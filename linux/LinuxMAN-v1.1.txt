                               -- Linux MAN --
                  Linux: Manual de Aprendizaje para Novatos
                                 Version 1.1
______________________________________________________________________________

Indice:

1)  Introduccion y notas del autor.
2)  Introduccion al sistema operativo (muy poco original).
3)  Comandos basicos y semejanzas con otros sistemas operativos.
    - 3.1 Comandos Basicos
    - 3.2 Usuarios, Grupos, Permisos y las Consolas Virtuales
    - 3.3 Multitareas
4)  Estructura de directorios. Archivos importantes.
    - 4.1 Directorios
5)  Sistema de booteo.
6)  Sistemas de archivos.
    - 6.1 Nociones principales
    - 6.2 Tipos de sistemas de archivo.
    - 6.3 Buscando errores.
7)  Utilizando el vi.
    - 7.1 Insertar y borrar texto en vi.
    - 7.2 Moverse por el vi.
    - 7.3 opciones del menu ':'.
8)  Nociones del autor.

______________________________________________________________________________

Esta nueva version del LinuxMAN no contiene nuevos capitulos sino que solo
se corregiran algunos errores y se tocaran algunos comandos y / o temas que
no se vieron en la version anterior del mismo documento. Muchas Gracias por
leer el LinuxMAN. Pueden encontrar siempre la ultima version del LinuxMAN en 
<http://www.proyectoslinux.cjb.net>.
______________________________________________________________________________


1) Introduccion y notas del autor.

     Esta es la segunda version (la primera fue LinuxMAN-v1.0) de este
pequenio manual para usuarios de Linux. Este manual esta pensado para los
recien iniciados y es solo una pequenia introduccion al mundo de los
sistemas de la familia UNIX. Este manual no tiene fines lucrativos y se
considera la posibilidad de la precesencia de errores gramaticales, etc.
Cualquier sugerencia y / o notificacion sobre las mismas puedes enviarla a
mi e-mail <daniel_w@flashmail.com>. 

2) Introduccion al sistema operativo (muy poco original).

     Linux es principalmente una de las tantas opciones de sistemas
operativos diseniados especialmente para trabajar en red. Es una plataforma
UNIX con un entorno un poco mas amigable, sin embargo, podriamos decir que a
pesar de algunas diferencias es casi un perfecto clon del mismo. Por eso,
este tutorial puede servir tambien no para iniciados en otras plataformas UNIX,
como por ejemplo, FreeBSD, SunSCO, Solaris, Minix, POSIX, entre otras.
     Linux es un sistema multiusuario, multitarea, y trabaja en 32 Bits
REALES a diferencia de otros sistemas como Microsoft Windows 95 / 98 que
dice hacerlo pero que en realidad trabajan a 16 Bits.
     Quiero hablar un poco sobre las ventajas de usar Linux. Hay muchas
cualidades que diferencian a Linux de otros Sistemas Operativos (SOs), pero
no voy a nombrarlas todas. Sus mas grandes ventajas las habran oido
seguramente en un canal de chat o en algun texto: Linux es reconocido por su
gran estabilidad, la excelente administracion de recursos que realiza el 
sistema y su open source (codigo abierto) porque el usuario tiene total 
libertad sobre el manejo y administracion del sistema. El kernel o nucleo de 
Linux se actualiza todo el tiempo, tapando viejos bugs o agujeros y ampliando 
la compatibilidad con diferentes dispositivos. El ultimo kernel puede 
conseguirse a traves de Internet en ftp.kernel.org o algunos de sus mirrors.
     Sobre la historia de Linux no puedo decir mucho, nunca me gusto' leer
sobre ese tema, y casi siempre omito la mayor parte de este cuando leo algun
texto referido al sistema, lo unico que puedo decirles, que seguro ya sabran
es que fue programado originalmente por Linus Torvalds que no me acuerdo
donde nacio' ni nada, pero lo que si se es que fue un capo. Despues se fue
mejorando con la ayuda de programadores y hackers de todo el mundo (o por lo 
menos asi lo tengo entendido).
     Otro tema que me gustaria conversar aprovechando este capitulo es
referido a los hackers. Es normal que muchos usuarios de Windows dejen
dicho sistema para acercarse a Linux, porque asi se lo recomendaron los
comunmente llamados Lamers, ya que es el SO que usan comunmente los hackers
(valga la rebundancia). Este ultimo dato puede que sea cierto, pero mas
cierto es que no cualquier persona es un hacker y no vamos a ser hackers
solo por ser usuarios de Linux. Si queremos usar linux hagamoslo por el solo
hecho de querer disfrutar de este grandioso SO y no para satisfacer un
suenio casi imposible. Espero que la gente tome nocion de ello.


3) Comandos basicos y semejanzas con otros sistemas operativos.

3.1 Comandos Basicos
--------------------
     Aunque muchos no lo crean, el llamado Microsoft DOS fue creado mucho
despues que UNIX, y esta basado en cierto modo, en este ultimo, es por eso
que los amantes o simplemente usuarios de DOS tendran cierta ventaja cuando
nos referimos a algunos (en realidad muy pocos) comandos de linux ya que son
similares al SO de Microsoft.
     Para saber cual es el contenido del directorio en el que estamos
situados existe el comando "ls" (list), aunque tambien podemos utilizar
alternativamente el tipico de DOS: "dir", aunque yo prefiero el primero por
ser mas corto. Estos comandos nos mostraran simplemente los nombres de los
archivos y directorios que se encuentran, como dije antes, en el directorio
en el que estemos situados. Por ejemplo: estamos situados en el directorio
raiz "/" (semejante a c:\ en DOS) y tenemos dentro de este los directorios
"linux", "mis archivos", "fotos" y "home" y ademas el archivo
"linuxfile". Entonces:

localhost:/# (este es el prompt y la / despues de : indica donde estamos
situados)

localhost:/# ls
linux	mis\ archivos	fotos	home	linuxfile
localhost:/#

     Esa seria la salida al comando "ls". Pero aqui no podemos diferenciar cual
es un archivo y cual un directorio. Para averiguar esto y otros datos sobre
los archivos y directorios el comando ls (asi como cualquier otro comando)
posee algunas opciones las cuales veremos ahora:
     "ls -F" definira' cuales de los nombres de la salida de arriba sera un
archivo, y cual un directorio. Los terminados con una barra (/) son los
directorios, los terminados con un asterisco (*) son archivos ejecutables, y
los que solo se les muestra el nombre son archivos de otro tipo, como por
ejemplo, de texto. Veamos un ejemplo:

localhost:/# ls -F
linux/	mis\ archivos/	fotos/	home/	linuxfile
localhost:/# 

     Hay otras opciones para el comando "ls" que iremos viendo conforme
tratemos temas referidos a su tipo de salida.

     El siguiente comando a tratar es el "cd" (change directory) que como su
nombre lo indica, sirve para movernos de un directorio a otro. Por ejemplo,
si nosotros estamos en el directorio raiz (/) y queremos entrar al
directorio "linux" que se encuentra en dicho directorio debemos tipear "cd"
mas el nombre del directorio al que querramos entrar:

localhost:/# cd linux
localhost:/linux#

     Como vimos en el ejemplo, el prompt nos muestra que luego de haber
ejecutado el comando "cd linux" pasamos a estar dentro de dicho directorio.
Pero el problema es como hacemos para volver un directorio mas abajo. Esto
es muy sencillo, ejecutamos el comando "cd .." el cual nos dirijira' al
directorio que contiene al directorio en el que estamos. (Igual que en DOS):

localhost:/linux# cd ..
localhost:/#

     Noten que los dos puntos ".." se encuentran separados del comando "cd
por un espacio, esto es porque si ponemos todo junto el comando sera
reconocido como un comando erroneo, ya que el sistema buscara' entre los
archivos ejecutables el comando "cd.." que por supuesto, no existe.

     Ahora puede que surja la posibilidad de que tengamos que copiar un
archivo que tenemos en un directorio por cualquier motivo que sea. Entonces
para ello se usa el comando "cp" (copiar). La sintaxis de este comando seria la
siguiente:

localhost:/# cp archivo.que.quiero.copiar dir_de_destino/

     Tambien podemos indicarle al comando "cp" que al copiar el archiv cambie 
su nombre agregando el nuevo nombre del archivo despues de la barra que marca
la carpeta de destino. En este caso la sintaxis seria:

localhost:/# cp archivo.que.quiero.copiar dir_de_destino/archivo.que.copie

     Si en vez de copiar solo un archivo queremos copiar muchos podemos
hacerlo solo agregando el nombre de cada archivo a copiar uno al lado del
otro separados por un espacio. Si queremos que se copien todos los archivos
que hay en el directorio podemos hacer directamente los siguiente:

localhost:/# cp * dir_de_destino/

     El asterisco abarca todos los archivos y directorios contenidos en el
directorio actual. Aca podemos encontrar un problema: los directorios no
pueden copiarse igual que los archivos. Para copiar todo un directorio
debemos agregar la opcion "-R" a continuacion del comando cp, de otra manera
Linux no copiara' ningun directorio:

localhost:/# cp -R * dir_de_destino/

     Pero si lo que queremos no es copiar un archivo o carpeta sino moverlo
de un lado al otro, entonces no podemos utilizar el comando cp (en realidad
podriamos copiar el archivo que necesitaramos mover a otra carpeta y despues
borrarlo de el directorio actual, pero eso no seria logico). Por lo
contrario el comando adecuado para esta operacion seria "mv" (move). La
sintaxis de este comando es similar a la de cp:

localhost:/# mv archivo.a.mover directorio_de_destino/

     Pero, en cambio, si queremos mover un directorio entero no nos servira'
la opcion "-R" como en cp, sino que deberemos agregar la linea "-f" para
forzar la mobilidad del directorio con todo su contenido. El comando "mv" no
solo sirve para mover archivos o directorios de un directorio a otro, sino
tambien para renombrarlos. Por ejemplo, si queresmos que el archivo
'archivo.a.copiar' se llame 'archivo.que.copiare' debemos usar la siguiente
linea de comando:

localhost:/# mv archivo.a.copiar archivo.que.copiare

     En muchas ocasiones hay programas, archivos o directorios que no nos
sirven y lo unico que hacen es ocupar espacio en nuestro escaso (o quiza no)
disco rigido. Si queremos eliminar estos archivos o directorios usamos el
comando "rm" (remove). Su sintaxis es similar a la del comando "cp" o "mv". 
Por ejemplo, si queremos borrar el archivo "viejo_y_nosirve.txt"
entonces la sintaxis sera' la siguiente:

localhost:/# rm viejo_y_nosirve.txt

     Al igual que con el comando "cp" si queremos borrar un directorio con
todos su contenido deberemos usar la siguiente sintaxis:

localhost:/# rm -R directorio_viejo/

     Dependiendo de la distribucion de Linux con la que estemos trabajando,
nos aparecera la pregunta de si queremos eliminar el archivo/directorio o
no. Pero por las dudas, antes de experimentar, tengamos cuidado y veamos lo
que estamos haciendo. Tambien podemos usar el comando "rmdir" para borrar un
directorio pero lo que hace a este comando poco eficiente es que el
directorio a eliminar debe estar completamente vacio. Este comando se
asemeja al comando "rd" de DOS para que tengan una idea.

     Si lo que queremos es crear un directorio entonces el comando que
debemos usar es "mkdir" y su sintaxis seria la siguiente:

localhost:/# mkdir directorio_a_crear
localhost:/#

     Aunque el sistema no nos muestre ninguna senial, el directorio fue
creado satisfactoriamente.

     Ahora, para visualizar un archivo, sin tener la posibilidad de
modificar su contenido podemos usar el comando "more" seguido del nombre del
archivo a visualizar. Por ejemplo, si queremos visualizar el contenido del
archivo "linux-release", por decir algun nombre, hacemos lo siguiente:

localhost:/# more linux-release
Slackware Linux 3.6 with kernel 2.2.13
localhost:/#

     Esa seria la salida del comando. Si el archivo a visualizar es muy
extenso y no alcanza a mostrarse enteramente en pantalla presionamos la
tecla "enter" (o intro) para avanzar; la tecla "b" retrocedera' una pagina
completa; la tecla "'" (apostrofe o tilde) volvera' al principio del documento
la tecla "h" para obtener ayuda; la tecla "=" nos dira' el numero de linea en
el que estamos situados; la tecla "!" abrira un subprompt para que podamos
ejecutar un comando sin salir del documento; la tecla "v" abrira dentro del
programa more el editor predeterminado de todo sistema Unix que es el VI; y
la tecla "q" sale del programa more. Para mas opciones importantes leer la
ayuda.

     El comando cat sirve para concatenar uno o varios archivos a la vez,
sin embargo, tambien se lo usa comunmente para visualizar el contenido de un
archivo de una sola vez, sin la posibilidad de volver hacia atras o de
examinar el archivo. Su sintaxis seria asi:

localhost:/# cat nombre.del.archivo
Aca se muestra el contenido del archivo.
localhost:/#

     Esa fue la salida del comando. Si a este comando le sumamos algunos
argumentos puede que sea de mas utilidad. Por ejemplo, el signo mayor (>)
despues antecedido por el comando cat y precedido por el nombre de algun
archivo que puede o no existir, hara' que se escriba en el archivo destino
lo que las siguientes lineas que nosotros escribamos mientras dure el
comando cat que interrumpiremos con la combinacion de las teclas CTRL D.
Esta seria la salida:

localhost:/# cat > archivo.destino
esto es un ejemplo
de la utilizacion del comando cat
aqui termina el ejemplo.
CTRL D
localhost:/#

     Ahora, si observamos el contenido del archivo "archivo.destino" pasara'
lo siguiente:

localhost:/# more archivo.destino
esto es un ejemplo
de la utilizacion del comando cat
aqui termina el ejemplo.
localhost:/#

     Los argumentos como los signos mayor (>), menor (<), doble mayor (>>) y
doble menor (<<) pueden ser combinados con otros comandos de los que ya
hemos hablado, por ejemplo:

localhost:/# ls > archivo.destino
localhost:/#

     Lo que paso' aqui es que toda la informacion que tendria que haber
dirigido el comando "ls" a la pantalla se guardo' en el archivo
"archivo.destino". El argumento ">>" hace lo mismo que el ">" pero la unica
diferencia entre ambos es que si el 'archivo.destino' ya contiene informacion
adentro el >> escribira' la salida del comando ls al final del archivo, en
cambio el > reescribira' el archivo completo y se perdera' toda la
informacion que este contenia anteriormente.

     Hay una una manera de combinar dos comandos para obtener una salida
diferente a su salida estandar utilizando la tecla "|". Por ejemplo, si yo
hago un ls y su salida ocupa mayor tamanio que lo que puede mostrar la
pantalla entonces no podre' ver el contenido total de todo un directorio,
pero si yo combino el comando "ls" con el comando "more" entonces la salida
sera' similar a visualizar un archivo con el programa more:

localhost:/# ls | more
archivo1
archivo2
archivo3
archivo4
--More--

     Asi seria mas o menos la salida, y cuando apretemos el boton enter se
seguiran mostrando los demas archivos o directorios contenidos en el
directorio actual.
     Tambien podemos combinar el comando "ls" con el comando "sort" que
ordenara' alfabeticamente la lista a mostrar:

localhost:/# ls | sort
archivo1
archivo3
fotos
home
linux
mis\ archivos
localhost:/#

     Tambien podemos combinar una o mas tareas para que se realicen una
detras de la otra escribiendolas en una sola linea y separando cada comando
con sus respectivos argumentos y / o opciones con un punto y coma ';'. Por
ejemplo:

localhost:/# more archivo.txt ; ls ; cd /root
-----------
archivo.txt
-----------
Esto es lo primero que pasa...
archivo1
archivo3
fotos
home
linux
mis\ archivos
localhost:/root#

     Como vemos aca, se ejecutaron todos los comandos uno detras de otro
como los habiamos dicho y no aparecio' en ningun momento intermedio el
prompt.

     Para tener un acceso mas agil y rapido a ciertos archivos o directorios
podemos crear vinculos a ellos. Estos vinculos pueden ser tanto simbolicos
como duros. Para crear un vinculo de otro directorio o archivo se utiliza el
comando 'ln'. Su sintaxis serial el comando 'ln' seguido del archivo que
queremos vincular (archivo original) y a continuacion el nombre y ubicacion
del vinculo. Usamos los vinculos simbolicos para vincular directorios y los
vinculos duros para vincular archivos ejecutables. Veamos un ejemplo:

localhost:/# ls -F
archivo1*
archivo3*
directorio1/
directorio2/
localhost:/# ln -s directorio1 /usr/local/directorio1
localhost:/# ln -n archivo1 /usr/bin

     Hay veces que necesitamos buscar un archivo que contiene una
informacion especifica que necesitamos y no sabemos con que nombre lo
habiamos guardado. En estos casos el comando 'grep' nos ayudara' bastante.
Este comando se encarga de buscar una patron dentro de los archivos que
especifiquemos, por ejemplo, yo quiero buscar un archivo que contenga las
palabras 'Daniel Wyrytowski'. La sintaxis de este comando es : 
grep [opciones] patron de busqueda [donde buscar]
Por ejemplo:

localhost:/# grep Daniel /root/*
/root/LinuxMAN-v1.1:Copyright (C) 1999  Daniel Wyrytowski
localhost:/#

Como vemos aca nos esta mostrando toda la linea que contiene las palabras
'Daniel' y si observamos mas claramente tambien nos dice (al principio) en que
archivo esta, en este caso se encuentra en el archivo /root/LinuxMAN-v1.1

     Otros comandos muy utiles dentro de linux son 'du' y 'df'. Estos
comandos nos dan informacion de la cantidad de espacio libre o utilizado en
el sistema. Veamos cada uno de ellos.

El comando 'du': da informacion de el espacio que utiliza un directorio o un
rango de directorios. Su sintaxis es : 'du [opciones] directorios'

localhost:/# du -s /usr
551088  /usr
localhost:/# 

Como vemos, el comando nos devolvio' la cantidad de kilobytes que contiene
el directorio '/usr'. La opcion '-s' hace un resumen de todo mostrandonos el
resultado final de la cuenta en vez de mostrarnos lo que ocupa cada uno de
los directorios que contiene el directorio '/usr'.

El comando 'df': da informacion de el espacio utilizado y disponible en un
sistema de archivos siempre y cuando estos esten montados. Sobre como montar
o desmontar sistemas de archivos se vera' en el Capitulo 6.
Por ejemplo:

localhost:/# df 
Filesystem         1024-blocks  Used Available Capacity Mounted on
/dev/hda1            1016376  733355   230506     76%   /
/dev/hda2             934629  368684   517662     42%   /mnt
localhost:/#

     Otro comando muy util es el 'w'. Este comando muestra quienes estan
logueados en el sistema y que es lo que cada uno de estos usuarios estan
haciendo. Veamos un ejemplo:

localhost:/# w
  3:37pm  up  1:13,  3 users,  load average: 0.00, 0.04, 0.03
USER     TTY      FROM       LOGIN@   IDLE   JCPU   PCPU  WHAT
root     tty1                3:19pm  0.00s  0.84s  0.03s  w
root     tty2                3:28pm  1:37   1.50s  1.39s  joe LinuxMAN-v1.1
root     tty3                3:32pm  5:19   0.10s  0.10s -bash
localhost:/#

Como vemos, la salida se explica por si sola asi que solo dare' una
explicacion muy por arriba. La primera columna muestra el nombre del usuario
logueado. La segunda muestra en que consola virtual se encuentra. La tercer
columna muestra el host remoto. La columna cuarta muestra a que hora se ha logueado en el
sistema dicho usuario. La quinta muestra el tiempo IDLE. La cuarta muestra
muestra el JCPU time que es el tiempo que utilizan todos los procesos
adjuntos a las consolas virtuales. La sexta muestra el PCPU time que es el
tiempo que utiliza el proceso que esta marcado en la columna numero 7. En la
columna numero siete muestra el proceso que esta ejecutando el usuario
(generalmente el ultimo proceso).

3.2 Usuarios, Grupos, Permisos y Consolas Virtuales
---------------------------------------------------

     Como dije antes, Linux es un sistema multiusuario. La maquina que posee
el sistema que sirve a los demas usuarios se llama Host.
     Una posibilidad de entrada de diferentes usuarios al mismo sistema es por
medio de las consolas virtuales. La tecla ALT combinada con las teclas que
van desde el F1 hasta el F6 habren una nueva consola en la que puede
loguearse (entrar) un nuevo usuario. 
     Hay diferentes tipos de usuario, entre los que distinguimos los dos
tipos mas importantes: Los administradores y los usuarios comunes. El
usuario administrador (root) tiene un completo control sobre el sistema, el
puede guardar, configurar, borrar, o hacer lo que quiera con lo que haya
dentro del sistema. Un usuario comun, en cambio, solo puede manejarse con
limitados recursos dentro del mismo sistema, esto es porque hay informacion
y cosas que dichos usuarios no deben tener a su alcance por medidas de
seguridad. Imaginense que un usuario pueda tener acceso al directorio /etc
que es donde se guarda toda la informacion de configuracion del sistema,
podria causar un desastre, podria cambiar la contrasenia del root y dejar a
este sin acceso momentaneamente, y eso es solo un ejemplo, hay cosas mucho
peores que podria hacer, pero eso no viene al caso ahora.
     El problema ahora es como hacer para restringir el acceso de ciertos
usuarios a algunos archivos o directorios. Para ello hay que cambiar los
permisos de cada archivo al que no queramos que dichos usuarios tengan
acceso o al directorio que los contenga. Los permisos son justamente lo que
la palabra indica: la autoridad que se puede ejercer ante un archivo o
directorio, o ante otro. Para ver cuales son los permisos de cada
archivo/directorio debemos ejecutar el comando "ls" con el argumento "-l".
La salida a este comando seria la siguiente:

localhost:/# ls -l
-rwxr-xr-x   3 root     root         1024 Oct 14 15:44 archivo.de.prueba
localhost:/# 

     Por el momento solo prestaremos atencion a los primeros tres
parametros. Paso a explicar el primero (drwxr-xr-x). Estos son los permisos
del archivo que estamos mirando. Entendemos esta linea de la siguiente
manera: los primeros 4 parametros corresponden al duenio del archivo; los
siguientes 3 parametros corresponden al grupo/s de usuario al que pertenece
el usuario duenio del archivo; y los ultimos tres parametros corresponden a
cualquier otro usuario. Las letras significan el tipo de permiso que cada
usuario o grupo tiene al archivo. La letra "r" quiere decir que el usuario
solo tendra' la posibilidad de leer el contenido del archivo, pero no
modificarlo ni ejecutarlo. La letra "w" le da al usuario permiso de
escritura, es decir que el usuario tiene la posibilidad de modificar de
cualquier manera el archivo o directorio. La letra "x" le da al usuario la
posibilidad de ejecutar el archivo o directorio al que nos refiramos, con
ejecutar un directorio entendemos que podemos acceder a el. Veamos ahora un
par de ejemplos para que nos vayamos familiarizando con los permisos:

 ----|---|---  
  U    G   O

U corresponde al duenio del archivo
G corresopnde al grupo
O correponde a los (O)tros usuarios

-rwx------ ==> esto significa que el duenio del archivo/directorio podra'
leer el contenido (r), modificar (w) y ejecutar (x) el mismo. Los demas
usuarios o participantes del mismo grupo no podran hacer nada con el
archivo.

-rwx--x--x ==> estos permisos significan que tanto el duenio, como el grupo
y los demas usuarios pueden ejecutar el archivo al que se refieren. Ademas
el duenio tambien puede leer y escribir el mismo archivo.

     Bueno, creo que esta parte del tema ya habra' quedado bastante claro
asi que paso a explicar como cambiar los permisos de cada archivo o
directorio. Notificamos que los permisos pueden ser cambiados solamente por
el usuario root o por el duenio. Para tener una nocion de como cambiar los
permisos debemos tener en cuenta la tabla que hice un poco mas arriba donde
se muestran a que correponden las letras U, G, O. El comando correspondiente
para cambiar los permisos de un archivo o directorio es "chmod". Su sintaxis
es chmod opciones archivo:

localhost:/# ls -l
-rwxr-xr-x   3 root     root         1024 Oct 14 15:44 archivo.de.prueba
localhost:/# chmod u-x archivo.de.prueba (quita el permiso de ejecucion para
el duenio del archivo)
localhost:/# ls -l
-rwr-xr-x   3 root     root         1024 Oct 14 15:44 archivo.de.prueba
localhost:/#

     Como vemos arriba, chmod combinado con una de las letras indicadas en
la tabla ya mencionada (u, g, o) seguida del los signos '+' (dar) o '-'
quitar y seguido por el tipo de permiso (r, w, x) cambia los permisos del
archivo que queramos. Entonces:

'chmod o-x archivo' cambiara' -rwxr-xr-x >> -rwxr-xr--
'chmod o+w archivo' cambiara' -rwxr-xr-x >> -rwxr-xrwx
'chmod g+w archivo' cambiara' -rwxr-xr-x >> -rwxrwxr-x

Asi podemos hacer tambien muchas otras combinaciones.

     Ahora que ya sabemos cambiar los permisos seria bueno saber como
cambiar los duenios de los archivos o directorios, ya que de nada nos sirve
que todos pertenezcan a un mismo usuario. Para saber quien es el propietario
y el grupo de un archivo o directorio debemos observar el segundo y el tercer 
parametro del comando 'ls -l' respectivamente: 
-rwr-xr-x   3 root     root         1024 Oct 14 15:44 archivo.de.prueba
              ----     ----
              duenio   grupo

     El comando apropiado para cambiar tanto el duenio como el grupo de cada
archivo o directorio es 'chown'. Su sintaxis es 'chown usuario.grupo
archivo'. Veamos un ejemplo:

> Si yo quiero cambiar el duenio del archivo.de.prueba a el del usuario
linuxero entonces pero quiero que el grupo siga siendo el mismo entonces
debere' hacer:

localhost:/# chown linuxero archivo.de.prueba
localhost:/#

> Si en cambio, yo quiero cambiar tanto el usuario (a linuxero) como el grupo
(a linuxgroup) del archivo.de.prueba entonces:

localhost:/# chown linuxero.linuxgroup archivo.de.prueba
localhost:/# 
Ahora hacemos un ls -l para ver como quedaron los propiedades
localhost:/# ls -l
-rwr-xr-x   3 linuxero   linuxgroup     1024 Oct 14 15:44 archivo.de.prueba
localhost:/#

     Ahora que ya sabemos manejarlos con los atributos de los archivos y
directorios con respecto a los usuarios, veamos como crear un nuevo usuario
en el sistema.
     Hay dos maneras diferentes de crear un nuevo usuario: una es usando el
programa 'useradd' y la otra el crearlo manualmente. Yo, por mi cuenta,
prefiero la segunda.
     Primero y empezando, sabemos que cada usuario tiene sus propios
programas, su propio espacio ya designado, su password o contrasenia y otros
datos mas que el sistema debera' tener en cuenta cuando trate de ingresar un
nuevo usuario a este. Todos estos datos estan guardados en el archivo
'passwd' que esta en el directorio /etc. Veamos como esta compuesto este
archivo.

localhost:/# more /etc/passwd
operator:x:11:0:operator:/root:/bin/bash
localhost:/#

     Esta simple linea da al sistema toda la informacion que necesite para
que el usuario pueda entrar tranquilamente. Analizemos esa linea:

operator  x  11  0  operator  /root  /bin/bash
--------  -  --  -  --------  -----  ---------
   1      2   3  4     5        6        7

1: nombre del usuario
2: aqui se encuentra el password (generalmente encriptado).
3: numero de identificacion del usuario UID, (user id).
4: numero de identificacion del grupo al que pertenece, GID (group id)
5: el verdadero nombre del usuario
6: directorio home del usuario. Este es el directorio donde aparecera' el
usuario apenas se loguee. Es el unico directorio donde los usuarios comunes
podran grabar cosas.
7: interprete de comandos. Ejecuta las instrucciones que recibe desde es
teclado. Es similar al command.com en MSDOS. En los sistemas UNIX existe mas
de un interprete de comandos, el mas comun es bash (bourne shell).

     Ahora que sabemos como configurar un usuario nuevo lo unico que debemos
hacer es agregar la linea que definira' al nuevo usuario y todas sus
caracteristicas dentro del archivo 'passwd'. Entonces:

localhost:/# cat >> /etc/passwd
linuxero::1001:100:usuario:/home/usuario:/bin/bash
CTRL D
localhost:/#

     Eso agregara' al final del archivo passwd la linea con todos los datos del
usuario. Tambien podrimos haber editado el archivo con un editor pero yo
preferi' hacerlo de esta manera, ademas todavia no mostre' como utilizar el
editor de textos principal del linux. Ahora paso a explicar la linea que
agregamos el archivo /etc/passwd:

linuxero::1001:100:usuario:/home/usuario:/bin/bash

El primer argumento es el nombre con el que entrara' al sistema el usuario.
El segundo argumento lo deje' en blanco (::) porque todavia no especifique'
el password ya que no se puede hacer directamente editando el archivo, sino
que hay que utilizar el comando 'passwd' seguido del nombre del usuario.
Esto dara' una salida mas o menos asi:

localhost:/# passwd linuxero
Changing password for netgod
Enter the new password (minimum of 5, maximum of 8 characters)
Please use a combination of upper and lower case letters and numbers.
New password: (aqui escribimos el password del usuario aunque el sistema no
nos lo mostrara' mientras lo hacemos por motivos de seguridad)
Re-enter new password: (aqui debemos escribir denuevo el password para
asegurarnos de que no haya confusiones)

     El tercer argumento es el UID (ver mas arriba) del usuario. No es
recomendable que un usuario comun tenga un UID menor a 1000.
     El cuarto argumento es el GID del usuario. En este caso es el numero 100
que generalmente corresponde al grupo llamado users.
     El quinto argumento es el verdadero nombre del usuario, en este caso no
quise poner mi verdadero nombre asi que solo lo reemplace' por el nombre
'usuario'.
     El sexto argumento corresponde al home directory del usuario. Este es el
unico directorio donde el usuario podra guardar sus programas, etc.
     El septimo y ultimo argumento es el interprete de comandos que utilizara' el
usuario. Aunque en este caso el el bash, tambien podria haber elegido el zch
o el tcsh.
     Ahora que ya tenemos creado el usuario necesitaremos crear el
directorio donde se alojara' (/home/usuario), darle la propiedad de este y
cambiar sus permisos para que nadie mas pueda revolver entre sus cosas.

localhost:/# mkdir /home/usuario (creo el directorio)
localhost:/# cd /home (entro al directorio home donde se aloja el
subdirectorio 'usuario')
localhost:/# chown linuxero usuario
localhost:/# chmod u+xwr usuario
localhost:/# chmod go-xwr usuario
localhost:/#

     Bueno, ya hemos creado el nuevo usuario, el cual podra' entrar al
sistema por ftp, telnet, o por una consola virtual directamente y que
tendra' acceso a limitados programas y recursos dentro del sistema. Siempre
es bueno tener un usuario comun ademas del root para poder evitar loguearnos
(entrar) como administrador asi no hacemos desastres.

3.3 Multitareas
---------------
     Como dije en un principio, Linux es un sistema multitarea, aunque no se
parece en nada al sistema de ventanas de cualquier entorno grafico. Linux es
capaz de correr mas de un programa a la vez pero no es posible que tengamos
todos los programas corriendo a la vista al mismo tiempo. Linux puede hacer
correr un programa en segundo plano mientras que corre uno en un primer
plano. Por ejemplo, yo puedo dejar un programa compilandose en segundo plano
mientras que tengo el cliente de IRC andando en primer plano, ya que no
necesito ver cuando se esta compilando el programa.
     Dejar un programa corriendo en segundo plano no es nada del otro mundo,
es mas, es realmente una pabada. Para dejar un trabajo en segundo plano
debemos simplemente agregar el signo '&' luego del nombre del programa que
querramos dejar andando. Por ejemplo, si yo quiero buscar un archivo en todo
el disco y que la salida se grabe en el archivo 'encontrados' pero no quiero
esperar a que termine de buscar el archivo para usar otro programa debere'
hacer lo siguiente:

localhost:/# find / -name *.conf > encontrados &
[1] 189
localhost:/#

La linea que se muestra luego de ejecutar el comando nos indica que el
proceso es el unico comando que se esta corriendo y por eso se le asigna el
numero 1, pero el numero 189 se refiere al numero de proceso, o PID (Process
Identificator). Para ver todos los procesos que se estan corriendo (no los
comandos) se utiliza el comando 'ps'. Para ver, en cambio, solo los comandos
que se estan corriendo en segundo plano debemos ejecutar el comando 'jobs'.
Veamos ahora unos ejemplos:

localhost:/# ps
  PID TTY STAT TIME COMMAND
  109   1 S    0:00 -bash
  110   2 S    0:00 -bash
  111   3 S    0:00 /sbin/agetty 38400 tty3 linux
  112   4 S    0:00 /sbin/agetty 38400 tty4 linux
  113   5 S    0:00 /sbin/agetty 38400 tty5 linux
  114   6 S    0:00 /sbin/agetty 38400 tty6 linux
  189   1 S    0:00 find / -name *.conf > encontrados
  396   2 R    0:00 ps
localhost:/#

Como vemos aqui, todos los procesos que se estan corriendo tiene un PID.
Ahora veamos los comandos que se estan corriendo

localhost:/# jobs
[1]+  Running                 find / -name *.conf > encontrados
localhost:/#

     Ahora, si yo quiero matar el comando find, porque me equivoque en el
nombre del archivo que quiero que guarde los resultados debere' poner el
comando en primer plano y matarlo con la combinacion de teclas CTRL C. El
comando 'fg' pondra' el comando en primer plano.

localhost:/# fg
find / -name *.conf > encontrados
CTRL C
localhost:/#

     Como vemos aca, al ejecutar el comando 'fg' el trabajo que estaba
ejecutandose en segundo plano paso' a estar en primero de nuevo, y cuando
apretamos la combinacion de teclas CTRL C interrumpimos el programa.
     Pero, que pasaria si yo estoy ejecutando un programa en primer plano y
de repente me acuerdo que tengo que realizar un trabajo para el colegio???
No es necesario que habra otra consola virtual para ejecutar otro programa.
Puedo frenar el programa (no interrumpirlo) y darle la instruccion de que se
siga ejecutando pero desde este momento en segundo plano. Para frenar el
programa necesitare' utilizar la combinacion de teclas CTRL Z y luego
ejecutar el comando 'bg' que le dira' al programa que esta' frenado que siga
ejecutandose en segundo plano. Veamos como es la cosa:

localhost:/# find / -name *.conf > encontrados
CTRL Z
[1]+  Stopped                 find / -name *.conf > encontrados
localhost:/# bg
[1]+ find / -name *.conf > encontrados &
localhost:/#

     El problema con los comandos 'fg' y 'bg' es que siempre actuan sobre
los ultimos comandos ejecutados, asi que si queremos referirnos a un comando
que esta en ejecucion especifico debemos identificarlo con la combinacion
'%' seguido del numero que se le haya asignado al comando (no el PID, sino
el otro). Veamos el ejemplo:

localhost:/# find / -name *.conf > encontrados &
[1] 189
localhost:/# find / -name *.xpm > encontrados1 &
[2] 189
localhost:/# fg % 2
find / -name *.xpm > encontrados1

     Eso fue todo con respecto a las multitareas. Ahora pasemos al siguiente
punto.


4) Estructura de directorios. Archivos importantes.

     Aunque haya diferentes distribuciones y cada una traiga sus programas,
etc. la estructura basica de directorios y archivos es mas o menos las misma
en todas:
 
/ -|--> bin
   |--> boot
   |--> dev
   |--> etc
   |--> home
   |--> lib
   |--> mnt
   |--> proc
   |--> root
   |--> sbin
   |--> tmp
   |--> usr -|--> X11
   |         |--> bin
   |         |--> etc
   |         |--> include
   |         |--> lib
   |         |--> local -|--> bin
   |         |           |--> etc
   |         |           |--> lib
   |         |--> man
   |         |--> src --> linux
   |         |--> tmp
   |
   |--> var --> adm
          

     El arbol que observamos arriba muestra un tipico arbol de directorios
comun en linux. Pueden variar sin embargo, algunos de los nombres
dependiendo de la distribucion o version del Linux que estemos usando, pero
basicamente esta es correcta.

4.1 Directorios:
----------------

/bin: es la abreviacion de la palabra binaries (del ingles ejecutables).
Aqui se guardan muchos de los programas basicos y escenciales para el
funcionamiento del sistema como los comandos basicos (ls, cp, etc)

/dev: viene del ingles 'device' (dispositivo). Aqui se guardan los
controladores de dispositivos. Se usan para acceder a los dispositivos del
sistema y a sus recursos como discos rigidos, modems, memoria, mouse, etc.
Hay diferentes nombres con los que se identifica a cada dispositivo: los
archivos que empiezan con las letras 'hd'se refieren a los discos rigidos
IDE que hay en el ordenador. 

Dispositivos:
-------------
hd: hda1 sera' el disco rigido IDE (hd), primario (a), y la primera 
particion (1). 

fd: Asi tambien, los archivos que empiecen con las letras 'fd' se referiran a los 
controladores de las disqueteras: fd0 seria la primera disquetera fd1 seria 
la segunda (b: en MSDOS) y asi sucesivamente. 

ttyS - cua: Los dispositivos ttyS y cua se usan para acceder a los puertos serie como 
por ejemplo, ttyS0 seria el puerto com1 en MSDOS. Los dispositivos cua son 
'callout' por eso se usan en conjuncion con el modem.

sd: son los dispositivos SCSI. Su uso es muy parecido al del hd.

lp: son los puertos paralelos. lp0 equivale a LPT1 en MSDOS y asi
sucesivamente.

null: este es usado como un agujero negro, ya que todo lo que se dirige alli
desaparece. Nunca le encontre' hasta ahora, una buena utilidad, pero existe
y espero que ustedes si puedan encontrarsela.

tty: Los tty hacen referencia a cada una de las consolas virtuales. Como es
de suponerse, tty1 sera' la primera consola virtual, tty2 la segunda, etc.

pty: son pseudo terminales. Es decir, proporcionan una terminal a sesiones
remotas, esto quiere decir que si la maquina esta conectada en red
cualquiera que telnetee para entrar al sistema usara uno de estos
dispositivos.

sndstat: es el dispositivo de sonido instalado en el sistema. Si hacemos
'cat /dev/sndstat' saldra' toda la informacion acerca del dispositivo.

Esos son los dispositivos mas importantes (por lo menos para mi). Cuando
tengan un poco mas de experiencia iran, seguramente, descubriendo para que
sirven los demas dispositivos.

/etc: Aqui se guardan muchos de los archivos de configuracion del sistema,
y de los programas, por ejemplo: /etc/passwd guarda informacion de cada uno
de los usuarios como por ejemplo el directorio de inicio del usuario, el
interprete de comandos que usara', su UID, GID, etc.

/sbin: aqui, al igual que en bin se guardan muchos programas que son solo
usados por el administrador del sistema, por ejemplo: el comando exit, el
comando halt, el comando reboot, etc.

/home: aqui se encuentran generalmente los directorios de inicio (home
directory) de los distintos usuarios. Aunque no es obligatorio esto, se usa
ya por costumbre para ello.

/lib: aca estan las imagenes de las librerias compartidas. Estos archivos
son usados por muchos programas y se guardan aqui para que cada programa no
tenga que tener cada rutina en sus ejecutables. Esto ahorra espacio en
disco.

/proc: es un sistema de archivo virtual. Contiene archivos que residen en
memoria pero no el disco rigido. Hace referencia a los programas que se
estan corriendo en el momento en el sistema.

/tmp: al igual que en el popular sistema operativo de microsoft, en el
directorio tmp se guardan archivos de caracter temporal, es decir, si un
programa necesita mantener cierta informacion guardada, pero que no sera'
necesaria en otro momento, guardara' esa informacion en el directorio tmp
que se vaciara' en cuanto el sistema sea reiniciado.

/usr: Este directorio es muy importante porque contiene mas subdirectorios
que contienen a su vez, muchos archivos importantes, programas, y archivos
de configuracion del sistema.
     La mayoria de las cosas que hay en el directorio usr son opcionales, es
decir, el sistema no las necesita para funcionar correctamente.

/usr/X11: contiene el sistema X window (no windows) que es el entorno
grafico de los sitemas UNIX. El X windows, al igual que el entorno de
Micorsoft Windows se maneja con ventanas y programas graficos, por llamarlos
de alguna manera.

/usr/bin: contiene otros programas que no se encuentran en el directorio
/bin.

/usr/etc: Tiene algunos archivos de configuracion y programas del sistema.
Estos archivos, a diferencia de los del directorio /etc no son escenciales
para el correcto funcionamiento del sistema, aunque puede que algunos si lo
sean.

/usr/include: contiene archivos que utiliza el compilador de C. Son
escenciales para compilar casi cualquier programa hecho en C.

/usr/lib: contiene las librerias equivalentes 'stub' y 'static' a los
archivos de /lib. Muchos programas, ademas, guardan archivos de
configuracion en /usr/lib.

/usr/local: contiene al igual que /usr una gran cantidad de programas. Este
directorio difiere mucho entre cada sistema UNIX.

/usr/man: aqui se encuentran la mayoria de las paginas del manual de cada
program. Para acceder a los manuales se utiliza el comando man seguido del
nombre del programa. Por ejemplo: 

localhost:/# man ls 
mostrara' las paginas del manual del mismo comando.

Si el manual que buscamos no esta instalado entonces veremos la salida:

localhost:/# man lss
No manual entry for lss
localhost:/#

/usr/src: contiene el codigo fuente (programas por compilar) de muchos
programas. 

/usr/src/linux: contiene el codigo fuente del nucleo, que puede ser
recompilado nuevamente por el administrador. (no aconsejable para usuarios
inexpertos, como yo por ejemplo).

/var: aqui estan los programas que cambian de vez en cuando o a menudo de
tamanio. 

/var/adm: contiene archivos que son de incumbencia ara el administrador del
sistema, mas que nada historicos, donde se loguea (graba) todos los errores,
entradas, salidas, etc.

5) Sistema de booteo.

     El sistema de booteo (inicio) de linux cumple un cierto orden donde
primero se carga el kernel o nucleo del sistema, luego de esto se carga el
programa init que pone en funcionamiento el archivo inittab despues se cargan 
todos los modulos, dispositivos, demonios (programas residentes), etc. y una 
vez concluido esto, podemos pasar a loguearnos en el sistema.
     Una vez que el kernel termina de cargarse se ejecuta el programa INIT
que carga uno de los archivos mas importantes para el inicio, que indica a su
vez a otros archivos a cargarse para que pongan en marcha los distintos 
programas en memoria, monten las unidades correspondientes, etc. Este archivo
se llama inittab y reside en el directorio /etc. Este archivo describe que 
procesos son inicializados en el booteo y durante las operaciones normales.
InitTab distingue multiples run-level, los cuales tienen cada uno sus 
procesos a inicializar. Hay run-levels validos del 0 al 6. Paso a explicar 
para que sirve cada uno de ellos. 
     El run-level '1' inicia el sistema en modo 'monousuario'. El modo
'monousuario' no puede usarse para muchas cosas en mi opinion, pero podemos
utilizarla si en algun momento perdemos por casualidad la contrasenia.
Cuando iniciamos en modo monousuario no se cargan muchos de los demonios y
programas que se cargarian cuando entramos normalmente en modo
multiusuario.
     El run-level '2' inicia el sistema en modo multiusuario sin soporte para
NFS (Network File Sistem o Sistema de Archivos de Red).
     El run-level '3' inicia el sistema en modo multiusuario. Este es el
run-level mas comun, ya que al instalarse linux es generalmente el run-level
por defecto.
     El run-level '4' inicia el sistema directamente en el administrador de
ventanas Xwindow. Este run-level es muy practico para los que acostumbran a
trabajar todo el tiempo en Xwindow y no utilizan la consola casi nunca,
pero aclaro que yo no le encuentro mucho sentido a ello. Dependiendo de la
distribucion de linux que estemos usando el numero de este run-level puede
variar entre '4' y '5'. Por ejemplo, yo uso Slackware Linux 3.6 y el
run-level que inicia el sistema en modo de ventanas es el '4', pero la
distribucion Red Hat Linux utiliza el numero '5'. El numero '4' en cambio en
Red Hat Linux no tiene ningun uso.
     Los run-levels '0' y '6', a diferencia de los otros run-levels son
utilizados por el sistema en el momento de apagar el sistem. El run level
'0' utiliza cuando se desea apagar el sistema definitivamente, sin
intenciones de reiniciar, a este proceso se le conoce como 'halt'. El
run-level '6' se utiliza, sin embargo, al momento de reiniciar el sistema.
Estos dos run-levels dan instrucciones al sistema de que hacer antes de
apagarlo o reiniciarlo, como descomprimir unidades, matar procesos, etc.
     Veamos como hacer para decidir cual sera' el run-level por defecto en
nuestro sistema. El archivo 'inittab' en la parte donde se define cual sera'
el run-level que se cargara' cada vez que iniciemos la maquina se vera' asi
mas o menos:

localhost:/# more /etc/inittab
# Default runlevel.
id:3:initdefault:
localhost:/#

     Para cambiar el run-level por defecto solo debemos cambiar el numero
que aparece entre 'id:' y ':initdefault:' por el modo que nosotros
querramos. Por ejemplo:

id:4:initdefault: (iniciara' en modo de ventanas).

     Si tenemos instalado el administrador de booteo Lilo (Linux Loader) en
nuestro sistema podemos iniciar en el modo que querramos al momento de
elejir que sistema se iniciara' agregando el numero del run-level que
querramos precedido por el nombre con que identifica el Lilo a Linux. Veamos
un ejemplo:

Welcome to the LILO Boot Loader!

Please enter the name of the partition you would like to boot
at the prompt below.  The choices are:

Linux  - Linux (ext2fs partition)

Windows  - Windows (vfat partition)

Lilo Boot: Linux 1

     Esto iniciara' el sistema en modo monousuario. Si en cambio ponemos
solo 'Linux' el sistema se iniciara' en el modo predeterminado.

     Despues del 'initdefault' el archivo 'inittab' decidira' que archivos
se cargaran con respecto al run-level que se correra' y los archivos
necesarios para la iniciacion y halting o reinicio del sistema. Veamos las
siguientes lineas del archivo (solo las mas importantes):

localhost:/# more /etc/inittab
# Run level por defecto
id:3:initdefault:

# Inicializacion del sistema (cuando el sistema bootea)
si:S:sysinit:/etc/rc.d/rc.S

# Este archivo se corre cuando se inicia en modo monousuario
su:1S:wait:/etc/rc.d/rc.K

# Este Archivo se corre cuando se carga en multiusuario.
rc:2345:wait:/etc/rc.d/rc.M

# El runlevel 0 apaga el sistema
l0:0:wait:/etc/rc.d/rc.0

# El runlevel 6 reinicia el sistema
l6:6:wait:/etc/rc.d/rc.6

# Abre los puertos tty que se definan
c1:1235:respawn:/sbin/agetty 38400 tty1 linux
c2:1235:respawn:/sbin/agetty 38400 tty2 linux
c3:1235:respawn:/sbin/agetty 38400 tty3 linux
c4:1235:respawn:/sbin/agetty 38400 tty4 linux
c5:1235:respawn:/sbin/agetty 38400 tty5 linux

# Abre al menos una consola al iniciar en runlevel 4 por si por alguna razon
# falla el sistema de ventanas.
x1:4:wait:/etc/rc.d/rc.4

localhost:/#

     Ahi ya esta la explicacion de cada parte del archivo inittab. Veamos
ahora los demas archivos de inicio.
     Los siguientes archivos no los explicare' en su totalidad linea por
linea ya que cada uno de ellos es muy extenso y ademas creo que hay muchas
cosas que yo todavia no se de ellos asi que no deseo hablar de mas para no
mandarme macanas.

     El primer archivo a examinar es el 'rc.S'. Este archivo primero activa
todas las particiones y/o directorios de intercambio (swaps). Luego el
sistema examinara' la particion primaria de linux para comprobar errores y
si se ha cerrado correctamente o no el sistema la ultima vez que fue usado.
Si hay algun error el sistema nos avisara' y nos dira' que es lo que podemos
hacer al respecto. Este archivo, como ya vimos antes, esta especificado en
el archivo inittab y es el primero en correrse. Este archivo recide en el
directorio '/etc/rc.d' (o '/etc/init.d' en algunas distribuciones).

     El siguiente archivo tambien esta especificado en el inittab y es el
'rc.K'. Este archivo, como ya esta explicado anteriormente se carga cuando
iniciamos en modo monousuario. Este archivo mata desde un principio todos
los demonios y prepara el sistema para que solo pueda entrar un usuario.
Tambien anula todas las cuentas (usuarios).

     El archivo rc.M se carga al iniciar en cualquiera de los modos
multiusuario (2, 3 y 4). Este archivo arranca todos los demonios que esten
especificados y a su vez llama a otros archivos para que carguen sus
programas correspondientes. Entre estos archivos encontramos: rc.local,
rc.modules, rc.cdrom, rc.inet1, rc.inet2, rc.font, rc.httpd, rc.keymap.

     El archivo rc.local corre todos los programas que nosotros le
especifiquemos al momento de iniciar el sistema. Generalmente encontraremos
una linea que habilita el mouse.

     El archivo rc.cdrom busca en la unidad de cdrom si encuentra algun
disco, si lo encuentra lo montara' en el directorio que este especificado.

     El archivo rc.inet1 inicia el sistema de red. Configura el dispositivo
loopback, las rutas, las IPs, la mascara de red, la Gateway, etc.

     El archivo rc.inet2 inicia el completo sistema de red, asi como los
demonios que correspondan al trabajo en red. Tambien configura la discos de
NFS.

     El archivo rc.font define el tipo de letra o fuente que se utilizara'.

     El archivo rc.httpd inicia la configuracion del servidor de paginas
Apache.

     El archivo rc.keymap inicializa el mapa de caracteres.

     El archivo rc.modules carga los drivers extra en el kernel de linux.
Los modulos son buscados generalmente en /lib/modules/(numero de version del
kernel).

     Dependiendo de la distribucion que usemos el nombre de algunos de estos
archivos de puede variar o pueden llegar a estar distribuidos de manera
diferente, pero siempre se cumplira' por regla que se encuentren dentro del
directorio '/etc/rc.d' (o '/etc/init.d' en algunas distribuciones).

6)  Sistemas de archivos.

6.1 Nociones principales
------------------------
     Para poder acceder a un sistema de archivos, antes debe ser montado en
un directorio, por ejemplo, si tenemos un diskette con cierta informacion y
queremos acceder a ella debemos montarla bajo algun directorio, como por
ejemplo '/floppy'. Entonces, cuando vayamos al directorio '/floppy' y
miremos el contenido veremos el contenido del diskette. Si luego desmontamos
el sistema el directorio '/floppy' estara' vacio o solamente contendra' el
contenido original del directorio. Veamos un ejemplo:

localhost:/# mount /dev/fd0 /floppy                   # Monto el disco de 3 1/2
localhost:/# cd /floppy             # Entro al direcotorio donde monte el disco  
localhost:/floppy# ls                       # Miro el contenido del direcotorio
archivos dentro del disco
localhost:/floppy# umount /dev/fd0                          # Desmonto el disco
localhost:/floppy# ls                       # Miro el contenido del direcotorio
localhost:/floppy#                         # El directorio vuelve a estar vacio

     El mismo caso puede ser usado para los discos rigidos, podemos montar y
desmontar los discos rigidos que querramos en el directorio que deseemos. El
unico sistema de archivos que no podemos desmontar es el sistema de archivos
raiz o primario porque en el trabajamos.
     Como vimos en el ejemplo, para montar un sistema de archivos utilizamos
el comando 'mount' seguido del dispositivo a montar y este ultimo seguido
del directorio donde lo quiero montar.
     El comando 'mount -av' obtiene la informacion de los sistemas de
archivos que estan especificados en el archivo '/etc/fstab' y sus puntos de
montaje. El archivo 'fstab' contiene informacion de los sistemas de archivos
que se montaran al inicio del sistema. Veamos un ejemplo de este importante
archivo:

localhost:/# more /etc/fstab
/dev/hda2       swap     swap        defaults   0   0
/dev/hda1       /        ext2        defaults   1   1
none            /proc    proc        defaults   0   0
locahost:/#

Veamos ahora como se organiza la informacion en este archivo:

/dev/hda1       /        ext2        defaults   1   1
---------       -        ----        ----------------  
    1           2         3          opciones de mount

1) Este es el dispositivo que se montara' (vease seccion 4.1). En este caso
es el disco rigido Master primario, particion numero 1.
2) Este es el directorio donde se montara' el sistema de archivos. Por ser
la particion primaria de linux se montara' en el directorio raiz.
3) Esto indica el Tipo de sistema de archivos que es el dispositivo. Veremos
mas claramente los tipos de sistemas de archivos en el capitulo 6.2.

     El archivo 'fstab' contiene una linea que es especial para el sistema
de archivos /proc. Se debe montar el comando sistema proc para que podamos
ver los procesos que estan en ejecucion en el momento, es decir, que si no
montamos el /proc entonces no podremos ejecutar comandos como 'jobs', 'ps',
etc.

6.2 Tipos de sistemas de archivo.
---------------------------------

     No todos los sistemas de archivos son iguales. Generalmente, cada
sistema operativo tiene su propio sistema de archivos, y el kernel de linux
soporta muchos de ellos. Los sistemas de archivos que no son de linux
necesitan de algun argumento para poder ser montados. El comando 'mount' mas
los argumentos indicados, montaran con exito el sistema de archivos que
nosotros querramos. Veamos un ejemplo:

localhost:/# mount /dev/hda3 /mnt/windows98/
mount: error: You must specify file type
localhost:/#

     Lo que vemos aca es un error al tratar de montar una unidad de windows
98 (seguramente fat32 o fat16). Esto es porque no le indicamos a linux que
tipo de sistema de archivos estamos montando. Entonces lo que deberiamos es
echar una mirada a la siguiente tabla:

Tipos de Sistemas de Archivos:

Tipo              Nombre y especificaciones
----              -------------------------
ext2              Second Extended File System: es el sistema de archivos mas
                  comun actualmente en linux. Antes se usaba el 'ext' que fue
                  reemplazado por este.
ext               Extended File System: muy parecido al 'ext2' y reemplazado
                  por el mismo.
minix             Minix File System: Sistema de archivos del SO Minix.
xiafs             Xia File SystemMuy parecido al ext2. Casi no se lo utiliza 
                  actualmente.
msdos             MS-DOS File System: Sistema de archivos de MS-DOS.
nfs               Network File System: Sistema de archivos de Red
iso9660           ISO 9660 File System: Sistema de archivos usado comunmente
                  para los CD-ROMs
xenix             Xenix File System: Sistema de archivos del SO Xenix
swap              Sistema de archivos de intercambio.
hpfs              HPFS File System: Nos da acceso de solo lectura a las
                  unidades comprimidas con DoubleSpace.
vfat              FAT File System: Accede a particiones de FAT16 y FAT32.

     Entonces para montar un sistema de archivos que no es ext2 deberemos
utilizar el comando 'mount' seguido de la opcion '-t' y seguido el tipo de
sistema de archivo como argumente, detras de esto, agregamos como antes, el
sistema de archivos a montar y el directorio donde montarlo:

localhost:/# mount -t vfat /dev/hda3 /mnt/windows98
localhost:/# cd /mnt/windows98
localhost:/mnt/windows98# ls
Archivos\ de\ Programa   juegos   windows
localhost:/mnt/windows98#


6.3 Buscando errores
--------------------
     Como no es raro que pase, puede que sin querer hayamos apagado el
sistema sin utilizar los comandos apropiados, o quiza solamente presionamos
'reset' porque no teniamos tiempo de esperar a que todos los programas se
cierren. Eso esta muy mal, ya que los sistemas de archivos de linux son muy
delicados y es muy necesario que se desmonten automaticamente antes de
apagar el sistema , porque algun archivo importante podria corromperse y no
podremos recuperarlo. Pero, que tal si ya lo hicimos, tal vez, estemos en
precencia de algun error grave y nosotros no lo sabemos. Para poder ver si
el sistema esta funcionando correctamente existen un par de herramientas que
pueden ayudarnos escaneando el disco en busca de errores. Pero antes de
verificar cualquier sistema de archivos primero tenemos que desmontarlo.
     Para desmontar un sistema de archivos se usa el comando 'umount' (de
unmount o desmontar) seguido del directorio donde este montado el sistema de
archivos. Veamos un ejemplo:
 
localhost:/# umount /mnt/linux2
localhost:/# 

     Si no hemos recibido ningun mensaje de error quiere decir que el
sistema de archivos se ha desmontado satisfactoriamente. Ahora que hemos
desmontado el sistema de archivos podemos hacerle un chequeo para comprobar
que este todo bien. Para esto se utiliza el comando 'fsck' (de file system
check). Este comando determina automaticamente cual es el tipo de sistema de
archivos que queremos chequear y realiza su funcion. Veamos como es la
sintaxis:

localhost:/# fsck /dev/hda4
e2fsck 1.12, 9-Jul-98 for EXT2 FS 0.5b, 95/08/09
/dev/hda4: clean, 338/241664 files, 286449/965664 blocks
localhost:/#

     Esta salida nos indica todo esta bien con este sistema de archivos. Si
acaso linux encontrara algun error nos dara' un aviso de donde se encontro'
y todos los datos.


7) Utilizando el vi.

     El vi es un editor de texto muy poderoso y un poco dificil de usar. Lo
particular de este editor que es podemos encontrarlo en cualquier sistema
Unix y solo hay unas pocas diferencias entre un sistema y otro. Solo voy a
explicar lo mas basico sobre como usar este pequenio editor para que sepamos
como se maneja y como dominarlo. No voy a dar una explicacion muy extensa
porque lo que pretendo de este manual es que sea algo corto, conciso, y
facil de leer. 

     Comencemos con el vi.

localhost:/# vi

------------------------------------------------------------------------------
~
~
~
~
~
~
~
~
~
~
~
~
 "[NO FILE]"  1 line, 1 char________________________________________________

^ editor vi.

La sintaxis para editar un archivo con vi es: 

localhost:/# vi nombre.de.archivo

------------------------------------------------------------------------------
~
~
~
~
~
~
~
~
~
~
~
~
"nombre.de.archivo" [New_File]______________________________________________

7.1 Insertar y borrar texto en vi.
----------------------------------
     Cuando iniciamos el vi, editando un archivo, o no, entramos en modo
ordenes, es decir, que no podremos empezar a escribir simplemente asi como
asi, sino que el vi esta esperando que le demos cualquiero orden para que el
la obedezca. Si queremos entrar en modo de insercion de texto debemos
presionar la tecla 'i'. Ahi ya estaremos en modo de insercion de texto, lo
que quiere decir que ya podemos empezar a escribir.

------------------------------------------------------------------------------
Aqui ya estamos escribiendo porque apretamos la tecla 'i' al estar en modo
ordenes.
~
~
~
~
~
~
~
~
~
~
______________________________________________________________________________

Para salir ahora, del modo de insercion de texto debemos presionar la tecla
'Esc'. Con eso volvimos al modo ordenes. El vi ahora estara' esperando a que
le demos una nueva orden.

La tecla 'a' tambien entra en modo de insercion de teto, pero en vez de
comenzar a escribir en la posicion del cursor, empieza un espacio antes. por
ejemplo:

------------------------------------------------------------------------------
El cursor esta ubicado en la letra siguiente :p, y si apreto la tecla 'a'
entonces comenzare a escribir en los dos puntos (:).
~
~
~
~
~
~
~
~
~
~
______________________________________________________________________________

Ahora si lo que queremos es insertar texto pero desde la linea que sigue a
la linea donde estemos ubicados, entonces debemos entrar al modo de
insercion de texto con la tecla 'o'.

Para borrar texto, hay que salir al modo ordenes, y presionar la tecla 'x'
que borrara' el texto que se encuentre sobre el cursor. Si quiero borrar las
lineas enteras, entonces debo presionar dos veces la tecla 'd' sobre la
linea que deseo eliminar. Si presiono las teclas 'dw' borrare' la palabra
sobre la que estare' ubicado:

------------------------------------------------------------------------------
Aca va el antes y el despues de borrar con 'dw' y el cursor queda sobre la
palabra borrar.
~
~
~
______________________________________________________________________________

El cursor ha quedado ubicado sobre la palabra borrar y ahora apreto 'dw'
sobre de ellas.
------------------------------------------------------------------------------
Aca va el antes y el despues de  con 'dw' y el cursor queda sobre la
palabra borrar.
~
~
~
______________________________________________________________________________

Si presionamos, en cambio, la letra 'R' (en mayusculas) sobre una palabra
podremos sobre escribir encima de ella. Esto es una especie de modo de
insercion de texto pero solo podra modificar la palabra en la que estamos
situados.
La tecla ~ cambia de mayuscula a minuscula la letra sobre la que estemos
situados. 


7.2 Moverse por el vi.
----------------------
     Estando en modo ordenes podemos movernos por el archivo que estemos
editando de diferentes y practicas maneras. 
     Las teclas h, j, k y l reemplazan a las flechas izquierda, abajo,
arriba y derecha respectivamente. Realmente no le encuentro ningun uso a
esto. 
     Con la tecla 0 me muevo hasta el comienzo de la linea donde estoy
ubicado, y con la tecla $ voy hasta el final de la misma linea.
     Con las teclas w y b me muevo hasta el comienzo de la siguiente palabra
o al de la palabra anterior respectivamente.
     Para moverme hacia la pantalla siguiente presiono la combinacion de
teclas CTRL F, y para volver a la pantalla anterior CTRL B.
     Para ir hasta el principio del archivo presiono la tecla G (en
mayusculas).


7.3 opciones del menu ':'.
--------------------------
     Desde el menu ': ' (como yo lo llamo) podre' guardar, salir, cambiar de
archivo que estoy editando entre otras cosas. Para entrar a este menu
debemos estar en modo ordenes y presionar la tecla ':'. Al abrirlo
apareceran los dos puntos (:) donde yo podre' darle al menu la instruccion
que desee:

------------------------------------------------------------------------------
~
~
~
~
~
~
~
~
~
~
~
~
"nombre.de.archivo" [New_File]______________________________________________

Presiono :

------------------------------------------------------------------------------
~
~
~
~
~
~
~
~
~
~
~
~
 :       _____________________________________________________________________

Ahora puedo dar la orden que yo necesite. Si quiero guardar el archivo con
algun nombre en especial debo presionar 

:w nombre.deseado

Si lo que deseo es guardar el archivo con el nombre que ya tenia presiono

:w

Si lo que deseo es guardar el archivo con el nombre que ya tenia y salir de
vi presiono

:wq

Si deseo salir del archivo sin guardar los cambios presiono

:q!

Si deseo editar otro archivo pongo

:e nombre_del_archivo

Si quiero insertar un archivo que ya tengo guardado ( como por ejemplo,
linux.txt) presiono

:r linux.txt

Si quiero ejecutar algun comando del shell y que su salida aparezca en el
archivo que estoy editando tambien puedo hacerlo

:r! comando

Ejemplo

------------------------------------------------------------------------------
~
~
~
~
~
~
~
~
~
~
~
~
 :r! ls    ___________________________________________________________________

------------------------------------------------------------------------------
bin/     dev/     home/    proc/    shlib/   var/
boot/    etc/     lib/     root/    tmp/     vmlinuz
cdrom/   floppy/  mnt/     sbin/    usr/
~
~
~
~
~
~
~
~
______________________________________________________________________________



8) Nociones del autor.

     El total responsable y autor de esta segunda version de este material
educativo es Daniel Alejandro Wyrytowski, de 17 anios. El mismo no se hace
responsable por ningun problema o/y perjuicio que pueda causar el mismo ya
que fue creado solo con fines educativos. Este pequenio manual hace a una
referencia rapida del uso de Linux y sus mas esenciales herramientas. El
autor es solo un simple usuario Argentino de Linux que quiere ayudar a los 
novatos a progresar un poco mas rapido en este facinante sistema operativo.
Sin embargo, si quieren especializarse mas entonces deberan un manual mas
amplio sobre el mismo sistema.
     Para contactarme pueden mandarle un e-mail a daniel_w@flashmail.com.
Acoto que no respondere' ninguna duda referida al manejo del sistema o
cualquier pregunta tecnica. Solo contestare' aquellos e-mails con opiniones
y/o sugerencias sobre el mismo articulo o por motivos personales. 

La version 1.1 de este manual fue concluida el dia 26 de Noviembre de 1999. 

Este manual se actualizara' y por ningun motivo la presente sera' su ultima
version.

___________________________________________________________________________

                                      Copyright (C) 1999  Daniel Wyrytowski 
                                                   <daniel_w@flashmail.com>
                                        <http://www.proyectoslinux.cjb.net>