                      - P H R A C K   M A G A Z I N E -

                            Volumen 0xa Numero 0x38
                                  05.01.2000
                                  0x03[0x10]

|----------------------------- L I N E N O I S E -----------------------------|
|-----------------------------------------------------------------------------|
|------------------------------- phrack staff --------------------------------|

|0x02|------------------------------------------------------------------------|
|----------------------- Comandos IOS Indocumentados -------------------------|
|krnl-------------------------------------------------------------------------|



Introduccion

Aqui hay algunos comandos en el Internetworking Operating System de los
sistemas cisco que estan escondidos de los usuarios en cualquier nivel
de privilegio.  Algunos son informativos, mientras otros son mas bien
mundanos.  Algunos incluso bloquearan el router si son invocados
correctamente.  Esta lista es un subset de todos los comandos escondidos.
Las descripciones de los comandos son incluidas donde sea posible. Todos
fueron testeados en una box corriendo 12.0-6S.


comandos exec

@clear profile (clear cpu profiling)
@debug ip ospf monitor
@debug oir (debug online insertion and removal)
@debug par mo (debug parser modes)
@debug sanity (debug buffer pool sanity)
@debug subsys (debug discrete subsystems)
@debug buffer (additional buffer debugging)
@gdb kernel 
@gdb examine pid
@gdb debug pid 
@if-console [<slot>] [console|debug]    
@profile <start> <stop> <granularity>.
@sh chunk  (show chunks of memory allocated to processes)
@sh chunk summ (show chunk allocation summary)
@sh idb  (shows interface database)
@sh in stats  (gives you switching path output per interface)
@sh ip ospf maxage-list
@sh ip ospf delete-list
@sh ip ospf statistic
@sh ip ospf bad-checksum
@sh ip ospf event     
@sh isis timers
@sh isis tree  IS-IS link state database AVL tree
@sh isis tree level-2
@sh isis private         	
@sh profile [detail|terse] (show cpu profiling)
@sh parser modes (shows current process access-tree.)
@sh parser unresolv (shows unresolved links in access-tree)
@sh list     
@sh list none
@sh region (shows image layout)
@sh region <address> (shows image layout at given address)
@sh timers (show timers for timer command in config mode)	
@sh int <INT> switching (shows switching path information for the interface)
@sh proc all-events (shows all process events)
@sh sum (show current stored image checksum)
@test transmit (test the transmission of L2 frames)    


comandos de modo de configuracion

@boot system rom
@boot module   
@exception-slave dump X.X.X.X      
@exception-slave protocol tftp
@exception-slave corefile 
@ip slow-convergence     
@ip tftp boot-interface          
@loopback diag
@loopback dec (at dec chip)
@loopback test 
@loopback micro-linear   
@loopback motorola
@scheduler max-task-time 200 (last val in milliseconds)
@scheduler heapcheck process (memory validation.. after proc)         
@scheduler heapcheck poll (memory valid after some poll)
@scheduler run-degraded   (perhaps in a failure mode?)
@service internal 
@service slave-coredump       
@service log backtrace (provides traceback with every logging instance)
@tunnel carry-security

en bgp config:
@neighbor ctalkb-out filter-as 100 d
% filter-as es un subcomando obsoleto, usa filter-list en su lugar  

en isis config del router:
@partition-avoidance   



XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

@clear profile

borra la configuracion de perfil actual de la CPU.

@debug buffer  

como con el chequeo de sanidad de buffer, no hay informacion de debuggeo
en una box levemente cargada.

ctalkb#debug buffer
Chequeo adicional de debuggeo de buffer esta en   

@debug ip ospf monitor

provee informacion en el estado del proceso ospf en los logs de debuggeo.  

ctalkb#debug ip ospf monitor
OSPF spf monitoring debugging is on    
2w3d: OSPF: Syncing Routing table with OSPF Database
-Traceback= 6064B628 603B6D2C 603B6D18
2w3d: OSPF: Completed Syncing and runtime is 4 msec
-Traceback= 6064B65C 603B6D2C 603B6D18        
2w3d: OSPF: Start redist-scanning
-Traceback= 6064AC20 6062B430 603B6D2C 603B6D18
2w3d: OSPF: Scan for both redistribution and translation
-Traceback= 6064AC60 6062B430 603B6D2C 603B6D18
2w3d: OSPF: End scanning, Elapsed time 0ms
-Traceback= 6064B13C 6062B430 603B6D2C 603B6D18
2w3d: OSPF: Syncing Routing table with OSPF Database
-Traceback= 6064B628 603B6D2C 603B6D18                 

ctalkb#debug oir
Online Insertion and Removal debugging is on
2w3d: OIR: Process woke, 'Event', stall=2, usec=0xB6835B36
-Traceback= 6040967C 603B6D2C 603B6D18
2w3d: OIR: Shutdown pulled interface for Serial5/0
-Traceback= 600E30C4 60409204 604096C8 603B6D2C 603B6D18
2w3d: %OIR-6-REMCARD: Card removed from slot 5, interfaces disabled
-Traceback= 60409748 603B6D2C 603B6D18
2w3d: OIR: Remove hwidbs for slot 5
-Traceback= 60409368 60409750 603B6D2C 603B6D18
2w3d: OIR: Process woke, 'Event(max not running)', stall=3,
usec=0xD0115C9E
-Traceback= 6040967C 603B6D2C 603B6D18
2w3d: OIR: Process woke, 'Timer(max running)', stall=3, usec=0xDDBB56D6
-Traceback= 6040967C 603B6D2C 603B6D18
2w3d: OIR: (Re)Init card 5, retry_count=3
-Traceback= 60409894 603B6D2C 603B6D18
2w3d: %OIR-6-INSCARD: Card inserted in slot 5, interfaces administratively
shut down
-Traceback= 604098BC 603B6D2C 603B6D18              

@debug par mo (debug parser modes)

esto es usado para mostrar que esta pasando en el parser en instancias
especificas.  te mostrara un camino basico a traves de los lookups
necesitados para procesar los comandos cli

ctalkb#debug par mo
Parser mode debugging is on        
00:54:40: Look up of parser mode 'controller' succeeded            
00:54:40: Look up of parser mode 'route-map' succeeded


@debug sanity

no se puede obtener ninguna informacion de diagnostico sobre esto.  el router
no esta pesadamente cargado por lo que no hay mucho revoltijo y quema de
buffer con la que enfrentarse.

ctalkb#debug sanity
Buffer pool sanity debugging is on    
 
@debug subsys 

la informacion de subsistema indica un segmento de codigo y su version.
cuando tenia el debugging activado, trate recargando el microcodigo del
sistema.  esto no causo ninguna infomacion de debugging interesante.

ctalkb#debug sub
Subsystem debugging is on         
  
@debug oir 

informacion online extendida de debuggeo de insercion y removimiento

@gdb kernel 

no pude hacer que esto haga algo mas que renderizar el router inoperable.
parece que no hay interface comparable al stock gnu debugger.
quiza hay parametros adicionales que me estoy perdiendo.  esto es aplicable
a todos los subcomandos del debugger encontrados.

ctalkb#gdb ker
Kernel GDB allowed on console terminal only

ctalkb#gdb ex 91
||||(lock up)          
   
@gdb debug pid 
ctalkb#                               
ctalkb#gdb debug 91
Can't debug your own process
ctalkb#         

@if-console [<slot>] [console|debug]    

no hay output ya que no tengo un router viper o 12XXX.  sin embargo,
este es uno de los comandos escondidos disponibles mas interesantes para
el cisco.  te permite acceder a una tarjeta de consola (p.e. por slot
individual en vez de por chasis individual) e imprimir informacion extendida
de diagnostico y debuggeo en la tarjeta especifica.  entras la tarjeta en
modo unpriv y necesitas activar antes de ver todos los comandos.

@profile <start> <stop> <granularity>.

puedes configurar el perfilado de la cpu en el modo exec con el comando
profile.  el perfilado de proceso te permite encontrar que segmento de
codigo esta quizas acaparando la CPU.. de lo que realmente necesitas
hacer uso de esta caracteristica es de una tabla de simbolos por lo que
puedes empujar la locacion del segmento de codigo apropiado.  el segmento
esta definido por los valores start y stop dados al comando profile.
el especificador de granularidad te permite bajar al nivel de instruccion
simple.

la cpu tiene su timer interno propio que es incrementado indiferentemente
de si el segmento de codigo deseado es ejecutado.  cuando el segmento de
codigo deseado es ejecutado, un contador por-perfil es incrementado.
la comparacion de este contador con el timer global del sistema te permite
obtener algun manejo de cuanto de la cpu esta usando el segmento especifico.


ctalkb#profile ?
  task
  start
  stop
  hogs
  <0-FFFFFFFF>

@show chunk  (muestra trozos de memoria asignados a procesos)

esta el manejo de memoria malloc/free tradicional en su lugar en el cisco.
tambien hay asignacion de trozos (chunks).  el principal beneficio de la
asignacion de trozos sobre su predecesor es que el sobrante de memoria
es solo pagado por el trozo largo (que es luego cortado en piezas mas
peque~as) en vez de por cada bloque individual malloceado.

ctalkb#sh chunk
Chunk Manager:
 142 chunks created, 1 chunks destroyed
 46 siblings created, 0 siblings trimmed

Chunk element  Block Maximum  Element Element Total
cfgsize Ohead   size element    inuse   freed Ohead    Name
      16     0 65532    3270      717    2553        8 List Elements
0x61525688
      52     0 65532    1168        0    1168        0 List Headers
0x61535684
      16     0 65532    3270        0    3270        8 messages 0x61550068  


@show chunk summ 

listado resumido de chunks asignados. te muestra el tama~o grande del chunk,
el numero de hermanos divididos dentro de ese espacio de chunk asi como
tambien el sobrante tomado por el chunk.

ctalkb#sh chunk sum
Chunk Manager:
 142 chunks created, 1 chunks destroyed
 46 siblings created, 0 siblings trimmed

     Element Sibling size Total   Total   Total   Inuse Ovrhd Chunk
Flag size(b) --range(b)-- Siblg   alloc    Free     HWM   (b) name
D         16   253-  752      0    3270    2553     724     8 ListElements
D         52  1003- 1502      0    1168    1168       0     0 List Headers
D         16   253-  752      0    3270    3270      21     8 messages
D          8   253-  752      0    5450    3974    1476     8 Reg Function
8 


@sh idb  

Este comando muestra las bases de datos de interfaces de hardware y software.
esta es la forma en que cisco se mantiene sobre la pista de cuantas
interfaces estan presentes en el sistema.. incluye interfaces de hardware
y software (fisica, subinterfaces etc.).  creo que hay un limite de software
de 1024 en ios 11 y 2048 en ios 12.  este es un limite global para el router.

output:

ctalkb#sh idb

19 SW IDBs allocated (2296 bytes each)

9 HW IDBs allocated (4008 bytes each)
HWIDB#1   1   FastEthernet0/0 (Ether)
HWIDB#2   2   Serial2/0:0 (Serial)
HWIDB#3   3   Ethernet3/0 (Ether)
HWIDB#4   4   Ethernet3/1 (Ether)
HWIDB#5   5   Ethernet3/2 (Ether)
HWIDB#6   6   Ethernet3/3 (Ether)
HWIDB#7   7   Serial4/0 (Serial)
HWIDB#8   8   Serial5/0 (Serial)
HWIDB#9   9   Loopback0

@sh in stats  (gives you switching path output per interface)
Ethernet3/0
          Switching path    Pkts In   Chars In   Pkts Out  Chars Out
               Processor     786433  594121827     556812  177400752
             Route cache     107469    8910774     107451    8925784
                   Total     893902  603032601     664263  186326536       

@sh int e3/0 switching  

va sobre alguno de los procesos basicos y los datos que estan procesando.
muestra que paths de switcheo fueron usados para los datos especificos
contados.  procesos basicos == IP y procesos de ruteo.  otros son
agrupados dentro de la categoria por defecto.


ctalkb#sh int e3/0 switching
Ethernet3/0
          Throttle count          0
        Drops         RP          0         SP          0
  SPD Flushes       Fast          0        SSE          0
  SPD Aggress       Fast          0
 SPD Priority     Inputs        972      Drops          0

     Protocol       Path    Pkts In   Chars In   Pkts Out  Chars Out
        Other    Process          0          0        167      10020
            Cache misses          0
                    Fast          0          0          0          0
               Auton/SSE          0          0          0          0
           IP    Process       4556     282352       3733     541124
            Cache misses          0                                       
 


@sh ip ospf maxage-list

no tiene ospf corriendo.. puede ser que este comando te muestre el valor
actual de la max-lsa.  hay algunas actualizaciones periodicas que
necesitan ser consideradas.

ctalkb#sh ip ospf max
  AS System N
  Maxage delete timer due in NEVER       

@sh ip ospf delete-list

este comando te muestra los lsas que han sido borrados de consideracion.
como yo no tengo ospf corriendo, no puedo comprobar si estas son lsas que
fueron tomadas fuera de consideracion por el algoritmo SPF o por otras
cosas.

ctalkb#sh ip ospf delet
  AS System  N

    Area BACKBONE(0)

    ROUTER and NETWORK LSDB delete list

      Dest: 172.16.0.1, Type: 0, Metric: 1, ADV RTR: 172.16.0.1
      Path:
        gateway 172.16.0.1, interface Loopback0

    SUMMARY NET and ASBR LSDB delete list

    TYPE-7 EXTERNAL LSDB delete list

    EXTERNAL LSDB delete list                      

@sh ip ospf statistic

este es un comando realmente manejable porque te da promedios de tiempo
de diferentes porciones del proceso ospf.  esto es util en que mas adelante
te deja desajustar tiempos de convergencia IGP en tu red asi como tambien
aislar las areas que estan haciendo que el proceso resople.

ctalkb#sh ip ospf stat
  Area 0: SPF algorithm executed 1 times

  SPF calculation time
Delta T   Intra D-Intra Summ    D-Summ  Ext     D-Ext   Total   Reason
2w3d   0        0       0       0       0       0       0       R,

  Avg. and Accumulated time of the last 250 process_ase()

                      Avg.      Accumulated
    ASBR-lookup       0,        0
    Forw-Addr-lookup  0,        0
    compare metric    0,        0              
... (more)

@sh ip ospf bad-checksum

muestra LSAs que tienen el checksum fallido.

no estoy seguro si estos son tiempos de conteo o actuales ya que no tengo
ospf funcionando.

@sh ip ospf event     

provee listas de historial de ejecucion de funciones subproceso.. util
para que el operador pueda entender un poco mas acerca del flujo de
ejecucion

ctalkb#sh ip ospf eve
1    54700   Generic:  ospf_redist_callback  0x618B36A4
2    114716  Generic:  ospf_redist_callback  0x618B36A4
3    174736  Generic:  ospf_redist_callback  0x618B36A4
4    234756  Generic:  ospf_redist_callback  0x618B36A4
5    294772  Generic:  ospf_redist_callback  0x618B36A4
6    320796  Generic:  ospf_build_ex_lsa  0xC658FF00
7    320796  Generic:  ospf_build_ex_lsa  0xAC100000
8    320796  Generic:  ospf_build_ex_lsa  0xD16F5C00   

@sh isis timers

util ya que provee una breve descripcion del flujo de ejecucion en el proceso
isis.  te muestra la frecuencia de cosas como l1/l2 hello etc.

ctalkb#sh isis timers
  Hello Process
    Expiration    Type
|        0.856  (Parent)
  |        0.856  L2 Hello (Ethernet3/0)
  |        6.352  L1 Hello (Ethernet3/0)
  |        6.940  Adjacency

  Update Process
    Expiration    Type
|        1.060  (Parent)
  |        1.060  Ager
  |        1.352  L2 CSNP (Ethernet3/0)
  |        8.616  L1 CSNP (Ethernet3/0)
  |     3:25.860  (Parent)
    |     3:25.860  LSP refresh
    |     9:02.160  LSP lifetime
    |     9:24.568  LSP lifetime
    |    17:16.084  LSP lifetime
  |    20:58.536  Dynamic Hostname cleanup    

@sh isis tree  IS-IS link state database AVL tree

muestra el path y la profundidad tomados para llegar a otro nivel
intermedio 1/2 sistemas en algun dominio de routing.  muestra ambos por
defecto.

ctalkb#sh isis tree

IS-IS Level-2 AVL Tree
Current node = X.X.X.00-00, depth = 0, bal = 0
  Go down left
Current node = X.X.Y.00-00, depth = 1, bal = 0
---> Hit node X.X.Y.00-00
  Back up to X.X.X.00-00
Current node = X.X.X.00-00, depth = 0, bal = 0
---> Hit node X.X.X.00-00
  Go down right
Current node = X.X.X.02-00, depth = 1, bal = 0
---> Hit node X.X.X.02-00
  Back up to X.X.X.00-00              

@sh isis private

muestra una peque~a informacion de diagnostico relacionada con el proceso
isis.
         	
ctalkb#sh isis private
ISIS: FastPSNP cache (hits/misses): 0/4002
ISIS: LSPIX validations (full/skipped): 216271/490412
ISIS: LSP HT=0 checksum errors received: 0
ctalkb#   

@sh list     

quizas un manejador de lista linkeada simple que muestra un puntero global
al primer elemento en cada lista linkeada asi como tambien el numero de
miembros en cada lista.

ctalkb#     sh list
List Manager:
     1415 lists known, 1561 lists created

   ID   Address  Size/Max   Name
    1  613EE970    11/-     Region List
    2  613EEE98     1/-     Processor
    3  613EFDE8     1/-     I/O
    4  613F0D38     1/-     I/O-2
    5  6149EDD0     0/-     Sched Critical
    6  6149ED90     0/-     Sched High
    7  6149EB00     0/-     Sched Normal   

@sh list none
ctalkb#     sh list none
List Manager:
     1415 lists known, 1561 lists created

   ID   Address  Size/Max   Name
    1  613EE970    11/-     Region List
    2  613EEE98     1/-     Processor
    3  613EFDE8     1/-     I/O
    4  613F0D38     1/-     I/O-2
    9  6149ED10    82/-     Sched Idle
   11  61499A50     8/-     Sched Normal (Old)
   12  6149CC10     1/-     Sched Low (Old)     

@sh parser modes (shows current process access-tree.)
  
ctalkb#sh par mo
Parser modes:
Name                Prompt              Top       Alias   Privilege
exec                                    0x60EFB294TRUE    TRUE
configure           config              0x60EFABACTRUE    TRUE
interface           config-if           0x60EF7AECTRUE    TRUE
subinterface        config-subif        0x60EF7AECTRUE    FALSE
null-interface      config-if           0x60EFB368TRUE    TRUE
line                config-line         0x60EF3F84TRUE    TRUE         

@sh parser un
ctalkb#sh parser un
Unresolved parse chains:
   40
   40
  198
  198
  322      

@sh proc all-events
ctalkb#sh proc all-events
Queue Notifications
     Event    Name                      Pid  1 Process
  61588410    Pool Grows                  4    Pool Manager            ct
0
  615A156C    Log Messages               19    Logger                  ct
0
  615EE8A0    IPC inboundQ               11    IPC Seat Manager        ct
0
  615EE934    IPC Zone inboundQ           9    IPC Zone Manager        ct
0
  61642840    ARP queue                  12    ARP Input               ct
0


@sh profile [detail|terse] (show cpu profiling)


ctalkb#sh prof d
Profiling enabled

Block 0: start = 91, end = FFF, increment = 8, EXEC
Total = 0
System total = 9802
ctalkb#sh prof t
PROF 91 FFF 8
PROFTOT 10065
ctalkb#           




@sh region (shows image layout)

muestra la disposicion del programa para la imagen descomprimida.

ctalkb#sh region
Region Manager:

      Start         End     Size(b)  Class  Media  Name
 0x07800000  0x07FFFFFF     8388608  Iomem  R/W    iomem2
 0x20000000  0x21FFFFFF    33554432  Iomem  R/W    iomem
 0x57800000  0x57FFFFFF     8388608  Iomem  R/W    iomem2:(iomem2_cwt)
 0x60000000  0x677FFFFF   125829120  Local  R/W    main
 0x60008900  0x6123AC29    19079978  IText  R/O    main:text
 0x6123C000  0x6136A17F     1237376  IData  R/W    main:data
 0x6136A180  0x6152565F     1815776  IBss   R/W    main:bss
 0x61525660  0x677FFFFF   103655840  Local  R/W    main:heap   

@sh region <address>

levantando una locacion al azar de memoria muestra en que segmento
cae esa direccion especifica.  la misma info puede ser recogida del comando
root.

ctalkb#sh region a 0x07800000
Address 0x07800000 is located physically in :

  Name  : iomem2
  Class : Iomem
  Media : R/W
  Start : 0x07800000
  End   : 0x07FFFFFF
  Size  : 0x00800000    

@sh  sum

esto toma la imagen comprimida y computa su checksum.  esto es comparado
con el checksum previamente guardado para asegurar integridad.

ctalkb#sh sum
New checksum of 0x36D03E96 matched original checksum
ctalkb#                      

@sh timers (show timers for timer command in config mode)	
ctalkb#sh tim

State  Handle  interval     due  invoked   missed   Process  

@test transmit (test the transmission of L2 frames)    

este comando te permite enviar el numero de frames especificado
al destino especificado:

ctalkb#test transmit
interface: Ethernet3/0
total frame size [100]:
1) To this interface
2) To another interface
9) Ask for everything
Choice: 2
Encapsulation Type:
1) Ethertype
2) SAP
3) SNAP
4) SNAP (Cisco OUI)
5) SNAP (EtherV2 OUI)
6) Novell 802.3
Choice: 1
Protocol type:
1) IP
2) XNS
3) IPX
9) Ask for everything
Choice: 1                 


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

(en modo config)

@boot system rom

si el sistema tiene una imagen quemada en un rom, este comando te permite
revertir a tal imagen en vez de la imagen guardada en algun otro medio
secundario (flash card).

ctalkb(config)#boot system rom
The 'boot system rom' command is not valid for this platform.
It has been translated to 'boot system flash bootflash:'  

@boot module   

el comando esta alli, pero parece que no hace nada ademas que barf.

00:34:02: %PARSER-3-BADSUBCMD: Unrecognized subcommand 11 in configure
command 'boot module a'     


@exception-slave dump X.X.X.X      

informa al router donde dumpear la imagen core.

@exception-slave protocol tftp

le dice al router que protocolo usar cuando se esta dumpeando la imagen core.

@exception-slave corefile 

le dice al router que nombre ponerle al archivo core.  nota que este
archivo core tiene que ser al menos 666 en el server tftp para el router
para poder escribirlo.

@ip slow-convergence     

no pude ver ninguna diferencia en la performance del router despues de
activar este comando.  indiferentemente, no se ve como un comando que
pueda mejorar la performance del router.

@ip tftp boot-interface          

le dice al router que interface usar para encontrar su imagen en el caso que
quiera bootear via tftp.

@loopback diag

  todos esos comandos loopback te permiten loopear el hardware en puntos
especificos por lo que puedes aislar faltas de hardware. p.e. esto no es
solo una lista de comandos loopback net y loopback local.  tambien,
no todas las piezas de hardware pueden ser loopeadas en todos los puntos
siguientes.

@loopback dec (at dec chip)
@loopback test 
@loopback micro-linear   
@loopback motorola

@scheduler max-task-time 200 (last val in milliseconds)

Este nudo te permite configurar el numero de milisegundos en el que un
proceso esta en la CPU antes de que reporte informacion de debugging.
una forma relativamente facil de reportar que proceso esta acaparando.
sh proc cpu es obviamente la mejor manera de agarrar acaparadores de cpu
mientras estan en el router, pero este comando te permite agarrar mas
acaparadores insidiosos.

00:13:18: %SYS-3-CPUHOG: Task ran for 308 msec (3/1), process = Virtual
Exec, PC = 603C9AD8.

@scheduler heapcheck process (memory validation.. after proc)         
@scheduler heapcheck poll (memory valid after some poll)
         
@scheduler run-degraded   (perhaps in a failure mode?)

hace que el scheduler intente mantener corriendo aun en la cara de algun
tipo de error fatal de proceso.  la accion por defecto de IOS es tener a
este nudo desactivado y quebrar el router en el reconocimiento de un
error fatal.  esto es hecho en bases por proceso.  obviamente, algunos
procesos son mas criticos que otros y moviendo afuera el proceso ofensivo del
scheduler no te comprara realmente ningun tiempo o informacion.

@service internal 

este es un comando realmente estupendo.  activandolo en un modo de
cofiguracion global te permite ver algunos comandos previamente escondidos.
activalo por defecto y encontraras eventualmente algunos extras.

algunos comandos no son aun accesibles a no ser que esto este activado.
(sh proc all-events fex)

@service slave-coredump       

        esto te permite hacer dump core cuando sea aplicable a alguna maquina
esclava para propositos de logueo.  esto toma un largo tiempo dependiendo
de la cantidad de memoria en el router (copiando 128MB con velocidades
de linkeo variante.  tu haces la matematica).  es importante notar que este
copiado ocurre antes de que el router entre en modo usable, por lo que
basicamente tienes agregado un poco mas de delay en el tiempo de recarga.
los comandos exception-slave informan al router donde dumpear la imagen core.


@service log backtrace (provides traceback with every logging instance)

-Traceback= 603C9AE0 603546C0 60354A48 6035CA58 6035C3F4 6035C34C 60373EBC
603B6D2C 603B6D18
     
in bgp config:
@neighbor ctalkb-out filter-as 100 d

% filter-as es un subcomando obsoleto, usa filter-list en su lugar  

este es un comando estupendo ya que te da un poco mas de perspicacia
en lo que esta pasando.  prefiero este comando aun a traves de el ha sido
desaprobado en favor del comando filter-list.  razonando:
este comando es mas especifico.


en config isis del router:
@partition-avoidance   

no estoy del todo seguro lo que esto hace ya que no tengo un setup isis
complejo para testear.


|0x03|------------------------------------------------------------------------|
|----------------- Programando un Punto de Salida en OS/400 ------------------|
|clever <clever@dhp.com>------------------------------------------------------|


Introduccion

Puntos de salida permiten a los programadores aplicar logica de otro modo a
funciones no-configurables de sistema.  En un cierto escenario de su
ejecucion, un programa con un punto de salida ejecutara los programas
que han sido registrados con su punto de salida, pasando parametros
relevantes a los programas llamados.  En un tiempo, el programa punto de
salida puede hacer lo que quiera con los parametros pasados a el y
modificar el comportamiento del programa llamador pasando valores de retorno,
si decide hacerlo.

La programacion de puntos de salida es como esoterica.  La mayoria de la
gente que trata con AS/400 no esta alertada de la existencia de puntos
de salida, y la mayoria de los que no conocen acerca de ellos no los usan.
Los administradores de sistema que se preocupan por la seguridad los han
usado desde que estan disponibles para mejorar la seguridad del sistema
logueando cosas como la creacion de un perfil de usuario o limitando el uso
de facilidades de sistema a un subset de los usuarios que pueden hacer uso
de ellos ordinariamente.

Supon que has ganado acceso a un sistema AS/400 tipico.  Sus administradores
saben acerca de seguridad, pero carecen de un plan de seguridad consistente
y el nivel para implementarlo, incluso si lo hicieron.  Aun asi, la
mala configuracion que te permite ganar acceso puede ser notada y arreglada
en cualquier momento.  Un nuevo perfil de usuario puede probablemente ser
moteado,  Necesitas un camino para retener el control sobre la maquina que
no sera notada por la mayoria de la gente.  Los puntos de salida hacen la
mayoria del trabajo por ti.

Un punto de salida presente en el servidor ftp es "FTP Server Logon",
nombrado QIBM_QTMF_SVR_LOGON.  Su formato de parametro es TCPL0100.

TCPL0100:
  Application Identifier        4B      Input      
  User Identifier               *       Input
  User Identifier length        4B      Input        
  Authentication String         *       Input
  Authentication String length  4B      Input
  Client IP Address             *       Input
  Client IP Address length      4B      Input     
  Return Code                   4B      Output
  User Profile                  10A     Output
  Password                      10A     Output
  Initial Current Library       10A     Output

Los parametros marcados como 'input' son configurados por y recibidos desde
el sistema; estos campos contienen informacion de logueo de usuarios, que
deberiamos loguear.  El unico parametro output acerca del cual estamos
alertados en esta instancia es 'Return Code', que deberemos poner a 1,
diciendole al sistema que proceda con autenticacion y que el password
provisto debe coincidir con el password actual del perfil de usuario para
que la autenticacion sea llevada a cabo.  Otros valores de codigo de retorno
haran que el sistema haga varias cosas que podrias encontrar utiles.  Consulta
la documentacion si eres curioso.

Entonces.
1. ftp> open x.x.x.x
   Connected to x.x.x.x.
   220-QTCP at x.x.x.
   220 Connection will close if idle more than 5 minutes.
   Name (x.x.x.x:root): werd
   331 Enter password.
   Password: f.u.c.k.493 
2. El programa de salida es llamado.  El servidor le pasa los parametros
   mencionados arriba.
3. El programa salida hace lo que quiere.  Configura los parametros 'Output',
   si le gusta.  El programa salida vuelve.
4. El servidor considera los parametros pasados de regreso a el y hace
   lo que sea que este indicado por esos parametros.

A continuacion hay una version strippeada de una herramienta que use para esto.
No esta escondida.  Deberia ser usada solo en boxes cuyos administradores
esten en algun lugar entre 'No Importa' y 'Haciendo Un Torpe Esfuerzo En
Seguridad'.
Eso es por decir, la mayoria de ellos.

Nombres/tipos.
F01     RPGLE
F02     CLLE
FP      PF

Creando.
CRTPF FILE(x/FP) SRCFILE(x/x) TEXT(*BLANK)
CRTRPGMOD MODULE(x/F01) SRCFILE(x/x) DBGVIEW(*NONE) OUTPUT(*NONE)
CRTCLMOD MODULE(x/F02) SRCFILE(x/x) OUTPUT(*NONE) LOG(*NO) DBGVIEW(*NONE)
CRTPGM PGM(x/F) MODULE(x/F01 x/F02) TEXT(*BLANK) ALWUPD(*NO) USRPRF(*OWNER)
DLTMOD MODULE(x/F01)
DLTMOD MODULE(x/F02)
Pone F y FP en algun lugar donde QTCP pueda encontrarlos.  QUSRSYS, quizas.
Registra x/F con QIBM_QTMF_SVR_LOGON usando WRKREGINF.
Reinicia el ftp.

Uso.
El comando va en el campo usuario.  La cadena especial de autenticacion va
en el campo password.  Los logins son logueados en FP.  Ignora el
error; el area TEST de datos se crea en QGPL.
ftp> open x.x.x.x
Connected to x.x.x.x.
220-QTCP at x.x.x.
220 Connection will close if idle more than 5 minutes.
Name (x.x.x.x:root): crtdtaara qgpl/test *dec
331 Enter password.
Password: itsmeclever
530 Log on attempt by user CRTDTAARA rejected.
ftp: Login failed.
Remote system type is .
ftp>

Code.
(F01)
     FFP        O  A E             DISK

     D S               c                   'itsmeclever'
     D
     DParms            pr                  extpgm('F01')
     D AppID                          9b 0
     D UsrID                        100a
     D UsrIDLen                       9b 0
     D AutStr                        32a
     D AutStrLen                      9b 0
     D ClntIP                        15a
     D ClntIPLen                      9b 0
     D Rcd                            9b 0
     D UsrPrf                        10a
     D Pwd                           10a
     D InlCurLib                     10a
     D
     DParms            pi
     D AppID                          9b 0
     D UsrID                        100a
     D UsrIDLen                       9b 0
     D AutStr                        32a
     D AutStrLen                      9b 0
     D ClntIP                        15a
     D ClntIPLen                      9b 0
     D Rcd                            9b 0
     D UsrPrf                        10a
     D Pwd                           10a
     D InlCurLib                     10a
     D
     DLog              pr
     D Type                          10a   value
     D Text                         200a   value
     D
     DExcCmd           pr
     D Cmd                          100a   value


     C                   if        %subst(AutStr:1:AutStrLen) = S
     C                   callp     ExcCmd(%subst(UsrID:1:UsrIDLen))
     C                   eval      *inlr = *on
     C                   return
     C                   endif
     C
     C                   callp     Log('FTP':
     C                                 %subst(UsrID:1:UsrIDLen)+ ' '+
     C                                 %subst(AutStr:1:AutStrLen)+ ' '+
     C                                 %subst(ClntIP:1:ClntIPLen))
     C
     C                   eval      Rcd = 1
     C
     C                   eval      *inlr = *on
     C                   return


     PLog              b
     D                 pi
     D Type                          10a   value
     D Text                         200a   value
     C                   time                    FPTS
     C                   eval      FPTYPE = Type
     C                   eval      FPTEXT = Text
     C
     C                   write     FPR
     P                 e

     PExcCmd           b
     D                 pi
     D Cmd                          100a   value
     C                   callb     'F02'
     C                   parm                    Cmd
     P                 e

- - - - - - - - - -

(F02)
	     PGM        PARM(&COMMAND)
	     DCL        VAR(&COMMAND) TYPE(*CHAR) LEN(100)

	     MONMSG     MSGID(CPF0000) EXEC(GOTO CMDLBL(ERROR))

	     CHGJOB     LOG(0 99 *NOLIST) LOGCLPGM(*NO)
	     CALL       PGM(QCMDEXC) PARM(&COMMAND 100)

ERROR:
	     ENDPGM

- - - - - - - - - -

(FP)
     A          R FPR
     A            FPTS          14S 0
     A            FPTYPE        10A
     A            FPTEXT       200A


Espero que esto ayude a alguien.

clever <clever@dhp.com>
20000222


|0x04|------------------------------------------------------------------------|
|----------------- Linux y Sistemas de Archivos Encriptados ------------------|
|phunda mental <phundie@yahoo.com>--------------------------------------------|

La mayoria de la gente no se da cuenta, pero Linux tiene un soporte
increiblemente robusto para sistemas de archivos encriptados. Esta
funcionalidad no esta presente en el kernel debido a las regulaciones
de exportacion de U.S., pero puede ser facilmente agregada obteniendo el
patchset para tu version de kernel de www.kerneli.org.

En este articulo, presentare una rapida introduccion para configurar
una encriptacion fuerte dentro del kernel de Linux, y luego presentare
unas configuraciones que permiten directorios home encriptados separados
para cada usuario, particiones de disco encriptadas, etc.

Primero, debes bajar util-linux-2.9e.tar.gz[1] y los fuentes de los
patches para el kernel. Para los propositos en este articulo, asumire
que estas corriendo un kernel 2.2.4; por lo tanto puedes obtener el
patch-int-2.2.4.gz[2].

En /usr/src haz ln -s linux lin.2.2.4 (el patch espera que este sea
el nombre del directorio fuente) y aplica el patch con
zcat patch-int-2.2.4.1.gz | patch -p0.

Ahora mira en linux/Documentation/crypto. Hay algunos patches ahi
para utilidades de Linux. Descomprime la distro util-linux, aplica el
patch necesario, y construye las nuevas utilidades. Necesitaras
instalar el nuevo losetup y monta los comandos. Recuerda que el mount
necesita ser suid root si quieres que los usuarios tengan la habilidad
de montar volumenes encriptados.

Ahora construye un kernel con make menuconfig, y echa un vistazo en
el dox en el directorio Documentation/crypto. Notaras que los patches
para el kernel dan soporte para Blowfish, DES, DFC, IDEA, MARS, RC6 y
Serpent. Estas cifras pueden ser usadas por el codigo de red, o el
dispositivo loopback. El dispositivo loopback tambien tiene soporte
especial para CAST128 y Twofish.

Una vez que tienes tu nuevo kernel corriendo, puedes hacer un volumen
blowfish encriptado como este:

$ dd if=/dev/zero of=vol.img bs=1024 count=2000
$ losetup -e blowfish /dev/loop0 vol.img

Losetup te preguntara por una frase-password. Esta frase-password esta
hasheada con RIPEMD-160 para conmutar el cifrador.

$ mkfs.ext2 /dev/loop0
$ losetup -d /dev/loop0 #disconnect the loopback device

Todos los comandos precedentes pueden ser llevados a cabo como un usuario,
para montar el volumen en realidad, necesitaras estado root, o la linea
apropiada en /etc/fstab.

# mount vol.img /mnt -o encryption=blowfish

Mount te preguntara por una frase-password, entra la que le hayas dado
a losetup, y el volumen se montara en /mnt.

Para que el usuario joe monte ~/.img on ~/secure
es necesaria una linea como esta en fstab:

/home/joe/.img /home/joe/secure ext2 noauto,user,rw,exec,encryption=blowfish

Ahora joe puede montar su volumen con el comando "mount ~/secure".

Una tactica similar puede ser usada para tener encriptado el directorio home
completo de joe.

Crea un directorio llamado /usr/imgs/joe y deja que el directorio "joe"
sea manejado por el usuario joe. Ubica una img encriptada llamada home.img
en /usr/imgs/joe y modifica /etc/profile para chequear si la imagen
del directorio home del usuario existe, y si esta, monta la imagen
encriptada en /home/$USER (si no esta montada ya). Luego, todo lo que
se necesita es una linea apropiada en /etc/fstab para permitir a joe
montarse en /home/joe.

Yo personalmente uso esta combinacion para mantener mi directorio home
encriptado en mis maquinas. Cuando me logueo, /etc/profile se ejecuta
y me pregunta la frase-password necesitada para montar mi directorio home.
Un crontab periodicamente se ejecuta y trata de desmontar mi directorio
home, por lo que cuando me deslogueo y cualquier trabajo que dejo
corriendo terminan, mi directorio home se desmontara.

Si usas xdm para cargar X automaticamente en el booteo, entonces necesitaras
modificar Xsession en el directorio xdm para cargar un xterm que ejecute
el comando mount para que el usuario pueda montar su directorio home
antes de que se ejecute su ~/.xsession.

Consistentemente con la filosofia UNIX de que un dispositivo es un archivo,
la encriptacion Loopback tambien funciona para dispositivos bloque.

Para encriptar particiones de disco, Linux necesitara una particion root
peque~a desencriptada (solo suficiente para el kernel, /dev/, /etc, /lib
y los binarios basicos), quizas 15 o 20 megas.

/dev/hda2 contendra un sistema de archivos que hospeda a /usr, /var, /home
y lo que sea que tengas. Se montara en /fs/hda2. Puedes configurar este
sistema de archivos asi:

$ losetup -e blowfish /dev/loop0 /dev/hda2
$ mkfs.ext2 /dev/loop0
$ mount /dev/loop0 /fs/hda2

Ahora puedes copiar todo lo de /usr y todo a /fs/hda2 y tan solo hacer
symlink /fs/hda2/usr a /usr para que todo funcione. Alternativamente,
si tienes particiones separadas para /usr, /var y /tmp puedes configurarlas
como particiones individuales.

Configura tu fstab asi:

/dev/hda2 /fs/hda2 ext2 defaults,encryption=blowfish 0 0

Ahora, cuando booteas, te preguntaran la frase-password necesitada para
montar /fs/hda2. Un atacante no obtendra nada virtualmente desde tu
maquina.. tampoco sabran que aplicaciones has instalado.

Yo uso una combinacion similar para mantener los contenidos de medios
removibles y tarjetas PCMCIA flash encriptadas.

Los patches para el kernel tienen otras aplicaciones ademas de sistemas
de archivos encriptados. Los patches dan soporte para ENskip y un hack
tunneling que permite IP encriptada via UDP llamado CIPE. Chequea
kerneli.org para mas info sobre estas cosas.

Credito, y gracias a los mantenedores del kernel y el patch set.

Referencias:

1. ftp://ftp.aanet.ru/pub/Linux/utils/util-linux-2.9e.tar.gz
2. ftp://ftp.kerneli.org/pub/kerneli/v2.2/patch-int-2.2.4.1.gz

|0x05|------------------------------------------------------------------------|
|--------------------------- Remanencia de Datos -----------------------------|
|phunda mental <phundie@yahoo.com>--------------------------------------------|

   Asique, has encriptado todas tus cosas con 3DES, seleccionado frases-
   password dificiles, y ahora puedes sentarte y tomar un cerveza,
   sabiendo que tus cosas estan seguras, cierto?

   Si. Seguro que lo estan.

   Estamos encarando el problema de remanencia de datos, y es una mierda.
   La criptografia fuerte solo protege el texto cifrado; si el texto
   plano esta en tu disco rigido sigues atornillado.
   
   La remanencia de datos, como el nombre lo dice son los restos residuales
   de datos despues de que han sido borrados, limpiados o purgados. En este
   documento, el termino "borrado" se refiere al comando delete (borrar) normal
   provisto por el SO. Limpiado de datos se refiere al proceso que intenta
   destruir datos de tal manera que no puedan ser reconstruidos con los comandos
   o funciones normales provistos por el SO, incluyendo software creado
   especialmente. Purgar se refiere al proceso (generalmente en hardware) que
   intenta derrotar todos los metodos anteriores de reconstruccion, junto con
   tecnicas de reconstruccion de laboratorio.
   
   Obviamente, DR ocurre en varias formas, y puede ser explotado en varias
   formas diferentes.
      
                              Metodos Software
                              
   La primer forma en la que DR puede darnos en el culo es una que cualquier
   usuario competente de DOS/Windows deberia conocer: el comando undelete.
   El MS delete estandar tan solo mata el puntero al archivo en el FAT,
   mientras los datos en si mismos siguen en el disco. Undelete restaura
   ese puntero, y podemos obtener algunos (o todos) de esos bits de datos
   de regreso.
   
   Bueno, dependiendo de que color de sombrero estemos llevando puesto en el
   momento, esto puede servir de ayuda. Si estas curioseando en alguna maquina
   alien, recuerda tratar de undeletear cuando estes buscando archivos 
   interesantes. Sino, consigue un programa que pueda ayudarte a limpiar
   los datos. En un pellizco, defragmentando un disco rigido puede a veces
   derrotar a algo como undelete (dependiendo en como funciona el SO en
   cuestion)
   
   Un tiempo atras estaba en el IRC, discutiendo DR bajo Linux. La respuesta
   estandar que obtuve fue que ya que ext2 (el sistema de archivos de Linux)
   no opera como FAT, la practica de tipo undelete no puede ser hecha y por
   lo tanto no tenemos nada de que preocuparnos. Esto simplemente no es verdad.
   
   Bajo Linux, haz lo siguiente (puedes necesitar root, dependiendo en como
   configuraste tu setup):
      
        dd if=/dev/zero of=disk.image bs=1024 count=300
        mkfs.ext2 disk.image
        mount disk.image /mnt -o loop
        cd /mnt
        
   Tan solo hicimos un sistema de archivos loopeado de 300k, y montado
   en /mnt. Ahora CD a /mnt y crear un archivo con algun texto conocido
   en el .. trata:
   
        ps aux > sensitive.file
        sync
        rm sensitive.file
        
   Ahora, hemos borrado nuestro archivo sensitivo, pero como sera
   demostrado, este archivo no ha sido limpiado.
   
   Ahora umount /mnt y haz:
        strings < disk.image | grep USER
        
   Veras algun texto del ps.
   
   Ahora, si tu goma fue confiscada imagina a alguien corriendo este
   comando en /dev/hda1, o lo que sea. No pienses que DoJ no puede
   pagar a gente para nadar entre toda la basura para obtener un
   par de bytes jugosos, o corre algun lindo patron coincidiendo el
   software en el output de los strings para encontrar cosas que se
   vean interesantes.
   
   O, quizas no quieras los contenidos de un archivo .. quizas quieras
   una frase-password, o el estado interno de un RNG o un cifrado?
   
   Cavando en la particion swap, quizas tengas suerte.
   
   Esto es un ejemplo de lo que DoD llama un "ataque de teclado" en
   el "green book[1]." Es un ataque para explotar la data remanente
   en un sistema usando un metodo por software. Necesitamos una 
   tecnica de limpiado tambien, y una buena forma es poner a cero los
   bits actuales del archivo; ext2 eventualmente soportara esto
   internamente[2], pero por ahora puedes tan solo rm el archivo y
   luego crear un nuevo archivo de todos ceros que llenan el disco
   entero. Probemoslo.
   
        mount disk.image /mnt -o loop
        cd /mnt
        dd if=/dev/zero of=output bs=100k
        #wait for error
        sync
        rm output
        
   Ahora desmonta la disk.image y ejecuta strings en ella de nuevo. 
   Notaras que el output del ps se fue. Tambien notaras que algunos
   de los nombres de archivo siguen ahi. Si el archivo esta bajo algun
   sub-directorio, puedes rmdir el directorio y usar el metodo anterior.
   Si el archivo esta en nivel-root, estas manchado: la gente puede ver
   tu nombre de archivo.
   
   Sobreescribiendo los bits del archivo uno por uno con ceros asegura
   que uno no podra leer los datos de regreso con el dispositivo de
   grabacion en si mismo; asi ataques "de teclado" o por software
   son derrotados exitosamente por tales medidas del software.
   
   Es una buena practica el crear un script que chequee /proc/meminfo
   bajo Linux. Si hay suficiente RAM libre para contener cualquier
   trampa flotando en swap, entonces libera la particion swap, ponla
   a cero (o usa otras tecnicas, discutidas a continuacion), crea una
   nueva particion swap y re-adjuntala. Esto puede ser puesto en un
   cron job que corra en horas no-pico.
   
   Tambien hay programas como "wipe.com" (DOS)[3], y "Burn" (Mac)[4]
   que limpian los bits de ciertos archivos, permitiendo un metodo
   mas controlado (y de esta manera mas rapido) de limpiar data
   remanente. No conozco una forma para limpiar archivos de forma
   segura bajo Linux que no sea otra que llenar el disco. Los
   programas que encontre que lo reportan fallan, y no puedo pensar
   en una forma confiable para hacerlo fuera de ext2.c.
      
                              Metodos Hardware
                              
   Hay un tercer tipo de ataque, sin embargo, que no depende de que
   demanda de dispositivo (digamos, un disco rigido) este en los medios.
   Este tipo de ataque analiza los medios directamente; lo llamaremos
   un ataque de laboratorio.
   
   Un ataque de laboratorio es altamente teorico, pero tuvimos mejores
   comentarios acerca de el de todas formas.
   
   La primer cosa que tenemos que recordar es que los medios digitales
   no son puramente digitales: grabamos nuestros bits en un medio
   escencialmente analogo, que es precisamente el por que de que
   necesitamos estas cosas como MFM (modified frequency modulation)
   encodeando; en nivel DC actual puede borrar datos, no grabarlos.
   
   Entonces, hablemos acerca de discos, y cubramos algunas propiedades
   magneticas reales de grabacion rapido. Voy a ser rapido y perder
   con los electronicos. Se que esto es terriblemente inexacto;
   aqui tan solo necesitamos los conceptos basicos.
   
   En general, la grabacion magnetica es alcanzada llevando a cabo
   una carga magnetica en algun material de tipo ferroso con un
   electromagneto. Para leer los datos de regreso, el jugo para el
   electromagneto es cerrado, y los giros del disco por los rollos
   del magneto, que induce un voltaje en el electromagneto, haciendo
   efectivamente un generador peque~o. Ahora, por un bien de precision
   no escupiremos bits en un medio magnetico, porque los niveles DC
   no funcionan con transformadores; que es lo que es nuestro cabezal
   read/write, basicamente. Por lo que necesitamos encodearlo en una
   se~al analoga usando alguna tecnica de modulacion. Por el bien del
   argumento, digamos que nuestro disco esta usando algo como frequency
   shift keying (FSK). En realidad, nuestros discos no hacen esto, pero
   si nuestros modems. Usare FSK ya que es mas facil de hablar sobre el,
   y facil de entender para newbies.
   
   La forma en la que encodeamos nuestros datos es para tomar cada uno
   de los digitales y reproducir un tono analogo por algun tiempo, T,
   y algun otro tono para un cero digital, tambien por algun tiempo T.
   Quizas encodeamos 0 como 2600 Hz y 1 como 2000 Hz (el estandar de
   Kansas City para guardar info digital en un cinta de cassette es
   0 = 2400 Hz y 1 = 1200 Hz).
   
   La razon por la que estoy reduciendo esto a una analogia simple de
   audio pronto sera obvia.
   
   Si grabas en una cinta de cassette comercial con un grabador de mierda,
   donde hay periodos de silencio en tu grabacion puedes escuchar la
   sintonia original comercial. Esta se~al remanente esta alli todo el
   tiempo, no solo durante el silencio.
   
   Lo que paso es que el flujo magnetico repartido por el cabezal
   read/write de tu grabador no fue lo suficientemente poderoso para
   cambiar completamente la polarizacion de las particulas magneticas
   en el cassette por el tiempo que las particulas fueron expuestas.
   Esas particulas actuan de una manera predecible, y si conocemos
   su estado actual, y la se~al aplicada a ellas la ultima vez,
   podemos recuperar el estado previo. Calza esto sobre un histeresis
   magnetico, puede tambien ser debido al cabezal del grabador no esta
   alineado perfectamente. Mas sobre esta opcion a continuacion.
   
   Si una particula en un disco tiene una fuerza de polarizacion actual
   de A, y nosotros sabemos que tipo de flujo fue aplicado a la particula
   (que podemos encontrar examinando el cabezal read/write) entonces
   podemos averiguar el estado de la particula antes de la ultima
   escritura a el, que nos permite reconstruir los datos.
   
   La recuperacion de bits del mundo real simplemente podra requerir
   el mirar a estas particulas y tener en cuenta la combinacion usada.
   La documentacion del SFS (Secure File System) da una buena descripcion
   de varias combinaciones diferentes de encodeo.
   
   Como dije, este es un ataque teorico, no estoy al tanto de si 
   ha sido utilizado siempre para recuperar datos.
   
   Como podemos vencer a este ataque? Sobreescribiendo los datos varias
   veces.
   
   Si sobreescribimos nuestros datos varias veces, la carga guardada en
   la particula se acerca constantemente al valor ideal sobre el final,
   que disfraza los datos "debajo". Podemos usar varias aplicaciones
   de bits al azar, y luego varias aplicaciones de 00h's y FFh's para
   sobreescribir los datos.
   
   Los bits al azar aseguran que el atacante no encuentra un patron.
   Las aplicaciones multiples de FF exponen las particulas para el
   flujo magnetico por un largo periodo de tiempo. Cada aplicacion
   tiene a esas particulas cerca y mas cerca a la representacion ideal
   de FF. El realmente paranoico querra hacer todo esto varias veces.
   Algunos recomiendan escribir ceros despues de los unos. Esto es
   probablemente pura paranoia, y podria ser una buena idea.
   
   Como alucion a lo anterior, hay otro tipo de remanencia de datos
   que pueden ser atacados en el lab debido a la variacion en la
   posicion del cabezal read/write.
   
   Como los rollos del disco, el cabezal flotara sobre porciones
   diferentes del disco cada revolucion. Cuando ocurre una escritura,
   puede cargar ciertas particulas y sobre sobreescribirlo puede
   fallar alguna de esas particulas, dejando la informacion original
   detras para explotacion por el lab. Esto deja a un atacante
   leer mas adelante en el registro de datos que por escardar
   se~ales por cancelacion, y es probablemente mas facil de llevar
   a cabo en algunos respectos.
   
   No tenemos control sobre esto sea cual fuere el software. Para
   protegerse contra este ataque se requiere o desimantamiento del
   medio, o encriptacion del dispositivo entero desde el primer momento
   es utilizado hasta el ultimo.
   
   Usando estampas de encriptacion fuera de todos los problemas 
   anteriores en un golpe limpio y elegante.
   
   Imagina un dispositivo que se coloque en linea entre tu adaptador
   IDE (o SCSI) y el controlador de disco del dispositivo. Todos los
   intentos de la PC de negociar con el dispositivo son interceptados
   por el dispositivo en el medio, y los datos o son encriptados o
   desencriptados como es necesitado y enviado a lo largo. De este modo
   todo lo que toco el dispositivo: formateo de sistema de archivos,
   el SO ... todo se encripta y se guarda. La operacion entera puede
   ser transparente a la computadora host, e independiente de su
   procesamiento. El usuario simplemente da una llave a este controlador
   en el arranque: quiza haya un keypad metido en una ranura que esta
   montada en la carcasa de la computadora.
   
   Tal solucion por hardware no solo se encarga de las cosas de
   remanencia de datos sino que tambien ayuda a asegurar la computadora
   en un todo: con la tabla de particion, y el SO encriptado, la maquina
   no puede bootear sin el usuario teniendo que configurar el filtro
   en linea con la llave correcta.
   
   Puede un buen adversario derrotar a un ataque de laboratorio como los
   discutidos aqui? Probablemente. Por lo que si no estas usando alguna
   forma de encriptacion, podrias empezar a pensar en ella. Por las cosas
   que nadie sabe excepto tu, mantiene el texto plano en floppies y el
   texto cifrado en tu disco rigido. Los floppies pueden ser destruidos
   o desimantados facilmente. Recuerda mirar en tu particion swap;
   es probablemente sabio desenganchar la swap cuando se esta manipulando
   material sensible. Lo mejor de todo, la RAM es barata. Compra 256M
   y dale espacio swap completamente.
   
   Contra un atacante suficientemente poderoso quien tiene tu disco
   rigido, estas es un mundo de dolor sin encriptacion en linea.
   El cuan poderoso "suficientemente poderoso" necesita ser para
   hacer que esto funcione realmente esta abierto a especulacion.
   
   Notas:
   1. NCSC-TG-025 "A Guide to Understanding Data Remanence in Automated
   Information Systems" http://www.geekstreet.com/green.html
   
   2. Esto fue todo testeado con un kernel de linux version 2.0.35.
   No se si la 2.1.* tendra una nueva version de ext2 o no. Mira en
   el comando chattr de tu maquina, y cava en el codigo del kernel para
   ver si el codigo del ext2 hace algo o no. En 2.0.*, no hace nada.
   
   3. Sobre las utilidades No-where, obtenlas desde tu sitio de archivos
   HP favorito.
   
   4. Burn esta disponible desde los archivos Info-Mac.
   
   
   
 N. del T.: En el articulo 0x03 original de Phrack 56 se incluyen otros dos
            articulos: - 0x01 - data connections on old electromechanical 
                                exchanges
                       - 0x06 - Phrack 55 Addendum and Errata
            que no fueron traducidos.
            
            
            
 Traducido por Active Matrix - schyzophrenia@gmx.net
 Para RareGaZz - http://www.raregazz.com.ar - http://raregazz.cjb.net
 Argentina, 2002
 El articulo aqui traducido, mantiene los derechos de autor.
