


                                <<<====NeWsPaPeR====>>>               
                                ***********************
					19/12/99



Hola colegas como @ndan, espero ke todo bien  ya ke estamos llegando a las
fiestas les kiero contar ke estoy tratando de ke la e-zine salga +as o -nos
cada un mes maso menos a s1 ke y@ saves ke la tenes ke venir a buscar.

ESPERO KE TU TE HAGAS RESPONSABLE DE LAS PROPIAS ACCIONES KE TIENES EN LA RED 
POR KE NO ME KIERO HACER CARGO DE KE UNA PERSONA SE KISO HACER EL VIVO EN LA
RED Y ME MANDEN EN CANA A MI ESCUCHARON!!!!!!!!!!!!

>>>>>>>>>>>>>>>>>>>>>>>RECOMENDADO EL EDIT DE MS-DOS(leelo con lo ke kieras)<<<<<<<<<<<<<<<<<<<<<<<<<<

bueno cuando estaba haciendo la edicion de la revista me llegaron 2 notas nada
mas no me escribiste lector.(por hay la estoy haciendo para mi solo)



|||||||||||||||||||||||||||||||||>CoNsUlTa<||||||||||||||||||||||||||||||||||||
				=============

TE GUSTA LA E-ZINE????????
TE GUSTARIA KE MUERA????????

BUENO ESPERO KE TE GUSTE LA E-ZINE Y KE NO KIERAS KE MUERA A SI KE COMENTA A LA
GENTE KE TIENES CERCA, EN EL CANAL DE IRC KE SUELES ESTAR EN DONDE SE TE OCURRA
PERO KE NO SEA UNA PERSONA KE..............
YA SAVES.

|||||||||||||||||||||||||||||||>FiN_dE_cOnSuLtA<|||||||||||||||||||||||||||||||


Este numero se lo dedico a los colaboradores y a las personas ke me ayudaron a 
instalar el linux, ya que ahora estoy trabajando en linux(muy poco) y la garcha
que nunca vamos a dejar de usar.
Espero ke consigan una distribucion de linux y se la instalen es muy copado pero
a su ves un pokito dificil asi ke hay que provar.
AAAAAAAA me olvidava les kiero comentar ke tambien se lo dedico a una minita ke
me estoy por agarrar pero es mas grande y ensima esta jugando con migo. :-(


************************EDICION NAVIDEÑA************************
Vamos todavia se acerca La navidad y el Año nuevo vamos carajo
vamos a festejar con miles de descorchasos.
vamos a enborracharnos y estar con las personas ke keremos
vamos a estar con nuestras mujeres(lo mejor)
************************EDICION NAVIDEÑA************************





bueno vamos a lo ke todos keremos.

			####################################
                        #               INDICE             #
                        #                                  #
                        #          OTRA VEZ NOSOTROS       #
                        #          HACK  WEB  PAGE`S       #
			#       ATAKES A SERVERS NT        # 
			#      CURSO DE LINUX INTENSIVO    #
			#       HISTORIA DEL PHREAK        #
			# NUESTRAS HUELLAS EN LOS SISTEMAS #
                        #              DESPEDIDA           #
			####################################





¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬


  ---------------------------------\               /-------------------------------
				        NOSOTROS
					°°°°°°°°

Bun0 espero ke esten pasando un buen fin de año y unas buenas fiestas junto a los ke kieren
ESTOY RE CONTENTO POR KE VAMOS A CHUPARRRRRRRRR APLENO!!!!!!!!!!!!!!!!!!!!!!
bueno esta e-zine numero 3 tubo bastantes colaboradores espero ke crescan, aki va una lista 
de los ke trabajamos en esta edicion:

Edicion y Texto
°°°°°°°°°°°°°°°
CamaleonV5

Edicion y Articulos
°°°°°°°°°°°°°°°°°°°
Duvahazard
Mr. Nuk3m
Cyborg

Gracias a todos.
Bueno pasemos a los articulos.


  ---------------------------------\               /-------------------------------
				    HACK WEB PAGE´S
				    °°°°°°°°°°°°°°°
				     by  Duvahazard


      "Lo espantoso no es la altura, sino la pendiente.
       La  pendiente  donde la mirada se precipita a lo hondo y la  mano
       se extiende hacia la cumbre. Alli es donde se apodera del corazon
       el vertigo de su doble voluntad." -Federico Nietzsche

1. Introduccion
^^^^^^^^^^^^^^^
 Si alguna vez  has  hechado a volar tu imaginacion  se te habra ocurrido que
 seria  comico remover algunas graficas de algun website,  o mejor aun borrar
 toda la pagina de algun enemigo para deleitarte con tu venganza.  Pues bien,
 este es el manual que te ayudara a lograrlo.
 Primero  deberas  entender que andar por ahi  borrando paginas es *TONTO*  e
 inmaduro. Lo que trato de hacer es que sientas la adrenalina de entrar a  un
 sistema  al que no estes  autorizado  y  echar una ojeada alrededor.  Si  te
 dedicas a invadir  sistemas y borrar  archivos le  quitaras  el privilegio a
 otra persona de entrar a ese sistema ya que el operador se dara cuenta de la
 intrusion y aumentaran la seguridad negando asi la entrada a mas 'intrusos'.
 Si el sistema al que entraste pertenece a unos hijos de la chingada (Plantas
 Nucleares, Creadores de abrigos de piel, Agencias de Gobierno,etc) olvida lo
 antes dicho y haz que  se arrepientan de haberse conectado a la red causando
 kaos o mejor aun, infectandolos con algun buen virus  (por que no reemplazar
 un ejecutable por un caballo de troya?). En fin, usa tu cabeza y cuida de no
 ser sorprendido en tus viajes de kAoS.

2. Websites
~~~~~~~~~~~
 Un website es solamente una computadora llamada servidor por su capacidad de
 de  realizar  diferentes  tareas al  mismo  tiempo,  ejecutando  un  sistema
 operativo que generalmente sera UNIX o algunas de sus variaciones y con toda
 la informacion guardada en algun medio.

2.1 Ganando acceso a un servidor WWW
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 Aqui reside la magia del Hacker, la proteccion comun son dos preguntas Login
 y Password.  El usuario que tenga una cuenta en ese servidor tiene un nombre
 de  usuario  (Login)  y contrase¤a (Password)  por lo que la entrada  a  ese
 servidor no tiene problemas;  pero  para una persona ajena a ese servidor la
 entrada es un poco mas complicada.
 Para poder penetrar el sistema necesitamos saber su URL y una vez conectados
 con  el explorador prestar atencion al mensaje  waiting reply from 103.38.28
 o algo parecido que haga aparecer una direccion IP en  lugar de el nombre de
 dominio.
 Si  lograste  conseguir  la  direccion IP usa telnet para conectarte  a  esa
 direccion.  Si  cuando  tratas  de conectarte aparece el mensaje 'connection
 refused' probablemente  este protegida  esa  direccion con una FIREWALL.  Si
 este es el caso trata de hacer telnet a el nombre de dominio con la finalidad
 de llegar a el frustrante LOGIN/PASSWORD.
 Para  entrar  necesitas conseguir alguna cuenta haciendo algo de  ingenieria
 social o intenta con los defaults.


                           * CUENTAS DEFAULTS DE UNIX *

Login:                         Password:

root                                    root
root                                    system
sys                                     sys
sys                                     system
daemon                                  daemon
uucp                                    uucp
tty                                     tty
test                                    test
unix                                    unix
unix                                    test
bin                                     bin
adm                                     adm
adm                                     admin
admin                                   adm
admin                                   admin
sysman                                  sysman
sysman                                  sys
sysman                                  system
sysadmin                                sysadmin
sysadmin                                sys
sysadmin                                system
sysadmin                                admin
sysadmin                                adm
who                                     who
learn                                   learn
uuhost                                  uuhost
guest                                   guest
host                                    host
nuucp                                   nuucp
rje                                     rje
games                                   games
games                                   player
sysop                                   sysop
root                                    sysop
demo                                    demo


 Si  fracasas al intentar el acceso usando cada uno de los anteriores logins,
 probablemente tengas que conseguir el password de otra manera como relaciones
 humanas; esto significa que vas a tener que conseguir la clave valiendote de
 trucos como hablar por telefono a una persona que sepas que esta  registrada
 en ese servidor y pedirle su Login y Password diciendo que necesitas validar
 su cuenta o algo parecido. Otra manera de conseguir un Password es crear  un
 programa que robe las claves de acceso del disco duro de una persona.

3. Cuando se esta adentro
~~~~~~~~~~~~~~~~~~~~~~~~~
 Una vez que hayas logrado entrar a un sistema necesitaras localizar y obtener
 el archivo passwd disponible en el directorio /etc

 Para obtener el archivo PASSWD usa el siguiente ejemplo:
 ($ simboliza el prompt UNIX)

 $ ftp
 FTP> get /etc/passwd
 FTP> quit

 Para ver el contenido de el archivo usa el siguiente comando:

 $ cat /etc/passwd
  
 Una  vez  que tengas en tu posesion el archivo PASSWD editalo y fijate en su
 contenido, debera tener la siguiente informacion:

       usuario:contrase¤a:ID:Grupo:descripcion/nombre:directorio:shell

usuario    - Este es el login de algun usuario.
contrase¤a - Es el password de el usuario (encriptada con DES)
ID         - Es la identificacion de ese usuario.
grupo      - El grupo al que pertenece esta cuenta.
descripcion- El nombre del usuario.
directorio - El directorio de acceso de el usuario.
shell      - El shell que procesa los comandos de ese usuario.

 Un ejemplo podria ser:

    john:234abc56:9999:13:John Johnson:/home/dir/john:/bin/john

Nombre de usuario: john
Password encriptado: 234abc56
Usuario numero: 9999 
Numero de grupo: 13
Descripcion: John Johnson
Directorio de acceso: /home/dir/john
Shell: /bin/john

 Si el archivo que conseguiste contiene la misma informacion pero en el campo
 del password tiene un asterisco (*) o cualquier otro caracter, significa que
 las contrase¤as se encuentran 'sombreadas'.
 Si las contrase¤as se encuentra sombreada,las podras encontrar en el archivo
 shadow aunque generalmente no se puede tener acceso a ese archivo a menos de
 tener root.  Una  forma  de  conseguir SHADOW es usando el comando  cp  para
 copiarlo  a  otro archivo y  despues tratar de obtener el archivo al que  se
 copio, ejemplo:

 $cp /etc/shadow /usuarios/carlos/hack.txt
 $ftp
 FTP> get /usuarios/carlos/hack.txt
 FTP> quit
 $rd /usuarios/carlos/hack.txt

 Mas adelante pondre como descubrir el SHADOW

 Ya tengo los passwords encriptados, ahora que?
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 Los passwords estan encriptados usando one-way encription, significa que  no
 se  pueden  des-encriptar.  Lo que Unix hace es obtener  la  contrase¤a  del
 usuario,la encripta y la compara con la que ya esta encriptada, si coinciden
 entonces se le permite el acceso.

 Para poder obtener las contrase¤as es necesario tener un archivo con palabras
 y usar un programa para que encripte las palabras del archivo  y las compare
 con las contrase¤as encriptadas,si coinciden te avisa que palabra fue la que
 coincidio con la contrase¤a encriptada.
 Algunos programas de este tipo son:

 Nombre            Palabras por Segundo    Computadora

 John the Ripper          5077                 586
 Starcracker              1300                 586
 Cracker Jack             1008                 586
 KillerCracker             350                 586

 Estos programas se encuentran disponibles en cualquier pagina de Hackers, si
 quieres la ultima version de StarCracker visita la siguiente URL:
 http://www.geocities.com/SiliconValley/park/8403/index.html

 Para conseguir listas de palabras haz FTP a el siguiente servidor:
 warwick.ac.uk
 directorio: /pub/cud

 Algunas de las palabras mas usadas en contrase¤as son:
      
      aaa            academia          ada            adrian
      aerobics       airplane          albany         albatros
      albert         alex              alexander      algebra
      alias          alisa             alpha          alphabet
      ama            amy               analog         anchor
      andy           andrea            animal         answer
      anything       arrow             arthur         ass
      asshole        athena            atmosphere     bacchus
      badass         bailey            banana         bandit
      banks          bass              batman         beautiful
      beauty         beaver            daniel         danny
      dave           deb               debbie         deborah
      december       desire            desperate      develop
      diet           digital           discovery      disney
      dog            drought           duncan         easy
      eatme          edges             edwin          egghead
      eileen         einstein          elephant       elizabeth
      ellen          emerald           engine         engineer
      enterprise     enzyme            euclid         evelyn
      extension      fairway           felicia        fender
      finite         format            god            hello
      idiot          jester            john           johnny
      joseph         joshua            judith         juggle
      julia          kathleen          kermit         kernel
      knight         lambda            larry          lazarus
      lee            leroy             lewis          light
      lisa           louis             love           lynne
      mac            macintosh         mack           maggot
      martin         marty             marvin         matt
      master         maurice           maximum        merlin
      mets           michael           michelle       mike
      minimum        nicki             nicole         rascal
      really         rebecca           remote         rick
      reagan         robot             robotics       rolex
      ronald         rose              rosebud        rosemary
      roses          ruben             rules          ruth
      sal            saxon             scheme         scott
      secret         sensor            serenity       sex
      shark          sharon            shit           shiva
      shuttle        simon             simple         singer
      single         singing           smile          smooch
      smother        snatch            snoopy         soap
      socrates       spit              spring         subway
      success        summer            super          support
      surfer         suzanne           tangerine      tape
      target         taylor            telephone      temptation
      tiger          tigger            toggle         tomato
      toyota         trivial           unhappy        unicorn
      unknown        urchin            utility        vicki
      virginia       warren            water          weenie
      whatnot        whitney           will           virgin
      william        winston           willie         wizard
      wonbat         yosemite          zap            whatnow


De ^DuVaHaZaRd^ para NeWsPaPeR.
Biohazard@uol.com.ar

Aclaracion: Yo he leido esto de otras magazines y he puesto lo que entendi. 
(he copiado las palabras que son mas usadas en las contrase¤as).



  ---------------------------------\               /-------------------------------
				   ATAKES A SERVER NT
				   °°°°°°°°°°°°°°°°°°

En este texto vamos a explicar las formas que hay para que nos ataquen nuestro servidores NT. Este texto quiere informar a la
gente los posibles ataques, pero no enseñan a como defenderse de ellos, a lo mejor, un día de estos me apetece y hare un
articulillo de seguridad. Lo primero que se suele hacer es un scan de puertos para saber los puertos abiertos y que servicios
estan corriendo en ellos y versión. 

Despues de haber realizado un scan de puertos suelen realizar los siguientes pasos: 

1.- Ver si el objetivo tiene recursos compartidos. 

Me parece que hace no falta hablar de esto. Aunque teneis un articulo por la pagina sobre este tema, sino esta es que se nos
habra olvidado ponerlo. 

                          nbtstat -A 192.168.234.25 
                          nbtstat -a  www.victima.com 

Y luego a utilizar comandos NET, no hace falta explicarlos teneis una ayuda de ellos en el MSDOS. Recordad que los
sistemas NT posee recursos compartidos ocultos que no salen al utilizar los comandos NET. Algunos ejemplos de NET
pueden ser. 

NET  localgroup -->         Grupos creados que hay en el equipo 
NET  name ------->          Muestra el nombre del ordenador y quien hay dentro. 
NET accounts ---->          Muestra las restriciones de password del usuario. 

2.- Utilizar la herramienta NAT. 

Que nos permite ver recursos compartidos en el ordenador de la victima, pasar unos diccionarios de login y pass y hacer el
scan en un rango de ordenadores. Bastante majo, y ahora con shell para windows, para un facil manejo, genera un log para ver
los resultados. Uso: 

    NAT [-o ficheroLOG] [-u ficheroLogin] [-p ficheropass] ip ó rango de ips 

Lo bueno de esta herramienta es que tambien chequea los recursos ocultos de los NT. 

3.- Extensiones del FRONTPAGE. 

Esta forma de ataque es que podemos acceder al directorio wwwroot y poder modificar una pagina HTML. A continuacion os
pongo la lista de donde pueden estar los ficheros localizados en el HD de victima.com: 

C:\InetPub\wwwroot                                             <Home> 
C:\InetPub\scripts                                                   /Scripts 
C:\InetPub\wwwroot\_vti_bin                                /_vti_bin 
C:\InetPub\wwwroot\_vti_bin\_vti_adm                  /_vti_bin/_vti_adm 
C:\InetPub\wwwroot\_vti_bin\_vti_aut                   /_vti_bin/_vti_aut 
C:\InetPub\cgi-bin                                                 /cgi-bin 
C:\InetPub\wwwroot\srchadm                                /srchadm 
C:\WINNT\System32\inetserv\iisadmin                   /iisadmin 
C:\InetPub\wwwroot\_vti_pvt 
C:\InetPub\wwwroot\samples\Search\QUERYHIT.HTM   Internet Information Index Server sample 
C:\Program Files\Microsoft FrontPage\_vti_bin 
C:\Program Files\Microsoft FrontPage\_vti_bin\_vti_aut 
C:\Program Files\Microsoft FrontPage\_vti_bin\_vti_adm 
C:\WINNT\System32\inetserv\iisadmin\htmldocs\admin.htm  /iisadmin/isadmin 

Usando el Frontpage se puede modificar una page, los pasos que siguen para modificar una página son los siguientes: 

En el menu File del explorador del frontpage, elegimos abrir pagina web y elegimos la web de frontpage y damos a OK. Si te
pide el nombre del autor y el pass hara falta descriptar el service.pwd 
Entramos el nombre y el pass que nos pide y pulsamos OK, alteramos la pagina existente y subimos nuestra modificacion. 
Escaneando el puerto 80 o el 443 por telnet podemos poner lo siguiente para conseguir el nombre y el pass: 

GET    /_vti_inf.html                                Asegura que tiene las extensiones frontpage 
GET    /_vti_pvt/service.pwd                   contiene el pass encriptado 
GET    /_vti_pvt/authors.pwd                  Encriptados nombres del autor y el pass 
GET    /_vti_pvt/administrators.pwd 
GET    /_vti_log/author.log 
GET    /samples/search/queryhit.htm 

Otras formas de conseguir este archivo es con los buscadores, prueba a buscar: 
                                                   "/_vti_pvt/service.pwd"

Podemos conectarnos por ftp al puerto 21 
 Login : anonymous 
 Pass : guest@unknown 
Este login es usado por la cuenta creada IISUSR_nombredelordenador 

La forma que tiene el archivo service.pwd es: 
                                         CyBoRg:DFBTF323O7S1zxE

Queda pasar este pass a un formato DES: 
                       CyBoRg:DFBTF323O7S1zxE:10:200:CyBoRg:/users/CyBoRg:/bin/bash

Ya solo te queda correr un programita como el John de Ripper y listo. 

4.- Fallos en el registro. 

Si utilizamos RDISK /s nos hace una copia del registro para hacer un disquete de emergencia, esta informacion esta en
\winnt\Repair. Hay utilidades para realizar esto. Para realizar esto hay muchas utilidades.. 
  

Como ganar acceso al registro entero en un equipo local. Para poder realizar esto es necesario arrancar el servicio Schedule.
Esta configurado como manual. Asi que os vais a panel de control/servicios, selecionais SCHEDULE le dais a comenzar
inmediatamente y ya ta activado. Este servicio es el famoso AT. 
Bueno que hacemos ahora, tecleamos desde la linea de comandos: 

                at <hora> /interactive "regedt32.exe" 

Y os saldra una cosa asi, si lo habeis echo bien claro: 
  
 Añadido nuevo trabajo con trabajo ID = 0 

Para acceder al registro remotamente, leete el articulo que hay por la page, pero recuerda que tienes que ser administrador
para poder abrirlo. Pero solo podras leer estas hive: HKEY_CURRENT_USER y HKEY_LOCAL_MACHINE. Por ahora
basta. 

5.- Buscar equipos que tenga instalados Wingate. 

El wingate tiene unos fallos de seguridad que si no estan cerrados podemos realizar algo con ellos. 

     - Puerto 23. si encontramos un ordenador con wingate podemos ejecutar telnet al puerto 23 del ordenador con el wingate y
entraremos sin que nos pida pass. 

     - Puerto 1080. Si entramos por telnet tampoco pide pass. 
     - Puerto 6667, el puerto del IRC, esto nos servira para hacer un bouncer de irc. Como? 

Cogemos la ip del servidor o persona que tenga el wingate y en irc en setup en server ponemos dicha ip, damos a conectar o
lo hacemos desde la pantalla status: 

   1. /server ipdel wingate 
   2. /quote irc.arrakis.es 6667 
   3. /quote user pepe pepe pepe@server.com pepe 
   4.  /quote nick pepe 

A continuacion pongo un script para el mirc, que detecta que personas utilizan un bouncer wingate y lo kickea y banea. 

------ EMPIEZA AQUI ------------ 
alias telnet .msg $me $chr(1) $+ DCC CHAT CHAT $longip($$1) $$2 $+ $chr(1) 
alias removenickcheck unset %lastjoined $nick 
alias gatekick { 
  set %nick $$1 
  set %chan 0 
  :loop2 
  inc %chan 1 
  if (%nick ison $chan(%chan)) { 
    mode $chan(%chan) -o %nick 
    ban $chan(%chan) %nick 2 
    kick $chan(%chan) %nick -=_Wingate Spoof_=- 
    goto loop2 
  } 
  if ($chan(%chan) == $null) { goto end2 } 
  goto loop2 
  :end2 
  unset %nick 
} 
#spoofcheck on 
on 1:JOIN:%protchans:set %gatenick $nick | set %lastjoined $nick | timer 1 3 removenickcheck | write $mircdirips.txt
%gatenick --> $site <--   [ $time, $date ] | dns $nick 
on 1:DNS:echo -a _DNS ON [ $+ $nick $+ ]] | echo -a _IP address: $iaddress | echo -a _Name address: $naddress | set
%gateip $iaddress | set %gatename $naddress | telnet %gateip 23 | timer66 1 15 close -c 
on 1:CHATOPEN:msg =$nick gatecheck | timer66 1 15 close -c 
on 1:CHAT:*WinGate>*:gatekick %gatenick | write $mircdirgate.txt %gatename = %gateip 
on 1:CHAT:*many*:gatekick %gatenick | write $mircdirgate.txt %gatename = %gateip 
#spoofcheck end 
#gateslip on 
on 1:NICK:{ 
  if ($nick == %lastjoined) && ($nick != $me) { 
    echo 4 -a (-=_GateSlip Check_=-) 
    kick %protchans $newnick -=_GateSlip_=- 
    removenickcheck 
  } 
} 
#gateslip end 
---------- FIN ------------ 

Hay mas formas pero lo dejaremos para otra ocasion, hay muchas herramientas para tratar el registro remotamente. y mas
cosas, pero bueno por ahora no me apetece escribrir mas. Ultima cosa tambien se pueden introducir entradas en el registro, es
decir, escribir en el registro, pero bueno. Colocar troyanos, etc

By Cyborg.

  


---------------------------------\               /-------------------------------
                                  (B3G1N 0F F1l3) 


                         Descubriendo Linux Red Hat 5.0
                         ------------ ----- --- --- ---
                                 By Mr. Nuk3m 
                                 -- --- -----

 Hola a todos los que estan leyendo esto, yo soy Mr. Nuk3m y voy a tratar
 de escribir un manual del sistema operativo Linux Red Hat 5.0. Disculpen
 las faltas de ortografia pero no voy a poner acentos, salvo las e¤es
 para que todos puedan leer este texto sean usuarios de Windows o Linux :)
 Me reservo los derechos de autor de este manual por lo que si quieren hacer
 modificaciones, avisen primero. Este texto es de libre distribucion, siempre
 y cuando aparezcan estas lineas y mi nombre, Mr. Nuk3m. 

 A continuacion un indice para que puedas buscar lo que te interesa saber
 de Linux Red Hat 5.0:

  Contenido

   Introduccion (lo esta leyendo)

   1. Caracteristicas Del Sistema Operativo (S.O.) Linux
      1.1  Principales Caracteristicas
           1.1.1  Linux y los sistemas de Microsoft
           1.1.2  Linux y los sistemas de archivos
           1.1.3  Linux y las redes
           1.1.4  Linux y la interconeccion con otros sistemas
      1.2  Caracteristicas de Hardware requerido y soportado
           1.2.1  Hardware requerido por Linux en maquinas con arquitecturas
                  Intel 80x86
           1.2.2  Hardware soportado por Linux
   2. Estructura General Del Sistema De Archivos
      2.1  Sistema De Archivos
           2.1.1  Nombres de archivos
           2.1.2  Atributos de los archivos
           2.1.3  Directorios
           2.1.4  Estructura del sistema de archivos
           2.1.5  Rutas dentro del sistema de archivos
           2.1.6  Los "links" y los archivos
      2.2  Estructura General De Un Sistema De Archivos Linux
   3. Usuarios, Permisos y Grupos
      3.1  Permisos de acceso
      3.2  Directorio "home" y permisos predefinidos
   4. Dispositivos De Entrada-Salida
      4.1  Conceptos Fundamentales
           4.1.1  Puertos de entrada-salida
           4.1.2  Iterrupciones e IRQ's
           4.1.3  Accesos Directos a Memoria (DMA)
      4.2  Tratamiento de los dispositivos en Linux
           4.2.1  Archivos de los dispositivos mas comunes
   5. Programas y Procesos
      5.1  Ejecucion en primer plano y en "background"
      5.2  Demonios
   6. La Interaccion Con El Sistema. Shell y Comandos
      6.1  La Shell
           6.1.1  Funcionamiento de la shell
      6.2  Comandos
           6.2.1  Comandos simples
           6.2.2  Separador de comandos
      6.3  La Entrada Estandar y La Salida Estandar
           6.3.1  Redireccionando la salida
           6.3.2  Redireccionando la conexion de errores estandar
           6.3.3  Redireccionando la entrada
      6.4  Ca¤erias
      6.5  Generacion De Nombres De Archivos
   7. Comandos Y Utilidades
      7.1  Movimiento En El Sistema De Archivos
      7.2  Listado De Archivos
           7.2.1  Moviendo y copiando archivos
      7.3  Manipulando Archivos
           7.3.1  Moviendo y copiando archivos
           7.3.2  Realizando links
           7.3.3  Eliminando archivos
      7.4  Manipulando Directorios
           7.4.1  Creando directorios
           7.4.2  Eliminando directorios
      7.5  Busqueda De Archivos
           7.5.1  Ejemplos del uso de find
      7.6  Cambiando Permisos, Grupos y Due¤os
           7.6.1  Averiguando los derechos de acceso de un archivo
           7.6.2  Cambiando los permisos
           7.6.3  Cambiando el due¤o y el grupo de los archivos
        
  Empecemos con una pregunta clasica, ¨ Por que Linux y no otros S.O. ?

 Existen una serie de problemas que son comunes a los sistemas operativos
 comerciales y aquellos que, basicamente tienen las siguientes caracteristicas:

  * Cuestan mucho dinero (mas de U$S 50).
  * El codigo fuente del S.O. no esta disponible.
  * Existen limites extrictos en cuanto a la copia del sistema se refiere.

 Consecuentemente, Windows, MacOS, DEC, Ultrix, Solaris, OS/2 son sistemas
 operativos comerciales. Linux y FreeBSD son gratituos; estan disponibles
 generalmente por el costo del medio (CD-ROOM, DISQUETTES, ETC) en que se
 distribuye, el codigo fuente esta disponible y existen pocas limitaciones
 en cuanto a su distribucion. Dado que los sistemas operativos comerciales
 son la fuente de ingreso de las companias que desarollan estos sistemas,
 se dan algunas situaciones que no son ventajosas para el usuario final de
 la computadora. Algunos de estos problemas se deben a la necesidad de
 proteger y mantener en secreto el codigo fuente, como ser:

  * SE ACTUALIZA LENTAMENTE: Los S.O. comerciales como Windows, etc.
    realizan actualizaciones importantes cada 2 o 3 a¤os (Windows 3.11,
    Windows 95, Windows 98 y proximamente Windows 2000), mientras que
    existen lanzamientos de las mayores distribuciones de Linux (Red Hat,
    Debian, SlackWare) cada 6 u 8 meses y se publica en Internet una version
    nueva del Kernel por semana, aproximadamente.

  * ALTO COSTO: Una copia y un numero limitado de licencias de cualquier
    sistema operativo comercial (especialmente para servidores) cuesta mas
    o menos U$S 400 dolares y casi nunca incluyen herramientas de desarrollo,
    como servidores de mail, de web, compiladores C, C++, etc.

  * SOPORTE TECNICO: Los compradores de S.O. comerciales dependen
    exclusivamente del servicio tecnico que brinda la compania en cuestion,
    incluso realizando costosas llamadas telefonicas. En la vereda de enfrente
    y de una forma descentralizada, existen una gran cantidad de puntos de
    consulta para Linux, ya sean organizaciones dedicadas o particulares
    experimentados.

 Se agregan, ademas, un par de problemas que se aplican casi exclusivamente
 al sistema Windows de Microsoft, veamos esto:

  * OBSOLENCIA DEL HARDWARE: No se mantiene compatible con los sistemas
    anteriores. Se dice que es tecnicamente posible "correr" Windows 95
    sobre una PC 386 a 25 Mhz, pero podemos comprobar que hacerlo sobre un
    harware anterior a una PC 486 DX2 a 66 Mhz con 16 Mb de Ram es un
    ejercicio masoquista :) Y es aca donde el costo aparece nuevamente como
    un factor importante a considerar.

  * PROPENSO A FALLOS: No es raro observar que Windows se "CAE" sin razon
    aparente, y la experiencia personal de quien alguan vez uso un Windows
    lo ha demostrado con creses. Aunque su hermano mayor, Windows NT, es
    bastante mas estable, todavia se caecon una frecuencia mayor a la que
    cualquier usuario espera. Hay casos documentados donde servidores Linux
    han estado operando por mas de 1 a¤o sin caida alguna :)

 Caracteristicas de Linux

 Ventajas

  * ADECUADO PARA LA COMUNICACION EN RED: Dado que Linux fue desarrollado por
    un grupo de programadores de Internet, se le dio una prioridad mayor a
    las propiedades  de networking. Estas propiedades funcionan muy bien aun
    con configuraciones de hardware minimas. Se lo utiliza tanto de cliente
    como de servidor de otros S.O. populares; incluso puede ser utilizado por
    los proveedores de Internet. Soporta todos los protocolos mas utilizados
    (TCP/IP, FTP, Samba, Apple Talk, etc).

  * MULTIUSUARIO - MULTITAREA: Sigue la filosofia Unix, lo cual es ventajoso
    incluso si lo utiliza una sola persona, dado que las tareas se ejecutan
    con una proteccion mayor; ademas un mismo usuaro puede estar ejecutando
    varias tareas concurrentemente. Linux tiene la capacidad de manejar todo
    ese "trafico" de informacion.

 Falencias

  * INTERFACE DE USUARIO INCONSISTENTE: GNU/Linux refelja el trafico de varios
    programadores, cada uno con metas de dise¤o diferentes, interfaces
    diferentes, etc. Incluso no existe una restriccion de consistencia entre
    utilidades de una misma distribucion. Esto puede llevar a confusiones y
    frustraciones. Actualmente, se estan llevando a cabo proyectos para
    promover interfases graficas consistentes a traves del sistema XWindows
    (KDE, GNOME, Teak, etc).

  * PAQUETES REPETIDOS: Dentro de una distribucion se pueden encontrar una
    gran cantidad de paquetes "repetidos"; cumplen uan misma funcion, pero
    fueron dise¤adas por distintas personas, con objetivos de dise¤o. Por
    ejemplo: se pueden encontrar varios agentes de transmision de mail como
    el sendmail, smail, qmail, exim, etc.

  * FALTA DE APLICACIONES COMERCIALES: No se han desarrollado grandes suites
    de aplicaciones, aunque en Internet podemos encontrar el Star Office para
    Linux ;)

 Conclusion

 El numero de usuario de Linux esta creciendo rapidamente. Las ventajas
 tecnicas de Linux por sobre otros S.O. comerciales son muy grandes,
 importantes y evidentes. A pesar de ello, Linux todavia tiene caracteristicas
 que lo hacen un poco dificil de usar y otras que pueden hacer que Linux no
 sea el sistema adecuado al momento de elegir.

 La mayoria de las personas que hoy son usuarios de Linux, eran usuarios de
 los distintos sistemas de Microsoft (Windows, MS-DOS, etc) que se dieron
 cuenta de la potencialidad del sistema Linux y de su gran futuro. Hoy hay
 una gran tendencia a abandonar los sistemas de Microsoft y sumarse a la
 filosofia del sistema operativo Linux. Pero, cuidado, obviamente Linux no
 es el sistema ideal en todas las situaciones. No existe tal cosa como la
 MEJOR COMPUTADORA o el mejor SISTEMA OPERATIVO; todo va a depender de la
 tarea que realizemos. Por eso, no creo que Linux sea la mejor solucion para
 todos, por mas que sea tecnicamente superior a muchos S.O. comerciales.

 Un usuario se beneficiara enormemente con Linux si lo que necesita es
 software para programar :), utilizar Internet :), para procesar texto
 con "TeX", y software tecnico en genereal, pero si se necesita fuertemente
 el software comercial o si el usuario no se siente comodo aprendiendo y
 tipeando comandos, entonces debe buscar en otro lado...

 Bueno, bueno, hasta aca llego la introduccion ahora empezamos...



 CAPITULO 1

 CARACTERISTICA DEL SISTEMA OPERATIVO LINUX

 En este capitulo vamos a describir las caracteristicas del S.O. Linux. Es
 importante conocer estas caracteristicas ya que explican porque Linux es
 un sistema tan potente, versatil y nos daran una amplia vision de algunas
 de las caracteristicas internas importantes del sistema. Tambien se
 describira el hardware sobre el cual se puede ejecutar Linux y los
 distintos dispositivos de entrada/salida que son soportados por el sistema.

 Todo lo tratado en este capitulo es aplicable al sistema Linux sobre
 plataformas de la familia Intel 80386 y superiores. El nucle analizado es
 la version 2.2.5.

 1.1 PRINCIPALES CARACTERISTICAS

 Linux es un sistema operativo completo multiusuario con multitarea real.
 Esto significa que sobre una misma maquina con el S.O. Linux pueden estar
 trabajando varias personas simultaneamente y a su vez cada persona puede
 estar ejecutando varios procesos.

 Linux es un S.O. de 32 bits desarrollado para la plataforma Intel 80386.
 Fue realizado aprovechando las caracteristicas de modo protegido de este
 procesador. Asi fue posible implementar la multitarea real y otras
 caracteristicas como memoria virtual y ejecutables con carga de paginas
 por demanda. Linux es tan robusto y completo que es capaz de ser utilizado
 en maquinas en las universidades hasta en largas corporaciones en las
 cuales trabajan cientos de personas al mismo tiempo.

 El codigo del nucleo de Linux fue realizado pensado en ser compatible con
 los estandares de POXIS2 de Unix y otros. Esto quiere decir que es
 totalmente compatible con la mayoria de los sistemas Unix comerciales y
 gratituos que existen en la actualidad. De esta forma la mayoria del
 software desarrollado para otras versiones de Unix funciona perfectamente
 sobre Linux.

 El nucle es capaz de emular por su cuenta las instrucciones del coprocesador
 matematico 80387, con lo que cualquier maquina 80386 sin coprocesador podra
 ejecutar, sobre Linux, aplicaciones que requieran de estas instrucciones.
 En maquina 80486, no es necesario que el nucle emule estas instrucciones ya
 que el coprocesador se encuentra instalado en hardware como parte del
 procesador.

 Otra caracteristica muy importante del sistema es la memoria virtual, que
 permite que se puedan ejecutar programas que utilizan mas memoria de la
 disponible y que es fundamentalmente necesaria para soportar la multitarea.
 Ademas se soportan ejecutables con paginacion por demanda, esto significa
 que solo las paginas necesarias son cargadas en memoria en cada momento,
 utilizando asi mas efectivamente la memoria del sistema. Relacionado con
 esto se encuentra el concepto de area de intercambio o "SWAP" la cual se
 utiliza para almacenar temporariamente informacion que no se puede matener
 en memoria porque esta no alcanza. Esta area de intercambio es imprescindible
 en maquinas que tiene muy poca memoria.

 Fuertemente ligado a Linux, y a los sistemas Unix, esta el concepto de
 librerias dinamicas. Estas se utilizan para almacenar codigo compartido por
 varios programas en una unica libreria. Asi los programas son mas chicos y
 utilizan estas funciones.

 1.1.1 LINUX Y LOS SISTEMAS DE MICROSOFT

 Cabe destacar que Linux NO ES COMPATIBLE con el sistema MS-DOS ni con los
 sistemas Windows 95/98/NT. Los sistemas MS-DOS, Windows 95/98 son sistemas
 hibridos de 16/32 bits y los programas que se ejecutan sobre estos sistemas
 NO PUEDEN SER EJECUTADOS en Linux ya que fueron desrrollados para ser
 ejecutados especificamente en esos sistemas. En cuanto al sistema Windows NT
 es un sistema de 32 bits con un nucleo completamente nuevo y tambien es
 totalmente incompatible con Linux. Sin embargo, todos estos sistemas pueden
 convivir tranquilamente en una PC, o sea que sobre cualquier computadora, con
 suficiente espacio en el disco duro, es posible tener instalado Linux y ademas
 Ms-DOS, Windows 95/98 o NT.

 Sobre Linux, existen emuladores de MS-DOS los que permiten que ciertas
 aplicaciones de MS-DOS puedan ejecutarse sobre Linux. Uno de los emuladores
 mas conocido es el llamado "DOSEMU" y permite ejecutar aplicaciones como
 Turbo Pascal, Turbo Assembler, Harvard Graphics, etc. A su vez existe un
 proyecto llamado "WINE" (Win Emulator) para permitir ejecutar aplicaciones
 Windows sobre el sistema grafico de vantanas X Windows.

 1.1.2 LINUX Y LOS SISTEMAS DE ARCHIVOS

 Linux posee un sistema de archivos propio, no compatible con los de Microsoft,
 llamado "ext2fs" ( Extended File System 2 =). Esto quiere decir que si en una
 PC tenemos instalados los sistemas Linux y MS-DOS/Win95/98/NT desde los
 sistemas de Microsoft no podremos acceder, ni para lectura ni para escritura,
 a los sistemas de archivos de Linux.

 En cambio Linux es capaz de leer y escribir en sistemas de archivos de MS-DOS
 (FAT), de Win95 (VFAT), inclusive con nonbres largos :)) , de Win98 (FAT32),
 tambien con nombres largos =) , y de NT (NTFS). Aunque el soporte de escritura
 sobre NTFS esta, hasta el momento, desarrollado en forma experimental y se
 recomienda no utilizarlo ya que podria da¤ar la escritura de archivos de una
 particion NTFS.

 Ademas de los sistemas de archivos descriptos anteriormente, Linux es capaz
 de leer y escribir sobre particiones basadas en sistemas de archivos de MINIX,
 FFS (Fast File System), de Apple Macintosh, de los sistemas Unix SCO, System
 V, Coherent y Xenix, y UFS de BSD (Unix de Berkeley).

 Linux es capaz de leer archivos de particiones OS/2 HPFS del S.O. OS/2 de
 IBM y del ADFS (Acorn Disk file System) del S.O. de Acorn. Soporta ademas
 lectura desde los CD-ROM's sobre el sistema de archivos estandar que es el
 ISO9660.

 Ademas de esto podemos aplicar sobre el sistema de archivos ext2fs porciones
 del disco limitadas a cada usuario. Esto es conocido como "QUOTAS" y sirve
 para limitar la cantidad de espacio de espacio de almacenamiento en disco
 que cada usuario es capaz de usar.

 1.1.3 LINUX Y LAS REDES

 Cuando hablamos de redes, Linux es la opcion. No solo porque el trabajo en
 red esta altamente integrado con el sistema operativo, sino que ademas una
 infinidad de aplicaciones de libre distribucion se encuentran disponibles y
 que, mas importante aun, es totalmente robusto bajo una gran carga, lo que
 es un resultado de a¤os de desarrollo, testeo y correccion basados en el
 proyecto Open Server.

 Linux tiene realizada como parte de su nucleo una implementacion completa de
 los protocolos de la famila TCP/IP muy eficiente y con soporte para muchos
 conceptos avanzados de trabajo en redes.

 Linux puede funcionar como servidor de WWW en Internet de forma excelente. Es
 mas el servidor APACHE mediante el cual se puede instalar un servidor WWW
 sobre Linux, es el servidor de WWW mas utilizado en Internet y en Itranets
 actualmente. Ademas Linux es capaz de funcionar como cliente de WWW, ya sea
 en una maquina conectada permanentemente a Internet o mediante modem (PPP).

 Esto no es lo unico que se puede realizar con un sistema Linux. Linux es
 capaz de actuar de servidor PROXY, ser utilizado como FIREWALL, como ROUTER
 avanzado o como BRIDGE (puente). Tiene soporte para alias de IP, protocolos
 IPX/SPX, protocolos IPv6, AppleTalk, X.25, ISDN, PPP, SLIP, PLIP, etc.

 A nivel aplicaciones, Linux esta acompa¤ado de innumerables aplicaciones
 como lo son:

  * Sendmail: Puede actuar de servidor de mail, ya sea para enviar, recibir y
              realizar un sin numero de tareas relativas al correo electronico.
              Sendmail es el servidor de mail mas utilizado en Internet.

  * Ftp: Linux puede actuar como servidor o cliente de ftp (File Trasnfer
         Protocol). Un servidor de FTP es capaz de permitir que los clientes
         se conecten y recuperen archivos disponibles en el servidor.

  * Noticias (NEWS): Existen varias implementaciones del protocolo NNTP, el
                     cual sirve para permitir que una red de computadoras
                     sobre Internet intercambien articulos que cubre todo
                     tipo de topicos o tematicas.

  * DNS (Domain Name System): Un servidor DNS tiene el trabajo de traducir
                              los nombres utilizados en Internet como por
                              ejempl www.linux.org en direcciones de IP. El
                              trabajo de DNS sobre Unix/Linux lo realiza un
                              programa llamado "NAMED".

  * Telnet: Telnet es un programa que permite a una persona usar una
            computadora remota como si estuviera trabajando directamente
            sobre la misma.

 1.1.4 LINUX Y LA INTERCONECCION CON OTROS SISTEMAS

 Linux puede interactuar completamente con varios sistemas conocidos
 compartiendo archivos e impresoras en una red. Esto hace posible integrar
 una maquina Linux con cualquiera de los sistemas mas utilizados actualmente
 y permitir su total conectividad.

 Los sistemas con los que Linux puede ser usado para compartir recursos son
 los siguientes:

  * Apple: Linux soporta la familia de protocolos AppleTalk. Linux permite a
           clientes Macintosh ver recursos de un servidor Linux, asi como
           otros clientes Macintosh en una red y compartir archivos e
           impresoras desde el servidor Linux.

  * Entorno Windows: El grupo de aplicaciones SAMBA, que es provisto con el
                     S.O. Linux, permite interactuar a un sistema Linux como
                     servidor o cliente de maquinas con Windows 95/98, Windows
                     NT, DOS o Windows For Workgroups.

  * Novell Netware: A traves del protocolo IPX, Linux puede ser configurado
                    para actuar como un servidor o un cliente NCP, y
                    permitiendo asi servicios de archivos e impresoras en
                    redes Novell.

  * Entornos Unix: La manera mas conocida y eficiente de compartir archivos
                   en entornos Unix es mediante NFS (Network File Sharing).
                   Este protocolo fue originalmente desarrollado por Sun
                   Microsystems. Es una de compartir archivos entre maquinas
                   de forma que parezca que son archivos locales. Asi se
                   puede tener una maquina totalmente funcional sin necesidad
                   de tener un disco rigido instalado.

 1.2 CARACTERISTICAS DE HARDWARE REQUERIDO Y SOPORTADO

 1.2.1 HARDWARE REQUERIDO POR LINUX EN MAQUINAS CON ARQUITECTURA INTEL 80x86

 Linux requiere como configuracion minimima de hardware una maquina con
 procesador 80386 con 2 Mb de memoria RAM y 40 Mb de espacio libre en disco
 rigido y puede correr tranquilamente sobre esta configuracion. Para utilizar
 el modo grafico (vale la pena, Sistema X Windows ;) necesita al menos 8 Mb
 de RAM y 100 Mb de espacio en disco.

 Linux puede trabajar con los buses ISA, VLB (Vesa Local Bus), EISA y PCI.
 Ademas puede trabajar en sistemas con arquitectura PS/2 MCA (Micro Channel
 Architecture).

 Linux puede correr, ademas, en la familia de PC's portables, desde las 80386
 en adelante, inclusive con su sistema grafico.

 1.2.2 HARDWARE SOPORTADO POR LINUX

 PROCESADORES, UNIDADES DE PUNTO FLOTANTE Y MEMORIAS

 Es totalmente compatible con los microprocesadores 386 SX / DX / SL / DXL /
 SLC, 486 DX / SL / SX2 / DX2 / DX4 de Intel/AMD/Cyrix, Pentium, Pentium MMX,
 Pentium Pro, Pentium II y III de Intel, K5, K6, K6-2 3D de AMD, y todos los
 procesadores de la familia Cyrix.

 Linux posee emulacion de unidad de punto flotante para servir de soporte a
 los procesadores que no tiene coprocesador matematico como lo son los 386 o
 los 486/SX.

 Ademas una caracteristtica muy pontente de Linux es que se provee soporte
 para sistemas con multiples CPU's (SMP).

 Con respecto a las memorias, todas las memerias DRAM, FPM, EDO o SDRAM pueden
 ser utilizadas con Linux.

 CONTROLADORES DE UNIDADES DE DISCO RIGIDO, DISQUETTES, CD-ROM Y UNIDADES DE
 CINTA

 Linux puede trabajar con las controladoras estandar de disco IDE, MFM y RLL.
 Tambien hay soporte para interfaces IDE extendidas (EIDE), con hasta dos
 interfaces IDE y 4 discos y/o unidades de CD-ROM. Linux detectara las
 siguientes interfaces EIDE:

  * CMD-640

  * DTC 2278D

  * FGI/Holtek HT-6560B

  * RZ1000

  * Triton I y II con Bus-Master DMA

 Estas interfaces son las mas utilizadas en las computadoras personales y en
 general Linux no tendra ningun problema en detectarlas.

 Linux funcionara tambien con la interface mas moderna IDE/ATAPI, ya se para
 discos, unidades de CD-ROM, unidades de discos flexible o unidades de cinta.

 Es posible, ademas, utilizar las modernas unidades Zip de Iomega, ya sea por
 el puerto paralelo o SCSI.

 UNIDADES DE CD-ROM (NO IDE) (NO SCSI)

 Es factible (ja de donde salio esa palabra :) utilizar sobre Linux las
 siguientes unidades de CD-ROM: Aztech, Creative Labs (una cagada), Goldstar,
 IBM, Panasonic, Mitsumi, Sanyo, Sony, Teac.

 ULTRA-DMA

 Linux puede trabajar con las interfaces de disco con Ultra-DMA mas conocidas
 del mercado. (Bus-Master, VIA, etc.).

 SCSI

 Linux soporta una gran cantidad de interfaces controladoras SCSI. Entre las
 mas importantes encontramos: Adaptec, BusLogic, DTC, Future Domain, NCR,
 Seagate, UltraStor, Quantum, Iomega y Western Digital.

 ADAPTADORES DE RED

 De forma similar, Linux soporta una amplia variedad de trajetas de red
 Ethernet com lo son: 3Com, AMD, AT&T, Cabletron, DEC, Fujitsu, HP, Intel
 EtherExpress, Novell NE2000/1000, SMC, Western Digital, Zenith.

 Ademas soporta varias tarjetas de red ISDN, ARCNet, Token Ring, FDDI,
 Amateur Radio, PCMCIA, Frame Relay, como otras intefaces (que no utilizan
 tarjetas) SLIP, PPP o PLIP.

 TARJETAS DE SONIDO

 Las tarjetas de sonido mas importantes soportadas por Linux son las
 siguientes: Adlib, Crystal, Ensoniq Soundscape, Gravis Ultrasound, Logitech,
 Media TriX, Media Vision, Microsoft Sound System, OPTi, Sound Blaster (100 %
 compatibles), Turtle Beach y puertos MIDI MPU-401.

 MOUSES

 Los siguientes mouses pueden ser utilizados con Linux:

  * Mouse serie de Microsoft

  * Mouse serial de Mouse Systems

  * Mouse de Logitech serie o de bus

  * Mouse de bus de Microsoft

  * Mouse ATI XL

  * Mouse PS/2

 MODEMS

 Todos los modems internos o externos (conectados a un puerto serie) deben
 funcionar con Linux. Algunos frabricantes han creado lineas de modems que
 solo funcionan con Windows 95, por lo que hay que tener mucho cuidado al
 comprar, porque en Linux no sera posible hacerlos funcionar.

 Todos los modems que funcionan bajo interfaz PCMCIA deben funcionar en Linux.
 En lo que respecta a los Modem/Fax, necesitan software apropiado para
 funcionar, pero hay que asegurarse de que el Modem/Fax cumpla con el estandar
 de Fax Clase 2.0 porque es generalmente verdad que el software de Fax
 disponible para Unix no funciona com Modems/Fax de Clase 1.0

 IMPRESORAS

 Todas las impresoras conectadas a un puerto paralelo funcionan en Linux, pero
 al igual que los modems, algunos fabricantes han lanzado impresoras designadas
 para trabajar solamente con el sistema Windows 95.

 Muchos programas de Linux generan como salida de impresion documentos en
 formato Postscript. En general este formato es entendido solo por impresoras
 Laser y algunas otras impresoras avanzadas. Para solucionar este problema en
 Linux podemos utilizar el programa Gostscript, que es un interprete del
 formato Postscript para utilizar con las impresoras que no tiene el soporte
 para este formato. Ghostscript posee, entre otros, drivers para las
 siguientes impresoras:

  * Impresoras Apple

  * Cannon Bubble-Jet, LBP, LIPS III

  * Impresoras DEC

  * Epson 9 y 24 pines, y serie LQ.

  * Epson Stylus con color.

  * Una amplia variedad de las impresoras Hewlett Packard Deskjet, Paintjet y
    Laserjet
  * IBM, Oki, Okidata, Ricoh, Tektronix y Xerox

 SCANNERS

 Para trabajar con scanners en Linux se debe agregar el paquete SANE (Scanner
 Access Now Easy), que es posible conseguirlo gratituamente en Internet, y
 provee soporte para los siguientes scanners:

  * Adara ImageStar

  * Epson GT6000

  * Fujitsu SCSI-2 Scanners

  * Genius ColorPage, GS-B105G, GeniScan, GS-4000 y ScanMate

  * Varios HP ScanJet

  * Varios Logitech ScanMan

  * Nikon CoolScan

 OTROS DISPOSITIVOS

 Linux puede trabajar con Touch-Screens, Joysticks, Terminales en los puetos
 serie, una gran variedad de trajetas de captura de video, varios sistemas
 de manejo de energia UPS, etc.

 DISPOSITIVOS PLUG & PLAY

 PnP fue inventado por Intel y Microsoft, en parte por eso y en parte por las
 diferencias que existian con los desarrolladores de Linux por la forma en que
 se habia implementado, Linux no daba soporte a los dispositivos PnP. Pero nos
 guste, o no, la mayoria del harware, hoy, es PnP y Linux no tiene otra opcion
 que trabajar efectivamente con el PnP.

 Los Kernels actuales de Linux poseen soporte integrado para PnP. Esto favorece
 a la aceptacion de Linux porque muchas personas se rehusaban a Linux porque
 los dispositivos PnP no funcionaban. Hoy estamos en condiciones de usar
 cualquier dispositivo PnP con Linux, siempre que sea 100% compatible con algun
 dispositivo soportado por Linux.



 CAPITULO 2

 ESTRUCUTURA GENERAL DEL SISTEMA DE ARCHIVOS

 2.1 SISTEMA DE ARCHIVOS

 La parte del sistema operativo que fija como los archivos son estructurados,
 nombrados, accesidos, usados, protegidos e implementados se conoce como
 "Sistema de Archivos".

 Desde el punto de vista del usuario, el aspecto mas importante de un sistema
 de archivos es la estructura que refleja el sistema de archivos, que
 constituye un archivo, como los archivos se nombran y se protegen, que
 operaciones estan permitidas sobre los archivos, etc.

 2.1.1 NOMBRES DE ARCHIVOS

 Las reglas exactas para nombrar archivos, varian de sistema en sistema. En
 el caso de Unix es posible tener nombres de archivos de hasta 255 caracteres.
 Por lo tanto los siguientes nombres son totalmente validos:

  Tony, reporte, README.TXT, ls, cp, Resultados de la primera Fecha - Basket

 Una caracteristica importante a tener en cuenta es que en Unix/Linux cae en
 la categoria de sistemas que distinguen entre letras minusculas y letras
 mayusculas, es decir que es "case-sensitive". Por lo tanto se consideraran
 como archivos distintos los siguientes nombre:

  tony, Tony, TONY, tONY

 Muchos sistemas operativos dividen el nombre de un archivo en dos partes que
 se separan por un punto. La parte que se encuentra despues del punto se
 llama "extension". En MS-DOS, por ejemplo, los nombres de los archivos deben
 formarse con un nombre de 1 a 8 caracteres, con una extension opcional de 1
 a 3 caracteres. En Linux la extension es opcional y puede tener la cantidad
 de caracteres que el usuario quiera. Asimismo es posible definir archivos
 con dos o mas extensiones. Ejemplos:

  README.linux, linux-2.2.5.tar.gz

 En Linux no existe ninguna restriccion en las extensiones de los archivos
 que implique la asociacion del mismo con ciertas operaciones. En MS-DOS, por
 ejemplo, solo es posible ejecutar archivos con las extensiones .BAT, .EXE,
 .COM. En Linux para poder ejecutar un archivo se imponen otro tipo de
 restricciones que seran tratadas mas adelante.

 Sin embargo, algunos programas o utilidades exigiran ciertas extensiones en
 los archivos sobre los cuales se quiera trabajar. Por ejemplo el compilador
 de C de distribucion libre que viene con las distribuciones Linux, llamado
 gcc (GNU C Compiler), insistira en que los archivos fuente tengan extension
 .c al final del nombre del archivo. Hay que tener en cuenta que esto no es
 una restriccion impuesta por el S.O. sino que es el programa el que exige
 este tratamiento.

 2.1.2 ATRIBUTOS DE LOS ARCHIVOS

 Los principales atributos de los archivos en Linux tienen que ver con sus
 permisos de acceso, su propietario, grupo al que pertenece (todos estos
 conceptos se trataran mas adelante), su tama¤o en bloques, y su ultima
 fecha de modificacion.

 En el sistema MS-DOS, los archivos ocultos se identificaban con un atributo
 llamado HIDDEN. En Linux, en cambio, no existe ningun atributo especial para
 determinar cuando un archivo es oculto. La distincion se realiza sobre el
 nombre de archivo. Los nombres de los archivos que comienzan con un punto
 son considerados archivos ocultos. Ejemplos:

  .Xclients, .bash_history, .emacs

 2.1.3 DIRECTORIOS

 Con respecto a los directorios y sus nombres y sus atributos, todo lo dicho
 antes para los archivos se aplica de igual manera para los directorios, ya
 que en Linux son a su vez archivos normales.

 La estructura de directorios de la mayoria de los sistemas es una estructura
 de arbol. Esto quiere decir que se tiene un directorio raiz, el cual a su
 vez puede tener varios subdirectorios y asi sucesivamente.

 Linux Fue desarrollado con el objetivo de ser multiusuario y de su alta
 integracion en redes, por lo que uno de los objetivos fundamentales fuel el
 hacer posible el trabajo en grupos y compartir informacion. Con el modelo de
 directorios en forma de arbol es imposible permitir que se comparta
 informacion entre varios usuarios, por eso Linux fue mas alla y baso su
 sistema de archivos en la estructura de grafo aciclico (FIGURA 2.1) que es
 una generalizacion natural del del esquema de directorios jerarquico.

 2.1.4. ESTRUCTURA DEL SISTEMA DE ARCHIVOS

 En sistemas como MS-DOS las distintas unidades de disco, CD-ROM, disco
 flexible, etc., se manipulan con una estructura de directorios propia. Esto
 quiere decir que cada unidad tiene un directorio raiz y una estructura de
 subdirectorios determinada. Para diferenciar las distintas unidades se les
 asigna una letra a cada una de ellas. Asi tenemos la unidad A, la unidad C,
 etc.

 En Linux, esta estructura definitivamente no es adecuada porque trae muchos
 problemas de mantenimiento. Mas aun, es totalmente inaplicable en los
 sistemas de archivos de red como lo son NFS, SMB, etc. El hecho de fijar a
 cada una de las unidades una letra que debe mantenerse para siempre -o todos
 los programas perderan las refernecias de nombres- es una limitacion muy
 grande en sistem tan flexible como Linux :)

 2.1 SISTEMAS DE ARCHIVOS

                        ________________________
                        | Tony | Juan | README |
                        /-----------\-----------\
                      /              \           \-----\
        ____________/_________       _\_____________    \
        | mail | TODO | prog |       | prog | mail |     @
       /---------/------|----        -/---------\---
      /         /       |           /            \
     /        /      ___|__________/____________   \
    /       /       /   |         /             \    \
   /      /        |   _|________/___________    |     @
  @      @         |   | mod1 | mod2 | exec |    |
                   \_  ---|------|------|----   _/
                     \    |      |      |     _/ <-----_
                      \_  |      |      |   _/          |
                        \-|------|------|--/            Estos directorios
                          |      |      |               estan compartidos por
                          |      |      |               los usuarios Tony y
                          @      @      @               Juan.


 FIGURA 2.1: ESTRUCTURA DE SISTEMA DE ARCHIVOS ACICLICA. EJEMPLO DE UN
             DIRECTORIO COMPARTIDO.

 Para solucionar esto, Linux utiliza el concepto de particion raiz y sistemas
 de archivos montados sobre la particion raiz. Esto significa que todas las
 unidades utilizaran una estructura de directorios comun. Asi no existiran
 varias unidades y una estructura de directorios por unidad, sino que existira
 una unica estructura de directorios y sobre ella se acomodaran las distintas
 unidades, inclusive las que se comparten en redes.

 La particion raiz es llamada "/" y es el directorio principal de la
 estructura. Las unidades, antes de poder ser usadas, deben ser montadas en el
 sistema de archivos. Para ello debe existir un "punto de montaje" donde alojar
 la informacion de la unidad. Un punto de montaje no es mas que un directorio
 cualquiera dentro del sistema de archivos, que debe encontrarse vacio.

                        _______________________
                   /    | mnt | Tony | README |
                        øø/øøøøøø|øøøøøøøøø\øø
                        /         \          \______
                   ___/__         __\____________   \
                   |    |         | prog | mail |    @
                   øøøøøø         øøøøøøøøøøøø\øø
                                                \
                                                  \
                              ____________________  @
                             | mod1 | mod2 | exec |
                              øø|øøøøøø|øøøøøø|øøø
                                |      |      |
                                |      |      |
                                @      @      @

 FIGURA 2.2: EJEMPLO DE MONTAJE DE UNA UNIDAD. ESTADO DEL SISTEMA DE ARCHIVOS
             PREVIO AL MONTAJE.

                        _______________________
                   /    | mnt | Tony | README |
                        øø/øøøøøø|øøøøøøøøø\øø
                        /         \          \______
        ______________/__         __\____________   \
        | part1 | part2 |         | prog | mail |    @
        øøø/øøøøøøøø/øøøø         øøøøøøøøøøøø\øø
         /        /                             \
       /        /                                 \
      @        @              ____________________  @
                             | mod1 | mod2 | exec |
                              øø|øøøøøø|øøøøøø|øøø
                                |      |      |
                                |      |      |
                                @      @      @

 FIGURA 2.3: EJEMPLO DE MONTAJE DE UNA UNIDAD. ESTADO DEL SISTEMA UNA VEZ
             REALIZADO EL MONTAJE.

 Veamos un ejemplo de montaje de una unidad en Linux. El estado del sistema
 de archivos antes de montar la unidad es el que muestra la figura 2.2.
 Supongamos que queremos montar un disquettes que posee dos archivos llamados
 "part1" y "part2" en el punto de montaje dado por el directorio "/mnt". El
 directorio esta vacio, por lo que no hay ningun problema. El estado del
 sistema de archivos despues de realizar el montaje se muestra en la figura
 2.3.

 Una vez que se monta la unidad dentro del sistema de archivos se puede
 utilizar como si fuese cualquier directorio dentro de la estructura. La unica
 diferencia es la forma en la que se accede a los datos, ya que un directorio
 dentro del sistema de archivos puede corresponder a una particion del disco
 rigido, un disquette, un CD-ROM o una unidad de red que se encuentra en otra
 maquina. Afortunadamente, el sistema se ocupara de tratar con el dispositivo
 que corresponda, de la forma adecuada, para obtener y guardar la informacion.
 El tratamiento que Linux aplica a cada directorio del sistema de archivos se
 realiza de forma totalmente transparente para el usuario :)

 Esta forma de tratar las unidades trae, por supuesto, muchas ventajas. La
 belleza de los sistemas de archivos montados, por sobre las unidades
 basadas en letras, recae en la transparencia. Uno puede agregar unidades al
 sistema sin romper las referencias de las aplicaciones existentes.

 En el modelo de las unidades con letras, cada vez que se agregan unidades al
 sistema, cambian las letras de las unidades. Asi la mayoria del software y
 algunos S.O. se confunden cuando esto pasa. Tipicamente se termina teniendo
 que reinstalar los programas cada vez que se mueve algun disco de lugar.
 Este juego se vuelve ridiculo cuando se utilizan unidades de red.

 En Linux los sistemas de archivos de red, estan designados desde un principio
 con el objetivo de la transparencia. Asi se pueden mover archivos y
 aplicaciones de una maquina a otra en la red y ser compartidos ya que sus
 puntos de montaje no tienen porque cambiar.

 Lo que puede resultar incomodo es el hecho de tener que montar las unidades
 antes de usarlas. Esto es verdad, pero solo con las unidades extraibles
 (unidades de discos flexibles, o CD-ROM's), ya que las unidades fijas (discos
 rigidos, unidades de red, etc.) se configuran para que se monten
 automaticamente.

 2.1.5 RUTAS DENTRO DEL SISTEMA DE ARCHIVOS

 Las rutas (PATH) se utilizan para referirse a determinados directorios o
 archivos dentro del sistema de archivos. Ya hablamos del directorio raiz
 del sistema, el cual es llamado "/". Dentro de este se pueden crear otros
 directorios y archivos. Por ejemplo, si creamos un archivo llamado "Come As
 You Are.mp3" en el directorio raiz, entonces para referirnos a el tenderemos
 que especificar la siguiente ruta: /Come As you Are.mp3. Si creamos un
 directorio llamado "home" nos referiremos a el como /home o /home/. Esto es
 posible porque es un directorio.

 Generalizando, podemos encontrar encontrar un direcotorio llamado "linux" que
 se encuentra dentro del directorio "src" que a su vez se encuentra dentro del
 directorio "usr" que es un subdirectorio del directorio raiz. La ruta
 adecuada sera: /usr/src/linux.

 Las rutas no siempre se estructuran de esa manera. Todos los ejemplos dados
 en el parrafo anterior corresponden a "rutas absolutas". Esto quiere decir
 que son rutas completas, ya que marcan el camino desde el directorio raiz
 hasta el archivo o directorio deseado. Tambien es posible utilizar "rutas
 relativas". Las rutas relativas se construyen dependiendo del punto en el
 sistema de archivos donde nos encontramos ya que en cada momento nos
 encontramos en un cierto punto del sistema de archivos (el directorio
 actual o el de trabajo) y podemos cambiar de directorio, desplazandonos en
 la jerarquia. Toda ruta que comience con una barra ("/") es considerada una
 ruta absoluta, toda otra ruta es considerada ruta relativa.
 
                        _______________________
                   /    | mnt | Tony | README |
                        øø/øøøøøø|øøøøøøøøø\øø
                        /         \          \______
                      /           __\____________   \
                     @            | prog | mail |    @
                                  øøøøøøøøøøøø\øø
                                                \
                                                  \
                              ____________________  \
                             | mod1 | mod2 | exec |  _\_______________
                              øø|øøøøøø|øøøøøø|øøø   | mess | attach |
                                |      |      |      øøø|øøøøøøø|øøøøø
                                |      |      |         |       |
                                @      @      @         @       @
                                                         

 FIGURA 2.4: EJEMPLO DE RUTAS RELATIVAS. ARBOL DE DIRECTORIOS

 Como ejemplo de rutas relativas consideremos la estructura del sistema de
 archivos que muestra la figura 2.4, pueden darse las siguientes situaciones:

  * Si nos encontramos en el directorio /, entonces la ruta Tony/mail/attach
    se refiere al archivo attach que se encuentra dentro del directorio mail
    que es un subdirectorio del directorio Tony. Facil :)

  * Si nos en el directorio /Tony/mail entonces las rutas ./attach y attach
    ambas se refieren al mismo archivo de los ejemplos anteriores. Tambien
    Facil :))

  * Si nos encontramos en el directorio Tony/prog, entonces la ruta
     ../mail/attach se refiere al mismo archivo que el ejemplo anterior. Un
     poco mas dificil :|

  * Si el directorio en el que nos encotramos es Tony/prog entonces la ruta
    ../../README se refiere al archivo README que se encuentra en el
    directorio raiza. Muy dificil ;(

 HARD LINKS

 Los "hard links" (links "duros") son links directos al inodo ( no INODORO)
 del archivo y nos permiten tener mas de un archivo apuntando al mismo inodo.
 Desde un punto de vista practico dos archivos con el mismo inodo son el mismo
 archivo. Los cambios realizados sobre un archivo seran reflejados en el otro y
 viceversa. Lo unico que hay que tener en cuenta es que para borrar un archivo
 del sistema de archivos hay que borrar todos los hard links que el mismo
 posea. Por ejemplo, si el archivo doc1.tex es un hard link al archivo
 ejemplo1.tex, al borrar el ultimo no estamos borrando el primero. Para borrar
 definitivamente el archivo hay que borrar tambien el archivo doc1.tex. La
 unica restriccion que poseen los hard links es que solo pueden definirse
 dentro de un sistema de archivos, porque los inodos son unicos internamente a
 un sistema de archivos.

 Los directorios "." y ".." son hard links y estan presentes en todos los
 directorios del sistema de archivos. El primero es un hard link al mismo
 directorio y el segundo apunta al directorio padre. En particular la entrada
 ".." en el directorio "/" apunta a si mismo; es decir que el padre del
 directorio raiz es el mismo.

 LINKS SIMBOLICOS

 Los links simbolicos son otro tipo de links que tambien permiten darles varios
 nombres a un archivo pero no asocian a los archivos por numeros de inodo. Por
 esto los links simbolicos no tiene la restriccion de tener que permanecer al
 mismo sistema de archivos y pueden referenciar archivos entre sistemas de
 archivos. Esto quiere decir que un link simbolico tiene su propio numero de
 inodo pero apunta a otro archivo.

 Funcionalmente, los hard links y los links simbolicos son similares, aunque
 tiene algunas diferencias. Por ejemplo, se pueden crear links simbolicos a
 archivos que no existen, esto no es posible con los hard links.

 2.2 ESTRUCTURA GENERAL DE UN SISTEMA DE ARCHIVOS LINUX

 En un sistema de archivos Linux encontraremos los siguientes directorios
 importantes que forman parte del sistema y tiene funciones particulares:

  /bin  Archivos binarios o ejecutables. Aqui encontraremos los comandos mas
        utilizados. Los comandos que se encuentren en este directorio pueden
        ser ejecutados por todos los usuarios del sistema.

  /dev  Archivos que representan los dispositivos del sistema.

  /etc  Archivos de configuracion y pesonalizacion del sistema. Solo pueden
        ser modificados por el superusuario (ROOT).

  /sbin  Ordenes ejecutables solo por el superusuario.

  /home  Directorio donde se crean los directorios home de los usuarios del
         sistema.

  /lib  Librerias escenciales del sistema. 

  /proc  Es una estructura virtual de archivos utilizada por el kernel para
         mostrar la informacion del sistema y su configuracion. A traves del
         mismo es posible ver la informacion de las interrupciones, puertos
         de entrada/salida, uso del CPU, memoria, particiones, modulos, asi
         como la informacion de cada proceso en particular y de los distintos
         dispositivos instalados en el sistema.

  /tmp  Directorio que se utiliza como almacenamiento de archivos temporales.

  /var  Informacion de la historia del sistema. Se guardan los mensajes que
        los precesos realizan al ejecutarse, informacion de debug, archivos a
        imprimir, mensajes de correo a ser distribuidos, etc.

  /boot  Archivos e informacion necesaria para el arranque del sistema.

  /usr  Programas, herramientas y utilidades instaladas en el sistema como
        extension del S.O.

  /usr/bin  Binarios y ejecutables de los programas agregados al sistema.

  /usr/src  Codigo fuente de los programas.

  /usr/src/linux  Codigo fuente del kernel del sistema.

  /usr/man  Manuales de los comandos del sistema y de los programas agregados.

  /usr/X11  Archivos del sistema de ventanas X Windows.

  /usr/X11/bin  Archivos ejecutables del sistema de ventanas.

  /usr/local  Softaware agregado localmente al S.O. En este directorio se suele
              instalar todo el software que agregamos luego de realizar la
              instalacion.



 CAPITULO 3

 USUARIOS, PERMISOS Y GRUPOS

 El sistema operativo Linux es un sistema multiusuario. Esto quiere decir
 que un numero cualquiera de personas pueden trabajar en el sistema, ya sea
 de forma simultanea o no. Para comenzar a trabajar en el sistema Linux es
 necesario iniciar una sesion, esto quiere decir que el sistema nos preguntara
 el nombre de usuario con el cual queremos iniciar la sesion. Este proceso se
 conoce como LOG IN.

 Para que el sistema se asegure que la persona que intenta inciar una sesion
 corresponde al usuario indicado se asocio una contrase¤a (PASSWORD) con
 cada nombre de usuario. La contrase¤a solamente la debe conocer el usuario
 propietario de la cuenta.

 Como parte del proceso de inicio de sesion se debe ingresar la contrase¤a
 apropiada, la cual sera encriptada por el sistema inmediatamente y chequeada
 contra la base de datos de contrase¤as y gurdada en el sistema. Este proceso
 se conoce como autenticacion del usuario. Si la contrase¤a es cheaqueada
 satisfactoriamente entonces el usuario comienza su sesion en el sistema. De
 otra forma se rechaza la solicitud de comienzo de sesion.

 Para que este esquema de autenticacion funcione, es necesario que exista una
 forma de crear cuentas de usuario y de asociarles sus respectivas
 contrase¤as, y ademas no se debe permitir a cualquier usuario que pueda
 realizar estas tareas. Para solucionar estos y otros problemas de seguridad,
 Linux posee una cuenta predefinida llamada "root". Esta es la cuenta del
 superusuario, y es el unico usuario que esta autorizado a crear cuentas,
 asignarles contrase¤as y eliminarlas si es necesario. Estos no son los unicos
 permisos que posee esta cuenta; en realidad en una sesion iniciada como el
 superusuario, root, es posible realizar todas las operaciones necesarias para
 la administracion del sistema.

 El esquema de autenticacion de usuarios es necesario pero no suficiente. El
 hecho de que Linux  utilice la estructura de un unico sistema de archivos y
 de que sea un sistema multiusuario hacen que sea indispensable un sistema de
 permisos aplicable sobre los usuarios para con los archivos. Imaginemos un
 entorno en el cual no existieran permisos sobre los archivos y existieran
 multiples usuarios. Facilmente un usuario podria leer, modificar e incluso
 borrar archivos de otro usuario, o podrian darse otras situaciones
 indeseables para con la seguridad del sistema. Para evitar esto Linux
 establece un mecanismo de proteccion de archivos que funciona mediante
 permisos y grupos.

 Anteriormente, cuando hablamos de los atributos de un archivo, mencionamos
 que un archivo tiene asociado un usuario y un grupo. Estos atributos
 establecen quien es el usuario due¤o del archivo y a que grupo de usuarios
 pertenece. Los grupos son conjuntos de usuarios que tambien son definidos
 por el superusuario como parte de la administracion del sistema y sirven para
 agrupar a varios usuarios con caracteristicas de acceso al sistema similares.
 El concepto de grupos de usuario facilita enormemente la tarea de administrar
 los permisos en sistemas con gran cantidad de usuarios.

 3.1 PERMISOS DE ACCESO

 Ademas de los atributos de usuario y grupo, un archivo tiene asociados
 "permisos de acceso" que determinan las operaciones que son permitidas sobre
 el mismo por parte de cada usuario. Los permisos de un archivo se dividen en
 tres partes:

  * DUE¥O: El usuario que creo el archivo es el due¤o del mismo. El due¤o es
           determinado por el atributo del archivo que especifica quien es el
           due¤o.

  * GRUPO: El conjunto de usuarios que comparten el archivo y necesitan
           permisos de acceso similares. El grupo sobre el cual recaen estos
           permisos es el grupo al cual pertenecen el archivo como lo
           determina el atributo de grupo.

  * OTROS (Universo): El universo se constituye de todos los demas usuarios
                      que no son ni due¤os del archivo ni pertenecen al
                      grupo del archivo.

  Dentro de cada categoria, los permisos se dividen en tres grupos: leer,
  ecribir y ejecutar.

  PERMISO DE LECTURA: Deja a un usuario ver el contenido de un archivo o, en
                      el caso de los directorios poder listar su contenido.

  PERMISO DE ESCRITURA: Permite escribir en los archivos o modificar su
                        contenido. En el caso de los directorios permite
                        crear nuevos archivos o borrar archivos del
                        directorio.

  PERMISO DE EJECUCION: Deja que el usuario pueda ejecutar el archivo, ya sea
                        como un programa o como un script de comandos. El
                        permiso de ejecucion sobre un directorio nos permite
                        cambiar el directorio de trabajo.

 Este mecanismo de permisos nos garantiza seguridad y simultaneamente nos
 permite compartir archivos con grupos de usuarios. Pero para que este
 esquema funcione adecuadamente, la pertenencia a los grupos debe ser
 controlada rigidamente por el adminsitrador del sistema.

 Los permisos asociados con un archivo dependen tambien de los permisos que
 tenga asignado el directorio donde se encuentra el archivo. Por ejeplo, si
 un usuario tiene permisos de lectura y escritura sobre un archivo pero no
 tiene permiso de lectura ni de ejecucion sobre el directorio en el cual se
 encuentra el archivo, entonces no podra leer ni escribir el archivo.
 Generalizando, para poder acceder a un archivo es necesario tener permiso de
 ejecucion en todos los directorios que forman parte de la ruta del archivo,
 ademas del permiso adecuado sobre el archivo.

 3.2 DIRECTORIO "HOME" Y PERMISOS PREDEFINIDOS

 Cuando el administrador del sistema crea una cuenta, crea ademas un
 directorio, el cual sera propiedad del usuario que solicito la cuenta. Este
 directorio es llamado "directorio home" y constituye el lugar en el sistema
 de archivos donde el usuario puede guardar sus archivos. El usuario tiene un
 control total sobre los permisos de su directorio home. El acceso del usuario
 a otros directorios estara regido por los permisos correspondientes. Cuando
 un usuario inicia una sesion en el sistema, su directorio de trabajo es su
 directorio home.

 Al crear un nuevo archivo o directorio, el sistema asigna una combinacion de
 permisos predeterminada. Los permisos predefinidos para los archivo son: de
 lectura y escritura para el due¤o y de lectura y ejecucion para el universo.
 Para los directorios son: de lectura, escritura y ejecucion para el due¤o y
 de lectura y ejecucion para el grupo y para el universo (otros usuarios).

 En cualquier momento, el usuario que es due¤o del archivo o directorio puede
 cambiar sus permisos para gestar la combinacion que desee.



 CAPITULO 4

 DISPOSITIVOS DE ENTRADA/SALIDA

 4.1 CONCEPTOS FUNDAMENTALES

 Los dispositivos de entrada/salida utilizados en las computadoras pueden ser
 divididos, esencialmente, en dos categorias: dispositivos de bloques y
 dispositivos de caracter.

 Un dispositivo de bloque se caracteriza por guardar la informacion en bloques
 de tama¤o fijo, cada uno con su direccion. Los tama¤os de bloques mas comunes
 se encuentran en el rango de 512 bytes a 32768 bytes (32 Kb). La propiedad
 esencial de los dispositivos de bloque es que es posible leer o escribir cada
 bloque independientemente de todos los demas. Los "discos" son los
 dispositivos de bloque mas comunes.

 El otro tipo de dispositivos de entrada/salida es el dispositivo de caracter.
 Un dispositivo de caracter envia o acepta secuencias de carateres sin
 relacion a una estructura de bloque. No tiene direccionamiento y por lo tanto
 no tiene ninguna estructura mecanica interna para realizar posicionamientos.
 Los siguientes dispositivos pueden ser vistos como dispositivos de carater:
 impresoras, ratones, interfaces de red, etc.

 Este esquema de clasificacion no es perfecto. Algunos dispositivos son
 dificiles de clasificar en estas categorias. Sin embargo, para fines practicos
 esta clasificacion nos sera suficiente.

 A continuacion se describen conceptos esenciales para el tratamiento y
 configuracion de los dispositivos de entrada/salida. Estos conceptos son
 importantes a la hora de instalar cualquier dispositivo sobre Linux y
 determinan el exito o el fracaso de la instalacion y el correcto
 funcionamiento del dispositivo.

 4.1.1 PUERTOS DE ENTRADA/SALIDA

 Asi como el sistema accede a memoria, tanto para lectura como escritura, debe
 poder acceder a los dispositivos de entrada/salida. En las maquinas basadas en
 las arquitecturas Intel 80x86 existe un espacio de direccionado para la
 memoria y otro separado para los dispositivos. Este esquema es conocido como
 espaciado separado de direcciones de entrada/salida o espacio de entrada/
 salida.

 Los puertos de entrada/salida son direcciones mediante las cuales el
 procesador se comunica con los dispositivos, ya sea leyendo datos o
 escribiendolos. Un dispositivo puede tener asignadas una o mas direcciones
 dentro del espacio, de acuerdo a cuantas necesite.

 4.1.2 INTERRUPCIONES E IRQ'S

 La velocidad con la que los dispositivos trabajan es, en general, ordenes
 de magnitud mas lenta que la velocidad de proceso de la unidad central de
 procesamiento (CPU). Cuando el CPU necesita comunicarse con un dispositivo,
 inicia la operacion y, en vez de esperar a que el dispositivo termine, sique
 realizando tareas, aprovechando el tiempo. Asi el dispositivo debe poder
 comunicarle al CPU que la operacion de entrada/salida finalizo o que necesita
 algun tipo de informacion para continuar. Aqui es donde entran en juego las
 interrupciones.

 Una interrupcion es una se¤al electronica que se emite desde un dispositivo
 hacia el CPU para comunicarle informacion que permite controlarlo. Para
 emitor las interrupciones existen lineas de pedido de interrupcion (Interrupt
 ReQuest Lines) donde cada dispositivo situa los pedidos de interrupcion.

 Las arquitecturas Intel 80x86 proveen 15 lineas de interrupcion para los
 dispositivos de entrada/salida. Cada dispositivo debe utilizar una y solo
 una de estas lineas, porque sino existen altos riesgos de conflictos en la
 atencion de las interrupciones.

  NOTA: Una caracteristica especial de la arquitectura de las IBM PC's es que
        algunos dispositivos trabajan con puertos de entrada salida e
        interrupciones prefijadas. Por ejemplo: el primer puerto serie,
        conocido como COM1, trabaja en el puerto 0x3f8. Otro ejeplo es la
        unidad de discos flexibles que trabaja sobre la linea de pedido de
        interrupcion numero 6.

 4.1.3 ACCESOS DIRECTOS A MEMORIA (DMA)

 Hay veces que los controladores de los dispositivos necesitan leer o escribir
 grandes cantidades de datos desde o hacia la memoria del sistema. En estos
 casos se utilzan los accesos directos a memoria (Direct Memory Access). Estos
 sirven para permitir que los dispositivos accedan directamente a memoria,
 pero esto se realiza bajo estricto control del CPU.

 4.2 TRATAMIENTO DE LOS DISPOSITIVOS EN LINUX

 En los S.O. de la famila UNIX todos los dispositivos de entrada/salida son
 tratados como archivos que forman parte del sistema de archivos. En general
 estos archivos se encuentran en el directorio /dev, pero esto puede depender
 del sistema.

 Estos archivos, llamados "archivos de dispositivos", son creados por el
 nucleo y son indespensables para el funcionamiento del sistema. Uno de los
 principales objetivos es manejar los dispositivos como archivos es que se
 abstrae y simplifica el tratamiento de los mismos para el usuario. Los
 archivos especiales de dispositivos se manejan con las mismas operaciones
 que se realizan sobre los archivos comunes, pero al tratarse de un archivo de
 dispositivo el sistema se encarga de realizar las tareas necesarias para
 comunicarse con el dispositivo. Esto se realiza por medio de un "manejador de
 dispositivo" que forma parte del nucleo y conoce los detalles de como tratar
 con el dispositivo en cuestion.

 Otra de las ventajas de este esquema de tratamiento de dispositivos es que 
 se pueden fijar permisos sobre los dispositivos utilizando el esquema de
 usuarios, grupos y permisos ya analizado. De esta forma, podremos hacer que
 un grupo de usuarios pueda usar una impresora, que otro grupo pueda usar una
 red, o inclusive denegar el acceso a un disco a un usuario determinado, etc.

 Los archivos de dispositivos tienen un atributo especial que determina si
 son archivos de dispositivos de bloque o de caracter. Esto es necesario
 para que el sistema sepa como tratar a cada uno.

 Como es posible que existan varios dispositivos de entrada/salida de las
 mismas caracteristicas (podemos tener varios discos, varias placa de red,
 etc.) se crean grupos de usuarios para cada clase de dispositivo y hace
 que los archivos pertenezcan a esos grupos. Por ejemplo: todos los
 dispositivos de disco del sistema son archivos que pertenecen al grupo
 "disk, etc."

 4.2.1 ARCHIVOS DE LOS DISPOSITIVOS MAS COMUNES

  * DISCOS MFM, RLL O IDE  (EIDE): La interfaz IDE en Linux soporta hasta 6
    interfases con soporte para dos discos cada una. Se denominan primaria,
    secundaria, terciaria, etc. y a los discos se los denomina maestro y
    esclavo. Tenemos un maestro y un sclavo por cada interfaz. Sus nombres
    son:

       |øøøøøøøøøøøøøøøøøøøøøøø|øøøøøøøøøøøøøøøøøøøøøøøø|
       | Interfaz              | Archivo de dispositivo |
       |-----------------------|------------------------|
       | Primaria - Maestro    |      /dev/hda          |
       | Primaria - Esclavo    |      /dev/hdb          |
       | Secundaria - Maestro  |      /dev/hdc          |
       | Secundaria - Esclavo  |      /dev/hdd          |
       | ...                   |      ...               |
       |_______________________|________________________|

        NOTA: Si uno de los lugares en las interfases es ocupado por un
              CD-ROM, se le asigna un archivo correspondiente a la interfaz,
              pero ademas se crea un link simbolico llamado /dev/cdrom que
              apunta a la interfaz que corresponda al CD-ROM.

  * DISCOS SCSI: Linux tiene soporte para 128 discos SCSI y sus archivos son:

         |øøøøøøøøøøøøøøøøø|øøøøøøøøøøøøøøøøøøøøøøøø|
         | Numero de disco | Archivo de dispositivo |
         |-----------------|------------------------|
         | Disco SCSI 1    |     /dev/sda           |
         | Disco SCSI 2    |     /dev/sdb           |
         | ...             |     ...                |
         | Disco SCSI 26   |     /dev/sdz           |
         |-----------------|------------------------|
         | Disco SCSI 27   |     /dev/sdaa          |
         |-----------------|------------------------|
         | Disco SCSI 28   |     /dev/sdab          |
         |-----------------|------------------------|
         | ...             |     ...                |
         | Disco SCSI 128  |     /dev/sddx          |
         |_________________|________________________|

  * PARTICIONES: Cada disco puede estar particionado. Para referirnos a las
    particiones solo agregamos el numero de la particion correspondiente, al
    nombre del archivo que representa el disco. Los nombres se forman de la
    siguiente forma: /dev/hd?n y /dev/sd?n reemplazando por "?" la letra del
    disco adecuado y por "n" el numero de particion correspondiente.

        NOTA: En particiones del estilo MS-DOS (tipicamente usadas por Linux
        en sistemas i386) los numeros del 1 al 4 representan particiones
        primarias y del 5 en adelante particiones logicas.

  * UNIDADES DE DISQUETTES: Se soportan dos controladoras de unidades de
    disquettes con hasta 4 unidades por controladora.

            |øøøøøøøøøøøøøøøøøøøøøøøøøøøø|øøøøøøøøøøøøøøøøøøøøøøøø|
            | Controladora - Disquettera | Archivo de dispositivo |
            |----------------------------|------------------------|
            | Controladora 1 - Unidad 1  |         /dev/fd0       |
            |       "        -   "    2  |         /dev/fd1       |
            |       "        -   "    3  |         /dev/fd2       |
            |       "        -   "    4  |         /dev/fd3       |
            |       "      2     "    1  |         /dev/fd4       |
            |       "      "     "    2  |         /dev/fd5       |
            |       "      "     "    3  |         /dev/fd6       |
            |       "      "     "    4  |         /dev/fd7       |
            |____________________________|________________________|

  * CONSOLAS VIRTUALES: Son 64 consolas y se nombran /dev/ttyn donde "n" es
    el numero de la consola virtual correspondiente.

  * PUERTOS SERIE, MODEMS Y MOUSES: Se tiene soporte para 64 puertos serie y
    se nombran como /dev/ttySn donde, de nuevo, "n" es el numero del puerto.

        NOTA: En sistemas basados en MS-DOS los puertos  serie se nombran
        COM1, COM2, etc. La correspondencia de esos pueros con los de Linux
        es la siguiente:
             _______________________________
             |   MS-DOS    |   Linux        |
             |-------------|----------------|
             |  COM1       |   /dev/ttyS0   |
             |  COM2       |   /dev/ttyS1   |
             |  COM3       |   /dev/ttyS2   |
             |  COM4       |   /dev/ttyS3   |
             |_____________|________________|
                            
    Los dispositivos de puertos serie pueden ser utilizados, entre otros
    dispositivos, por puertos serie fisicos o por modems. Si el modem es
    externo, entonces se conecta a uno de los puertos serie y se crea un
    link simbolico /dev/modem que apunte al puerto serie fisico
    correspondiente. Si el modem es interno entonces utilizara uno de los
    puertos que se encuentren disponibles (que no esten utilizados por
    puertos serie fisicos) y el link simbolico debera apuntar al puerto
    "logico" que se utilice.

    Si se utiliza un mouse serial entonces se crea un link simbolico /dev/mouse
    que apunta al puerto serie en cual esta conectado el mouse. Si no se
    utiliza un mouse serial entonces se pueden utilizar los siguientes
    dispositivos, dependiendo del tipo del mouse:

            |øøøøøøøøøøøøøøøøøøøøøøøøøøøøøøø|øøøøøøøøøøøøøøøøøøøøøøøø|
            | Mouse                         | Archivo de dispositivo |
            |-------------------------------|------------------------|
            | Mouse PS/2                    |   /dev/psaux           |
            | Mouse Logitech de bus         |   /dev/logibm          |
            | Microsoft InPort mouse de bus |   /dev/inportbm        |
            | Ati XL mouse de bus           |   /dev/atibm           |
            | Mouse Atari                   |   /dev/atarimouse      |
            | Mouse Sun                     |   /dev/sunmouse        |
            | Mouse Amiga                   |   /dev/amigamouse      |
            |_______________________________|________________________|

  * PUERTOS PARALELOS: Pueden ser 3 y sus nombres son los siguientes:

          |øøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøø|øøøøøøøøøøøøøøøøøøøøøøøø|
          | Puerto paralelo                | Archivo de dispositivo |
          |--------------------------------|------------------------|
          | Primer puerto paralelo (0x3BC) |       /dev/lp0         |
          |    "     "       "     (0x378) |       /dev/lp1         |
          |    "     "       "     (0x278) |       /dev/lp2         |
          |________________________________|________________________|

  * TECLADO: El teclado se maneja con el dispositivo /dev/kbd

  * PLACAS DE SONIDO: Los dispositivos relacionados con las placas de sonido
    son los siguientes:

    |øøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøø|øøøøøøøøøøøøøøøøøøøøøøøø|
    | Dispositivo                                   | Archivo de dispositivo |
    |-----------------------------------------------|------------------------|
    | Control de mezcladora                         |     /dev/mixer         |
    | Secuenciador de audio                         |     /dev/sequencer     |
    | Puertos midi                                  |     /dev/midinn4       |
    | Audio digital                                 |     /dev/dsp5          |
    | Audio digital compatible con formato SUN      |     /dev/audio         |
    | Informacion del estado de la placa de sonidos |     /dev/sndstat       |
    |_______________________________________________|________________________|

  * JOYSTICK: Los dispositivos de joystick se nombran /dev/jsn, para los
    joysticks analogicos y /dev/djsn para los joysticks digitales; "n" es el
    numero de joystick.

  * INTERFASES DE RED: Las interfases de red mas utilizadas son las Punto a
    Punto (PPP) o las interfases Ethernet. Los dispositivos para las mismas
    son: /dev/pppn para las interfases PPP y /dev/ethn para las interfases
    Ethernet; "n" es el numero de interfase.

  * CD-ROM'S ESPECIALES:

        |øøøøøøøøøøøøøøøøøøøøøøøø|øøøøøøøøøøøøøøøøøøøøøøøøø|
        | CD-ROM                 | Archivo de dispositivo  |
        |------------------------|-------------------------|
        | Sony CDU-31A/CDU-33A   |   /dev/sonycd           |
        | Sony CDU-535           |   /dev/cdu535           |
        | Goldstar               |   /dev/gscd             |
        | Optics                 |   /dev/optcd            |
        | Sanyo                  |   /dev/sjcd             |
        | Hitachi                |   /dev/hitcd            |
        | Mitsumi                |   /dev/mitcd            |
        | Panasonic/SoundBlaster |   /dev/sbpcdn6          |
        | Aztech                 |   /dev/aztcd            |
        |________________________|_________________________|
        



 CAPITULO 5

 PROGRAMAS Y PROCESOS

 El concepto central mas importante en cualquier sistema multitarea es el de
 proceso. Informalmente, un proceso es una abstraccion de un programa en
 ejecucion. Un programa es una secuencia de instrucciones que la computadora
 ejecuta con el objetivo de obtener un cierto resultado; es lo que crea el
 programador. Cuando un programa no esta siendo ejecutado se encuentra en un
 archivo del disco. Para poder ejecutar el programa, una copia de las
 instrucciones debe ser cargada en memoria. Cuando un programa se esta
 ejecutando, se lo llama proceso. Es muy importante conocer las
 caracteristicas de los procesos para comprender el funcionamiento de Linux y
 aprovechar la potencia de su modelo multiprogramado.

 Todas las computadoras modernas pueden hacer varias cosas al mismo tiempo
 para aprovechar los recursos mas eficientemente. Por ejemplo: se puede estar
 ejecutando un programa mientras se leen datos de un disco o se imprime un
 documento. En un sistema multiprogramado, ademas, se pueden estar ejecutando
 varios procesos al mismo tiempo (posiblemente de distintos usuarios). Esto
 es posible gracias al concepto de multiprogramacion. En un sistema
 multiprogramado, cada proceso obtiene una tajada del tiempo del procesador.
 Estrictamente hablando, en cada instante de tiempo el procesador ejecuta un
 solo proceso, pero en un periodo determinado, digamos 1 segundo, puede
 trabajar sobre muchos procesos dando a los usuarios la impresion de la
 existencia de paralelismo. En realidad, como resultado de lo que realiza
 internamente obtenemos un "pseudo-paralelismo" que hace que los procesos
 se puedan ejecutar concurrentemente compartiendo el tiempo del procesador.
 Asi el S.O. hace que la operacion de la computadora resulte mas productiva.

 Linux es un sistema multitarea-multiusuario, lo que quiere decir que cada
 usuario puede estar ejecutando varios procesos al mismo tiempo. El S.O.,
 atendera las necesidades de todos los usuarios de una manera justa,
 ejecutando concurrentemente todos los procesos.

 Cada vez que un usuario ejecuta un programa se inicia un proceso en el
 sistema. Cada proceso tiene un PID (Process ID) unico, que es el numero que
 sirve para identificarlo. Alguno se preguntara por que no es el nombre del
 programa el que identifica al proceso ?. Bueno, esto trae muchas desventajas,
 ya que por ejemplo, pueden haber varios procesos ejecutandose como parte del
 mismo programa, y seria imposible identificarlos. Sin embargo, cada proceso
 guarda como atributo el comando que se ingreso para iniciarlo.

 5.1 EJECUCION EN PRIMER PLANO Y EN "BACKGROUND"

 Un proceso puede ejecutarse en primer plano o en "background". Solo puede
 existir un proceso ejecutandose en primer plano y es el proceso con el cual
 podemos interactuar. La entrada del proceso se toma del teclado y la salida
 se muestra por pantalla. Los procesos que se ejecutan en "background" no
 reciben entradas del teclado ni de ninguna terminal, y en general se ejecutan
 "silenciosamente" sin necesidad de interaccion.

 Todos los S.O. proveen algun tipo de mecanismo para ejecutar procesos en
 primer plano, pero, sin embargo no todos proveen la posibilidad de ejecutar
 procesos en "background". La importancia de los procesos en "background" se
 puede analizar considerando sus varias utilidades. Por ejemplo: existen
 procesos que tardan mucho tiempo para completarse y no requieren la 
 interaccion del usuario. Compilar programas o comprimir un archivo muy grande
 son ejemplos de este tipo de tareas. Estas conviene realizarlas en
 "background", ya que mientras varios procesos se estan ejecutando en
 "background" estamos libres para ejecutar cualquier otro tipo de tarea.

 Los procesos pueden estar en varios estados, los cuales pueden ser:

  * Ejecutando: El proceso ejecuta ya sea en primer plano o en "background"

  * Suspendido: Un proceso suspendido es un proceso que esta temporariamente
    detenido. Luego de suspender un proceso es posible reanudarlo ya sea en
    primer plano o en "background". De esta manera el proceso continua en el
    punto en el cual habia sido suspendido.

  * Interrumpido: A diferencia de un proceso suspendido, un proceso es
    interrumpido por algun evento y no puede ser reanudado. Por lo que es
    inmediatamente terminado.

 5.2 DEMONIOS

 Los demonios son procesos que se ejecutan en "background". Se los puede
 pensar como procesos que se mantiene "dormidos" a la espera de eventos que
 los despierten para llevar a cabo una tarea determinada. Cuando un evento
 despierta un demonio, este se ocupa de ejecutar lo pertinente y cuando
 completa el tratamiento del evento vuelve a dormirse y asi sucesivamente.
 Los tipos de eventos que cada demonio espera y las tareas que realiza en
 respuesta a los mismos dependen de la naturaleza del demonio en cuestion.
 Las tareas mas comunes para las que se utilizan demonios son: demonios que
 controlan dispositivos (impresoras(lpd), adaptadores de red (pppd), etc.),
 control de los protocolos de red (tcp/ip (tcpd), etc.), agentes de
 transferencia de correo electronico (sendmail), etc.



 CAPITULO 6

 LA INTERACCION CON EL SISTEMA. SHELL Y COMANDOS

 6.1 LA SHELL

 Todo S.O. debe proveer un mecanismo para que el/los usuarios puedan
 comunicarle lo que quieren realizar y para poder interactuar con el. Linux
 posee una interfase de comunicacion llamada "shell" y es el medio mediante
 el cual el usuario puede comunicarle comandos al sistema y recibir la
 salida de los procesos con los que interactua.

 Basicamente, la shell es un proceso mas que obviamente se ejecuta en primer
 plano, ya que sino seria imposible interactuar con el mismo. Su
 funcionamiento se limita a recibir comandos del usuario, interpretarlos y
 ejecutar las tareas necesarias en respuesta a los mismos. El nombre tecnico
 de la shell puede ser "interprete de comandos". Su funcion se puede comparar
 a la del programa "comand.com" en MS-DOS que esencialmente realiza las mismas
 tareas.

 En los sistemas UNIX cada usuario puede elegir que shell quiere utilizar para
 comunicarse con el sistema. Linux tiene varias shells las cuales pueden ser
 elegidas por el usuario. Inclusive es posible que el usuario programe y
 utilice su propia shell si asi lo desea. Las shells que Linux provee son:

  * sh: Shell de Bourne. Es la shell mas utilizada en los sistemas UNIX.

  * csh: Shell de C. Es la shell preferida por los programadores. Es
         compatible con la shell de Bourne.

  * ash: Shell de Ash. Es una version especial reducida. Se utiliza cuando
         existe muy poca memoria disponible.

  * ksh - pdksh: Shell de Korn. Extension de la shell de Bourne.

  * bash: Bourne Again Shell. Es la shell de la FSF (Free Software Fundation).
          Amplia las capacidades de la shell de Bourne y es utilizada por
          Linux como shell predeterminada.

  * zsh: Z Shell. Compatible con la shell de Bourne.

 6.1.1 FUNCIONAMIENTO DE LA SHELL

 La shell es iniciada inmediatamente cuando un periodo de inicio de sesion es
 autenticado exitosamente. El sistema recuerda cual es la shell que utiliza
 cada usuario y carga la correspondiente al usuario que inicio la sesion.
 Desde este momento, la shell muestra un identificador llamado "prompt" que
 significa que esta esperando que el usuario ingrese una orden.

 Una vez que se visualiza el prompt, el usuario puede ingresar cualquier
 orden, ya sea para que se ejecute en primer plano o en "background". Si el
 pedido de ejecucion dado por el comando ingresado especifica que el proceso
 se debe ejecutar en "background", el proceso se inicia y se comienza a
 ejecutar en "background", por lo que el shell inmediatamente vuelve a mostrar
 el prompt y al estado de espera de mas ordenes. Asi es posible seguir
 ejecutando ordenes. Si el proceso se debia ejecutar en primer plano, la
 shell no retorna el prompt hasta que el proceso ejecutado se termine. Por
 lo tanto debemos esperar a que termine el proceso para poder iniciar otro.

 6.2 COMANDOS

    NOTA: Desde esta seccion en adelante todo lo referente a la shell y sus
    comandos estara basado en la shell bash (Bourne Again Shell) que es la
    shell predefinida en Linux :)

 El uso interactivo tipico de la shell se basa en ingresar comandos simples,
 comandos con calificadores, comandos con facilidades de generacion de
 nombres de archivos, redireccion de entrada-salida, y comandos combinados
 mediante el uso de "ca¤erias". Estas tecnicas son poderosas y extremadamente
 utiles, pero son solo una parte de las capacidades de la shell.

 La shell es, ademas de interprete interactivo de comandos, un interprete de
 un lenguaje de programacion de comandos llamado "El lenguaje de programacion
 de la shell". Este lenguaje nos permite realizar nos permite realizar
 "scripts" que sera posible ejecutar como un programa binario mas, con la
 diferencia que lo interpreta la shell linea por linea y ejecuta los comandos
 correspondientes. Mas adelante nos ocuparemos de analizar este lenguaje de
 programacion en profundidad, ya que es una de las caracteristicas mas
 poderosas de la shell y nos sirve para automatizar muchas de las tareas que
 tenemos que realizar en el sistema y nos ayuda a ahorrar la cantidad de
 comandos que tenemos que tipear.

 6.2.1 COMANDOS SIMPLES

 Un comando simple es una secuencia de (una o mas) palabras separadas por
 espacios o tabuladores. La primer palabra de la secuencia es el nombre del
 comando. Las palabras subsiguientes son los argumentos del comando. Los
 comandos mas simples son de una sola palabra.

 Los comandos mas comunes pueden ser: ls para listar el contenido de un
 directorio, ps para ver los procesos que se encuentran creados en el
 sistema, reboot para reiniciar el sistema, etc.

 ARGUMENTOS

 Los comandos, en su forma mas simple, se ejecutan simplemente poniendo el
 nombre del archivo correspondiente. Sin embrago, existen comandos que
 necesitan argumentos para trabajar. Un ejemplo de esto puede ser el
 comando cp que sirve para copiar archivos. Este comando necesita dos
 argumentos obligatorios, el/los archivo fuente y el detino de la copia.
 Por ejemplo:

  ==> cp /home/juan/cuotas.tex /home/tony/

 Los argumentos se utilizan para pasar informacion adicional a los programas
 que ejecutamos. En algunos casos son opcionales, en otros obligatorios y
 puede ser que la cantidad de argumentos de algunos comandos pueda ser
 variable. La gran mayoria de las veces los argumentos seran nombres de
 archivos o de directorios, pero esto es dependiente de cada programa.

 El nombre del comando y sus argumentos deben ser separados por uno o mas
 espacios, sino la shell nos informara del error con un mensaje. Ejemplo:

  ==> ls/bin

  bash: ls/bin:  No such file or directory

 Otros argumentos  son los "modificadores" que son formas de pasar opciones
 a los programas y seran tratados a continuacion.

 MODIFICADORES

 Los comandos, usualmente, sirven para realizar una funcion pero pueden
 aceptar varias opciones que especifiquen como se debe realizar esta tarea.
 Las opciones que cada comando acepta y la sintaxis con la que se especifica
 la opcion dependen exclusivamente del comando en cuestion. Aunque en general
 se puede hablar  de "modificadores" que son la forma general de ingresar las
 opciones a los comandos. Consideremos el siguiente comando:

  ==> ls -a

 Este comando listara el contenido del directorio actual, pero mostrara
 ademas los que comienzan con ".", ya que estos son ocultos y al ejecutar ls
 no son mostrados. Este comportamiento es especificado por la opcion de
 mostrar los archivos ocultos que es seleccionada con el modificador -a (all).

    NOTA: Un modificador muy util es -h que sirve para especificarle a un
    comando que nos muestre su sintaxis y las opciones que soporta. Esto
    sirve como referencia del funcionamiento del comando. Este modificador
    se puede usar con la mayoria de los comandos de Linux. Algunos comandos
    soportan --help o -help para la misma funcion.

 6.2.2 SEPARADOR DE COMANDOS

 Para ingresar varios comandos en una sola linea es necesario separarlos por
 ";". Por ejemplo:

  ==> date;df -h

 La salida de este comando sera la siguiente:

  Thu Apr 15 17:29:15 ART 1999
  Filesystem           Size  Used  Avail  Capacity Mounted on
  /dev/hda3            1.6G  613M   963M     39%   /
  /dev/hdc1            2.0G  1.9G   138M     93%   /akenaton
  /dev/hda2            298M  238M    60M     80%   /games
  /dev/hda1            2.0G  1.5G   546M     73%   /nt

 La primera linea de la salida es generada por el comando date y muestra la
 hora y el dia actual en el sistema. La tabla que es mostrada a continuacion
 es generada por el comando df y muestra las capacidades, tama¤os utilizados
 y disponibles, y puntos de montaje de los distintos sistemas de arhcivos que
 se encuentran montados. Notemos que las unidades se muestran en distintos
 formatos de acuerdo al valor que tenga cada campo. Esto es causado por la
 opcion -h que indica al comando que muestre los valores con unidades
 significativas y no en numero de bloques.

 6.3 LA ENTRADA ESTANDAR Y LA SALIDA ESTANDAR

 Los programas basados en el modelo de entrada/salida por teletipo son
 aquellos en los que su salida consiste en lineas de texto ASCII. Estos
 programas ofrecen solo una primitiva interfase con el usuario basada en linea
 de comandos. Pero justamente por esto, y por la funcionalidad que provee la
 shell, es posible interconectar varios programas que realizan tareas simples
 para realizar tareas mas complejas. Todos los comandos de Linux y la mayoria
 de sus utilidades se encuentran basados en este modelo. Por esto es
 importante entender el funcionamiento e interaccion de los programas, la shell
 y la entrada/salida para sacar provecho a estas facilidades.

 Cuando un programa, del modelo de teletipo, produce una salida sobre una
 terminal el programa, en general, esta realizando operaciones de salida a lo
 que se denomina salida estandar (stdout). Asimismo, cuando tipeamos algo en
 el teclado de la terminal, un programa lee los caracteres de lo que se llama
 entrada estandar (stdin). Para comunicar errores y mensajes de diagnostico,
 existe una conexion de salida separada llamada stderr.

 La shell, por ejemplo, es un programa que lee caracteres de stdin e
 interpreta los mismos como comandos, argumentos, etc. El comando ls envia
 su salida (el contenido del directorio de trabajo) a stdout y luego se
 visualiza en nuestra pantalla. Este funcionamiento es el predefinido, ya que
 la entrada estandar y la salida estandar se encuentran, normalmente,
 asociadas a la terminal de la computadora, stdin el teclado y stdout a la
 pantalla.

 La shell, sin embargo, nos permite reasignar o redireccionar las conexiones
 de entrada, salida o la de diagnostico de errores. Esta es una de las
 caracteristicas mas poderosas de Linux :)

 6.3.1 REDIRECCIONANDO LA SALIDA

 Supongamos que ejecutamos el comando ps (process status), el cual nos reporta
 del estado de los procesos, que nosotros iniciamos, que se estan ejecutando
 en el sistema. La figura 6.1a nos muestra la salida generada por una
 ejecucion del comando ps. Asi visualizamos la salida en nuestra pantalla.

 Si nos interesa guardar la salida del comando ps, por ejemplo para analizarla
 posteriormente, podemos hacer uso de la redireccion de la salida que nos
 brinda la shell. Le indicamos a la shell que queremos redireccionar la
 salida con el simbolo ">". Entonces, en nuestro ejemplo, debermos ejecutar
 el comando como indica la figura 6.1b. En la misma, observamos que el
 comando termina de ejecutarse sin realizar ninguna salida en la pantalla,
 pues la salida del comando se envio al archivo "procesos" y fue guardada en
 el mismo. Luego mostramos el contenido del archivo procesos, con el comando
 cat, y visualizamos la salida que el comando ps realizo al ejecutarse.

      NOTA: No es necesario que el archivo sobre el cual escribimos al
      redireccionar la salida exista antes de ejecutar el comando ya que la
      shell crea el archivo, si es necesario.

 REDIRECCION NO-DESTRUCTIVA DE LA SALIDA

 Al redireccionar la salida de un comando a un archivo se sobreescriben
 completamente los contenidos del mismo. Hay ocasiones en las que no queremos
 perder la informacion almacenada en un archivo, sino agregarle datos al final
 del mismo. En el ejemplo de la figura 6.1b, los contenidos del archivo
 procesos, si existia antes de ejecutarse el comando, son sobreescritos.
 Para poder concatenar informacion en un archivo usamos ">>" en vez de ">".

 6.3.2 REDIRECCIONANDO LA CONEXION DE ERRORES ESTANDAR

 La conexion de errores estandar es la segunda conexion de salida que el S.O.
 Linux abre para cada programa. Normalmente es conectada a la terminal, o sea
 a nuestra pantalla, y es por eso que cada vez que un programa muestra un
 mensaje de error, este es visualizado en ella. Si ejecutamos un comando y
 redireccionamos la salida del mismo a un archivo, no estamos cambiando para
 nada la conexion de errores estandar de ese comando, por lo que cualquier
 mensaje de error que el comando reporte sera visualizado en pantalla.
 Esto ocurre porque la conexion de errores estandar no se encuentra
 redireccionada. Hay programas que producen una cantidad voluminosa de salida.
 En estos casos uno puede querer redireccionar la conexion de errores estandar
 a un archivo, para luego examinar los mensajes que el programa genero. Para
 redireccionar la conexion de errores estandar se utiliza "2>". El numero 2
 indica el numero de conexion de salida que es justamente la conexion de
 errores estandar.

 6.3.3 REDIRECCIONANDO LA ENTRADA

 Tambien es posible redireccionar la entrada. Ya vimos que uno de los
 programas que lee la informacion de la entrada es la shell, los demas
 programas que vimos (ls, ps, cat, etc.) producen su salida sin leer de la
 entrada estandar. La shell lee los comandos a ejecutar de la entrada estandar.
 Como la entrada estandar puede ser redireccionada a un archivo, es posible
 que la shell obtenga los comandos a ejecutar desde un archivo. Un ejemplo de
 esta situacion se muestra en la figura 6.2. En la misma vemos que los
 contenidos del archivo "comandos" son los nombres de dos comandos de Linux:
 date y ps. Luego utilizando el simbolo "<" redireccionamos la entrada del
 programa bash (Bourne Again Shell) al archivo comandos y los resultados se
 muestran en pantalla.

 REDIRECCIONANDO LA SALIDA Y LA ENTRADA SIMULTANEAMENTE

 Es posible redireccionar, simultaneamente, la entrada estandar y la salida
 estandar. Cuando esto sucede, el unico rol que cumple la terminal es ingresar
 el comando que vamos a ejecutar, pero luego el programa trabaja sin tener
 asociada la entrada ni la salida a la terminal. Salvo que no se redireccione
 la conexion de errores estandar porque los mensajes de error serian
 visualizados en pantalla. La forma de redireccionar la salida y la entrada
 simultaneamente se muestra con un ejemplo en la figura 6.3.

 6.4 CA¥ERIAS: LA INTERCONEXION ENTRE PROGRAMAS

 Las ca¤erias (pipes) conectan la salida estandar de un programa con la entrada
 estandar de otro programa. Una ca¤eria es diferente a la redireccion de la
 entrada/salida. Al redireccionar la entrada conectamos la entrada de un
 programa a un archivo y al redireccionar la salida conectamos la salida del
 programa a un archivo. Una ca¤eria coencta la salida de un programa
 directamente con la entrada de otro programa. Ver figura 6.4.

 Para construir una ca¤eria debemos separar los comandos que queremos
 conectar con el simbolo "|".

 En el ejemplo de la figura 6.5, conectamos dos comandos: ls y wc. El primero
 nos lista el contenido de un directorio, en este caso del directorio /bin. El
 segundo comando, wc (word count) sirve para contar palabras, lineas y
 caracteres, pero al pasarle la opcion -w le estamos diciendo que solo cuente
 palabras. El funcionamiento de este pipe es muy simple: El comando ls lee el
 contenido del directorio /bin y genera una lista de palabras con los nombres
 de los archivos y directorios encontrados. Esta lista, en vez de ser enviada
 a la terminal, es redireccionada a la entrada estandar del comando wc que
 comienza a contar las palabras y muestra el resultado en la salida estandar
 del mismo que es la terminal.

 6.5 GENERACION DE NOMBRES DE ARCHIVOS

 El S.O. Linux nos permite especificar conjuntos de nombres de archivos
 automaticamente utilizando "generacion de nombres de archivos y caracteres
 comodines". Cuando ingresamos argumentos a un comando, la shell examina los
 mismos con el objeto de detectar el uso de la generacion de nombres de
 archivos. El usuario controla la generacion de nombres de archivos
 especificando un modelo para los nombres de archivo. La shell compara el
 modelo provisto con todos los archivos del directorio de trabajo. Si alguno
 de los nombres de archivo responde al modelo, entonces una lista ordenada
 alfabeticamente con todos los nombres de archivos que responden al modelo es
 enviada al programa. Si ninguno de los nombres de archivo del directorio
 actual cumple con el modelo, entonces el modelo (en forma textual) es enviado
 al programa como argumento. Un modelo consiste de caracteres ordinarios y de
 "metacaracteres" llamados caracteres comodines. Los caracteres ordinarios son
 interpretados textualmente; los metacaracteres tiene un significado propio.
 Los metacaracteres utilizados para la generacion de nombres de archivo y sus
 significados se muestran en la tabla 6.1. 

  |øøøøøøøøøøøøøø|øøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøø|
  | Metacaracter |          Significado                                     |
  |--------------|----------------------------------------------------------|
  |      *       | Equivale a cualquier cadena de caracteres                |
  |      ?       | Equivale a cualquier caracter                            |
  |      [       | Comienza una clase de caracteres                         |
  |      ]       | Termina una clase de caracteres                          |
  |      -       | Indica un rango de caracteres en una clase de caracteres |
  |______________|__________________________________________________________| 
      
  Tabla 6.1: Metacaracteres utilizados para generacion de nombres de archivo.

 El asterisco y el signo de pregunta son muy faciles de usar. Por ejemplo *.c
 equivale a todos los archivos que tienen como sufijo .c como pueden ser:
 prog.c, ab.c, Main.c; los siguientes nombres no satisfacen el modelo unit2.cc,
 main.c.cc; el modelo ???.tex equivale a todos los nombres de archivo que
 tengan tres caracteres cualesquiera y luego el sufijo .tex, por ejemplo:
 ref.tex, cp1.tex, bea.tex, c++.tex, cumplen con el modelo pero ab.tex,
 tony.tex, intro.tex chapter1.tex.z no lo satisfacen.

 Los corchetes y el signo menos se utilizan para formar modelos para grupos
 de caracteres. Los caracteres en el grupo (o clase) son especificados dentro
 de los corchetes. El modelo abc[aeiou] representa todo nombre de archivo que
 comienze con abc y culmine con una unica vocal. El signo menos se utiliza
 para especificar rangos de caracteres. El modelo chapter[0-9] representa a
 todos los nombres de archivo que comienzan con chapter y finalizan con un
 digito. Notemos que el rango incluye a sus limites.

 Es necesario realizar una aclaracion con respecto a los archivos ocultos.
 Recordemos que todo archivo tal que su nombre comience con un punto es
 considerado un archivo oculto. La generacion de nombres de archivos no
 considerara que un modelo representa a un archivo oculto si no se especifica
 explicitamente el punto al comienzo del modelo. Por ejemplo: El modelo
 xinit* no representara al archivo cuyo nombre es .xinitrc. Para solucionar
 esto es necesario especificar el modelo de la siguiente forma .xinit*.

  # ps
    PID TTY STAT  TIME COMMAND
    338   1 S    0:00 /bin/login -- root
    356   1 S    0:00 -bash
    368   1 S    0:00 sh /usr/X11R6/bin/startx
    372   1 S    0:01 wmaker
    373   1 S    0:06 kfm
    377   1 S    0:00 wmmon
    381   1 S    0:00 mount.app
    394   1 S    0:37 emacs
    412  p0 S    0:01 kdvi apunte.dvi
    415   1 S    0:01 /usr/local/bin/x11amp
    479   1 S    0:00 kvt
    515  p0 R    0:00 ps

            a. Ejecucion del comando ps

  # ps > procesos

  # cat procesos
    PID TTY STAT  TIME COMMAND
    338   1 S    0:00 /bin/login -- root
    356   1 S    0:00 -bash
    368   1 S    0:00 sh /usr/X11R6/bin/startx
    372   1 S    0:01 wmaker
    373   1 S    0:06 kfm
    377   1 S    0:00 wmmon
    381   1 S    0:00 mount.app
    394   1 S    0:37 emacs
    412  p0 S    0:01 kdvi apunte.dvi
    415   1 S    0:01 /usr/local/bin/x11amp
    479   1 S    0:00 kvt
    515  p0 R    0:00 ps

            b. Ejecucion del comando ps redireccionando la salida al archivo
               "procesos"

            Figura 6.1: Redireccionando la salida del comando ps.

  # cat comandos
  date
  ps
  # bash < comandos
  Thu Apr 15 19:47:03 ART 1999
    PID TTY STAT  TIME COMMAND
    338   1 S    0:00 /bin/login -- root
    356   1 S    0:00 -bash
    368   1 S    0:00 sh /usr/X11R6/bin/startx
    372   1 S    0:01 wmaker
    373   1 S    0:06 kfm
    377   1 S    0:00 wmmon
    381   1 S    0:00 mount.app
    394   1 S    0:37 emacs
    412  p0 S    0:01 kdvi apunte.dvi
    415   1 S    0:01 /usr/local/bin/x11amp
    479   1 S    0:00 kvt
    515  p0 R    0:00 ps
   
            Figura 6.2: Redireccionando la entrada para que la shell ejecute
                        comandos desde un archivo.

  # cat comandos
  date
  pwd
  # bash < comandos > salida
  # cat salida
  Thu Apr 15 20:06:30 ART 1999
  /home/tony/docs/linux

            Figura 6.3: Redireccionando la entrada y la salida.



      |øøøø|__    <------------------------------------------------------\
  |---|____|  |_____                                                      |
  |    |      |     |            stderr                                   |
  |    |______|     | -----------------------------------> |øøøøøøøø|     |
  |         |       |                                      |        |     |
  |---------|       |                                 _--> |________|     |
     |  PROG1       |                                |        |   |       |
     |______________| --\                            |     /øøøøøøøøø\  --/
                         | stdout                    |    øøøøøøøøøøøøø
                         |                           |
                         |                           |
                         |                           |
                          \                          |
                          |                          |
      |øøøø|__            |                          |
  |---|____|  |_____      |                          |
  |    |      |     | <--/  stdin                    |
  |    |______|     |                                |                 
  |         |       |                                |                  
  |---------|       |                stdout & stderr |               
     |  PROG2       |                                |                
     |______________|  -----------------------------/                
                                                                       
            Figura 6.4: Ca¤eria de dos programas.


  # ls /bin | wc -w
       75

            Figura 6.5: Ejemplo de una ca¤eria. Contar la acntidad de
                        archivos en un directorio.
 


 CAPITULO 7

 COMANDOS Y UTILIDADES

 7.1 MOVIMIENTO EN EL SISTEMA DE ARCHIVOS

 EL directorio actual, o el direcorio de trabajo, es probablemente la pieza
 de informacion mas importante del entorno de trabajo. En cualquier momento,
 podemos saber cual es el directorio actual ejecurando el comando pwd (print
 working directory). La utilizacion de este comando se muestra en la figura
 7.1.

  # pwd
  /home/tony/txts/manual-linux

            Figura 7.1: Averiguando el directorio de trabajo.

 Una vez que completamos el proceso de inicio de sesion (log in), nos
 encontramos en el directorio home que el administrador del sistema nos ha
 designado. Con el comando cd (change directory) podemos cambiar el directorio
 de trabajo. Para ello tenemos que invocarlo con un argumento: el directorio
 que queremos que sea el directorio de trabajo. Se muestran ejemplos de este
 comando en la figura 7.2.

 El argumento con el que proveemos al comando cd puede ser tanto una ruta
 absoluta como una ruta relativa. En la figura 7.2a vemos un ejemplo de una
 ruta relativa y en las figuras 7.2b y c vemos ejemplos de argumentos de
 rutas relativas. Como caso especial, si ejecutamos el comando cd sin
 parametros, el nuevo directorio de trabajo sera nuestro direcotrio home.

 7.2 LISTADO DE ARCHIVOS

 7.2.1 LISTANDO ARCHIVOS

 Como fue comentado anteriormente, el comado ls (list) se utiliza para listar
 el contenido de los directorios. Este comando utiliza muchas opciones, muchas
 de las cuales no vamos a tratar aqui. Nos vamos a ocupar de su uso mas comun
 y de sus opciones mas utiles. El comando ls acepta multiples argumentos. Cada
 argumento que le pasamos puede ser el nombre de un archivo, de un directorio
 o una opcion (modificador). Si no le pasamos ningun argumento, entonces nos
 mostrara el contenido del directorio de trabajo. Por defecto, este comando
 nos muestra el contenido de los directorios en forma de columnas con los
 nombres de archivos encontrados como se muestra en la figura 7.3.

  # pwd
  /home/tony
  # cd /
  # pwd
  /

    a. Cambiando de directorio de trabajo de nuestro directorio home al
       directorio raiz.

  # pwd
  /
  # cd bin
  # pwd
  /bin

    b. Cambiando el directorio de trabajo a un subdirectorio.

  # pwd
  /home/tony/txts
  # cd ..
  # pwd
  /home/tony

    c. Cambiando el directorio de trabajo al directorio padre.

             Figura 7.2: Cambiando el directorio de trabajo.

  # ls
  init.d     rc.local     rc0.d      rc2.d     rc4.d     rc6.d
  rc         rc.sysinfo   rc1.d      rc3.d     rc5.d

             Figura 7.3: Listado del contenido de un directorio.

 Como vemos, el listado se presenta en orden alfabetico. De esta forma, la
 unica informacion que tenemos de cada archivo o directorio listado es su
 nombre. Cuando queremos conocer informacion adicional de cada archivo debemos
 usar los modificadores adecuados.

 LISTADO EN FORMATO LARGO

 El modificador -l indica al comando ls que visualize los nombres de los
 archivos y directorios junto con otros atributos, mas especificamente sus
 permisos, su due¤o, el grupo al que pertenece, la cantidad de links que
 posee, su tama¤o (en bloques), y su fecha de modificacion. Un ejemplo de un
 listado largo de archivos se muestra en la figura 7.4.

  # ls -l
  drwx------    2 root     root         1024 Mar 22 20:55 Xfree86/
  -rw-r--r--    1 root     root        25787 Apr  9 04:48 djetool-0.1.6.tar.gz
  -rw-r--r--    1 root     root       143078 Apr  9 04:50 hpdj-2.5.tar.gz
  -rw-r--r--    1 root     root       252411 Apr  9 04:11 kalendar-0.5b.tar.gz
  -rw-r--r--    1 root     root       677963 Apr  9 04:27 kget-0.6.1.tgz
  -rw-r--r--    1 root     root       766699 Apr  9 04:13 korganizer-1.1.tar.gz
  -rw-r--r--    1 root     root       288856 Apr  9 04:20 kpackage-1.2.tgz
  -rw-r--r--    1 root     root        92157 Apr  9 04:18 kuser-0.6.0.tar.gz
  -rw-r--r--    1 root     root      2643205 Apr  9 04:37 qt-1.42.tar.gz
  -rw-r--r--    1 root     root       140918 Apr  9 04:51 xtexcad-2.1.tar.z

      Figura 7.4: Listado en formato largo del contenido de un directorio  
    
 Sobre el ejemplo anterior se pueden notar varios puntos interesantes:

  * Cada archivo o directorio es mostrado en una linea separada acompa¤ado
    de toda su informacion adicional.

  * La primer columna de la lista, la cual es una serie de simbolos, especifica
    que permisos posee el archivo, pero ademas nos muestra, mediante el primer
    caracter, el tipo del archivo. Los diferentes codigos que se utilizan se
    muestran en la tabla 7.1.

  * La primera entrada en la lista se diferencia de todas las demas porque el
    codigo de tipo de archivo es "d", lo que significa que es un directorio,
    mientras que todas las demas entradas muestran "-" lo que nos informa
    que son archivos ordinarios.

  * La columna siguiente especifica la cantidad de hard links que posee el
    archivo. En el caso del directorio Xfree86 vemos que posee 2 mientras
    que los demas archivos todos tiene un solo link. El directorio posee 2
    links porque uno es creado por el directorio en si mismo y el otro es la
    entrada que se nombra "." que todo directorio contiene y que apunta a si
    mismo. Cada directorio tiene ademas otra entrada denominada ".." que
    apunta a su padre. Esto quiere decir que si un directorio "dir" tiene 4
    subdirectorios, entonces cada uno de estos poseera una entrada ".." que
    apuntara a "dir". Por lo tanto, el direcotrio "dir" tendra asociados 6
    links: uno que represente al directorio, uno por la entrada "." dentro
    de el, y uno por cada subdirectorio que posea. Esta situacion se muestra
    en la figura 7.5.

  * Las siguientes columnas especifican el usuario que es due¤o del archivo o
    directorio, y el grupo al que pertenece.

  * La columna que sigue nos muestra el tama¤o del archivo, pero este tama¤o
    es especificado en bloques. Esto es porque el S.O. utiliza bloques como la
    unidad de transferencia entre memoria y los dispositivos de bloques
    utilizados (discos rigidos, CD-ROM's, disketteras, etc). Tanto los archivos
    como los directorios pueden tener un numero cualquiera de bloques. En gral.,
    en Linux, se utilizan bloques de 1KB o sea (1024 bytes), pero esto no
    siempre es verdad ya que pueden utilizarse tambien bloques de 512 bytes.

  * La siguiente columna nos muestra el momento en el que se modifico por
    ultima vez el archivo o el directorio.

    NOTA: Disculpen semjante dibujo, pero es que si lo hacia mas chico, mo se
    iba a entender demasiado ;)

                         _____ ______ ________
                        |     |      |        |
               /        | mnt | Tony | README |
                        |_____|______|________|
                                  \
                                  1 \
                                      \
              ________________________\|/___________________
             |         |         |        |        |        |
         /-->|    .    |  dir1   |  dir2  |  dir3  |  dir4  | <---------------------------\       
        |    |_________|_________|________|________|________|                               \
      2 |       |         |  /|\        |    |   |   /|\  \                                   \
         \_____/          |   |         |    |    \    \    \                                   \
                          |   |         |     \     \    \    \__________________                 \
                         /    |         |       \     \    \ ______               \                 \  6
                       /      |          \        \     \           \ 5             \____             \
                     /         \           \        \     \_____      \_______            \             \
                   /         3 |             \      4 \         \              \           |             |
       __________\|/______     |    _______ _\|/____   |      __\|/__ _______   |       __\|/________    |
      |         |         |   /    |       |        |  |     |       |       |  |      |      |      |   |
  /-->|    .    |   ..    |--/  /->|   .   |   ..   |--/ /-->|   .   |  ..   |--/  /-->|  .   |  ..  |--/
 |    |_________|_________|    |   |_______|________|   |    |_______|_______|    |    |______|______|
 |       |                     |       |                |       |                 |      |
  \_____/                       \_____/                  \_____/                   \_____/

               Figura 7.5: Links definidos sobre un directorio.

             ______________________________________________     
            | Codigo  | Significado                        |
            |øøøøøøøøø|øøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøø|     
            |    -    | Archivo ordinario                  |
            |    d    | Directorio                         |
            |    c    | Archivo de dispositivo de caracter |
            |    b    | Archivo de dispositivo de bloque   |
            |    l    | Link simbolico                     |
            |    p    | Archivo de ca¤eria                 |
             øøøøøøøøø øøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøøø     

               Tabla 7.1: Codigos de tipos de archivos y sus significados.

 LISTADO DE ARCHIVOS OCULTOS

 Se pueden notar, en los ejemplos anteriores, que tanto el listado predefinido
 como el listado largo producidos por el comando ls no nos muestran los
 archivos ocultos, es decir aquellos que su nombre comienza con un punto ".".
 Para listar los archivos ocultos es necesario especificar la opcion -a. Un
 ejemplo de listado de archivos ocultos se muestra en la figura 7.6.

 LISTADO DE DIRECTORIOS

 Hemos dicho que le podemos pasar varios argumentos al comando ls. Estos
 argumentos pueden ser archivos o directorios. Supongamos que queremos
 averiguar los permisos que tiene un archivo determinado. Para ello
 ejecutamos:

  ==>  ls -l <archivo>

 Como muestra la figura 7.7a. La ejecucion del comando tendra como resultado
 una unica linea correspondiente al archivo solicitado y su informacion
 correspondiente. Supongamos que, ahora, queremos averiguar los permisos
 que tiene seteados un cierto directorio. Intuitivamente se puede pensar que
 ejecutando ls -l <directorio> vamos a obtener la misma informacion que
 obtuvimos con el archivo. Veamos la figura 7.7b cual es el resultado.
 Imagino que adivinaron cual es el problema. En caso de que no, piensen lo
 siguiente: el comado ls cuando recibe un argumento decide si el mismo es
 un archivo o un directorio. En caso de ser un archivo lista la informacion
 solicitada del mismo y en caso de ser un directorio lista la informacion
 para cada archivo que se encuentre dentro del direcotorio especificado.
 Para que el comando nos liste solo la informacion del directorio y no de su
 contenido es necesario especificar la opcion -d (directory). El comando
 quedara de la siguiente forma:

  ==>  ls -dl <directorio>

   Ver figura 7.7c.

 7.3 MANIPULANDO ARCHIVOS

 Los comandos mv (move), cp (copy), ln (link) y rm (remove), junto con ls son
 los comandos mas importantes a la hora de manipular los archivos de Linux.
 Move y copy se utilizan para mover archivos de un lado a otro en el sistema
 de archivos. La unica diferencia entre ellos es que move borra el archivo
 original y copy no. El comando link se utiliza para establecer pseudonimos
 a los archivos (links). Para borrar los archivos utilizamos el comando
 remove.

 7.3.1 MOVIENDO Y COPIANDO ARCHIVOS

 El comando mv mueve un archivo de un sitio a otro. Si ambos sitios se
 encuentran en el mismo sistema de archivos, entonces el movimiento es
 esencialmente una operacion de renombre. Si por el contrario, los sitios se
 encuentran en distintos sistemas de archivos entonces se realiza una copia y
 luego se borra la original. La sintaxis del comando mv es:

  ==>  mv [opciones] fuente..  destino

 Donde las opciones son opcionales, valga la redundancia, y fuente...
 significa que podemos especificar varios argumentos de fuente, pero solo uno
 de destino.

 Vemos varios ejemplos en la figura 7.8. En el primer ejemplo (figura 7.8a)
 utilizamos mv para cambiar el nombre de un archivo. En el ejemplo siguiente
 (figura 7.8b) movemos un archivo de un directorio a otro y en el ultimo
 ejemplo (figura 7.8c) movemos varios archivos.

  # ls -l penguinc06.gif
  -rw-r--r--   1 root    root       8994 Apr  9 04:42 penguinc06.gif

                      a. Listando la informacion de un archivo.

  # ls -l Xfree86/
  total 6756
  -rw-r--r--   1 root    root          21268 Mar 22 20:27 README
  -rw-r--r--   1 root    root         818655 Mar 22 21:04 XVG16.tgz
  -rw-r--r--   1 root    root        2587331 Mar 22 20:53 Xbin.tgz
  -rw-r--r--   1 root    root           3340 Mar 22 20:39 Xcfg.tgz
  -rw-r--r--   1 root    root         311690 Mar 22 20:34 Xdoc.tgz
  -rw-r--r--   1 root    root        1284484 Mar 22 20:50 Xfonts.tgz
  .
  .
  .

       b. Intento fallido de listado de informacion de un directorio.

  # ls -dl Xfree86/
  drwx------   2 root    root           1024 Mar 22 20:55 Xfree86/

        c. Intento exitoso.

        Figura 7.7: Listando direcotorios e informacion sobre direcotorios.

 Para copiar archivos utilizamos el comando cp que se comporta de forma
 similar a mv, pero con la salvedad de que no borra la fuente del archivo
 original. Al igual que mv acpeta multiples argumentos siempre y cuando el
 ultimo de ellos sea un directorio. En el ejemplo de la figura 7.9a realizamos
 una copia de un archivo en el directorio donde este se encuentra; en el
 ejemplo de la figura 7.9b copiamos el mismo archivo pero en otro directorio
 y en el utimo ejemplo (figura 7.9c) copiamos varios archivos en un directorio.

 COPIANDO DIRECTORIOS

 Si necesita copiar un directorio en vez de archivos, debemos especificar la
 opcion -R o -r (recursive) ya que sino el comando omitira cada argumento
 fuente que sea un directorio y no sera copiado. En caso de proveer esta
 opcion, todo argumento que corresponda a un directorio sera copiado
 (incluyendo todos sus subdirectorios y los subdirectorios de estos y etc)
 en el directorio destino especificado. Veamos un ejemplo en le figura 7.10.
 Supongamos que queremos copiar el directorio mail -que es subdirecotorio de
 Tony- completo con sus archivos en el directorio /backup que se encuentra
 vacio. Para ello ejecutamos:

  ==>  cp -r mail/ /backup/

  # ls
  kernel-2.1.125  kernel-2.2.1   kernel-2.2.5
  # mv kernel-2.2.5 kernel
  # ls
  kernel      kernel-2.1.125   kernel-2.2.1

     a. Utilizando mv para renombrar archivos

  # ls
  kernel      kernel-2.1.125  kernel-2.2.1
  # mv kernel ../config/
  # ls ../config/
  kernel
  # ls
  kernel-2.1.125  kernel-2.2.1

     b. Moviendo un archivo de un directorio a otro.

  # ls
  kernel-2.1.125  kernel-2.2.1   kernel-2.2.5
  # mv kernel* ../config/
  # ls ../config/
  kernel-2.1.125  kernel-2.2.1   kernel-2.2.5
  # ls

     c. Moviendo varios archivos de un directorio a otro.

         Figura 7.8: Moviendo archivos.

 En la figura 7.10 se muestra el arbol resultante una vez realizada la copia.
 El directorio que se copio se muestra resaltado con una elipse

 7.3.2 REALIZANDO LINKS

 Como vimos en la seccion 2.1.6 los "links" sirven para establecer
 pseudonimos entre los archivos, es decir para que un mismo archivo fisico
 sea referenciado por varios nombres logicos. En la terminologia de Linux
 estos pseudonimos son llamados "links". Como tambien ya vimos, existen dos
 tipos de links: hard links y links simbolicos. Primero veremos los hard links
 y despues nos ocuparemos de los simbolicos.

 El comando ln es el utilizado en Linux para establecer los links.

 CREANDO Y MANIPULANDO HARD LINKS

 Los hard links se crean con el comando ln. Supongamos que queremos crear un
 link llamado index.htm a un archivo que se llama presentacion.htm.
 El comando para realizar esto se muestra en la figura 7.11.

 Una vez creado el hard link, tanto el viejo nombre del archivo (presentacio.htm)
 como el nuevo (index.htm) se refieren al mismo archivo, es decir a los
 mismos datos en la misma locacion fisica del disco. Una vez creados los
 links, podemos ver los numeros de i-nodo asociados a cada nombre de archivo
 ejecutando el comando siguiente:

   ==> ls -i

  # pwd
  /usr/local/articles/NT lies/
  # ls
  Lies.htm  lie10.jpg  lie3.jpg  lie5.jpg  lie7.jpg  lie9.jpg
  lie1.jpg  lie2.jpg   lie4.jpg  lie6.jpg  lie8.jpg 
  # cp Lies.htm index.htm
  # ls
  Lies.htm  lie1.jpg  lie2.jpg  lie4.jpg  lie6.jpg  lie8.jpg
  index.htm lie10.jpg lie3.jpg  lie5.jpg  lie7.jpg  lie9.jpg 

       a. Copiando un archivo sobre un mismo directorio.

  # ls
  Lies.htm  lie1.jpg  lie2.jpg  lie4.jpg  lie6.jpg  lie8.jpg
  index.htm lie10.jpg lie3.jpg  lie5.jpg  lie7.jpg  lie9.jpg 
  # cp Lies.htm /root/articles/
  # ls /root/articles/
  Lies.htm

        b. Copiando un archivo hacia otro directorio.

  # ls
  Lies.htm  lie1.jpg  lie2.jpg  lie4.jpg  lie6.jpg  lie8.jpg
  index.htm lie10.jpg lie3.jpg  lie5.jpg  lie7.jpg  lie9.jpg 
  # cp lie* /root/articles/
  # ls /root/articles/
  Lies.htm  lie10.jpg  lie3.jpg  lie5.jpg  lie7.jpg  lie9.jpg
  lie1.jpg  lie2.jpg   lie4.jpg  lie6.jpg  lie8.jpg 

         c. Copiando varios archivos.

           Figura 7.9: Copiando archivos.

 En la figura 7.11 vemos que tanto el archivo el archivo presentacion.htm
 como el archivo index.htm poseen el mismo numero de i-nodo, lo que quiere
 decir que ambos nombres se refieren al mismo "archivo fisico". Esto se
 ilustra en la figura 7.12a. A partir de esto, es valido acceder al archivo
 con cualquiera de los dos nombres que este posee. Es importante notar que si
 modificamos el archivo presentacion.htm, por lo dicho anteriormente, tambien
 modificamos el archivo index.htm.

 En la figura 7.11, antes de crear el hard link, listamos los detalles del
 archivo presentacion.htm y vemos que el numero de links del mismo es 1.
 Cuando listamos por segunada vez, luego de haber creado el hard link, vemos
 que el numero de links de ambos archivos es 2. Ademas de esto notemos que
 todos los atributos restantes son iguales, incluyendo los permisos.
 
          _______________________
     /    | mnt | Tony | backup |
          øø/øøøøøø|øøøøøøøøøøøøø\              __________________
          /         \              \           /                  \
        /           __\____________  \        | ________            \______
       @            | prog | mail |    \------+-| mail |                   \
                    øøøøøøøøøøøø\øø           | øøøøøøøø\                    \
                                  \           |           \                    \
                                    \          \_______     \                   |
                ____________________  \                 \     \                 |
               | mod1 | mod2 | exec |  _\_______________ | _____\___________    |
                øø|øøøøøø|øøøøøø|øøø   | mess | attach | | | mess | attach |    |
                  |      |      |      øøø|øøøøøøø|øøøøø | øøø|øøøøøøø|øøøøø    |
                  |      |      |         |       |      |    |       |         |
                  @      @      @         @       @       \   @       @         |
                                                            \                   |
                                                              \________________/

   # ls mail/
   attach mess
   # cp -r mail /backup/
   # ls /backup/
   mail
   # ls /backup/mail/
   attach mess

                Figura 7.10: Copiando directorios recursivamente.

 OBSERVACIONES ACERCA DE LOS HARD LINKS

 Los hard links, como ya vimos, relacionan nombres de archivos con numeros de
 i-nodo. Un sistema de archivos posee un cierto numero de i-nodos con los
 cuales identifica los archivos que posee. Lo que quiere decir que los i-nodos
 son relativos a un sistema de archivos particular y que podemos tener dos
 archivos distintos que se encuentran en distintos sistemas de archivos, pero
 con el mismo numero de i-nodo. Por esto, no se pueden establecer hard links
 entre archivos que se encuentren en distintos sistemas de archivos archivos.
 Esto es una limitacion importante a la hora de utilizar hard links.

 CREANDO Y MANIPULANDO LINKS SIMBOLICOS

 Para crear links simbolicos tambien utilizamos el comando ln pero modificamos
 su comportamiento con la opcion -s, la cual especifica que el link a crear
 sera un link simbolico. En la figura 7.13 vemos como se crearia un link
 simbolico index.htm al archivo presentacion.htm.

 Al listar los contenidos del directorio, una vez creado el link simbolico,
 vemos que la entrada del archivo index.htm nos informa que el archivo es un
 link simbolico (atributo 1 en la columna de tipo de archivo).

 Ademas vemos que el numero de links del archivo presentacion.htm es 1, esto
 es porque este numero cuenta la cantidad de hard links establecidos y no se
 contabilizan los links simbolicos. Esto quiere decir que al borrar el archivo
 presentacion.htm se borraran directamente los contenidos, y el link simbolico
 quedara destruido, es decir apuntara a algo que ya no existe.

   # ls -l
   total 60
   -r--------   1 root    root         59997 Apr 28 22:47 presentacion.htm
   # ln presentacion.htm index.htm
   # ls -l
   ls -l --color=none
   total 120
   -r--------   2 root    root         59997 Apr 28 22:47 index.htm 
   -r--------   2 root    root         59997 Apr 28 22:47 presentacion.htm
   # ls -i
    262288 index.htm         262288 presentacion.htm

                    Figura 7.11: Estableciendo hard links.

 Otra cosa para notar en el listado, es que la columna respectiva al nombre
 de los archivos, vemos que el archivo index.htm apunta al archivo
 presentacion.htm.

 Es importante tener en cuenta que estos archivos son dos archivos separados.
 Es decir que cada uno tiene sus atributos propios. Por ejemplo, en la figura
 7.13 vemos que los archivos tiene distintos tama¤os, distintas fechas de
 modificacion, etc.

 Al realizar la consulta de los numeros de i-nodo de los archivos, vemos
 tambien que ambos archivos tiene distinto numero de i-nodo, lo que quiere
 decir que ambos tienen un lugar fisico distinto en el medio donde se
 almacenan.

 Anteriormente, vimos que no es posible crear hard links entre archivos que
 se encuentran en distintos sistemas de archivos. Con los links simbolicos,
 esto no es problema, ya que la asociacion se realiza por nombre y no por
 numero de i-nodo. Ver figura 7.12b.

 Al crear los links simbolicos, debemos tener cuidado con la forma en que los
 creamos, ya que podemos hacerlo mediante una ruta relativa o una ruta
 absoluta. Un problema que podemos tener si creamos un link con una ruta
 relativa, es que si movemos el link a otro lugar del sistema de archivos,
 perderemos la asociacion entre los archivos. Con los links absolutos, esto
 no es problema.

   Observacion: Si borramos el archivo que es link simbolico, este sera
                eliminado pero no se borrara el archivo al cual apunta.
                Para borrar el archivo apuntado debemos borrar este
                directamente.

                            __________
                           |          |
                           |          |           _______
                           |          |          |       |
   index.htm -----------.  |          |   .----->|       |
                        |  |          |   |      |_______| 
   presentacion.htm --. |  |          |   |
                      | ø->|----------|___|       Archivo
                      ø--->|__________|
                           |          |
                           |__________|

                         Tabla de i-nodos

     a. Un hard link entre los archivos presentacion.htm e index.htm.

                            __________
                           |          |
                           |          |           _______
    index.htm              |          |          |       |
       |                   |          |   .----->|       |
      \|/                  |          |   |      |_______| 
   presentacion.htm --.    |          |   |
                      |    |----------|___|       Archivo
                      ø--->|__________|
                           |          |
                           |__________|

                         Tabla de i-nodos

     b. Un link simbolico del archivo index.htm al archivo presentacion.htm.

       Figura 7.12: Estructura logica de los links entre archivos.

 7.3.3 ELIMINANDO ARCHIVOS

 Para eliminar archivos ordinarios, utilizamos el comando rm (remove). Vemos
 un ejemplo en la figura 7.14. Debemos tener en cuenta que para poder eliminar
 archivos debemos tener permiso de escritura en el directorio donde se
 encuentren los archivos.

 Si tenemos permiso de escritura sobre el archivo a borrar, entonces el
 mismo sera borrado directamente. En cambio, si no tenemos permiso de
 escritura sobre el archivo, entonces el comando nos preguntara si queremos
 ignorar la proteccion y borrarlo igualmente. Si contestamos "y" (yes), el
 archivo sera borrado, solo si somos due¤o del mismo, sino obtendremos un
 mensaje que nos indicara que no tenemos permiso para borrar el archivo.
 Esto es ilustrado en la figura 7.14: el archivo vi.htm tiene permiso de
 escritura, por lo que es borrado inmediatamente. En cambio el archivo
 persentacion.htm no tiene seteado el permiso de escritura, por lo que el
 comando nos preguntara si queremos ignorar la proteccion. Contestamos que si
 y el archivo es eliminado.

 Se debe tener mucho cuidado cuando eliminamos archivo en Linux, ya que los
 archivos eliminados realmente SE PIERDEN Y NO HAY FORMA DE RECUPERARLOS. No
 existe ningun mecanismo de recuperacion de archivos en Linux. Siempre que
 estemos en duda de borrar un archivo, pensemos en preservarlo ya que no
 tendremos forma de recuperarlo.

 OPCIONES DEL COMANDO RM

 Las opciones mas importantes del comando rm son las siguientes:

  * -f: Forzar la eliminacion de los archivos sin permiso de escritura sin
        pedir la confirmacion.

  * -i: Operacion interactiva. Realizar una confirmacion antes de eliminar
        cada archivo. Las respuestas que comienzan con y o Y son consideradas
        afirmativas.

  * -r: Operacion recursiva. Elimina archivos y subdirectorios, borrando todo
        un subarbol de directorios.

  # ls
  presentacion.htm
  # ls -s presentacio.htm index.htm
  # ls -l
  total 60
  lrwxrwxrwx  1 root    root            16 Apr 29 19:11 index.htm -> presentacion.htm
  -r--------  1 root    root         59997 Apr 28 22:47 presentacion.htm
  # ls -i
   262269 index.htm       262269 presentacion.htm

                  Figura 7.13: Estableciendo links simbolicos.

  # ls -l
  total 14
  -rw-r--r--  1 gg      users        7559 May  2 01:15 commands.htm
  -r--------  1 gg      users        2880 May  2 01:15 presentacion.htm
  -rw-r--r--  1 gg      users        2880 May  2 01:15 vi.htm
  # rm vi.htm
  # rm presentacion.htm
  rm: remove 'presentacion.htm', overriding mode 0400? y
  # ls
  commands.htm

                  Figura 7.14: Eliminando archivos.

 7.4 MANIPULANDO DIRECTORIOS

 7.4.1 CREANDO DIRECTORIOS

 Para organizar nuestros archivos utilizamos directorios y subdirectorios. La
 creacion de directorios tambien se realiza mediante comandos. El comando para
 crear directorios es mkdir (make directory). El mismo acepta una lista de
 argumentos (cada argumento puede ser una rura absoluta o una rura relativa) y
 crea un directorio por cada argumento que se encuentre en la lista. Los
 directorios, una vez creados, se encuentran vacios.

 Veamos un ejemplo en la figura 7.15. primero creamos un directorio llamado
 qt, verificamos que haya sido creado y vemos que esta vacio. Luego creamos
 tres directorios juntos (c, java. c++).

    # la
    # mkdir qt
    # ls
    qt
    # ls qt
    # mkdir c java c++
    # ls
    c     c++    java    qt

      Figura 7.15: Creando directorios.

 7.4.2 ELIMINANDO DIRECTORIOS

 Tenemos dos formas de eliminar directorios:

  1. Utilizando el comando rm con la opcion -r (recursive). Esto borrara un
     directorio junto a todo su contenido (archivos y subdirectorios)
     eliminando asi todo un subarbol.

  2. Utilizando el comando rmdir (remove directory). Este comando nos permite
     eliminar directorios pero con la exigencia de que los mismos esten vacios.
     Si queremos borrar un directorio que tiene archivos dentro, debemos,
     primero, eliminar los mismo com rm y luego eliminar el directorio con
     rmdir.

 Ilustramos ambas formas en la figura 7.16. En la figura 7.16a, borramos el
 directorio com rm -r y en la figura 7.16b lo hacemos con rmdir. Notemos, en
 el primer caso, que el comando nos pide confirmacion para cada archivo o
 directorio que se encuentre en el directorio a borrar. Esto se puede evitar
 utilizando rm -rf, ya que la opcion -f (force), hace que no se realicen las
 confirmaciones y borra directamente.

 En el segundo caso, primero debemos vaciar el directorio (en este caso lo
 hacemos con rm -f) y luego debemos eliminar el directorio con rmdir.

 7.5 BUSQUEDA DE ARCHIVOS

 En ocasiones podemos estar interesados en averiguar donde se encuentran
 determinados archivos. Cuando queremos buscar uno o mas archivos dentro de
 un directorio en particular, podemos utilizar el comando ls para listar los
 archivos y verificar en la lista si el/los mismos se encuentran alli. Pero
 cuando queremos buscar archivos en todo un subarbol de directorios, trabajar
 con ls puede resultar muy incomodo.

 El comandp find (buscar), localiza archivos, de acuerdo a un criterio de
 busqueda, en todo un subarbol de directorios y nos reporta los resultados.

 Los criterios de busqueda del comando find se pueden ser combinar para
 realizar busquedas realmente complejas. Aqui vamos a estudiar los criterios
 mas utilizados a nivel usuario que a su vez son los mas sencillos.

 La sintaxis del commando find es la siguiente:

  ==> find <path...> <criterio>

   * <path...> es una lista de directorios donde se comenzara a buscar. find
     buscara en los subarboles que comienzan en cada directorio especificado
     en la lista de directorios.

   * <criterio> es una serie de acciones, tests y opciones que especifican
     un cierto criterio de busqueda y posiblemente ciertas acciones a
     realizar sobre los archivos encontrados. Esto se vera mas adelante.

    # ls
    c    c++    java    qt
    # ls java
    hello-world.class  hello-world.java
    # rm -r java
    rm:descend directory 'java'? y
    rm: remove 'java/hello-world.java'? y
    rm: remove 'java/hello-world.class'? y
    rm: remove directory 'java' y
    # ls
    c    c++    qt

               a. Eliminando un directorio con rm -r.

    # ls
    c    c++    java    qt
    # ls java
    hello-world.class  hello-world.java
    # rmdir java
    rmdir: java: Directory not empty
    # rm -f java/*
    # rmdir java
    # ls
    c    c++    qt

               b. Eliminando un directorio con rmdir.

                 Figura 7.16: Eliminando directorios

 No vamos a analizar detalladamente la sintaxis de la expresion que denota los
 criterios de busqueda, sino que vamos a ilustrar el uso del comando find con
 varios criterios de busqueda tipicos.

 7.5.1 EJEMPLOS DEL USO DE FIND

 BUSCANDO ARCHIVOS POR NOMBRE

 Supongamos que queremos buscar todos los archivos que comiencen con X en el
 subarbol que encabeza el directorio /etc. El comando utilizado para realizar
 la busqueda y el resultado de la misma se muestran en la figura 7.17.

 En este ejemplo, para realizar la busqueda, le pasamos como ruta de comienzo
 el directorio /etc y la expresion que especifica que el criterio es -name X*.
 La opcion -name especifica al comando find que queremos realizar la busqueda
 por nombre de archivo y el argumento X* expresa que queremos buscar los
 archivos cuyo nombres comiencen con X.

 En general, la busqueda de archivos por nombre se realiza con el siguiente
 comando:

  ==>  find <path> -name <expresion>

 Donde la expresion especifica el formato de los nombres a buscar. Para formar
 la expresion podemos utilizar todas las capacidades de generacion de nombres
 de archivo que nos prove la shell (ver seccion 6.5).

  # find /etc -name X*
  /etc/X11
  /etc/X11/xinit/Xclients
  /etc/X11/xdm/Xaccess
  /etc/X11/xdm/Xresources
  /etc/X11/xdm/Xservers
  /etc/X11/xdm/Xsession
  /etc/X11/xdm/Xsetup_0
  /etc/X11/X
  /etc/X11/XF86Config

                   Figura 7.17: Buscando archivos por nombre.

 BUSCANDO ARCHIVOS POR TAMA¥O

 Otro uso comun del comando find es la busqueda de archivos por tama¤o. Para
 buscar archivos por tama¤o, en vez de utilizar la opcion -name utilizamos la
 opcion -size. A continuacion de esta opcion debemos especificar el tama¤o de
 los archivos a buscar y ademas si queremos buscar archivos mas grandes o mas
 chicos que el tama¤o especificado. Veamos un ejemplo en la figura 7.18.

  # find /mp3 -size +700k
  /mp3/Nirvana/Lithium.mp3
  /mp3/Black Sabbath/paranoid/War Pigs.mp3
  /mp3/Led Zeppelin/Stairway to Heaven.mp3

           Figura 7.18: Buscando archivos por tama¤o.

 En este ejemplo, queremos encontrar todos los archivos que tengan un tama¤o
 mayor a 7000 Kbytes, a partir del directorio /mp3. Debemos realizar dos
 observaciones:

  * El signo "+" que prefijamos al argumento que especifica el tama¤o obliga
    al comando find a realizar un test. En este caso testeara que el tama¤o
    del archivo sea mayor a 7000 Kbytes. En caso de querer buscar archivos
    de un tama¤o menor al argumento debemos prefijar el simbolo "-". Si no
    usamos ningun simbolo, find buscara archivos cuyo tama¤o sea exactamente
    igual al argumento especificado.

  * La letra "k" que agregamos luego del argumento informa a find que la
    unidad a utilizar sera Kbytes. Tambien podemos utilizar:

    - "c": Bytes

    - "w": Palabras (words) de 2 bytes cada una

    - "b": Bloques de 512 bytes cada uno (esta opcion es utilizada por
           defecto si no especificamos ninguna).

 BUSCANDO ARCHIVOS POR FECHA DE MODIFICACION

 Otra manera de utilizar el comando find para buscar archivos es utilizando
 criterios de busqueda basados en fechas de modificacion de los archivos. En
 este caso la opcion a utilizar es -mtime (modified time). Vemos un ejemplo
 en la figura 7.19.

  # find /gome/tony/html -name *.htm -mtime -6
  /home/tony/html/commands.htm
  /home/tony/html/vi.htm

        Figura 7.19: Buscando archivos por fecha de modificacion.

 El argumento de la opcion -mtime es un numero que especifica la cantidad de
 dias. Si prefijamos un "-", entonces find buscara archivos que hayan sido
 modificados dentro de la cantidad de dias especificada. Si prefijamos un "+"
 al argumento, entonces se buscaran archivos que no hayan sido modificados
 en ese periodo. Esto es particularmente util cuando queremos generar listas
 de archivos viejos.

 En este ejemplo, ilustramos como es posible combinar opciones para formar
 criterios de busqueda mas avanzados. En este caso solo seran devueltos como
 resultado los nombres de los archivos que terminen con ".htm" y hayan sido
 modificados en los ultimos 6 dias.

 EFECTUANDO ACCIONES SOBRE LOS ARCHIVOS ENCONTRADOS

 El comando find nos permite realizar ciertas acciones sobre los archivos
 que se van encontrando como resultado de la busqueda. Esta es una
 caracteristica muy util de este sistema.

 Cuando un programa de Linux falla, el S.O. escribe, en el directorio de
 trabajo que el programa tenia en el momento de la falla, un archivo
 (usualmente muy grande) llamado core que se utiliza para realizar un analisis
 de las causas por las que el programa fallo. En un sistema que se utiliza
 para el desarrollo de programas estos archivos son muy utiles, pero en la
 mayoria de los sistemas estos archivos no tienen utilidad y pueden ser
 purgados periodicamente. En la figura 7.20 mostramos un comando find que
 buscara en todo el sistema de archivos a los archivos que se llamen "core" y
 los eliminara.
   
   # find / -name core -exec rm {} \;
   rm: /proc/sys/net/core: is a directory
   find: /proc/410/fd: Permission denied
   find: /proc/411/fd: Permission denied
   find: /proc/433/fd: Permission denied
   rm: /usr/src/linux-2.2.5/net/core: is a directory

           Figura 7.20: Eliminando los archivos encontrados por find.

 Vamos a analizar en detalle el comando utilizado:

  * La opcion -exec nos permite especificar un comando a realizar sobre cada
    archivo que find encuentra. El argumento de esta opcion es un comando. En
    este caso utilizamos el comando rm para que elimine los archivos
    encontrados.

  * Las llaves "{}" que agregamos a continuacion del comando rm seran
    reemplazadas por find con el nombre de cada archivo encontrado. Asi el
    comando rm tendra especificado como argumento el nombre de archivo
    correcto y podra eliminarlo.

  * La sintaxis del comando find nos obliga a colocar, luego del argumento a
    la opcion -exec, un punto y coma ";". Pero como la shell le otorga a este
    simbolo un significado especial (es el separador de comandos) debemos
    utilizar la barra "\" como caracter de escape para que la shell no
    interprete que queremos utilizarlo como separador de comandos. Veremos
    mas sobre esto en los capitulos siguientes.

 OTROS USOS DEL COMANDO FIND

 Es posible utilizar el comando find para realizar busquedas basadas en muchos
 otros criterios, por ejemplo:

  * Buscar archivos vacios (-empty)
  * Buscar archivos pertenecientes a grupos de usuarios (-group)
  * Buscar archivos por nombre, pero que la evaluacion se realice sin
    diferenciar letras minusculas y mayusculas (-iname)
  * Buscar archivos por numero de links (-links)
  * Buscar archivos por tipos (directorios, links simbolicos, etc) (-type)
  * Buscar archivos por usuario (-user)

 7.6 CAMBIANDO PERMISOS, GRUPOS Y DUE¥OS

 La habilidad de poder especificar los permisos, grupos y due¤os de los
 archivos para cada archivo en particular es uno de los puntos mas fuertes
 del S.O. Linux y de todos los demas UNIX.

 Los comandos chmos (change mode), chown (change owner) y chgrp (change group)
 se utilizan para cambiar  los derechos de acceso de los archivos y
 directorios.

 Se debe tener en cuenta que para poder cambiar los derechos de acceso de un
 archivo debemos ser due¤o del mismo. Existe una excepcion a esta regla que
 es el "superusuario" :).

 EL SUPERUSUARIO PUEDE CAMBIAR LOS DERECHOS DE ACCESO DE CUALQUIER ARCHIVO O
 DIRECTORIO.

 Como vimos anteriormente, las tres operaciones que pueden ser realizadas
 sobre un archivo son: lectura, escritura y ejecucion. Por cada archivo
 existen tres niveles de privilegio:

  * user: es el due¤o del archivo

  * group: es el grupo a el cual pertenece el archivo

  * others: es el universos (otros usuarios) de usuarios restantes

 Por cada nivel de privilegio, es posible setear los permisos para las tres
 operaciones de cada archivo o directorio. Mas especificamente por cada nivel
 de privilegio, cada operacion puede estar permitida o denegada.

 7.6.1 AVERIGUANDO LOS DERECHOS DE ACCESO DE UN ARCHIVO

 Para averiguar que permisos tiene un archivo, que usuario es due¤o y a que
 grupo pertenece, podemos utilizar el comando ls -l que nos muestra un listado
 largo de los archivos. Por ejemplo:

  # ls -l
  total 15
  -rw-r--r--   1 tony   users       7559 May 12 04:31 commands.htm
  -rw-r--r--   1 tony   users       3817 May 12 04:31 krabber-2.html
  -rw-r--r--   1 tony   users       2880 May 12 04:31 vi.htm

 Cada entrada del listado, en su comienzo, tiene una serie de simbolos que
 especifican los permisos del archivo. La tercer columna de la entrada
 muestra el usuario due¤o del archivo y la columna siguiente especifica el
 grupo al cual pertenece el archivo. En este caso el due¤o de los archivos
 es el usuario tony y los mismos pertenecen al grupo users. La identificacion
 de los permisos es un poco mas complicada.

 La informacion de los permisos de cada archivo se encuentra en el primer
 campo de la entrada del listado. Este campo es una serie de simbolos. El
 primer simbolo especifica el tipo de archivo (ver tabla 7.1). Los demas
 simbolos especifican los permisos seteados sobre el archivo. El formato es
 el siguiente (ver figura 7.21):

  * Los tres primeros simbolos especifican los permisos de lectura, escritura
    y ejecucion para el usuario due¤o del archivo.

  * Los siguientes tres simbolos especifican los permisos del archivo para los
    usuarios que pertenecen al grupo al cual el archivo pertenece.

  * Los ultimos tres simbolos muestran los permisos del universo restante.

           _________ Permisos del due¤o
          |
          |      ___ Permisos del grupo
         _|_   _|_
         | |   | |
        -rwxrwxrwx
            | ||||_____ Permiso de ejecucion
            ø|ø||______ Permiso de escritura
             | |_______ Permiso de lectura
             |
             |_______Permisos del grupo

             Figura 7.21: Permisos de un archivo

 Los tres simbolos de cada uno de los tres niveles de privilegio se interpreta
 de la siguiente manera:

  1. "r" el archivo tiene permiso de lectura en este nivel de privilegio.

  2. "w" el archivo tiene permiso de escritura en este nivel de privilegio.

  3. "x" el archivo tiene permiso de ejecucion en este nivel de privilegio.

 En cualquiera de los casos, un simbolo "-" significa que no se tiene el
 permiso determinado. En el ejemplo anterior, los tres archivos tienen
 permiso de lectura para todos los niveles de privilegio, pero solo el due¤o
 tiene permiso de escritura y ninguno de los niveles tiene permiso de
 ejecucion, lo que quiere decir que nadie podra ejecuar ninguno de los
 archivos. Esto tiene sentido ya que no son ejecutables, son archivos "html"
 de hipertexto.
 
 Es usual que los miembros del grupo tengan los mismos o menos privilegios
 que el due¤o del archivo y que los demas usuarios tengan los mismos o menos
 privilegios que los de los miembros del grupo, pero Linux no nos impone
 ninguna restriccion sobre el seteo de los permisos. Facilmente podemos
 hacer que un archivo no pueda ser leido por su due¤o pero que los demas
 usuarios puedan hacerlo. (Aunque no tendria sentido desde un punto de vista
 practico).

 7.6.2 CAMBIANDO LOS PERMISOS

 Existen dos formas de cambiar los permisos con el comando chmod. Una de ellas
 es utilizando el modo simbolico y la trataremos a continuacion. La otra forma
 es utilizando el modo numerico octal y usualmente es !!ODIADA!! por los
 usuarios novatos. Esta forma sera tratada en segundo termino.

 MODOS DE ACCESO SIMBOLICOS

 Una palabra de control de modos de acceso simbolica consiste en tres partes:
 quienes, operador y permisos. "Quienes" especifica sobre que niveles de
 privilegio setearemos los permisos. El "operador" es la operacion a plicar:
 agregar, quitar o setear los permisos. Veamos un ejemplo en la figura 7.22.

  # ls -l
  -rw-r--r--   1 tony    users     1090 May 29 17:04 file
  # chmod go-r file
  # ls -l
  -rw-------   1 tony    users     1090 May 29 17:04 file
  # chmod g=u file
  # ls -l
  -rw-rw----   1 tony    users     1090 May 29 17:04 file

        Figura 7.22: Cambiando permisos utilizando el modo simbolico.

 En este ejemplo vemos que el archivo de nombre file tiene permiso de lectura
 para todos los usuarios, pero su due¤o es el unico que tiene permiso de
 escritura. Luego ejecutamos.

  ==> chmod go-r file

 En este comando el campo "quienes" esta formado por g (group) y o (others),
 el operador es "-" por lo tanto se quitaran los permisos especificados, que
 en este caso es unicamente el permiso de lectura "r" (read). Luego de estos
 tres campos se debe especificar  el/los archivos sobr los que queremos
 modificar los permisos. Luego de cambiar los permisos, verificamos que el
 archivo ya no tiene permiso de lectura ni para los usuarios del grupo, ni
 para los demas. Luego ejecutamos:
  
  ==> chmod g=u file

 Aqui el campo "quienes" contiene solo el grupo. El operador es este caso es
 "=" por lo que los permisos del grupo seran seteados iguales a los del
 usuario.

 Los valores que pueden tomar cada campo de la palabra de control simbolico
 se muestran en la tabla 7.2.

    Quienes         Operador                Permisos
  -------------------------------------------------------------------------
  u Usuarios     -  Eliminar el permiso  r Lectura (read)
  g Grupo        +  Agregar el permiso   w Escritura (write)
  o Otros        =  Setear el permiso    x Ejecucion (execute)
  a Todos (all)                          u Permisos actuales del usuario
                                         g Permisos actuales del grupo
                                         o Permisos actuales del resto

                   Tabla 7.2. Formando la palabra de control chmod.

 MODOS DE ACCESO EN NOTACION OCTAL

 Muchas personas prefieren especificar los modos de acceso de los archivos
 utilizando el modo simbolico. Pero el comando chmod tambien nos permite
 utilizar una especificacion numerica. Aunque uno prefiera utilizar la
 notacion simbolica es bueno entender la notacion numerica octal de modos de
 acceso de los archivos en esta notacion. Mas aun si vamos a dedicarnos a la
 administracion de un sistema, nos encontraremos con la notacion octal muy
 frecuentemente. Como usuario, podemos encontrar situaciones en las que los
 comandos mv, cp, ln, rm necesiten confirmacion de las acciones a realizar y
 nos especifiquen el modo de acceso del archivo en notacion octal.

 Los numeros del sistema octal, se encuentran en base 8. Lo que significa que
 los digitos octales son 0, 1, 2, 3, 4, 5, 6 y 7. Cada digito octal es
 representado por tres digitos binarios (0 o 1), por esto la notacion octal
 es practica para represntar cosas que se agrupan en trios, ya que solo un
 digito octal puede representar todas las posibilidades.

 Un solo digito puede servirnos para representar un conjunto de permisos
 de lectura/escritura/ejecucion como vemos en la tabla 7.3.

 Como un digito octal puede guardar un conjunto de permisos, necesitamos tres
 digitos para representar los modos de acceso de un archivo, un digito para
 los permisos del usuario, otro para los permisos del grupo y otro para los
 permisos de los demas usuarios.

 Una diferencia grande con la utilizacion de la notacion simbolica es que
 con el modo octal debemos especificar completamente el modo de acceso del
 archivo y no podemos agregar o quitar permisos. Veamos varios ejemplos
 en la fihura 7.23.

   Digito Octal   Permiso de lectura   Permiso de escritura   Permiso de ejecucion
        0                  no                  no                    no
        1                  no                  no                    si
        2                  no                  si                    no
        3                  no                  si                    si
        4                  si                  no                    no
        5                  si                  no                    si
        6                  si                  si                    no
        7                  si                  si                    si

            Tabla 7.3: Especificacion de modos de acceso con notacion octal.

   # chmod 666 file
   # ls -l file
   -rw-rw-rw-    1 tony    users       1090 May 29 17:04 file
   # chmod 000 file
   # ls -l file
   ----------    1 tony    users       1090 May 29 17:04 file
   # chmod 755 file
   # ls -l file
   -rwxr-xr-x    1 tony    users       1090 May 29 17:04 file
   # chmod 700 file
   # ls -l file
   -rwx------    1 tony    users       1090 May 29 17:04 file

              Figura 7.23: Seteando permisos utilizando la notacion octal.

 7.6.3 CAMBIANDO EL DUE¥O Y EL GRUPO DE LOS ARCHIVOS

 Los comandos chown (change owner) y chgrp (change group) cambian el due¤o y
 el grupo asociados con un archivo. Estos comandos son usualmente utilizados
 cuando un usuario hereda archivos de otro usuario o cuando obtiene copias de
 archivos de otros usuarios. El siguiente comando cambiara el due¤o de todos
 los archivos del directorio actual al usuario juan:

  ==> chown juan *

 El nombre del nuevo due¤o debe ser un nombre de usuario valido o un numero
 de identificacion de usuario (UID) valido. Los nombres de usuarios y los
 respectivos UID's se encuentran en el archivo /etc/passwd. En algunas
 versiones de UNIX/Linux el comando chown solo esta permitido al superusuario.
 El siguiente comando asociara el grupo users con el archivo example.tex.gz:

  ==> chgrp users example.tex.gz

 Los grupos que se pueden utilizar con el comando chgrp pueden ser nombres de
 grupos o numeros de identificacion de grupos (GID) que se encuentran en el
 archivo /etc/group.


  Bueno hasta hemos llegado por hoy, espero que les haya gustado y les cuento
  que veremos en la segunda entrega:

   En el capitulo 8 en adelante veremos un poco las utilidades mas comunes
   que usamos en Linux y algunos otros comandos que andan por ahi.

   En el capitulo 9 veremos como instalamos software adicional a nuestro
   sistema Linux.

   Como montar unidades (en el capitulo 10), tambien hablaremos un poco del
   kernel y los modulos (en el capitulo 11) y tambien profundizaremos un
   poco mas en los aspectos avanzados de la shell.

   Bueno nos vemos en la segunda entrega de este manual de Linux.

                Create By Mr. Nuk3m (mr_nukem@mixmail.com)

_____________________________/( 3ND 0F F1l3 )\__________________________________________


---------------------------------\               /-------------------------------
						  PHREAK
						  °°°°°°


El phreaking empezo en los inicios de la decada de los 60 cuando un tal Mark
Bernay descubrio como aprovechar un error de seguridad de Bell. Este error se
basaba en la utilizacion de los mecanismos loop-arround-pairs como via para
realizar llamadas gratuitas.

Lo que Bernay descubrio fue que dentro de Bell existian unos numeros de
prueba que servian para que los operarios comprobaran las conexiones. Estos
numeros solian ser dos y consecutivos, y estaban enlazados de tal manera que
si se llamaba a uno este conectaba con el otro. Asi pues si alguien en EEUU
marcaba una serie de estos numeros de prueba consecutivos podria hablar
gratuitamente :).

Este descubrimiento fue potenciado sobre todo por los jovenes de aquel
entonces, los cuales solo lo utilizaban con el fin de ahorrase dinero a la
hora de hablar con sus amigos. Pero la cosa cambio cuando cierto numero de
estos descubrieron que Bell era un Universo sin explorar y al que se le
podria sacar mas partido que el de unas simples llamadas gratuitas. Asi pues
de los rudimentarios loop-arround-pairs se paso a la utilizacion de ciertos
aparatos electronicos, los cuales son conocidos ahora como boxes. La primera
box que se encontro fue hallada en 1961 en el Washington State College, y era
un cajoncito con una carcasa metalica que estaba conectado al telefono...
automaticamente fue llamado Blue Box (caja azul).

Estas boxes lo que hacian era usar el nuevo sistema de Bell para redirigir
las llamadas: los tonos. Esto es, cuando se marcaba un numero, este lo
identificaba Bell como una combinacion de notas musicales que eran creadas
por 6 tonos maestros, los cuales eran los que controlaban Bell y por lo tanto
eran secretos...o al menos eso pretendian. Jaja. El como los phreakers llegaron a
enterarse del funcionamiento de estos tonos fue algo muy simple y estupido :
Bell, orgullosisima de su nuevo sistema lo publico detalladamente en dos
revistas que iban dirigidas unica y exclusivamente a los operarios de la esta
compañia telefonica, lo que paso es que no cayeron en la cuenta de que todo
suscriptor de esa revista recibio tambien en su casa un ejemplar que narraba
el funcionamiento de Bell...increible pero cierto :).

Bien, una vez que los phreakers conocieron los secretos la compañia telefonica
no les fue muy dificil reproducir esos tonos y utilizarlos de la misma forma
que lo hacia Bell. Las primeras Blue boxes eran unos aparatos que tenian unos
tubos de vacio (precursores de los transistores) que emitian tonos. Tambien
eran conocidas como MFs (multifrequency trasmitters). Pero desde aquel
entonces las Blue Box han evolucionado mucho...

Mas o menos por esas fechas Bell ya estaba bastante ocupada intentando
acabar con lo que ahora de conoce como Red Boxes (cajas rojas), que eran
unos artilugios mas simplones que las Blue Boxes pero que tambien eran muy
utilizados. Solian ser un telefono de campo militar o uno corriente
modificado que se conectaban a un aparato Bell. Su funcionamiento era muy
simple (pero efectivo), mandaban una señal lo suficientemente corta para que
la centralita pensara que la llamada no habia sido descolgada cuando en
realidad si lo hab¡a sido. Por ejemplo, supongamos que instalamos una cajita
roja en casa de un amigo, al que luego llamamos por un telefono publico.
Nuestro colega no tendra mas que apretar un botoncito para mandar una señal y
poder hablar gratis. Mientras en la centralita local no se ha registrado que
el telefono de nuestro amigo se haya levantado sino que sigue sonando como si
no hubiera nadie en casa. Y este era el mayor handicap de las Red Boxes, que
solia ser sospechoso que una persona hubiera estado esperando 30 o 40 minutos
a que en el destino levantaran el telefono. Jaaa !! Tambien existia otra Red Box que
imitaba el sonido que hacen las monedas al caer, haciendo creer a la compañia
telefonica que la llamada habia sido pagada :)

Al poco tiempo salio una variacion de la Red Box inicial que fue llamada
Black Box, la cual hacia que el telefono dejara de sonar antes de ser
descolgado, de esta manera en la centralita no se facturaba la llamada ya que
habia sido cancelada antes de que el destinatario descolgara el telefono.

En realidad no existe ningun nombre especifico para cada Box, quiero decir,
que lo que uno llame Reb Box otro puede llamarla de otra forma siendo lo
mismo, aunque normalmente la Blue Box, la Red Box y la Black Box suelen ser
siempre llamadas por estos nombres debido a que fueron las primeras en salir y
las mas famosas...pero no las unicas (piensa en todos los colores que te
sepas y podras sacar una box por cada uno mas o menos).

La mas famosa y evolucionada era la Blue Box. Para no pagar la llamada los
phreakers lo que hacian era llamar a un numero de informacion de otra ciudad
o a un numero comercial gratuito (1-800 en EEUU, 0-800 en Argentina...) y despues
redirigian la llamada utilizando los tonos de su MF. Profundicemos: cuando se
realizaba una llamada lo primero que hace la centralita es leer los primeros
digitos marcados que son los que indican que tipo de llamada es (larga
distancia, urbana...). Supongamos que la llamada realizada es de larga
distancia. Para ello la centralita la conecta con una linea de larga distancia
que en ese momento este desocupada, la cual emite constantemente un silbido de
2600 ciclos (mmmmh...¨de que me suena este numero?) el cual significa que la
l¡nea esta preparada para recibir una llamada. Cuando el phreaker termina de
marcar el resto de los numeros (llamados digitos de direccion) la llamada ha
finalizado. La centralita deja al emisor (el phreaker) que marque su numero
deseado, y la linea vuelve a silbar 2600 ciclos para permitir entrar a la 
llamada. Es entonces cuando nuestro amigo marcaba un numero gratuito, por
ejemplo el 1-800 de cualquier empresa. La centralita local de la zona de la
empresa a la que hemos llamado detecta una llamada interurbana a un numero
gratuito, y dirige la llamada hacia alli. Es en ese momento, antes de que la
empresa responda, es cuando el phreaker pulsa el boton de su MF, mandando un
silbido de 2600 Hz, que es interpretado por la centralita primera como que la
llamada ha sido cortada, puesto que la linea silbaba, cosa que hacia cuando
estaba libre. Pero mientras tanto en la centralita de la zona de la empresa
no se habia detectado nada, sino solamente una llamada a un numero gratuito
que no habia finalizado aun. Asi pues, el phreaker podia marcar pacientemente
el numero que quisiera, ya que tenia una linea de larga distancia para el
solito y gratis. Ufff, no se si se ha entendido bien...si esta complicado
decirlo que intentare enfocarlo de otra manera, ok?

Las blue boxes no solo servian para realizar llamadas gratuitas, sino que
proporcionaban a sus usuarios los mismos privilegios que los operadores de Bell.

Lo realmente curioso, y desastroso para Bell, es que algunas personas eran
capaces de silbar 2600 ciclos de forma completamente natural. El primer
phreaker que utilizaba este metodo fue Joe Engressia (ciego) que ha los 8
años y por azar silbo por el auricular de su telefono cuando escuchaba un
mensaje pregabado y la llamada se corto. Realizo esto varias veces y en
todas se le cortaba. La razon es un fenomeno llamado Talk-Off, que consiste
en que cuando alguien silba y alcanza casualmente los 2600 hz, la llamada se
corta, como si fuera una Blue Box organica :). Joe aprendio como potenciar su
habilidad para silbar 2600 Hz y ya con 20 años era capaz de llamar, producir
los 2600 Hz con su boca y silbar los tonos del numero al que queria llamar...
increible!.
Fue avisado de que sus aficiones telefonicas eran ilegales y se mudo a otro
estado para ahorrarse problemas. Se mudo a Memphis, ciudad que tenia distritos
telefonicos independientes, y se dedico a realizarse como phreaker. Empezaron
a vigilarlo y lo agarraron; paso la noche en la carcel. Fue solamente acusado
de poseer una caja azul y de robo intencionado de servicios...en realidad su
unico delito fue su amor por Bell, la cual se nego a devolverle la linea. Joe
Engressia trabaja actualmente para Bell Mountain :).

Otro phreaker que utilizaba el metodo de Engressia, fue John Draper, mas
conocido por Cap'n Cruch, nick que saco a raiz de un silbato que regalaban
con la marca de cereales Cap'n Cruch, el cual, podria utilizarse como
instrumento para hacer phreaking. Draper hacia algo parecido a lo que que
hacia Joe Engressia, soplaba su silbato y la linea se quedaba libre :).
Tambien se dedico a proveer a muchismos chicos invidentes cajas azules y les
enseño a manejarlas, lo que le hizo muy popular. Una vez que Draper fue a
Inglaterra hablo con uno de sus amigos ciegos que vivia en Nueva York. Este
le dijo que habia descubierto el codigo que utilizaban los operarios de Bell
para comprobar la conexion con Inglaterra. Ese codigo era 182 + un numero de
telefono britanico. Las llamadas efectuadas por esa linea eran gratuitas :).
El descubrimiento se divulgo rapidamente por toda la comunidad phreaker que
querian probar la nueva via, pero como casi ninguno conocia a nadie en
Inglaterra se dedicaron todos a llamar a Cap'n Crunch. Hay que decir que por
aquel entonces una llamada intercontinental no era algo muy comun, y mucho
menos si era transatlantica, para empezar porque la mayoria de las veces la
llamada podria tardar mas de medio dia en llegar a su destino. Cuando una
familia se comunicaba con otro pariente de otro continente solian hacerlo un
par de veces al año como mucho, debido a las dificultades que conllevaba esto.
Por esa razon la GPO (Oficina de correos Britanica, que en ese momento se
encargaba de la telefonia bretona) se sorprendio de que un turista recibiera
del orden de unas 5 o 6 llamadas al dia, por lo que le investigaron. Draper
solto la excusa de que era muy popular en EEUU y por eso la cantidad de
llamadas...no convencio mucho a las autoridades inglesas, y Cap'n Crunch tuvo
que pedirle a sus amigos que dejaran de llamarlo. 

Una de las mas extravagantes formas de difusion del phreaking fue la que
llevo a cabo Cap'n Crunch cuando fue arrestado y encarcelado a mediados de
los años 70. Dentro de la carcel se vio obligado a transmitir sus
conocimientos por cuestiones de vida o muerte, es decir, o les explicaba a los
reclusos las mas diversas tecnicas del phreaking o le rompian el culo...el
resultado es evidente. Draper enseño a los reclusos de la prision en la que se
encontraba a cambio de seguir vivo. De esa manera todo recluso que salia de
alli era un phreaker en potencia, que habia tenido como maestro a uno de los
mejores, por no decir el mejor.

Muchos phreakers evolucionaron mas tarde al hacking, como es el caso del
pionero Mark Bernay, que bajo el nick de The Midnight Skulker (El vigilante
de medianoche) se rio de todos los fallos de seguridad de su empresa, dejando
mensajitos sarcasticos a cualquiera que metiera la pata...fue traicionado y
encerrado :( 
Pero eso no significa el phreaking haya muerto, ni mucho menos,
simplemente que con el avance de las tecnolog¡as tambien avanzaron ellos.
Ahora se sigue practicando este fantastico arte, aunque tanto han mejorado
las tecnolog¡as de un lado como de otro...ya no basta con realizar un truco
parecido al de los loop-arround-pairs para mantener una conversaci¢n gratuita,
ahora es 'algo' mas dificil, pero siempre que exista una valla alguien la
saltara...o sea, que nadie piense que el hacking mato al phreaking porque no
es asi, los dos viven en perfecta armonia y en pleno auge.

Este texto es una revision muy poco puntualizada de lo que fue la historia
de los inicios de la practica del phreaking, obviamente hubo mas personajes
famosos que los citados aqui, y muchas mas maneras de meterse por la linea
telefonica. Si no se entiende bien o alguien ha notado algun fallo o algun
dato erroneo se admiten todo tipo de criticas, ok?

---------------------------------\               /-------------------------------
			      NUESTRAS HUELLAS EN LOS SISTEMAS (UNIX)
				°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°

Ficheros:

  (Cuando pongo dos directorios significa que el fichero puede estar en cualquiera de esos
                                       dos directorios). 

     utmp --> Guarda un registro (log) de los usuarios que están utilizando el
     sistema mientras están conectados a él. 

                    Directorios: /var/adm/utmp 
                                       /etc/utmp 

     wtmp --> Guarda un log cada vez que un usuario se introduce en el
     sistema o sale del sistema. 

                    Directorios: /var/adm/wtmp 
                                     /etc/wtmp 

     lastlog --> Guarda un log del momento exacto en que un usuario entró
     por última vez. 

                    Directorio: /var/adm/lastlog 

     acct --> Registra todos los comandos ejecutados por cada usuario (aunque
     no registra los argumentos con que dichos comandos fueron ejecutados). 

                   Directorio: /var/adm/acct 

En algunos sistemas el fichero acct se puede llamar pacct Comandos: 

     who --> Permite saber quién está conectado al sistema en el momento en
     que ejecutamos el comando. 

     finger --> Lo mismo que el comando who, con el añadido de que se
     puede  aplicar a otras m quinas. Es decir, podemos saber que usuarios
     estén conectados a una determinada m quina en el momento en que
     ejecutamos el comando. 

     users --> Igual que el who

     rusers --> Igual que finger, pero la m quina remota debe utilizar el
     sistema operativo Unix. 

Los comandos who, finger, users y rusers toman la información que sacan en pantalla del
fichero utmp. 

     last --> Permite saber cuando fué la última vez que se conectó un
     usuario. 

El comando last toma la información que saca en pantalla del fichero wtmp. 

     ps --> Permite saber que procesos están siendo ejecutados por el sistema
     y que usuarios los ejecutan. 

El comando ps ofrece una información mucho más completa de quién está utilizando el
sistema puesto que un usuario que no aparezca en los ficheros utmp o wtmp puede tener
procesos ejecutándose, por lo que el comando ps ofrece la información de quién está
ejecutando dichos procesos. En contrapartida, la información que ofrece el comando ps es
más complicada de interpretar que la información ofrecida por el resto de comandos. 

     accton --> Activa un proceso llamado accounting, que es el que
     proporciona información al fichero acct. 

     lastcomm --> Permite saber qué comandos han ejecutado los usuarios. 

     acctcom --> Igual que lastcomm pero exclusivamente para Unix del tipo
     SYSTEM V. 

Los comandos lastcomm y acctcom toman la información que sacan por pantalla  del fichero
acct (pacct en algunos sistemas) 

Por lo tanto, si queremos borrar nuestras huellas del sistema, bastar  con borrar
cualquier log relativo a nuestro usuario de los ficheros utmp, wtmp y acct. Esto se puede
hacer de dos formas: 

Ficheros utmp y wtmp: 

 1 -No borramos los ficheros pero los dejamos con cero bytes. Sólo se 
     utiliza como último recurso por suscitar muchas sospechas por parte 
     de los administradores. Hay hackers que opinan que esto es incluso 
     peor que no borrar los logs. 

 2 -Los ficheros utmp y wtmp no son ficheros de texto, es decir, no se 
     pueden editar con un editor de textos. Sin embargo, existen programas 
     llamados zappers (debido a que el programa más famoso de este tipo se 
     llama zap) que pueden borrar los datos relativos a un usuario en 
     particular de estos ficheros dejando el resto de los datos relativo a 
     los demas usuarios intacto. 

Fichero acct: 

 Cuando el accounting está activado (es decir, cuando el sistema recoge 
 información acerca de los comandos ejecutados en el fichero acct) es 
 bastante complicado borrar nuestras huellas, de hecho no se pueden borrar 
 del todo, aunque s¡ se pueden reducir a una m¡nima información de nuestra 
 presencia en el sistema. 

 1 -LO PRIMERO que hacemos nada más entrar en el sistema es copiar el 
     fichero acct a otro fichero y LO ULTIMO que hacemos antes de abandonar 
     el sistema es copiar dicho fichero de nuevo al acct, de modo que los 
     comandos que hemos ejecutado durante la sesión no aparecen en el 
     fichero acct. 

    Problema: Nuestra entrada en el sistema queda registrada, as¡ como las dos copias. 

 2 -Dejamos el fichero acct a cero bytes. Como antes, esto es bastante 
     sospechoso para un administrador, además, algunos sistemas reaccionan 
     mal y paran el proceso de accounting, para no levantar sospechas habr¡a 
     que reactivarlo con el comando accton. 

Problema: Bastante sospechoso. El propio comando accton quedar¡a registrado como
ejecutado por nuestro usuario. 

 3 -Hacerse un editor para el fichero acct que borrara los datos 
     correspondientes a nuestro usuario y dejara intactos los datos relativos 
     al resto de los usuarios. Existen unos pocos programas que hacen esto. 

Problema: La ejecuci¢n del programa editor que borra nuestras huellas quedar¡a registrado
como ejecutado por nuestro usuario. 

Afortunadamente, no hay muchos sistemas que tengan activado el accounting debido a la
cantidad de capacidad que es necesaria para guardar los comandos ejecutados por cada
usuario. 

Aparte de los ficheros utmp, wtmp, acct y lastlog, hay que tener en cuenta otras
facilidades y aplicaciones que posee el sistema operativo Unix que
permiten al administrador vigilar ciertos aspectos cr¡ticos relativos a la 
seguridad y al mantenimiento del sistema. 

1 - Syslog 

Syslog es una aplicación que viene con el sistema operativo Unix. El sistema
operativo Unix se puede configurar de tal forma que determinados programas,
procesos o aplicaciones generen mensajes que son enviados a determinados
ficheros donde quedan registrados dichos mensajes. Estos mensajes son generados
cuando se dan unas determinadas condiciones, ya sean condiciones relativas a
seguridad, mantenimiento o simplemente de tipo puramente informativo. 

Para conseguir esto hay que configurar varias cosas. 

     A -Decidir qué programas, procesos y aplicaciones pueden generar 
         mensajes. (Pongo los principales) 

         kern --> mensajes relativos al kernel 
         user --> mensajes relativos a procesos ejecutados por usuarios 
         normales. 
         mail --> mensajes relativos al sistema de correo. 
         lpr --> mensajes relativos a impresoras. 
         auth --> mensajes relativos a procesos de autentificación 
         (aquellos en los que estn involucrados nombres de usuarios 
         y passwords, por ejemplo login, su, getty, etc) 
         daemon --> mensajes relativos a otros demonios del sistema. 

         etc... 

     B -Decidir qué tipos de mensajes pueden generar cada uno de esos 
         programas, procesos o aplicaciones. 

         emerg --> emergencias graves. 
         alert --> problemas que deben ser solucionados con urgencia. 
         crit --> errores cr¡ticos. 
         err --> errores ordinarios. 
         warning --> avisos. 
         notice --> cuando se da una condición que no constituye un error .
         info --> mensajes informativos. 

         etc... 

     C -Decidir a qué ficheros van a parar dichos mensajes dependiendo del 
         tipo al que pertenezca el mensaje correspondiente. 

Syslog cumple su función mediante el syslogd (syslog daemon o en      castellano el
demonio syslog). 

NOTA:Un demonio (o daemon) es un proceso que no tiene propietario (es decir, no es
ejecutado por ningún usuario en particular) y que se está ejecutando permanentemente. 

El syslogd lee su configuración del fichero /etc/syslog.conf. Dicho fichero contiene
la configuración relativa a qué eventos del sistema son registrados y en que ficheros
son registrados. Los ficheros a los cuales se mandan los registros (logs) pueden
estar situados en la misma máquina en la que estamos trabajando o en otra
máquina de la red. 

Cómo borrar las huellas relativas al syslog: 

Bien, nuestras andanzas por el sistema cuando hemos accedido a él y cuando nos
hemos convertido en root, pueden generar diversos mensajes registrados por el
syslogd y guardados en los ficheros indicados en el /etc/syslog.conf 

A diferencia de los ficheros utmp, wtmp, acct y lastlog, los ficheros en los que se
guardan los registros del syslog s¡ se pueden editar con un editor de textos. 

Para poder borrar estas huellas necesitamos tener privilegios de root,
naturalmente. Bastará con examinar el fichero /etc/syslog.conf para saber los
ficheros que guardan los registros del syslog. Después miraremos cada uno de esos
ficheros comprobando que no hay ningún mensaje relativo a nuestra intrusión en el
sistema (los mensajes del estilo "login: Root LOGIN REFUSED on ttya" a ciertas
horas de la noche son bastante sospechosos :-) ). En caso de que lo haya, lo
borramos y CAMBIAMOS LA FECHA del fichero con el comando touch de forma que
coincida la fecha del último mensaje (después de haber borrado nuestras huellas)
con la fecha del fichero. Si no lo hacemos as¡, algún administrador demasiado
suspicaz puede comprobar que las fechas no coinciden y deducir que alguien ha
modificado el fichero (esta es una      precaución extrema pero la recomiendo por
experiencia). Si es necesario,      y SOLO si es necesario, habr¡a que cambiar la
fecha de los directorios en los que estén inclu¡dos los ficheros que guardan los logs.

Si en el fichero /etc/syslog.conf hay mensajes que se destinan a     /dev/console eso
significa que los mensajes (ya sean de error, alerta o emergencia) salen
directamente en la pantalla del root (o sea, en la      consola). En este caso no se
puede hacer nada (que yo sepa), pero      mensajes de este tipo suelen estar
generados por alertas bastante graves como por ejemplo intentar acceder con la
cuenta de root directamente o utilizar el comando su para intentar convertirse en
root, etc. Es decir, cuanto más sigilosos seamos a la hora de hacernos root y menos
ruido armemos más posibilidades tendremos de no aparecer en este tipo de logs. 

2 - TCP-Wrapper 

Se trata de una aplicación que proporciona una serie de mecanismos para el
registro (logging) y filtro (filtering) de aquellos servicios invocados o llamados a
través del inetd (internet daemon). Con esta herramienta el administrador posee un
control absoluto de las conexiones hacia y desde su máquina. 

Puede, entre otras muchas cosas, filtrar un servicio de internet como por ejemplo el
telnet, ftp, etc de forma que nadie pueda conectarse al sistema desde otra máquina
o puede especificar una lista de máquinas que s¡ pueden conectarse (y las demás no
podrán). Además, el administrador es informado en todo momento y con todo lujo
de detalles de las conexiones que se han hecho desde su máquina y hacia su
máquina con cualquiera de los diferentes servicios de internet (telnet, ftp, finger,
etc...) 

Como en el syslog, para borrar nuestras huellas del tcp-wrapper, tendremos que
buscar posibles huellas mirando el archivo de configuración (alojado NORMALMENTE
en el directorio /etc), borrar dichas huellas y cambiar las fechas de los ficheros
correspondientes. 

Bien, hasta aqu¡ un resumen sobre cómo borrar las huellas. Como vereis me he
extendido un poco más porque me parece importante que la gente adquiera
conciencia de que tan importante o más que controlar el sistema (convertirse  en
root) es saber ocultarse en él (aunque es una opinión personal). 

Puede parecer bastante pesado el borrar todas las posibles huellas que hayamos
dejado, pero en ALGUNAS ocasiones, una vez que hayamos visto los ficheros de
configuración es posible preparar un shell script (el equivalente a los ficheros batch
en MS-DOS, aunque la programación en shell es infinitamente más potente :-) ) que
haga todo el trabajo por nosotros en cuestión de borrar las huellas. Dicho script lo
podemos dejar bien camuflado en el sistema para que la próxima vez que entremos
lo podamos ejecutar (utilizando como par metros el usuario con el que hayamos
entrado, el terminal por el que hayamos entrado, la hora a la que hayamos
entrado, etc..) ahorrándonos todo el trabajo pesado. 

Para terminar con lo de borrar las huellas, sólo advertir que aunque seamos
perfectamente invisibles en el sistema, cualquier usuario que esté conectado al
mismo tiempo que nosotros podr¡a detectarnos viendo el terminal por el que hemos
entrado (el fichero /dev/ correspondiente a nuestro terminal tendr¡a como
propietario (owner) al usuario con el que hemos entrado en el sistema, y la fecha
del fichero /dev/ correspondiente al terminal también nos delatar¡a). Para evitar
esto tendr¡amos que cambiar de owner el fichero correspondiente al terminal
(teniendo privilegios de root naturalmente) al owner que tengan los otros
terminales a los cuales no hay nadie conectado (es decir, al owner de los terminales
por defecto que NORMALMENTE es el root). 

De todas formas, esto último, junto con lo de cambiar de fecha ciertos ficheros de
logs, son medidas quizá extremas, pero vuelvo a insistir que son muy
recomendables. 

Por último, la cuestión de ocultar o camuflar procesos mientras los estamos
ejecutando es otra cuestión que se tratar  en otro mensaje si teneis la paciencia de
seguir. :-) 

Ya hemos visto de forma resumida y sin detallar algunas técnicas sobre cómo
conseguir acceso, conseguir privilegios y borrar nuestras huellas. Vamos a ver el
último paso, cómo conseguir acceso a otros ordenadores una vez controlado el host
que hayamos hackeado (es decir, después de asegurarnos que hemos borrado
absolutamente todas nuestras huellas y de implantar algún sushi u otro método an
logo para conseguir privilegios de root). 

Una vez controlado el host que ten¡amos como objetivo, podemos hacer todo lo que
queramos en el sistema, aunque hay que tener en cuenta que nuestras acciones
pueden ser registradas por el syslog, tcp-wrapper u otra utilidad que genere logs,
por lo que cuando vayamos a irnos del sistema siempre tendremos que comprobar
antes que no hemos dejado registros (logs). 

Es en este punto donde adquiere importancia la "filosofía" del hacker. La diferencia
entre un hacker y un cracker (no me estoy refiriendo a alguien que rompe las
protecciones de software), consiste en que un cracker accede al sistema para
dañarlo o corromperlo y un hacker accede al sistema simplemente para conseguir
información o por pura curiosidad, pero nunca corromper ni borrar  ningún fichero
del sistema, sigue el lema (aunque tampoco de forma radical, es decir, sin
tomárselo al pie de la letra) de "se ve pero no se toca". A esto último hay que hacer
una excepción , naturalmente. Los únicos ficheros que el hacker modificar o borrar
serán los ficheros relativos a los logs que haya podido dejar en el sistema. Por
supuesto que esto es una situación ideal y no realista, en la práctica un hacker
puede que realize otras acciones en el sistema que puedan modificar ficheros ya
existentes, pero siempre procurará que los cambios sean m¡nimos. 

---------------------------------\               /-------------------------------
                                     DESPEDIDA
                                     =========

 UUUUUUU TODOMALTOOOOOOOO!!!!!!!!!!!!!!!!!!!!!!
 bueno se nos va un numero mas ke mala leche la puta ke los pario y eso ke yo
 me dibierto haciendo los numeros.
 bueno espero ke festejen las fiesta lokooooooooooooo!!!!!!!!!!

 bueno nos estamos viendo la pagina oficial de la e-zine:
 http://www.lanzadera.com/gnpphack
 nos estamos viendo en el irc de ciudad digital: conectados.ciudad.com.ar
                                          canal: NEWSPAPER o ROOT
                                          puerto: 6667

END FILE TRANSFER                                                             
