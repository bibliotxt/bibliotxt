-[ 0x03 ]--------------------------------------------------------------------
-[ Bazar de SET ]------------------------------------------------------------
-[ by Others ]-------------------------------------------------------SET-35--

Indice

3x01  Certificaciones                           Info         Anay

3x02  La Cripta                                 Proyecto     blackngel

3x03  Syn vs Fin Scan                           Programacion blackngel


-[ 3x01 ]--------------------------------------------------------------------
-[ Certificaciones ]---------------------------------------------------------
-[ by Anay ]-----------------------------------------------------------------


Existe toda una oferta en certificaciones ¿quien no se ha planteado nunca
sacarse una? Y aun me arriesgo mas a apostar porque seguro que el 30% o mas de
los que pasais por esta zine habeis cursado alguna con mejor o peor resultado.

Lo que realmente es cuestion de debate es si certificarse en alguna materia o
software en concreto es o no realmente positivo para nosotros yo diria que
depende.

Como anecdota contar lo que me paso durante las primeras clases de MCSA, muchos
de mis compañeros eran gente de uno u otro modo habian acabado trabajando como
informaticos, en alguna tienda o gran empresa de helpdesk, hablando con ellos
me contaban que ellos realmente habian acabado la ESO y despues se pusieron a
trabajar de lo que les iba saliendo. Puede que sea muy pesimista pero en esos
casos no creo que  sirva de nada que la gente invierta tales cantidades de
dinero en hacer una certificiacion. En primer lugar tienes que tener muy claro
porque has de hacer esa certificacion, un companyero mio me contaba que queria
ser administrador de redes informaticas, apenas tenia experiencia en una gran
empresa en el departamento de help desk y sus conocimientos sobre informatica
se limitaban a lo que habia aprendido leyendo esos formulario de
pregunta-respuesta que tienen a su disposicion, yo para esos casos recomiendo
en vez de una certificacion el realizar otro tipo de cursos.

Si por el contrario ya has terminado tu ciclo o carrera y estas trabajando en
una empresa y crees que tener esos titulos te abriran las puestas del CPD y de
la consola de AD con mayores permisos, en ese caso, merece la pena certificarte.
Todo conocimiento es bueno pero por experiencia os digo que hay que hacerlo
desde un punto de vista con realismo, cuando llego el momento de comenzar los
examenes muchos ni siquiera se sacaron el de XP (ahora tambien disponible el de
Vista :)) ya que se creian que eso del examen de XP era instalar el sistema y
drivers.

Sobre el tema del idioma: si, si y si lo mejor es hacer los examenes en ingles
desde el principio. Soy consciente de que no todos tenemos el nivel de ingles
que, segun el ministerio, deveriamos tener pero si yo he conseguido entender lo
que preguntan cualquiera lo puede conseguir. Hay examenes ya traducidos que
puedes estudiar y examinarte en ingles pero son los minimos y probablemente
cuando lleges a un examen mas amplio si no te has familiarizado ya con todas
esas palabras en ingles tienes muchas mas posibilidades de que se te haga cuesta
arriba.

No seas pesimista con esto, una vez hayas echo las primeras 300 preguntas de
test veras que las palabras son siempre las mismas y que ya apenas te cuesta
esfuerzo entender todo lo que ponen, sin embargo las traducciones en muchisimos
casos dejan bastante que desear y una pregunta mal traducida puede convertirse
en una pregunta no acertada y necesitando un 700/1000 lo mejor es reducir esas
preguntas fallidas cuanto mas mejor.

Una vez echos los pequenyos consejillos pasemos ha hablar sobre el como de las
certificaciones.

Certificaciones de Microsoft.

Es la madre de todas las certificaciones, no porque sea la mejor sino porque es
la que mas variedad de examenes te puede pedir y porque es la mas popularizada.

Hasta hace un anyo teniamos 2 certificaciones una para administradores y otra
para ingenieros:

   1 - MCSA
   2 - MCSE.

No puedes conseguir la una sin pasar primero por la otra, te vendan lo que te
vendan en las academias :P



[ --- "MCSA" Administrador Certificado en Sistemas Microsoft --- ]

Ante certificaciones de Microsoft relacionadas con sus sistemas esta sera la
primera prueba que tendremos que vencer, consta de 4 examenes:

   -> Windows XP (ahor atambien disponible Windows Vista).

   -> Administracion y mantenimiento de entornos Windows Server 2003.

   -> Implementacion, administracion y mantenimiento de redes con Windows
      Server 2003.

Hasta aqui lo obligatorio, una vez superados estos tres examenes puedes elegir
el cuarto entre Isa Server o Exchange Server. 

MCSA especializado en seguridad: SOn en total 5 examenes con el de ISA y el de
Seguridad, propiamente dicho. La informacion oficial sobre la numeracion de los
examenes la tienes aqui:

   - http://www.microsoft.com/learning/mcp/mcsa/security/windowsserver2003.mspx

MCSA especializado en Mensajeria: Consta de los 3 examenes ya dichos y tan solo
1 mas, siendo este un poco mas corto, aqui tienes el enlace a las numeraciones
y opciones:

   - http://www.microsoft.com/learning/mcp/mcsa/messaging/windowsserver2003.mspx

Como apunte indicaros que tambien se pueden cursar con Windows 2000 Server, yo
personalmente pienso que si vas ha hacer la titulacion completa no es util ya
que es una tecnologia casi obsoleta y muy sencilla de dominar si saber acerca
de 2003.

De todos modos aqui os dejo tambien su enlaces:

   - Experto en seguridad Windows 2000:
     http://www.microsoft.com/learning/mcp/mcsa/security/windows2000.asp

   - Experto en mensajeria Windows 2000:
     http://www.microsoft.com/learning/mcp/mcsa/messaging/windows2000.asp

Es muy importante que quienes hizieron estas certificaciones en el pasado
sepan que no hace falta hacer todos los examenes de nuevo para actualizarse,
solo tienen que hacer algunos de ellos.
Personalmente os recomiendo que os pongais en contacto con Prometric para que
os digan el centro certificador mas cercano a vosotros y asi poder preguntar
alli mismo por vuestro caso. Estos son los telefonos de contacto en europa:

   - http://www.prometric.com/Microsoft/EMEAIT.htm



[ --- "MCSE" Ingeniero Certificado en Sistemas Microsoft --- ]


Una vez que hemos superado el MCSA podemos comenzar con el MCSE, si es bien
cierto que puedes hacer examenes de MCSE sin haber terminado los de MCSA o
hacerlos salteados pero personalmente no recomiendo que hagais eso, si
realmente quereis tener ambas certificaciones lo mejor es ir en orden ya que
hay examenes sobre ingeniera de redes que es absurdo hacer si antes no has
pasado por la administracion de Windows 2003. Una vez llegados a este nivel
ya apenas os separan un par de examenes de nuestro titulo.

En esta parte nos enseñaran ya no solo a administrar y mantener redes sino
que tambien aprenderas ha plantear las redes desde 0.

Especializado en seguridad - Aquí os dejo el enlace de oficial de los
examenes y sus numeraciones que tendreis que cursar, estan todos incluidos
los de MCSA que ya podriais descontarlos ;) :

   - http://www.microsoft.com/learning/mcp/mcse/security/windowsserver2003.mspx

Especializado en mensajeria -  Lo mismo que el anterior, aqui os dejo el enlace: 

   - http://www.microsoft.com/learning/mcp/mcse/messaging/windowsserver2003.asp



[ --- ¿Academia o no academia? --- ] 

Existen academias que te pueden formar en las distintas certificaciones, las
mas extendidas con las de Microsoft y Cisco estas academias suelen formarte
para sacar los cursos basicos como son el MCSE, MCSA, CCNA... y para lo cual
estan muy bien sobretodo para entrar en la dinamica de las certificaciones,
irte acostumbrando al idioma y al estudio de test junto con clases al principio
viene muy bien.

La respuesta a esa pregunta puede ser muy variada en primer lugar dependera de
nuestra economia, no te he exagerado antes cuando he dicho que son caras y es
que en una academia cursar un MCSE puede salirte por mas de 5000 euros lo cual
ya es una cantidad de dinero que no todo el mundo puede pagar.
Tambien dependera, sobretodo, de la experiencia que tengan en lo que a la
materia respecta, es decir hay examenes como Mantenimiento de Windows 2003
que si has estado trabajando un par de anyos y estas familiarizado con dicho
entorno te va a resultar demasiado facil y posiblemente terminaras prescindiendo
de las clases, siempre hay algo nuevo pero para eso estan los libros, que son
tambien carisimos en todas ellas.

Una ayuda que podeis encontrar y que si suelen hacer mucho es pedir a tu empresa
que te financie estos estudios, si la empresa cree que será probechoso para
ellos seguramente accedan a pagartelos y sin duda alguna en ese caso asiste a
clases ya puestos a pagar...

Tienes que tener en cuenta que las certificaciones no acaban donde parece,
detrás del MCSE hay decenas de posibilidades mas, incluso puedes hacerte
profesor si te sacas el Trainer o  muchos otros examenes que lucen muy bonitos
en el curriculum pero estos seguramente no te los cursarán en las academias,
tendrás que acudir a un centro autorizado ha hacer el examen y nada mas. Asi
que esta opcion, como ya os he dicho solo es valida para los primeros examenes.



[ --- Otras certificaciones --- ]

Me he explayado mucho mas en la Microsoft que en ninguna otra, ciertamente es
la que conozco (luchando con ella estoy ahora mismo :P ) pero existen cientos
de certificaciones, casi tantas como empresas de informatica.
Para hacerte una idea de las posibilidades que existen y asi ver tu cual
realmente te conviene tienes la web de Prometic, se podria decir que es la
madre reguladora jeje.

Desde aqui podeis acceder a toda la informacion acerca de todas ellas:

   - http://www.prometric.com/Candidates/default.htm

Ellos te ayudaran e informaran de todas las dudas que puedas tener.



[ --- Sitios indispensables --- ]

Cuando ya estes dentro de una certificacion necesitaras hacer cientos de
preguntas ya que es lo que realmente va a ayudarte a la hora de pasar el
examen.

Existen empresas alrededor de toda esta industria, por ejemplo tenemos a
TestKing (http://www.testking.com/), la lider indiscutible en venta de test
de pasados examenes, desde su web puedes comprar pdfs con cientos de
preguntas de examenes pasados del que quieras, puedes bajarte de internet
esos examenes, el problema esta en que comprando tendras las ultimas
preguntas y los que te descargas fijate bien en que version te has bajado,
ya que pueden ser preguntas de hace mas de 2 anyos y luego llevarte una
desagradable sorpresa cuando estes ante el examen.

Otras empresas relacionadas son:

   - http://www.pass4sure.com/
   - http://www.actualtests.com/
   - http://www.trandumper.com/

Pero como ya he dicho el lider indicutible es TestKing.

Si tu economia no da para mas o simplemente no tienes ganas de pagar mas
dinero por tener ejemplos de examenes tienes otro sitio donde una inmensa
comunidad colabora muy activamente para poder disponer de esos examenes y
no en pdf sino en simulador como si de un examen real se tratara, esta
comunidad la tienes en:

   - http://www.examcollection.com

Para poder acceder a los examenes que tienes de descarga gratuita
necesitaras el software de Visual CertExam Suite, es de pago pero como
conseguirlo ya lo dejo a tu imaginacion ;)

Desde estos sitios tienes ya todas las herramientas que necesites para
aprobar el examen que quieras de la titulacion que desees.



[ --- Conclusion --- ]

Espero que os haya sido de utilidad, he tratado mediante el ejemplo de
Microsoft haceros una pequenya idea de como funcionan las certificaciones
y de donde poder encontrar recursos y ayuda para sacarlas. Ya no teneis
excusa a estudiar toca :)


*EOF*

-[ 3x02 ]--------------------------------------------------------------------
-[ La Cripta ]---------------------------------------------------------------
-[ by blackngel ]------------------------------------------------------------


 HACK THE WORLD

 by blackngel <blackngel1@gmail.com>
              <black@set-ezine.org>
             
 (C) Copyleft 2008 everybody



 1 - Prologo
 2 - La Cripta
 3 - Conclusion
 4 - Referencias



---[ 1 - Prologo

Hace tiempo que llevo pensando en una idea. No existe tiempo fisico ni
dispongo de servidores suficientes como para llevar a cabo tal tarea. Es
por ello que expongo aqui lo que se me ha ocurrido por si a alguien le
pica la curiosidad y desea meterse en un nuevo proyecto.



---[ 2 - La Cripta

La idea de La Cripta se me ocurrio tras leer la novela de culto de Neal
Stephenson "Criptonomicon". Escogi este nombre porque me parece el mas
acertado.

El proyecto se basa en crear un espacio web (o paraiso de datos) donde
uno pueda subir toda aquella informacion que desee (ficheros) quedando
esta completamente ilegible despues de cerrar su sesion.

Seria mas bien como crear un agujero negro donde poder tirar todo aquello
que deseamos esconder de miradas ajenas, con la posibilidad de recuperarlo
en cualquier momento.

Que necesitariamos?

   1 - Un servidor Apache. [1]
   2 - PHP [2]
   3 - MySQL [3]
   4 - Truecrypt [4]

Como podria implementarse?

Pues bien, la interfaz de la pagina principal deberia ser igual de sencilla
que el buscador de Google. Es decir lo minimo para que un usuario pueda iniciar
su sesion y un cuadro de dialogo para que pueda subir sus archivos sin tener
que utilizar ningun otro tipo de interactuacion.
Si el usuario quisiera recuperar alguno de sus ficheros, deberia acceder a otro
enlace que le facilitaria un listado de los mismos.

El problema?

El ESPACIO, como siempre. Lo normal seria proseguir la idea de un servidor de
correo o hosting, asignando una cantidad fija de disco duro a cada usuario (por
ejemplo 50Mb).

Cuando el usuario crea por primera vez su cuenta en "La Cripta", el servidor
deberia a~adir automaticamente un nuevo volumen encriptado con la contrase~a
del usuario mediante el software "Truecrypt". Ello es factible gracias a que
la linea de comandos de truecrypt nos facilita la creacion de volumenes con
una sola orden sin necesidad de interactuar directamente con el.

El resto de las veces, cuando el usuario inicie su sesion el volumen se montara
para su uso. Al cierre de la sesion el volumen encriptado se desmontara.

Una de las ventajas es que no todos los usuarios se veran obligados a utilizar
el mismo tipo de cifrado. Gracias a que Truecrypt dispone de varios algoritmos
realmente potentes, esta eleccion podria ofrecersele al usuario en la creacion
de su cuenta.

El nombre del volumen deberia asignarse en la base de datos de usuarios
guardando asi la relacion con el mismo, su nombre deberia ser aleatorio. De este
modo, en caso de intrusion en el servidor, no se ofreceria ninguna pista
acerca de a quien pertenecen los volumenes.

Vale! Hasta aqui bien, pero hay dos datos que necesitamos tener en cuenta. Si
alguiente puede facilitarmelos seria de gran ayuda:

   1 - Numero de volumenes simultaneos que puede manejar Linux.
   2 - Numero de volumenes simultaneos que puede manejar Truecrypt.

Si esto supusiera un limite, deberiamos controlar las entradas al servidor
denegandolas cuando el tope haya sido alcanzado. Esto seria una perdida de
eficiencia enorme cuando no se disponen de suficientes servidores.

Bueno, y ya no queda mucho por decir, el concepto ha sido expuesto lo mas
claramente posible. Ahora solo queda que te pongas manos a la obra y que
utilices un poco de tu imaginacion.



---[ 3 - Conclusion

Como has visto, esto no ha sido mas que una simple idea con posibilidad de
desarrollo. Si estas dispuesto a emplear un poco de tu tiempo y, sobre todo,
si tienes la gran amabilidad de prestar un servicio (deberia ser GRATUITO) a
la sociedad, entonces puedes convertirte en alguien grande.

ETICA: Algunos ya se les habrá ocurrido y es cierto. Por que ofrecer un
       servicio de estas caracteristicas a elementos tales como:
       Terroristas, pedofilos, crackers, kiddies y un largo etc.

       Vale, estamos jodidos, pero eso no es una forma de pensar evolutiva.
       Debemos aceptar que los buenos, aquellos que luchamos contra este
       tipo de comportamientos, tambien necesitamos escoder las armas con
       que combatimos a estas personas.

Al ser una idea, "La Cripta" necesita gente que piense en ella. Cualquier
elemento que puedas aportar, ya sea intelectual como material, no dudes en
hacerlo saber en <blackngel1@gmail.com>.

Y estate tranquilo, si consigues llevar a cabo este proyecto, a mi no
me habras robado la idea, pues para eso la he expuesto. El fruto del
reconocimiento es que esto se convierta en realidad.



---[ 4 - Referencias

 [1] Apache
     http://www.apache.org

 [2] PHP
     http://www.php.net

 [3] MySQL
     http://www.mysql.com

 [4] Truecrypt
     http://www.truecrypt.org


*EOF*

-[ 3x03 ]--------------------------------------------------------------------
-[ Syn vs Fin Scan ]---------------------------------------------------------
-[ by blackngel ]------------------------------------------------------------

            
 HACK THE WORLD
                     
 by blackngel <blackngel1@gmail.com>
              <black@set-ezine.org>
             
 (C) Copyleft 2008 everybody



 1 - Prologo
 2 - Motor Escaneo
 3 - Respuesta
 4 - Conclusion
 5 - Referencias



---[ 1 - Prologo

Aqui se presentara el motor basico de un escaner syn / fin y la diferencia
en concepto que existe a la hora de obtener las respuestas e interpretarlas.

No es una maravilla lo que encontraras aqui, pero si te apetece leer un poco
de codigo y conocer como funcionan este tipo de escaneos sin la necesidad de
destripar Nmap [1] y evitar la agonia de la complejidad que presenta para un
novato, entonces estas en el lugar adecuado.



---[ 2 - Motor Escaneo

Aqui tienes el motor principal para enviar paquetes syn o fin. Debes estar
especialmente atento a la funcion "libnet_build_tcp()". En el quinto parametro
de este metodo debes elegir si enviar la constante TH_SYN o TH_FIN segun el
tipo de escaneo que desees realizar.

Para realizar esta tarea, puedes ayudarte del 3 parametro del motor "type",
segun el valor de esta variable deberias establecer el 'flag' correspondiente.

Tienes deberes. Adapta el codigo.

Requisitos:

 - LibPcap (version 0.8) [2]
 - LibNet (version 1.1 o superior) [3]

Recuerda, las opciones de compilacion para programas que utilicen estas
librerias son: "-lpcap -lnet".

 **-------------------------------------------------------------------------**

#include <stdio.h>
#include <pthread.h>
#include <pcap.h>
#include <libnet.h>

#define SRCPORT 31313

libnet_t *lnet;
u_int32_t src_ip;

static int tscan;

int
scan_syn_fin(char *obj, int nports, int type)
{
   int c;
   u_int port;
   u_int iphdr = 1;
   u_long dst_ip;
   libnet_ptag_t tcp_pkt = 0;
   libnet_ptag_t ip_pkt = 0;
   u_int8_t *payload = NULL;
   u_int32_t payload_s = 0;
   char errbuf[PCAP_ERRBUF_SIZE];
   pthread_t th_snifftcp;

   /* El capturador de paquetes debe saber que tipo de escaneo realizamos */
   tscan = type;

   /* Iniciamos el contexto libnet y obtenemos la ip de origen */
   lnet = libnet_init(LIBNET_RAW4, device, errbuf);
   src_ip = libnet_get_ipaddr4(lnet);

   /* sniff_tcp() es una funcion que capturara las respuestas */
   pthread_create(&th_snifftcp, NULL, sniff_tcp, (void *)nports);

   sleep(1); /* Damos tiempo a que se inicie el capturador de paquetes */

   /* Resolvemos la direccion del host pasado como 1er argumento */
   dst_ip = libnet_name2addr4(lnet, (u_char *)obj, LIBNET_RESOLVE);
   if (dst_ip == -1) {
      printf("libnet_name2addr4(lnet) failed: %s\n", libnet_geterror(lnet));
      exit(1);
   }

   printf("   ***** Escaneando: %s *****\n", libnet_addr2name4(dst_ip, 0));

   for(port = 0; port < nports; port++){

      libnet_seed_prand(lnet); /* Preparar aleatoriedad en el contexto */

      tcp_pkt = libnet_build_tcp(SRCPORT, /* PUERTO ORIGEN */
      /* PUERTO DESTINO */       port,
      /* SEQ */                  libnet_get_prand(LIBNET_PRu32),
      /* ACK */                  libnet_get_prand(LIBNET_PRu32),
      /* TH_SYN o TH_FIN */      TH_SYN,
      /* TAMAÃ‘O VENTANA */       libnet_get_prand(LIBNET_PRu16),
      /* CHECKSUM */              0,
      /* URG */                  0,
      /* LONGITUD PAQUETE */     LIBNET_TCP_H + payload_s,
      /* DATOS */                (u_char *) payload,
      /* LONGITUD DATOS  */      payload_s,
      /* CONTEXTO */	         lnet,
      /* MANEJADOR TCP*/         tcp_pkt);

      /* La cabecera IP solo debe configurarse la primera vez */
      if(iphdr){
         iphdr = 0;

         ip_pkt = libnet_build_ipv4(LIBNET_IPV4_H + LIBNET_TCP_H + payload_s,
         /* TOS */                  0,
         /* ID */                   0,
         /* FRAGMENTACION */        0,
         /* TTL */                  64,
         /* PROTOCOLO */            IPPROTO_TCP,
         /* CHECKSUM */             0,
         /* IP ORIGEN */            src_ip,
         /* IP DESTINO */           dst_ip,
         /* DATOS */                NULL,
         /* LONGITUD DATOS*/        0,
         /* CONTEXTO */             lnet,
         /* MANEJADOR IP */         ip_pkt); 
      }   

      c = libnet_write(lnet); /* Enviamos el paquete */
      usleep(50); /* nanosleep() */
   }
   libnet_clear_packet(lnet); /* Vaciamos el paquete */
   libnet_destroy(lnet); /* Cerramos el contexto */
}

 **-------------------------------------------------------------------------**

Observaras que el motor es realmente sencillo:

   - Se crea un hilo con una funcion que capturara los paquetes (se vera en
     la siguiente seccion).

   - Un bucle 'for' que va desde 0 hasta el numero indicado en el segundo
     parametro de la funcion.

   - Para cada puerto se crea un nuevo paquete configurando la cabecera IP
     solo la primera vez y la cabecera TCP en los sucesivos ciclos.

   - Se manda un paquete cada 50 milisegundos.



---[ 3 - Respuesta

La funcion para establecer la interfaz de red en modo captura es muy sencilla
y suele seguir siempre un mismo orden.

OJO: El programa que implemente tanto este como el codigo anterior, debe
     mantener una variable global como 'char *device' que contenga la interfaz
     de red que utilizaras para realizar el escaneo.

 **-------------------------------------------------------------------------**

/* Paquetes TCP destinados al puerto desde el que realizamos el escaneo */
#define FILTRO_SYNFIN "tcp and dst port 31313"

void *
sniff_tcp(void *var)
{
   int rc;
   char errbuf[PCAP_ERRBUF_SIZE];
   struct bpf_program filtro;
   bpf_u_int32 netp, maskp;
   pcap_t* snifftcp;

   snifftcp = pcap_open_live(device, 1024, 0, 0, errbuf);
   if (snifftcp == NULL) {
      asprintf(&cadena, "pcap_open_live(): %s\n",errbuf);
      salida(1);
      return -1;
   }

   if (pcap_lookupnet(device, &netp, &maskp, errbuf) == -1) {
      asprintf(&cadena, "Error en pcap_lookupnet(): %s\n", errbuf);
      salida(1);
      return -1;
   }
 
   if(pcap_compile(snifftcp, &filtro, FILTRO_SYNFIN, 0, netp) == -1){
      asprintf(&cadena,"Error compilando el filtro\n");
      salida(1);
      return -1;
   }
   if(pcap_setfilter(snifftcp, &filtro) == -1){
      asprintf(&cadena,"Error aplicando el filtro\n");
      salida(1);
      return -1;
   }

   rc = pcap_loop(snifftcp, (int)var, &leer_tcp, NULL);
}

 **-------------------------------------------------------------------------**

Y ahora viene lo interesante del asunto:

Como funciona el escaneo SYN?

   1 - Se envia un paquete SYN a un puerto del objetivo.
   2 - Si se recibe un SYN/ACK, el puerto esta abierto.
   3 - Si se recibe un RST, el puerto esta cerrado.

Como funciona el escaneo FIN?

   1 - Se envia un paquete FIN a un puerto del objetivo.
   2 - Si no se recibe "ninguna" respuesta, el puerto esta abierto.
   3 - Si se recibe un RST el puerto esta cerrado.

El el primer caso, la operacion es muy facil, aquellos paquetes cuyo campo
'th_flags' de la cabecera TCP coincida con las constantes TH_SYN Y TH_ACK
resultaran en un puerto abierto que extraeremos inmediatamente.

El segundo caso es un poco mas complejo de lo que parece, pero no tanto.
Me explico. En los puertos abiertos no llegara ninguna respuesta. La cuestion
es, como interpretar esa "no respuesta"?

La solucion es recibir los paquetes con el flag RST activado y llevar un
contador con el siguiente puerto que deberia responder otro RST comparandolo
cuando este llegue para ver que coincide con el puerto.
Si un puerto esta abierto, este paquete no llegara, el contador no se
incrementara y la proxima vez que recibamos una respuesta la comparacion nos
alertara de que no coinciden.

Vamos a explicarlo con un ejemplo para que se entienda este embrollo. Imaginar
que el puerto 4 esta abierto. Empezaremos con un contador llamado "nextp" a 0.

   * pe -> puerto escaneado

   static int nextp = 0;

   Escanear Puerto = 0 -> [RST] -> (nextp == pe) -> nextp = pe + 1;
   Escanear Puerto = 1 -> [RST] -> (nextp == pe) -> nextp = pe + 1;
   Escanear Puerto = 2 -> [RST] -> (nextp == pe) -> nextp = pe + 1;
   Escanear Puerto = 3 -> [RST] -> (nextp == pe) -> nextp = pe + 1;
   Escanear Puerto = 4 -> NO HAY RESPUESTA
   Escanear Puerto = 5 -> [RST] -> (nextp != puerto escaneado)
                                          ||
                                          ||-> PUERTO "nextp" ABIERTO.
                                               nextp = puerto escaneado + 1;
   Escanear Puerto = 6 -> [RST] -> (netxp == puerto escaneado) -> nextp += 1;
   ...
   ...

Tambien debemos tener en cuenta que puede haber varios puertos consecutivos
abiertos. Para ocuparnos de este detalle utilizaremos un sencillo bucle while
que ira marcando puertos abiertos mientras 'nextp' no vuelva a coincidir con
el puerto escaneado. Es decir, si hay 3 puertos seguidos abiertos, el contador
va a diferir en 3 por debajo del puerto esperado. Iremos incrementando este
contador y marcando como abiertos los puertos en cada interaccion hasta que
este se vuelva a igualarse con el puerto escaneado.

Creo que lo he liado mas de lo que realmente es. Aqui teneis el codigo. Mas
vale un buen codigo que mil palabras :)

 **-------------------------------------------------------------------------**

struct hosts {
   char ip[16];
   int h_ports[65536];
} thost;

static int nextp = 0;

void
leer_tcp(u_char *useless, const struct pcap_pkthdr* pkthdr,const u_char* pkt)
{
   struct libnet_ipv4_hdr *iph;
   struct libnet_tcp_hdr *tcph;

   iph = (struct libnet_ipv4_hdr *)(pkt + LIBNET_ETH_H);
   tcph = (struct libnet_tcp_hdr *)(pkt + LIBNET_ETH_H + LIBNET_IPV4_H);

   switch (tscan) {

      /* SYN SCAN */
      case 1: {
         /* Podrias hacer: (tcph->th_flags & (TH_SYN|TH_ACK) ) */
         if ((tcph->th_flags & TH_SYN) && (tcph->th_flags & TH_ACK)) {
            thost.h_ports[ntohs(tcph->th_sport)] = 1;
         }
         break;
      }

      /* FIN SCAN */
      case 2: {
         if (tcph->th_flags & TH_RST) {
            if (nextp != ntohs(tcph->th_sport)) {
               while (nextp != ntohs(tcph->th_sport)) {
                  thost.h_ports[nextp] = 1;
                  nextp += 1;
               }
            }
            nextp = ntohs(tcph->th_sport) + 1;
         }
         break;
      }
   }
}

 **-------------------------------------------------------------------------**

Y esto es todo lo que te voy a proporcionar, en la estructura 'thost' han
quedado almacenados los puertos abiertos. Estos se distinguen por los elementos
del array h_ports[] que son iguales a 1.

Imprimirlos en pantalla es algo trivial. Pon tus manos sobre el teclado y crea
tu propia interfaz que implemente estas funciones.



---[ 4 - Conclusion

Con esta forma de trabajar, realizar otro tipo de escaneos se vuelve mucho mas
facil. Si echas un vistazo al README del programa "nmap" se te pueden ocurrir
cosas bastante interesantes.

Cualquier duda o correccion, a <blackngel1@gmail.com>.

Hasta la proxima...



---[ 5 - Referencias

 [1] Nmap
     http://www.insecure.org

 [2] LibPcap
     http://sourceforge.net/projects/libpcap/

 [3] LibNet
     http://libnet.sourceforge.net


*EOF*
