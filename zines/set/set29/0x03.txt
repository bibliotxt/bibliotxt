-[ 0x03 ]--------------------------------------------------------------------
-[ Bazar ]-------------------------------------------------------------------
-[ by Varios autores ]-----------------------------------------------SET-29--


Otro numero mas donde damos la oportunidad de publicar en SET a gente que no se
ve con animos para escribir penyazos tan largos como los que suelen ir sueltos o
quieren enviarnos sus trucos, opiniones o pequenyos descubrimientos.

De todas manereras, ya sabeis que lo que nos gusta es que os mojeis y hagais
vuestros articulos cuanto mas completos mejor!


-----------------[  Contenidos del Bazar de SET 29  ]------------------------

    [3x01] Rompecabezas                      by Lindir
    [3x02] Mini ejemplo                      by Astaroth H
    [3x03] Mainframes                        by Anonimo
    [3x04] interpolando                      by FCA0000


     
-[ 3x01 ]--------------------------------------------------------------------
-[ RompeCabezas ]------------------------------------------------------------
-[ by Lindir ]-------------------------------------------------------SET-29--     

	


Me consta que muchos lectores de SET se dedican a la programacion. Algunos
lo hacen por hobby y otros por trabajo. Pero lo que propongo aqui es
divertirnos un poco con lo que podria llamarse "programacion limitada".

Hoy en dia que tan de moda estan los deportes de riesgo, vamos a intentar el
mas dificil todavia de la programacion en C: acercarnos al limite del
lenguaje y el compilador. No os asusteis. No soy ningun guru y posiblemente
muchos de vosotros resolvais los pasatiempos enseguida, aunque si estais
empezando a programar en C puede que os cuesten bastante.

Propongo a continuacion ocho acertijos de programacion en lenguaje C. No se
trata de realizar programas largos o complicados, sino de realizar programas
triviales si no fuera por este detalle: tendremos la sintaxis limitada.

Cada acertijo tiene su propias reglas, que pueden incluir el no utilizar
ciertas palabras reservadas (for, switch ...), usar solo una cantidad
determinada de variables, etc. Ademas hay ciertas reglas comunes: no pueden
usarse funciones de la biblioteca estandar (salvo printf y scanf) ni enlazar
el codigo con ningun modulo externo. Los programas deben constar de un solo
archivo C. Aparte de esto, todo lo que no se indique expresamente como
prohibido estara permitido. Por supuesto, esta expresamente prohibido el uso
de ensamblador en linea o utilizar buffers de codigo: todo debe hacerse en C.

Como guia, los acertijos estan ordenados, y los primeros pueden resolverse
de forma mas sencilla que los ultimos, en general. Ademas algunos estan
relacionados con los siguientes. Por lo tanto, si sois capaces de resolver
los ultimos podreis utilizar lo aprendido para resolver los primeros de
forma distinta a la solucion propuesta.

Tras cada uno de estos pasatiempos incluyo una solucion al mismo. La
solucion no tiene por que ser unica ni la mejor posible. He intentado que
sea corta cuando esto ha tenido sentido, y que sea clara en la mayor parte
de los casos, incluyendo comentarios al codigo.

Notar que las soluciones pueden no funcionar en ciertos compiladores o
maquinas. Su correccion esta comprobada usando el gcc 2.95.3 (si, es muy
antiguo) bajo Linux en un x86. Seguro que versiones mas modernas del mismo
compilador tambien sirven. Tambien puede ser que segun las opciones de
compilacion (alineacion de la pila, etc.) alguna no funcione. Como pista,
yo utilizo la orden "gcc archivo.c -o archivo". He intentado evitar que el
compilador muestre "warnings", salvo el de que la funcion main devuelve void
en lugar de int.

Estas soluciones propuestas estan escritas "al reves". Cada linea debe ser
leida de derecha a izquierda. Incluyo un peque¤o programa que "da la vuelta"
a las lineas recibidas por la entrada estandar, para que podais comprobar de
forma mas rapida si vuestra solucion coincide con la propuesta.

Os aconsejo que si alguno no os sale a la primera lo penseis un tiempo y no
mireis la solucion enseguida, puesto que ya no tendra gracia volverlo a
intentar. En algun caso el siguiente pasatiempo puede daros una pista de como
resolver el anterior.

				-Vuelta.c-
/* vuelta.c: programa que toma lineas de la entrada estandar y las escribe
caracter a caracter desde el final al principio por la salida estandar. */
#include <stdio.h>
void main (void){
	char linea[256];
	int c,n=0;
	while ((c=getchar())>0){
		if (c=='\n'){
			int i;
			for (i=n;i>0;i--)
				putchar(linea[i-1]);
			putchar(c);
			n=0;
		}
		else linea[n++]=(char)c;
	}
}
/**************************** fin de vuelta.c ******************************/


				-Acertijos-

/****************************************************************************
1) Pasatiempo en C n§ 1:

	Sin utilizar if, do, while, for, switch, goto ni el operador ternario
	?, hay que realizar un programa que compare dos numeros enteros (a y
	b) que reciba por teclado e imprima un mensaje en la pantalla
	indicando cu l de ellos es mayor ("a es mayor/menor que b").
	S¢lo se permite llamar a scanf() y printf() para recibir los n£meros
	e imprimir los mensajes. No se permite llamar a ninguna otra funci¢n
	de biblioteca.
*/


/* Soluci¢n: */
>h.oidts< edulcni#

{)diov(niam diov
;b,a tni	
;)b&,a&,"d% d%"(fnacs	
;)b,a,"n\d%>d%"(ftnirp && ))b,a,"n\d%<d%"(ftnirp! || b>a(	
}
/****************************************************************************/

/****************************************************************************
2) Pasatiempo en C n§ 2:

	Se trata de, sin usar mas constantes que las cadenas pasadas a
	printf y scanf para recibir los datos e imprimir los mensajes y sin
	usar operadores *, /, ni ++, hacer un programa que multiplique dos
	numeros que reciba por teclado e imprima un mensaje con el resultado
	de la operacion.
	No puede usarse ningun tipo de constante literal, ni siquiera
	constantes numericas  (1,2...) o de caracter ('a','\0'...).
*/

/* Solucion: */
>h.oidts< edulcni#

{)diov(niam diov
;d,c,b,a dengisnu	
/* ;1 = d */			;)a&,"d%"(fnacs=d	
;)b&,"d%"(fnacs	
/* 0 = c */					;c=^c	 
/* rodacilpitlum elcub */			};b=+c;d=-a{)a(elihw	 
;)c,"n\d%"(ftnirp	
}
/****************************************************************************/

/****************************************************************************
Pasatiempo en C n§ 3:

	Al igual que el anterior, se trata de, sin usar mas constantes que
	las cadenas pasadas a printf y scanf para recibir los datos e imprimir
	los mensajes y sin usar operadores *, /, ni ++, hacer un programa que
	multiplique dos	numeros que reciba por teclado e imprima un mensaje
	con el resultado de la operacion.
	No es valido usar los valores de retorno de las	funciones de stdio.h.
*/

/* Solucion: */
>h.oidts< edulcni#

{)diov(niam diov
/* tesffo elpmis nU */				;f,e rahc	
/* 1 = d */		;)f&(-)e&(=d,c,b,a dengisnu	
;)b&,a&,"d% d%"(fnacs	
/* 0 = c */					;c=^c	 
/* rodacilpitlum elcub */			} ;b=+c ;d=-a {)a(elihw	 
;)c,"n\d%"(ftnirp	
}
/****************************************************************************/

/****************************************************************************
Pasatiempo en C n§ 4:

	Utilizando solo una variable, una llamada a printf, y el caracter
	; dos veces, hay que escribir un programa que imprima los numeros del
	1 al 5, sin utilizar ninguna constante numerica ni llamada a funcion. 

*/

/* Solucion: */
>h.oidts< edulcni#

{)diov(niam diov
;c^c=c tni	
;)c++,c++,c++,c++,c++,"n\d% d% d% d% d%"(ftnirp	
}
/****************************************************************************/

/****************************************************************************
Pasatiempo en C n§ 5:

	Usando el caracter ; solo dos veces y unicamente dos variables,
	escribir un programa que multiplique dos numeros que reciba por
	teclado.
*/

/* Solucion: */
>h.oidts< edulcni#

{)diov(niam diov
;b,a tni	
;))b&,a&,"d% d%"(fnacs,b*a,"n\d% :se odatluser lE"(ftnirp	
}
/****************************************************************************/


/****************************************************************************
Pasatiempo en C n§ 6:

	Sin utilizar operadores de multiplicacion ni bucles for/while/do
	y usando el caracter ; solo tres veces, escribir un programa que
	multiplique dos numeros unsigned >0 que reciba por teclado.
*/

/* Solucion: */
>h.oidts< edulcni#

/* noicacilpitlum ed ovisrucer omtiroglA */
{)b dengisnu ,a dengisnu(itlum dengisnu
;)b,1-a(itlum+b:b?1==a nruter	
}

{)diov(niam diov
;b,a dengisnu	
;))b&,a&,"d% d%"(fnacs,)b,a(itlum,"n\d% :se odatluser lE"(ftnirp	
}
/****************************************************************************/

/****************************************************************************
Pasatiempo en C n§ 7:

	Sin utilizar el caracter ; ni ninguna constante mas que las cadenas
	de formato para printf/scanf, escribir un programa que reciba un
	numero (se supone > 0) por teclado y escriba todos los numeros desde
	este al 1.
*/


/* Solucion: */
>h.oidts< edulcni#

{)vgra** rahc ,cgra tni(niam diov
}{)))cgra&,"d%"(fnacs!(||)cgra=^cgra((elihw	
)cgra(elihw	
}{)cgra--||)cgra," d%"(ftnirp!(elihw		
}
/****************************************************************************/

/****************************************************************************
Pasatiempo en C n§ 8:

	Sin utilizar el caracter ; ni los operadores * / ni mas constantes
	que las cadenas de formato de printf/scanf, escribir un	programa
	que reciba dos numeros (se suponen > 0) por teclado e imprima el
	resultado de multiplicarlos.
*/


/* Solucion: */
>h.oidts< edulcni#

redop arap eneit es olos ortemarap omitlu lE .noicacilpitlum ed noicnuF */
/* ; le razilitu nis sam lacol elbairav anu noc ratnoc
{)c tni ,b* tni ,a* tni(itlum tni
/* ;0=c */			}{)c=^c(fi	
/* rodacilpitlum elcub */			{)a*(elihw	
}{)--)a*((fi		
}{))b*(=+c(fi		
}	
/* aicnerefer rop odatluser led osaP */		}{)c=a*(fi	
}

{)vgra** rahc ,cgra tni(niam diov
/* ;0=vgra=cgra ,oremirP */	
	}{))vgra)tni(^vgra)tni(=vgra)tni((||)cgra^cgra=cgra((fi	
	
/* odalcet rop adartnE */	
	}{))vgra&,cgra&,"d% d%"(fnacs!(fi	

/* .odatluser led noiserpmi e noicacilpitluM */	
}{))cgra^cgra(&&)cgra,vgra&)* tni(,cgra&(itlum(fi	
 }{))cgra,"n\d%"(ftnirp!(fi	
}
/****************************************************************************/





-[ 3x02 ]--------------------------------------------------------------------
-[ Mini ejemplo ]------------------------------------------------------------
-[ by Astaroth H ]---------------------------------------------------SET-29--


 
"El mar siempre esta ahi y es imposible aprender a nadar si nunca intentamos 
sumergirnos en el".
                                   (Relis).


 ######=====....___Introduccion___....=====######
 Bueno este es mi primer tutorial, espero que lo entiendan.
 El programa con que comienzo es interesante a parte de que es un buen 
 explorador de windows de 1 a 10 le pongo 7, es interesante porque voy a 
 utilizar varias herramientas, y para que uno que no sabe utilizarlas las 
 aprenda facilmente, entonces a por el perrito.

 Programa    : Super Explorer  v 1.4
 Proteccion  : Tiempo limite de 15 dias y esta empaquetado.
 Descripcion : Es un buen explorador de windows.
 Dificultad  : Newbie.
 Web site    : http://www.galcott.com
 Herramientas: Exescope v 6.30
               ProcDump32 v 1.6
               W32Dasm v 8.93
               Hex Workshop v3.02
               (Las pueden conseguir de cualquier lado hay muchas).
 Cracker     : Cracker

 ######=====....___Comenzando___....=====######

 Primero: (A jugar perrito).
         Lo instalamos, lo ejecutamos y una nag nos dice que este programa no 
 esta registrado, luego entramos y miramos que de bueno tiene el programa, 
 jugamos con el un rato y a mi me parecio interesante, y hay muchas que hacer 
 con el, pero bueno a crackearlo, para eso primero vamos al menu Help y 
 escogemos Enter Registration Code, nos sale una ventana solo con un espacio 
 para poner nuestro codigo ponemos cualquiera y OK, y un mensaje diciendo 
 "Incorrect Registration Code", lo anotamos y salimos del programa.

 Segundo: (Ahora la patita, la patita perrito).
         Siempre antes de crackear hay que analizar el programa, por ahi hay 
 muchas herramientas yo utilizo el Exescope v 6.30 , entonces ejecutamos 
 Exescope y abrimos superexp.exe y nos aparece tres menus: Header 
 (informacion del programa), Import (las funciones que importa) y Resource 
 (Recursos del programa).

 Entramos a Header y vamos a encontrar varios submenus (No voy a ahondar en 
 todo lo que significa esto, si quieren mas informacion de esto, busquen por 
 ahi tutoriales sobre encabezados PE) , y nos dirigimos a Section Header y 
 vamos a ver que hay UPX0, UPX1 y .rsrc, esto significa que esta empaquetado 
 con un uno que se llama UPX; ahora que sabemos que esta empaquetado hay que 
 desempaquetarlo. (Si desean pueden ver lo que hay en los otros menus y 
 submenus).

 Tercero: (Hazte el muerto perrito).
         Para desempaquetarlo voy a utilizar ProcDump32 v 1.6, ejecutamos 
 ProcDump32 y dentro nos dirigimos a Unpack y escogemos UPX (el empaquetador) 
 damos a OK y luego abrimos superexp.exe, y nos sale un mensaje le damos a 
 aceptar, esperamos un momento y nos sale una pantalla diciendonos con que 
 nombre vamos a guardarlo, ponen el nombre que les guste y guardar, despues 
 aparece un mensaje diciendonos que a terminado, le damos a aceptar y listo 
 programa desempaquetado, ahora podemos trabajar con el desensamblador. (Como 
 observacion el original pesa 905KB y el desempaquetado 2,854KB).

 Cuarto: (Vamos perrito, traeme el palo perrito).
        Vamos a desensamblarlo, (Como observacion si intentamos desensamblarlo 
 sin desenpaquetarlo nos saldra un mensaje diciendo que el W32Dasm a 
 efectuado una operacion no admitida y que se tendra que cerrar). Ejecutamos 
 W32Dasm v8.93 y abrimos el desempaquetado y podemos ir a preparar un cafe, 
 porque se va a demorar un par de minutos.

 Una vez dentro buscamos en las SDR (String Data References), la cadena que 
 anotamos al comienzo la del mensaje del error "Incorrect Registration Code", 
 cuando la encontremos hacemos doble click y nos lleva a una parte del codigo 
 le damos otra vez doble click a la cadena para saber si hay mas 
 coincidencias en el codigo pero solo hay una que es esta:

 :005DBF53 BAE4BF5D00             mov edx, 005DBFE4
 * Possible StringData Ref from Data Obj ->"You have been successfully
                                            registered."
 |
 :005DBF58 B8F4BF5D00             mov eax, 005DBFF4
 :005DBF5D E87A91FEFF             call 005C50DC
 :005DBF62 A178D26200             mov eax, dword ptr [0062D278]
 :005DBF67 8B00                   mov eax, dword ptr [eax]
 :005DBF69 E88AB9E7FF             call 004578F8
 :005DBF6E EB14                   jmp 005DBF84   ; Salto incondicional que 
                                                   nos evita el mensaje de error
 * Referenced by a (U)nconditional or (C)onditional Jump at Address:
 |:005DBEB3(C)
 |
 :005DBF70 B930000000             mov ecx, 00000030

 * Possible StringData Ref from Data Obj ->"Error"
 |
 :005DBF75 BA94C05D00             mov edx, 005DC094

 * Possible StringData Ref from Data Obj ->"Incorrect registration code"
 |
 :005DBF7A B8A4C05D00             mov eax, 005DC0A4           ; Aparecemos 
                                                                aqui
 :005DBF7F E85891FEFF             call 005C50DC

 * Referenced by a (U)nconditional or (C)onditional Jump at Address:
 |:005DBF6E(U)
 |
 :005DBF84 33C0                   xor eax, eax


 Un salto condicional nos trae aqui y un poco mas arriba hay un salto 
 incondicional que evitaria mostrar el mensaje de error y arriba de ese salto 
 esta el mensaje de felicitacion por registrarnos, pero miremos quien nos 
 trae al mensaje de error, asi que busquemos con la linterna la direccion 
 005DBEB3 , nos lleva aqui:

 * Referenced by a (U)nconditional or (C)onditional Jump at Address:
 |:005DBE44(C)
 |
 :005DBEB3 0F85B7000000           jne 005DBF70    ; Aparecemos aqui
 :005DBEB9 B201                   mov dl, 01
 :005DBEBB A1400B4800             mov eax, dword ptr [00480B40]
 :005DBEC0 E8974EEAFF             call 00480D5C
 :005DBEC5 8BD8                   mov ebx, eax

 Miremos que tambien se viene aqui con un salto condicional y cuando llega 
 esta el salto que si no son iguales, no se que cosa, salta y el error, y si 
 son iguales nos muestra el mensaje de felicitacion asi que podemos nopear 
 toda esa instruccion osea:
 cambiar :    005DBEB3 0F85B7000000        jne 005DBF70
 por     :    005DBEB3 909090909090        nop nop nop nop nop nop

 Los 90 significa NOP'S en hexadecimal, nop significa que no hace nada y asi 
 siempre nos muestra el mensaje de felicitacion .

 Para eso ponemos el seleccionador (marca celeste) del W32Dasm encima de la 
 instruccion 
 : 005DBEB3 0F85B7000000           jne 005DBF70 
 y en la parte de abajo miramos el offset de esa instruccion la anotamos, y 
 luego entramos en el Hex Workshop abrimos el ejecutable buscamos el offset y 
 cambiamos los bytes y lo guardamos.

 Luego ejecutamos Super Explorer introducimos cualquier codigo y listo 
 programa registrado.
 (Eso perrito asi se hace).

 Observacion: En el desensamblado si subimos un poco por encima del mensaje 
 bueno, veremos que entra en el registro para meter la clave que hayamos 
 escrito.


 Comentarios a astaroth_h@hotmail.com

 Chau y espero que les haya gustado este tutorial, y espero que no sea el 
 ultimo que escriba.








-[ 3x03 ]--------------------------------------------------------------------
-[ Introduccion a los mainframes ]-------------------------------------------
-[ by Anonimo ]------------------------------------------------------SET-29--


1. Prefacio
-----------
Vaya hombre... una busqueda del termino 'mainframe' en todos los numeros de
SET y ni una sola referencia. Con la ilusion que me hacia... ¨Sera que no
interesa el tema? Solo dire que los bancos son de los principales usuarios;
eso ya los hace muy atractivos de estudiar. ¨Estaran pasados de moda? Pues
tampoco, aunque en los 80 parecia que iban a desaparecer.

En un primer momento pense que lo que pasaba es que los mainframes son
bastante desconocidos y que ademas los hackers no hablaban de ellos en las
e-zines porque les da rabia la imposibilidad para hackearlos.

En realidad hice mal la busqueda. Hay referencias a 'Main frames' en SET15
(Red Global de IBM, de fca0000, y en los SET24 (Modems, de IMOEN) y SET04
(Metodos de hacking, de warezzman!!!). Que bien... pero no me satisfacen. ­Yo
quiero mas informacion!


El presente texto pretende ofrecer una vision global del confuso concepto de
mainframe.

La informacion aqui contenida no siempre es correcta ni objetiva (menos da una
piedra).



2. Que es un mainframe?
------------------------
Eso me pregunto yo. Despues de dudar de mi propia idea de mainframe, y tras
buscar en el Google, llego a la conclusion de que en Internet hay demasiada
informacion y ningun metodo automatico para resumirla al gusto de uno mismo.
Asi que he intentado resumir las referencias del apartado final (y otras que
no menciono). Y este es el resultado.


Etimologicamente, mainframe se refiere a la estructura o sistema (frame)
principal (main), en referencia a la convergencia en un solo bloque principal
de las diferentes unidades (procesamiento, comunicacion, datos...) que tuvo
lugar con los primeros mainframes.

El concepto suele aplicarse sobretodo a ordenadores grandes en general,
variando entre miniordenadores y macroordenadores segun la definicion. Los
originales ocupaban grandes salas. Los actuales son como armarios. Otras
definiciones no menos precisas, se concentran en el hecho de procesar muchos
datos, o procesar datos muy deprisa, o lo equiparan al concepto de servidor
grande o al concepto de multiusuario, incluso se llega a referenciar como un
sistema operativo en si mismo... un cajon de sastre!

Segun el diccionario de IBM, su principal fabricante, un mainframe es 'un
ordenador, generalmente de un centro computacional, con amplias capacidades y
recursos a los que otros ordenadores pueden ser conectados para poder
compartir facilidades (...).' Algo asi como un procesador de la ostia con una
gran base de datos y con capacidad de servir el resultado a otra maquina.

Otra definicion adecuada y muy flexible es la que sostiene que un mainframe es
'una plataforma de computacion de uso general en continua evolucion y que
incorpora en su definicion arquitectural la funcionalidad esencial requerida
por las aplicaciones a las que va dirigida'. Es una definicion mas basada en
el software del cliente que en el hardware.


En mi humilde opinion, un mainframe es una gran maquina (o varias) de
computacion, los sistemas operativos por los que corre, las arquitecturas de
red que lo soportan, y las aplicaciones que ejecuta y que lo mantienen, y que
posee una suprema capacidad para almacenar, procesar y compartir enormes
volumenes de datos y de procesos de forma altamente rapida y
extraordinariamente segura.

¨A que mola? Es un poco larga. ¨Como que no mola? Pues saca tu propia e
igualmente valida conclusion despues de repasar la historia de los mainframes
y las principales caracteristicas de los actuales.



3. Breve historia de los mainframes
-----------------------------------
La historia de los mainframes tiene 60 anos (12 lustros, maldita enye!).

Empieza con el nacimiento de maquinas enormes capaces por ejemplo de realizar
multiplicaciones en pocos segundos (que ya es mas que muchas personas). P.ej.,
el SSEC de IBM de 1944, el ENIAC de 1942, BINAC de 1949...

Posteriormente, en la decada de los 50's, nacen los ultimos ordenadores
basados en tubos de vacio como los IBM 701, 650 y RAMAC 305, y los primeros
basados en transistores como los IBM DPS 7070, 1401 y 7000. Consultad la web
de IBM para un listado mas completo.

A partir de los 60's los mainframes sufren un redisenyo radical. Aparece la
serie IBM System/360, un sistema con tecnologia SLT (Solid Logic Tech.),
economicamente mas asequible y con mejores prestaciones de almacenamiento,
procesamiento y recuperacion de datos.

La decada de los 70's trae la serie M de Hitachi y la serie IBM System/370 con
los recien nacidos circuitos integrados en placas de silicio. Se incorporan
chips cada vez mas miniaturizados y con cableado de circuitos cada vez mas
corto, sus sistemas de refrigeracion mejoran notablemente, empiezan a poder
utilizar mas de un procesador en paralelo...
Los modelos IBM 30xx de la decada de los 80's parece que son mejoras de la
serie System/370, con chips con mayores capacidades (p.ej., familia SAMOS) y
con innovaciones en refrigeracion y mantenimiento del hardware.

Coincidiendo con la expansion y crecientes posibilidades del PC y de las work-
stations, empiezan a escucharse malos augurios sobre los mainframes. Por
entonces se les llego a dar menos de 10 anos de vida. Los fabricantes empiezan
a fusionarse y a reestructurarse.

Pero con la llegada de internet, IBM introduce ya en los 90's la serie
System/390 y la arquitectura ESCON z/os, dirigida al e-business de grandes
empresas, y compuesta de circuitos ultradensos, comunicaciones por fibra
optica, capacidades multiplicadas de supercomputacion y de optimizacion de
los recursos (procesadores CMOS en vez de procesadores bipolares) que reducen
el precio final.

Los 90's tambien traen la tecnologia de control en paralelo de los Hitachi
MP5800.

El exponencial desarrollo de internet y la e-tecnologia ha traido la familia
IBM eServer, con sus omnipotentes representantes z900, z800 y z990.

Con el anuncio de Hitachi de dejar de fabricar sus mayores modelos Trinium y
Pilot se deja el monopolio en manos de IBM. El resto de mercado se lo
reparten pocas companias mas, sobretodo asiaticas como Hitachi, Ahmdal,
Fujitsu...


Las joyas actuales son los IBM z990. Salen a la venta en 2003. Introducen la
puntera tecnologia MCM (MultiChip Module): un modulo mas pequeno que tu mano
con 3 millones de transistores ultradensos aislados con tecnologia SOI capaces
de procesar 9000 MIPS (millones de instrucciones por segundo). La
virtualizacion que tienen les confiere la capacidad de soportar miles de
servidores en un solo aparato. Posee exquisitos mecanismos dinamicos de
redireccionamiento de recursos (y 256 GB de RAM). Y su seguridad y control
de intrusiones y fallos es extrema. ¡¡Sus 32 procesadores creo que lo hacen
mejor que mi Pentium II!!

Aunque tanta excelencia es muy cara: suelen costar entre 10.000 a 500.000
dolares USA.


4. Y quien puede permitirse unas maquinas tan caras?
-----------------------------------------------------
Los mainframes son sistemas-maquinas-servidores que gestionan el procesamiento
diario de cantidades desorbitadas de datos y de modo concurrente.
Por ello, son maquinas utilizadas basicamente por empresas que generan ese
tipo de datos y que pueden pagar tantos millones (principalmente aerolineas
y empresas de transporte, holdings bancarios, grandes almacenes...), centros
superiores de investigacion privados y publicos, e instituciones publicas
civiles y militares.
No obstante, en el terreno de la investigacion tambien tenemos a los monstruos
capaces de realizar predicciones y simulaciones metereologicas, sismicas,
militares, geologicas, fisicas... que no por grandes se llaman mainframes.

La mayor centralizacion del uso de mainframes para empresas privadas reside en
las grandes capitales economicas y politicas (Madrid y Barcelona en el caso de
Espana).

<Opinion> A pesar de crecer el volumen de transacciones y el mercado de
negocio de estas empresas, que en ultima instancia se procesa en los
mainframes, el maldito capitalismo subsubcontratista privado y amoral, se
concentra en explotar y despedir al personal que lo mantiene funcionando.



5. Principales caracteristicas de un mainframe
----------------------------------------------
Intentar encontrar puntos comunes a todos los mainframes actuales es tarea
dificil. Basicamente son las siguientes, no necesariamente todas ni en el
orden expuesto (ten en cuenta la definicion dinamica del mainframe segun el
fin al que se destina):

- Aspecto: Las maquinas suelen ser del tamano de un armario o estanterias de
  biblioteca. Tienen gran ramificacion de conexiones y un sistema de
  refrigeracion fuera de lo normal (aire y/o agua). (En las referencias hay
  fotos).

- Elevadisima velocidad de ejecucion de instrucciones de maquina (cientos a
  miles de MIPS; MIPS = millon de instrucciones por segundo). Aqui se pueden
  englobar varias caracteristicas:
  1- Generalmente tienen varias CPU's (hasta una trentena).
  2- Se comparten recursos por reasignacion dinamica de procesos al
     procesador disponible. P.ej., tecnologia IRD de IBM o PCT de Hitachi.
  3- Tecnologia VMS (Virtual Machine System): Permite soportar diferentes
     sistemas operativos en cada maquina virtual. El gran desarrollo de la
     virtualizacion amplian la memoria disponible y por tanto su poderio.
  4- Gran velocidad de I/O. La conectividad entre componentes (CPU o
     circuiteria de ejecucion, memoria o almacen de datos, y unidades
     perifericas) esta muy optimizada.
  5- Pueden incluso poseer un juego propio y mas amplio de instrucciones de
     maquina, de registros, de interrupciones... Un ejemplo es el High Level
     Assembly Language, que nada tiene que ver con el ensamblador para 80x86
     que tanto me cuesta seguir.


- Elevadisimo numero de accesos a bases de datos sin cabida a la corrupcion de
  datos por contencion de procesos. Aqui juega un gran papel la tecnologia de
  la base de datos (DB2, IMS, Oracle...), el soporte (cinta, disco, cartucho,
  disco optico...), y el metodo de acceso (utilidades del fabricante). Hasta
  7 Terabytes a disposicion de la empresa. Hasta varios millones de registros
  generados al dia a ser procesados en tiempo real (y en batch, ya no te
  cuento).

- Gran numero de usuarios en concurrencia (p.ej., miles de usuarios), gracias
  a tecnologia TSS (Time Share System).

- Uso continuado 365 dias al ano y 24 horas al dia. Permiten la reparacion de
  fallos sin dejar de dar servicio al usuario.

- El mainframe suele ser la maquina de ejecucion (jobs) y de almacen (bases de
  datos), y el resultado se envia a un terminal conectado (estaciones de tele-
  working).

- Soporta diferentes protocolos y arquitecturas de red y de comunicacion: SNA,
  TSO, emulacion T3270, TCP/IP, ftp's, intranets y LAN's... Creo que de todo.

- Los sistemas operativos soportados suelen ser especiales: z/OS, OS/390, MVS,
  VM, VSE, WindowsNT, UNIX e incluso Linux (almenos los IBM).
                                                              
- Soportan aplicaciones generalmente programadas en COBOL, REXX, FORTAN, PLI,
  REXX, SAS, ASM, C, C++, Java, XML...

- Utilizan en inteligente sinergia las tecnologias mas punteras en seguridad
  contra errores internos y contra accesos no autorizados (p.ej. ACL o Access
  Control List, RACF o Resource Access Control Facility, DES o Data Encrypting
  Standard, firewalls y gateways, transacciones SSL o Secure Socket Layers,
  incluso pueden albergar utilidades criptograficas intrinsecas en la propia
  CPU...).


6. Conclusion
-------------
La vaguedad, amplitud y flexibilidad del concepto 'mainframe' hacen de el un
sustantivo dificil de utilizar, a la vez que encaja en muchas definiciones.

En mi opinion, seria preferible hablar en terminos de sistema operativo o de
la plataforma de comunicacion o de hardware que esta siendo utilizando, mas
que de mainframe. O incluso de la empresa que lo utiliza.


Bueno, amiguetes, espero que os haya interesado.



7. Referencias
--------------
1.- http://www-1.ibm.com/ibm/history/exhibits/mainframe
    Historia de los mainframes IBM.
2.- http://www-1.ibm.com/ibm/history/documents/pdf/glossary.pdf
    Dictionary of IBM and Computing Terminology
3.- http://www.mainframes.com/whatis.htm
    Lo que yo me pregunto: que es un mainframe.
4.- http://www.sdl.hitachi.co.jp/english
    http://www.amdahl.com
    Paginas de la principal competencia de IBM.
5.- http://www.thocp.net/hardware/mainframe.htm
    Excelente web sobre la historia de la informatica. Visitadla!
6.- http://www.ibm.com
    Miles de manuales tecnicos de productos IBM (serie RED books).


-[ 3x04 ]--------------------------------------------------------------------
-[ interpolando ]------------------------------------------------------------
-[ by Fca0000 ]------------------------------------------------------SET-29--

/*
Hola a todos, ninios y ninias. Bienvenidos a otra excitante leccion del
profesor Siesta.

Nuestro tema de hoy va a consistir en la imposibilidad de la interpolacion
numerica.Este es un tema para el que son necesarias unas bases matematicas
de las que se estudian cuando tiene 15 anios, que es aproximadamente cuando
se estudian polinomios en una variable.

Para los que lo han olvidado (o nunca lo han sabido), un polinomio de grado-n
es una funcion inyectiva, continua, derivable hasta n veces, con dominio R
(los numeros reales) y campo R o un subconjunto suyo, y que se expresa como
constantes multiplicativas de potencias de la variable.

Esto quiere decir mas o menos que:
-se definen como
 f(x)=a*x^n + b*x^(n-1) + c*x^(n-2) + ...+ t*x^2 + u*x + v
 Por supuesto, el simbolo '^' significar elevar a la potencia, o
 sea, multiplicarlo por si mismo tantas veces como indique
 el exponente)
-la variable  x  puede tomar cualquier valor Real. Esto
 incluye valores como 1, 5, 0, -17 , 24/5 , PI, raiz cuadrada de 2,
 raiz sexta de 17
-en cambio, valores no permitidos de x son: infinito, raiz
 cuadrada de -1 , matrices, conjuntos de numeros, valores
 de 2 dimensiones, y otros bichos raros
-cuando se toma una variable x y se le aplica la funcion f(x) se
 obtiene un valor  y. Normalmente se representa en un sistema
 de coordenadas, con una abcisa x y una ordenada y. Si, ese dibujo
 que tiene una raya vertical y otra horizontal y una curva continua.
-ser una funcion inyectiva significa que para un valor de x solo
 puede haber un valor de y. Por ejemplo, una circunferencia no
 puede provenir de un polinomio porque existen rayas verticales
 que cortan a la circunferencia en 2 puntos.
-es continua: si tomas un valor de x1 y otro cercano x2, sus
 respectivos valores y1 , y2 tambien estan cercanos. En otras
 palabras, no hay saltos al pintar la curva, ni huecos en medio.

Por ejemplo:
f(x)=x+9

f(x)=x^2 - 1

f(x) =x^400000 + x^ 399999

f(x) = (x-2) * (x+2)

f(x) = (x^4)/3 + 2*(x^3)/3 + 3*(x^2)/2 + 4*x + 5

f(x)=7

Pero NO son polinomios:
f(x) = 88*(x-5)/(x^4)

f(x) = sqr(x)  , donde sqr es la raiz cuadrada.

f(x) = x^x

f(x)= 2^x

f(x) = cos(x) , donde 'cos' es la funcion coseno

Lo que trato de mostrar aqui es que cualquier funcion cuyos
datos sean todos valores enteros (numeros sin decimales, vamos)
es posible expresarla como un polinomio
Por ejemplo:
si f(1)=2 , f(2)=4, f(3)=6, f(4)=8, f(5)=10, f(6)=12 , cuanto
crees que vale f(7) ?  La respuesta logica es 14, pues f(x)=2*x

Otro ejemplo:
f(1)=1, f(2)=4, f(3)=9, f(4)=16, f(5)=25, f(6)=36, f(7)=49,
cuanto crees que vale f(8) ? Esta vez la respuesta logica es 64, pues f(x)=x^2

Seguro que es mas dificil si uso polinomios con mayores
exponentes de x, y los valores de las constantes las uso
negativas y con fracciones (decimales). Pero no
se trata aqui de complicarnos la vida.

Una aplicacion inmediata es cuando se usa f(x)=g(f(x-1))
por ejemplo, para hallar el siguiente de una serie
de numeros. Esto es, en los que cada numero depende
solamente de su posicion en la lista.

Vamos alla: cual es el numero siguiente en esta serie:
2, 4, 6, 8, 10, 12, ?   La respuesta logica es 14, pues
siguiente(x) = f(x) , siendo f(x)=x*2, siendo x su
posicion en la lista.

Y en esta serie:
0.0001 , 0.0004, 0.0009, 0.0016, 0.0025, 0.0036, 0.0049, ?
La respuesta es 0.0064 , y aqui f(x)=(x^2)/10000

Bien, pues ahora supongamos que tenemos unos numeros
de serie de un programa, o unos numeros de recarga de
tarjetas de moviles, o simplemente un test psicotecnico
de esos en los que piden cual es el numero que sigue a otros.

Concretando, la cuestion se reduce a: 
partiendo de una serie de numeros (tan larga como se quiera)
nos piden averiguar el siguiente.

Bueno, pues la solucion es 'cual quieres que sea?'
En efecto, cualquier numero puede seguir la secuencia.

Por eso, si alguien me da una lista de 25 numeros
para recargar tarjetas de pre-pago de moviles yo soy
capaz de decir cual es el siguiente numero: 220 (pues
este es mi numero favorito), y soy capaz de demostrarlo.
Por supuesto que tambien puedo demostrar que es cualquier
otro numero, por eso no me sorprendo cuando me dicen el
siguiente numero y no coincide con el mio.

La demostracion mas convincente es dar la formula:

      N
   +-----        N
    \        ---------
     \        |     |
f(x)= \ { Y  *|     | (X - X)   /           }
      /    i  |     |       j  /  (X - X) 
     /        |     |         /     i   j 
    /         |     |
   +------     j=1
      i=1       j!=i


Que quiere decir este dibujo?
El primer simbolo se llama sumatorio. Quiere decir tomar
los valores desde 1 hasta N , hacer algo con cada uno de
ellos, y al final sumarlos todos.

El segundo simbolo se llama producto multiple (el nombre
correcto seria productorio). Quiere decir tomar los
valores desde 1 hasta N , pero solo si  i  es distinto de  j,
hacer algo con ellos , y luego multiplicarlos todos.

Cada vez que aparece X   o  X   quiere decir tomar el valor
                      i      j  
de X en la posicion i-esima , es decir: la primera, la
segunda, la decimo-septima (es totalmente incorrecto
decir diecisieteava; eso significa otra cosa) o la
127-esima.

Similarmente, Y   es el valor conocido en el punto X
               i                                    i

Tomemos la serie 1,2,3,4 . El siguiente valor es 220.
No te lo crees?
Dicho de otro modo: f(1)=1, f(2)=2, f(3)=3, f(4)=4, f(5)=220
Para verlo, usamos este poligono interpolador, de acuerdo con
la formula que hemos dicho antes:


f(x)=   { 1 * [      (x-2)*(x-3)*(x-4)*(x-5)]/[      (1-2)*(1-3)*(1-4)*(1-5)] }
      + { 2 * [(x-1)*      (x-3)*(x-4)*(x-5)]/[(2-1)*      (2-3)*(2-4)*(2-5)] }
      + { 3 * [(x-1)*(x-2)*      (x-4)*(x-5)]/[(3-1)*(3-2)*      (3-4)*(3-5)] }
      + { 4 * [(x-1)*(x-2)*(x-3)*      (x-5)]/[(4-1)*(4-2)*(4-3)*      (4-5)] }
      + {220* [(x-1)*(x-2)*(x-3)*(x-5)      ]/[(5-1)*(5-2)*(5-3)*(4-5)      ] }

Efectivamente
f(1)=   { 1 * [      (1-2)*(1-3)*(1-4)*(1-5)]/[      (1-2)*(1-3)*(1-4)*(1-5)] }
      + { 2 * [(1-1)*      (1-3)*(1-4)*(1-5)]/[(2-1)*      (2-3)*(2-4)*(2-5)] }
      + { 3 * [(1-1)*(1-2)*      (1-4)*(1-5)]/[(3-1)*(3-2)*      (3-4)*(3-5)] }
      + { 4 * [(1-1)*(1-2)*(1-3)*      (1-5)]/[(4-1)*(4-2)*(4-3)*      (4-5)] }
      + {220* [(1-1)*(1-2)*(1-3)*(1-5)      ]/[(5-1)*(5-2)*(5-3)*(4-5)      ] }
calculando
f(1)=   { 1 * [          24                 ]/[             24              ] }
      + { 2 * [ 0                           ]/[            -6               ] }
      + { 3 * [ 0                           ]/[             4               ] }
      + { 4 * [ 0                           ]/[            -6               ] }
      + {220* [ 0                           ]/[             24              ] }
O sea, f(1)=1*24/24 + 0 + 0 + 0 + 0 = 1

Igualmente f(2)=2 , f(3)=3, f(4)=4, y
f(5)=   { 1 * [ 0                           ]/[             24              ] }
      + { 2 * [ 0                           ]/[            -6               ] }
      + { 3 * [ 0                           ]/[             4               ] }
      + { 4 * [ 0                           ]/[            -6               ] }
      + {220* [  219 *  218 *  217 *  216   ]/[  219 *  218 *  217 *  216   ] }


O sea, f(5)=0+0+0+0+ 220 = 220

Como queriamos demostrar.

Es posible que la gente a la que se lo cuentes no puedan entenderlo.
Bueno, las matematicas son sencillas cuando se tienen los conceptos claros.
Aqui no hay mas que 4 operaciones: sumas, restas, multiplicaciones
y divisiones.

Esta funcion es una curva algo asi:


220|          /
   |         |
   |         |
   |         |
   |         |
   |         |
   |        /
   |        |
   |        |
   |        |
   |        |
  4|       /
   |      /
  3|     /
   |    /
  2|   /
   |  /
  1| /
   |/
   +-+-+-+-+-+-------
     1 2 3 4 5


Otro ejemplo mas sencillo.
Si un crio de 2 anios bebe 0 litros de cerveza al mes, y un anciano
de 99 anios bebe 0 litros de cerveza, ?Cuantos bebe un chico
de 23 anios?
La solution, por supuesto, es 220
Simplemente porque la grafica de consumo de cerveza verifica que
f(1)=0
f(99)=0
f(20)=220
La funcion que cumple esto es:
f(x)= 0.0
     +0.0   * (        (x-23.0)*(x-99.0))/(           (1.0-23.0)* (1.0-99.0) )
     +220.0 * ((x-1.0)*         (x-99.0))/((23.0-1.0)*            (23.0-99.0))
     +0.0   * ((x-1.0)*(x-23.0)         )/((99.0-1.0)*(99.0-23.0)            )


Claro que esto dice que un chaval de 4 anios bebe 37.5 litros, pero
las matematicas no mienten... a menos que se les obligue.

Para finalizar doy un programa que dice la funcion que pasa por
unos puntos (x,y)
Cambia los parametros y sorprende a tus amigos !
Conviertete en el centro de atraccion de las fiestas !
Una diversion sana y barata !

*/
/* Este programa averigua una funcion que es capaz de interpolar
   unos valores. Sirve para demostrar que el siguiente numero
   en la secuencia
   10, 20, 30, 40, 50, ???
   debe ser 220
   Si quieres, modifica los valores y[1], y[2], y[3], ....
   Luego compila el programa y ejecutalo por primera vez.
   Escribira en pantalla una funcion       float f(x) ....
   Pega esas lineas otra vez en el codigo; compila y
   ejecuta de nuevo, y fijate en las ultimas lineas.
   Verificaran que esta funcion cumple los requisitos, y
   ademas mostrara otros valores
*/

#include <stdio.h>
#include <string.h>

#define N 6+1

/*  pega entre esta linea */
/*  --------------------- */
float f(float x) 
 { 
 float f; 
 
 f=0
+ 10.00 * (          (x-2.00)*(x-3.00)*(x-4.00)*(x-5.00)*(x-6.00) )/(          (1.00-2.00)*(1.00-3.00)*(1.00-4.00)*(1.00-5.00)*(1.00-6.00) ) 
+ 20.00 * ( (x-1.00)*         (x-3.00)*(x-4.00)*(x-5.00)*(x-6.00) )/( (2.00-1.00)*         (2.00-3.00)*(2.00-4.00)*(2.00-5.00)*(2.00-6.00) ) 
+ 30.00 * ( (x-1.00)*(x-2.00)*         (x-4.00)*(x-5.00)*(x-6.00) )/( (3.00-1.00)*(3.00-2.00)*         (3.00-4.00)*(3.00-5.00)*(3.00-6.00) ) 
+ 40.00 * ( (x-1.00)*(x-2.00)*(x-3.00)*         (x-5.00)*(x-6.00) )/( (4.00-1.00)*(4.00-2.00)*(4.00-3.00)*         (4.00-5.00)*(4.00-6.00) ) 
+ 50.00 * ( (x-1.00)*(x-2.00)*(x-3.00)*(x-4.00)*         (x-6.00) )/( (5.00-1.00)*(5.00-2.00)*(5.00-3.00)*(5.00-4.00)*         (5.00-6.00) ) 
+ 220.00 * ( (x-1.00)*(x-2.00)*(x-3.00)*(x-4.00)*(x-5.00)          )/( (6.00-1.00)*(6.00-2.00)*(6.00-3.00)*(6.00-4.00)*(6.00-5.00)          ) 
; 
 return f; 
}
/*  --------------------- */
/* y esta linea */

main(int argc, char *argv[])
{
int i=1, j=1, t;
float x[N], y[N];

for(i=0;i<N;i++)
	x[i]=0.0;
for(i=0;i<N;i++)
	y[i]=0.0;

x[1]=1.0;  y[1]=10.0;
x[2]=2.0;  y[2]=20.0;
x[3]=3.0;  y[3]=30.0;
x[4]=4.0;  y[4]=40.0;
x[5]=5.0;  y[5]=50.0;
x[6]=6.0;  y[6]=220.0;

printf("Copia estas lineas en el codigo ; compila, y ejecuta \n");
printf("para verificar que esta funcion interpola tus valores.\n");
printf("-----------------------\n");
printf("float f(float x) \n { \n float f; \n \n f=0\n");

for(i=1;i<N;i++)
	{
	printf("+ %3.2f * ", y[i]);
	printf("( ");
	for(j=1;j<N;j++)
		{
		if(i!=j)
			printf("(x-%3.2f)",x[j]);
		else
			printf("         ");
		if(j!=N-1 && i!=j && i+j!=N*N-2)
			printf("*");
		}
	printf(" )");
	printf("/");
	printf("( ");
	for(j=1;j<N;j++)
		{
		if(i!=j)
			printf("(%3.2f-%3.2f)",x[i], x[j]);
		else
			printf("         ");
		if(j!=N-1 && i!=j && i+j!=N*N-2)
			printf("*");
		}
	printf(" ) ");
	printf("\n");
	}
printf("; \n return f; \n}\n");
printf("-----------------------\n");
printf("Estos valores solo son correctos la segunda vez \n");
printf("que ejecutas el programa\n");

for(i=1;i<N;i++)
	{
	printf(" f(%3.2f)=%3.2f \n", x[i], f(x[i]));
	}
printf("Otros valores:\n");
printf(" f(0)  =%8.2f \n",   f(0));
printf(" f(%3.2f)  =%8.2f \n", (float)(N),  f((float)(N)));
printf(" f(1.5)=%8.2f \n",   f(1.5));
printf(" f(100.0)=%8.2f \n", f(100.0));
printf(" f(999.9)=%8.2f \n", f(999));

return 1;


*EOF*