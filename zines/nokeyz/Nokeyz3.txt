שרשרשרשרשרשרשרשרשרשרשרשרשרשרשרשרשרשרשרששרשרשרשרשרשרשרשרשרשרשרשרשרשרשרשרשרשרשר
|@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@| 
|@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@   @@@@@@@@@@@@@@@ @@@@@@@@@@@@|
|@@@     @@@@@   @@@@@@@@@@@@@@@@@@@@@@@@@@@@   @@@@@@@@@@@ @@@@@@@@@@@@@@@@|
|@@@      @@@@   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@   @@@@@@   @@@@         @@@@|
|@@@   @   @@@   @@@@@@@@@@@@@@@@@@@@@@@  @  @@  @@  @@ @@  @@     @@   @@@@|
|@@@   @@   @@   @@@@@@@@@@@@@@@@@@@@@@   @    @    @   @  @       @@@  @@@@|
|@@@   @@@   @   @@@@@@@@@@@@@@@@@@@                               @@@@ @@@@|
|@@@   @@@@      @@@@@@@@@@    @@@@@@@@                            @@@  @@@@|
|@@@   @@@@@     @@@@@@@@   @@   @@@@@@@@@@@@@@  @@@@@@@@   @@@    @@   @@@@|
|@@@@@@@@@@@@@@@@@@@@@@@@  @@@@  @@@@@@@@@@@   @@@@@@@@@@@   @@         @@@@|
|@@@@@@@@@@@@@@@@@@@@@@@@  @@@@  @@@@@@@@@   @@@@@@@@@@@@@@   @@@@@@@@@@@@@@|
|@@@@@@@@@@@@@@@@@@@@@@@@   @@   @@@@@@@   @@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@|
|@@@@@@@@@@@@@@@@@@@@@@@@@@    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@|
|@@@   @@@@  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@         @@@@@@@@@@@@@@|
|@@@   @@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@|
|@@@   @  @@@@@@@@@@@@@@@@@@@@@@@@@@@@  @@@@@@  @@@@@@@@@@@@ @@@@@@@@@@@@@@@|
|@@@     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@  @@@@  @@@@@@@@@@@@ @@@@@@@@@@@@@@@@|
|@@@   @  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@  @@  @@@@@@@@@@@@  @@@@@@@@@@@@@@@@|
|@@@   @@  @@@@@@@@@        @@@@@@@@@@@@@    @@@@@@@@@@@@  @@@@@@@@@@@@@@@@@|
|@@@   @@@  @@@@@@@@  @@@@@@@@@@@@@@@@@@@@  @@@@@@@@@@@@  @@@@@@@@@@@@@@@@@@|
|@@@   @@@@  @@@@@@@  @@@@@@@@@@@@@@@@@@@@  @@@@@@@@@@@  @@@@@@@@@@@@@@@@@@@|
|@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@  @@@@@@@@@@       @@@@@@@@@@@@@@@|
|@@@@@@@@@@@@@@@@@@@  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@|
|@@@@@@@@@@@@@@@@@@@  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@|
|@@@@@@@@@@@@@@@@@@@       @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@|
|@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@|
|@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@|
|@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@|
שרשרשרשרשרשרשרשרשרשרשרשרשרשרשרשרשרשרשרששרשרשרשרשרשרשרשרשרשרשרשרשרשרשרשרשרשרשר



                       Editor de este numero: Reaven
                       
			     Co-Editor: Corsario-X

			     Home Page:
                             http://www.nokeyz.net
                       
			     Email:
                             ezine@nokeyz.net
                       
			     Canal:
                             #nokeyz
                       
			     Server:
                             irc.terra.cl port 7000
                       
			     Horarios:
                             - Lunes a Jueves: Horario kontinuado
                             - Viernes a Sabado: Hasta las 0:30 hrs 
                             - Domingos y Festivos: Cerrado :(
                       
                             Colaboradores:
                             Narkerbyt - Gin_suK-als 
                       
			     Saludos:
                             Proyecto_R - 350cc(FYE) - OWN3D
                       
			     Fuck off!!:
                              ZoKRaM (cut & paste??) - #hack_
                       
			     Detenido Desaparecido:
                              Cyber (eskribe konchetumare!! :)
                       
                             Linkz:
                              - http://www.zine-store.com.ar - Zine-Store
                              - http://www.350cc.com - Grupo 350cc
                              - http://www.cdlr.org - Proyecto_R
                              - http://www.350cc.com/0wn3d - #0WN3D 
                              - http://www.bugnet.com - Bugnet                                     

_.-ת:=:ת-._.-ת:=:ת-._.-ת:=:ת-._.-ת:=:ת-._.-ת:=:ת-._.-ת:=:ת-._.-ת:=:ת-._.-ת:=:ת
_.-ת:=:ת-._.-ת:=:ת-._.-ת:                                _.-ת:=:ת-._.-ת:=:ת-._
_.-ת:=:ת-._.-ת:=:ת-._.-ת:         --=={STAFF}==--        _.-ת:=:ת-._.-ת:=:ת-._
_.-ת:=:ת-._.-ת:=:ת-._.-ת:                                _.-ת:=:ת-._.-ת:=:ת-._
_.-ת:=:ת-._.-ת:=:ת-._.-ת:          -={sdriLiO}=-         _.-ת:=:ת-._.-ת:=:ת-._
_.-ת:=:ת-._.-ת:=:ת-._.-ת:           -={Cyber}=-          _.-ת:=:ת-._.-ת:=:ת-._
_.-ת:=:ת-._.-ת:=:ת-._.-ת:          -={Nashugga}=-        _.-ת:=:ת-._.-ת:=:ת-._
_.-ת:=:ת-._.-ת:=:ת-._.-ת:           -={Reaven}=-         _.-ת:=:ת-._.-ת:=:ת-._
_.-ת:=:ת-._.-ת:=:ת-._.-ת:          -={Corsario-X}=-      _.-ת:=:ת-._.-ת:=:ת-._
_.-ת:=:ת-._.-ת:=:ת-._.-ת:           -={b||os}=-          _.-ת:=:ת-._.-ת:=:ת-._
_.-ת:=:ת-._.-ת:=:ת-._.-ת:          -={Risc_6000}=-       _.-ת:=:ת-._.-ת:=:ת-._
_.-ת:=:ת-._.-ת:=:ת-._.-ת:_.-ת:=:ת-._.-ת:=:ת-._.-ת:_.-ת:=:ת-._.-ת:=:ת-._.-ת:_.-

-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_
DISCLAIMER: La informacion aqui expuesta tiene el unico fin de_-_-_-_-_-_-_-_- 
mantener al tanto al lector de todo lo relacionado con temas under_-_-_-_-_-_-
No insitamos de ninguna manera a poner en practica dichos articulos-_-_-_-_-_-
ya que muchos de ellos pueden ser penados por la ley...y/o otras autoridades_-
Todo lo que puedas hacer o deshacer con esta informacion es enteramente-_-_-_-
tu responsabilidad. De no aceptar este trato por favor no nos leas :)-_-_-_-_-
_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-



  //\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\/\
  \\                                                                      //
  //                                Indice                                \\
  \\                               ========                               //
  //            Tema                                         POR          \\
  \\                                                                      //
  // |- Editorial                                          Reaven         \\
  \\ ||- Redes                                             Corsario-X     //
  // |||- Shell... ke wea es? tipos, etc                   Reaven         \\
  \\ |V- LinModem                                          Narkerbyt      //
  // V- Sistemas Operativos                                sdriLiO        \\
  \\ V|- Conexion a Inet con linux + la conf. del modem    Gin_suK-als    //
  // V||- FireWalls                                        Risc_6000      \\
  \\ V|||- Scripting                                       b||os          //
  // |X- Virus Troyanos                                    sdriLiO        \\
  \\ X- Instalacion y configuracion del kernel             Risc_6000      //
  // X|- Despedida                                         NoKeyZ         \\
  \\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\/\//


                             |  -={Editorial}=-


        Estrenamos dominio(eso pensamos),nuevos integrantes,algunos cambios en
el team, nuevos proyectos  y todo con el unico fin de hacer un buen e*zine, un
e*zine de calidad, para  contribuir de  mejor manera al under nacional. Los  2 
numeros  anteriores  no  estuvieron 100%  trabajados, este  numero tratamos de
construirlo  lo  mejor posible  y siguiendo  paso  a  paso las recomendaciones
que  nos  hicieron llegar, es  asi como se lanza a la gran telara₪a la tercera
entrega  de  este  magazine  electronico  totalmente reconstituido. Sobre  los
colaboracion de articulos... esta mal, han  llegado  solo dos articulos, bueno
desde el punto de que somos un e-zine no muy conocido no esta nada mal... pero
bueno  que  se le  va  a  hacer po, escribir!! ahaha  ya  cabros se pusieron a
escribir  y  cuando  terminen   mandan  sus   textos   mandenlos   al  e-mail:
ezine@nokeyz.net.

        En IRC se corrio un rumor que decia que NoKeyZ habia muerto,debe haber
sido  en  el  tiempo en  que nadie del team se metia al canal, por razones que
nadie  conoce :) ahaha yo  en  lo  personal, taba  arreglando  mi  tarro... el
ventilador   cago   y  cuando  partia  sonaba  como  motor  de  auto  viejo...

        Por  otro  lado damos la  bienvenida a los nuevos integrantes del team
sdriLiO y Risc_6000, vamos bien lokos!!.

        Tenemos un proyecto que pensamos sacarlo (si se dan las cosas) para el
cambio de milenio, por eso  lo  mas  probable  es  que los proximos numeros no
salgan  con  la misma constancia de los que han salido los anteriores, vamos a
estar algo ocupados, no desesperen. Sobre  el  proyecto no podemos contar nada
aun, porque todavia no es seguro y como  no  nos  gusta  decir  las  cosas por
decirlas, sin basarnos en algo concreto.. no decimos na po! queate con la duda
=P.

Ya me aburri de escribir tanta wea junta, so let's go!!!

                                                                  Reaven 
=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=


                              ||  -={Redes}=-


        Hola amigos, nos encontramos de nuevo ya que en la segunda  entrega de
la E-zine no estuve presente, pero ahora vuelvo a estarlo.

        Bueno, he querido hablar sobre algo que ha ido creciendo mucho a nivel
de  empresas  e  incluso a nivel de hogar, gente en particular que tiene dos o
mas computadores  en  su  casa, en  fin, en  este  articulo  tocare el tema de
"redes" en general.

        Comenzare definiendo lo que es una red. Ok, una  red  es un sistema de
comunicaciones   entre   varios   computadores  conectados  entre  si, o  sea,
compartiendo su informacion usando  para  esto varios elementos  como  lo  son
cables  los  cuales  hay  de distintos tipos, placas que tambien hay muchas, y
ademas un conjunto de programas que de ahi forman el sistema operativo en red.

	Hay dos grandes "divisiones" o "formas" de redes, estas son:
 
- "redes basadas en un servidor": comparte su informacion  (el  servidor)  con
las otras maquinas mas pequenas llamadas estaciones de trabajo  y  estas  usan
los recursos propios y del servidor. Este servidor puede  ser  dedicado  y  no
dedicado. La diferencia entre estos dos es que el servidor no  dedicado  puede
funcionar, ademas de servidor, como una estacion de trabajo.


- "redes entre pares": cualquier estacion puede ofrecer el compartir recursos,
pero   no   todas   lo   hacen. Las  que   comparten   recursos    se   llaman 
"servidor/cliente" y las  estaciones  que  no  comparten  recursos  se  llaman
"clientes".

        A  todo  esto  hay  que resaltar las caracteristicas de cada red, y la
mayoria de las redes empresariales son a base de servidores dedicados en redes
basadas en un servidor, como fue nombrado antes. Ok algunas caracteristicas de
su preferencia son, que por ejemplo, un servidor dedicado tiene mas  capacidad
que una maquina servidor/cliente. Cuando una estacion  de redes  pares  ofrece
recursos ocupa mas memoria que cuando no y ademas de ser la maquina principal,
ocupa  mas  recursos  propios  y puede suceder que les falte hosting despues o
simplemente  que algunas aplicaciones carguen con demora. Las redes que tienen
corriendo sistemas operativos distintos se basan en servidores dedicados.

        Algunas  caracteristicas  de la redes entre pares es que, por ejemplo,
pueden  compartir  la  impresora  en una sola oficina abaratando asi costos. O
pueden  compartir el sistema operativo, etc. En todo caso al haber redes entre
pares  y  si  es  que  llegase  a  crecer  este  sistema  de   redes   despues
necesariamente se va a requerir de un servidor principal.

	Aunque las podemos deducir facilmente, veamos  las  ventajas  de  usar
redes :)

- Facilitamos el uso del correo electronico.
- Si nos comunicamos con otras redes, mejor aun.
- Facilitamos el respaldo de datos.
- Se comparten perifericos de elevado costo  como  impresoras  lasers, a veces
plotters, unidades de respaldo (zip, jazz, copiadoras, etc.).
- A algunos novatos en informatica se les  pueden  ejecutar  las  aplicaciones
desde otra maquina y asi aprenden rapido.

	Y las desventajas :/

- Si se cae un sistema caga todo el sistema que esta en red
- Si llega a entrar un virus en una maquina, cagan las demas facilmente ya que
se comparte informacion rapidamente en el sistema de redes.
- Si  algun  tipo  por casualidad  caga  algo  (en  el  caso donde se comparte
sistema)  todo  lo  demas  caga  junto  con  el  equipo  donde se las mando el 
compadre, aunque esto depende de si se puede corregir facil o dificilmente.


        Veamos la topologia de las  redes  LAN (red de area local generalmente
usada en casa o en  instituciones  como  universidades o algunas empresas). La
topologia  de  las redes las define el hardware y hay tres topologias basicas.

*DATO: aunque la palabra topologia  va ligada a las matematicas, en particular 
a la geometria, en el tema de redes en informatica se usa como la "forma de la
red".

1) ESTRELLA

        En  esta topologia hay un centro llamado "hub" hacia el cual van todas
las  lineas  de comunicacion, y cada maquina tiene un enlace distinto hacia el
hub  (o  puede ser igual eso depende de como se quiera la red). En las lans el
hub  es  el  que  permite  que  las maquinas esten comunicadas unas con otras.
Veamos un esquema de esta topologia.


                               ESTACION DE TRABAJO
                                        |
                                        |                                                                     |
        ESTACION DE TRABAJO------------HUB-----------------SERVIDOR
                                        |
                                        |                                  
                               ESTACION DE TRABAJO



2) BUS

        En esta topologia hay un solo cable  que  recorre  todos  los  caminos
hacia todas las estaciones de  trabajo  y el  servidor; este  cable  no  tiene
ninguna interrupcion ni caminos cerrados ni na de na que lo moleste. Se  deben
conectar  dos  finalizadores  de  cableado  en  el  inicio y fin del cable que
conecta todo. Veamos el esquema:

  ESTACION DE TRABAJO  /  ESTACION DE TRABAJO / ESTACION DE TRABAJO
	     |			     |			   |
	     | 			     | 			   |
	     |			     |			   |
	     |			     |			   |
inicio--------------------------------------------------------------fin
         |              |            |              |
         |              |            |              |
         |              |            |              |
         |              |            |              |
      ESTACION      ESTACION      ESTACION      SERVIDOR


3) ANILLO

        En esta topologia las lineas de  comunicacion  forman  camino  cerrado
denominado  anillo. La  informacion  enviada por una maquina recorre el anillo
en forma  unidireccional, o sea, una  maquina  recibe  la  informacion  de  la
anterior y si no es para ella la manda a la siguiente. Veamos el esquema:





         ESTACION DE TRABAJO               ESTACION DE TRABAJO                                                         |
                  |                                 |
              ____|_________________________________|___
             |                                          |                                                      |
             |                                          |
             |                                          |
  ESTACION---|                 ANILLO                   |            
             |                                          |----SERVIDOR
             |                                          |
             |                                          |
             |__________ _______________________________|
                        |
                   ESTACION DE TABAJO


        Esas son las tres topologias usadas en redes LAN.


        Ok, despues de ver estas topologias de redes, vamos  a  lo  que  es el
hardware y protocolos.


	ETHERNET:

        Es la tecnologia  mas usada en lo que es soporte fisico de LAN, aunque
tambien hay otros  y mejores, pero la gracia de esta es que el costo es barato
y logra un buen balance en lo que es  velocidad, y tambien la  instalacion  es
facil. Algo que favorece mucho al  uso  de  Ehternet  es  que  puede  aceptar,
virtualmente, todos los protocolos de redes.

        El estandar Ehernet ("version") fue dado por  una  serie de ingenieros
electricos y electronicos norteamericanos, y quedo a  final  como  IEEE 802.3.
Este define las reglas que hay para configurar una Ethernet y especifica  como
trabajan entre si los componentes de una red Ethernet. Asi tambien  se  define
que se le puede adherir al estandar IEEE par a que  interactue  bien  y mejor.

	FAST ETHERNET:

        Asi como Ethernet es una red simple, obviamente hay necesidad de tener
algo mejor en algunos casos, y para esto fue establecido el Fast Ethernet, que
como su nombre lo dice, es una ETHERNET RAPIDA. Este estandar puede transmitir
desde 10 Mb/seg. (mbps) y pudiendo hasta 100 mb/seg si se le  aplican  algunos
cambios a los cableados.

	Hay tres tipos de Fast Ethernet:

- 100BASE-FX: para el uso de cables de fibra optica.
- 100BASE-TX: para el uso de cables de par trenzado sin malla (UTP) nivel 5.
- 100BASE-T4: usa un par de hilos extras para utilizar cableado UTP  existente
pero nivel 3.

        En este momento ya se estan creando  Ethernets  de  transmision en GB,
pero  falta todavia.                                                                   

Ok, vamos a lo que es PROTOCOLOS:

        Un protocolo  es  el  estandar  que permite comunicarse a las redes, o
sea, es la compatibilizacion entre una red y otra.

        Los protocolos definen varias cosas, por ejemplo: como se  identifican
las maquinas entre si en una red o la forma que deben tomar los datos para ser
transmitidos o tambien el procesamiento de informacion, etc.

	Algunos protocolos de redes son: 

IPX: para Novell.

DECnet: para las maquinas de Digital Equipment corp.

TCP/IP: ya saben, Unix, Linux, Windows 95, NT, etc.

AppleTalk: Macintosh.

NetBIOS/NetBEUI: para redes LAN Manager y Win 95.

        No importa que sean distintos los  protocolos  de  redes, porque igual
pueden usar un mismo cableado. Esto es bueno porque en  sistemas  distintos se
pueden usar un medio comun para todos. Esto es conocido como "independencia de
protocolos".

	CABLEADO:

	Al tener el Ethernet o Fast Ethernet no lo tenemos todo, sino que  falta
otra parte importante que es el cableado. Hoy se usan estos  cuatro  tipos  de
cableado:

-Cable coaxial grueso: para redes 10BASE5
-Cable coaxial fino: para redes 10BASE2
-Trenzados: para redes 10BASE-T
-Fibra optica: para redes 10BASE-FL

	Niveles:

        Denante  nombre  las Ethernet y puse que eran para cableado X nivel X,
bueno ahora voy a explicar que pasa con estos niveles:

Nivel 5: es el mas caro pero  el  mejor, se  usa  en  Fast  Ethernet  y  puede 
transmitir hasta una velocidad de 100 Mb/seg.

Nivel 4 y 3: Menos costosos pero mas lentos, aunque igual buenos. El  nivel 4
puede llegar a velocidades de 20 mb/seg. y el 3 hasta 14 mb/seg.

        Bueno, aqui pongo fin a mi articulo, pero no del todo ya que hare dos
articulos mas  sobre  este  mismo  tema  en  la  numero  4 y 5  de  la Nokeyz 
respectivamente, cualquier  cosa  que  quieras  que  salga  explicada en esos
articulos  y  que  no este aqui comunicamela al e-mail corsario-x@nokeyz.net. 
Hasta la proxima =).
=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=


                         ||| -={Shell???}=-

Holap!, como tan???  ahaha pa que pregunto eso si no me importa como estan XD.
En  este numerito  me  toco  escribir  sobre  las shell pero a si que TRATE de
escribir  sobre  las  shell, aunque  me  salio  cualquier wea... no! ahaha, el
articulo se dividira en varias secciones para que sea mas  comodos para todos,
tambien  lo  escribi sin muchos modismos para que la gente de ajuera nos lea y
nos entienda :) aunque derrepente se me sale uno que otro.

Intro
-----
La  shell  es  el  programa  mas  importante para la mayoria de los usuarios y
administradores  de  Unix. Si  el  lenguaje  de  comandos  de   Unix, lee  los
caracteres escritos por los usuarios, los interpreta y los ejecuta.

La  diferencia  con  otros  interpretes en otros S.O., aqui existe un completo
lenguaje de programacion .

Una  vez  que  un  usuario  se  registra al sistema con su login y su pass, el
sistema le cede el control a la shell, la que  casi siempre ejecuta 2 ficheros
de      configuracion,  el    gral. (/etc/profile)     y     el     particular 
(<DirectorioUsuario>/.profile). Una vez aqui, la  shell  muestra  el "inductor
de comandos", que seria mas o menos asi:
$
¢
#

Tipos y Propiedades
-------------------
Hay varios tipos de shell, cada uno con distintas propiedades:

- Bourne shell (/bin/sh): Es la  mas  antigua, y  por   esto  mismito  la  mas
confiable   y   compatible   entre   plataformas. En  esta  se basan las shell
que explicare.

- Korn shell (/bin/ksh): Es mas moderna, toma los  comandos  de la bourne y le
anade varios mas como  varias  caracteristicas  de  reedicion  interactiva  de
comandos, control  de  trabajos  y  mejor  rendimiento  en  velocidad  que  la
anterior. Existen  2  versiones, la   primera se  llama "maldita"  y la actual
(no tanto), de  16/11/1988 (puedes  averiguar  que  version  tienes ejecutando
el comando "what /bin/ksh"). Esta  wea no  es tan  la raja porque cuando tenis
que hacer weas complikadas la ksh  falla, la  de  bourne  es  como  mas  bakan
en  este sentido.

- C Shell
           

Metacaracteres
--------------

Cuando escribes cualquier comando y pulsai Enter, es la shell  no  UNIX la que
interpreta lo que estay escribiendo y ordenando que  se  ejecute  el  comando.
Aparte  de  los  caracteres  normales, la shell interpreta otros caracteres de
modo  especial: un  grupo  de  caracteres  se  utiliza para generar nombres de
ficheros sin la necesidad de escribirlos aparte.

Cuando  la  shell  esta interpretando un nombre, los caracteres * ? [] se usan
para  crear  patrones. El  nombre  que  tenga  alguno  de  estos caracteres es
cambiado  por  una  lista de ficheros del directorio actual y que su nombre se
adapta al patron que se creo.

Las reglas de creacion de patrones son:

*    Vale cualquier cadena de caracteres
?    Vale un caracter cualquiera
[..] Vale cualquiera de los caracteres que coincida con los que esten entre
     los corchetes

Ej: Supongamos que en el directorio que estas tiene los siguientes archivos

$ ls
weon
weona
aweonao
aweona
Veamos las salidas que corresponden a las reglas anteriores:

$ ls * (valen todos)
weon
weona
aweonao
aweona
$ ls *a (todos pero tienen que terminar en "a")
weona
aweona
$ ls aweon? (que empiecen con aweon y terminen con cualquier letra)
aweonao
aweona
$ ls aweon[oa] (que empiecen con aweon y ke despues venga "o" o "a")
aweona
aweonao

Concepto de comando/proceso
----------------------------

Para  comprender  la  manera  en  que  la shell ejecuta  los comandos, hay que
tener en cuenta las siguientes cosas:

- Despues  de  salir  en  pantalla el indicador $, espera que se le introduzca
algo... (8===3), sera   interpretado  y  ejecutado   en  el momento de apretar
Enter

- La shell evalua lo que hemos escrito buscando primero si tiene  un  caracter
"/" al principio. Si  lo  tiene, lo  toma  como  programa y lo ejecuta, si no,
examina si se  trata  de una  funcion (o  un  alias, en el caso de la ksh). Si
no encuentra ninguna con  ese  nombre, busca  a  ver si se trata de un comando
interno  (exit, exec, trap, etc)  o   palabra  reservada  (case, do, done, if,
for... etc), para ejecutarlo o  pedir mas entrada. Si no es ninguna  de  estas
condiciones, la  shell  piensa  que  lo que esta escrito es  un  comando, y lo
busca  dentro  de los directorios contenidos en  la  variable de entorno PATH.
Si  no esta, saca  un mensaje que  dice  algo  komo: "XXXX : not found", donde
XXXX es lo que hemos escrito.

 Ej:

  $ Hola
  Suponiendo  que  la  variable PATH contenga los directorios /bin, /usr/bin y
  /etc, la  shell  busca  el  comando "/bin/hola", "/usr/bin/hola" y "etc/hola".
  Ya que es como obvio  que  no existe, la respuesta sera sh: hola: not found.

Variable de Entorno
-------------------
Una variable de entorno en  la  shell es una  referencia  de  un  valor. Hay 2
tipos: las locales y las globales.

Local:  Se define en  la  shell actual y se conocera solo durante la sesion de
conexion vigente.

Global: Se exporta desde un proceso activo a todos los procesos hijos.

- Para crear una variable local:
  #cosa="Juan Perez"

- Para hacerla global:
  #export cosa

Una variable  se  inicia  con  la  expresion <variable>=<valor>. Es importante
que el signo igual "=" vaya sin espacios.

Una variable  se  referencia escribiendo  antes  el  signo  de  la  plata "$".
Utilizando  el  comando "echo", que imprime por la salida  estandar  el  valor
que se le indique, veamos el contenido de alguna de estas variables:

# echo $TERM
vt220

Un error que se puede mandar un weon cuando trabaja con variables es:

# $TERM=vt220

La  shell  interpreta que le queremos poner algo asi komo "vt220=vt220", y eso
esta  malo. Para  borrar  una  variable, tienes  que ocupar el comando "unset"
junto con el nombre de la variable que quieras quitar, ej:
                                               
# echo $cosa (saca el valor de la variable)
Juan Perez (el que le dimos antes)
# unset cosa (borra la variable)
#echo $cosa
# (ya no tiene ninguna wea)

Cuidado  con  borrar  variables  empleadas por programas nativos de UNIX, como
TERM,  si  borras   esta   variable, el  editor  "VI"  (el  de  linux) deja de
funcionar  automaticamente. Otro   problema   que  es  posible  que  pase  es:
supongamos una variable que se llame COSA y otra que se llame COSAS. La shell,
en el  momento  de  evaluar  la  expresion "$COSAS", se  encuentra  ante las 2
siguientes opciones:

- Evaluar $COSA y pegar su contenido a la "S" (<contenido de COSA + "S")
- Evaluar $COSAS, ocupando la intuicion.

Las  2  evaluaciones  por parte  de la shell estarian buenas, pero dependiendo
de  lo que nosotros queramos hacer puede producir  efectos  que no se quieren.
Te recomiendo  usar los parentesis llave "{}" para  encerrar  la variable  que
queremos  expandir. De  tal forma, para reflejar "COSA" tendriai que  escribir
esto:

${COSA}
Y para reflejar "COSAS"
${COSAS}

Con  esto  tienes  la  seguridad  de  que  las  variables  siempre   son  bien
interpretadas. Las llaves se utilizan SIEMPRE en e l momento  de   evaluar  la
variable, no de asignarle valores. No tiene sentido hacer cosas como:

{COSAS}

Algunas variables usadas por el sistema o por programas son:

HOME:    Directorio personal. Usado por el comando "cd", se  cambia  cuando se
         llama sin argumentos.

LOGNAME: Nombre del usuario con el que se comenzo la sesion.

PATH:    Lista de rutas de acceso, separadas  por  2  puntos ":" y  donde  una
         entrada  con un solo punto "." indentifica el directorio  actual. Son
         validas las asignaciones como:

         #PATH=$PATH/home/reaven:/home/nokeyz

PS1:     Simbolo  principal   del   indicador   de  "preparado"  del  sistema.
         Generalmente, su valor sera "#" o "$".

TERM:    Tipo de terminal.

Podemos ver como se inicializan las  variables consultando  los   ficheros  de
inicializacion. Esos ficheros son:

/etc/profile: Fichero  de  inicializacion  global, esto  significa que despues
de  hacer  login  todos los usuarios pasan atraves del mismo, inicia variables
como PATH, TERM.

<directorio usuario>/.profile: Fichero particular, esta en el "home directory"
del usuario. Es  particular  para  cada  uno  de  los usuarios y es aqui donde
podemos configurar cosas como que les salga un menu al  entrar, mostrarles  el
correo, etc.

Sustitucion de comando: que hacen las comillas en la shell
--------------------------------------------------------------

Dependiendo de cuales sean las comillas usadas, los resultados son:

- Carakter backslash \:Quita  el  significado  especial del caracter que viene
                       despues del backslash (\).                
                     
- Comillas simples `' :Quitan el significado especial de todos los  caracteres
                       encerrados entre comillas simples.

- Comillas dobles " " :Quitan el significado especial de todos los  caracteres
                       excepto  los  sgtes. :  $  (plata),  \  (backslash)   y `
                       (comilla de ejecucion).

- Comillas de: `'     :Ejecuta  el  comando  encerrad o entre  las  comillas y
  ejecucion            reemplazan su valor por la salida estandar del  comando
                       que se va ejecutado. 

 - Para sacar un aviso en pantalla que contenga comillas, debemos "escaparlas"
   porque si no, la shell la interpretaria:

# echo "Apreta "Enter" para seguir" (Eso esta malo, porque la shell ve
                                     4 komillas y no las sacaria).

# echo "Apreta\"Enter\" para seguir" (Ahora esta bien)

- Lo mismo pero en comillas simples:

# echo `Apreta "Enter" para seguir'

- Una forma mejor pero con comillas dobles

#echo "Oe,$LOGNAME apreta \"Enter\" para seguir"
y se veria asi:

Oye, root apreta Enter para seguir

- Comillas de ejecucion

#echo "Estas en el terminal: `tty`"

Estas en el terminal /dev/tty002

Programacion con shell.scripts.
-------------------------------

La  shell  aparte  de  interpretar  y  ejecutar  comandos, tiene primitivas de
control  de  programas  como  por ejemplo  sentencias condicionales y bucles.

- Variables

Dentro de una shell, existen variables de entorno, puede ser en  la  misma, en
otra o en ficheros profile de inicializacion. Ademas  de  estas, existen otras
que detallare:

$0    : Nombre de la shell-script que tamos ejecutando
$#    : Numero de parametros que han pasado a la shell
$1, $2: Primer y segundo parametro posicional
$*    : Un  argumento  que  contiene  todos  los  parametros que se han pasado
        ($1, $2...)
        menos el $0
$?    : Numero donde se almacena el codigo de error del ultimo comando  que se
        ha ejecutado
$$    : Numero de proceso actual (PID)
$!    : Ultimo numero de proceso ejecutado.
#     :Comentario: Todo lo que se encuentra a la derecha del  gato (#) se toma
       como comentario.

Ej: Supongamos que escribimos la sgte. shell-script llamada "prueba.sh"

echo "El script se llama $0"
echo "Me han llamado con $# argumentos"
echo "El primero es $1"
echo "Y todos los parametros son $*"
echo "Chao Reaven"

Y la podemos ejecutar de 2 maneras:

1) Directamente

# sh prueba.sh uno dos

2) Dando permisos y ejecutando como un comando:

# chmod 777 prueba.sh
# prueba.sh uno dos

Lo que se ve:

Me han llamado con 2 argumentos
El primero es uno
Y todos los parametros son uno dos
Chao Reaven

Como hemos visto los comandos se separan por lineas y  se  van  ejecutando  de
forma  secuencial, pero  podemos  poner  varios  comandos  en la misma linea y
separlos por punto y coma (;). Ademas podemos  agrupar  comandos  a  traves de
parentesis: # (date;who) | wc -l

- Comando read

Con el fin  de  de  permitir  una  ejecucion  interactiva, existe  el  comando
"read<nombre_variable>", este  comando al  momento  de  ejecucion  espera  una
entrada de datos por teclado en <INTRO>, lo que hay introducido por el teclado
va a la variable especificada.

Supongamos la sgte. shell-script:

echo "Como te llamas"
read nom
echo "Hola $nom"
Ejecucion:

Como te llamas?
Reaven (aqui escribes "Reaven" y pulsas Enter)
Hola Reaven
el comando read, cargo "Reaven" en "nom"

- if..fi:

if <condicion>
then
.....comandos.....
else
....comandos.....
fi
("else" puede eliminarse, solo se usara cuando  sea  necesario). La  condicion
puede  escribirse como "test" <argumentos> o con corchetes, para los corchetes
se tiene  que  poner  espacios  entres  los  corchetes y los valores. Posibles
condiciones y sintaxis:

if[<variable>=<valor>]: variable es igual a valor
if[variable>!=<valor>]: variable es distinta a valor
if[<variable>-eq<valor>]: variable es igual a valor. la variable tiene que
tener numeros, en este caso se pueden usar las siguientes:

-eq: Igual (equal)
-ne: Distinto (not equal)
-ge: Mayor o igual (greater or iqual).
-le: Menor o igual (less or iqual)
-lt: Menor que (less than)
-gt: Mayor que (greater than)
if[ -f<fichero>]: Existe <fichero> 
if[ -d<fichero>]: Existe <fichero> y es un directorio
if[ -s<fichero>]: Existe <fichero> y tiene tama₪o mayor de cero
if[ -x<fichero>]: Existe <fichero> y es ejecutable.
(Hay mas, pero con eso ta bien)
En el campo <condicion> se pueden escribir comandos, los  que  se ejecutaran y
el valor de la condicion dependera de 2 factores:
* Retorno 0 del comando=verdadero
* Retorno !=0 del comando=falso
Ejemplo de lo ultimo:
if grep reaven /etc/passwd
the # retorno del comando "grep" ha sido cero
echo "Reaven esta registrado como usuario"
else # retorno el comando grep no ha sido cero
echo "Reaven no esta registrado como un usuario"
fi

- Secuencia condicional case..esac
Sintaxis:
case <variable> in
<valor>) <comando> (la variable es = valor, ejecuta los comandos hasta
`;;')
<comando>
;;
<valor>) <comando>
<comando>
;;
* ) <comando> (Clausula "otherwise" o "default": Si no se cumple alguna
<comando> de las anteriores ejecuta los comandos `;;')
;;
esac (Igual que if acaba fi, case acaba en esac)

Ejemplos: minimenu.sh

clear # borra pantalla
echo "1.- Quien ta weando?" # pintar opciones
echo "2.- Cuanto disco keda ?"
echo "3.- Nada. Salir. "
echo "Cual quieres ? : \c # el caracter "\c" evita  que  el  echo  salte nueva
                                             linea
read opcion # "opcion" vale lo que se ha tecleado en la pantalla
case "$opcion" in # IMPORTANTE : Poner la variable como "$opcion"
1) who;; # porque si el tipo pulsa Enter daria error al no valer nada
2) df;;
3) echo "Adios";;
*) echo "Opcion $opcion Es Incorrecta";;
esac

- FOR

Sintaxis:
for <variable> in <lista>
do
<...comandos...>
done
El  bloque  entre  "for"  y "done" da tantas vueltas como elementos existan en
<lista>, tomando como la variable  cada  uno  de los elementos de <lista> para
cada  vuelta. En  esto  conviene  no  confundirlo kon lod for..next existentes
en   los  lenguajes  de  tipo  agol (pascal, basic)   que  varian  contadores.
Supongamos un programa que kontenga un bucle for de la siguiente manera:
for j in perico palotes
do
echo "Variable = $j"
done
Y la salida que produce es:

Variable es perico
Variable es palotes

Explicacion: El bloque hizo 2 vueltas, para la  primera, la  variable -j- toma
el valor del primer elemento (perico), y  para  la  segunda  (palotes). En  el
campo <lista> podemos cambiar la lista por patrones de ficheros para la shell,
la  cual  expande  dichos  patrones  por los ficheros correspondientes, de tal
forma queckuando escribas
for j in *
la shell cambia el "*" por todos los ficheros del directorio actual, por esto,
el siguiente programa:
for j in *
do
echo $j
done
equivale al comando "ls" sin opciones, tambien se  puede  poner  en  el  campo
<lista>  comillas  de  ejecucion  junto  con cualquier comando, la estructura:
for j in "cat /etc/passw" ,por ejemplo, ejecutaria tantas vueltas  como lineas
tuviese ese fichero, y para cada vuelta, la variable "j" tendria cada una de
las lineas del mismo, son validas las siguientes expresiones:
for j in "who" para procesar todos los usuarios activos en el sistema,
for j in "lpstat -o" para procesar todos los listados pendientes, o
for j in "ps-e" para tratar todos los procesos de nuestra sesion.

Ya eso seria tdoo por este numero, pal proximo  escribire  algo  sobre: Bucles
WHILE, Operadores And / Or, Cron.

Chuchas, quejas, errores que cometi, copuchas, cualkier wea a:
reaven@nokeyz.net
Saludos a: PlaXiuS  gracias  por tu apoyo loko, OWN3D the h4x0r zone wena onda
           kauros, 350cc Team, #informatica, y a los que se me  quedan  en  el
           olvido.
=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=

                             |V -={LinModem}=-


Holas, decidi  escribir  este  articulo  al  ver  la  cantidad de personas que
querian saber como conectarse  con el sistema operativo linux  con un winmodem
(yo tambien me incluyo entre esas personas). Bueno antes que empieces  a  leer
este articulo te aviso que este dirigido  para  los  winmodems  con  chips  de
pctel, como  los hsp micromodem 56 que los fabrica la empresa pctel, ya que no
he  instalado drivers para otro tipo de winmodem, pero seguramente los pasos a
seguir  son  los  mismos, aunque siempre es bueno leerse el archivo README que
viene  incluido  en  todos  los  paquetes  de  drivers  para  saber  sobre  su
instalacion.

[Reaven: yo  lo  probe  con  mi  Cirrus Logic CL-MD5620DT y no me funciono, al
hacer el make me mandaba un error  diciendo  que  configurara  bien el  modem.
Despues de cabezearme 4 hrs, decidi comprarme un modem :)]

Bueno  se  preguntaran  porque  #@#!!##sumare no sirven los winmodems, esto es
porque los winmodems no son mas que un simple chip que viene con  un  software
ECHO especialmente para el "sistema operativo" windows. Los  reales modems son
un conjunto de hardware que permite trabajar con cualquier  sistema  operativo
ya que el modem es  el  que  realmente  marca, pero  los  winmodems  la  parte
faltante del  hardware  lo reemplaza con el software o driver que generalmente
viene en un diskette que como  ya  dije  generalmente se hacen para el sistema
operativo windows. Y porque hacen  esto, los  fabricantes  de  winmodems? pues
porque  un  diskete  sale  mucho  mas  barato  que comprar la parte entera del
hardware, entonces hacen la mitad del hardware y la otra mitad la rellenan con
software echo para windows y no para el sistema linux. Bueno  ya  que cada vez
es mayor la demanda del sistema operativo Linux cada vez  se  hace  mas  facil
encontrar drivers para winmodems echos para Linux... o sea vendrian a llamarse
"linmodems". Despues de anos de busqueda (XD) en la red  he  encontrado  estos
winmodems  en  los  cuales  se  han  fabricado  driver s para  Linux  con  sus
respectivas direcciones para bajarlos.
------------------------------------------------------------------------------
Lucent LT Winmodem, PCI   (Modulo binario del kernel)  
http://www.linmodems.org/linx565a.zip
------------------------------------------------------------------------------
Lucent LT Winmodem, PCI or ISA PnP  (Modulo binario del kernel) 
http://www.linmodems.org/linux568.zip
------------------------------------------------------------------------------
Lucent LT Winmodem, PCI   (modulo binario del kernel) 
http://www.definitesoftware.com/LucentPCI-1.1-1.i386.rpm
------------------------------------------------------------------------------
Lucent LT Winmodem, PCI  (fuentes GPL) 
http://www.close.u-net.com/ltmodem.html
------------------------------------------------------------------------------
Cirrus Logic CL-MD5620DT, PCI (fuentes GPL) 
http://linmodems.org/CLModem-0.1.0.tar.gz
------------------------------------------------------------------------------
PCTel Micromodem, AMR (Modulo binario del kernel 2.2.x )  
http://www.o2.net/~gromitkc/pctel/MODEM.zip
------------------------------------------------------------------------------
PCTel Micromodem, PCI (Modulo binario del kernel 2.2.x) 
http://perso.wanadoo.fr/eric.santonacci/pctel/pctel.zip
------------------------------------------------------------------------------
PCTel Micromodem, AMR, PCI (Modulo binario del kernel 2.2.x) 
http://www.o2.net/~gromitkc/pctel/hsp56-linux-1.tar.gz
------------------------------------------------------------------------------
PCTel Micromodem, Zoltrix Phantom (Modulo binario del kernel 2.2.x)
http://www.zoltrix-int.com/PUBLIC/MODEM/linux/hsp56-linux.zip
------------------------------------------------------------------------------

Bueno pasemos a la  parte  interesante... resulta  que  cuando me  pasaron  el 
driver para mi winmodem "hsp micromodem 56" venia comprimido en un tgz. Lo que
debia hacer era ejecutar make  clean  y  despues  make  pero  resulta  que  al
ejecutar varias veces make ya que veia que no me instalaba el  driver  vi  que 
make  clean  te  borrar el pctel.o, o sea el driver y despues al ejecutar make
este  te  lo  pedia. Asi  que simplemente no lo compile. (este problema por lo
menos venia en mi paquete, lo digo por si  alguien  se  baja  el  mismo). Pero
bueno al bajarse el paquete o solo el driver que tendria  que  ser  algo  como
"nombre.o" hacen lo siguiente:
Primero nos tenemos que averiguar en que puerto esta tu  modem, para  esto  te
vas a windows, te vas a "panel de  control" , te  metes  a  "modems"  y  luego
pones "diagnostico", ahi veras el puerto en el que esta  tu  modem. Si es com1
en Linux seria ttyS0, si es com2 ttyS1
com1: ttyS0
com2: ttyS1
com3: ttyS2
com4: ttyS3
com5: ttyS4
etc etc etc...

Entonces te vas a Linux nuevamente y en la  consola  ejecutas  los  siguientes 
comandos:
(Hare referencia a mi puerto del modem ttyS4 (com5) si el tuyo  esta  en  otro 
puerto cambias el ttyS4 por tu puerto) antes de hacer esto es preferible que
borres el archivo /dev/modem.
------------------------------------------------------------------------------
mknod /dev/ttyS4  c  62  79         --->> con esto creamos un nodo
chgrp uucp  /dev/ttyS4              --->> aqui cambiamos los permisos del
				          grupo
chmod 666  /dev/ttyS4               --->> cambiamos el permiso de archivo
ln -s  /dev/ttyS4  /dev/modem       --->> y creamos un link a /dev/modem
------------------------------------------------------------------------------
Si no te funca trata de borrar tambien el archivo /dev/ttyS4.

        Ok... si  esto  no  te ha dado ningun error entonces copias el driver,
que  en  mi caso es pctel.o al directorio /lib/modules/tukernel/net despues de
esto  ejecutas  la  orden "insmod -f pctel"  (sin comillas)  y  cada  vez  que
reinicies el pc tendras que ejecutar esa orden en modo  root (insmod -f pctel)
para activar el driver y asi poder conectarte. Bueno, una  vez  echo  esto, se
supone que tienes que ya haber activado el modem. Para conectarte  a  Internet
prueba con la herramienta "conexion a internet" del KDE. (herramienta  probada
en redhat 6.1) y tendras lista tu conexion a internet. Bueno eso es todo... un
saludo a #0wn3d #informatica Fye y Nokeyz e INx-X. ;-)        

BY NARKERBYT
irc.terra.cl 
#informatica


Mas informacion en www.linmodems.org
=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=


                             V -={Sistemas Operativos}=-

Introduccion .-

Holas, para empezar quisiera hacerles una pregunta:
-Que sistemas  Operativos  conocen?-,  sin  lugar  a  dudas  la  respuesta  de
muchos de ustedes (no de todos) seria; Windows y Linux.

Es por eso que decidi escribir un poco mas sobre  estos  programas  que  hacen
que  la  maravilla  de las computadoras funcione.  Sin ellos no seriamos nada,
bueno  el  computador  no  seria nada, pero ya nosotros nos concideramos parte
de el, por eso la expresion anterior.

Como   dije   anteriormente   los   sistemas   operativos   mas  utilizados  y
conocidos  son  Windows  y Linux, que por otra  parte no tienen nada de malo y
ambos estan bastante bien.


Descripcion .-

Un  sistema  operativo, como  su nombre  lo dice, es un sistema computacional,
pero  mas  que  eso, es  un software  obligatorio/basico,  esto  por   razones
obvias,  que  todo computador  debe poseer.  Este  cumple varias  labores  muy
importantes   para   el  desarrollo  de nuestas PC's,  coordina y  manipula el
hardware,  la  memoria,  las  unidades  de salida (monitor, impresoras, etc.),
las  unidades   de   entrada  (diskettes,  teclado,  etc.), organiza  nuestros
archivos  en  diversos  dispositivos de almacenamiento (disco duro, diskettes,
CD-ROM, etc), y  tambien  gestiona  los errores  de hardware  y  la perdida de
datos.

El  sistema  operativo   es  en  si   un conjunto de  programas  que  permiten
administrar  y  optimizar los  recursos del sistema,   son  los  anteriormente
mencionados).

Un  sistema  operativo es  en  un  principio el soporte logico que controla el
funcionamiento  del  equipo  fisico o hardware haciendo que el trabajo  con la
computadora  sea sencillo.  Desde este  punto  de  vista se  podria  decir  lo
siguiente;  un sistema  operativo  es  un conjunto  de  programas  y funciones 
que  controlan  el  funcionamiento   del   hardware  ocultando  sus  detalles, 
ofreciendo  al  usuario   una   via   sencilla  y   flexible  de  acceso  a la
computadora.

   
Funcionamiento .-
   
El  funcionamiento general de todos los  sistemas  operativos, es  basicamente
y  escencialmente  la  comunicacion  usuario/computador  y  vice versa.   Para
esto,  los  programas  que  el  sistema  operativo  incorpora,  y  ademas  los
dispositivos de E/S son escencialemnte para cumplir estas funciones.


Actualidad .-

En  la  actualidad,  existen   varios   sistemas   operativos,  cada   sistema
operativo  tiene   caracteristicas   que   los  hace  diferente unos de otros.

A  continuacion   se  descriviran   algunos  de  los  sistemas operativos  mas
utilizados en la actualidad.


((1)( ::: Windows :::))

Sin  lugar  a  dudas  este  es  e l sistema  operativo  mas  usado   por   los
usuarios de todo el mundo,  desarrollado por el  mounstro  de los softwares de
aplicacion,   Microsoft   Corporation,  Windows  es   un   sistema   operativo
multitarea  pero  NO  es  multiusuario.  Tiene  un entorno grafico muy  comodo
y facil de usar, este  se  ejecuta  en  computadores  con MS-DOS.

Este   sistema   operativo, proporciona   una   interfaz    estandar    basada
en  menus  desplegables,  ventanas   en  pantalla  y  un dipositivo  se₪alador
como lo  es el mouse  o  raton,  los programas  de  este  sistema   operativo,
deben   estar   especialmente  dise₪ados y desarrollados para aprovehar  estas
caracteristicas.

La  instalacion de este  sistema operativo es  sumamente facil  y  aprueba  de
tontos,  un resumen  de  su  instalacion  es mas o menos algo asi:  Siguiente,
Siguiente,   Siguiente,   Siguiente,  Omitir, Siguiente, Siguiente, Siguiente,
Reiniciar. Listo.

((2)( ::: Unix    :::))
	
Ok,  UNIX,  este es un s.o multiusuario  y  multitarea.  Fue  creado  por  Ken
Thompson y Dennis  Ritchie en  los  laboratorios  de AT&T Bell en el  a₪o 1969
(ayayai),  fue desarrollado para  ser usado  en  microcomputadoras.  Este S.O,
tiene   diversas   variantes  y  se  considera  potente, mas  transportable  e
independiente de equipos concretos que otros sistemas operativos  porque  esta
escrito en lenguaje C.
       
El UNIX esta disponible en varias formas, entre las  que  se  cuenta AIX,  una
version  de UNIX adaptada  por  IBM  (para  su  uso en estaciones  de  trabajo
basadas  en RISC), A/UX (version grafica para   equipos   Apple  Macintosh)  y
Mach (un sistema operativo reescrito, pero esencialmente  compatible con  UNIX
para   las computadoras NeXT).

((2)( ::: OS/2    :::))

El  OS/2, acronimo  de  "Sistema  Operativo  de Segunda    generacion", es  un
sistema   operativo    multitarea    para    computadores    personales    con
microprocesadores de la gama x86 de Intel. El OS/2 puede ejecutar aplicaciones
para  Windows  y MS-DOS y leer discos de MS-DOS.

La   idea  de  OS/2  surgio entre las compa₪ias IBM y Microsoft a mediados  de
los a₪os 80,  fue originalmente programado para hacer un intento de sucesor de
MS-DOS,  el cual  ya  empezaba  a  acusar  el  paso  del  tiempo  y  resultaba
claramente   desaprovechador  de  los  recursos  de  las  m quinas de la epoca
(basadas en el Intel 286).

OS/2 1.0  salio en abril de 1987 y era un sistema operativo de  16 bits,  pues
estaba  pensado  para  trabajar  sobre  el  microprocesador  286. Sin embargo,
aprovechaba plenamente el modo protegido de este computador,   haciendo uso de
sus capacidades para  proteccion  de  memoria,  gestion  de  multitarea,  etc.
El resultado fue un sistema operativo estable, rapido y muy potente.

((5)( ::: Linux  :::))

Bueno, para empezar  a  saber  un poco mas de este grandioso sistema operativo
quisiera hacer un poco de  historira  sobre  el  mismo.

Mas o  menos por Agosto de 1991, un estudiante findaldes envio  un  mensaje al
grupo de noticias comp.os.minix que empezaba asi:

" Hola a todos los que usan minix: -
    
Estoy   haciendo   un   (gratuito)  sistema operativo, (solo por  aficion  sin
pretender  ser  tan grande y profesional como gnu) para clonicos AT 386(486)."
   
Este  estudiante  era  Linus  Torvalds,  y la "aficion"   de  la  que  hablaba
con el tiempo se ha convertido en lo que ahora conocemos como Linux.

Linux,  un  completo sistema operativo conforme a  Posix, ha sido desarrollado
no  solo  por  Linus Torvalds, si no que por cientos de programadores de todo
el mundo. Lo mas interesante al  respecto  es  que  este  masivo  esfuerzo  de
desarrollo  mundial  esta  en  gran  parte descoordinado. Por  supuesto, Linus
lleva las  riendas con respecto al nucleo,  pero  Linux es mucho  mas  que  el
mero nucleo. No  hay  una  infraestructura  de  direccion;  un  estudiante  en
Rusia adquiere una nueva placa base,  y escribe  un controlador que implementa
una fantastica  caracteristica de  esa  placa. Un  administrador  de  sistemas
en  Maryland  necesita un software para hacer copias de seguridad, lo escribe,
y  lo  cede  a  cualquiera  que   pueda   necesitarlo. Las   cosas  necesarias
simplemente parecen ocurrir en el momento oportuno.
 
Otra  cosa  interesante  es  que  Linux  se puede conseguir sin pagar un peso.
Ciertamente, la mayoria del  software  esta  disponible   (sin  cargo  alguno)
para cualquiera con el tiempo y la dedicacion necesaria  para  copiarlo. Claro
que no todo el mundo dispone de tanto tiempo....


((6)( ::: Lista  :::)) (anadida por Reaven)

AIX
BeOS
BSDI
Digital Unix
DGUX
FreeBSD
HPUX
IRIX
Linux(RedHat,Slackware,SuSe,Mandrake,Corel,Winlinux,Caldera Open Linux,Debian)
Mac OS
Open VMS
RS6000
SCO
Sequent PTS
SGI IRIX
Solaris x86
Sparc/Solaris
Sparc/SunOS
Ultrix
VMS/VAX

NOTA: Por supuesto  los  anteriores, no son los unicos sistemas operativos que
existen en el mercado. Solo puse los  mas conocidos aunque se que me faltaron,
pero es nada. ;)

Despedida .-

Bueno  amigos,  esto es todo con respecto a lo que  sistemas   operativos   se
refiere, espero que te haya servido para  tomar  el  conocimiento de los estos
para   que  algun  dia te sea  util, recuerda   que  no  es  Windows  el unico
sistema opertivo con el cual tu PC puede trabajar. Ahora me  despido  y  hasta
la proxima.
=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=



      V| -={Conexion a Inet con linux incluyendo la conf del modem}=-

Hola  amigos  como  estan  todos  en  este  articulo  se tratara el tema "como
conectarse  con  linux  a internet=inet" desde la conf del modem y la conexion
misma

Primero  que todo  partiremos  con el modem tenemos que comprobar si funca con
linux bueno si es que es isa lo mas probable(99,999%) que  funque  pero si  no
sabes  si  es que  isa metet a www.linmodem.org y ve si tu  modem  funca  bajo
linux.
        Una vez chequeado esto bamos a  configurarlo  (esta  configuracion  es
para modem que NO funquen con jumpers )bueno ahora lo que tenemos que hacer es
un  link  entre  el  modem  y nuestro pc para hacer esto en una shell pones lo
siguiente
ln -sf /dev/ttySx /dev/modem ----> en donde ttyS es el  puerto  x  se  refiere
al  numero  si  es que tu modem esta en el com2 seria en este caso ttyS1 en el
com 3 ttyS2 y haci sucesivamente despues de hacer este link comprobamos que el
modem funque osea  este  todo  en  buen  estado  para  esto  desde  una  shell
ejecutamos el comando dip
$dip -t 
open port /dev/modem
dip> 
si es que te muestra esto esta todo bien bien ahora vamos  hacer  la  conexion
a inet                                                             

CONEXION A INET
Bueno  esta  conexion  la  vamos  hacer con el netconfig que viene con algunas
distribuciones de linux (ESTA MANERA DE  HACER  LA  CONEXION  ESTA  COMPROBADA
A MI POR LO MENOS ME FUNCO Y ME FUNCA).
Lo primero que tenemos que hacer es abrir el netconfig  es  el  icono  de  una
red que hay en el "control panel" lo habrimos ahora  detallaremos  los  pasos:
0.1 
te va aparecer un cuadrito que tiene varias opciones haces clik en  interfases
y pones:
add
0.2
va  aparecer  otro  cuadro ahi tienes que porner el n§ de  usuario  tu  passwd
y el n§ de telefono .despues tienes que hacer click  en  pap  authentification
esto te va a servir para al momento de conectarte te  conecte  automatico  sin
meter login ni passswd.
0.3
en el mismo cuadro pones customize y te va aparecer otro  cuadro  en  el  cual
van aparecer hartas opciones hay tienes que tener tiquiad use  hareergrerdware
flow  control  and  modem  lines  abort all conection on well -known errors  y
ssi es que quieres  que  cualquierea  quiera  activar  la  conexion  pones  un
click en  any  user  to  de  activate  interfaces. Ahora si  miras  abajo  van
aparecer  dos  espacios  ven  lo  cuales  tienes  que dejarlos tal cual, en el
primero sale la velocidad de modem y en el segundo sale el  puerto  ahi  tiene
que aparecer /dev/modem si es que isiste lo indicado
en este doc.
0.4
ahora  haces  click  en  networking y dejas tal cual como esta pero si quieres
que la conexion cuando falle no vuelva a marcar desctiques  restart  ppp  when
connection fails ahora cierras el cuadro y pones  save 0.5 ahora  tenemos  que
configurar al archivo /etc/resolv.conf en donde tenemos que poner el proveedor
su direccion  en inet y su dns, aca dare el ejemplo con terra:
----------------------
search terra.cl
nameserver 206.34.141.1
nameserver 206.34.141.2
-------------------------------
pa conectarnos puedes usar tu comando preferido como pppd  etc  pero  dare  un
ejemplo con el ipup para conectaarnos desde una shell  pones  /sbin/ifup  ppp0
y desconectarnos /sbin/ifdown ppp0

Bueno  eso  es  todo pero te recomiendo que te leas los siguieentes documentos
referidos    al    mismo    tema    (para    que     te     culturices    mas)
www2.netexplora.com/Linux/modem.html y un documento que hizo crackx en la
pr n§ 7 referido a lo mismo

quejas comentarioss etc a cgc@antisocial.com con el tema modem

Shutdown:
quiero  felicitar  a  esta  e-zine  ya  que  esta  muy buena y se nota que sus
integrantes se han esforzado por su construccion.

[Team:­Muchas gracias! Asi es, nos hemos esforzado harto :]

GRANDE CABROS SIGAN ASI
DERECHOS DE COPIA :
PUEDES REDISTRIBUIR ESTE DOCUMENTO SI NI UN PROBLEMA SI QUERIA DI QUE ES
TUYO NOSE LO QUE QUERAI PERO ESPERO QUE SIEMPRE LE DES UN USO PRACTICO Y
UNTIL PARA LOS QUE QUIEREN APRENDER

                                                                 Gin_suK-als
=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=


                            V|| -={FireWalls}=-                              

 Esta  es  una  pequenisima  introduccion  a los Firewalls, estos dispositivos
que a mas de alguien ha llamado  la  atencion  y  por  cierto  no  con  buenas
intenciones... Basicamente aqui se dara una descripcion cortisima  de  que  es
y como actua un Firewall en una Red. Al final hay un Glosario si no se acuerda
de algun concepto o no lo tiene muy claro. Bueno no mas introduccion  y  vamos
a lo que nos interesa.

Un  Firewall  o  Cortafuegos  es  un  Software  o  Hardware  o  la combinacion
de ambos que tiene por funcion el filtrar los paquetes  que  circulan  por  la
red, tanto interna como externa de la LAN a la cual  sirve. Este  Firewall  se
monta en un servidor o se conecta a el (depende cual sea el caso, SW, HW) pero
lo que interesa es que los equipos conectados a el  poseen  una  direccion  IP
especifica que los  identifica, para  que  un  Firewall  realmente  cumpla  su
funcion, esta debera tener otra direccion  IP, con  la  cual  pueda  realmente
filtrar los paquetes de la red.

  Veamos el siguiente esquema:
                      _________________________
                     |                         |
                     |                         |
                     |           WAN           |
                     |                         |
                     |                         |
                      -------------------------
                                 |
                                 |
                                 |
                            ____________
                           |  Servidor  |
               L A N       |    con     |
                           |  FIREWALL  |
                           | 100.2.3.2  |
                            ------------
                             |   |   |
                             |   |   |
           ------------------    |    ---------------------
          |                      |                         |
     ------------           ------------              ------------
    |  Cliente   |         |  Cliente   |            |  Cliente   |
    |            |         |            |            |            |
    |  1.2.3.1   |         |  1.2.3.2   |            |  1.2.3.3   |
    |            |         |            |            |            |
     ------------           ------------              ------------

Aqui hay un Firewall filtrando una peque₪a  lan  de  3  clientes  (notese  las
direcciones IP asignadas a cada uno de ellos)

Entonces podemos decir que un firewall:

1.- Organiza la red, es decir, toda la red esta sujeta a este, y la  red  solo
podra acceder a los parametros que el Firewall tenga permitido.

        Por ejemplo, si un terminal de la red intenta enviar un paquete a  una
        direccion   IP   no  autorizada,  el  Firewall  rechazara  este  envio
        impidiendo realizar esta transmision.

2.- Con el Firewall podemos  definir  tama₪o s de  paquetes  estableciendo  un
tama₪o maximo para el paquete saliente o entrante, muy  util  en  el  caso  de
proteccion contra MailBombers o un intento por  interrupir  el  funcionamiento
de la red con el proceso de un paquete gigante.

3.- IP con las que no interesa comunicacion, basicamente se puede generar  una
tabla con las IPs que estan autorizadas y analogamente  con  las  Ips  que  no
estan autorizadas, en unix las tablas ACCEPT y DENY  son  las  encargadas   de
almacenar esta informacion.

4.- Deshabilitacion de envios o recogida de paquetes por determinados puertos,
en la mayoria de los casos un puerto accede a  una  aplicacion  en  particular
corriendo en el servidor o el cliente, pero maliciosamente se puede tratar  de
acceder a un puerto tratando de encontrar una  Backdoor, el  firewall  en  ese
caso debe controlar estos accesos identificando el origen de  la  peticion  si
esta  no  esta  dentro  de  los  autorizados, entonces  debera  rechazar  esta
solicitud  de entrada, por  ejemplo en Windows NT se puede utilizar la funcion
de identificacion que posee.
   

5.- Imposibilitar el uso del comando Finger, de el usuario de la red LAN o  un
usuario externo quiere saber quienes estan conectados en la La red  Interna  o
Externa, depende del caso, el firewall debe denegar el uso del comando  finger
para mantener la privacidad de la informacion de la red, en algunos  casos  el
finger se utiliza como desbordaminto, es decir se  hacen  cusecivos  Finger  a
una maquina para disminuir el rendimiento de esta, al  tener  desabilitado  el
Finger, el sistema no retornara informacion y el desbordamiento  no  ocurriria
puesto que ya no se tarasmite la informaciond de la red si  no  que  un  corto
mensaje de rechazo.

6.-Adicionalmente  se  puede  utilizar programas de manejo de informacion para
establecer un control estadistico de los sitios, paquetes, tiempo  de  uso  de
la red, identificacion de personas usando que y cuando, etc. Estos  pueden ser
costruidos como una aplicacion almacenando  la  informacion  en  una  base  de
datos relacional o un banco de datos con el fin de  gestionar  el  uso  de  la
red, esto es muy eficiente para la determinacion  de  centros  de costos de el
recurso internet para una empresa.

Ahora bien si el firewall rechaza lo que entiende como no habilitado y  filtra 
los paquetes de datos como es el acceso a la red Interna y externa  ¨Que  pasa 
con los usuarios, estos se verian afectados por el uso de un Firewall?

Si el Firewall no valida nuestra IP no podremos conectarnos con la LAN, aunque
como la IP podemos falsificarla hoy en dia se implementan  tambien  Servidores
Proxys,  ante  los  cuales  deberemos  identificarnos  antes, protegiendo  asi
tambien al Firewall.

Para el usuario la LAN es transparente, es decir, si desde cualquier  estacion 
enviamos un paquete a una IP y el Firewall nos valida el tama#o, IP de destino, 
puerto, etc (Estos parametros varian segun las necesidades de  seguridad  cada 
red, y por tanto del nivel de configuracion del Firewall), nosotros no veremos 
ningun inconveniente en aser esta transaccion , seria como si no hubiera  nada
vigilando por nuestra seguridad, aunque si lo hay.

Lo mismo ocurre para los usuarios conectados en el exterior si el firewall los
valida estos ingresaran sus paquetes de datos sin ningun problema.

Veamos algunas caractiristicas de los Firewalls.

a.- Los Firewalls son complejos, ya  no  en  si  mismos, sino  en  definicion,
basicamente un firewall consta de la misma forma de funcionamiento, lo  que si
se vuelve complejo es como el administrador o el Ingeniero de sistemas  define
los funciones de restricciond de los firewalls, en algunos casos se ha  optado
por utilizar un sistema Experto para  la  estructuracion  eficiente  de  estas
configuraciones particulares para cada institucion.

b.- Hoy  en  dia  a un Router que cumpla funciones de Firewall le daremos esta
clasificacion, debido a que cumple  con  los  requerimientos  minimos  que  un
firewall debe tener (Ip independiente, funcion de filtrado de paquetes).

c.- El  concepto  de seguriad aplicado seria: Filtrar antes de repartir, mejor
que multiplicar por x el trabajo de seguridad en una red (punto  extraido  del
seminario de Webmaster y tecnologias de Informacion Espa#a diciembre 1999).

Para  terminar  aqui  hay  y  un  grupo de direcciones interesantes hacerca de
firewalls.

Una direccion de un proveedor de firewalls y proxy  servers  con  demos   para
bajar
http://www.csm.co.at 

El portal de Firewaals
www.firewall.com

Empresa proveedora de firewalls
www.frus.com

Seguridad para windows NT
www.ntguard.com


                              GLOSARIO


Finalmente veamos algunas definiciones Basicas para  recordar  o  si  no  esta 
muy claro alguna cosilla.

Paquete: Cantidad minima de datos  que  se  transmite n en  una  red  o  entre 
dispositivos . Tiene   estructura  y  longitud  variable  segun  el  protocolo
utilizado.

Puerto: Es un numero que identifica a una aplicacion que  interviene  o  va  a 
intervenir en una comunicacion bajo TCP.

Socket: Es la combinacion de la IP de  la  maquina  y  del  numero  de  puerto
utilizado por el TCP.

TCP: Protocolo de Control de Transmision.

NAT: Network Address Translation. Basicamente es un sistema  de  encapsulacion
de IP de terminales de LAN en los paquetes enviados.

RDSI: Red Digital de Servicios Integrados (ISDN).

LAN: Red de Area Local.

WAN: Red de area Extensa, como por ejemplo Internet.

Gateway: Ordenador o Dispositivo que conecta redes  diferentes  en  protocolo.

OSI: Interconexion de Sistemas abiertos. Modelo de referencia de Interconexion
de Sistemas Abiertos propuesto por la ISO. Divide las tareas de la  red  en  7
capas.

Router: Elemento Hardware que trabaja a nivel de red y entre  otras  cosas  se
utiliza para conectar una LAN a  una  WAN. Un  Router  (enrutador)  asigna  el
encabezado del paquete a una ubicacion de una LAN y  elige  la mejor  ruta  de
acceso para el paquete, con lo que optimiza el rendimiento de la red. 

Linea Dedicada: Una linea de alta capacidad (Suele ser una  linea  telefonica) 
dedicada a las conexiones de red. 

MRouter: Router que soporta protocolos MultiCasting.

MultiCasting: Tecnica de transmision de datos a traves de internet, en la  que
se envian paquetes desde un punto a varios simultaneamente. 

Mascara de Subred: Un  parametro   de configuracion  de  TCP/IP  que extrae la
configuracion de red y de host a partir de una direccion IP. Este valor  de 32
bits permite que el destinatario de los paquetes IP distinga, en la  direccion
IP, la parte de Id. de red (nombre de dominio) y el Id. del  host  (Nombre  de
host).

Direccion IP: Una direccion unica que  identifica  a  un  equipo  en  una  red
mediante una direccion de 32 bits que es unica  en  toda  la  red  TCP/IP. Las
direcciones IP se suelen  representar  en  notacion  decimal  con  puntos, que
representan cada octeto (8 bits o 1 byte) de una direccion IP  como  su  valor
decimal y separa cada octeto con un punto; por ejemplo, 100.2.3.4.

Nombre de Dominio: El  nombre  de  equipo que substituye a una direccion IP de
red. Por ejemplo, www.mi_server.com  en  vez  de  la  direccion  IP 100.2.3.4.
Tambien se llama Nombre descriptivo. 

Nombre del Host: El  nombre  dado  a  un  equipo que forma parte de un dominio y
que se utiliza para autenticar a los clientes. Tambiיn se denomina  Nombre  de
equipo.

Protocolo: El software que permite que los equipos se comuniquen  a  traves de
una red. El protocolo de Internet es TCP/IP. 

Firewall: elemento basado en Hardware, Software o en una combinacion de ambos,
que controla el flujo de datos que entra y sale de una red. 

Proxy: Es basicamente un Software equivalente a un Router, que tiene funciones
de identificacion y cache de datos.

Risc_6000                                                risc_6000@nokeyz.net
=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=


                             V||| -={Scripting}=-


hi dude, esta vez, mi trabajo es al IRC, mas especificamente  al mIRC, pronto,
pero no en esta ocacion, hablare del BitchX XDDDDDDDD,  por ahora, metanse los
acentos y  las faltas de otrografia por la raja,  por que a mi no me caben son
muchas

                        ---===CONTENIDOS===---

I.................................................................Introduccion
II....................................Entendiendo la programacion de un Script
III.....................................................Alias, Eventos, Popups
IV.......................................Takeover, Massdeop, Massban, Masskick
V.................................................................Protecciones
VI..................................................................Bot de IRC
VII..............................................................Guerra en IRC
VIII...........................................................Agradecimientos





                        ---===Introduccion===---


Esta bueno  que paremos de lamearnos con  Scripts para mIRC hechos por otros y
empecemos  a  hacer  nuestros propios Scripts  de mIRC,  o  no???,   da paja y
molesta  ver  que usan scripts culiaos,  (no tengo nada contra ellos), por que
pienso,   que para llegar  a  ser alguien,   hay  que tener la  mentalidad  de
construir  sus  propias  Herramientas,  y por lo tanto,  programen sus propios
Scripts,  o  no,  acaso esos que  "Hackean"  usando Herramientas,  no  les  da
verguenza  llegar contando  y preguntando que herramientasc usamos???, por que
no las programan ustedes mismos???.

Este tutorial,   no  pretende  empezar  con  una lista  tremendamente larga de
"Comandos de mIRC" y  que da  una  paja  leersela!!!  yo  me  la  aprendi  por
ustedes, jeje.





         ---===Entendiendo la programacion de un Script===---


Bien,  primero,  hay que entender que para comenzar a  Hacer un Sccript, seria
bueno copiar  el  mirc.exe  a  una nueva carpeta,  pero solo el ejecutable,  a
capela,  y al ejecutarlo,  la  wuea se vera mas fea que la chucha,  pero,  ahi
estara apto parar comenzar a hacer nuestro Script.

La programacion de un Script,  es  muy simple,  les  parece  complicada,  como
cualqier lenguaje  de  programacion,  pero esto,  posee una muy buena guia  de
ayuda,  en la Ayuda del mIRC viene todo, es bueno hechar una pasadita por ahi.
el  mIRC  tiene  distintas  secciones  de  programacion,  que   explicare  mas
adelante, por ahora, solo dire como trabajan en comjunto.  Por orden,  tenemos
los Alias, que nos sirven para muchas cosas,  como por ejemplo,  hacer dibujos
con  caracteres (ASCII)  o  hacer nuestros  propios comandos,  o funciones que
devuelven un valor, pero,  lo mejor de todo  es  que pueden ser llamados desde
los Popus, o menus, estos  son totalmente  moldeables  y  permiten  el  uso de
variables y llaman a los alias, como tambien lo hacen los Remotos,  que sirven
para detectar eventos, como por ejemplo, cuando un usuario entra a un canal, o
te hacen ping, etc. Luwego, las  variables  se  almacenan todas  juntas  y  se
escriben anteponiendole un "%" como por ejemplo, %b||os y para almacenarle  un
valor, se usa el comando SET, esot quedaria asi:

set %b||os valor

donde  valor es  lo  que queremos almacenar en la  variable %b||os. Recuerden,
este tutorial,  nos permitira empezar con esto  de los Scripts,  pero,  no nos
hara competir con otros que tienen mucho tiempo en esto.

Como bien  decia,  hay muchas palabras claves  en  todo esto,  como  cualquier
lenguaje de  programacion,  y  es importante que  sepas utilizar la  ayuda del
mIRC.

Como veras,  todo se  relaciona,  y  si no lo hace,  es bueno que  empiezes  a
programar de esta manera,   ocupando todo lo que el  mIRC te  ofrece,   Alias,
Popups,  Remotos,  etc, todos juntos  hacen potentes Scripts.   el mIRC guarda
tood lo que programas en ficheros  .ini,  que son faciles de  editar fuera del
editor que el mirc trae.

Para trabajar en el Script,  el mIRC te pone unos editores a  toda raja,  para
ver el editor del Alias,  presiona Alt + A y te aparecera el editor del  mIRC,
ahi, explora sus menus  y  borra todo lo que tiene,  se supone que  el Script,
lo vamos  a empezar desde cero.  Es importante destacar  que el menu File,  es
como todos los demas,  onda,  guardar,  nuevo,  cargar,  etc,  el menu view te
muestra  los  archivos que  tienes cargados  con alias en este momento,  y  el
menu alias,  te muestra los comandos  o  alias  que tienes en cada fichero, el
que actualmente te aparece en pantalla.

si presionas  Alt + P  te aparecera  una  ventana en el mismo  editor del mIRC
pero  esta  vez,   muestra  la  ficha  que  contiene  los  popups   del  mIRC.
Interesante  resulta el  menu  VIEW,  que  nos  muestra el  menu  que  estamos
editando que puede ser,  el Estado,  Canal,  Privado/Chat, Lista de Nicks y la
El menu de la Barra.

si presiona Alt + R te aparecen ahora,  los Remotos,  y es interesante el menu
VIEW,  que nos muestra los  ficheros  que tenemos cargados  con remotos en ese
momento.

A medida  que  vamos programando,  necesitaremos  saber  los  valores  de  las
variables como en una ventana Debug, en un lenguaje de programacion, como  aca
no lo hay,   haremos una, primero,   y  la forma mas facil,   es  imprimir  el
contenido  de  una vasiable  en  la ventana Status,  con el siguiente comando,
/echo -s %variable,  esto nos  sera de mucha ayuda,  otra forma,  es hacer una
ventana con el comando:

/window @nombreventana -1 -1 600 200

donde nombreventana es   el   nombre de tu ventana, y -1 -1 nos   muestran  la
ventana centrada en la pantalla del mIRC, y 600 200  son  las  dimensiones  de
nuestra ventana,  para mostrar el  contenido de una variable,   en la ventana,
usaremos el comando:

/aline @nombreventana %variable

un ejemplo del uso de estas ventanas es el siguiente:

/imprstatus {
set %var1 1
:inicio
if %var1 > 10 {goto fin}
echo -s %var1
inc %var1
goto inicio
:fin
}

/imprventana {
clear @ventana
set %var1 1
:inicio
if %var1 > 10 {goto fin}
aline @ventana %var1
inc %var1
goto inicio
:fin
}

y  en los popups,  abres en el editor,  el popus del Status y lo limpias todo,
borralo todo, y pon ahi, esto:

Debug
.Status:/imprstatus
.Ventana:/window @ventana -1 -1 600 200 | /imprventana

Guarda  los cambios  y  saca el menu desde  la ventana Status y hazlo trabajar,
veras que hemos hecho una ventana de debug que  nos sera de mucha ayuda cuando
comencemos a programar muestro Script.





                 ---===Alias, Eventos, Popups===---


Los alias, se editan con el editor del mIRC presionando Alt + A.

Con los alias puedes hacer tus propios comandos, como por ejemplo:

/op /mode # +ooo $$1 $2 $3
/deop /mode # -ooo $$1 $2 $3
/k /kick # $1

como veras,  al llamar al comando  /op,  /deop  o  /k  se produce  lo  que  se
encuentra a la derecha del mismo, esto tambien se puede escribir asi:

/op {
mode # +ooo $$1 $2 $3
}
/deop {
mode # -ooo $$1 $2 $3
}
/k {
kick # $1
}

pero,   esto  nos  sera mas  util  cuando veamos  comandos  mas complejos  que
necesiten estruturas de control y wueas parecidas.


los  Popups  los  podemos  editar presionando  Alt + P,  son los encargados de
editar los menus en el mIRC y su funcionamiento  es  simple,  por ejemplo,  un
popup utilivandolo anterior, ubicado en la lista de nicks, sera:

Control
.Dar OP:/op
.Quitar op:/deop
.Patear:/k

y  eso  se nos muestra primero,  el menu Control,  y en ese, como sub menu, el
menu Dar OP, Quitar op,  y  Patear.  como te habras  dado cuenta,  que hace un
punto  antes  de  "Dar OP",  "Quitar op" y "Patear"???,  simple,  determina la
posicion de menu y sub menu.  mira,  prueba con esto, ponlo en el menu Status:

Hi dude
.hola loko
..hola wuea:/
..hola idiota
...hola lamo:/
.hola
..hola compadre:/

y nota la diferencia de todos con respecto a los puntos.



Eventos

Se  editan presionando Alt + R y su funcion es detectar un determinado evento,
algunos ejemplos de eventos son:

Join.
se produce cuando un usuario entra a un canal
su sintaxis es:
on nivel:JOIN:canal:comandos

op.
se produce cuando un usuario da OP a otro usuario
su sintaxis es:
on nivel:OP:canal:comandos

deop.
se produce cuando un usuario quita OP a otro usuario
su sintaxis es:
on nivel:deop:canal:comandos

text.
Se produce cuando en un canal o Query se escribe un determinado texto
su sintaxis es:
on nivel:TEXT:texto:canal:comandos

Start.
se produce al iniciar el mIRC, al cargarlo
su sintaxis es:
on nivel:START:canal:comandos

Connect.
se produce al conectarse al servidor de IRC
su sintaxis es:
on nivel:CONNECT:canal:comandos

los eventos CTCP seran explicados mas adelante, en la seccion de Bots para IRC

con esto basta para darnos cuenta como funkan los eventos remotos, el primero,
nos  dice,  que cuando un usuario,  de nivel determinado,  o 1 (para todos los
usuarios)

en canal, es necesario diferenciar de:

#nombrecanal :sirve para un canal especifico
#	     :sirve para cualquier canal
?	     :sirve para un Query
*	     :sirve para un canal o un query

Tambien seria poco inteligente utilizar esto:

on 1:JOIN:?:comandos

por que no se produce un evento on join en un Query.

los  numeros raw son otro tipo de eventos que hace el servidor en respuesta de
algo, por ejemplo, analicemos estos numero raw:

raw 401:*: echo -a $2 no esta en IRC | /halt
raw 482:*: echo tu no eres operador del canal
raw 301:*: echo -a $2 esta away!!!

donde el numero que sigue a la palabra "raw" es el numero de evento producido,
para conocer los numeros raw, (que son demasiados) te recomiendo buscarlos en
internet, o hacer algo asi:

raw 1:*: echo -s Raw numero 1 producido
raw 2:*: echo -s Raw numero 2 producido
raw 3:*: echo -s Raw numero 3 producido
raw 4:*: echo -s Raw numero 4 producido
raw 5:*: echo -s Raw numero 5 producido
...
raw 100:*: echo -s Raw numero 100 producido
...
raw 200:*: echo -s Raw numero 200 producido
...
raw 300:*: echo -s Raw numero 300 producido
...etc
...hasta el 1000 mas o menos (conocen Ctrl+c y Ctrl+v???, pues usenlos!!!)
recuerdan echo -s ??? (lean mas arriba)


Usuarios.

como en los eventos antes mencionados se tiene ke indicar le nivel de usuario,
pero ke chucha es eso???, bien, miren esto:

Join.
se produce cuando un usuario entra a un canal
su sintaxis es:
on nivel:JOIN:canal:comandos

lo recuerdan???, yeah!!!, aer, hagamosle algunos cambios

on 1:JOIN:*:/msg $nick Hola loko!!!       #para todo el ke entre, tu tambien
on +10:JOIN:*:/msg $nick Hola compradre   #solo el usuario con nivel 10
on +30:JOIN:*:/msg $nick hi dude          #amigos en especial
on +69:JOIN:*:/msg $nick Hola preciosa!!! #alguna mina por ahi XDDDDDDDDD,
                                          #nota el + que tiene al principio,
                                          #eso es pa que solo a quienes tengan
                                          #nivel de 69 se les envie el mensaje
                                          #y no a otro con nivel menor
on +100:JOIN:*:/msg $nick hi seסor IRCop  #pa algun IRCop

bueno,  pero como determino el nivel para cada usuario,  pues bien, utilizando
el  comando:  /auser  nivel nick,   y  con esto,   podemos  hacer un popups en
nickname list para aסadir niveles:

Niveles
.Aסadir
..10:/auser 10 $1
..30:/auser 30 $1
..69:/auser 69 $1
..100:/auser 100 $1
.Borrar:/ruser $1

Mas informacion de todo esto, podras encontrar en la ayuda del mIRC, usala!!!.





           ---===Takeover, Massdeop, Massban, Masskick===---


Massdeop.

Esto  nos  servira para  quitarle el  OP  a  todo el que lo tenga en el canal.
veamos como funciona.

en alias pon esto:

/massdeop {
set %i 1
:uno
set %nickdeop $nick(#,%i)                  #devuelve nicks desde la lista
if $me !isop $chan { goto end }            #si no eres operador, te hace tapa
if %nickdeop == $me { goto dos }           #si el nick eres tu, lo deja
if ( %nickdeop == $null ) { goto end }     #si ya no hay mas op, finaliza
if ( %nickdeop isop # ) { mode $chan -o %nickdeop } #quita el OP,  si lo tiene
:dos
inc %i
goto uno
:end
}

mas claro aonde, lo que esto hace  es quitarle el OP  a todos los que estan en
tu canal,  menos a ti,  para llamarlo necesitas colocar  un popup en el canal,
copia esto:

Massdeop:/massdeop

que facil no???, bueno sigoentonces con el massban copiando esto en los alias:


/massban {
set %e 1
:uno
set %nickban $nick(#,%e)
if $me !isop $chan { goto end }
if %nickban == $me { goto dos }
if ( %nickban == $null ) { goto end }
mode $chan +b %nickban
:dos
inc %e
goto uno
:end
}

es casi  lo mismo,  solo que al final, en vez de quitar el OP, pone ban a toda
la lista, menos a ti, y en el popups del canal, pon esto otro:

Massban:/massban

y listo,  ahora te pueder ir preparando pa la  guerra en IRC!!!  (a esto no le
llamo guerra)

bueno, finalmente,  para completar un TAKEOVER,  necesitamos  el masskick,  ke
creen???,  es lo mismo, pero esta vez, en vez de quitar el OP y banear,  patea
a todos menos a ti, pero como se ke eres flojo, te pongo el codigo.

/masskick {
set %r 1
:uno
set %nickick $nick(#,%r)
if $me !isop $chan { goto end }
if %nickick == $me { goto dos }
if ( %nickick == $null ) { goto end }
kick $chan %nickick
:dos
inc %r
goto uno
:end
}

clarito???, ahora que!!! en el popup del canal, coloca:

Masskick:/masskick

y nos iris quedando asi:

Massdeop:/massdeop
Massban:/massban
Masskick:/masskick


y listo, ahora vamos por el takeover!!!.

en le popup del canal, coloca:

Guerra
.Massdeop:/massdeop
.Massban:/massban
.Masskick:/masskick
.-
.TAKEOVER:{
massdeop
massban
masskick
}

jajaja,  listo,  ahora a  dejar la caga  en  los  canales.  hmmm.  pero  falta
demasiado!!!!!!!!,  falta  lo mas  importante,  asegurarnos  que  mantendremos
tomado el canal,  para eso,  es  necesario cambiar los  modos del canal,  esto
quedaria asi:

Guerra
.Massdeop:/massdeop
.Massban:/massban
.Masskick:/masskick
.-
.TAKEOVER:{
massdeop
massban
masskick
mode $chan +ipsl 1
}

lo que eso hace "mode $chan +ipsl 1" pone  modos  al canal de  solo invitados,
XDDDD,  privado DXXXX, secreto DXXXXX y  limite de usuarios  a  1, o  sea,  tu
solito!!! XDDDDDDDDDD  sin duda,  ahora se ve mejor, pero, que tal, si despues
de todo esto,  un usuario logra entrar en el canal???,  por que pasa, pero aki
entra una vez mas en ingenio del Scripter...

necesitamos un evento remoto (Alt + R) donde se produce un eventon on  JOIN  y
que lo patee inmediatamente,   jejeje, entendieron???,  bueno,  miren, en  los
remotos aסadan esto:

on 1:JOIN:%canalop:{
if $nick isop %canalop {
 mode -o %canalop
}
mode %canalop -b $nick
kick %canalop $nick
}

despues de aסador esto, si no funciona, es por que ya  tienes mas de un evento
on JOIN en  el  mismo archivo,  abre un nuevo archivo  y  copialo ahi. y en el
popup, modificandolo un poco, quedaria asi:

Guerra
.Massdeop:/massdeop
.Massban:/massban
.Masskick:/masskick
.-
.TAKEOVER:{
massdeop
massban
masskick
mode $chan +ipsl 1
set %canalop $chan
}
.-
.Detener Takeover:{
mode %canalop -ipsl
unset %canalop
}

ok, les quedo claro???,  pues bien, despues de esto, no keda otra ke probarlo,
jeje, a tomarse algun canal no mas...





                             ---===Protecciones===---


En lasa protecciones, las mas adecuadas son:

Antideop
Antiban
Antikick
AntiTkeover.

todo es simple,  primero,  el antideop,  consiste en pedirle OP al chanserv si
tienes access o si eres el funfador del canal.

usa esto en remotos:

on +99:DEOP:#:/msg chanserv op $chan $nick

y aסadete a  la lista de usuarios con nivel 99,  tambien asi puedes protejer a
algunos amigos (/auser 99 nick)

para el Antiban, usamos esto en remotos

on +99:BAN:#:/msg chanserv unban $chan $bnick

el antikick:

on +99:KICK:#:/join $chan

y  el takeover es un poco mas complicado, esot es solo para el que es fundador
de un canal y tiene la contraseסa del mismo.

en popups del Status, ponemos:

Recuperarse:{
set %canal $$?="Canal que quieres recuerar"
msg chanserv identify %canal $$?="Contraseסa del canal"
msg chanserv set %canal mlock -ispkl
msg chanserv clear %canal users        <------saca al ke se tomo tu canal
join %canal
}

listo, que lindo,  y funka,  eso te deja el canal para ti solito. pero hay mas
proteciones, como por eejmplo, las de texto:

on 1:TEXT:*reculiao*:#:/kick $chan $nick
on 1:TEXT:*puto*:#:/kick $chan $nick
on 1:TEXT:*wueon*:#:/kick $chan $nick

entienden la idea???, tambien es util para hacer que un bot interactue, eso lo
veremos mas adelante.   aun hay mas protecciones,  eso lo dejo a ustedes,  con
esto, podran empezar...





                          ---===Bot de IRC===---


un bot es un usuario que nadie controla, fue programado para cuidar canales  y
por lo general, pasa gran cantidad  de tiempo dentro de  los canales,  podemos
hacer  bots  para mIRC  y  sin dude, lo ideal  seria dejarlo  corriendo  en un
servidor NT.  El bot detecta texto  en los  canales como  por ejemplo,  cuando
alguien le dice hola en un privado, el bot detectaria:

on 1:TEXT:*hola*:?:/msg nick Hola, soy un bot, programado por b||os.

y asi, se puede jugar  con el bot.  sin duda,  tambien   resulta   interesante
controlar el  bot desde otro nick,  y  sobre todo, si tu  lo  programaste,  lo
que mas me gusta a mi, es hacerlo mediante eventos CTCP.

primero, haremos un popup destinado solamente  a  controlar el bot, dando OP a
usuarios en un canal a travez de el,  anadiendole usuarios  con  niveles a sus
listas, pateado, baneando, etc.

el menu lo puedes poner en status y seria algo asi:

b||os_Bot
.Control
..Dar op:/ctcp b||os_bot daop $$?="canal" +o $$?="Nick"
..Quitar op:/ctcp b||os_bot dep $$?="canal" -o $$?="Nick"
..Banear:/ctcp b||os_bot ban $$?="canal" +b $$?="Nick"
..kick:/ctcp b||os_bot kick $$?="canal" $$?="Nick"
.Niveles
..add users:/ctcp b||os_bot auser /auser $$?="Nivel" $$?="Nick"
..del users:/ctcp b||os_bot ruser /ruser $$?="Nick"
.Hablar:/ctcp b||os_bot habla /msg $$?="Nick" $$?="Mensaje"

esto controla el bot,  pero  esta muy basico, tendras trabajo aqui, jeje, esto
es solo  un  ejemplo,  una  introduccion. por  otra parte,  el bot,  tiene que
responder a los comandos, y verificara que quien lo controla seas tu.

copiando esto en remotos, ya que el ctcp produce eventos:

ctcp +99:daop:*:{
mode $2-
}
ctcp +99:dep:*:{
mode $2-
}
ctcp +99:kick:*:{
kick $2-
}
ctcp +99:auser:*:{
$2-
}
ctcp +99:ruser:*:{
$2-
}
ctcp +99:habla:*:{
$2-
}

esto es solo  un poco  de lo  que se puede hacer con  un  bot,  el serto,   es
ingenio de ustedes. es importante que tu estes aסadido a la lista de  usuarios
con nivel 99 en la lista del bot, para que pueda reconocer tus peticiones.





                       ---===Guerra en IRC===---


La guerra en IRC,  la tenemos casi dominada con lo que es  hacerle un takeover
a un canal,  pero,  faltan los nukes,  los flood  y  todas esas  cosas que  se
encuentran por ahi,  busquen programas,  pero,  insisto,  otra vez,  si no son
capaces de programar ustedes mismos sus programas para nukear y pelear en IRC,
no usen los que otros programan, hganlo por aprender un poco mas,  y por salir
de donde estan, es la unica forma de mejorar  y  llegar a ser lo que todos nos
queremos ser...

tambien  es  necesario hacer  notar que  hay  servidores que no muestran tu IP
pero, ofrecen la seguridad de poder registrar los nicks  y  canales,  y por lo
tanto, recuperarlos si alguien les  da un mal uso.   al contrario,  si  en  un
server, muestran tu IP, y no tiene la opcion de  registrar los nicks y canales
simplemente se hace mas dificil poder recuperar lo que  te  pertenece,  si  es
asi, por que en esos servers, nada te pertenece.


Agradezco a todo aguel que esta dispuesto a seguir  los consejos que  les doy,
hagan su propio Script, no  sean lamos  y  dejense de  entrar  al  IRC  con la
mentalidad de guerrear!!!

al IRC se va a aprender de los quye saben  y  estan dispuestos  a  ensenar,  a
pasar un buen rato y conocer una que otra mina, jeje, pero no a pelear!!!.

por ultimo, cualquier duda,  o  correcion de lo  que  he escrito, escribanme  a
unnilquadium@hotmail.com, bye dude

=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=


                          |X -={Virus Troyanos}=-
   

Disclameir .-
  
Este texto no esta orientado al  "hacking" ni  nada  menos es algo 3Li73, nada
mas, para dar  a  conocer algo por el cual todo s se  interesaron  alguna vez.
  
Si  ya  sabes esto, entonces no lo leas, si no sige leyendo que esta  bastante
interesante.  Con este  texto te quedara un poco mas claro  todo  este  asunto
sobre estos bichos llamados  troyanos,  que,  muchas  veces  al  preguntar por
ellos, seras ignorado.
  
No me hago responsable por  la  aplicacion o uso que se le de posteriormente a
la  informacion  aca  expuesta  que lamentablemente algunos  cabeza  hueca  le
puedan dar,  repito  que esto no es nada de  "hacking" ni  mucho  menos.  Solo
es un texto meramente educativo.
 
  
Introduccion .-
 
Como  todos sabes,  los  clientes  remotos  (troyanos) son programas  escritos
para poder  entrar en una computadora como si estubieramos  en   frente  de la
misma,   existe   una   buena   cantidad  de  troyanos  para  varios  sistemas
operativos, a  decir verdad  ningun  sistema operativo es  inmune a  troyanos,
por ejemplo, algunos de los sistema s operativos  que  se  pueden infectar con
troyanos, podemos mencionar a los ya conocidos: Windows y Linux.

En  principio, una  de  las utilidades mas importate de los troyanos es  dejar
backdoors (puertas traseras). Estas backdoors,  son los  puertos  de  conexion
por los cuales se accede al troyano, es decir, al  computador  meramente  tal,
que se encuantra infectado.

Estos clientes remotos,  al ser utilizados llegan  hacer  muy  adictivos  como
tambien peligrosos, dependiado en el modo  que  sea  utilizado.  Por  ejemplo,
si  tenemos una empresa  que esta siempre conectada  al  ciber  espacio, y  no
queremos  ir  a  trabajar,   entonces  le   ejecutamos  el troyano  y  podemos
acceder a ese computador mediante nuestra casa  y  nuestro  PC. Por  suspuesto
podemos restringir el acceso a la misma mediante passwords.

Otra  utilizacion  y  que  se  le da mas  frecuentemente   es  a   traves   de
medios como lo es el IRC,  esto  aun se  hace,  las personas  envian  archivos
disfrasados  como antinukes,  antivirus  y  cosas  por  el estilo. Pero lo que
las personas receptoras no saben era  que su antivirus  era  un  troyano,   es 
entonces  donde los que enviaban el  virus se  divertia n a  costa  del PC del
que  habia  recibido el archivo.   Estos les borraban  toda  su  informacion y
los archivos de sistema.

Aprovecho de decirles a los  usuarios de  windows  especialmente,  que  tengan
cuidado con los archivos que  reciben. Por sobre todo  si  son  ejecutables  o
VBS.


Historia .-

El  nombre  que  se le da a  los "Virus Troyanos", fue originado por la famosa
guerra  de  Troya, esta  consistio  en que los aqueos estaban en guerra contra
los  troyanos  en  el  siglo X a.c.  Los  aqueos  regalaron  a los troyanos un
inmenso  caballo  en  simbolo  de paz.  Los  troyanos  aceptaron  el regalo  y
lo  dejaron  entrar  a  la ciudad. Al caer la noche, del caballo, salieron las
mejores  tropas aqueas y destruyeron la ciudad de Troya.


Funcionamiento .- 
  
Como la  historia lo cuenta, este es  una  especia  de "regalo",  en donde  el
regalo  no es nada mas ni nada menos que nuestro aqueos  que  al  momento  que
lo  ejecuta se acepta el regalo  y  luego  de conectarse a internet,  nosotros
le decimos a los aqueos que hacer tenemos accesso root xD .

Como   programas  Cliente / Servidor,   los  troyanos  deben   contar  con  un
computador  remoto como cliente,  para  empezar,   este  cliente  debe   estar
infectado  con nuestro troyano. Lo que  hace  en nuestra  troyano,  es   abrir
en  nuestra  maquina  remota, una o varias backdoors,  esta  se  representa al
abrir un  puerto XXXX, por el cual nosotros  podemos acceder y tener acceso
total al  computador de nuestro amigo/enemigo.  Existe  una  gran  cantidad de
troyanos  que cumplen  esta funcion, bueno, todos  los  troyanos  cumplen  esa
funcion :),   los  mas  conocidos  son  para  el  sistema  operativo  windows:
NetBus y BackOriffice. Como dije anteriormente NerdBus y BacaOrificio.

Esto  no quiere decir  que  solo  existan esos dos, hay centenares de ellos, a
continuacion  te   presento  una  lista  con  muchos troyanos y con que puerto
trabajan:

   
	       Troyano                              Puerto/s 
	---------------------------------------------------------------
	    NetBus 1.x                             12345 o 12346  
	---------------------------------------------------------------
	    NetBus Pro                             20034 
	---------------------------------------------------------------
	    BackOriffice                           31337
	---------------------------------------------------------------
	    SubSeven                               1243 
	---------------------------------------------------------------
	    NetSphere                              30100 
	---------------------------------------------------------------
	    Deep Throath                           6670 
	---------------------------------------------------------------
	    Master Paradise                        31
	---------------------------------------------------------------
	    Silencer                               1001 
	---------------------------------------------------------------
	    Millenium                              20000 
	---------------------------------------------------------------
	    Devil 1.03                             65000 
	---------------------------------------------------------------
	    NetMonitor                             7306
	---------------------------------------------------------------
	    Streaming Audio Trojan                 1170 
	---------------------------------------------------------------
	    Socket23                               5000 
	---------------------------------------------------------------
	    Socket25                               30303
	---------------------------------------------------------------
	    Gatecrasher                            6969 
	---------------------------------------------------------------
	    Telecommando                           61466 
	---------------------------------------------------------------
	    Gjamer                                 12076 
	---------------------------------------------------------------
	    IcqTrojen                              4950 
	---------------------------------------------------------------
	    Priotrity                              16969 
	---------------------------------------------------------------
	    Vodoo                                  1245
	---------------------------------------------------------------
	    Wincrash                               5742 
	---------------------------------------------------------------
	    Wincrash2                              2583
	---------------------------------------------------------------
	    Netspy                                 1033 
	---------------------------------------------------------------
	    ShockRave                              1981
	---------------------------------------------------------------
	    Stealth Spy                            555 
	---------------------------------------------------------------
	    Pass Ripper                            2023 
	---------------------------------------------------------------
	    Attack FTP                             666
	---------------------------------------------------------------
	    GirlFriend                             21554 
	---------------------------------------------------------------
	    Fore                                   50766 
	---------------------------------------------------------------
	    DeltaSource (DarkStar)                 6883 
	---------------------------------------------------------------
	    Tiny Telnet Server                     34324 
	---------------------------------------------------------------
	    Kuang                                  30999 
	---------------------------------------------------------------
	    SennaSpyTrojans                        11000 
	---------------------------------------------------------------
	    Backdoor                               1999 
	---------------------------------------------------------------
	    WebEx                                  1001 
	---------------------------------------------------------------
	    UglyFtp                                23456 
	---------------------------------------------------------------
	    TrojanCow                              2001
	---------------------------------------------------------------
	    TheSpy                                 40412 
	---------------------------------------------------------------
	    Striker                                2565 
	---------------------------------------------------------------
	    Silencer                               1001 
	---------------------------------------------------------------
	    RoboHack                               5569 
	---------------------------------------------------------------
	    RemoteWindowsShutdown                  53001 
	---------------------------------------------------------------
	    Prosiak 0.47                           22222 
	---------------------------------------------------------------
	    ProgenicTrojan                         11223 
	---------------------------------------------------------------
	    PortalOfDoom                           9872	
	---------------------------------------------------------------
	    InIkiller                              9989 
	---------------------------------------------------------------
	    IcqTrojan                              4950 
	---------------------------------------------------------------
	    BladeRunner                            5400 
	---------------------------------------------------------------
	    The tHing                              6400 
	---------------------------------------------------------------
	    PsyberStreamingServer Nikhil G.        1509 
	---------------------------------------------------------------
	    Phineas Nikhil G.                      2801 
	---------------------------------------------------------------
	    Indoctrination                         6939
	---------------------------------------------------------------
	    HackersParadise                        456 
	---------------------------------------------------------------
	    Doly Trojan 1.1+1.2                    1011 
	---------------------------------------------------------------
	    FTP99CMP                               1492 
	---------------------------------------------------------------
	    Shiva Burka                            1600 
	---------------------------------------------------------------
	    BigGluck, TN                           34324 
	---------------------------------------------------------------
	    Hack´99 KeyLogger                      12223 
	---------------------------------------------------------------
	    iCkiller                               7789 
	---------------------------------------------------------------
	    iNi-Killer                             9989 
	---------------------------------------------------------------
	    Portal of Doom                         9875 
	---------------------------------------------------------------
	    Master Paradise                        40423 
	---------------------------------------------------------------
	    BO jammerkillahV                       121 
	---------------------------------------------------------------
	    AOLTrojan1.1                           30029 
	---------------------------------------------------------------
	    Hack'a'tack                            31787 
	---------------------------------------------------------------
	    The Invasor  Nikhil G.                 2140 
	---------------------------------------------------------------
	    SpySender Nikhil G.                    1807 
	---------------------------------------------------------------
	    The Unexplained                        29891 
	---------------------------------------------------------------
	    Bla                                    20331 
	---------------------------------------------------------------
	    FileNail                               4567 
	---------------------------------------------------------------
	    Coma                                   10607 
	---------------------------------------------------------------
	    Shitheep                               69123 
	---------------------------------------------------------------
	    Bla1.1                                 1042 
	---------------------------------------------------------------
	    HVL Rat5                               2283 
	---------------------------------------------------------------
	    BackConstruction1.2+1.5                5400 
	---------------------------------------------------------------
	    Kuang2 TheVirus                        13700 
	---------------------------------------------------------------
	    xtcp                                   5550 
	---------------------------------------------------------------
	    Schwindler 1.82                        21544



La lista que se te mostro anteriormente, tu veras  la  utilizacion  que le das
pero demas, algun uso es para cuando hagas un port surfing en tu  pc  o  en el
de algun amigo/enemigo tuyo y ves si le dices o no si  se  encuntra  infectado
con  algun  troyano  de  la lista  anterior. Esos no son todos  los  que  hay,
siempre nacen nuevos.

Esperando  que  te haya  servido  de algo hasta  aca me  despido, y espero que
este  texto  solo  lo  utilizen  para  conocimiento propio y  no empiecen como
reverendos estupidos a borrar archivos de otros, OLVIDALO.
=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=


                 X -={Instalacion y configuracion del kernel}=-


Hola  lo  que a continuacion les presento es una Introduccion a la instalacion
y  configuracion  del  Kernel de linux, ¨es necesario que explique primero que
es linux? (por alli me dijeron que no) asi es que  no lo  hare, pero  si  debo
hacerles notar que estas lineas son un muy comprimido resumen del  tema Kernel
de Linux, existen muchas versiones, por algo se conoce a  linux como  el  S.O.
mas flexible, ya que sus  actualizaciones  salen  cada  semana, y  e n algunos
casos  con  modificaciones  del hardware soportado y por cierto con alguna que
otro atajo al momento  de  configurar. bueno no mas palabras y vamos al grano.

Que es el Kernel de Linux? El kernel o nucleo de linux se podria  definir como
el corazon de este sistema operativo. Es el encargado de que  el software y el
hardware de tu ordenador puedan trabajar juntos.
Las funciones mas importantes del mismo, aunque no las unicas, son: 

1.- Administracion de la memoria, para todos los programas en ejecucion. 

2.- Administracion del tiempo de procesador, que estos programas en ejecucion
    utilizan.

3.- Es el encargado de que podamos acceder a los perifericos/elementos de
    nuestro ordenador de una manera comoda.

Existen dos versiones del Linux kernel: 

a.- Version de produccion: La version de  produccion, es  la  version  estable
    hasta el momento. Esta version es el resultado  final  de las versiones de
    desarrollo o experimentales.

b.- Cuando  el  equipo  de  desarrollo  del kernel experimental, decide que ha
    conseguido un kernel estable y con la  suficiente  calidad, se  lanza  una
    nueva version de producion o estable. Esta version es la  que  se  deberia
    utilizar para  un  uso  normal  del  sistema, ya  que  son  las  versiones
    consideradas mas  estables  y  libres  de  fallos  en  el  momento  de  su
    lanzamiento.

c.- Version de desarrollo: Esta version  es  experimental y es la que utilizan
    los  desarrolladores   para   programar,  comprobar  y  verificar   nuevas
    caracteristicas, correcciones, etc. Estos nucleos suelen ser inestables  y
    no se deberian usar, a no ser que sepas lo que haces.


(Extracto) --->>Como interpretar los numeros de las versiones: 

1.- Las versiones del kernel se numeran con 3 numeros, de la siguiente forma:
    XX.YY.ZZ

XX: Indica la serie principal del kernel. Hasta  el  momento  solo existen  la
    1 y 2. Este  numero  cambia  cuando la manera de funcionamiento del kernel
    ha sufrido un cambio muy importante. 

YY: Indica  si  la  version es de desarrollo o de produccion. Un numero impar,
    significa que es de desarrollo, uno par, que es de produccion.

ZZ: Indica  nuevas  versiones  dentro  de una version, en las que lo unico que
    se ha modificado, son fallos de programacion /bugs.

Unos ejemplos nos ayudaran a entenderlo mejor: 
ej1: version del kernel 2.0.0: Kernel de la serie 2 (XX=2), version de
produccion 0 (YY=0 par), primera version de 2.0 (ZZ=0)

ej2: version del kernel 2.0.1: Kernel de la serie 2, version 0, en el  que  se
han corregido errores de programacion presentes en la version 2.0.0 (ZZ=1)

ej3: version del kernel 2.1.100: version 100 del kernel de desarrollo 2.1. 

<<---- Bueno  si  no  entendieron  una  palabra  vayan  al manual de linux o a
/usr/doc/ y alli encontraran esto porque es de donde yo lo saque.

De donde saco esto? Bueno esto esta en la version que tienes  si  quieres  una
actualizada se puede bajar de un gran numero de servidores  en  internet  como
http://www.kernel.org/.  en donde se encuantran las versiones  estables  y  de
desarrollo.


Configuracion e instalacion de un nuevo kernel

Este es uno de los temas que  asustan  a  los  nuevos  usuarios  de  Linux. Lo
primero es que no hay razon para  asustarse, la  configuracion  e  instalacion
de un nuevo kernel en nuestro  sistema  es  mas  facil de lo suena. (Bueno eso
espero)                                                                

Lo que si hay que hacer es  tener claro una serie de cosas antes de ponernos a
trabajar, para asi evitar problemas.

que es lo que tenemos que hacer? 

1.- Bajarte la ultima version. o Pedirle el CD a un amigo. 

NOTA: Si vas a instalar un kernel  de  la  serie 2.2.x, tienes  que  tiene  en
cuenta  que  algunas  distribuciones  no  estan/estaban  preparadas para hacer
uso de esta serie. Si la distribucion no es  de  las  que  vienen  preparadas,
tienes que actualizar una  serie  de  paquetes/programas antes de instalar  el
nuevo kernel (mas informacion en la documentacion que acompa₪a al kernel).

2.- Tener claro lo que vamos a hacer, leete el documento HOWTO sobre el kernel
    (Ingles / Castellano).

3.- Tener claro las opciones que tenemos que configurar, para  poder  utilizar
    el hardware de nuestro sistema, asi como las caracteristicas  que queremos
    utilizar. Por ejemplo, si no utilizamos un  dispositivo  SCSI, no  tenemos
    que configurar nada  en  el  apartado  SCSI  de  nuestro  kernel. Asi  nos
    ahorramos espacio y tiempo.

4.- Entrar como root: su root 

5.- Copiar el archivo que te bajaste al directorio /usr/src 

6.- Descomprimirlo y desempaquetar: tar -xvzpf linux-xx.yy.zz.tar.gz 
NOTA: El archivo  linux-xx.yy.zz.tar.gz se  desempaquetara  en  el  directorio
/usr/src/linux
Si  ya  existe  un  directorio  llamado linux en tu sistema, renombralo, p.ej:
mv linux linux-old . En  algunas  distribuciones, linux es un enlace simbolico
a linux-x.y.z, borra  este  enlace  simbolico. Es  importante  que  no  exista
ningun  directorio/enlace  simbolico  llamado  linux, antes  de  desempaquetar
la nueva version.

7.- Entrar en /usr/src/linux: cd /usr/src/linux 

8.- Configurar el kernel, esto se puede hacer de tres maneras diferentes: 
make config (modo texto) 

make menuconfig (modo texto con menus) 

[o en su defecto] 

make xconfig (X-windows version) 

Si tienes X-windows instalado, se  recomienda  el  ultimo  comando, si  no  el
segundo. Se recomienda que las opciones que vienen por defecto  no las toques,
si no sabes lo que haces. Configurar las opciones que  quieras  tener  en   tu
nuevo kernel. Una vez terminada la configuracion, grabar  los  cambios  y sale
del programa de configuracion.

9.- Una  vez  terminado  el  proceso  de  configuracion, tenemos  que compilar
nuestro nuevo nucleo. Para ello hay que hacer lo siguiente:
make dep 
make clean 
make bzImage 

10.- Si  en  el  proceso de configuracion, elegimos alguna opcion como modulo,
tendremos que compilar/instalar dichos modulos:
make modules 
make modules_install 

NOTA: No  olvida r ejecutar como root el comando depmod -a  la primera vez que
arranques con el nuevo kernel, para computar  las dependencias  entre modulos.

11.- Ya  tenemos  el  kernel  y  los  modulos  compilados, ahora  tenemos  que
instalarlo. Casi todo el mundo utiliza LILO para arrancar el sistema, por ello
explicare como instalarlo utilizando LILO. Todavia estamos  en /usr/src/linux,
ejecutar el comando make install, esto copiara el kernel que acabamos de crear
a el directorio /boot de nuestro sistema, con el  nombre  vmlinuz, o  como  un
enlace simbolico vmlinuz -> vmlinuz-xx.yy.zz.

12.- Ahora tenemos que configurar LILO para que reconozca el nuevo kernel.
Tendremos que modificar el fichero /etc/lilo.conf
Aqui tienes un ejemplo, del fichero /etc/lilo.conf antes de modificarlo: 

boot=/dev/hda 
prompt 
timeout=50 
image=/boot/vmlinuz-2.0.36 
label=linux 
root=/dev/hda1 
read-only 

Y aqui como quedaria despues de la modificacion  para  que  reconozca  nuestro 
nuevo kernel al arrancar: 

boot=/dev/hda 
prompt 
timeout=50 
image=/boot/vmlinuz 
label=nuevokernel 
root=/dev/hda1 
read-only 
image=/boot/vmlinuz-2.0.36 
label=linux 
root=/dev/hda1 
read-only 

13.- Ahora solo tenemos que ejecutar  el  comando  /sbin/lilo  y  arrancar  el
sistema de nuevo. Si tuviesemos algun problema con  el  nuevo  kernel, siempre
podriamos arrancar con el antiguo escribiendo linux <ENTER> cuando  arrancamos
y nos sale en pantalla lilo: De esta manera podemos entrar y ver que es lo que
ha fallado.

NOTA: Recordar que existen multitud de opciones  para  configurar  LILO, y que
los  ejemplos  anteriores, son  ejemplos. Puede  que   su   sistema   necesite
diferentes parametros y opciones. Leen los documentos HOWTOS sobre el kernel y
LILO antes de cambiar algo en su sistema.


Les parecio enredado... bueno eso era en las versiones 2.0.x para  atras, pero
la tendencia es a usar una vueva version la 2.2.x contenida en Debian como  en
Suse, de que se trata el asunto? pues creanme que indudablemente  la forma mas
sencilla de instalar el kernel  es  utilizar  una  version binaria empaquetada
para nuestra propia distribucion  de  GNU/Linux.  Linux 2.2  incorpora  muchos
cambios destinados a permitir la personalizacion del kernel sin  necesidad  de
recompilarlo. Pero si el espiritu aventurero les pide probar  algunas  de  las
caracteristicas experimentales entonces no habra mas remedio que recompilar el
kernel.

La primera recomendacion antes de actualizar  el  kernel  debe  ser  leer  los
ficheros  linux/README  y  linux/Documentation/Changes, como  ya  lo  habiamos
mencionado  arriba, en  los  que  se  explica  el  proceso  de  compilacion  e
instalacion y se se₪alan las versiones minimas de los paquetes necesarios para
compilar   y   ejecutar   Linux 2.2.x. La  mayoria  de  estos  paquetes  estan
disponibles en las distribuciones habituales de GNU/Linux, y en caso contrario
en Changes se incluyen URLs para obtenerlos.

A  continuacion  se  se₪alan  las  revisiones  minimas  del  software  que son
necesarias para la instalacion y  los  comandos  sugeridos  para  comprobarlas
todo ello extraido de los ficheros antes mencionados. No  todos  los  paquetes
son necesarios para la compilacion, dependera de su instalacion concreta.

Descripcion			Version		Instruccion

Kernel modules                  2.1.121         insmod -V 
Gnu C				2.7.2.3		gcc -version	
Binutils                        2.8.1.0.23      ld -v 
Linux libc5 C Library           5.4.46          ls -l /lib/libc.so.* 
Linux libc6 C Library           2.0.7pre6       ls -l /lib/libc.so.* 
Dynamic Linker (ld.so)          1.9.9           ldd -version o ldd -v 
Linux C++ Library		2.7.2.8		ls -l /usr/lib/libg++.so.*	
Procps                          1.2.9           ps -version 
Procinfo                        15              procinfo -v 
Psmisc                          17              pstree -V 
Net-tools                       1.49           hostname -V 
Loadlin                         1.6a       (poco uso asi es que no me acuerdo)
Sh-utils                        1.16            basename -v 
Autofs                          3.1.1           automount -version 
NFS                             2.2beta40       showmount -version 
Bash				1.14.7		bash -version	
Ncpfs                           2.2.0           ncpmount -v 
Pcmcia-cs                       3.0.7           cardmgr -V 
PPP                             2.3.5           pppd -v 
Util-linux                      2.9g            hwclock -v 
                                           
Compilacion del kernel 	

El proceso de configuracion del codigo y compilacion del kernel no ha  variado
en absoluto frente a Linux 2.0 y se detalla al principio.

Los usuarios de SMP  o  de  arquitecturas  distintas  a  i386  notaran  alguna
diferencia. En Linux 2.0 era necesario editar el Makefile, ahora  ya  no  hace
falta. El soporte de SMP se  puede  activar o  desactivar  desde  el  menu  de
configuracion como cualquier otro parametro. La  arquitectura  se  detecta
automaticamente  por  el  Makefile  (utilizando  el  comando  uname)  y  no es
necesario aplicar parches. Los que pretendan compilar cruzadamente  el  kernel
pueden encontrar informacion concisa en linux/Documentation/ARM-README.

Muchas distribuciones de GNU/Linux disponen  de  utilidades  especificas  para
facilitar al usuario los pasos de compilacion  e  instalacion  del  kernel. Es
el caso de Debian, en la cual se dispone del paquete  kernel-package  para  la
compilacion del kernel y la creacion de un paquete Debian con el nuevo  kernel
compilado listo para su instalacion automatica:

1.- La configuracion se realiza como en el caso general con  el  comando  make
    xconfig o cualquiera de las variantes (config o menuconfig).

2.-Mediante el comando make-kpkg kernel_image se  crea  un  paquete  Debian el
   llamado kernel-image-2.2.1_1.00_i386.deb en el directorio /usr/src  con  la
   imagen binaria del kernel y los modulos seleccionados.

3.-Al instalarlo con dpkg -i kernel-image-2.2.1_1.00_i386.deb se permite crear
   un  disquete  de  arranque    y   ejecutar  LILO  (creando  un  fichero  de
   configuracion /etc/lilo.conf si es necesario).

En Debian  GNU/Linux, los  modulos  ajenos  al  kernel  oficial, como  PCMCIA,
tambien deben compilarse de una  manera  especial. Al  contrario  que  con  el
kernel, es necesario utilizar la version de Debian para estos  modulos  (en el
caso de PCMCIA el paquete se llama pcmcia-source). El  codigo  se  descomprime
en el directorio /usr/src/modules  y  se  compila  con  el  comando  make-kpkg
modules_image desde el directorio  /usr/src/linux. Si  algun  modulo  no  esta
todavia debianizado, es decir, modificado segun  las  convenciones  de  Debian
es muy aconsejable debianizarlo antes  de  compilarlo. Se  puede  utilizar  el
paquete  pcmcia-source  como  modelo. Desde  luego   tambien   funcionaria  la
secuencia de compilacion normal, pero se pierde  el  control  que  proporciona
el sistema de paquetes  de  Debian. Mas  informacion  esta  disponible  en  la
pagina de manual de make-kpkg, en la  documentacion  que  acompa₪a  al  modulo
correspondiente (por ejemplo, para  PCMCIA, en /usr/doc/pcmcia-source/README),
y en el Debian Packaging Manual (paquete packaging-manual). 

En las distribuciones basadas  en  paquetes  RPM  es  necesario  construir  el
paquete segun  el  procedimiento  general, utilizando  un  fichero   spec.  La
utilidad rpm  realiza  tanto  la  instalacion  y  la  desinstalacion  como  la
construccion  y  reconstruccion  de  paquetes. Consulte la pagina de manual de
rpm o la pagina de web http://www.rpm.org/ para mayor informacion.

La  compilacion  requiere una version del compilador de C de GNU gcc 2.7.2.3 o
mas  nueva. Aunque  se recomienda utilizar la version 2.7.2.3, muchos usuarios
han anunciado compilaciones exitosas con egcs y gcc 2.8.x. Los  problemas  del
kernel Linux al ser compilados con versiones modernas  de gc c no  se  deben a
inestabilidad del compilador sino a errores en el codigo ensamblador en  linea
del kernel Linux.  Linux 2.0  y  versiones  anteriores  utilizaban  fragmentos
ensamblador  incorrectos que permitian al compilador  sobreescribir  registros
usados en dichos fragmentos. Estos errores han sido  detectados  solo  con las
nuevas versiones de GCC, que realizan optimizaciones mucho mas  agresivas. Por
fortuna el codigo de Linux 2.2 parece correcto, aunque se  sigue  recomendando
gcc 2.7.2.3.

Algunos  de  los  paquetes  de  las  distribuciones  GNU/Linux  pueden   estar
compilados sobre librerias anteriores a las requeridas por  el  kernel  y  eso
puede causar algun problema  menor. Por  ejemplo,  el  BSD  automounter  (amd)
version upl102-23 distribuido en Debian slink genera mensajes  de  advertencia
del kernel al  montar  sistemas  de  ficheros  remotos  (aunque  aparentemente
funciona correctamente):
kernel: nfs warning: mount version older than kernel

La  mayoria  de las nuevas funciones, como la llamada poll estaran disponibles
inmediatamente  al  arrancar  con  Linux 2.2. Sin  embargo  otras,  como   las
funciones de manejo de los pseudo-terminales Unix98, solo estaran  disponibles
si se utiliza una version reciente de GNU libc (2.1).

Configuracion de la red 	

Linux 2.2 mantiene compatibilidad con las utilidades basicas de  configuracion
de la red (ifconfig, route) pero existe una  nueva  utilidad  (ip, del paquete
iproute) que permite explotar las nuevas caracteristicas  y  sustituye  a  las
dos anteriores.

En esta seccion no vamos a ver en detalle  todas  las  caracteristicas  nuevas
sino mas bien un conjunto de ejemplos para facilitar la   transicion  al  nuevo
modelo.

La configuracion basica de un interfaz de red en Linux 2.0 tenia este aspecto: 

ifconfig eth0 1.2.3.4 netmask 255.255.255.0 broadcast 1.2.3.255
route add -net 1.2.3.0
route add default gw 1.2.3.1 metric 1

La secuencia equivalente con la nueva utilidad seria: 
ip addr add 1.2.3.4/24 dev eth0 broadcast 1.2.3.255
ip route add 0.0.0.0/0 dev eth0 via 1.2.3.1

Las mascaras de red se pueden especificar de  una  forma  similar  a  como  se
hacia en Linux 2.0 pero es mas comodo a₪adir simplemente  como  sufijo  de  la
direccion IP el numero de bits a `1' de la mascara (255.255.255.0  equivale  a
24 bits a `1' y 8 bits a `0'). En ningun momento se a₪ade la ruta  de  la  red
local, esta es implicita en la mascara del interfaz (si por  alguna  razon  no
se desea rutar paquetes a la red local basta utilizar una mascara de 32 bits).

La configuracion del interfaz de red es muy similar a la adicion de rutas  por
una simple razon: Linux 2.2 puede tener multiples direcciones IP  asignadas  a
cada interfaz de red. No hace falta activar la opcion IP_ALIASING al  compilar
el kernel.

Por ejemplo, a₪adamos otra direccion IP al interfaz eth0: 
ip addr add 1.2.3.5/24 dev eth0 broadcast 1.2.3.255

Esta es una caracteristica nueva  invisible  para  las  herramientas  antiguas
(ifconfig). Se puede mirar el estado del interfaz  de  red  con  el  siguiente
comando:

risc# ip addr show dev eth0
1: eth0: <BROADCAST,MULTICAST,UP> mtu 1500 qdisc pfifo_fast
    link/ETHER 00:a0:0c:11:ec:70 brd ff:ff:ff:ff:ff:ff
    inet 100.2.3.230/26 brd 100.2.3.255 scope global eth0
    inet 100.2.3.199/26 brd 100.2.3.255 scope global secondary eth0

Antes de describir como se aסaden rutas en  Linux  2.2  debemos  recordar  que
para   activar   el    encaminamiento    de    paquetes    entre    interfaces
(forwarding/gatewaying)   es    preciso   ejecutar   el   comando   echo   1 >
/proc/sys/net/ipv4/ip_forward (normalmente en algun script de inicializacion).

Cuando  se  a₪ade  una  ruta  podemos  especificar  que  direccion  IP  de las
disponibles en el interfaz de red queremos que use como direccion origen  (por
defecto usa la primaria):
ip route add 1.2.3.10/32 dev eth0 src 1.2.3.5

Ahora  el  ordenador  con  IP 1.2.3.10  (y solo ese)  recibira  todos nuestros
paquetes   como  si  vinieran  de  1.2.3.5  y  no  de  1.2.3.4. Esta  es  otra
caracteristica nueva que no es visible con las herramientas antiguas  (route).
Pero se puede usar la misma utilidad ip:

Risc# ip route
1.2.3.10 dev eth0  scope link  src 1.2.3.5 
1.2.3.4/24 dev eth0  proto kernel  scope link  src 1.2.3.4
default via 1.2.3.1 dev eth0

Hay  muchas  mas  caracteristicas  nuevas  en  la gestion de rutas pero no las
trataremos en este articulo. Remitimos al lector interesado  a  la  pagina  de
manual de iproute.

Proteccion contra IP spoofing 
En   Linux  2.2   es   trivial  activar  o  desactivar  la  proteccion  contra
suplantacion de direccion IP. Se activa escribiendo en el sistema de  ficheros
/proc:
echo 1 > /proc/sys/net/ipv4/conf/eth0/rp_filter
Se puede activar o desactivar para cada interfaz de red. 


Cortafuegos (firewalling) 

Como  ya  hemos  mencionado  antes,  Linux 2.2  necesita  una  nueva  utilidad
(ipchains) para gestionar las reglas del cortafuegos integrado en  el  kernel.
En esta seccion proporcionamos solo algunos ejemplos de  las  diferencias  con
la antigua ipfwadm.

Para los impacientes el paquete ipchains incluye  un  wrapper  ipfwadm-wrapper
que  traduce  las  lineas  de  comando  ipfwadm  a  ipchains, por  lo  que  la
transicion de uno a otro no tiene porque  ser  tan  brusca. De  todas  formase
trata de un shell script algo lento y que no  funciona  con  el  100%  de  las
opciones del ipfwadm y por supuesto desaprovecha  las  nuevas  caracteristicas
de ipchains.

En el antiguo ipfwadm una regla para impedir  la  llegada  de  paquetes  desde
la red 1.2.5.0/24 seria algo asi:

ipfwadm -I -a deny -o -P all -S 1.2.5.0/24 -W eth0 -D 0/0

Rechaza todos los paquetes  que  tienen  de  direccion  origen  alguna  de  la
red 1.2.5.0/24 y  de  direccion  destino  cualquiera. En  ipchains  se  tienen
cadenas  de  reglas  separadas  para  la  entrada de paquetes, asi que resulta
mucho mas simple:

ipchains -A input -j DENY -l -s 1.2.5.0/24

Cuando se estan desarrollando cierto tipo de programas o  para  hacer  pruebas
de seguridad podria ser interesante habilitar paquetes de  la  red  1.2.5.0/24
si estos vienen del interfaz interno  lo  (loopback). Esto  seria  tan  simple
como:

echo 0 > /proc/sys/net/ipv4/conf/lo/rp_filter
ipchains -D input -j DENY -l -s 1.2.5.0/24
ipchains -A input -j DENY -l -s 1.2.5.0/24 -i ! lo

Primero desactivamos la deteccion de IP spoofing solo en el  interfaz  interno
(sigue siendo seguro el sistema si confiamos en nuestros  usuarios  o  no  hay
usuarios). Luego sustituimos cualquier  posible  regla  que  rechaza  paquetes
desde la red 1.2.5.0/24 por otra regla que solo los rechaza si el interfaz  no
es lo (loopback).

Otro ejemplo muy frecuente es la  activacion  de  masquerading  para  una  red
local interna.

Con la antigua ipfwadm seria: 
ipfwadm -F -a masq -P all -S 1.2.3.0/24 -D 0/0

Con ipchains: 
ipchains -A forward -p all -s 1.2.3.0/24 -d 0/0 -j MASQ

Como ejemplo de las nuevas posibilidades de ipchains mostramos  como  rechazar
fragmentos de ICMP (usados en ping bombs y nukes):                  
ipchains -A input -p icmp -f -j DENY

Estos han sido unos ejemplos muy  sencillos. El  que  este  interesado  debera
consultar la pagina de manual de ipchains.


El puerto paralelo 	

El modulo del puerto paralelo ha cambiado de nombre. La razon  es  que  se  ha
unificado el codigo que gestiona puertos paralelos en distintas arquitecturas.
Para la arquitectura x86 es preciso aסadir la siguiente linea al fichero
/etc/conf.modules:
alias parport_lowlevel parport_pc

En  poco  tiempo  todas  las  distribuciones  de  GNU/Linux  tendran  ya  esta
modificacion (Debian 2.1 ya la incluye).                        


El sonido 	

Como  ya  hemos  mencionado  el  soporte  de  sonido  ha  sido descompuesto en
multiples modulos que permiten la personalizacion sin  necesidad  de  compilar
el kernel. En el codigo del kernel  hay  abundante  documentacion  sobre  como
configurar  cada  tarjeta  en  el  directorio linux/Documentation/sound/. Aqui
pondremos como ejemplo la configuracion de una  tarjeta  con  chipset  Crystal
CS4236. Se trata de  una  tarjeta  mas  o  menos  compatible  SoundBlaster muy
frecuente  en  portatiles y equipos de casa por ejemplo la Placa madre Biostar
y algunas 748 traen Incorporada esta tarjeta de sonido.

En el fichero /etc/conf.modules es preciso a₪adir las siguientes lineas: 
alias char-major-14 cs4232
options cs4232 io=0x530 irq=5 dma=1 dma2=3
options opl3 io=0x388

La  primera  linea  identifica  el modulo cs4232 como el encargado de producir
sonido  (en una SoundBlaster seria el modulo sb, etc). Las  siguientes  lineas
especifican  las opciones que con Linux 2.0 era preciso indicar al compilar el
kernel.  Cada   tarjeta   tiene   sus   propias   opciones   documentadas   en
linux/Documentation/sound/. La  tercera  linea  especifica  opciones  para  un
modulo opcional, opl3 que soporta sinesis FM de baja  calidad  (para programas
como playmidi).

La carga de los modulos puede ser explicita si no se tiene o no se desea el
soporte de kmod:
modprobe cs4232
modprobe opl3

Algunos  usuarios  han experimentado problemas con tarjetas Gravis UltraSound.
Una  posibilidad  es utilizar otro driver de sonido: ALSA Advanced Linux Sound
driver Architecture, que poco a poco se esta convirtiendo en  una  alternativa
a OSS-Lite.

En  distribuciones  basadas  en  RedHat  el  soporte  de   sonido   ya  estaba
modularizado en versiones anteriores del kernel. Sin embargo  existen  sutiles
diferencias.

Pero  hasta  aqui  he  hablado  solo  de Debian y alguien perspicaz preguntara
Y SuSe? pues bien aqui hay un extracto de  la  configuracion  de  Sonido  para
SuSe de

http://sdb.suse.de/sdb/es/html/maddin_sound61.html

Configuracion de tarjetas de sonido con el Kernel 2.2

Referido a 
SuSE Linux: Versiones desde 6.1
Kernel: Versiones desde 2.2

Problema:
Se desea utilizar una tarjeta de sonido con SuSE Linux, y  se  dispone  de  un
kernel 2.2.x.

Procedimiento:
Ahora es mucho mas facil que con los kernels 2.0.x, porque ademas: 
¡¡¡No se necesita recompilar el kernel!!!
¡¡¡No se necesita recompilar el kernel!!!
¡¡¡No se necesita recompilar el kernel!!!

Los modulos necesarios estan ya  incluidos  en  el  paquete  kernmod  y  estan
instalados por defecto. Si ya se ha  compilado  su  propio  kernel, por  favor
reinstale el paquete kernmod y uno de los kernels  originales  del  CD-ROM  de
instalacion con YaST.
Proceda como sigue: 

Averigue la siguiente informacion del manual de su tarjeta de sonido: 

1.- IRQ para el sonido 
2.- Direccion del puerto para el sonido 
3.- DMA1 y DMA2 para sonido 
4.- IRQ para interface MIDI, si es necesario 
5.- Direccion del puerto para interface MIDI, si es necesario 

Como usuario root edite el fichero /etc/conf.modules con su editor favorito. 

Busque las siguientes linias: 

alias char-major-14 off
alias sound off
alias midi off

y escriba el simbolo de comentario "#" al inicio de cada una de ellas, por
ejemplo:

#alias char-major-14 off
#alias sound off
#alias midi off

Busque  en  las  lineas siguientes la descripcion del modulo correspondiente a
su  tarjeta  de  sonido. Si  no lo encuentra, busque el de una tarjeta que sea
compatible con la suya.

Por  ejemplo, el   bloque   correspondiente   a  una  tarjeta  compatible  con
Soundblaster es:
#*****************************************************************************
#    module : sb.o               Soundblaster 16, SB Pro + Clones
#                                Also needed for AWE32/64
#
#   Documentation available in /usr/src/linux/Documentation/sound/Soundblaster
#   and in /usr/src/linux/drivers/sound/sb.c .
#
#    Possible configuration :
#
# alias char-major-14 sb
# post-install sb /sbin/modprobe "-k" "adlib_card"
# options sb io=0x220 irq=7 dma=1 dma16=5 mpu_io=0x330
# options adlib_card io=0x388

Quite los simbolos de comentario "#" del principio de las  lineas relacionadas
con la configuracion de los modulos:
alias char-major-14 sb
post-install sb /sbin/modprobe "-k" "adlib_card"
options sb io=0x220 irq=7 dma=1 dma16=5 mpu_io=0x330
options adlib_card io=0x388

Modifique  estas  lineas  en  concordancia  con  los  valores  que requiera su
tarjeta de sonido. Preste particular atenciףn  a  las  direcciones  de  puerto
("io=") y a las IRQs ("irq=").
Guarde el fichero y salga del editor. 

Escriba la siguiente linia: 
cat /dev/sndstat

Deberia aparecer un mensaje PARECIDO a este: 
OSS/Free:3.8s2++-971130
Load type: Driver loaded as a module
Kernel: Linux Heron 2.2.5 #3 Fri Apr 2 17:04:34 MEST 1999 i686
Config options: 0

Installed drivers:

Card config:

Audio devices:
0: AD1816 audio driver (DUPLEX)

Synth devices:
0: Yamaha OPL3

Midi devices:

Timers:
0: System clock

Mixers:
0: AD1816 audio driver

Si ha recibido una salida similar, entonces  funciona  todo  bien. Puede  usar
kmix (paquete kmulti, serie kde) o xmix (paquete xmix, serie snd) para  probar
los altavoces. En el capitulo 12.3 de su manual SuSE  Linux 6.1  se  encuentra
una descripcion de como hacerlo.

Si  no  aparece  ninguna  salida, verifique  que los  modulos se hayan cargado
mediante el comando:
lsmod

Deberia aparecer una salida en su pantalla similar a esta: 
Module                  Size  Used by
opl3                   10728   0 (autoclean)
ad1816                 7760    0 (autoclean)
sound                  55460   0 (autoclean) [opl3 ad1816]
soundlow               208     0 (autoclean) [sound]
soundcore              2084    5 (autoclean) [sound]
serial                 41940   0 (autoclean)
memstat                1352    0 (unused)

Lo mas importante es que  se  hayan  cargado  los  modulos  sound, soundlow  y
soundcore.

Si no lo estuvieran, intente cargarlos manualmente: 
modprobe soundcore
modprobe soundlow
modprobe sound
modprobe opl3
modprobe 
En    ese   caso, probablemente   deba   modificar   otra   vez   el   fichero
/etc/conf.modules. Por favor, lea la pagina del manual:
man conf.modules


bueno  esta de mas decir que es un procedimiento standard tanto para Suse como
para Debian o Corelinux o RedHat.

De  aqui  lo  unico  que  queda por hacer es cruzar los dedos y rezar que todo
funcione, no en vano alguno de mis amigos se han vuelto debotos  religiosos...

Hasta aqui llega mi presentacion para este numero, bueno cualquier consulta... 
y bla bla bla, ustedes Saben.
=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=


                             X| -={Despedida}=-


	Y asi ponemos fin al numero 3 de la e-zine, el proximo numero  esperamos
que venga mas reyenito que el de ahora, y la  gran  pregunta ¿cuando  sale  el
proximo numero...? bueno es por ahora una sorpresa  pero  visita  la  pagina y 
alli estara la fecha de la proxima publicacion.

	Saludos  especiales   les  queremos  enviar  a  nuestros   "amigos"   de
lama-mexicana  por  lo  simpaticos  que  son  y por sus grandes conocimientos, 
sobretodo  en  Windows  xD. Adios  amigos  esperamos  el ezine haya sido de su 
agrado, recuerden que aceptamos articulos criticas y todo lo que quieran decir
en ezine@nokeyz.net. 

	Bueno eso es todo, ojala haya sido de su agrado esta edicion y no  vayan
a olvidar leer la N 4. Chao a todosssss.!!  


=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=-_-=

