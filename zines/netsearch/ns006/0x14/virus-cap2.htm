<html>
<head>
<title>Curso de virus (Fundamentos de SSOO)</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
</head>

<body bgcolor="#000000" text="#FFCCCC" link="#FF6666">
<p align="center"><img src="caos-paz1.jpg" width="270" height="270"></p>
<p align="center"><font color="#FF0000" size="7"><b>II</b></font></p>
<p align="center"><font size="7" color="#FF3333">Fundamentos de SSOO</font></p>
<p align="left">&nbsp;</p>
<p align="left"> <font size="4"><b><font color="#FF3333">2.1.- Introducci&oacute;n 
  y funciones de los SSOO</font></b></font></p>
<p>La misi&oacute;n del sistema operativo es dar una serie de programas al ordenador 
  que permitan una utilizaci&oacute;n c&oacute;moda del computador, dot&aacute;ndolo 
  de toda una serie de funciones:</p>
<p><font color="#FF9999"><b>- Gesti&oacute;n de los recursos del computador:</b></font><b> 
  </b>Debe de controlar a este nivel la asignaci&oacute;n de recursos a los programas 
  libres en ejecuci&oacute;n, recuperaci&oacute;n de recursos cuando los programas 
  no los necesitan. Ser&aacute; lo que conoceremos como &quot;nivel kernel&quot;.</p>
<p><font color="#FF9999"><b>- Ejecuci&oacute;n de servicios para los programas:</b></font> 
  Estos servicios incluir&aacute;n varios para lanzar la ejecuci&oacute;n de un 
  programa, comunicar unos con otros, operar con la E/S, sobre ficheros, y el 
  tratamiento y soluci&oacute;n de errores. Lo llamaremos m&aacute;s adelante 
  &quot;nivel API&quot;</p>
<p><font color="#FF9999"><b>- Ejecuci&oacute;n de los mandatos de los usuarios:</b></font><b> 
  </b>Es el m&oacute;dulo del sistema operativo que permite que los usuarios dialoguen 
  de forma interactiva con el sistema, conocido como &quot;nivel shell&quot;.</p>
<p>Analizaremos estos tres niveles en detalle.</p>
<p>&nbsp;</p>
<p align="center"><img src="capas.jpg" width="208" height="171"></p>
<p align="center"><font size="2"><i><font color="#FFCCCC">Las tres capas, kernel, 
  API y Shell, siendo kernel la m&aacute;s cercana al computador y shell la m&aacute;s 
  cercana al usuario</font></i></font></p>
<p align="left">&nbsp;</p>
<p align="left"><font size="4"><b><font color="#FF3333">2.2.- Nivel Kernel</font></b></font></p>
<p></p>
<p>Dec&iacute;amos en el anterior punto que el &quot;nivel kernel&quot; es el 
  que se encarga de la gesti&oacute;n de los recursos del computador; por as&iacute; 
  decirlo, el kernel es la parte m&aacute;s interna de un sistema operativo, la 
  que maneja las cosas m&aacute;s b&aacute;sicas que este posee y da la base para 
  que podamos utilizarlo. Realizar&aacute; la gesti&oacute;n b&aacute;sica de 
  procesos (un proceso es a grandes rasgos un programa ejecut&aacute;ndose, con 
  su propio espacio virtual de direcciones de memoria tal y como indic&aacute;bamos 
  en la parte dedicada a la memoria en el cap&iacute;tulo primero), as&iacute; 
  como va a ser el encargado de proteger unos programas de ser accedidos por otros, 
  va a realizar el mantenimiento del sistema de ficheros, etc. Podemos definir 
  sus tareas como:</p>
<p><b><font color="#FF9999">- Asignaci&oacute;n de recursos:</font></b> Proporcionarlos 
  para aquellos programas que se encuentran en ejecuci&oacute;n, manteniendo para 
  ello estructuras que le permitan saber qu&eacute; recursos est&aacute;n libres 
  y cu&aacute;les est&aacute;n asignados a cada programa, teniendo en cuenta la 
  disponibilidad de los mismos; es importante la recuperaci&oacute;n de estos 
  recursos cuando los programas ya no los necesitan. Una recuperaci&oacute;n mal 
  hecha puede hacer por ejemplo que el sistema operativo considere que no tiene 
  memoria, cuando en realidad si la tiene.</p>
<p><b><font color="#FF9999">- Protecci&oacute;n: </font></b>Ha de garantizarse 
  en este nivel que existe protecci&oacute;n entre los usuarios del sistema, y 
  que la informaci&oacute;n ha de ser confidencial, asegur&aacute;ndose de que 
  unos trabajos no interfieran con otros, impidiendo que unos programas puedan 
  acceder a los recursos de otros.</p>
<p>&nbsp;</p>
<p align="left"><font size="4"><b><font color="#FF3333">2.3.- Nivel API</font></b></font></p>
<p></p>
<p>Consiste en una serie de servicios que los programas pueden solicitar, complementando 
  los que el hardware proporciona. Si s&oacute;lo cont&aacute;semos con lo que 
  nos da el hardware como servicios, al programar tendr&iacute;amos por ejemplo 
  que abrir ficheros localiz&aacute;ndolos f&iacute;sicamente en el disco duro; 
  con esta API, se nos pueden proporcionar funciones software que nos liberen 
  de esta tarea y nos faciliten las cosas convirtiendo una lectura de un sector 
  del disco duro en algo tan sencillo como &quot;abrir fichero X&quot; y &quot;leer 
  fichero X&quot;, abstrayendo el c&uacute;mulo de datos existente en el HD en 
  estas estructuras llamadas ficheros en lugar de acceder a ellos dir&eacute;ctamente. 
  As&iacute;, tenemos estas cuatro clases de servicios:</p>
<p><b><font color="#FF9999">- Ejecuci&oacute;n de programas:</font></b> Se proporcionan 
  funciones para lanzar la ejecuci&oacute;n de un programa as&iacute; como para 
  pararla o abortarla, junto con otros que sirvan para conocer y modificar las 
  condiciones de ejecuci&oacute;n de los programas, para comunicar y sincronizar 
  unos programas con otros. Como ejemplos tenemos funciones en sistemas operativos 
  Unix como exec (ejecutar un programa) o fork (reproducir el proceso actual en 
  otro espacio virtual), o en otros como Windows, algunos como CreateProcess (crear 
  proceso, indicando qu&eacute; ejecutar para &eacute;l) .</p>
<p><font color="#FF9999"><b>- Operaciones de E/S: </b></font>Proveen de operaciones 
  de lectura, escritura y modificaci&oacute;n del estado de los perif&eacute;ricos; 
  la programaci&oacute;n de estas operaciones de E/S es compleja y depende del 
  hardware en particular utilizado, ofreci&eacute;ndose con estos servicios un 
  nivel alto de abstracci&oacute;n para que el programador de aplicaciones no 
  haya de preocuparse de estos detalles. Los servicios dados por una tarjeta gr&aacute;fica 
  gracias a su driver, por ejemplo, tendr&iacute;an como objetivo ocultar la complejidad 
  del hardware espec&iacute;fico de esta tarjeta haciendo que el programador s&oacute;lo 
  tenga que escribir sus rutinas una vez, y seg&uacute;n la implementaci&oacute;n 
  particular del driver con los servicios comunes, &eacute;ste solucione la forma 
  de transformar lo programado en algo f&iacute;sico (la imagen en pantalla).</p>
<p><b><font color="#FF9999">- Operaciones sobre ficheros: </font></b>Ofrecen un 
  nivel mayor en abstracci&oacute;n que las operaciones de E/S, orientadas en 
  este caso a ficheros y por lo tanto a operaciones como la creaci&oacute;n, borrado, 
  renombrado, apertura, escritura y lectura de ficheros, llevadas a cabo con funciones 
  como en Windows ser&iacute;an CreateFile, OpenFile o CloseFile, o en sistemas 
  Posix (Unix, Linux...) funciones como open(), readdir(), close(), etc.</p>
<p><font color="#FF9999"><b>- Detecci&oacute;n y tratamiento de errores:</b></font> 
  Se trata de la parte en que se controlan los posibles errores que puedan detectarse.</p>
<p>&nbsp;</p>
<p align="left"><font size="4"><b><font color="#FF3333">2.4.- Nivel de Shell</font></b></font></p>
<p></p>
<p align="left"></p>
<p>Se trata de la parte del sistema que se encarga de atender y llevar a cabo 
  las peticiones de los usuarios del computador, proporcionando una serie de funciones 
  b&aacute;sicas que el usuario pueda llevar a cabo. El nivel de abstracci&oacute;n 
  es mayor que la API, y permite que por ejemplo al borrar un fichero el usuario 
  tenga simplemente que ejecutar<i> &quot;del fichero&quot;</i> en un sistema 
  Dos, o <i>&quot;rm fichero&quot;</i> en un Posix (Unix, Linux..) en lugar de 
  tener que programar un ejecutable que borre ese fichero llamando a funciones 
  de la API.</p>
<p>El shell es el <b>interfaz</b> con el que interactuamos normalmente, que intenta 
  crear un entorno acogedor para el usuario, intuitivo; uno de los objetivos que 
  se necesitan obtener, es que se facilite el trabajo a los usuarios novatos pero 
  que al tiempo esto no destruya la productividad de los usuarios m&aacute;s avanzados. 
  Tenemos entonces shells de tipo alfanum&eacute;rico (modo terminal en Unix, 
  o la cl&aacute;sica ventana Ms-Dos en Windows) donde el modo de trabajo se basa 
  en l&iacute;neas de texto dadas como instrucciones al sistema, y de tipo gr&aacute;fico 
  (X-Windows en Unix, entorno gr&aacute;fico de Windows) </p>
<p>Sea cual sea la forma de presentaci&oacute;n, alfanum&eacute;rica o gr&aacute;fica, 
  el shell deber&iacute;a de cumplir estas funciones:</p>
<p><b><font color="#FF9999">- Manipulaci&oacute;n de archivos y directorios:</font></b> 
  La interfaz ha de proporcionar operaciones para crear, borrar, renombrer y procesar 
  archivos y directorios. </p>
<p><font color="#FF9999"><b>- Ejecuci&oacute;n de programas: </b></font>El shell 
  o interfaz ha de proporcionar mecanismos para que desde &eacute;l se puedan 
  ejecutar programas.</p>
<p><font color="#FF9999"><b>- Herramientas para el desarrollo de aplicaciones:</b></font> 
  Debe poseer utilidades como compiladores para que el usuario pueda construir 
  sus propias aplicaciones.</p>
<p><b><font color="#FF9999">- Comunicaci&oacute;n con otros sistemas:</font></b> 
  Han de existir herramientas b&aacute;sicas para acceder a recursos localizados 
  en otros sistemas, como puedan ser telnet o ftp.</p>
<p><b><font color="#FF9999">- Informaci&oacute;n de estado del sistema:</font></b> 
  Utilidades que permitan consultar y/o cambiar cosas como la fecha, hora, n&uacute;mero 
  de usuarios conectados al sistema, cantidad de disco y de memoria disponible.</p>
<p><font color="#FF9999"><b>- Configuraci&oacute;n:</b></font> El interfaz ha 
  de ser configurable en su modo de operaci&oacute;n seg&uacute;n las preferencias 
  del usuario (por ejemplo, formato de fechas y lenguaje).</p>
<p><b><font color="#FF9999">- Seguridad:</font></b> En sistemas multiusuario (Unix, 
  Windows NT), la interfaz ha de controlar el acceso de usuarios al sistema para 
  mantener su seguridad.</p>
<p>&nbsp;</p>
<p><font size="4"><b><font color="#FF3333">2.5.- Arranque del computador</font></b></font></p>
<p></p>
<p>Cuando encendemos el ordenador, podr&iacute;amos decir que est&aacute; &quot;desnudo&quot;; 
  el sistema operativo no se ha cargado a&uacute;n y se encuentra inutilizable 
  para el usuario. As&iacute; pues, se realizar&aacute;n una serie de operaciones 
  antes de darnos el control sobre &eacute;l.</p>
<p>Primero, se ejecutar&aacute; el <font color="#FF9999"><b>iniciador ROM</b></font>; 
  en esta memoria se encuentra un programa de arranque siempre disponible (la 
  ROM no puede sobreescribirse) que va a realizar una comprobaci&oacute;n del 
  sistema averiguando cosas como la cantidad de memoria disponible y los perif&eacute;ricos 
  instalados, se asegurar&aacute; de que funcionan mediante un test, y cargar&aacute; 
  en memoria el programa de carga del sistema operativo, dando despu&eacute;s 
  el control a este programa (para dar independencia, suele hacerse que el iniciador 
  ROM sea independiente del sistema operativo instalado).</p>
<p> Si hablamos de arranque desde un disco duro, la ROM cargar&aacute; en memoria 
  lo que conocemos como<font color="#FF9999"><b> MBR o Master Boot Record</b></font>. 
  Esto, es un sector del disco duro (el primer sector f&iacute;sicamente) de 512 
  bytes que contiene la tabla de particiones del disco duro. En esta tabla se 
  indicar&aacute; como se encuentra dividido el HD (podr&iacute;amos tener por 
  ejemplo un disco duro dividido en una partici&oacute;n de 4 Gb y otra de 2Gb, 
  por cualquiera que fuese el motivo). Adem&aacute;s, se va a indicar qu&eacute; 
  partici&oacute;n es la que contiene el sistema operativo activo que se desea 
  arrancar. As&iacute; pues, el programa que hay dentro de la MBR lo que va a 
  hacer es seg&uacute;n el contenido de la tabla de particiones (dentro de esta 
  MBR) cargar el &quot;sector boot&quot;, programa de carga del sistema operativo, 
  correspondiente al que se desea arrancar. A veces sin embargo queremos tener 
  m&aacute;s de un sistema operativo instalado, como pueda ser la t&iacute;pica 
  combinaci&oacute;n Windows/Linux. En esta ocasi&oacute;n, se utilizan programas 
  m&aacute;s complejos, &quot;gestores de arranque&quot;, con los que el usuario 
  puede decidir si quiere arrancar uno u otro.</p>
<p align="center"><img src="arranque.jpg" width="500" height="200"></p>
<p>El programa de la MBR (s&oacute;lo en discos duros, puesto que en un diskette 
  no existe), pasar&aacute; el control al <font color="#FF9999"><b>sector boot 
  o programa de carga</b></font> del sistema operativo (que ocupa un sector del 
  disco duro, 512 bytes, aunque servir&aacute; sencillamente para arrancar el 
  resto). Una vez cargados los componentes se pasa a la fase de inicializaci&oacute;n 
  del sistema operativo, lo cual incluye:</p>
<p><b><font color="#FF9999">- Test del sistema: </font></b>Completa el test realizado 
  por el iniciador ROM, comprobando tambi&eacute;n que el sistema de ficheros 
  se encuentra en un estado coherente revisando los directorios.</p>
<p><font color="#FF9999"><b>- Establecimiento de estructuras</b></font> de informaci&oacute;n 
  propias del SO, como los sistemas de gesti&oacute;n de procesos, memoria y E/S.</p>
<p><font color="#FF9999"><b>- Carga en memoria principal </b></font>de las partes 
  del SO que hayan de encontrarse siempre en memoria (SO residente).</p>
<p><b><font color="#FF9999">- Creaci&oacute;n de un proceso de inicio</font></b> 
  o login por cada terminal definido en el sistema as&iacute; como una serie de 
  <i>procesos auxiliares y programas residentes en memoria</i>; el proceso de 
  login comprobar&aacute; que el usuario puede acceder al sistema pidi&eacute;ndole 
  que se identifique mediante su nombre y clave, aunque esto puede no existir 
  en sistemas Windows.</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><font size="4"><b><font color="#FF3333">2.6.- Servidor de ficheros</font></b></font></p>
<p></p>
<p><font color="#FF6666"><b>2.6.1.- Estructura de ficheros</b></font></p>
<p>Los datos en un disco duro ser&iacute;an un caos sin una estructura capaz de 
  organizarlos y presentarlos de forma coherente. &iquest;C&oacute;mo podemos 
  saber que el sector f&iacute;sico 1537 del disco duro pertenece al fichero que 
  buscamos y en qu&eacute; zonas se encuentra este repartido?. Para ello, en toda 
  partici&oacute;n existe una estructura (llamada <font color="#FF9999"><b>FAT</b></font> 
  o File Allocation Table, Tabla de Localizaci&oacute;n de Ficheros, en sistemas 
  Ms-Dos y Windows, o la estructura de <b><font color="#FF9999">i-nodes</font></b> 
  en sistemas UNIX) dedicada a esta labor. En ella, se va a mantener un registro 
  de los ficheros que pertenecen a la partici&oacute;n y d&oacute;nde se encuentran 
  f&iacute;sicamente.</p>
<p> As&iacute;, mientras nosotros hacemos referencia a un concepto abstracto como 
  ser&iacute;a &quot;el fichero c:\documentos\datos.txt&quot;, cuando accedamos 
  a &eacute;l nuestro sistema operativo traducir&aacute; esto junto con la FAT 
  a &quot;los datos que se almacenan en los sectores (x1, x2,... xn) del disco 
  duro y que juntos forman una unidad de tama&ntilde;o Z. En la tabla se indicar&aacute;n 
  adem&aacute;s, otros datos, como puedan ser los atributos del fichero (s&oacute;lo 
  lectura, oculto, o los permisos de usuario en UNIX), fechas de creaci&oacute;n 
  y &uacute;ltima modificaci&oacute;n, tama&ntilde;o, etc.</p>
<p>Sin embargo, sabemos que en el disco duro no encontramos todos los ficheros 
  juntos sino que hay una divisi&oacute;n jer&aacute;rquica en directorios (me 
  niego a utilizar la palabra &quot;carpetas&quot;) y que los ficheros est&aacute;n 
  relacionados con esos directorios perteneciendo a algunos en particular. En 
  realidad y aunque la implementaci&oacute;n var&iacute;e seg&uacute;n el sistema 
  operativo, esto es una falsa sensaci&oacute;n; un directorio puede ser un fichero 
  que contenga una serie de nombres, que ser&aacute;n referencia a otros archivos 
  o a otros directorios. As&iacute;, habr&iacute;a un directorio raiz (el c:\, 
  d:\, etc, o un / ) que contendr&iacute;a toda una serie de ficheros, de los 
  cuales algunos ser&aacute;n directorios. Estos directorios a su vez, ser&aacute;n 
  ficheros que funcionan como almacenes de nombres, de los ficheros que contienen 
  y los directorios que cuelgan de &eacute;l.</p>
<p>&nbsp;</p>
<p><font color="#FF6666"><b>2.6.2.- Acceso a ficheros</b></font></p>
<p>Cuando deseamos acceder a los contenidos de los ficheros tenemos dos maneras:</p>
<p><b><font color="#FF9999">- Uso de punteros: </font></b>Al abrir un archivo 
  para lectura/escritura, el puntero de acceso se dirigir&aacute; al inicio del 
  fichero. As&iacute;, si leemos o escribimos en &eacute;l, la operaci&oacute;n 
  se realizar&aacute; sobre su primer byte. Si modificamos el puntero para que 
  apunte a la direcci&oacute;n 800 del archivo, escribiremos o leeremos sobre 
  ella; este, es el m&eacute;todo cl&aacute;sico de leer y modificar datos contenidos 
  en un soporte f&iacute;sico.</p>
<p><font color="#FF9999"><b>- Mapeado en memoria:</b></font> Bajo varias denominaciones 
  (<i>mapeado en memoria, Memory File Mapping, proyecci&oacute;n de ficheros en 
  memoria</i>) se esconde un m&eacute;todo much&iacute;simo m&aacute;s c&oacute;modo 
  que el de punteros y que en Windows 95 supone uno de los grandes avances de 
  cara a la programaci&oacute;n (aunque avance entre comillas dado que el sistema 
  lleva a&ntilde;os funcionando bajo sistemas UNIX). Utilizando las ventajas de 
  la memoria virtual, se marcan una serie de p&aacute;ginas de memoria abarcando 
  el tama&ntilde;o del archivo de forma que apuntan a las partes del disco duro 
  donde &eacute;ste se halla. El programador escribir&aacute; o leer&aacute; dir&eacute;ctamente 
  de estas zonas de memoria como si lo hiciera del fichero; cuando los datos solicitados 
  no se encuentren en memoria (lo cual sucede siempre que se accede a una zona 
  del archivo por primera vez) se generar&aacute; un fallo de p&aacute;gina y 
  estos ser&aacute;n cargados desde el disco duro, modific&aacute;ndose o ley&eacute;ndose 
  aquello que haya sido solicitado por el programa. Cuando el fichero se cierra, 
  se guardar&aacute;n los cambios realizados en memoria.</p>
<p>Es evidente que el m&eacute;todo de acceso mediante mapeado en memoria es mucho 
  m&aacute;s c&oacute;modo dado que no hay que llamar a funciones que cambien 
  el puntero de lugar, funciones que escriban y funciones que lean, sino que basta 
  con escribir y leer en una zona de memoria accediendo dir&eacute;ctamente a 
  todos los contenidos del fichero.</p>
<p>&nbsp;</p>
<p><font color="#FF6666"><b>2.6.3.- Acceso a directorios</b></font></p>
<p></p>
<p></p>
<p>Las funciones para leer de un directorio var&iacute;an seg&uacute;n el sistema 
  operativo; hay que reconocer aqu&iacute; que a bajo nivel (ensamblador) las 
  funciones de las que est&aacute;n dotados los sistemas Windows son bastante 
  m&aacute;s sencillas que las de un Linux:</p>
<p><b><font color="#FF9999">- Sistema tipo-Windows:</font></b> Leer datos de un 
  directorio es tan sencillo como usar las funciones <b>FindFirst</b> y<b> FindNext 
  </b>que proporcionan el primer y siguientes archivos coincidentes con el patr&oacute;n 
  dado por el usuario. Podr&iacute;amos por ejemplo indicar que queremos buscar 
  &quot;*.exe&quot; (todos los ficheros con extensi&oacute;n exe), y con la primera 
  llamada a FindFirst y las siguientes ir&iacute;amos obteni&eacute;ndolos todos.</p>
<p><b><font color="#FF9999">- Sistema tipo-Linux: </font></b>Tenemos una estructura 
  interna llamada <b>Dirent</b>, entrada de directorio, a la que accederemos mediante 
  la funci&oacute;n <i><b>ReadDir</b></i>. El problema de esta funci&oacute;n 
  es la mala documentaci&oacute;n presente a este respecto, lo que hace algo m&aacute;s 
  dif&iacute;cil su manejo (readdir hace una lectura secuencial de cada entrada 
  del directorio, sea esta fichero, directorio, etc). Personalmente, para poder 
  utilizarla tuve que echarle un vistazo al c&oacute;digo fuente de Linux para 
  ver c&oacute;mo funcionaba realmente esta estructura Dirent de cara a la programaci&oacute;n 
  en ensamblador.</p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><font size="4"><b><font color="#FF3333">2.7.- Procesos</font></b></font></p>
<p><font color="#FF6666"><b>2.7.1.- Concepto de un proceso</b></font></p>
<p></p>
<p>Podemos definir un proceso como un programa en ejecuci&oacute;n; el objetivo 
  de un sistema operativo es al fin y al cabo crear, ejecutar y destruir procesos 
  de acuerdo a los deseos de los usuarios, por tanto es este un concepto fundamental 
  en el estudio de los SSOO; podemos definir entonces proceso tambi&eacute;n como 
  la unidad de procesamiento gestionada por el SO.</p>
<p>En cada procesador van a mantenerse una serie de estructuras de informaci&oacute;n 
  que permitan identificar sus caracter&iacute;sticas y los recursos que tiene 
  asignados. Una buena parte de ellas van a estar en el Bloque de Control de Proceso 
  o BCP, que contiene (en el ejemplo tipo UNIX) informaci&oacute;n como la siguiente:</p>
<p><b><font color="#FF9999">- Identificador de proceso: </font></b>Se trata del 
  <b> <i>pid</i></b>, un n&uacute;mero &uacute;nico que etiqueta al proceso para 
  no ser confundido con ning&uacute;n otro (tambi&eacute;n se va a almacenar el 
  pid del proceso padre, es decir, del que creo a &eacute;ste).</p>
<p><b><font color="#FF9999">- Identificador de usuario: </font></b>Conocido tambi&eacute;n 
  como <b><i>uid</i></b>, identifica de forma inequ&iacute;voca al usuario que 
  inici&oacute; el proceso.</p>
<p> <b><font color="#FF9999">- Estado de los registros:</font></b> Situaci&oacute;n 
  actual de los registros del procesador (&uacute;til en la multitarea puesto 
  que al volver a la ejecuci&oacute;n de un proceso que se hab&iacute;a dejado 
  de atender, han de reponerse estos registros para seguir sin problemas).</p>
<p><b><font color="#FF9999">- Descriptores:</font></b> De ficheros abiertos indicando 
  los que est&aacute; manejando el fichero, de segmentos de memoria asignados 
  y de puertos de comunicaci&oacute;n abiertos.</p>
<p>Podemos resumir por tanto un proceso como un conjunto que abarca por un lado 
  los segmentos de memoria en los que residen c&oacute;digo y datos del proceso 
  (imagen de memoria o core image), por otro lado el contenido de los registros 
  del modelo de programaci&oacute;n y finalmente el BCP ya mencionado.</p>
<p>&nbsp;</p>
<p><font color="#FF6666"><b>2.7.2.- Jerarqu&iacute;a de procesos</b></font></p>
<p>Existe un proceso de inicio original a partir del cual se crean los dem&aacute;s; 
  podr&iacute;amos entonces describir el listado de procesos como un &aacute;rbol 
  en el que un proceso originario da lugar a otros que a su vez crean m&aacute;s. 
  Cuando un proceso A solicita que al sistema operativo la creaci&oacute;n de 
  otro proceso B, se dir&aacute; entonces que A es padre del proceso B, y que 
  B es hijo del A (y el padre podr&aacute; si lo desea matar a su proceso hijo).</p>
<p>&nbsp;</p>
<p><font color="#FF6666"><b>2.7.3.- Multitarea</b></font></p>
<p>Dependiendo de las tareas y usuarios simult&aacute;neos, los sistemas operativos 
  pueden ser:</p>
<p><b><font color="#FF9999">- Monotarea: </font></b>Tambi&eacute;n monoproceso, 
  ya que s&oacute;lo permiten que haya un proceso en cada momento. Un ejemplo 
  t&iacute;pico de esto ser&iacute;a Ms-Dos.</p>
<p><b><font color="#FF9999">- Multitarea: </font></b>O multiproceso, permitiendo 
  que existan varios procesos activos al mismo tiempo, encarg&aacute;ndose el 
  sistema operativo de repartir el tiempo de procesador entre ellos. </p>
<p><b><font color="#FF9999">- Monousuario:</font></b> S&oacute;lo un usario puede 
  ser soportado a la vez, pudiendo no obstante ser mono o multiproceso.</p>
<p><b><font color="#FF9999">- Multiusuario:</font></b> En ellos, el sistema operativo 
  soporta varios usuarios a la vez en distintos terminales; un sistema as&iacute;, 
  es obligatoriamente multitarea.</p>
<p>La multitarea, se basa en el hecho de que en todo proceso que ejecutemos siempre 
  van a haber espacios en los que el microprocesador no tiene nada que hacer; 
  as&iacute;, cuando se est&eacute; esperando una operaci&oacute;n de lectura 
  del disco duro el procesador no estar&aacute; haciendo nada &uacute;til con 
  lo que su tiempo puede ser utilizado para otras tareas. As&iacute; pues, tenemos 
  un modelo m&aacute;s eficiente para la multitarea que simplemente asignar un 
  trozo de tiempo a cada proceso; podemos adaptarnos a su funcionamiento usando 
  sus tiempos de uso de la E/S en ejecutar otros procesos.</p>
<p>&nbsp;</p>
<p><font color="#FF6666"><b>2.7.4.- Ejecuci&oacute;n de un programa y formaci&oacute;n 
  de un proceso</b></font></p>
<p></p>
<p>Un fichero ejecutable va normalmente a mantener una estructura que va a incluir 
  las siguientes partes:</p>
<p><b><font color="#FF9999">- Cabecera: </font></b>Contiene informaci&oacute;n 
  acerca del ejecutable, como el estado inicial de los registros, descripciones 
  con tama&ntilde;o y localizaci&oacute;n de c&oacute;digo y datos en el archivo, 
  lugar de inicio de la ejecuci&oacute;n del programa, etc.</p>
<p><b><font color="#FF9999">- C&oacute;digo:</font></b> Aquello que al ejecutar 
  el proceso va a ser ejecutado por el sistema operativo; habr&aacute; un punto 
  de comienzo o entry point que es donde se empieza a ejecutar.</p>
<p><b><font color="#FF9999">- Datos: </font></b>Existen de dos tipos; los datos 
  inicializados por un lado van a ocupar espacio en disco, se trata de datos que 
  poseen valor desde un principio. Los datos sin inicializar no ocupan espacio 
  en el fichero, sino que va a reserv&aacute;rseles una porci&oacute;n de memoria 
  para que el programa pueda utilizarlos (ser&aacute;n inicializados desde el 
  propio c&oacute;digo).</p>
<p><b><font color="#FF9999">- Tabla de importaciones: </font></b>Har&aacute; referencia 
  a aquellas funciones que el ejecutable necesita de las librer&iacute;as del 
  sistema operativo. El motivo de no incluir estas funciones en el propio c&oacute;digo 
  es sencillo; si hay 100 ejecutables que usan la misma funci&oacute;n es mucho 
  m&aacute;s eficiente cargar la librer&iacute;a que las contiene cuando uno de 
  ellos es ejecutado que almacenar el c&oacute;digo de esta funci&oacute;n en 
  el c&oacute;digo de cada ejecutable. En este caso habremos usado 100 veces menos 
  espacio, puesto que la librer&iacute;a s&oacute;lo tiene que estar en el disco 
  duro una vez para que pueda ser utilizada por los ejecutables.</p>
<p>As&iacute; pues, cuando se inicie un proceso el sistema operativo asignar&aacute; 
  un espacio de memoria para albergarlo, seleccionar&aacute; un BCP libre de la 
  tabla de procesos rellen&aacute;ndolo con el <i>pid</i> y<i> uid</i>, descripci&oacute;n 
  de memoria asignada y dem&aacute;s, y finalmente cargar&aacute; en el segmento 
  de c&oacute;digo en memoria el c&oacute;digo y las rutinas necesarias de sistema, 
  y los datos en el segmento de datos contenido en el fichero, comenzando a ejecutar 
  en su punto inicial. Adem&aacute;s, el proceso reci&eacute;n iniciado tendr&aacute; 
  una serie de variables propias que se pasan al proceso en el momento de su creaci&oacute;n 
  como puedan ser en UNIX algunas como <b>PATH</b>, <b>TERM</b> o <b>HOME</b>, 
  adem&aacute;s de los par&aacute;metros dir&eacute;ctamente pasados <i>a trav&eacute;s 
  del shell</i>.</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><font size="4"><b><font color="#FF3333">2.8.- Seguridad</font></b></font></p>
<p></p>
<p>Existen dos grandes mecanismos para proteger la informaci&oacute;n y evitar 
  el acceso por parte de usuarios a recursos para los que no han sido habilitados. 
  Podr&iacute;amos dividirlos en dos tipos; por un lado los que se llevan a cabo 
  por parte del procesador, y por otro los que dependen del sistema operativo.</p>
<p>&nbsp;</p>
<p><font color="#FF6666"><b>2.8.1.- Rings del procesador</b></font></p>
<p></p>
<p>En un microprocesador como el 80x86, es decir, el PC com&uacute;n, existen 
  cuatro modos diferentes de ejecuci&oacute;n o rings, de los que s&oacute;lo 
  se utilizan dos (el 0 y el 3). El <b><font color="#FF9999">ring0</font></b> 
  es el modo privilegiado de ejecuci&oacute;n, mientras que el <b><font color="#FF9999">ring3</font></b> 
  es el modo de usuario. Cuando el procesador se ejecuta en modo supervisor o 
  ring0, puede acceder a la zona del kernel, escribir sobre ella si la desea, 
  controlar cualquier proceso... sin embargo en ring3 o modo usuario hay una gran 
  cantidad de limitaciones que evitan que se pueda acceder a zonas no permitidas 
  del sistema.</p>
<p>Por ejemplo, un micro ejecut&aacute;ndose en modo usuario no podr&aacute; modificar 
  en memoria el c&oacute;digo base del sistema operativo ni realizar varias operaciones 
  prohibidas, como acceder dir&eacute;ctamente a los perif&eacute;ricos (este 
  modo es en el que normalmente estamos ejecutando). Cuando queramos realizar 
  una lectura del disco duro entonces lo que haremos ser&aacute; llamar a una 
  interrupci&oacute;n pidiendo ese servicio. &iquest;Qu&eacute; har&aacute; entonces 
  el sistema operativo?. Dar&aacute; control a la zona del kernel dedicada a tratar 
  esa interrupci&oacute;n (y por tanto en esta ocasi&oacute;n de leer del disco 
  duro), pasando a modo supervisor para que se pueda realizar su funci&oacute;n. 
  Al terminar el procesamiento de la interrupci&oacute;n, el micro volver&aacute; 
  al estado de usuario y continuar&aacute; ejecutando el programa; se trata de 
  un m&eacute;todo infalible si est&aacute; bien implementado, para que el usuario 
  del ordenador jam&aacute;s pueda ser supervisor excepto en aquellas ocasiones 
  que el sistema operativo lo permita.</p>
<p>&nbsp;</p>
<p><font color="#FF6666"><b>2.8.2.- Protecci&oacute;n de usuarios y ficheros</b></font></p>
<p></p>
<p>Algunos sistemas operativos permiten el acceso a distintos usuarios mediante 
  un mecanismo llamado autenticaci&oacute;n, que se puede basar en cosas que conoce 
  el usuario (preguntar por un password, por ejemplo) o mediante t&eacute;cnicas 
  m&aacute;s complejas como tarjetas de identificaci&oacute;n o biometr&iacute;a 
  (reconocimiento de una caracter&iacute;stica f&iacute;sica del usuario como 
  su huella dactilar, pupila, etc).</p>
<p>Este sistema adquiere mucha potencia cuando se suma a un sistema fuerte de 
  protecci&oacute;n de ficheros; en los sistemas UNIX, cada fichero tiene un due&ntilde;o 
  y una serie de permisos de acceso que consisten en 9 bits: <b>&quot;rwx rwx 
  rwx&quot;</b>. El primer bloque de tres bits se refiere al usuario que es due&ntilde;o 
  del fichero (r es read, lectura, w es write, escritura, y x es exec, ejecuci&oacute;n), 
  el segundo bloque al grupo de usuarios al que pertenece el due&ntilde;o del 
  fichero y el tercero al resto del mundo. As&iacute;, supongamos este fichero:</p>
<p><b><font color="#FF9999"><u>datos.txt:</u> <font size="4">&lt; rw- r-- --- 
  &gt; </font> <i>Usuario:</i> Tifaret, <i>Grupo:</i> Arcontes</font></b></p>
<p>El archivo datos.txt pertenecer&iacute;a entonces al usuario Tifaret, el cual 
  tendr&aacute; derechos de lectura y escritura sobre &eacute;l. Todos aquellos 
  usuarios pertenecientes a su mismo grupo de usuarios (Arcontes), tendr&aacute;n 
  permiso de lectura. Finalmente, el resto de usuarios del sistema no podr&aacute; 
  acceder a este fichero.</p>
<p>Diferente es cuando estos permisos se aplican sobre un directorio; en este 
  caso siguen habiendo nueve bits pertenecientes a usuario, grupo y resto de usuarios, 
  pero la <b>r</b> especifica que el directorio se puede leer (hacer un listado 
  de sus contenidos), la <b>w</b> que se puede a&ntilde;adir o borrar ficheros 
  en &eacute;l, y la <b>x</b> que se puede atravesar para acceder a ficheros alojados 
  a partir de &eacute;l.</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
</body>
</html>
