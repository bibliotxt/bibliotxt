<html>
<head>
<title>Curso de virus (Estructura de computadores)</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
</head>

<body bgcolor="#000000" text="#FFCCCC" link="#FF6666">
<p align="center"><img src="caos-paz1.jpg" width="270" height="270"></p>
<p align="center"><font color="#FF0000" size="7"><b>I</b></font></p>
<p align="center"><font size="7" color="#FF3333">Estructura de computadores</font></p>
<p align="left">&nbsp;</p>
<p align="left"> <font size="4"><b><font color="#FF3333">1.1.- Arquitectura Von 
  Neumann</font></b></font></p>
<font color="#FFCCCC">As&iacute; se conoce la forma de estructuraci&oacute;n utilizada 
en los ordenadores actuales; desde 1945 con <b>UNIVAC</b>, se utiliza la arquitectura 
diferenciadora entre hardware y software que &eacute;l cre&oacute; (Von Neumann 
es junto con Alan Turing padre de la inform&aacute;tica moderna, y curiosamente 
el gran precursor de los virus inform&aacute;ticos en sus estudios sobre aut&oacute;matas 
autorreproductores que John Conway continu&oacute; en 1970 con el juego &quot;Life&quot;, 
antecesor a su vez de los algoritmos gen&eacute;ticos). Seg&uacute;n esta arquitectura, 
una definici&oacute;n adecuada para un computador ser&iacute;a la siguiente: </font> 
<p align="center"><font color="#FFCCCC"><i>M&aacute;quina programada de prop&oacute;sito 
  general capaz de realizar una serie de operaciones b&aacute;sicas siguiendo 
  un conjunto de instrucciones que le son proporcionadas a trav&eacute;s de un 
  programa encaminado a resolver un problema.</i></font></p>
<p align="left"><font color="#FFCCCC">Los elementos b&aacute;sicos de un computador 
  propuestos por Von Neumann y que se utilizan en la actualidad son los siguientes:</font></p>
<p align="left"><font color="#FFCCCC"><b>-<font color="#FF9999"> Memoria</font>:</b> 
  Su misi&oacute;n consiste en servir de almacenamiento de la informaci&oacute;n 
  dentro del computador, sean programas o datos, y sin hacer distinci&oacute;n 
  entre c&oacute;digo y datos (no hay una memoria para datos y otra para c&oacute;digo 
  ejecutable, est&aacute; unificada).</font></p>
<p align="left"><font color="#FFCCCC"><b>- <font color="#FF9999">Dispositivos 
  de E/S (Entrada/Salida)</font>:</b> Engloban todos aquellos perif&eacute;ricos 
  como puedan ser ratones, monitores, teclados,... es decir, todo lo que proporcione 
  datos al computador o a trav&eacute;s de lo cual salgan de &eacute;l.</font></p>
<p align="left"><font color="#FFCCCC"><b>- <font color="#FF9999">BUS de comunicaciones</font>:</b> 
  Las operaciones de accesos a datos, de manejo de perif&eacute;ricos y otras, 
  han de realizarse a trav&eacute;s de un BUS (hilos de comunicaci&oacute;n); 
  su misi&oacute;n engloba por ejemplo la transferencia de datos entre memoria 
  y procesador.</font></p>
<p align="left"></p>
<p align="left"><font color="#FFCCCC"><b>- <font color="#FF9999">CPU</font></b><font color="#FF9999"><i> 
  - Unidad Central de Proceso (Central Processing Unit)</i></font>: Es la encargada 
  de controlar y ejecutar todas las funciones del computador. Es la que determina 
  en qu&eacute; condici&oacute;n se ejecuta el c&oacute;digo y como han de mandarse 
  los datos, generando adem&aacute;s todas las se&ntilde;ales de control que afectan 
  al resto de las partes.</font></p>
<p align="left">&nbsp;</p>
<p align="left">&nbsp;</p>
<p align="left"><font size="4"><b><font color="#FF3333">1.2.- Memoria</font></b></font></p>
<p align="left"> </p>
<p align="left"><font color="#FF6666"><b>1.2.1.- Jerarqu&iacute;a de memoria</b></font></p>
<p align="left">La memoria en un computador se organiza en varios niveles que 
  se organizan en forma piramidal, en el pico aquello que es m&aacute;s r&aacute;pido 
  y tambi&eacute;n m&aacute;s escaso (registros) y en la base lo m&aacute;s lento 
  pero al tiempo m&aacute;s abundante (discos):</p>
<p align="center"><img src="piramide.jpg" width="264" height="228"></p>
<p align="center"><font size="2"><i><font color="#FFCCCC">Pir&aacute;mide de memorias 
  (seg&uacute;n su velocidad y tama&ntilde;o)</font></i></font></p>
<p align="center">&nbsp;</p>
<p align="left"><b>Los <font color="#FF9999">registros</font></b> pertenecientes 
  al microprocesador son los m&aacute;s r&aacute;pidos (con un tiempo de acceso 
  que suele estar entre 1 y 5 nanosegundos) aunque por su coste el tama&ntilde;o 
  es reducido (normalmente no m&aacute;s que 256 bytes). <b>La <font color="#FF9999">memoria 
  cach&eacute;</font></b>, m&aacute;s lenta, tarda entre 5 y 20 ns (tiempo de 
  acceso) pero con un tama&ntilde;o mayor que a pesar de todo pocas veces sobrepasa 
  el megabyte.<b> La<font color="#FF9999"> memoria principal</font></b>, lo que 
  solemos conocer como <b>RAM</b>, tiene ya un tama&ntilde;o bastante mayor - 
  las configuraciones standard de PCs dificilmente bajan ya de los 128Mb - pero 
  al tiempo un acceso m&aacute;s lento (entre 60 y 200 nanosegundos). Finalmente, 
  con la <b><font color="#FF9999">memoria secundaria</font> </b>hacemos referencia 
  normalmente al <b>disco duro</b>, que es utilizado por el ordenador como <b>memoria 
  virtual</b>.</p>
<p align="left">Entre los distintos niveles de la jerarqu&iacute;a, ha de haber 
  una correspondencia en los datos. Un nivel superior, m&aacute;s peque&ntilde;o 
  que el inferior, contendr&aacute; informaci&oacute;n proveniente de este nivel 
  m&aacute;s grande que &eacute;l, informaci&oacute;n a la que quiere acceder 
  m&aacute;s deprisa. Por ejemplo, cuando accedemos a una base de datos, esta 
  se carga en memoria para que podamos accederla a m&aacute;s velocidad; sin embargo, 
  si modificamos valores de estos datos en memoria, tendremos que hacer una actualizaci&oacute;n 
  desde la memoria al disco duro para que los cambios sean permanentes; as&iacute; 
  pues, siempre que modifiquemos algo en un nivel de la jerarqu&iacute;a, tarde 
  o temprano habr&aacute; que transferir estos cambios a los niveles inferiores 
  hasta llegar a la base de la pir&aacute;mide.</p>
<p align="left">Del mismo modo sucede en la relaci&oacute;n entre memorias cach&eacute; 
  y principal; en la memoria cach&eacute; se van a cargar partes de la memoria 
  principal que se supone van a ser m&aacute;s utilizadas que otras, con lo cual 
  cuando se produzca una modificaci&oacute;n de lo que contiene la cach&eacute;, 
  habr&aacute; que actualizar de alguna manera la memoria principal.</p>
<p align="left">Podr&iacute;amos decir lo mismo de la relaci&oacute;n entre cach&eacute; 
  y registros del micro, pero estos registros han de ser descritos m&aacute;s 
  adelante en detalle pues su importancia va a ser capital para la programaci&oacute;n 
  en lenguaje ensamblador.</p>
<p align="left">Es ya cosa de la implementaci&oacute;n de cada procesador, decidir 
  cuales son las pol&iacute;ticas de extracci&oacute;n (decidir qu&eacute; informaci&oacute;n 
  se sube al nivel superior y cuando) y de reemplazo (decidir qu&eacute; porci&oacute;n 
  de la informaci&oacute;n de ese nivel superior ha de ser eliminada).</p>
<p align="left">&nbsp;</p>
<p align="left"><font color="#FF6666"><b>1.2.2.- Memoria virtual</b></font></p>
<p align="left"></p>
<p align="left">En un sistema dotado de memoria virtual, dos niveles de la jerarqu&iacute;a 
  de memoria son tratados hasta cierto punto como si fueran uno s&oacute;lo; esto 
  es, las memorias principal y secundaria (memoria RAM y disco duro generalmente) 
  se acceden mediante lo que denominamos <b><font color="#FF9999">direcciones 
  virtuales</font></b><font color="#FF9999"> </font>(no olvidemos en cualquier 
  caso que un programa ha de residir en memoria principal para ejecutarse, al 
  igual que los datos para ser accedidos o modificados).</p>
<p align="left">Para llevar a cabo esta labor, al ejecutarse un programa se asignar&aacute; 
  un <b><font color="#FF9999">espacio virtual</font></b><font color="#FF9999"> 
  </font>a este, espacio que no va a compartir con ning&uacute;n otro programa 
  y gracias al cual tampoco va a ver a ning&uacute;n otro programa m&aacute;s 
  que al propio sistema operativo. Es decir, supongamos que tengo tres programas 
  ejecut&aacute;ndose, P1, P2 y P3, y que nuestro sistema virtual maneja direcciones 
  desde la 0x00000000 a la 0xFFFFFFFFh (en numeraci&oacute;n hexadecimal). Cada 
  uno de estos tres programas podr&aacute; ocupar la parte que quiera de esta 
  memoria virtual, y aunque dos de ellos ocuparan la misma direcci&oacute;n virtual 
  no se &quot;pisar&iacute;an&quot; dado que son procesador y sistema operativo 
  quienes mediante la <b><font color="#FF9999">MMU</font></b> (Memory Management 
  Unit) deciden a qu&eacute; parte f&iacute;sica de la memoria principal (o a 
  qu&eacute; zona de la memoria secundaria) corresponde la direcci&oacute;n virtual 
  (ojo, el espacio virtual 0x00000000 a 0xFFFFFFFFFh es independiente en cada 
  uno de los programas). Es por ello, que excepto por mecanismos que se implementen 
  a trav&eacute;s del sistema operativo, el c&oacute;digo y datos de un programa 
  no podr&aacute; ser accedido desde otro.</p>
<p align="left">En cualquier caso, un programa no puede acceder a *todo* el espacio 
  virtual, sino a la parte que le reserva el sistema operativo (volveremos a esto 
  cuando hablemos sobre procesos en la parte dedicada a SSOO), ya que parte de 
  &eacute;l estar&aacute; ocupado por c&oacute;digo perteneciente al propio sistema 
  operativo. </p>
<p align="left">Por &uacute;ltimo, destacar que este espacio virtual se divide 
  en <b><font color="#FF9999">p&aacute;ginas virtuales</font></b>, cada una normalmente 
  de 4Kb de tama&ntilde;o; sobre estas se mantendr&aacute; una <b><font color="#FF9999">tabla 
  de p&aacute;ginas</font></b>, una estructura que contiene la informaci&oacute;n 
  acerca de donde residen las p&aacute;ginas de un programa en ejecuci&oacute;n. 
  Si se intenta acceder en lectura o escritura sobre una p&aacute;gina que est&aacute; 
  en la memoria principal no habr&aacute; problemas y la MMU traducir&aacute; 
  la direcci&oacute;n virtual a la posici&oacute;n f&iacute;sica en memoria. Sin 
  embargo, si se intenta acceder a una p&aacute;gina que resida en el disco duro, 
  se generar&aacute; un <b>fallo de p&aacute;gina</b> y se cargar&aacute;n esos 
  4Kb que estaban en el disco duro sobre la memoria principal, pudiendo, ahora 
  s&iacute;, leer o escribir sobre la informaci&oacute;n contenida en ella.</p>
<p align="center"><img src="memorias.jpg" width="213" height="163"></p>
<p align="center"><font size="2"><i><font color="#FFCCCC">En un modelo muy simplificado, 
  1 bit indica si </font></i></font><font size="2"><i><font color="#FFCCCC">la 
  p&aacute;gina pertenece al disco duro o a la memoria, y su direcci&oacute;n 
  real (f&iacute;sica)</font></i> </font></p>
<p align="left">&nbsp;</p>
<p align="left"> La aplicaci&oacute;n pr&aacute;ctica la hemos visto todos en 
  sistemas como Linux o Windows; se reserva un espacio de tama&ntilde;o variable 
  como &quot;memoria virtual&quot; (el t&eacute;rmino es en realidad incorrecto 
  tal y como se utiliza en Windows, ya que la memoria virtual abarca la RAM que 
  tenemos y lo que asignemos para disco duro), y esto nos va a permitir como gran 
  ventaja cargar programas m&aacute;s grandes que la memoria que tenemos. Evidentemente, 
  si arrancamos diez programas que ocupan 20Mb cada uno en memoria y nuestra memoria 
  es tan s&oacute;lo de 128Mb no vamos a poder tenerlos a la vez en memoria, con 
  lo cual el sistema de memoria virtual se hace necesario. Lo mismo suceder&iacute;a, 
  si intentamos cargar un programa que necesita 140Mb de memoria. </p>
<p align="left"> As&iacute; pues, aquellos programas que estemos utilizando residir&aacute;n 
  en la memoria virtual, y aquellos que no, en el disco duro. Cuando utilicemos 
  los otros, las partes menos utilizadas de la memoria principal pasar&aacute;n 
  al disco duro, y se cargar&aacute;n desde &eacute;l las que estemos utilizando.</p>
<p align="left">&nbsp;</p>
<p align="left">&nbsp;</p>
<p align="left"><font size="4"><b><font color="#FF3333">1.3.- Dispositivos de 
  E/S</font></b></font></p>
<p align="left"></p>
<p align="left">Existen de entrada (rat&oacute;n, teclado, scanner), de salida 
  (monitor), y que cumplen ambas cosas (discos duros, disketeras, m&oacute;dems). 
  Los conocemos m&aacute;s como &quot;perif&eacute;ricos&quot;, y en realidad 
  cualquier cosa, desde un detector de movimiento a una c&aacute;mara de video, 
  pueden utilizarse como dispositivos de E/S.</p>
<p align="left">La tarea m&aacute;s compleja respecto a estos dispositivos, es 
  su control mediante el microprocesador; por ejemplo un m&oacute;dem conectado 
  al puerto serie de un PC ha de ponerse de acuerdo con el procesador respecto 
  a la forma de intercambiar sus datos o la velocidad con la que lo hace. Se necesita 
  que haya una coordinaci&oacute;n entre ambos para que uno lea a la misma velocidad 
  a la que el otro escribe, y para interpretar adecuadamente los datos transmitidos. 
  Adem&aacute;s, el procesador debe de mantener una jerarqu&iacute;a dando prioridad 
  antes a unos perif&eacute;ricos que a otros (atender una petici&oacute;n del 
  disco duro puede resultarnos m&aacute;s importante que atender una del teclado). 
</p>
<p align="left"><font color="#FF6666"><b>1.3.1.- Control de dispositivos de E/S</b></font></p>
<p align="left"></p>
<p align="left">Existen tres modos b&aacute;sicos de realizar operaciones de E/S: 
  programada, por interrupciones y por DMA (direct memory access):</p>
<p align="left">* La <i><b><font color="#FF9999">E/S programada</font> </b></i>exige 
  que el procesador est&eacute; pendiente de las operaciones realizadas por los 
  perif&eacute;ricos; por ejemplo, en caso de controlar mediante este sistema 
  un disco duro, la CPU tendr&iacute;a que ordenar la lectura de disco y estar 
  pendiente mediante comprobaciones de si esta lectura ha sido realizada hasta 
  que esto sea as&iacute;; este es el m&eacute;todo menos efectivo, puesto que 
  mientras la CPU est&aacute; haciendo estos chequeos para saber si la operaci&oacute;n 
  ha conclu&iacute;do no puede hacer otras cosas, lo cual reduce mucho su efectividad.</p>
<p align="left">* Con un sistema de <b><i><font color="#FF9999">E/S por interrupciones</font></i></b>, 
  el procesador se &quot;olvida&quot; una vez mandada en nuestro ejemplo esa &oacute;rden 
  de lectura de disco, y sigue ejecutando las instrucciones del programa actual. 
  Cuando esta operaci&oacute;n haya terminado, y en general cuando un perif&eacute;rico 
  tiene datos dispuestos para enviar o recibir, se generar&aacute; lo que se conoce 
  como &quot;interrupci&oacute;n&quot;; esto es, que la ejecuci&oacute;n del programa 
  por el procesador se detiene, y salta a una <b>rutina de tratamiento de interrupci&oacute;n</b> 
  que hace lo que tenga que hacer con esos datos. Salta a la vista, que este sistema 
  (utilizado con frecuencia) es mucho m&aacute;s efectivo que la E/S programada, 
  puesto que libera al procesador de estar pendiente de la finalizaci&oacute;n 
  de las operaciones de E/S.</p>
<p align="left">* Finalmente, la<b><i> <font color="#FF9999">E/S por DMA</font></i></b> 
  libera por completo al procesador no s&oacute;lo de la tarea de control sobre 
  estas operaciones como ya hac&iacute;a el sistema por interrupciones, sino tambi&eacute;n 
  del tener que preocuparse por la transferencia de los datos. Parte de la memoria 
  virtual se &quot;mapea&quot; sobre el perif&eacute;rico; esto es, si por ejemplo 
  tenemos una pantalla de 80x25 caracteres, en memoria se reservar&aacute; una 
  zona de 80x25 bytes tales que cada uno representar&aacute; un car&aacute;cter 
  (que se halla en ese momento en la pantalla). As&iacute; pues, para escribir 
  o leer lo que hay en pantalla en lugar de tener que estar el procesador enviando 
  &oacute;rdenes, se realizar&iacute;a de forma transparente, de modo que leyendo 
  de la memoria se leer&iacute;a dir&eacute;ctamente del monitor, y escribiendo 
  en ella se modificar&iacute;a lo que est&aacute; escrito sobre &eacute;l.</p>
<p align="left">&nbsp;</p>
<p align="left">&nbsp;</p>
<p align="left"><font size="4"><b><font color="#FF3333">1.4.- Buses de comunicaci&oacute;n</font></b></font></p>
<p align="left"></p>
<p align="left">Todas las operaciones mencionadas, han de realizarse a trav&eacute;s 
  de un BUS. B&aacute;sicamente, tendremos tres tipos de buses:</p>
<p align="left"><i><b><font color="#FF9999">- BUS de datos: </font></b></i>Transfiere 
  informaci&oacute;n, como su propio nombre indica. Por ejemplo, un bus de datos 
  une el procesador con los discos duros o la memoria, para que estos puedan ser 
  accedidos y su informaci&oacute;n transferida de un lugar a otro.</p>
<p align="left"><i><b><font color="#FF9999">- BUS de control:</font> </b></i>Transporta 
  las se&ntilde;ales que se utilizan para configuraci&oacute;n y control; pueden 
  ser por ejemplo se&ntilde;ales que decidan qu&eacute; perif&eacute;rico ha de 
  transmitir en un determinado momento, indicaciones para la memoria RAM de si 
  debe de leer o escribir, etc.</p>
<p align="left"><i><b><font color="#FF9999">- BUS de direcciones:</font></b></i><font color="#FF9999"> 
  </font>Su utilidad se hace patente en operaciones como accesos a memoria; transportar&iacute;a 
  la indicaci&oacute;n acerca del lugar de donde hay que leer o escribir en la 
  RAM, o en el acceso a un disco duro el lugar f&iacute;sico de este donde se 
  quiere leer o escribir.</p>
<p align="left">Estos buses se combinan constantemente para poder llevar a cabo 
  satisfactoriamente las operaciones requeridas por el procesador central. En 
  una lectura de memoria, la CPU mandar&iacute;a se&ntilde;ales para activar el 
  proceso de lectura en la RAM, mientras que por el bus de direcciones viajar&iacute;a 
  aquella direcci&oacute;n de la que se quiere leer. Una vez llegados estos datos 
  a la memoria, por el bus de datos viajar&iacute;a hasta el procesador aquella 
  informaci&oacute;n que se requiri&oacute; en un principio.</p>
<p align="left">&nbsp;</p>
<p align="left">&nbsp;</p>
<p align="left"><font size="4"><b><font color="#FF3333">1.5.- CPU</font></b></font></p>
<p align="left"></p>
<p align="left">Se trata del &quot;gran cerebro&quot; del computador, encargada 
  del control de todo lo que sucede y de la ejecuci&oacute;n del c&oacute;digo. 
  Se compone de tres partes principales; la ALU (Arithmethic-Logic Unit), la Unidad 
  de Control y la Unidad de Registros.</p>
<p align="center"><img src="ordgen.jpg" width="430" height="305"></p>
<p align="center"><font size="2"><i><font color="#FFCCCC">Modelo sencillo de un 
  procesador relacionado con memoria y dispositivos de E/S</font></i></font></p>
<p align="left">&nbsp;</p>
<p align="left"><font color="#FF6666"><b>1.5.1.- La ALU (Unidad Aritm&eacute;tico-L&oacute;gica 
  o Arithmethic-Logic Unit)</b></font></p>
<p align="left">Su misi&oacute;n es la de realizar operaciones aritm&eacute;ticas. 
  Dependen del dise&ntilde;o, aunque encontraremos como b&aacute;sicas suma y 
  resta; puede que queramos disponer de otras m&aacute;s complejas como multiplicaci&oacute;n 
  y divisi&oacute;n (para ahorrar tiempo a la hora de hacer una suma reiterada 
  en lugar de una multiplicaci&oacute;n si no estuviera implementada, por ejemplo). 
  Adem&aacute;s, tendremos operaciones l&oacute;gicas:</p>
<p align="left"><b>* <font color="#FF9999">AND</font>: </b>Un AND hecho a dos 
  bits devuelve 1 s&oacute;lo si los dos bits son 1 (por ejemplo, 011 AND 101 
  dar&aacute; como resultado 001). Equivale al &quot;Y&quot; l&oacute;gico (es 
  decir, al resultado en l&oacute;gica de algo como &quot;se da X <b>y</b> se 
  da Y&quot;, frase que s&oacute;lo ser&iacute;a verdadera en caso de darse X 
  e Y).</p>
<p align="left"><b>* <font color="#FF9999">OR</font>:</b> Un OR hecho a dos bits 
  devuelve 1 si al menos uno de los dos bits implicado en la operaci&oacute;n 
  es 1 (un 011 OR 101 da como resultado 111). Equivale al &quot;O&quot; l&oacute;gico 
  (el resultado de algo como &quot;se dan X, Y o ambos&quot;, sentencia cierta 
  en caso de darse X, Y o ambos).</p>
<p align="left"><b>* <font color="#FF9999">XOR</font>:</b> Un XOR, (eXclusive 
  OR, O exclusivo) da 1 operando sobre dos bits si uno de los dos bits es 1 y 
  el otro 0 ( la operaci&oacute;n 011 OR 101 resulta 010). Este &quot;O exclusivo&quot; 
  en l&oacute;gica es el que se dar&iacute;a en un &quot;X est&aacute; vivo o 
  est&aacute; muerto&quot;; una de las dos condiciones ha de cumplirse para que 
  esta sentencia sea cierta.</p>
<p align="left"><b>* <font color="#FF9999">NOT</font>: </b>Esta operaci&oacute;n 
  trabaja con un s&oacute;lo bit; lo que hace es invertirlo (as&iacute;, NOT 011 
  dar&aacute; 100 como resultado).</p>
<p align="left">Las operaciones con la ALU se pueden indicar mediante una se&ntilde;al 
  de control con los bits suficientes como para diferenciar entre los tipos de 
  operaci&oacute;n existentes. Es decir, si tenemos 2 bits para la se&ntilde;al 
  de control, las posibilidades de estos bits ser&aacute;n &quot;00-01-10-11&quot;, 
  lo cual da como resultado una ALU que pueda hacer cuatro funciones distintas. 
  Con 3 bits, tendr&iacute;amos &quot;000-001-010-011-100-101-110-111&quot;, es 
  decir, 8 operaciones posibles.</p>
<p align="left">Adem&aacute;s de esta se&ntilde;al de control, tendremos dos entradas 
  de datos; esto es, los operandos de la funci&oacute;n que se va a realizar. 
  As&iacute;, si queremos hacer un AND entre dos n&uacute;meros, meteremos cada 
  uno de ellos por una entrada de datos y seleccionaremos el AND. Por supuesto, 
  habr&aacute; al menos una salida conectada para el resultado de la operaci&oacute;n:</p>
<p align="center"><img src="alu.jpg" width="231" height="190"></p>
<p align="left">&nbsp;</p>
<p align="left"><font color="#FF6666"><b>1.5.2.- La Unidad de Control</b></font></p>
<p align="left"></p>
<p align="left">Es la que realiza el secuenciamiento del programa que estoy ejecutando; 
  esto es, la ejecuci&oacute;n de la instrucci&oacute;n actual y la obtenci&oacute;n 
  de la siguiente. Su funci&oacute;n es obtener las se&ntilde;ales de temporizaci&oacute;n 
  y control para ejecutar seg&uacute;n los datos que entran, determinando el funcionamiento 
  de la CPU y su comunicaci&oacute;n interna.</p>
<p align="left">Al ir a ejecutar una instrucci&oacute;n, la unidad de control 
  pedir&aacute; que sea cargada y la analizar&aacute;, viendo qu&eacute; tiene 
  que hacer en la CPU para que lo que la instrucci&oacute;n dice que ha de hacerse, 
  llegue a buen t&eacute;rmino; por ejemplo, si esta instrucci&oacute;n es un 
  AND de dos elementos, mandar&iacute;a estos dos a la ALU y activar&iacute;a 
  las se&ntilde;ales de control para que realizase un AND, para despu&eacute;s 
  transferir el resultado donde la propia instrucci&oacute;n indicase.</p>
<p align="left">&nbsp;</p>
<p align="left"><font color="#FF6666"><b>1.5.3.- La Unidad de Registros</b></font></p>
<p align="left">Tiene una gran importancia, ya que la CPU usa estos registros 
  para no tener que estar siempre accediendo a la memoria. Un registro no es m&aacute;s 
  que un &quot;pedazo&quot; de memoria con una velocidad de acceso muy grande, 
  normalmente de un tama&ntilde;o que no supera los 64 bits (siempre una cifra 
  tipo 16, 32, 64, 128...).</p>
<p align="left">Sus usos, son diversos; mientras que por ejemplo cuando se ejecuta 
  una instrucci&oacute;n esta se guarda en un registro mientras dura su procesamiento, 
  pueden usarse tambi&eacute;n para almacenar datos con los que operar o hacer 
  transferencias con la memoria, etc.</p>
<p align="left">Hay dos tipos b&aacute;sicos de registros</p>
<p align="left"><i><b>A.- Registros de prop&oacute;sito general</b></i></p>
<p align="left">Podemos darles cualquier uso. Son accesibles, visibles al programador, 
  que puede utilizarlos. Sirven para volcado de datos, instrucciones... por ejemplo, 
  en el MC68000 de Motorola, existen 16 registros de 32 bits de prop&oacute;sito 
  general (A0-A7 y D0-D7, para almacenar direcciones y datos respectivamente). 
  En otros como los 80x86 de Intel tenemos otra serie de registros de 32 bits 
  con nombres como EAX, EBX, ECX, EDX, etc...</p>
<p align="left"><i><b>B.- Registros de prop&oacute;sito espec&iacute;fico</b></i></p>
<p align="left">Son registros que utilizan la unidad de control; el programador 
  no puede utilizarlos, al menos dir&eacute;ctamente. Los principales (cuyo nombre 
  cambia seg&uacute;n cada implementaci&oacute;n pero que por lo general se suelen 
  encontrar en toda CPU) son:</p>
<p align="left"><b>-<font color="#FF9999"> IR</font>: </b>Su misi&oacute;n es 
  contener la instrucci&oacute;n que se est&aacute; ejecutando por la CPU; es 
  el Registro de Instrucci&oacute;n (o Instruction Register). Mientras la instrucci&oacute;n 
  se est&eacute; ejecutando, se contendr&aacute; ah&iacute;.</p>
<p align="left"><b>-<font color="#FF9999"> PC</font>:</b> Program Counter o Registro 
  de Contador de Programa. Su misi&oacute;n es contener la direcci&oacute;n de 
  la instrucci&oacute;n siguiente a la que estamos ejecutando. Por ello, permite 
  ejecutar un programa de modo secuencial (l&iacute;nea a l&iacute;nea), tal y 
  como ha sido programado.</p>
<p align="left"><b>- <font color="#FF9999">SR</font>:</b> Es el Registro de Estado, 
  o Status Register. Su misi&oacute;n es reflejar en cada momento en qu&eacute; 
  situaci&oacute;n se encuentran algunos detalles de la CPU (por ejemplo, almacena 
  resultados de comparaciones) de cara a tomar decisiones, as&iacute; como otros 
  par&aacute;metros que pueden necesitar ser consultados. En la mayor&iacute;a 
  de las implementaciones este registro es, al menos, accesible.</p>
<p align="left"><b>- <font color="#FF9999">SP</font>:</b> Registro de Pila o Stack 
  Pointer; la funci&oacute;n de la &quot;pila&quot; ser&aacute; explicada ya m&aacute;s 
  adelante, pero es necesario para poder hacer llamadas a funciones en programas 
  y para muchas otras cosas. </p>
<p align="left"><b>- <font color="#FF9999">MAR</font>:</b> Registro de Direcci&oacute;n 
  de Memoria (Memory Address Register): Es el que finalmente comunica la CPU con 
  el bus externo. Conclu&iacute;da la instrucci&oacute;n, el PC se vuelca en el 
  MAR, y el bus de direcciones localizar&aacute; la siguiente instrucci&oacute;n 
  seg&uacute;n el contenido de este registro.</p>
<p align="left"><b>- <font color="#FF9999">MDR</font>:</b> Registro de Datos de 
  Memoria (Data Address Register): Es el que pone en contacto la CPU y el bus 
  de datos, que contiene la informaci&oacute;n para ser transferida por &eacute;l 
  o para recibirla.</p>
<p align="left">&nbsp;</p>
<p align="left">&nbsp;</p>
<p align="left"><font size="4"><b><font color="#FF3333">1.6.- Ejemplo de un procesador 
  simple</font></b></font></p>
<p align="left">Para poner en pr&aacute;ctica lo explicado anteriormente, vamos 
  a dise&ntilde;ar y programar un procesador muy simple, que pretende servir para 
  acabar de comprender la forma de relacionarse de todos los elementos descritos.</p>
<p align="left">&nbsp;</p>
<p align="left"></p>
<p align="left"><font color="#FF6666"><b>1.6.1.- Estructura del procesador</b></font></p>
<p align="left"> Nuestro peque&ntilde;o ordenador, tendr&aacute; las siguientes 
  caracter&iacute;sticas:</p>
<p align="left">- Una memoria de 64Kb (65536 bytes), que ser&aacute; direccionable 
  con un registro MAR en el procesador de 16 bits (si se hace la operaci&oacute;n, 
  2 elevado a 16 es 65536, el mayor n&uacute;mero que un n&uacute;mero binario 
  de 16 cifras puede representar).</p>
<p align="left">- Un registro de prop&oacute;sito general de 16 bits, llamado 
  AC; adem&aacute;s, un SR (estado), MAR y MDR (datos y direcciones) y PC.</p>
<p align="left">- Una ALU en el procesador con 8 operaciones: AND, OR, NOT, XOR, 
  ADD (suma), SUB (resta), INC (incrementa en uno) y DEC (resta uno).</p>
<p align="left">&nbsp;</p>
<p align="left"><font color="#FF6666"><b>1.6.2.- Juego de instrucciones</b></font></p>
<p align="left"> </p>
<p align="left">Las instrucciones que va a poder ejecutar la CPU son las siguientes:</p>
<p align="left"><i>- Aritm&eacute;tico-l&oacute;gicas: </i>las que realiza la 
  ALU, es decir, <b><font color="#FF9999">AND, OR, NOT, XOR, ADD, SUB, INC y DEC</font>.</b></p>
<p align="left"><i>- Para mover posiciones de memoria entre s&iacute;,</i> al 
  registro AC o desde el registro AC (todo ello reunido en la instrucci&oacute;n 
  <b> &quot;<font color="#FF9999">MOV</font>&quot;</b>).</p>
<p align="left"><i>- Salto en ejecuci&oacute;n </i>(<b><font color="#FF9999">JMP</font></b>)</p>
<p align="left"></p>
<p align="left"><i>- Comparaci&oacute;n </i>(<b><font color="#FF9999">CMP</font></b>): 
  Lo que har&aacute; ser&aacute; actualizar el registro de estado en la CPU dependiendo 
  del resultado de la comparaci&oacute;n, para permitir saltos condicionales a 
  posteriori.</p>
<p align="left"><i>- Salto condicional</i> (<b><font color="#FF9999">JE</font></b> 
  -&gt; Salta si Igual (Jump if Equal), <b><font color="#FF9999">JNE</font></b> 
  -&gt; Salta si no Igual (Jump if Not Equal)).</p>
<p align="left"><i>- Parada del procesador</i> (<b><font color="#FF9999">STOP</font></b>)</p>
<p align="left">Algunos ejemplos de la implementaci&oacute;n de estas instrucciones 
  ser&iacute;an:</p>
<p align="left"><i><b>* </b><font color="#FF9999">AND [1214h],AC</font></i> -&gt; 
  realizar&iacute;a la operaci&oacute;n l&oacute;gica entre el registro AC y los 
  16 bits contenidos en la direcci&oacute;n de memoria 1214h (h significa que 
  la notaci&oacute;n del n&uacute;mero es hexadecimal), almacenando en esa posici&oacute;n 
  de memoria el resultado.</p>
<p align="left"><i><b>*</b> <font color="#FF9999">OR [1263h], [1821h]</font> </i>-&gt; 
  har&iacute;a un OR l&oacute;gico entre los contenidos de memoria de 1263h y 
  1821h, almacenando en 1263h el resultado.</p>
<p align="left"><i><b>* </b><font color="#FF9999">MOV AC,[8241h]</font></i><font color="#FFCCCC"> 
  </font>-&gt; Mover&iacute;a el contenido de la direcci&oacute;n de memoria 8241h 
  al registro AC.</p>
<p align="left"><i><b>*</b> <font color="#FF9999">JMP 2222h</font><font color="#FFCCCC"> 
  </font></i>-&gt; Cambiar&iacute;a el PC (Program Counter, es decir, la siguiente 
  instrucci&oacute;n a ser ejecutada) a la direcci&oacute;n 2222h. La instrucci&oacute;n 
  que se contenga en esa direcci&oacute;n ser&aacute; la siguiente a ser ejecutada.</p>
<p align="left"><i><b>*</b> <font color="#FF9999">CMP AC, 12</font> </i>-&gt; 
  Si el contenido del registro AC es 12, activar&iacute;a en el registro de estado 
  de la CPU un bit que indicar&iacute;a que el resultado de la ultima comparaci&oacute;n 
  es &quot;verdadero&quot;, con lo que un JE (Jump if Equal o Salta si Igual) 
  se ejecutar&iacute;a si siguiese a esa instrucci&oacute;n.</p>
<p align="left"><i><b>*</b> <font color="#FF9999">JE 1111h</font></i> -&gt; En 
  caso de que en una comparaci&oacute;n (CMP) anterior el resultado fuera verdadero 
  (por ejemplo, en el caso anterior AC vale 12), el PC cambiar&iacute;a para contener 
  1111h como direcci&oacute;n de la siguiente instrucci&oacute;n a ejecutar. En 
  caso de que la comparaci&oacute;n hubiera resultado falsa - en el caso anterior 
  que AC no valga 12 -, la instrucci&oacute;n ser&iacute;a ignorada y se ejecutar&iacute;a 
  la siguiente instrucci&oacute;n.</p>
<p align="left">&nbsp;</p>
<p align="left"><font color="#FF6666"><b>1.6.3.- Ejecuci&oacute;n de una instrucci&oacute;n 
  </b></font></p>
<p align="left"></p>
<p align="left">Podemos distinguir dos fases:</p>
<p align="left"><b><i>Fase de Fetch:</i></b> Al comienzo del procesado de una 
  nueva instrucci&oacute;n, el registro espec&iacute;fico PC de la CPU contiene 
  la direcci&oacute;n de donde esta ha de obtenerse. El contenido de este registro 
  se pasar&aacute; al MAR (Memory Address Register) transfiri&eacute;ndose a la 
  memoria mediante el bus de direcciones, y se activar&aacute; esta memoria para 
  indicar que se desea realizar una lectura sobre ella enviando una se&ntilde;al 
  adecuada a trav&eacute;s del bus de control. As&iacute;, la instrucci&oacute;n 
  llegar&aacute; hasta el MDR, de donde se enviar&aacute; a la Unidad de Control 
  para su procesamiento.</p>
<p align="left"><b><i>Procesamiento:</i></b> Una vez llega la instrucci&oacute;n 
  a la Unidad de Control, &eacute;sta distinguir&aacute; seg&uacute;n su codificaci&oacute;n 
  de qu&eacute; tipo es y realizar&aacute; las operaciones necesarias para ejecutarla. 
  Si por ejemplo es un salto tipo JMP, enviar&aacute; la direcci&oacute;n al PC 
  y dar&aacute; por terminada la ejecuci&oacute;n de la instrucci&oacute;n. Por 
  supuesto hay casos bastante m&aacute;s complejos, como podr&iacute;a ser un 
  ADD AC, 215 (sumar 215 al registro AC). En esta en particular, el procesador 
  enviar&aacute; esta cifra (215) a una de las entradas de la ALU y el registro 
  AC a la otra, indicando mediante se&ntilde;ales de control a &eacute;sta que 
  desea activar la operaci&oacute;n de sumar, ADD. Una vez realizada la operaci&oacute;n 
  dentro de la ALU, su salida se enviar&aacute; de nuevo al registro AC, con lo 
  que ahora contendr&aacute; AC+215, acabando entonces la ejecuci&oacute;n de 
  esta instrucci&oacute;n y pasando de nuevo a la fase de fetch (por supuesto 
  no sin antes sumarle al registro de contador de programa la longitud de la instrucci&oacute;n 
  que se acaba de ejecutar, para que al acceder a memoria en el fetch se cargue 
  la siguiente en la Unidad de Control).</p>
<p align="left">Dado que los ejemplos nunca sobran, veamos una instrucci&oacute;n 
  como CMP AC, 12. Una vez llegue tras la <i>fase de fetch</i> a la Unidad de 
  Control, de nuevo se utilizar&aacute; la ALU; en esta ocasi&oacute;n se la indicar&aacute; 
  mediante se&ntilde;ales de control que realice la operaci&oacute;n de resta 
  (SUB), metiendo por un lado el 12 y por otro el registro AC. Sin embargo, la 
  salida de la ALU se perder&aacute; pues lo &uacute;nico que no simporta es si 
  el resultado de la operaci&oacute;n es 0 (si el contenido de AC - 12 resulta 
  cero, est&aacute; claro que AC contiene un 12). En caso de ser por tanto AC 
  = 12, se modificar&aacute; el Registro de Estado para indicar que el resultado 
  de la anterior operaci&oacute;n fue cero, es decir, que AC vale efectivamente 
  12 (aunque no necesariamente AC, podr&iacute;amos hacer algo como CMP [1212h],16, 
  es decir, comparar 16 con el contenido de la posici&oacute;n de memoria 1212h). 
  A posteriori, de nuevo se sumar&iacute;a el tama&ntilde;o de esta instrucci&oacute;n 
  al registro PC y se har&iacute;a el fetch de la siguiente instrucci&oacute;n.</p>
<p align="left">&nbsp;</p>
<p align="left"><font color="#FF6666"><b>1.6.4.- Un programa sencillo</b></font></p>
<p align="left">Con lo que sabemos, ya podemos escribir un programa sencillo; 
  en este caso y dado que nuestro peque&ntilde;o ordenador no posee operaci&oacute;n 
  de multiplicar, lo que va a hacer la rutina siguiente es la multiplicaci&oacute;n 
  entre dos n&uacute;meros contenidos en las direcciones de memoria [1000h] y 
  [1002h], almacenando el resultado en [1004h].</p>
<pre align="left"><font color="#FF9999">		MOV AC,[1000h] ; Cargamos en AC el primer operando
		MOV [1004h],0 ; Ponemos a cero el resultado 
Bucle: 	DEC AC ; Decrementamos AC en uno 
		ADD [1004h],[1002h] ; Añadimos al resultado el segundo operando  
		CMP AC,0 
		JNE Bucle 
		STOP</font></pre>
<p align="left">La ejecuci&oacute;n de este programa es f&aacute;cil de comprender; 
  el algoritmo que utiliza para multiplicar los n&uacute;meros contenidos en 1000h 
  y 1002h es el de coger uno de ellos y sumarlo tantas veces como el otro indique 
  (por ejemplo, 7*6 se convertir&iacute;a en 7+7+7+7+7+7). Para ello lo que hace 
  es ir restando uno (con el DEC) cada vez que hace una suma del primer operando 
  sobre el resultado, y cuando este llega a cero, el JNE (Jump if Not Equal, salta 
  si no es igual) no se ejecutar&aacute; y por tanto llegar&aacute; al STOP, es 
  decir, que el programa habr&aacute; conclu&iacute;do y la operaci&oacute;n habr&aacute; 
  sido realizada.</p>
<p align="left">&nbsp;</p>
<p align="left"><font color="#FF6666"><b>1.6.5.- Lenguaje ensamblador</b></font></p>
<p align="left">El trozo de c&oacute;digo del apartado anterior est&aacute; escrito 
  en un lenguaje que el microprocesador entiende dir&eacute;ctamente gracias a 
  su unidad de control. Aunque este var&iacute;e seg&uacute;n el modelo (y tenemos 
  por ejemplo procesadores con pocas instrucciones como son los RISC o con muchas 
  como los CISC), la denominaci&oacute;n de este lenguaje b&aacute;sico del procesador 
  como <font color="#FF9999"><b>lenguaje ensamblador</b></font> se mantiene.</p>
<p align="left">M&aacute;s adelante, habr&aacute; que aprender el ensamblador 
  (o ASM) propio del PC de cara a la programaci&oacute;n de virus, pues es en 
  este lenguaje en el que se escriben. En realidad, cuando escribimos un programa 
  en cualquier otro lenguaje como pueda ser C, lo que est&aacute; haciendo el 
  compilador que traduce nuestro c&oacute;digo a un formato ejecutable es traducirlo 
  a ensamblador (l&oacute;gicamente, una m&aacute;quina no puede interpretar dir&eacute;ctamente 
  el lenguaje C). Una vez el compilador ha realizado ese trabajo de traducci&oacute;n 
  desde el lenguaje en que hemos programado a ensamblador, la m&aacute;quina ya 
  puede ejecutar nuestro programa. Es por esto, que programar dir&eacute;ctamente 
  en ensamblador nos da grandes ventajas al estar controlando al detalle qu&eacute; 
  sucede en la m&aacute;quina, qu&eacute; est&aacute; ejecutando el procesador, 
  en lugar de delegar el trabajo a compiladores sobre los que no ejercemos un 
  control directo.</p>
<p align="left">&nbsp;</p>
<p align="left">&nbsp;</p>
</body>
</html>
