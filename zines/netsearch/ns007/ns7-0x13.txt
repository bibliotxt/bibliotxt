=-[ 0x13 ]-==================================================================
=-[ NetSearch Ezine #7 ]-====================================================
=-[ Sistema de ficheros PROC v1.0 ]-=========================================
=-[ balrog@undersec.com ]-===================================================


	El sistema de ficheros PROC que casi nadie o casi nunca se le hecha
un vistazo, es bastante importante en un sistema Linux, aparte de darte
mucha información, tambien puedes especificar determinadas cosas que el
sistema hace efectivo en el momento del cambio de variable en el PROC. El
directorio /proc contiene varios subdirectorios con el nombre del ID del
proceso que esta ejecutandose en tu maquina. Los subdirectorios con ID de
procesos contienen los siguientes apartados:

 ----------------------------------------------------------
| File    Content					   |
|----------------------------------------------------------|							
| cmdline Argumentos de la linea de comandos		   |
| cwd     Enlace al directorio de trabajo por defecto	   |
| environ Valores de las variables de entorno		   |
| exe     Enlace al fichero ejecutable del proceso	   |
| fd      Directorio, que contiene todos los ficheros (1)FD|
| maps    Mapa de memoria a ficheros ejecutables y libs	   | (kernel 2.4)
| mem     Memoria ocupada por el proceso		   |
| root    Enlace al directorio padre de este proceso	   |
| stat    Estado del proceso				   |
| statm   Informacion de estado en memoria del proceso	   |
| status  Estado del proceso de forma legible		   |
 ----------------------------------------------------------

	Bueno, ya sabemos en que se compone cada proceso en el sistema de
ficheros PROC, tengo que decir que si el ordenador en el que nos encontramos
esta trabajando con mas de una CPU, apareceria otro campo mas en los
directorios de los procesos, que es el siguiente:

 ----------------------------------------------------------
| File    Content                                          |
|----------------------------------------------------------|
| cpu     En que CPU se esta ejecutando el proceso	   | (kernel 2.4)(smp)
 ----------------------------------------------------------

	Bueno, despues de especificar todo lo que contiene un proceso en el
PROC, vamos a poner un ejemplo para el que este todavia con la dudilla,
pueda resolverlo con mas facilidad:

 ----------------------------------------------------------------------------------------
| balrog# ps aux | grep 286								 |
| USER       PID %CPU %MEM   VSZ  RSS TTY      STAT START   TIME COMMAND 		 |
| postfix    286  0.0  0.4  3156 1112 ?        S    09:29   0:00 pickup -l -t | fifo -c	 |
 ----------------------------------------------------------------------------------------

	En mi caso voy a coger el proceso 286 que esta asignado al postfix, 
que es el servidor de correo que tengo instalado en mi sistema, ahora vamos al
directorio /proc/286 (el 286 corresponde al PID del proceso) y veamos que
contiene el directorio:

 ---------------------------------------------------------------------------------------
| -r--r--r--    1 root     root            0 jul 11 10:00 cmdline			|
| lrwxrwxrwx    1 root     root            0 jul 11 10:00 cwd -> /var/spool/postfix	|
| -r--------    1 root     root            0 jul 11 10:00 environ			|
| lrwxrwxrwx    1 root     root            0 jul 11 10:00 exe -> /usr/lib/postfix/pickup|
| dr-x------    2 root     root            0 jul 11 10:00 fd				|
| -r--r--r--    1 root     root            0 jul 11 10:00 maps				|
| -rw-------    1 root     root            0 jul 11 10:00 mem				|
| lrwxrwxrwx    1 root     root            0 jul 11 10:00 root -> /var/spool/postfix	|
| -r--r--r--    1 root     root            0 jul 11 10:00 stat				|
| -r--r--r--    1 root     root            0 jul 11 10:00 statm				|
| -r--r--r--    1 root     root            0 jul 11 10:00 status			|
 ---------------------------------------------------------------------------------------

	Ahora iremos comprobando de uno en uno los ficheros que contiene el
directorio /proc/286 que pertenece al proceso "postfix" para ir mirando lo
que contiene y que podais comprobar que lo que dije anteriormente en la
tabla principal, era todo cierto y no me estaba hechando un farol :P,
empezaremos:

 ---------------------
| balrog# cat cmdline |
| pickup-l-tfifo-c    |
 ---------------------

	Como vemos, el argumento que se le pasa al proceso es "pickup-l-tfifo-c",
vamos a comprobarlo haciendo un "ps aux | grep pickup" y veremos como sale
lo siguiente:

 --------------------------------------------------------------------------------------
| balrog# ps aux | grep pickup							       |
| USER       PID %CPU %MEM   VSZ  RSS TTY      STAT START   TIME COMMAND	       |
| postfix    286  0.0  0.4  3156 1112 ?        S    09:29   0:00 pickup -l -t fifo -c  |
 --------------------------------------------------------------------------------------

	Ya se que os estareis preguntando porque en el fichero "cmdline"
esta todo junto y en el "ps aux" sale con espacios, pues muy simple, porque
no reconoce los espacios y por eso lo mete todo junto. Sigamos con los
ficheros, los ficheros enlace no los explicare porque en la tabla que puse
anteriormente estan bien explicados ya.

 ---------------------------------------------
| balrog# cat environ			      |
| MAIL_CONFIG=/etc/postfixMAIL_LOGTAG=postfix |
 ---------------------------------------------

 ------------------------------------------------------------------------------------------------
| balrog# cd fd/										 |
| balrog# ls -l											 |
| dr-x------    2 root     root            0 jul 11 10:28 .					 |
| dr-xr-xr-x    3 postfix  postfix         0 jul 11 09:57 ..					 |
| lrwx------    1 root     root           64 jul 11 10:28 0 -> /dev/null			 |
| lrwx------    1 root     root           64 jul 11 10:28 1 -> /dev/null			 |
| lrwx------    1 root     root           64 jul 11 10:28 2 -> /dev/null			 |
| lrwx------    1 root     root           64 jul 11 10:28 3 -> socket:[336]			 |
| lrwx------    1 root     root           64 jul 11 10:28 4 -> /var/spool/postfix/public/pickup  |
| lrwx------    1 root     root           64 jul 11 10:28 5 -> socket:[410]			 |
 ------------------------------------------------------------------------------------------------

 ---------------------------------------------------------------------------
| balrog# cat maps							    |
| 08048000-0804a000 r-xp 00000000 03:01 701358     /usr/lib/postfix/pickup  |
| 0804a000-0804b000 rw-p 00001000 03:01 701358     /usr/lib/postfix/pickup  |
| 0804b000-08051000 rwxp 00000000 00:00 0				    |
| 40000000-40014000 r-xp 00000000 03:01 81535      /lib/ld-2.2.3.so	    |
| 40014000-40015000 rw-p 00013000 03:01 81535      /lib/ld-2.2.3.so	    |
| ... (hay mucho mas pero lo he omitido)				    |
 ---------------------------------------------------------------------------

 -----------------------------------------------------------------------------
| balrog# cat stat							      |
| 286 (pickup) S 284 284 284 0 -1 256 31 0 279 0 2 0 0 0 9 0 0 33300 7620     |
| 3231744 278 4294967295 134512640 134518656 3221225176 3221223348 1076010126 |
| 0 0 16781312 8192 3222508593 0 0 17 0					      |
 -----------------------------------------------------------------------------

 ------------------------
| balrog# cat statm	 |
| 278 278 229 3 0 275 49 |
 ------------------------

	La explicacion de los siete numeros que nos salen en el contenido
del fichero statm, significan los siguiente respectivamente:

1.- Size: Espacio total del proceso
2.- Resident: Porcion de espacio en memoria
3.- Shared: Numero de paginas que esta utilizando
4.- Trs: Numero de paginas que esta 'code' (no entendia esto)
5.- Drs: Numero de paginas de data/stack
6.- Lrs: Numero de paginas de librerias
7.- Dt: Numero de paginas sucias (dirty :?)

 ----------------------------------------
| balrog# cat status			 |
| Name:   pickup			 |
| State:  S (sleeping)			 |
| Pid:    286				 |
| PPid:   284				 |
| TracerPid:      0			 |
| Uid:    0       101     0       101	 |
| Gid:    0       101     101     101	 |
| FDSize: 256				 |
| Groups: 101				 |
| VmSize:     3156 kB			 |
| VmLck:         0 kB			 |
| VmRSS:      1112 kB			 |
| VmData:      228 kB			 |
| VmStk:        12 kB			 |
| VmExe:         8 kB			 |
| VmLib:      2784 kB			 |
| SigPnd: 0000000000000000		 |
| SigBlk: 0000000000000000		 |
| SigIgn: 8000000001001000		 |
| SigCgt: 0000000000002000		 |
| CapInh: 0000000000000000		 |
| CapPrm: 00000000fffffeff		 |
| CapEff: 0000000000000000		 |
 ----------------------------------------

	Bueno, como vemos, desde el proc se puede sacar todo tipo de
informacion necesaria de un proceso, cualquier cosa que quieras consultar lo
puedes hacer desde el proc, con solo hacer un "cat" del fichero que te de la
informacion necesaria, ahora pasaremos a especificar los demas ficheros que
nos podemos encontrar en el /proc, son ficheros de datos y especifican mas
información que puedes consultar. Empecemos a ver que significa cada uno de
estos ficheros, tengo que especificar que segun los modulos de kernel que
tengas activados o lo que tengas cargado en el kernel, tendras mas o menos
ficheros de datos que te puedan dar información del sistema, por ejemplo, si
no tienes cargado el modulo de APM, no tendras el fichero /proc/apm ... y
asi con todos los ficheros que ahora mismo voy a explicar:

 ------------------------------------------------------------------------------------------------
| File        Content										 |
|------------------------------------------------------------------------------------------------
| apm         Informacion avanzada de manejo de potencia (Advanced power management)		 |
| bus         El directorio contiene la informacion especificada del BUS			 |
| cmdline     Linea de comandos del kernel							 |
| cpuinfo     Informacion sobre la CPU								 |
| devices     Dispositivos instalados (block and character)					 |
| dma         Los canales DMS usuados								 | 
| filesystems Sistemas de ficheros soportados							 |
| driver      Directorio que contiene los drivers instalados (ej, rtc ...) (Kernel 2.4)		 |
| execdomains Execdomains, relativo a la seguridad (kernel 2.4)					 |
| fb          Dispositivos de Frame Buffer (Kernel 2.4)						 |
| fs          Dir. de parametros del sistema de fichero, por defecto nfs/exports (Kernel 2.4)	 |
| ide         Directorio que contiene informacion sobre subsistemas IDE				 |
| interrupts  Interrupciones usadas								 |
| iomem       Mapa de memoria (Kernel 2.4)							 |
| ioports     Puertos de Entrada/Salida usados (I/O)						 |
| irq         Masks for irq to cpu affinity (Kernel 2.4)(smp?) (no se lo que es)		 |
| isapnp      Informacion de PnP ISA (Plug&Play) (Kernel 2.4)					 |
| kcore       Kernel core image (puede ser ELF o A.OUT(deprecated in 2.4))			 |
| kmsg        Mensajes de kernel								 |
| ksyms       Tabla de simbolos del kernel							 |
| loadavg     Carga del procesador en 1, 5 y 15 minutos						 |
| locks       Bloqueos del kernel								 |
| meminfo     Informacion de memoria								 |
| misc        Otros										 |
| modules     Lista de modulos cargados en el kernel						 |
| mounts      Sistemas de ficheros montados							 |
| net         Directorio de informacion de red							 |
| partitions  Tabla de particion conocidas en el sistema					 |
| pci         Informacion de PCI								 |
| rtc         Reloj de tiempo real								 | 
| scsi        Informacion sobre SCSI								 |
| slabinfo    Informacion del la pila Slab							 |
| stat        Estadisticas									 |
| swaps       Espacio utilizado por la Swap							 |
| sys         (Este apartado lo analizaremos mas adelante)					 |
| sysvipc     Informacion de SysVIPC (msg, sem, shm) (Kernel 2.4)				 |
| tty         Informacion de los drivers de tty							 |
| uptime      Tiempo en el que no se apago el sistema						 |
| version     Version del Kernel								 |
| video       Informacion sobre dispositivos de video (Kernel 2.4)				 |
 ------------------------------------------------------------------------------------------------

	Bien, despues de el toston que os he metido con todas las
explicaciones de todos los ficheros y directorios del /proc, vamos a pasar a
explicarlos tranquilamente con ejemplos, porque mejor que visualizar un
ejemplo, no hay nada. No voy a poner ejemplos de todos, ya que sino se haria
eterno el documento y no es plan, que sino aburriria, eso ya cada uno lo que
le guste informarse de su sistema, pero creo que es bastante interesante
saber todo esto, ya que te puede ayudar bastante en determinados casos :P.
Pues empezaremos a explicar algunos ficheros interesantes:

 -----------------------
| balrog# cat devices	|
| Character devices:	|
|   1 mem		|
|   2 pty		|
|   3 ttyp		|
|   4 ttyS		|
|   5 cua		|
|   7 vcs		|
|  10 misc		|
|  13 input		|
|  14 sound		|
|  29 fb		|
| 128 ptm		|
| 136 pts		|
| 162 raw		|
| 180 usb		|
| 195 nvidia		|
|			|
| Block devices:	|
|  2 fd			|
|  3 ide0		|
|  7 loop		|
| 43 nbd		|
 -----------------------

	Este fichero nos especifica como dije anteriormente, todos los
dispositivos que tenemos en el sistema, ya sean de "Bloque" o de "Caracter"
(para mas informacion sobre dispositivos de Bloque o de Caracter, leerse un
buen manual de iniciado de Linux, es lo primero que se explica). No habra
que decir que esto es lo que yo tengo instalado en mi sistema, eso significa
que seguramente no saldra lo mismo en tu maquina si lo estas probando,
tambien tengo que especificar que en todo momento los "cat" los estoy
ejecutando dentro del directorio "/proc". De este fichero nada mas que decir
:)

 --------------------------
| balrog# cat filesystems  |	
| nodev   sockfs	   |
| nodev   shm		   |
| nodev   pipefs	   |
| nodev   proc		   |
|         ext2		   |
|         iso9660	   |
| nodev   smbfs		   |
| nodev   nfs		   |
| nodev   devpts	   |
|         vfat		   |
|         ntfs		   |
 --------------------------

	Este fichero te especifica todos los Sistemas de ficheros que tienes
cargados en tu sistema, la etiqueta "nodev" es porque no es un dispositivo,
como todos sabemos ext2 es el FS principal, los demas son añadidos, como el
vfat que es para poder montar dispositivos con vfat de windows y ver los
nombres largos, o el mismo ntfs, para poder montar particiones de Windows NT
o 2000 ....

 -----------------------------------------
| balrog# cat cpuinfo			  |
| processor       : 0			  |
| vendor_id       : GenuineIntel	  |
| cpu family      : 6			  |
| model           : 7			  |
| model name      : Pentium III (Katmai)  |
| stepping        : 3			  |
| cpu MHz         : 501.140		  |
| cache size      : 512 KB		  |
| ... (hay mas opciones)		  |
 -----------------------------------------

	Este fichero no hace falta que lo comente mucho jejeje, informacion
general de la CPU que tienes instalada. Si tuvieras mas de una CPU, pues te
especificaria de una en una toda la informacion de las CPUs que tienes.

 -------------------------------
| balrog# cat partitions	|
| major minor  #blocks  name	|
|				|
|   3     0   10007928 hda	|
|   3     1    5855661 hda1	|
|   3     2     240975 hda2	|
|   3     3    2867602 hda3	|
 -------------------------------

	Las particiones que tengo hechas en mis discos duros, si tuviera
algun disco duro mas, pues tambien saldria en este fichero.

 ---------------------------------------------------------
| balrog# cat modules					  |
| NVdriver              625968   0 (autoclean)		  |
| es1371                 24944   0			  |
| ac97_codec              7680   0 [es1371]		  |
| soundcore               3888   4 [es1371]		  |
| usb-uhci               21776   0 (unused)		  |
| usbmouse                1888   0 (unused)		  |
| usbcore                31024   0 [usb-uhci usbmouse]	  |
| mousedev                3968   1			  |
| input                   3328   0 [usbmouse mousedev]	  |
| 8139too                14752   1			  |
| ntfs                   35184   0 (unused)		  |
| vfat                   10448   0 (unused)		  |
| nls_iso8859-15          3392   0 (unused)		  |
| nls_iso8859-1           2880   0 (unused)		  |
| nls_cp850               3616   0 (unused)		  |
| nls_cp437               4384   0 (unused)		  |
| fat                    30272   0 [vfat]		  |
| rtc                     5280   0			  |
| nvram                   3840   0 (unused)		  |
| nbd                    14832   0 (unused)		  |
| loop                    7952   0 (unused)		  |
 ---------------------------------------------------------

	Como dije anteriormente, este fichero contiene los modulos que
tenemos cargado en el sistema y nos dice si esta siendo utilizado o no el
modulo, como vemos, tengo un monton de modulos cargados en el sistema y es
porque a mi me gusta que el kernel ocupe poco y todo lo que pueda cargar
como modulo, lo hago, asi el kernel me ocupa nada y puedo descargar y cargar
los modulos cuando me apetezcan o cuando el sistema los necesite, de la otra
forma, siempre estan cargados y eso come memoria, aunque ahora con lo barata
que esta la memoria, no nos importa mucho :DDDDDDDD :)

	Bueno, os invito a que veais el contenido de todos los ficheros del
directorio /proc, y que veais que se puede conseguir de cada uno de ellos,
hay cosas interesantes y otras que no te enteras ni de la mitad de las
cosas, pero seria bueno que se hechara un vistacito a los ficheros, asi te
vas familiarizando con tu sistema ;)

	Ahora pasaremos al directorio /proc/ide para ver mas informacion del
sistema, miremos su estructura de directorio:

 -------------------------------------------------------------------------
| dr-xr-xr-x    3 root     root            0 jul 11 12:16 .		  |
| dr-xr-xr-x   41 root     root            0 jul 11 09:28 ..		  |
| -r--r--r--    1 root     root            0 jul 11 12:16 drivers	  |
| lrwxrwxrwx    1 root     root            8 jul 11 12:16 hda -> ide0/hda |
| lrwxrwxrwx    1 root     root            8 jul 11 12:16 hdb -> ide0/hdb |
| dr-xr-xr-x    4 root     root            0 jul 11 12:16 ide0		  |
 -------------------------------------------------------------------------

	Miraremos los drivers que estan cargados en el sistema para manejar
los dispositivos IDE, y en mi caso veo lo siguiente:

 -------------------------
| balrog# cat drivers	  |
| ide-cdrom version 4.59  |
| ide-disk version 1.10   |
 -------------------------

	Se puede sacar mas informacion mirando el subdirectorio ide0, ide1,
.... segun cuantos dispositivos tengas instalados, en mi caso solo tengo un
ide ocupado y es el 0, el PRIMARIO. Si miramos dentro del directorio ideN
(donde N es el numero de IDE que quieres sacar informacion), veremos lo
siguiente mas o menos:

 -------------------------------------------------------------------
| dr-xr-xr-x    4 root     root            0 jul 11 12:19 .	    |
| dr-xr-xr-x    3 root     root            0 jul 11 12:16 ..	    |
| -r--r--r--    1 root     root            0 jul 11 12:20 channel   |
| -rw-r--r--    1 root     root            0 jul 11 12:20 config    |
| dr-xr-xr-x    2 root     root            0 jul 11 12:20 hda	    |
| dr-xr-xr-x    2 root     root            0 jul 11 12:20 hdb	    |
| -r--r--r--    1 root     root            0 jul 11 12:20 mate	    |
| -r--r--r--    1 root     root            0 jul 11 12:20 model	    |
 -------------------------------------------------------------------

	Si miramos bien, hay dos directorios, el de "hda" y el de "hdb", eso
significa que tengo dos dispositivos magneticos y como vimos anteriormente
que tenia cargado en los drivers, un ide-cdrom y un ide-disk, deberiamos
suponer que el "hda" es el disco duro primario y el "hdb" es el CDROM que
esta como secundario del canal ide0. Una maquina que solo tenga dos IDE
(ide0 y ide1), y tuviera en los dos IDE dos dispositivos en cada uno, pues
tendria en el directorio ide0, hda y hdb; y en el ide1 tendria, hdc y hdd.
Como tampoco quiero extenderme mucho, vamos a entrar al directorio hda que
es el que seguramente tendremos todos (sino tienes SCSI claro ...).

	El directorio hda contiene toda la informacion necesaria para el
sistema de que tiene el disco duro, cache, capacidad, geometria,
identificacion, configuracion .... con el comando "cat" puedes mirar de una
en una sus ficheros para sacar informacion de tu disco duro, yo por ejemplo
voy a poner un ejemplo de solo uno de los ficheros de "/proc/ide/ide0/hda":

 --------------------
| balrog# cat model  |
| FUJITSU MPF3102AT  |
 --------------------

	Bueno, ya sabemos que discu duro tenemos instalado en el sistema, si
fueramos a hdb (si lo tuvieramos claro), y vemos el mismo fichero (el
"model"), pues nos daria que modelo de dispositivo tendriamos en "hdb", y
hasta aqui esta este directorio explicado, no creo que se tengan muchas
dudas, no ?

	Ahora pasaremos al directorio /proc/net que es bastante interesante,
por lo menos si estas administrando una maquina o simplemente quieres dejar
a punto tu sistema, nos deparara muchas sorpresas, cosas que haciamos antes
con programas ajenos al sistema, veremos como tambien lo podremos hacer
desde kernel, y nada mejor que lo haga el kernel, que dejar a merced algo
tan importante a un programa ajeno al sistema ;)

	Primero tienes que saber que protocolo estas utilizando para
trabajar con el sistema de IP, si es la version 4 o la version 6 (ipv4 o
ipv6), si estuvieras trabajando con la version 6 de IP, entonces te
aparecerian los protocolos precedidos de un 6, por ejemplo ... en vez de
udp, pues udp6 y asi con todos. Pero vamos a estudiar lo que de verdad vamos
a ver hoy por hoy en cualquier maquina, que es el ipv4 y el sistema de
ficheros es el siguiente (/proc/net/):

 -----------------------------------------------------------------------
| -r--r--r--    1 root     root            0 jul 11 14:51 arp		|
| -r--r--r--    1 root     root            0 jul 11 14:51 dev		|
| -r--r--r--    1 root     root            0 jul 11 14:51 dev_mcast	|
| -r--r--r--    1 root     root            0 jul 11 14:51 netlink	|
| -r--r--r--    1 root     root            0 jul 11 14:51 netstat	|
| -r--r--r--    1 root     root            0 jul 11 14:51 packet	|
| -r--r--r--    1 root     root            0 jul 11 14:51 raw		|
| -r--r--r--    1 root     root            0 jul 11 14:51 route		|
| dr-xr-xr-x    2 root     root            0 jul 11 14:51 rpc		|
| -r--r--r--    1 root     root            0 jul 11 14:51 rt_cache	|
| -r--r--r--    1 root     root            0 jul 11 14:51 snmp		|
| -r--r--r--    1 root     root            0 jul 11 14:51 sockstat	|
| -r--r--r--    1 root     root            0 jul 11 14:51 softnet_stat	|
| -r--r--r--    1 root     root            0 jul 11 14:51 tcp		|
| -r--r--r--    1 root     root            0 jul 11 14:51 udp		|
| -r--r--r--    1 root     root            0 jul 11 14:51 unix		|
 -----------------------------------------------------------------------

	Sigo diciendo que lo que estoy poniendo en las tablas, es segun
tengas compilado el kernel, pondre ahora que puede aparecer en ese
directorio e iremos mirando los contenidos de los ficheros a ver que se
pueden hacer con ellos, todo el proc es como si fuera volatil, segun lo que
tengas compilado en el kernel, van a salir mas o menos ficheros en el
directorio /proc. Expliquemos todas las variantes que pueden surgir en
/proc/net:

 -------------------------------------------------------------------------
| File          Content							  |
|-------------------------------------------------------------------------|
| arp           Tabla de ARP del kernel					  |
| dev           Estadisticas de los dispositivos de red			  |
| dev_mcast     La capa Layer2 del grupo multicast de los dispositivos    |
|               que estan a la escucha (interface index, label, number of |
|		references, number of bound addresses).			  |
| dev_stat      Estado de los dispositivos de red			  |
| ip_fwchains   Enlace a las reglas de Firewall				  |
| ip_fwnames    Nombres de las reglas de Firewall			  |
| ip_masq       Directorio que contiene la tabla de enmascarado		  |
| ip_masquerade Major masquerading table				  |
| netstat       Estadisticas de red					  |
| raw           Estadisticas de los dispositivos RAW			  |
| route         Tabla de rutado del kernel				  |
| rpc           Directorio que contiene informacion sobre RPC		  |
| rt_cache      Cache de rutado						  |
| snmp          Datos SNMP						  |
| sockstat      Estadisticas de los Sockets				  |
| tcp           Sockets TCP						  |
| tr_rif        Tabla de rutado de una red Token ring 			  |
| udp           Socket UDP						  |
| unix          Socket de dominio UNIX (UNIX domain)			  |
| wireless      Wireless interface data (Wavelan etc)			  |
| igmp          IP multicast addresses, which this host joined		  |
| psched        Parametros de paquetes globales planificados		  |
| netlink       Lista de PF_NETLINK sockets				  |
| ip_mr_vifs    Lista de interfaces con multicast virtual		  |
| ip_mr_cache   Lista de cache de rutado de multicast			  |
 -------------------------------------------------------------------------

	Bueno, este directorio todavia es de informacion, no se puede tocar
nada de el ni modificar sino es via kernel (compilando y añadiendo nuevas
cosas), pondre dos ejemplos de lo que podemos conseguir de este directorio,
por ejemplo, imaginate que no sabes si la eth0 esta añadida como
dispositivo, pues haciendo un "cat /proc/net/dev" podrias mirar si esta el
dispositivo añadido en el sistema y aparte ver si ha transmitido algo, la
salida por pantalla seria algo parecido a lo siguiente:

 -------------------------------------------------------------------------------
| balrog# cat /proc/net/dev							|
|Inter-|   Receive                                                |  Transmit	|
|-------------------------------------------------------------------------------|
| face |bytes    packets errs drop fifo frame compressed multicast|   bytes	|
|      | packets errs drop fifo colls carrier compressed	  |		|
|-------------------------------------------------------------------------------|
|  lo: | 732        8      0   0    0     0        0         0	  |      732	|
|      |    8      0   0    0     0       0        0		  |		|
|-------------------------------------------------------------------------------|
| eth0:|1566700714 2241528  0   0    0    0        0         0	  |   20265435	|
|      | 306531   0     0   0    3390     0        0		  |		|
 -------------------------------------------------------------------------------

	Espero que entendais cada campo a que corresponde, solo tendreis que
mirar linea por linea los numeros y comparar con las etiquetas que hay
arriba, como vemos, tengo dos dispositivos de red y estan transmitiendo
bien, eso significa que no tengo ningun problema con los dispositivos que
tengo instalados, ademas, hay una etiqueta que pone "errs", si vemos en los
dos dispositivos tengo 0, eso significa que no ha habido ningun error, ahora
vamos hacer una prueba, voy a desconectar el cable de red a ver si me sale
algun error. Y la salida ahora del "cat" es la siguiente:

 -------------------------------------------------------------------------------
| balrog# cat /proc/net/dev							|
|Inter-|   Receive                                                |  Transmit   |
|-------------------------------------------------------------------------------|
| face |bytes    packets errs drop fifo frame compressed multicast|   bytes	|
|      | packets errs drop fifo colls carrier compressed          |		|
|-------------------------------------------------------------------------------|
|  lo: | 732        8      0   0    0     0        0         0    |      732	|
|      |    8      0   0    0     0       0        0              |		|
|-------------------------------------------------------------------------------|
| eth0:|1566700714 2241528  0   0    0    0        0         0    |   20265435  |
|      | 306586   (4)     0   0    3390     0        0            |		|
 -------------------------------------------------------------------------------

	Como vemos, el numero que esta entre "()", nos esta especificando
que hemos recibido 4 errores, elemental, habia quitado el cable de red
jejejeje, pues mas o menos nos coscamos de que va la cosa, no ? un apartado
bastante importante para sacar informacion del estado de la red del equipo
que estamos tratando :)

	Bueno, despues de empaparnos de tanta informacion sobre nuestra
maquina, vamos a pasar a escribir determinados valores a ficheros del
sistema, eso se puede hacer en /proc/sys y a eso vamos a ir, a explicar cada
una de las cosas que podamos hacer. 

	Vamos a entrar al directorio "fs/" y vamos a ver que se puede hacer
en él, por ahora cambiaremos la cantidad de ficheros que el sistema puede
procesar a la vez, por defecto tenemos que el sistema puede procesar
simultaneamente 4096 ficheros, pues vamos a ponerle que procese 8192, el
doble ;), cuando un programa una serie de programas te esta dando problemas
de limitacion de ficheros abiertos en el sistema, la variable que dire mas
adelante, es la que tenemos que cambiar en el sistema, para que admita mas
ficheros abiertos simultaneamente:

 ----------------------
| balrog# cat file-max |
| 4096		       |
 ----------------------

	Lo que no he dicho que para ponerle un nuevo valor a file-max se
utiliza normalmente el comando "echo" y es lo que vamos hacer, pongamos que
el sistema admita 8192 ficheros abiertos simultaneamente:

 -------------------------------
| balrog# echo 8192 > file-max  |
| balrog# cat file-max		|
| 8192				|
 -------------------------------

	Pues ya ta, ahora ya tenemos el sistema preparado para que pueda
tener 8192 ficheros abiertos simultaneamente, no pasaros con la cantidad, ya
que abrir tantos ficheros simultaneamente come recursos del sistema y
memoria y los recursos del sistema no son indefinidos y la memoria menos ;P

	Hay muchos mas parametros en este directorio, pero que no voy a
explicar porque quiero tratar otras cosas mas adelante y ya se va alargando
el documento que inicialmente queria hacer.

	Hablemos ahora del directorio /proc/sys/kernel que es mas
interesante jejejeje, pues a ello vamos:

 -----------------------------------------------------------------------
| -rw-r--r--    1 root     root            0 jul 11 15:38 acct		|
| -rw-------    1 root     root            0 jul 11 15:38 cap-bound	|
| -rw-r--r--    1 root     root            0 jul 11 15:38 ctrl-alt-del	|
| -rw-r--r--    1 root     root            0 jul 11 15:38 domainname	|
| -rw-r--r--    1 root     root            0 jul 11 15:38 hostname	|
| -rw-r--r--    1 root     root            0 jul 11 15:38 modprobe	|
| -rw-r--r--    1 root     root            0 jul 11 15:38 msgmax	|
| -rw-r--r--    1 root     root            0 jul 11 15:38 msgmnb	|
| -rw-r--r--    1 root     root            0 jul 11 15:38 msgmni	|
| -r--r--r--    1 root     root            0 jul 11 15:38 osrelease	|
| -r--r--r--    1 root     root            0 jul 11 15:38 ostype	|
| -rw-r--r--    1 root     root            0 jul 11 15:38 overflowgid	|
| -rw-r--r--    1 root     root            0 jul 11 15:38 overflowuid	|
| -rw-r--r--    1 root     root            0 jul 11 15:38 panic		|
| -rw-r--r--    1 root     root            0 jul 11 15:38 printk	|
| dr-xr-xr-x    2 root     root            0 jul 11 15:38 random	|
| -rw-r--r--    1 root     root            0 jul 11 15:38 rtsig-max	|
| -r--r--r--    1 root     root            0 jul 11 15:38 rtsig-nr	|
| -rw-r--r--    1 root     root            0 jul 11 15:38 sem		|
| -rw-r--r--    1 root     root            0 jul 11 15:38 shmall	|
| -rw-r--r--    1 root     root            0 jul 11 15:38 shmmax	|
| -rw-r--r--    1 root     root            0 jul 11 15:38 shmmni	|
| -rw-r--r--    1 root     root            0 jul 11 15:38 threads-max	|
| -r--r--r--    1 root     root            0 jul 11 15:38 version	|
 -----------------------------------------------------------------------

	Empezaremos de uno en uno, y ver que se puede hacer con el fichero
en cuestion:

- acct:
 Este fichero contiene tres valores: highwater, lowwater, and frequency
Solo existe cuando activamos en el kernel lo de "BSD Process Accounting",
conque si no lo tienes o modificas el fichero y no ocurre nada, es porque no
lo tienes activado en el kernel, ya sabes que tienes que hacer.
El valor "frequency" determina el tiempo en segundos que checkea el espacio
libre. El valor "lowwater" es el porcentaje mas bajo que permites en la
cuenta, si supera ese minimo la cuenta queda suspendida. El valor
"highwater" es el porcentaje mas alto que permites en la cuenta, si supera
ese maximo la cuenta queda suspendida. Para poner un nuevo valor que no sea
el por defecto que es 4-2-30 (4% maximo, 2% minimo y 30 seg), pues se hace
de la siguiente forma:

 -------------------------------
| balrog# cat acct		|
| 4       2       30		|
| balrog# echo "6 4 30" > acct	|
| balrog# cat acct		|
| 6       4       30		|
 -------------------------------

- ctrl-alt-del:
 Si el valor de esta variable es 0, la convinacion de las teclas
CTRL+ALT+DEL son efectivas y hace el reboot de la maquina, si colocas un 1,
la maquina no rebootea, desactiva ese tipo de función. para poner 1 al
fichero ctrl-alt-del pues se hace lo siguiente:

 -------------------------------
| balrog# cat ctrl-alt-del	|
| 0				|
| balrog# echo 1 > ctrl-alt-del	|
| balrog# cat ctrl-alt-del	|
| 1				|
 -------------------------------

- domainname y hostname:
Estos dos ficheros contienen el dominio y el nombre de la maquina
respectivamente y no creo que haga falta explicarlos mucho, la sintaxis para
cambiarlos a mano, es igual que la anterior, con el "echo":

 ---------------------------------------
| balrog# cat domainname		|
| undersec.com				| 
| balrog# cat hostname			|
| balrog				|
| balrog# echo "probando" > hostname	|
| balrog# cat hostname			|
| probando				|
| ... (Igual con el "domainname")	|	|
 ---------------------------------------

- osrelease, ostype y version:
Estos tres ficheros contienen la version de tu kernel, el sistema que es y
la la fecha y veces de su compilacion respectivamente:

 ---------------------------------------
| balrog# cat osrelease			|
| 2.4.3					|
| balrog# cat ostype			|
| Linux					|
| balrog# cat version			|
| #12 lun may 28 13:37:16 GMT 2001	|
 ---------------------------------------

- panic:
Este fichero se utiliza para poner el tiempo en segundos que quieres que
tarde para rebootear la maquina si ocurre un kernel panic en el sistema, por
defecto esta desactivado que es 0, pero puedes ponerle que tenga X segundos,
yo le pongo 30, por si se produce ver la salida del error por pantalla, para
modificarlo, pues:

 -------------------------
| balrog# echo 30 > panic |
| balrog# cat panic	  |
| 30			  |
 -------------------------

- printk:
Tiene 4 valores este fichero:
	- console_loglevel
	- default_message_loglevel
	- minimum_console_level
	- default_console_loglevel
Estos valores influyen en la funcion printk() donde escriba o loguee los
mensajes de error, que vengan del kernel. Los niveles los especifico ahora:

KERN_EMERG    "<0>"  /* el sistema no es utilizable
KERN_ALERT    "<1>"  /* debe tomarse una acción inmediata
KERN_CRIT     "<2>"  /* condiciones críticas
KERN_ERR      "<3>"  /* condiciones de error
KERN_WARNING  "<4>"  /* condiciones de advertencia
KERN_NOTICE   "<5>"  /* condición normal pero significativa
KERN_INFO     "<6>"  /* información
KERN_DEBUG    "<7>"  /* mensajes del nivel de depuración

No me metere en temas de programación porque no lo veo necesario para este
documento, al final del documento pondre de donde he sacado todo esto para
que el que quiera investigar mas, pueda hacerlo libremente ;)

Ahora explico que significa cada valor del fichero printk:

- console_loglevel: Los mensajes que tengan una alta prioridad se escribiran
en la consola.
- default_message_level: Los mensajes que tengan una especifica prioridad,
tendras que escribirse con esa prioridad.
- minimum_console_loglevel: El minimo valor que la consola puede
configurarse.
- default_console_loglevel: Por defecto el valor de console_loglevel.

	Bueno despues de mirarnos el directorio /proc/sys/kernel, vamos a
pasar ahora al de Memoria Virtual, que tambien es interesante, ahora
entraremos al directorio /proc/sys/vm y a listo lo que se puede hacer con
los ficheros que podemos encontrarnos alli:

- bdflush:
Este fichero controla el trabajo del demonio bdflush del kernel. Contiene 9
digitos enteros, 6 digitos los utiliza el kernel, cada digito significa lo
siguiente:

 -----------------------------------------------------------------------
| balrog# cat bdflush							|
| 30      64      64      256     500     3000    60      0       0	|
 -----------------------------------------------------------------------

 ----------------------------------------------------------------------------------
| Value      Meaning								   |
|----------------------------------------------------------------------------------|
| nfract     Percentage of buffer cache dirty to  activate bdflush		   |
| ndirty     Maximum number of dirty blocks to  write out per wake-cycle	   |
| nrefill    Number of clean buffers to try to obtain  each time we call refill	   |
| nref_dirt  buffer threshold for activating bdflush when trying to refil buffers  |
| dummy      Unused								   |
| age_buffer Time for normal buffer to age before we flush it			   |
| age_super  Time for superblock to age before we flush it			   |
| dummy      Unused								   |
| dummy      Unused								   |
 ----------------------------------------------------------------------------------

	Todas estas variables vienen explicadas en el documento que podras
encontrar en /usr/src/linux/Documentation/filesystem/proc.txt, y encontraras
mucho mas que lo que he puesto yo, esto es una guia basica para aprender a
utilizar el proc o saber para que sirve o que nos puede dar :)

	Ahora vamos a pasar a la parte de red al directorio /proc/sys/net,
si entramos y hechamos un vistazo en ese directorio veremos como tiene
varios subdirectorios, explicare para que sirve cada uno:

 ----------------------------------------------------------------
| Directory Content                Directory  Content		 |
|----------------------------------------------------------------|
| core      Parametros generales   appletalk  Protocolo Appletalk|
| unix      Socket Unix domain     netrom     NET/ROM		 |
| 802       Protocolo E802         ax25       AX25		 |
| ethernet  Protocolo Ethernet     rose       Capa X.25 PLP	 |
| ipv4      IP version 4           x25        Protocolo X.25	 |
| ipx       IPX                    token-ring IBM token ring	 |
| bridge    Bridging               decnet     Red DEC		 |
| ipv6      IP version 6					 |
 ----------------------------------------------------------------

	Vamos a empezar a analizar el directorio /proc/sys/net/core y en el
directorio core podemos encontrarnos los siguientes ficheros, en mi caso
tengo lo siguiente:

 ---------------------------------------------------------------------------
| -rw-r--r--    1 root     root            0 jul 12 12:25 hot_list_length   |
| -rw-r--r--    1 root     root            0 jul 12 12:25 lo_cong	    |
| -rw-r--r--    1 root     root            0 jul 12 12:25 message_burst	    |
| -rw-r--r--    1 root     root            0 jul 12 12:25 message_cost	    |
| -rw-r--r--    1 root     root            0 jul 12 12:25 mod_cong	    |
| -rw-r--r--    1 root     root            0 jul 12 12:25 netdev_max_backlog|
| -rw-r--r--    1 root     root            0 jul 12 12:25 no_cong	    |
| -rw-r--r--    1 root     root            0 jul 12 12:25 no_cong_thresh    |
| -rw-r--r--    1 root     root            0 jul 12 12:25 optmem_max	    |
| -rw-r--r--    1 root     root            0 jul 12 12:25 rmem_default	    |
| -rw-r--r--    1 root     root            0 jul 12 12:25 rmem_max	    |
| -rw-r--r--    1 root     root            0 jul 12 12:25 wmem_default	    |
| -rw-r--r--    1 root     root            0 jul 12 12:25 wmem_max	    |
 ---------------------------------------------------------------------------

Expliquemos algunas de los ficheros mas caracteristicos que podamos
modificar o simplemente sacar información de como tenemos el sistema:

- rmem_default:
Son los byte por defecto que un socket puede recibir, en este caso por
defecto esta a 65535 bytes, este campo se dejara como dice por defecto.

- rmem_max:
Son los bytes maximos que un socket puede recibir, por defecto lo tiene a
65535, pero a nosotros nos interese que un socket pueda recibir como maximo,
70000 en vez de 65535, conque vamos a cambiarlo:

 ---------------------------------------
| balrog# cat rmem_default              |
| 65535                                 |
| balrog# echo 70000 > rmem_default     |
| balrog# cat rmem_default              |
| 70000                                 |
 ---------------------------------------

Bueno, ahora el sistema esta capacitado para recibir por un socket 70000
bytes como maximo, hemos progresado un poquito, no pasaros con los valores
que le pongais a estas variables, porque todo esto son recursos del sistema
y piensa que si le pones una barbaridad de bytes, los datos que envies a un
socket se tendrian que fragmentar, con la consecuencia de la bajada de
rendimiento que eso supondria, cuando menos se fragmente los datos, mejor
para la maquina, yo os recomiendo dejarlo por defecto, a 65535.

- wmem_default:
Igual que el "rmem_default" pero como su primera letra indica "(w)rite", es
los bytes por defecto que un socket puede enviar. Por defecto son 65535.

- wmem_max:
Son los bytes maximos que un socket puede enviar, por defecto tiene 65535.
Imaginaros que queremos que nuestro sistema, pueda recibir por un socket
como mucho 70000 bytes y que tenemos un programa internamente en la misma
maquina que lo que hace es establecer un socket a nuestra maquina y enviar
una serie de datos por el, pues seria interesante tener tanto "wmem_max"
como "rmem_max" con el mismo valor, en este caso 70000, asi podriamos
enviar/recibir lo mismo por un socket, es un ejemplo casero :P

- message_burst and message_cost:
Estos parametros se utilizan para limitar los mensajes de "warning" que se
escriben en el log del kernel para el codigo de red. Un alto factor en el
"message_cost" significa que los resultados se escriben muy poco en el log
de kernel. El "message_burst" controla cuando son los mensajes borrados, por
defecto esta a 5 segundos, si queremos que que se escriban constantemente
los mensajes de kernel, pues se baja el numero de "message_cost" (por
defecto tiene 50), si queremos que los mensajes del log del kernel se borren
mas tarde que 5 segundos, pues modificamos el fichero "message_burst" y le
ponemos 10 segundos, no es muy recomendable que pongas bajos estos dos
numeros, ya que harias que el kernel trabajara mucho con el tema de los log
y eso haria bajar el rendimiento a la maquina, el valor por defecto es el
adecuado, ahora, cada uno con su paranoia.

- netdev_max_backlog:
Es el numero de paquetes que el interface puede recibir rapidamente para que
pueda procesarlo el kernel, por defecto esta a 300 paquetes, subamos a 500
paquetes:

 -----------------------------------------------
| balrog# cat netdev_max_backlog		|
| 300						|
| balrog# echo 500 > netdev_max_backlog		|
| balrog# cat netdev_max_backlog		|
| 500						|
 -----------------------------------------------

Bueno, del directorio "core/" ya tenemos lo mas interesante que yo creia
conveniente, pasaremos ahora a otro directorio a ver si vamos aligerando el
documento, porque ya se esta haciendo demasiado extenso x'DDDD

	Bueno.... vamos a empezar con el directorio /proc/sys/net/ipv4, este
directorio contiene mucha chicha, conque seguramente me extienda bastante,
intentare hacerlo lo más resumido posible. Con este directorio podemos
controlar todo lo relacionado a este protocolo, ya sea icmp, tcp, udp ....,
ahora explicaremos los ficheros que nos podremos encontrar en él:

- icmp_echo_ignore_all y icmp_echo_ignore_broadcasts:
Estos ficheros pueden contener (0) o (1) (off o on respectivamente), si
crees que es necesario que el kernel ignore todos los icmp echo request,
tendrias que ponerle el valor (1) al fichero "icmp_echo_ignore_all", de la
siguiente forma:

 ---------------------------------------
| balrog# cat icmp_echo_ignore_all	|
| 0					|
| balrog# echo 1 > icmp_echo_ignore_all	|
| balrog# cat icmp_echo_ignore_all	|
| 1					|
 ---------------------------------------

Veamos los dos resultados poniendo uno y poniendo cero haciendo un ping a
nuestra maquina, vamos a ver ....:

 ---------------------------------------------------------------
| balrog# echo 0 > icmp_echo_ignore_all				|
| balrog# ping -c 1 localhost					|
| PING localhost (127.0.0.1): 56 data bytes			|
| 64 bytes from 127.0.0.1: icmp_seq=0 ttl=255 time=0.0 ms	|
| 								|
| --- localhost ping statistics ---				|
| 1 packets transmitted, 1 packets received, 0% packet loss	|
| round-trip min/avg/max = 0.0/0.0/0.0 ms			|
 ---------------------------------------------------------------

Como vemos si desactivamos este fichero poniendole 0, el localhost contesta,
tanto localhost como cualquier interface de red que tengas en el sistema
instalado y funcionando correctamente, ahora vamos a activarlo a ver que
ocurre:

 ---------------------------------------------------------------
| balrog# echo 1 > icmp_echo_ignore_all				|
| balrog# ping -c 1 localhost					|
| PING localhost (127.0.0.1): 56 data bytes			|
|								|
| --- localhost ping statistics ---				|
| 1 packets transmitted, 0 packets received, 100% packet loss	|
 ---------------------------------------------------------------

Como vemos, si activamos este fichero ignora todos los echo request que
reciba, pasando de ellos totalmente, esto es una de las opciones que tiene
cualquier firewall de hoy en dia, cuando como vemos lo podemos hacer desde
el kernel, tan facil como poner un (1) en el fichero "icmp_echo_ignore_all"
;)

La otra variable "icmp_echo_ignore_broadcasts" ignora cualquier icmp echo
que se pueda enviar por broadcast o multicasting, una cosa muy importante y
que hay varias redes que no se han dado cuenta todavia, antiguamente y ahora
tambien se hace, se cogian muchas maquinas que tenian esto abierto y
trabajaban con multicast y desde esa maquina se floodeaban otras maquinas
spoofeando la ip de origen. Es importante que si tenemos el fichero
"icmp_echo_ignore_all" desactivado, pongamos activado el de
"icmp_echo_ignore_broadcasts" ya que sino cualquier persona podria utilizar
floodearnos utilizando broadcast o multicast, yo por su defecto tengo
desactivada las dos, asi me evito de problemas, estas variables son mas
importantes en un servidor que rute a internet que en una maquina de casa,
ya que si por esa maquina que ruta, llega a pasar una direccion broadcast,
se puede liar la de dios. Un hipotetico ataque seria el siguiente:

1.- Un tio que este aburrido y con ganas de jugar.
2.- Coge una lista de broadcast con el multicast activado.
3.- Coge el smurf.
4.- Convina el smurf con la lista de broadcast y pone como origen de la IP,
pues tu maquina.
5.- Te comes todas las respuestas de todas las maquinas que esten activas en
la broadcast.
6.- Reza para que no te vayas al garete.

El problema ya no es tuyo, es de los routers que hay por delante tuyo, que
dejan pasar las direcciones broadcast, pues en esos routers seria necesario
denegar lo de las broadcast, activando el fichero
"icmp_echo_ignore_broadcasts" si fuera un linux.

- icmp_destunreach_rate, icmp_echoreply_rate, icmp_paramprob_rate and
icmp_timeexeed_rate:
Configuras los limites para enviar ICMP a un especificado host. El valor 0
desactiva las limitaciones.

- ip_autoconfig:
Esta fichero contendra 1 si el dispositivo de red se configura via RARP,
BOOTP, DHCP o similares.

- ip_default_ttl:
TTL (tiempo de vida) para el protocolo IPv4 de tus dispositivos de red. Esto
es el maximo numero de saltos (hops) que el paquete realizara en el viaje a
su destino.

- ip_dynaddr:
Activa la direccion de socket dinamica para reescribir en dispositivos de
red que cambien de direccion. Esto se activa normalmente cuando tienes
conexiones "dialup" y cambian la direccion cada vez que conectas. Si esta a
0 esta desactivada y a 1 se activa.

- ip_forward:
Activa o desactiva el paso de paquetes entre interfaces de red. Un cambio en
este fichero inicia todos los demas parametros que normalmente esten por
defecto. Normalmente se activa para maquinas que hagan de router.

- ip_local_port_range:
Rango de puertos usados por TCP y UDP para seleccionar los puertos locales.
Contiene dos numeros, el primer numero es el puerto bajo, y el segundo
numero es el puerto alto. Por defecto esta de 1024 a 4999, eso significa que
localmente la maquina puede abrir 3975 puertos locales y que asignara a los
puertos que sean locales ese rango. Pongamos por ejemplo que necesites un
rango mas alto de puertos para abrir localmente ... pues esto no nos
serviria, entonces hay que cambiarlo para mas alta disponibilidad y eso se
hace de la siguiente forma:

 -------------------------------------------------------
| balrog# cat ip_local_port_range			|
| 1024    4999						|
| balrog# echo "32768 61000" > ip_local_port_range	|
| balrog# cat ip_local_port_range			|
| 32768   61000						|
 -------------------------------------------------------

Ahora hemos subido la disponibilidad de puertos que pueda abrir la maquina
localmente y la diferencia es mucho mayor tambien.

- ip_masq_debug:
Como su nombre indica, es para activar o desactivar el debug del IP
masquerade, para maquinas que esten realizando esa función.

- ip_always_defrag:
Esto remplaza la variable de kernel en las opciones:
        CONFIG_IP_ALWAYS_DEFRAG
Todos los paquetes de entrada que sean recibidos por el dispositivo de red
(partes de paquetes IP que son demasiado largos y se tienen que cortar en
pequeños trozos) se resensamblan (defragmentan) anteas de empezar el
proceso, si estan forwadeados.

Solo si esta activado si se ejecuta en una maquina FIREWALL en tu red o en
un proxy transparente; nunca activarlo si la maquina va a ser un router
normal.

Esto se activa automaticamente cuando se activa el enmascaramiento (ipmasq).

En mi caso como mi maquina no hace de router y es una estacion de trabajo
normal, lo tengo desactivado (0).

- ipfrag_high_thresh y ipfrag_low_thresh:
Maxima y minima memoria usada para resensamblar los paquetes fragmentados.
En el fichero "ipfrag_high_trash" es la memoria maxima destinada para este
proposito. Ejemplo:

 -----------------------------------------------
| balrog# cat ipfrag_high_thresh		|
| 262144					|
| balrog# cat ipfrag_low_thresh			|
| 196608					|
| balrog# echo "70000" > ipfrag_high_thresh	|
| balrog# cat ipfrag_high_thresh		|
| 70000						|
| balrog# echo "30000" > ipfrag_low_thresh	|
| balrog# cat ipfrag_low_thresh			|
| 30000						|
 -----------------------------------------------

En mi caso como tengo 262144 mb de memoria me pillo el maximo para el
fichero "ipfrag_high_thresh" pero yo que se que siempre no podra estar
disponible esa memoria, porque la maquina tiene procesos que tambien consume
su trocito de memoria, voy a poner un valor mas bajo porque veo suficiente
tener 70 mb para ese proposito y para la minima le coloco 30 mb. Pongamos
por ejemplo que tienes tantos paquetes resensamblando en tu ordenador que va
a consumir memoria que no tiene... la carga del sistema seria muy elevada,
con 70 mb me aseguro de que nunca le falte esos 70 mb e igual pasa con los
30 mb del minimo.

- ipfrag_time
El tiempo en segundos que guarda un paquete fragmentado en memoria. Yo dejo
el de por defecto que son 15 segundos. Si tienes poca memoria, tienes que
bajar ese valor para que no se almacene por mucho tiempo los paquetes
fragmentados en memoria llegando a quedarte sin memoria en algun momento.
Algun tipo de prueba se podria hacer elevando este valor para ver si se
podria llegar a consumir toda la memoria recibiendo/recibiendo paquetes
fragmentados, quien sabe... a lo mejor nos espera una denegacion de
servicio.

- tcp_keepalive_probes:
El numero de veces que envia los paquetes TCP, hasta que se decide que la
conexion es fallida. El valor por defecto es 9, se podria bajar este valor
para no tener que enviar esos 9 paquetes TCP para saber si la otra maquina
responde o no, ya que con 4 paquetes creo que es mas que suficiente, conque
nos ponemos manos al a obra y modificamos el valor del fichero de la
siguiente forma:

 ---------------------------------------
| balrog# cat tcp_keepalive_probes	|
| 9					|
| balrog# echo 4 > tcp_keepalive_probes	|
| balrog# cat tcp_keepalive_probes	|
| 4					|
 ---------------------------------------

- tcp_syn_retries:
Numero de tiempo inicial para la retransmision de paquetes SYN en las
conexiones TCP. No debe superar los 255. Esto es un timeout para las
conexiones salientes. En la documentacion no pone en que esta medido, pero
suponiendo el valor bajo por defecto que tiene es logico que pueda ser en
segundos, el valor por defecto es 10.

- tcp_syncookies:
Solo es valido si el kernel esta compliado con la opcion CONFIG_SYNCOOKIES.
Envia syscookies cuando el syn backlog da un socket overflow. Esto es para
prevenir ataques de flood por SYN. Por defecto esta desactivado.

- tcp_fin_timeout:
Los segundos que espera al final de un paquete con el flag FIN cuando el
socket este cerrado. Esto es estrictamente una violacion de las
especificaciones del TCP, pero previene ataque de denegacion de servicio.
Por defecto esta a 180 segundos.

---------------------------- THE END POR AHORA --------------------------

Bueno, creo que se estaba extendiendo mucho el documento por eso he querido
dejarlo por ahora aqui, esta sera la version light, la 1.0 digamos, para la
proxima version terminare con lo que me queda que no es poco. Dare una
referencia para los que se lean el documento y quieran insistentemente
seguir con el y no este la version 2.0, pues en la documentacion de las
fuentes del kernel de linux, en el directorio "Documentation/" hay un
fichero que se llama "proc.txt", normalmente esta en
"Documentation/filesystems/" pero te lo puedes encontrar en el raiz del
directorio "Documentation/". Pues eso, que el que quiera seguir o ver mucho
mas contenido de este documento que empece a realizar para estar documentado
yo mismo del sistema de ficheros proc que creia que era importante y mi
mini-estudio sobre él me ha dado la razon, es importante en el sistema y se
pueden hacer muchas cosas. Espero que sirva de ayuda a la gente que como yo
tiene lagunas sobre este sistema de ficheros.

Sin nada mas que objetar se despide un humilde servidor.
