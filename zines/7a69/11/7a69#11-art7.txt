-=( 7A69 E-zine 11 )=--=( art5 )=--=( Programacion en Perl )=--=( OvErDrIvE )=-
					
                ======================================
                        Programacion en Perl I
                ======================================

He decidido escribir este primer apartado como introducciÛn a PERL y conceptos
de programaciÛn en PERL, pero tengo pensado escribir 3 o 4 apartados mas en 
numeros posteriores o quizas mas, ya veremos. De paso mando un saludo a 
markit0s, que es el que me introdujo y me ha ayudado a aprender este lenguaje
de programacion y muchas cosas mas. De momento este es el primer apartado,que
es el basico, en el proximo texto que sera de un nivel medio, mas tarde el 
tercer texto que sera avanzado y posiblemente un cuarto texto de Perl orientado
a objetos. Estos articulos los he escrito siguiendo algunos libros de Perl que
he leido. Bien, sin mas pre·mbulos comencemos.

        ========
        =Indice=
        ========
          + Introduccion a Perl
          + Conceptos basicos
          + El primer programa
          + Almacenamiento de datos
          + Operadores
          + Secuencias de escape
          + Matrices
          + Procesamientos de datos en Perl
          + Otros operadores
          + Operadores para trabajar con valores numÈricos
          + Operaciones con cadenas de texto
          + Operadores para comparaciones numericas
          + Operadores para comparar cadenas
          + Sentencias y bucles
          + Ruptura de bucles
          + STDIN y STDOUT

        ===================
        Introduccion a Perl
        ===================

En este documento intentara explicar una parte de programaci¢n en PERL
que significa Practical Extraction and Report Language. Perl a diferencia de
los lenguajes de los lenguajes de programaci¢n tradicionales como c/c++, no
necesita un compilador para generar programas ejecutables. Un programa en Perl
es un archivo de texto, este puede ejecutarse sin mas que utilizar un 
interprete Perl.

Perl, en un principio se dise§o para extraer informacion de ficheros de texto y
generar informes.

La versi¢n 5 de perl (actualmente la £ltima), soporta programacion orientada a 
objetos. Debido a sus ra°ces Perl ha sido siempre popular entre los 
administradores de sistemas UNIX, cuando la World Wide Web se empezo ahacer 
popular y hubo necesidad de programas CGI (Common Gateway Interface o
Interfaz de Pasarela Com£n), perl, comenz¢ a "crecer", y es es estandar para
escribir programas CGI.

        =================
        Conceptos basicos
        =================

        No quiero extenderme mucho en este apartado, pero deber† saber el
significado de los siguientes conceptos en cualquier lenguaje de programaci¢n:

        - Variables: Almacenan datos. El contenido de la variable es su valor.
                Ejemplo; $nombre_del_libro
                         $precio_del_libro
        - Expresiones: Combinan variables usando operadores.
                Ejemplo; $precio_total = $precio_del_libro * 10;
                (Calcular°a el precio de 10 libros).
        - Sentencias: Realizan alguna acci¢n, como asignar un valor a una
                      variable o visualizar una cadena...
                Ejemplo; $nombre_del_libro = "El Quijote";
        - Sentencias de control de flujo: Son la estructura condicional
                                          if-then-else y bucles do-while.
                Ejemplo; if ($precio_total > 1000)
                         {
                                print "Ha gastado m†s de lo permitido\n";
                         }
                         else
                         {
                                print "Ha gastado menos del tope 1000\n";
                         }
        - Funciones: Agrupan distintas sentencias y se les da un nombre.

        ==================
        El primer programa
        ==================

        El primer programa, como siempre ser† el m†s simple, sacaremos una
cadena de caracteres por la salida est†ndar (la pantalla). Haremos el t°pico
programa para novatos, el hello world. Copie el siguiente c¢digo y gu†rdelo
como un archivo hola.pl

        #!usr/bin/perl
        #primer programa en perl
        print "Hola mundo!!!\n";

        Bien, no hay mucho que explicar, pero si a alguien no le ha quedado
claro, comentarÇ l°nea por l°nea el programa. La primera linea de programa
indica al sistema unix, que el fichero con el que est† trabajando es un
programa escrito en Perl. La segunda linea, es un comentario (todo lo que
comience por # escepto la primera linea, el programa los ignorar† y solo sirve
para que el programador, haga aclaraciones, notas, etc.). La tercera l°nea
utiliza la funci¢n print para sacar por pantalla lo que sigue entre comillas.
El \n indica una nueva l°nea.

        Facil, no? la verdad es que m†s simple no pod°a ser. Pero he decidido
empezar desde 0, para que todo el mundo lo entienda, aunque no sepa nada de
programaci¢n y nunca haya programado.

        Para ejecutar el programa en un sistema unix o variantes, deberemos de
hacelo ejecutable, si est† familiarizado con cualquier sistema unix, seguro
que esto lo tiene demasiado claro. Para ello utilice el comando chmod de la
siguiente forma: chmod +x hola.pl. Luego ejecutelo escribiendo perl hola.pl.

        =======================
        Almacenamiento de datos
        =======================

Los datos se almacenan en variables, para luego trabajar con ellos.
Hay 4 tipos de almacenamiento de datos:

        - Variables escalares: almacenan elementos de datos £nicos.
                Ejemplo; $precio = 2500;
                         $autor = "Robert L. Ziegler";
        - Variables matriciales/arrays: son listas de variables escalares.
                Ejemplo; @comandos = ("Nuevo", "Abrir", "Guardar", "Salir");
        - Matrices asociativas: son colecciones de parejas clave, en las que
                                la clave es una cadena y el valor es cualquier
                                valor escalar.
                Ejemplo; %gastos = ("Javi" => 200.9,
                                    "Pedro => 190,
                                    "Raul => 1900.95");

        Hagamos un segundo programa, donde por ejemplo, calcule el precio, de
cierto producto y saque cierta informaci¢n por pantalla:

        #!usr/bin/perl
        # Calcula el precio de cualquier producto

        #Definimos las variables
        $titulo = "El Quijote";
        $precio = "7995";
        $numero = "5";
        
        #Expresi¢n donde se calcula el total
        $total = $precio * $numero

        #Sacamos la informaci¢n por pantalla
        print "El precio de $numero libros $titulo es de $total\n";

        Bien, ya tenemos el segundo programa, en el cual podemos cambiar el
valor de las variables a nuestro antojo, seg£n el caso que sea. Intente hacer
un programa que calcule por ejemplo el iva de un producto, ver† como es muy
simple.

        ==========
        Operadores
        ==========

        Los operadores son los siguientes:

                + Suma
                - Resta
                * Multiplica
                / divide

        Hay m†s operadores, pero de momento, utilice estos. A medida que vaya
avanzando utilizar† m†s operadores.

        ====================
        Secuencias de escape
        ====================

        La secuencia de escape es la barra invertida seguida por uno o m†s
caracteres. Son las siguientes:

        \a  --> pitido
        \b  --> espacio atr†s
        \cn --> control+N (N es cualquier car†cter)
        \e  --> car†cter de escape
        \f  --> comienzo de la siguiente p†gina
        \l  --> convierte la siguiente letra en min£scula
        \n  --> nueva linea
        \r  --> retorno de carro
        \t  --> tabulado
        \u  --> convierte la siguiente letra en may£scula
        \L  --> convierte todos los caracteres posteriores en min£sculas
                hasta el siguiente \E
        \U  --> convierte todos los caracteres posteriores en may£sculas
                hasta el siguiente \E
        \E  --> fin de las secuencias de escape \L y \U
        \"  --> visualiza comilla
        \$  --> visualiza d¢lar
        \\  --> visualiza barra invertida
        \Onn -> inserta d°gitos octales nn
        \xnn -> inserta d°gitos hexadecimales nn

        Imagine que desea guardar el listado de un directorio en una variable
ser°a de la siguiente forma:

        $list = 'ls' #para sistemas UNIX
        ¢
        $list = 'dir' #para windows

        ========
        Matrices
        ========

        La matriz se define con una secuencia de valores escalares separados
por comas y encerrados por parÇntesis, como se muestra de la siguiente manera:

        @arc_perl = ("hello.pl", "var.pl", "print.pl");

        aunque podr°amos hacerlo de la misma manera si es un listado de un
directorio, de la siguiente manera:

        @arc_perl = 'ls *.pl';

        Cada elemento en una matriz es una variable escalar y es posible
acceder a Çl conociendo su posici¢n en la matriz. Siendo el primer elemento
de la matriz $arc_perl[0], el segundo $arc_perl[1] y as° sucesivamente, debe
de fijarse que en realidad cada elemento es una variable y no una matriz, por
lo que debe cambiarse el s°mbolo @ (de matriz) por el de $ (de variable 
escalar). TambiÇn debe de anotar, de que si desea acceder al £ltimo elemento
de la matriz debe de usar el °ndice -1, de la siguiente forma $arc_perl[-1].

        Si desea contar los elementos de una matriz, se debe inicializar una
variable escalar con el nombre de una matriz, de la siguiente manera:

        @colors = ("rojo", "azul", "verde", "amarillo");
        $num_colors = @colors;
        print "Tenemos $num_colors\n"; #imprimir† un 4

        Otra forma de obtener el n£mero de elementos de una matriz es usar la
variable escalar $#arrayname (que es el nombre de una variable matricial) que
almacena el £ltimo °ndice de la matriz. $#num_colors es 3.

        Pasemos ahora a explicar la matriz @ARG, perl define esta matriz
usando todos los argumentos de la l°nea de comandos cuando el programa se
inicializa. Esto ser°a un ejemplo para que quede m†s claro:

        #!/usr/bin/perl
        print "Bienvenido $ARG[0],\n";
        print "Gracias por ejecutar nuestro programa.\n";

        Si ejecut†semos este programa llamado arg.pl escribiendo lo siguiente:

        perl arg.pl Javi

        El programa dar°a la siguiente salida:

        Bienvenido Javi
        Gracias por ejecuta nuestro programa.

        Bien, m†s o menos ya tenemos claro algo sobre las matrices, pero ahora
aprenderemos a a§adir o eliminar los elementos de una matriz.

        Imagine que tenemos los siguientes elementos en una matriz:

        @names = ("Pedro", "Javi", "Paula", "Lorena");

        Si deseamos extraer el primer elemento de la matriz @names deberemos
utilizar la funci¢n shift, de la forma siguiente:

        $elim_primer = shift @names;

        Lo que hace esto es quita el elemento Pedro de la matriz @names, por
lo que esta matriz disminuir† el n£mero de elementos qued†ndose en 3 elementos
y el elementos extraido (Pedro) se a§adir† a la variable escalar $elim_primer.

        Si desea empezar por extraer el £ltimo elemento de una matriz deber†
usar la funci¢n pop, veamos un ejemplo para que quede m†s claro:

        @names = ("Pedro", "Javi", "Paula", "Lorena");
        $elim_ultimo = pop @names;

        Esto eliminar† el ultimo elemento de @names que es "Lorena", utilice
la print si desea ver los resultados por pantalla, que resulta muy c¢modo.
TambiÇn puede ver el antes y el despuÇs para ver como actuan las funciones que
ha utilizado, de la siguiente forma:

        @names = ("Pedro", "Javi", "Paula", "Lorena");
        print "Tenemos estos nombres al principio\n @names\n.";
        $elim_ultimo = pop @names;
        print "Pero al utilizar la funcion pop, tenemos \n @names \n.";
        print "Y el valor que ha sido extraido es $elim_ultimo\n.";

        Sencillo, no? esto resulta muy £til, de forma que ve lo que se est†
haciendo en todo momento, y que se ha eliminado y que no... etc.

        Hasta ahora hemos visto como eliminar elementos en una matriz, pero
ahora tenemos que saber como a§adir elementos a una matriz.

        Para a§adir elementos a la matriz utilizaremos las funci¢n unshift,
que a§ade un elemento al principio de la matriz y aumenta el tama§o de la
misma en una unidad, ser°a de la siguiente manera:

        @names = ("Pedro", "Pablo", "Javi");
        unshift (@names, "Juan", "Marcos");

        Por lo que la matriz habr† aumentado en 2 unidades, y el orden ser°a
el siguiente Juan, Marcos, Pedro, Pablo y Javi.

        Ahora bien, si queremos a§adir elementos a una matriz, pero esta vez
al final de una matriz, deberemos utilizar la funci¢n push de la siguiente
manera:

        @names = ("Pedro", "Pablo", "Javi");
        push (@names, "Juan", "Marcos");

        En este caso la matriz @names contiene cinco elementos en el siguiente
orden; Pedro, Pablo, Javi, Juan y Marcos.

        Vay†mos m†s adelante, e intentemos dar nuevos pasos y aprender as°
nuevas tÇcnicas de programaci¢n. Pasemos a explicar como clasificar los
elementos de la matriz. Si queremos clasificar los elementos de la matriz por
orden alfabÇtico, debemos recurrir a la funci¢n sort. La funci¢n sort devuelve
una matriz clasificada, pero no altera la matriz original, es decir que se
debe guardar el resultado de la clasificaci¢n en otra matriz. Veamos un
ejemplo para que esto quede un poco m†s claro:

        @names = ("Juan","Pedro", "Marcos", "Dani", "Patricia");
        @alf_names = sort(@names);

        Es decir, la matriz @names ser°a el conjunto de estos elementos
ordenados de la siguiente manera; Juan, Pedro, Marcos, Dani y Patricia.
Mientras que la matriz @alf_names ser°a el conjunto de estos elementos 
ordenados de la siguiente manera; Dani, Juan, Marcos, Patricia y Pedro. Es
decir la primera matriz no es modificada, sin¢ que es creada una nueva matriz
con los elementos de la primera pero con su orden cambiado.

        TambiÇn podemos usar la funci¢n splice, que puede remplazar una parte
de la matriz por otra matriz. La funci¢n splice elimina un n£mero de elementos
dado por el par†metro longitud, inserta la matriz indicada en el lugar que
ocupaban los elementos borrados. La sintaxis de splice es la siguiente:

        splice(@antiguo, desplazamiento, longitud, @nuevo);

        Queda claro? veamos un ejemplo para evitar confusiones.

        @names = ("Pedro", "Javi", "Arturo", "Pablo", "Juan");
        @nuevo = ("Jovi", "Minero");
        splice (@names, 3, 1, @nuevo);
        print "@names\n";

        Si ejecutamos este programa, se producir°a la siguiente salida:

        Pedro, Javi, Arturo, Jovi, Minero, Juan.

        Bien, por si no queda claro os lo explico; f°jese en la matriz @names,
la funcion splice salta "3" elementos y borra solo "1" y all° mismo inserta
los elementos de la matriz @nuevo, que son Jovi y Minero, quedando el orden
por detr†s de todos escepto de Juan. Creo que ahora ha quedado m†s claro.

        Bien, m†s o menos las matrices han quedado claras, pasemos ahora a las
matrices asociativas. Que mejor, para verlo que un ejemplo:

        %gastos = ("Jovi", 1000,
                   "Minero" 999,
                   "Juan"   100,
                   "Javi"   350,
                   "Alberto" 60);
        $jovi_gastos = $gastos{"Jovi"};
        print "Jovi gast¢ \$$jovi_gastos.\n";

        La salida de este programa ser°a la siguiente:

        Jovi gast¢ $1000.

        En las matrices asociativas, a un elemento de la matriz se le asocia
otro elemento de la matriz, a diferentes personas se les asignan sus gastos
(que cada uno es diferente). Se busca el elemento de la matriz mediante el
nombre para saber el gasto, definimos una variable nueva en este caso esa
variable es $jovi_gastos, a la que se le busca a que elemento pertenece, que
se busca de esta manera $gastos{"Jovi"} donde utiliza el valor asociado a Jovi
que es 1000. Para comprenderlo mejor, haced ejemplos de matrices asociativas.

        Bien, imagine que desea a§adir un "hueco" para un nuevo nombre que 
estÇ asociado a un gasto, se har°a de la siguiente forma:

        %gastos = ("Pablo" => 100,
                   "Pedro" => 350,
                   "Javi"  => 670);
        #a§adimos un nuevo elemento a la matriz asociativa
        $gastos {"Juan"} = 390;

        El elemento Juan con gasto 390, ser† a§adido a la matriz asociativa,
despuÇs de que la matriz %gastos halla sido creada.

        Pasemos ahora a explicar la matriz asociativa %ENV. La variable PATH
guarda un valor que consiste en una lista de nombres de directorio, donde el
sistema operativo (tanto windows como linux, unix y dem†s) guardan donde han
de buscar los comandos para el sistema, comandos como ls, pwd, etc.

        En UNIX la variable de ambiente PATH se define mediante la siguiente
cadena:

        /usr/local/bin:/bin:/usr/bin:/usr/etc:/usr/X11/bin:

        Mientras que en windows suele tener la siguiente forma:

        C:\WINDOWS;C:\WINDOWS\COMMAND;C:\PERL5\BIN;

        F°jese, que cuando utiliza un comando en un sistema UNIX, primero
buscar† ese programa en /usr/local/bin, si no lo encuentra lo buscar† en /bin,
y as° sucesivamente (notese que la separaci¢n en estos sistemas en con ":").

        Lo mismo pasa en un sistema como windows, pero en este caso, son
separados los directorios mediante ";". Para ver el valor de la variable PATH
solo ha de escribir PATH en el prompt del sistema en el que se encuentre,
tanto en sistemas UNIX como Windows.

        Para acceder a la variable de ambiente PATH, mediante un programa en
pero se har°a de la siguiente forma:

        print "El PATH actual es $ENV{PATH}\n;

        Aunque tambiÇn se puede hacer haciendo una llamada al sistema:

        system("PATH");

        Debe de tener en cuenta una cosa muy importante cuando programa, y es
que siempre hay m†s de una forma de hacer las cosas, no solo hay un camino.

        Bien, sigamos y pasemos a explicar la visualizaci¢n de variables de
ambiente; escriba el siguiente c¢digo en su intÇrprete:

        foreach $name (keys(%ENV))
        {
                $value = $ENV{$name};
                print "$name = $value\n";
        }

        Usamos la funci¢n keys y la sentencia foreach para visualizar todas
las variables. La funci¢n keys acepta como argumento una matriz asociativa y
devuelve todas las claves en esa matriz. De tal forma keys(%ENV) es una lista
de nombres de variables de ambiente.

        La sentencia foreach permitir† discurrir por una lista de elementos,
copiar uno de esos elementos en una variable, en este ejemplo $name. Se puede
acceder a los valores correspondientes utilizando cada clave como °ndice en la
matriz asociativa %ENV.

        Pasemos a utilizar una matriz asociativa como una peque§a base de
datos, para acceder a un elemento de una matriz asociativa se necesita una
clave, por lo que cuando se quiera consultar todos los elementos de la matriz
asociativa necesitar† las claves. Utilicemos la funci¢n keys para tomar el
nombre de la matriz asociativa como argumento y que devuelva una matriz con
todas las claves. Veamos un ejemplo:

        #!/usr/bin/perl
        #definimos la matriz asociativa
        %gastos = ("Javi" => 1000,
                   "Jose" => 1500,
                   "Juan" => 14.5,
                   "Maria => 950.75");

        #Obtenemos las CLAVES y las visualizamos
        @claves = keys(%gastos);
        print "@names\n";

        Con este programa se visualizar† la siguiente salida por pantalla:

        Juan Maria Javi Jose

        Bien, podemos observar como se han devuelto las "claves", pero si nos
fijamos bien veremos que las claves son devueltas con un orden aleatorio. Si
desea imprimir las claves en orden alfabÇtico puede utilizar la funci¢n sort
como se muestra a continuaci¢n:

        #!/usr/bin/perl
        #definimos la matriz asociativa
        %gastos = ("Javi" => 1000,
                   "Jose" => 1500,
                   "Juan" => 14.5,
                   "Maria => 950.75");

        #Obtenemos las CLAVES y son ordenadas alfabeticamente
        @claves = keys(%gastos);
        @claves_alfab = sort(@claves);

        #Visualizamos los elementos UNO A UNO
        foreach $claves (@claves_alf)
                {
                print "$name gast¢ \$$gastos{$name}\n";
                }

        La salida de Çste programa ser°a la siguiente:

        Javi gast¢ $1000
        Jose gast¢ $1500
        Juan gast¢ $14.5
        Maria gast¢ $950.75

        Puede ver como la salida del programa tiene una estructura ordenada,
pero tambiÇn puede utilizar la funci¢n values muy parecida a la funci¢n keys:

        @claves = values(%gastos)
        print "@claves\n";

        Siendo la matriz asociativa %gastos definida anteriormente, la salida
del programa ser°a la siguiente:

        1000 14.5 1500 950.75

        Los valores son devueltos de forma arbitr†ria.

        Hag†mos un programa que obtenga primero las claves y luego los valores
uno a uno, para ello puede utilizar la funci¢n each de la siguiente manera:

        #!/usr/bin/perl
        #definimos la matriz asociativa
        %gastos = ("Javi" => 1000,
                   "Jose" => 1500,
                   "Juan" => 14.5,
                   "Maria => 950.75");

        #Visualiza los pares clave-valor uno a uno
        while(($name, $money) = each(%gastos))
        {
                print "$name gast¢ \$$money\n";
        }

        $name y $money almacenan un par clave-valor, cuando no hay m†s
elementos en la matriz asociativa, la funci¢n each devuelve una matriz vac°a y
el bucle while finalizar†.

        Vay†mos ahora al borrado de un elemento de la matriz asociativa. Vea
el siguiente ejemplo como se utiliza la funci¢n delete para eliminarlo:

        #!/usr/bin/perl
        #definimos la matriz asociativa
        %gastos = ("Javi" => 1000,
                   "Jose" => 1500,
                   "Juan" => 14.5,
                   "Maria => 950.75");

        #Muestra claves actuales
        @names = keys(%gastos);
        print "Claves originales: @names\n";

        #Eliminamos la entrada correspondiente
        delete($gastos{"Juan"});

        #Muestra las claves de nuevo
        @names = keys(%gastos);
        print "DespuÇs de eliminar la entrada: @names\n";

        Si ejecuta el programa ver† la siguiente salida por pantalla:

        Claves originales: Javi Juan Jose Maria
        DespuÇs de eliminar la entrada: Javi Jose Maria

        Pasemos ahora a ennumerar algunas variables especiales:

        @ARG            ==>     Matriz que contienen los argumentos de las
                                l°neas de comando utilizados para iniciar el
                                programa Perl.
        @ENV            ==>     Almacena variables de ambiente.
        $_              ==>     Varias funciones.
        @_              ==>     Lista de argumentos que se transmite a una
                                subrutina.
        $0              ==>     Nombre del fichero que contiene el programa.
        $]              ==>     N£mero de versi¢n de Perl.
        $<              ==>     ID del usuario.
        $^X             ==>     Ruta completa del intÇrprete Perl.

        ===============================
        Procesamientos de datos en Perl
        ===============================

        Ya sabÇmos c¢mo almacenar datos, ahora solo hace falta saber como
efectuar datos con ellos, c¢mo escribir expresiones (f¢rmulas).

        Como ya hemos explicado antes, existen los operadores aritmÇticos,
tales como la suma(+), resta(-), divisi¢n(/) o multiplicaci¢n(*).

        Escribamos un programa sencillo que realice operaciones artimÇticas
usando constantes y variables.

        #!/usr/bin/perl
        
        #Definimos variables
        $producto_1 = "manzanas";
        $precio = 100;
        $iva = 1.16;

        #Operaci¢n que calcula el producto
        $producto_1_precio = $precio * $iva;
        $iva_producto = $producto_1_precio - $precio

        #Imprimimos por pantalla
        print "El precio de las $productos_1 con iva es $producto_1_precio\n";
        print "Por lo que el iva son $iva_producto pesetas\n";

        Bien, este programa calcula el iva de cierto producto, y adem†s
calcula la diferencia entre el precio total con iva y el precio sin iva, es
decir la diferencia (el iva en pesetas segun el producto).

        TambiÇn existen operadores muy comunes como ++ que es el operador de
autoincremento, si desea por ejemplo que una variable aumente su valor en uno
cada vez que se encuentre por ejemplo una palabra en un documento.

        $count++; #seria equivalente a $count = $count + 1;

        El operador de autoincremento se puede utilizarlo de dos formas; como
sufijo de una variable o como prefijo de una variable. El primero se
incrementa la variable DESPUêS de que se ha utilizado en la expresi¢n en curso
(llamado post-decremento). El segundo se incrementa la variable ANTES de que
se haya utilizado en la expresi¢n en curso (llamado pre-decremento).

        Para que quede m†s claro, hagamos dos ejemplos con el operador de
autoincremento y veamos su salida.

        #Post-decremento
        $count = 100
        $count_now = $count + 1; #Ser°a lo mismo que $count++
        print "Cuenta actual = $count_now\nCuenta = $count\n";

        La salida de este programa ser°a la siguiente:

        Cuenta actual = 100
        Cuenta = 101

        Veamos ahora que pasar°a con el pre-decremento:

        #Pre-drecremento
        $count = 100
        $count_now = ++$count
        print "Cuenta actual = $count_now\nCuenta = $count\n";

        El resultado ser°a:

        Cuenta actual = 101
        Cuenta = 101

        Aqu° $count incrementa antes de utilizar el valor, $count cambia de
100 a 101 ANTES de que el valor se asigne a la variable $count_now.

        TambiÇn existe el operador de autodecremento (--), que disminuye el
valor de la variable en una unidad. Existen dos formas de utilizar Çste
operador al igual que el anterior: $count--, el valor de $count se decrementa
despuÇs de que el valor antiguo se utilice en la expresi¢n actual. Mientras
que --$count, el valor de $count se decrementa antes de evaluar la expresi¢n
actual.

        ================
        Otros operadores
        ================

        %               ==>     Operador de m¢dulo o resto (9%4=1)
        **              ==>     Operador de exponente
        Virgulilla      ==>     Operador NOT
        &               ==>     Operador AND
        |               ==>     Operador OR
        ^               ==>     Operador OR exclusivo
        <<              ==>     Operador de desplazamiento hacia la izquierda
        >>              ==>     Operador de desplazamiento hacia la derecha

        ==============================================
        Operadores para trabajar con valores numÇricos
        ==============================================

        +=              ==>     Operador de asignaci¢n de suma
        -=              ==>     Operador de asignaci¢n de resta
        *=              ==>     Operador de asignaci¢n de multiplicaci¢n
        /=              ==>     Operador de asignaci¢n de divisi¢n
        $=              ==>     Operador de asignaci¢n de resto
        **=             ==>     Operador de asignaci¢n de exponenciaci¢n
        &=              ==>     Operador de asignaci¢n de AND binario
        |=              ==>     Operador de asignaci¢n de OR binario
        ^=              ==>     Operador de asignaci¢n de OR exclusivo
        <<=             ==>     Operador de asignaci¢n de desplazamiento hacia
                                la izquierda
        >>=             ==>     Operador de asignaci¢n de desplazamiento hacia
                                la derecha

        No me voy a extender en explicar cada uno de estos operadores, ya que
es muy extenso y se puede encontrar en cualquier libro o guia de referencia de
programaci¢n medianamente bueno.

        Cuando utilice operadores, puede alterar el orden de una determinada
parte de la expresi¢n usando parÇntesis.

        Perl incluye funciones como sin o como cos, para calcular el seno o
coseno respectivamente de cualquier valor, pero no incluye para calcular la
tangente, aunque se puede calcular de la siguiente manera:

        tan(A) = sin(A) / cos(A)

        Perl incluye tambiÇn la funci¢n atan2 para calcular el arco tangente,
utilizado muy frecuentemente para calcular por ejemplo la pendiente de un
terreno ($A) dada la elevaci¢n ($elev) desde una distancia concreta ($dist):

        $A = atan2($elev, $dist)

        La funci¢n sqrt se utiliza para calcular ra°ces cuadradas, por ejemplo
podria calcular la ra°z cuadrada de 2 catetos, obteniendo as° la hipotenusa:

        #Definimos los lados
        $x = 4
        $y = 5
        $hipotenusa = sqrt($x**2 + $y**2);
        print "La hipotenusa de un rect†ngulo de $x por $y es $hipotenusa\n";

        BiÇn, veamos un poco por encima la funci¢n srand y rand, que son
utilizadas para inicializar la semilla para generar n£meros aleatorios y
generar los mismos respectivamente. Veamos un ejemplo:

        #!/usr/bin/perl
        @seq = (); #Definimos Matriz vac°a para guardar la secuencia aleatoria
        srand(time()); #Inicializa la semilla usando la salida de la funci¢n
                       #time
        $count = 0;
        while($count < 20) #Genera 20 n£meros aleatorios entre 1 y 20
        {
                $number = int(rand(20) + 1); #Genera un n£mero aleatorio y lo
                                             #lo convierte en entero
                for($i = 0); $i < $count; $i++) #Comprueba si el n£mero ya est†
                                                #en el array
                {
                        if($number == $seq[$i])
                        {
                                last; #El num. ya est† en el array @seq
                        }
                }
                if($i >= $count) #Aun no est† en @seq
                {
                #Guarda el num. en @seq e incrementa la cuenta
                        $seq[$count] = $number;
                        $count++;
                }
        }
        #Muestra la secuencia aleatoria
        print "Seq. aleatoria del 1 al 20:\n@seq\n";

        Al ejecutar este programa puede obtener una salida parecida a esta:

        Seq. aleatoria del 1 al 20:
        4 7 5 6 9 8 10 1 2 11 3 20 17 15 12 18 19 13 14 16

        ================================
        Operaciones con cadenas de texto
        ================================

        En lo que esto se refiere, no es m†s que por ejemplo combinar dos
cadenas de texto para formar una tercera, separar las lineas de un fichero en
varias partes, etc.

        Pasemos a explicar lo que es la concatenaci¢n de cadenas y como se
realiza, que en realidad es la uni¢n de las mismas, veamos un ejemplo:

        #!usr/bin/perl
        #Definimos dos variables
        $nombre = "Javi";
        $apellidos = "Perez de la Torre";
        #Concatenamos las dos cadenas
        $nombrecompleto = $nombre. " ".$apellidos; 
        #Imprimimos por pantalla
        print "$nombrecompleto\n";

        La variable $nombrecompleto almacena el resulado de la operaci¢n, debe
haber un espacio en blanco entrecomillado entre las dos variables y la
concatenaci¢n es representada mediante el signo punto (.).

        FijÇmonos ahora en la repetici¢n de cadenas; el operador de repetici¢n
representado mediante el s°mbolo x, repite una cadena un n£mero espec°fico de
veces. Un ejemplo:
                      
        $separador = "_" x 10
        print "$separador\nBienvenido\n$separador\n";

        Este programa tiene la siguiente salida;

        __________
        Bienvenido
        __________

        PasÇmos ahora a explicar la extracci¢n de una subcadena, imagine que
tenemos un fichero de texto que contiene sugerencias de diversas persona, cada
una de Çstas sugerencias comienza con una l°nea informando de quiÇn la envi¢:

        From: Juan PÇrez
        sugerencia... bla bla bla
        From: Javi PÇrez
        sugerencia... bla bla bla
        From: Jaime Piedra
        sugerencia... bla bla bla
        From: Jacobo Ib†§ez
        sugerencia... bla bla bla
        
        BiÇn, imagine que desea hacer una lista de las personas que hayan
mandado sugerencias, para ello deberemos de EXTRAER una parte de la cadena,
exactamente la que sigue a la palabra From seguido de un espacio, para ello
podemos usar la funci¢n substr de la siguiente forma:

        #!/usr/bin/perl
        $line = "From: Juan PÇrez";
        #Extrae el texto que va despuÇs de los primeros 6 caracteres
        $from = substr($line, 6);
        print "$from\n";

        êsto imprimira Juan PÇrez, en el pr¢ximo n£mero ya escribirÇ como
acceder a un fichero y hacerlo con todas las lineas, de momento basta con
tener esto claro. Pero expliquemos un poco m†s la funci¢n substr, imagine que
tiene almacenado en una variable "Perl es un lenguaje de programaci¢n.", y que
de esa linea solo desea copiar la parte de "lenguaje", se podr°a hacer de la
siguiente manera:

        #!/usr/bin/perl
        #Cadena original
        $line = "Perl es un lenguaje de programaci¢n.";
        #Extracci¢n de una parte de la cadena anterior
        $parte = substr($line, 12, 8);
        print "$parte\n";

        Lo que hace este programa, es extraer de la cadena almacenada en $line
a partir del caracter 12 y terminando de extraer 8 caracteres m†s.

        TambiÇn puede hacer uso de la funci¢n index, imagine que no sabe la
posici¢n en la que se encuentra la palabra lenguaje, y es la que desea extraer
esto se podr°a hacer de la siguiente forma:

        #!/usr/bin/perl
        $line = "Perl es un lenguaje de programaci¢n.";
        $pos = index($line, "lenguaje");
        $part = substr($line, $pos, 8);
        print "$part\n";

        Creo que queda bastante claro, pasemos ahora a calcular la longitud
por ejemplo de una cadena, es decir el n£mero de caracteres que Çsta contiene.
Para ello podemos usar la funci¢n length del siguiente modo:

        #!/usr/bin/perl
        #Cadena original
        $line = "Perl es un lenguaje de programaci¢n.";
        #Calcula la longitud de $line
        $longitud = length($line);
        #Muestr la candena original
        print "$line\n";
        Prepara la linea de guiones y las visualiza
        $uline = "-" x $length
        pritn "$uline\n";

        La salida de este programa ser°a la siguiente:

        Perl es un lenguaje de programaci¢n
        -----------------------------------

        Los guiones son utilizados para hacer una especie de subrayado, que
encajar† perfectamente con la longitud de la cadena, ya que se multiplica el
n£mero de guiones por la longitud de la cadena (que es $longitud). Avancemos
un poco y pasÇmos a explicar otros operadores.

        =======================================
        Operadores para comparaciones numÇricas
        =======================================

        ==              ==>     Operador de igual que
        !=              ==>     Operador de distinto de
        <               ==>     Operador de menor que
        >               ==>     Operador de mayor que
        <=              ==>     Operador de menor o igual que
        >=              ==>     Operador de mayor o igual que
        <=>             ==>     Operador de comparaci¢n de tres v°as

        ================================
        Operadores para comparar cadenas
        ================================

        eq              ==>     Verdadero si las cadenas X e Y son iguales
        ne              ==>     Verdadero si las cadenas X e Y son distintas
        gt              ==>     Verdadero si X es mayor que Y
        ge              ==>     Verdadero si X es mayor o igual que Y
        lt              ==>     Verdadero si X es menor que Y
        le              ==>     Verdadero si X es menor o igual que Y
        cmp             ==>     -1 si X es menor que Y, 0 si son iguales, 1
                                si X es mayor que Y

        Cuando comparamos cadenas, se dice que una cadena es mayor que otra,
comparando su "valor numÇrico" de los caracteres, es decir el valor de A es 65
el valor de B es 66, por lo que A es menor que B. El valor numÇrico de los
caracteres viene determinado por el c¢digo ASCII.

        ===================
        Sentencias y Bucles
        ===================

        Debe de tener claro la siguiente estructura:

        palabra clave (expresi¢n)
        {
        bloque de sentencias
        }

        La expresi¢n entre parÇntesis se comprueba antes de que el bloque de
sentencias entre llaves se ejecute. Se deben de poner llaves para delimitar
las sentencias. Debe de utilizar las sentencias if y unless para ejecutar un
bloque de c¢digo basado en el valor de la expresi¢n, pero tambien puede usar
las sentencias elsif y else con la sentencia if.

        ==
        if
        ==

        If ejecuta un bloque de sentencias si se cumple una condici¢n. La
estructura de una sentencia combinada if-else tiene la siguiente estructura:

        if (expresi¢n)
        {
        sentencias a ejecutar si la expresi¢n es verdadera
        }
        else
        {
        sentencias a ejecutar si la condici¢n es falsa
        }

        esto ejecuta unas sentencias si la condici¢n es falsa, y otra
diferente si la condici¢n es verdadera, pero a veces es necesario comprobar
m†s de dos alternativas, por lo que podr°a utilizar una sentencia if con
varias cl†usulas elseif y una cl†usula else para implementar Çsta l¢gica, de
la siguiente manera:

        if ($longitud >= 10)
        {
                print "Es mayor de 9!!!!!!\n";
        }
        elseif ($longitud >= 6 && $longitud <= 9)
        {
                print "Es mayor o igual a 6 pero menor que 10!!!!\n";
        }
        elseif ($longitud > 3 && $longitud < 6)
        {
                print "Mayor que 3, pero menor que 6!!!\n";
        }
        } else
        {
                print "Muy Bajo!\n";
        }

        Imagine por ejemplo que desea salir del programa si el valor excede de
15, podr°a escribir lo siguiente para realizar esta operaci¢n:

        exit if($error >25);

        ======
        unless
        ======

        Muchas veces, quiere ejecutar un bloque de sentencias si una condici¢n
es falsa, por lo que escribir "si no es el root, no ejecutar este programa",
queda un poco lioso, y es m†s facil utilizar la l¢gica de "a no ser que sea
root, no ejecutar el programa", esto se realiza con la sentencia unless , que
significa "a menos que". Veamos un ejemplo:

        unless(open(DATAFILE. "tree.dat"))
        {
                die "No se puede abrir el fichero de datos!\n";
        }

        El programa se podr°a leer de la siguiente manera: "a no ser que el
fichero se abra, paralizar el programa". La func°on die provoca la salida del
programa despuÇs de visualizar el mensaje que tenemos como argumento.

        =====
        while
        =====

        Imagine que desea ejecutar un bloque de sentencias hasta que alguna
condici¢n llegue a ser falsa, la operaci¢n de repetici¢n de un bloque de
sentencias se le llama bucle. Veamos un ejemplo de un programa que sume los
n£meros del 1 al 10 y hasta que no los sume no salga del bucle:

        #!/usr/bin/perl
        while($i <= 10)
        {
                $sum += $i;
                $i++
        }
        print "Suma del 1 al 10 = $sum\n";

        La salida del programa ser† la siguiente:

        Suma del 1 al 10 = 55

        La sintaxis del bucle es la siguiente:

        while (expresi¢n)
        {
                bloque de sentencias a ejecutar MIENTRAS la expresi¢n sea
                verdadera
        }

        =====
        until
        =====

        La sentencia until repite un bloque de sentencias hasta que una
determinada condici¢n se haga verdadera, until ejecuta el bloque mientras la
condici¢n es falsa y repite el bucle hasta que una expresi¢n se cumpla. Veamos
un ejemplo:

        #!/usr/bin/perl
        #Procesa ¢rdenes hasta que se introduce "quit"
        until ($command eq "quit")
        {
                $command = <STDIN>; #Lee la orden
                chop $command; #Elimina el car†cter final de nueva l°nea
                print "$command\n";
        }

        êste programa acepta ¢rdenes y las imprime hasta que se teclee quit,
por lo que $command es equivalente a quit y termina el bucle until.

        ===
        for
        ===

        La sintaxis del bucle for es la siguiente:

        for (expresion_1; expresion_2; expresion_3)
        {
                bloque de sentencias
        }

        La expresi¢n expresion_1 se eval£a una vez, el bloque de sentencias se
ejecuta mientras la expresi¢n expresion_2 sea verdadera. La expresi¢n
expresion_3, se eval£a despues de cada ejecuci¢n del bloque de sentencias.
Debe de tener en cuenta que debe colocar las llaves alrededor del bloque de
sentencias incluso si no hay sentencias, veamos un ejemplo:

        for ($i=1, $sum=0; $i <= 10; $sum += $i, $i++) {}

        =======
        foreach
        =======

        Puede utilizar foreach para ejecutar el bloque de c¢digo con cada
elemento de la matriz y puede utilizar el bucle for para acceder a cada
elemento de una matriz mediante su °ndice.

        Imagine que desea hace un programa que encuentre el mayor valor en una
matriz, se podr°a hacer de la siguiente forma:

        #!/usr/bin/perl
        #Definimos la matriz
        @num = (55, 45, 54, 33, 22, 39, 10, 9, 57, 89, 99);
        #Encuentra el mayor valor
        foreach $num (@num)
        {
                if($num > $max)
                {
                        $max = $num;
                }
        }
        #Visualiza el mayor valor
        print "Valor m†ximo de la matriz = $max\n";

        Sencillo, no? bien, realmente la sintaxis ser°a la siguiente:

        foreach $variable (@matriz)
        {
                bloque de sentencias
        }

        Debe de saber, que si se omite la variable en una sentencia foreach,
Perl interpreta que se est† utilizando la variable $_ para guardar el elemento
actual de la matriz.

        ================
        Ruputa de bucles
        ================

        A veces, es necesario romper un bucle antes de que se hayan realizado
todas la iteraciones, por ejemplo est† buscando un nombre en una matriz y
desea que termine el bucle tan pronto como encuentre su objetivo, los nombres
se almacenan en la matriz @nombres y quiere buscar el nombre que se guarda en
la variable $customer.

        foreach $name (@nombres)
        {
                #rompe el bucle si se encuentra $customer
                last if($customer eq $name);
                #otro codigo...
        }

        Es posible usar last en todos los tipos de bucles. Puede tener un
bucle dentro de otro, y con el comando last puede romper el bucle exterior,
aunque last se encuentre en el bucle m†s interno, para ello primero ha de
etiquetarse el bucle exterior (darle un nombre), luego ha de colocarse el
nombre del bucle despuÇs de la palabra reservada last, un ejemplo:

        BUCLE_EXTERIOR: while($line =<STDIN>)
        {
                chop $line; #Se omite el car†cter de nueva l°nea
                foreach $name (@names)
                {
                        last BUCLE_EXTERIOR if ($line eq $name);
                        #Finaliza el bucle exterior
                }
        }

        La etiqueta que se le asigna, debe siempre ir seguida de : para que
Perl as° lo identifique.

        TambiÇn puede utilizar el comando next para saltar la iteraci¢n de un
bucle, en los casos que existe un bucle dentro de otro, se puede utilizar una
etiqueta con el comando next para designar al bcle que queremos saltar. Cuando
se use next sin etiqueta se salta la pr¢xima iteraci¢n del bucle interno.

        ==============
        STDIN y STDOUT
        ==============

        Los programas Perl se dise§an generalmente para leer informaci¢n de la
entrada est†ndar (el teclado) y enviarla a la salida est†ndar (la pantalla),
Çsta entrada y salida est†ndar se puede redireccionar. La expresi¢n siguiente
lee una l°nea de la entrada est†ndar "$line = <STDIN>" y la almacena en una
variable llamada $line. La funci¢n print env°a su salida a la salida est†ndar
que por defecto es la pantalla.

        Hay dos formas de redireccionar STDIN y STDOUT: Usando operadores de
redireccionamiento (por ejemplo enlazando la salida a un fichero) o usando la
salida de otro programa como STDIN.

        Puede usar operadores de redireccionamiento para enlazar STDIN y
STDOUT a ficheros en lugar de conectarlos al teclado y a la pantalla
respectivamente.

        El signo < es el operador de redireccionamiento de entrada, mientras
que el signo > es el operador de redireccionamiento de salida.

        Puede redireccionar el gestor STDOUT de cualquier programa al STDIN
de un programa Perl, para ello deber† usar el operador | (tambiÇn conocido
como pipe o tuber°a), que conecta la salida STDOUT del primer programa con la
entrada STDIN del segundo.

        Perl eval£a <STDIN> como resultado la siguiente l°nea de la entrada
est†ndar, todo lo que hay que hacer es asignar el valor a la variable:

        $linea = <STDIN>;

        Lee la siguiente l°nea de la entrada est†ndar y almacena el texto en
la variable llamada $line. <STDIN> lee todos los caracteres de la l°nea
incluyendo el car†cter de nueva l°nea, si desea eliminar el car†cter de nueva
l°nea, puede hacer uso de la funci¢n chomp de la siguiente manera:

        $linea = <STDIN>;
        chomp $linea; #Elimina el caracter de nueva linea de $linea

        Por lo general, se asigna el valor de <STDIN> a una variable, para
almacenar el texto de entrada que se utilizar† despuÇs, la l°nea de texto se
asigna autom†ticamente a una variable llamada $_. Esto ocurre cuando se usa
<STDIN> como la expresi¢n condicional de un bucle while, un ejemplo:

        while(<STDIN>)
        {
                print $_;
        }

        Este programa devolver† el car†cter introducido hasta encontrar el
car†cter de fin de fichero, que es marcado con control+D (en Unix) o control+Z
seguido de intro (en Windows).

        TambiÇn puede asignar <STDIN> a una matriz, por ejemplo:

        @line = <STDIN>;

        Hay una forma especial de leer la entrada est†ndar mediante el
operador <>, por ejemplo:

        print while(<>);

        El programa almacena datos en un fichero.

        Ve†mos ahora STDOUT, se puede especificar a la funci¢n print que env°e
su salida a STDOUT, por ejemplo:

        print STDOUT "WeLcOmE tO pErL ;)\n";

        Si desea enviar la salida a un fichero abierto (que se identifica a
travÇs de su gestor de fichero), debe de usar la funci¢n print con el nombre
de gestor de fichero como argumento:

        print GESTORDEFICHERO, "Texto a enviar al fichero";

        Debe de tener el fichero abierto para escritura, Para ello puede
a§adir el prefijo > al nombre del fichero, lo que se hace al sistema operativo
es que se quiere abrir el fichero para escritura.

        Cuando abre un fichero puede utilizar la estructura Open OR die, por
ejemplo:

        open (GESTOR_DE_FICHERO, "Nombre_del_fichero") ||
        die ("No se puede abrir el fichero!!!!!\n");

        El funcionamiente se puede comprender de la siguiente manera: "abre el
fichero X o si no lo puede abrir por lo que sea el programa muere y muestra
por pantalla Y".

        Al terminar la utilizaci¢n de un fichero es necesario cerrarlo
llamando a la funci¢n close, como se muestra a continuaci¢n:

        close GESTOR_DE_FICHERO;

        Con esto finaliza este articulillo, espero que os sea de gran ayuda.

        Algunas direcciones de interes, son las siguientes:

        Http://www.perl.com
        Http://www.cpan.org

Si teneis alguna duda sobre cualquier tema o articulo que hay escrito,os 
quereis poner en contacto conmigo por cualquier raz¢n, quejas o cualquier
otra cosa podeis escribir a mi mail: overdrive@ono.com
        
Tambien podeis contactar conmigo en el irc en el servidor hispano, en los 
canales #programaci¢n y #perl.

-=(EOF)=-


