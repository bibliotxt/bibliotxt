      _____       _      _                 _____            _              _
     |  _  |     |_|    |_|               /  ___|          | |            | |
     | | | | ____ _  ___ _ _ __   ___     | |    ___  _ __ | |_ _ __  ___ | |
     | | | |/ ___| |/ __| | '_ \ / _ \    | |   /   \| '_ \| __| '__|/ _ \| |
     | |_| | |_  | | |__| | | | | |.| |   | |___| Q_/| | | | |_| |  | |.| | |__
     |_____|  _| |_|\___|_|_| |_|_| |_|   \_____|____|_| |_|\__|_|  |_| |_|____|
           | |
           |_|
                                   _____       
                                  |   _ \     
                                   | | | | __ 
                                   | | | |/  \
                                   | |_| | Q_/
                                  |_____/|____|
           _   _           _                                            _
          | | | |         | |                                          | |
          | | | |_ __   __| | __  _ __  ___  _ __  ___  _   _ _ __   __| |
          | | | | '_ \ / _  |/  \| '__|/   \| '__|/ _ \| | | | '_ \ / _  |
          | |_| | | | | (_) | Q_/| |  | (_) | |  | (_) | |_| | | | | (_) |
          \_____/_| |_|\____|____|_|   \__  |_|   \___/ \__,_|_| |_|\____|
                                        _ | |
                                       / // /
                                       \___/



                              " Underground Research Group "


   >>>>>>>--------------------[ O C T U B R E  -  2 0 0 1 ]-----------------------<<<<<<<


                                  OCTAVA REGION - CHILE
                          

      _____________________________________________________________________________
     |                                                                             |
     |  Todos los contenidos de esta revista son solamente educativos, ninguno     |
     |  pretende incitar al crimen o a la ilegalidad. Cualquier uso erroneo de     |
     |  esta informacion no es responsabilidad nuestra. Si no estas de acuerdo     |
     |  con lo anterior elimina este documento de tu computador.                   |
     |_____________________________________________________________________________|

       ____________________________________________________________________________
      |                                                                            |
      |           OCTUBRE 2001                                                     |
      |                                                                            |
      |           AÑO 1, NUMERO 2                                                  |
      |                                                                            |
      |           EDITOR: BLACKWRITE                                               |
      |               E-MAIL: slinux@chile.com                                     |
      |                                                                            |
      |                                                                            |
      |           AGRADECIMIENTOS A:  skindzer                                     |
      |                                                                            |
      |                                                                            |
      |        *--> Nos puedes encontrar IRC /SERVER ATTLA.IRC.CL 6667             |
      |                                                                            |
      |          Canales:  #Hackers_Rulz                                           |
      |                    #under                                                  |
      |                    #Under_research                                         |
      |____________________________________________________________________________|



        " Cuando nos hayamos muerto ya no nos quedara tiempo de arrepentirnos. "

        " La mente de los seres Humanos es inmensa y nunca sabremos como llenarla
          es por eso que hoy quiero aprender algo nuevo"




          - - = =  " Somos la red, y la red nos pertenece "  = = - -


                     - - - =| Colaboradores |= - - -

                        -  Satanizer
                        -  ZedFiht



                   < < < <  C O N T E N I D O S  > > > >
  


         TITULO                                                  AUTOR
      -=-=-=-=-=-=-                                          -=-=-=-=-=-=- 


 01.  EDITORIAL                                            -    blackwrite

 02.  BACK ORIFICE PARA NOVATOS (II CAPITULO)              -    EXTRAIDO DESDE LA RED

 03.  PREACKING (II CAPITULO)                              -    EXTRAIDO DESDE LA RED
       - PINCHANDO LINEAS TELEFONICAS

 04.  SISTEMA DE TELEFONIA MOVIL GSM (I CAPITULO)          -    EXTRAIDO DESDE LA RED

 05.  LINUX PARA PRINCIPIANTES (I CAPITULO)                -    EXTRAIDO DESDE LA RED

 06.  SOCKETS                                              -    ZedFiht

 07.  HISTORIA DE KEVIN MITNICK                            -    skindzer

 08.  DESPEDIDA                                            -    blackwrite



      *****************************************************************************
 01  **                                EDITORIAL                                  **
      *****************************************************************************

         Ya despues de unas semanas de estar imbestigando y redactando les doy a 
 conocer el segundo numero de esta Ezine Chilena, espero que le gusten sus contenidos,
 asi como tambien si tienen alguna duda no duden en embiar un mail con las preguntas
 que las causaron.
         La informacion que publicaremos en las distintas ediciones es totalmente con
 propositos educativo y/o cientificos, por lo tanto ni nosotros, ni los colaboradores
 se hacen responsables por el uso que le des al material expuesto.


      *****************************************************************************
 02  **              BACK ORIFICE PARA NOVATOS (II CAPITULO)                      **
      *****************************************************************************

   Caracteristicas del BO

   El BO en verdad es un programa que establece una conexion cliente servidor entre la
 victima y el espabilao.

   El programa cliente forma parte del ordenata del agresor mientras el servidor debe ser
 instalado en el ordenata de la victima. Por eso, la parte infecciosa del virus no la trae
 el, sino que son las propias personas quienes lo distribuyen por las ventajas que el
 propio virus facilita al agresor cuando esta instalado.

   Funciona en ventanukos95, osr2 y ventanukos98. Lo unico que hace en su instalacion es
 modificar una DLL del ventanukos a la que a¤ade multitud de nuevos comandos accesibles
 por el agresor desde su ordenador.


   Comandos del cliente

- App add - 

      Sirve para asignar una aplicadion a un puerto y tener acceso a ella
      a traves de ese puerto mediante via telnet. La mallor utilidad de
      este comando es cargar el command.com y asignarle un puerto.

	ejemplo: Exen location _parametres= c:\command.com
	         Port = 23

	Ahora se le hace telnet a la victima y veremos como se convierte en un shell del
 dos. Esto abre oportunidades interesantes, como es ejecutar comandos de dos que desde
 otro lado no podiamos. Si sabemos que la victima ya tiene un atacante que ha abierto un
 HTTP server, le ejecutamos el comando netstat a la victima y averiguamos asi quien es el
 otro atacante.


- App del -

        Cuando se abre una aplicacion se le coloca un ID (numero de
        aplicacion abierta). Para borrar una aplicacion abierta necesitamos
        ese ID. Es el primer nimero que sale cuando abrimos la aplicacion.

- Apps list -

       Lista las aplicaciones abierta. Aunke las haya abierto otro
       tambien las muestra. Esto tambien abre muchas oportunidades...
       pensad pensad...

- Directory Create -

	Crea directorio. MD del dos


- Directory List -

	DIR del dos......lista directorios

- Directory remove -

	Pues este borra los directorios...

- Exports add -

- Exports delete -

- Exports list -

- File copy -

	Copia un fichero de un lugar a otro del ordenata de la victima.

- File delete -

	Te cargas lo que le pongas.

- File find -

	Busca un file en el ordenador de la victima. Es muy util cuando no
        sabemos donde esta un fichero que hemos abierto o subido.
        Ejemplo: cuando hacemos un keylog.

- File freeze -

	Comprime ficherillo en el ordenata de la victima.

- File melt -

	Lo descomprime.

- File view -

	Es el TYPE del DOS. Muestra el contenido de un fichero (de texto).

- Http Disble -

	Desactiva servidor HTTP

- Http enable -

        Activa servidor HTTP. Esto permite acceder al ordenador de la victima
        mediante el navegador. Esta forma de hacerlo es la mas practica de
        todas pero la mas detectable. Estariamos al descubierto con un simple
        netstat. El modo de funcionar es muy sencillo. Se le indica al bogui
        el puerto (ejemplo 83) y la unidad (ejemplo c:). Luego en el navegador
        ponermos en el espacio de url: http://IP_de_la_victima:port. En
        nuestro ejemplo: http://234.432.123.53:83
	Al final de la pagina esta la opcion UPLOAD por si queremos dejarle algun
        regalo. Si pinchamos sobre algun archivo nos lo bajamos o si es una imagen,
        un txt o un html lo muestra directamente.


- Keylog begin -

	Activa el capturador de teclas. Podemos capturar asi todo lo que
        escribe la victima.
        Se nos pide el nombre del fichero donde se grabara.
        Ejem: C:\system.txt.
	Luego ya sea con file view o desde el HTTP server leemos el archivo
        cada 'x' tiempo y sabes que hace.

- Keylog end -

	Desactiva el keylog.

- MM Capture avi -

	Pues eso...captura en ofrmato video lo que hace la victima.
        Necesitamos especificar el nombre del fichero por un lado y el el
        otro los segundo y el tamaño de la imagen.

- MM Capture frame -

	Captura la pantalla pero se le puede dar dimensiones a la pantalla.
        En formato BMP.

- MM capture screen -

	Captura la pantalla tal y como es. Solo requiere el nombre del
        fichero. Graba en BMP.

- MM List capture -

	Lista los procedimientos de captura que se estan llevando acabo...

- MM Play sound -

	Hace sonar un fichero wav que se encuentra en el ordenador de la
        victima. Por lo tanto si queremos uqe suene algo nuestro priemro hay
        que subirselo.

- Net connections -

	Muestra las conexiones netbios que estan en marcha.

- Net delete -

	Borra algun recuerso de red de netbios.

- Net use -

	es el comando NET USE de netbios. Asigna un recurso netbios a una
        unidad. Necesitamos pasword si es ke lleva. Normalmente si.

- Net view -

	Es el comando NET VIEW de netbios. Establece una relacion de los
        recursos netbios abiertos.

- Ping host -

	Pues eso. Para saber si un host-victima esta en la red. SI en el
        target ponrmos tres subredes y la ultima con un '*' entonces escanea
        ese rango de ips. Ejemplo: si ponemos 234.231.432.* escaneara desde
        234.231.432.1 hasta 234.231.432.255. Si sale PONG en la pantalla
        receptora de mensajes es que tenemos victima.

- Plugin execute -

	Ejecuta plugin en ordenata de la victima. Hay que subirlo pues.

- Plugin kill -

	Desinstala plugin.

- Plugins list -

	Lista los plugins que hay.

- Process kill -

	DEsactiva los programas que iban en marcha.

- Process list -

	Lista d eprogramas en marcha...

- Process spawn -

	Ejecuta programas. Aunke cuando la he puesto en marcha la victima
        siempre ha desaparecido por lo que algunas veces igual se cuelga el
        BO.

- Redir add -

	REdirecciona por t amodo de bouncer. Hace como de repetidor. A la
        salida del repetidor-victima tenemos su ip en lugar de la nuestra.

- Redir del -

	LA inversa de lo de antes.

- Redirs list -

	Pues eso....las lista.

- Reg create key -

	Crea una llave el archivo de registros del ventanucos.

- Reg delete key -

	Se cepilla la llave.

- Reg delete value -

	Se cepilla un valor del registro.	

- Reg list keys -

	Lista las llaves...

- Reg list values -

	Lista valores...

- Reg set value -

	Coloca un valor en una llave del registro. Requiere nombre de la
        llave por un lado. Por otro tipo de dato:

				S- cadena de texto
				B- Numero binario
				D- Numeros decimales
        y el valor del dato...

- Resolve host -

	Resuelve la ip de un tercer host....
	
- System dialogbox -

        Le muesta una ventana del sistema a la victima. Se le indica el titulo de la
        venta y el texto que aparece en ella.

- System info -

	Da informacion acerca del host victima.

- System lockup -

	Le bloquea el ordenata....

- System passwords -

	Le saca los user y pass de las cuentas que hayan en el host y de
        alguna paginas web que han solicitado algun tipo de user/pass.

- System reboot -

	Reinicia el ordenata....

- TCP file receive/send -

	Con la ayuda de programas como netcat (esta en unix y en ventanucos)
        se pueden enviar y recibir ficheros. Segun el manual la linea del
        netcat seria: netcat -l -p 666 < file






      *****************************************************************************
 03  **                          PREACKING (II CAPITULO)                          **
      *****************************************************************************

   Pinchando Lineas Telefonicas 


  En este texto tratare de explicar los pasos a seguir para pinchar una linea telefonica
 de tu vecino o de quien quieras. CON ESTE TEXTO NO! SE PRENTENDE INSITAR A LA ILEGALIDAD
 SOLO LO EXPONGO CON FINES EDUCATIVOS.

  Materiales:
  -----------
  - Alambre de timbre (lo necesario para que la liena llege a tu pieza)
  - Un telefono
  - Ser muy pero muy cara dura
  - Una coneccion a Internet (para ke puedas leer esto y mas :)


   Lo primero ke vamos a hacer es elegir la victima por si acaso si vos vivis en un
 departamento o algo parecido estas al otro lado y solo tenes quee leer las reconenda-
 ciones que salen al final del texto, en caso contario tienes que elegir muy bien a al
 victima, tienes que mirar como van las lineas, en donde llegan a la casa, en que parte
 o sea tenes saber todo.

   Paso numero 2 es saber cuando y como hacerlo o sea: lo tenes que hacer en la noche obio
 no creo que nadie sea tan estupido como para hacer esto en el dia lo otro a la hora mas o
 menos a partir de las 1 o 2 de la madrugada es una buena hora para hacer esto ok.... Todo
 listo!! Subamonos al techo del vecino...... trata de ke sea en una noche de lluvia por lo
 general no nada mucha gente a esa hora de la noche, luego ke te has subido en los extremos
 de los cables le colocas unos alfileres y jeje pinchas la linea deves tener bastante
 fuerza en las manos, ya ke los cables son bastantes duros bueno luego tu sabes pruebas el
 tono y lo tiras a tu pieza y ahi tu veraz lo ke haces con el, ahi tu si llamas a un amigo
 y si te conectas a InterNet tene la precaucion de hacerlo por un isp seguro, ya que por
 algunos Isp sale detallado en la cuenta telefonica como llamdas internaciones y con otros
 solo saldria como una llamada local ok....

   Bueno solo me basta decir que una vez que hallas terminado te desconectes
  (medio logico o no)

  Precauciones:
  -------------
  - Como dije no lo hagas en el dia 
  - En una noche de lluvia mmmmmmmmmmm penzandolo mejor en una noche de frio
  - Lo demas lo dejo a criterio tuyo no mas

   Basta decir que esto lo realizaras solo una vez para ver como corre la adrenalina y no
 estaras todas las noches conectandote a costas de los pulmones de las demas personas
 shiaaaaaaaaaa




      *****************************************************************************
 04  **                SISTEMA DE TELEFONIA MOVIL GSM (I CAPITULO)                **
      *****************************************************************************

   LA TARJETA SIM

   La tarjeta SIM es un chip a través del cual nos identificamos ante nuestro operador GSM
 y a través de este con otros operadores. Representa la línea GSM que tenemos contratada,
 ya que la pongamos en uno u otro terminal mantenemos el numero de abonado. La SIM, consta
 de un código de seguridad de acceso llamado PIN, el cual está formado por cuatro dígitos.
 Dicho código podemos cambiarlo a voluntad e incluso anular su petición.Está formada por un
 microprocesador, una memoria ROM y otra RAM de 8K, en la que se encuentran: ·	Una agenda
 de 90 o 100 posiciones para almacenar nombres y números de teléfono. ·	Una agenda de 14 o
 16 posiciones donde quedarán almacenados los SMS recibidos. ·	Una agenda de 10 posiciones
 donde almacenar 10 nombres y números para crear una restricción de llamadas a dichos
 números. Sólo con PIN 2. La SIM consta de un código de acceso, el PIN 1, de 4 dígitos, de
 manera que si lo introducimos 3 veces erróneamente se bloquea. En este caso nos pide el
 PUK 1 que consta de 8 dígitos, si lo introducimos correctamente nos desbloquea el PIN 1.
 Si el PUK se introduce erróneamente 10 veces, la SIM se bloquea indefinidamente. Dispone-
 mos también de un PIN 2 para activar la la marcación fija (agenda de 10 posiciones) o
 control del coste, restricciones,etc. Si lo introducimos 3 veces mal, nos pide el PUK 2
 que consta de 8 dígitos, el cual, una vez introducido correctamente, nos desbloquea el
 PIN2. Si el PUK 2 se introduce erróneamente 10 veces, el PIN 2 se bloquea indefinidamente.
 La podemos encontrar en dos tamaños: ISO, grande o Plug-in pequeña


      *****************************************************************************
 05  **                LINUX PARA PRINCIPIANTES (I CAPITULO)                      **
      *****************************************************************************


   INTRODUCCION AL SISTEMA OPERATIVO

   Linux es principalmente una de las tantas opciones de sistemas operativos diseniados
 especialmente para trabajar en red. Es una plataforma UNIX con un entorno un poco mas
 amigable, sin embargo, podriamos decir que a pesar de algunas diferencias es casi un
 perfecto clon del mismo. Por eso, este tutorial puede servir tambien no para iniciados
 en otras plataformas UNIX, como por ejemplo, FreeBSD, SunSCO, Solaris, Minix, POSIX,
 entre otras.
   Linux es un sistema multiusuario, multitarea, y trabaja en 32 Bits REALES a diferencia
 de otros sistemas como Microsoft Windows 95 / 98 que dice hacerlo pero que en realidad
 trabajan a 16 Bits.
   Quiero hablar un poco sobre las ventajas de usar Linux. Hay muchas cualidades que
 diferencian a Linux de otros Sistemas Operativos (SOs), pero no voy a nombrarlas todas.
 Sus mas grandes ventajas las habran oido seguramente en un canal de chat o en algun texto:
 Linux es reconocido por su gran estabilidad, la excelente administracion de recursos que
 realiza el sistema y su open source (codigo abierto) porque el usuario tiene total 
 libertad sobre el manejo y administracion del sistema. El kernel o nucleo de Linux se
 actualiza todo el tiempo, tapando viejos bugs o agujeros y ampliando  la compatibilidad
 con diferentes dispositivos. El ultimo kernel puede conseguirse a traves de Internet en
 ftp.kernel.org o algunos de sus mirrors.
   Sobre la historia de Linux no puedo decir mucho, nunca me gusto' leer sobre ese tema,
 y casi siempre omito la mayor parte de este cuando leo algun texto referido al sistema,
 lo unico que puedo decirles, que seguro ya sabran es que fue programado originalmente por
 Linus Torvalds que no me acuerdo donde nacio' ni nada, pero lo que si se es que fue un
 capo. Despues se fue mejorando con la ayuda de programadores y hackers de todo el mundo
 (o por lo menos asi lo tengo entendido).
   Otro tema que me gustaria conversar aprovechando este capitulo es referido a los
 hackers. Es normal que muchos usuarios de Windows dejen dicho sistema para acercarse a
 Linux, porque asi se lo recomendaron los comunmente llamados Lamers, ya que es el SO que
 usan comunmente los hackers (valga la rebundancia). Este ultimo dato puede que sea cierto,
 pero mas cierto es que no cualquier persona es un hacker y no vamos a ser hackers solo por
 ser usuarios de Linux. Si queremos usar linux hagamoslo por el solo hecho de querer
 disfrutar de este grandioso SO y no para satisfacer un suenio casi imposible. Espero que
 la gente tome nocion de ello.



   Comandos basicos y semejanzas con otros sistemas operativos.


   Comandos Basicos


   Aunque muchos no lo crean, el llamado Microsoft DOS fue creado mucho despues que UNIX,
 y esta basado en cierto modo, en este ultimo, es por eso que los amantes o simplemente
 usuarios de DOS tendran cierta ventaja cuando nos referimos a algunos (en realidad muy
 pocos) comandos de linux ya que son similares al SO de Microsoft.
   Para saber cual es el contenido del directorio en el que estamos situados existe el
 comando "ls" (list), aunque tambien podemos utilizar alternativamente el tipico de DOS:
 "dir", aunque yo prefiero el primero por ser mas corto. Estos comandos nos mostraran
 simplemente los nombres de los archivos y directorios que se encuentran, como dije antes,
 en el directorio en el que estemos situados. Por ejemplo: estamos situados en el 
 directorio raiz "/" (semejante a c:\ en DOS) y tenemos dentro de este los directorios
 "linux", "mis archivos", "fotos" y "home" y ademas el archivo "linuxfile". Entonces:

   localhost:/# (este es el prompt y la / despues de : indica donde estamos situados)

 localhost:/# ls
 linux	 mis\ archivos	 fotos 	home	 linuxfile
 localhost:/#

   Esa seria la salida al comando "ls". Pero aqui no podemos diferenciar cual es un archivo
 y cual un directorio. Para averiguar esto y otros datos sobre los archivos y directorios
 el comando ls (asi como cualquier otro comando) posee algunas opciones las cuales veremos
 ahora:
   "ls -F" definira' cuales de los nombres de la salida de arriba sera un archivo, y cual
 un directorio. Los terminados con una barra (/) son los directorios, los terminados con un
 asterisco (*) son archivos ejecutables, y los que solo se les muestra el nombre son
 archivos de otro tipo, como por ejemplo, de texto. Veamos un ejemplo:

 localhost:/# ls -F
 linux/  mis\ archivos/  fotos/   home/  linuxfile
 localhost:/# 

   Hay otras opciones para el comando "ls" que iremos viendo conforme tratemos temas
 referidos a su tipo de salida.

   El siguiente comando a tratar es el "cd" (change directory) que como su nombre lo
 indica, sirve para movernos de un directorio a otro. Por ejemplo, si nosotros estamos en
 el directorio raiz (/) y queremos entrar al directorio "linux" que se encuentra en dicho
 directorio debemos tipear "cd" mas el nombre del directorio al que querramos entrar:

 localhost:/# cd linux
 localhost:/linux#

   Como vimos en el ejemplo, el prompt nos muestra que luego de haber ejecutado el comando
 "cd linux" pasamos a estar dentro de dicho directorio. Pero el problema es como hacemos
 para volver un directorio mas abajo. Esto es muy sencillo, ejecutamos el comando "cd .."
 el cual nos dirijira' al directorio que contiene al directorio en el que estamos. (Igual
 que en DOS):

 localhost:/linux# cd ..
 localhost:/#

   Noten que los dos puntos ".." se encuentran separados del comando "cd por un espacio,
 esto es porque si ponemos todo junto el comando sera reconocido como un comando erroneo,
 ya que el sistema buscara' entre los archivos ejecutables el comando "cd.." que por
 supuesto, no existe.

   Ahora puede que surja la posibilidad de que tengamos que copiar un archivo que tenemos
 en un directorio por cualquier motivo que sea. Entonces para ello se usa el comando "cp"
 (copiar). La sintaxis de este comando seria la siguiente:

 localhost:/# cp archivo.que.quiero.copiar dir_de_destino/

   Tambien podemos indicarle al comando "cp" que al copiar el archiv cambie su nombre 
 agregando el nuevo nombre del archivo despues de la barra que marca la carpeta de destino.
 En este caso la sintaxis seria:

 localhost:/# cp archivo.que.quiero.copiar dir_de_destino/archivo.que.copie

   Si en vez de copiar solo un archivo queremos copiar muchos podemos hacerlo solo
 agregando el nombre de cada archivo a copiar uno al lado del otro separados por un
 espacio. Si queremos que se copien todos los archivos que hay en el directorio podemos
 hacer directamente los siguiente:

 localhost:/# cp * dir_de_destino/

   El asterisco abarca todos los archivos y directorios contenidos en el directorio actual.
 Aca podemos encontrar un problema: los directorios no pueden copiarse igual que los
 archivos. Para copiar todo un directorio debemos agregar la opcion "-R" a continuacion del
 comando cp, de otra manera Linux no copiara' ningun directorio:

 localhost:/# cp -R * dir_de_destino/

   Pero si lo que queremos no es copiar un archivo o carpeta sino moverlo de un lado al
 otro, entonces no podemos utilizar el comando cp (en realidad podriamos copiar el archivo
 que necesitaramos mover a otra carpeta y despues borrarlo de el directorio actual, pero
 eso no seria logico). Por lo contrario el comando adecuado para esta operacion seria "mv"
 (move). La sintaxis de este comando es similar a la de cp:

 localhost:/# mv archivo.a.mover directorio_de_destino/

   Pero, en cambio, si queremos mover un directorio entero no nos servira' la opcion "-R" 
 como en cp, sino que deberemos agregar la linea "-f" para forzar la mobilidad del
 directorio con todo su contenido. El comando "mv" no solo sirve para mover archivos o
 directorios de un directorio a otro, sino tambien para renombrarlos. Por ejemplo, si
 queresmos que el archivo 'archivo.a.copiar' se llame 'archivo.que.copiare' debemos usar
 la siguiente linea de comando:

 localhost:/# mv archivo.a.copiar archivo.que.copiare

   En muchas ocasiones hay programas, archivos o directorios que no nos sirven y lo unico
 que hacen es ocupar espacio en nuestro escaso (o quiza no) disco rigido. Si queremos
 eliminar estos archivos o directorios usamos el comando "rm" (remove). Su sintaxis es
 similar a la del comando "cp" o "mv". Por ejemplo, si queremos borrar el archivo
 "viejo_y_nosirve.txt" entonces la sintaxis sera' la siguiente:

 localhost:/# rm viejo_y_nosirve.txt

   Al igual que con el comando "cp" si queremos borrar un directorio con todos su contenido
 deberemos usar la siguiente sintaxis:

 localhost:/# rm -R directorio_viejo/

   Dependiendo de la distribucion de Linux con la que estemos trabajando, nos aparecera la
 pregunta de si queremos eliminar el archivo/directorio o no. Pero por las dudas, antes de
 experimentar, tengamos cuidado y veamos lo que estamos haciendo. Tambien podemos usar el
 comando "rmdir" para borrar un directorio pero lo que hace a este comando poco eficiente
 es que el directorio a eliminar debe estar completamente vacio. Este comando se asemeja al
 comando "rd" de DOS para que tengan una idea.

   Si lo que queremos es crear un directorio entonces el comando que debemos usar es
 "mkdir" y su sintaxis seria la siguiente:

 localhost:/# mkdir directorio_a_crear
 localhost:/#

   Aunque el sistema no nos muestre ninguna senial, el directorio fue creado satisfacto-
 riamente.

   Ahora, para visualizar un archivo, sin tener la posibilidad de modificar su contenido
 podemos usar el comando "more" seguido del nombre del archivo a visualizar. Por ejemplo,
 si queremos visualizar el contenido del archivo "linux-release", por decir algun nombre,
 hacemos lo siguiente:

 localhost:/# more linux-release
 Slackware Linux 3.6 with kernel 2.2.13
 localhost:/#

   Esa seria la salida del comando. Si el archivo a visualizar es muy extenso y no alcanza
 a mostrarse enteramente en pantalla presionamos la tecla "enter" (o intro) para avanzar;
 la tecla "b" retrocedera' una pagina completa; la tecla "'" (apostrofe o tilde) volvera'
 al principio del documento la tecla "h" para obtener ayuda; la tecla "=" nos dira' el
 numero de linea en el que estamos situados; la tecla "!" abrira un subprompt para que
 podamos ejecutar un comando sin salir del documento; la tecla "v" abrira dentro del
 programa more el editor predeterminado de todo sistema Unix que es el VI; y la tecla "q"
 sale del programa more. Para mas opciones importantes leer la ayuda.

   El comando cat sirve para concatenar uno o varios archivos a la vez, sin embargo,
 tambien se lo usa comunmente para visualizar el contenido de un archivo de una sola vez,
 sin la posibilidad de volver hacia atras o de examinar el archivo. Su sintaxis seria asi:

 localhost:/# cat nombre.del.archivo
 Aca se muestra el contenido del archivo.
 localhost:/#

   Esa fue la salida del comando. Si a este comando le sumamos algunos argumentos puede
 que sea de mas utilidad. Por ejemplo, el signo mayor (>) despues antecedido por el comando
 cat y precedido por el nombre de algun archivo que puede o no existir, hara' que se
 escriba en el archivo destino lo que las siguientes lineas que nosotros escribamos
 mientras dure el comando cat que interrumpiremos con la combinacion de las teclas CTRL D.
   Esta seria la salida:

 localhost:/# cat > archivo.destino
 esto es un ejemplo
 de la utilizacion del comando cat
 aqui termina el ejemplo.
 CTRL D
 localhost:/#

   Ahora, si observamos el contenido del archivo "archivo.destino" pasara' lo siguiente:

 localhost:/# more archivo.destino
 esto es un ejemplo
 de la utilizacion del comando cat
 aqui termina el ejemplo.
 localhost:/#

   Los argumentos como los signos mayor (>), menor (<), doble mayor (>>) y doble menor (<<)
 pueden ser combinados con otros comandos de los que ya hemos hablado, por ejemplo:

 localhost:/# ls > archivo.destino
 localhost:/#

   Lo que paso' aqui es que toda la informacion que tendria que haber dirigido el comando
 "ls" a la pantalla se guardo' en el archivo "archivo.destino". El argumento ">>" hace lo
 mismo que el ">" pero la unica diferencia entre ambos es que si el 'archivo.destino' ya
 contiene informacion adentro el >> escribira' la salida del comando ls al final del
 archivo, en cambio el > reescribira' el archivo completo y se perdera' toda la informa-
 cion que este contenia anteriormente.

   Hay una una manera de combinar dos comandos para obtener una salida diferente a su
 salida estandar utilizando la tecla "|". Por ejemplo, si yo hago un ls y su salida ocupa
 mayor tamanio que lo que puede mostrar la pantalla entonces no podre' ver el contenido
 total de todo un directorio, pero si yo combino el comando "ls" con el comando "more"
 entonces la salida sera' similar a visualizar un archivo con el programa more:

 localhost:/# ls | more
 archivo1
 archivo2
 archivo3
 archivo4
 --More--

   Asi seria mas o menos la salida, y cuando apretemos el boton enter se seguiran mostrando
 los demas archivos o directorios contenidos en el directorio actual.
   Tambien podemos combinar el comando "ls" con el comando "sort" que ordenara' alfabetica-
 mente la lista a mostrar:

 localhost:/# ls | sort
 archivo1
 archivo3
 fotos
 home
 linux
 mis\ archivos
 localhost:/#

   Tambien podemos combinar una o mas tareas para que se realicen una detras de la otra
 escribiendolas en una sola linea y separando cada comando con sus respectivos argumentos
 y / o opciones con un punto y coma ';'. Por ejemplo:

 localhost:/# more archivo.txt ; ls ; cd /root
 -----------
 archivo.txt
 -----------
 Esto es lo primero que pasa...
 archivo1
 archivo3
 fotos
 home
 linux
 mis\ archivos
 localhost:/root#

   Como vemos aca, se ejecutaron todos los comandos uno detras de otro como los habiamos
 dicho y no aparecio' en ningun momento intermedio el prompt.

   Para tener un acceso mas agil y rapido a ciertos archivos o directorios podemos crear
 vinculos a ellos. Estos vinculos pueden ser tanto simbolicos como duros. Para crear un
 vinculo de otro directorio o archivo se utiliza el comando 'ln'. Su sintaxis serial el
 comando 'ln' seguido del archivo que queremos vincular (archivo original) y a continuacion
 el nombre y ubicacion del vinculo. Usamos los vinculos simbolicos para vincular
 directorios y los vinculos duros para vincular archivos ejecutables. Veamos un ejemplo:

 localhost:/# ls -F
 archivo1*
 archivo3*
 directorio1/
 directorio2/
 localhost:/# ln -s directorio1 /usr/local/directorio1
 localhost:/# ln -n archivo1 /usr/bin

   Hay veces que necesitamos buscar un archivo que contiene una informacion especifica que
 necesitamos y no sabemos con que nombre lo habiamos guardado. En estos casos el comando
 'grep' nos ayudara' bastante.
   Este comando se encarga de buscar una patron dentro de los archivos que especifiquemos,
 por ejemplo, yo quiero buscar un archivo que contenga las palabras 'Daniel Wyrytowski'. La
 sintaxis de este comando es : grep [opciones] patron de busqueda [donde buscar]
   Por ejemplo:

 localhost:/# grep Daniel /root/*
 /root/LinuxMAN-v1.1:Copyright (C) 1999  Daniel Wyrytowski
 localhost:/#

   Como vemos aca nos esta mostrando toda la linea que contiene las palabras 'Daniel' y si
 observamos mas claramente tambien nos dice (al principio) en que archivo esta, en este
 caso se encuentra en el archivo /root/LinuxMAN-v1.1

   Otros comandos muy utiles dentro de linux son 'du' y 'df'. Estos comandos nos dan
 informacion de la cantidad de espacio libre o utilizado en el sistema. Veamos cada uno de
 ellos.

   El comando 'du': da informacion de el espacio que utiliza un directorio o un rango de
 directorios. Su sintaxis es : 'du [opciones] directorios'

 localhost:/# du -s /usr
 551088  /usr
 localhost:/# 

   Como vemos, el comando nos devolvio' la cantidad de kilobytes que contiene el directorio
 '/usr'. La opcion '-s' hace un resumen de todo mostrandonos el resultado final de la
 cuenta en vez de mostrarnos lo que ocupa cada uno de los directorios que contiene el
 directorio '/usr'.

   El comando 'df': da informacion de el espacio utilizado y disponible en un sistema de
 archivos siempre y cuando estos esten montados. Sobre como montar o desmontar sistemas de
 archivos se vera' en el Capitulo 6.
   Por ejemplo:

 localhost:/# df 
 Filesystem         1024-blocks  Used Available Capacity Mounted on
 /dev/hda1            1016376  733355   230506     76%   /
 /dev/hda2             934629  368684   517662     42%   /mnt
 localhost:/#

   Otro comando muy util es el 'w'. Este comando muestra quienes estan logueados en el
 sistema y que es lo que cada uno de estos usuarios estan haciendo. Veamos un ejemplo:

 localhost:/# w
   3:37pm  up  1:13,  3 users,  load average: 0.00, 0.04, 0.03
 USER     TTY      FROM       LOGIN@   IDLE   JCPU   PCPU  WHAT
 root     tty1                3:19pm  0.00s  0.84s  0.03s  w
 root     tty2                3:28pm  1:37   1.50s  1.39s  joe LinuxMAN-v1.1
 root     tty3                3:32pm  5:19   0.10s  0.10s -bash
 localhost:/#

   Como vemos, la salida se explica por si sola asi que solo dare' una explicacion muy por
 arriba. La primera columna muestra el nombre del usuario logueado. La segunda muestra en
 que consola virtual se encuentra. La tercer columna muestra el host remoto. La columna
 cuarta muestra a que hora se ha logueado en el sistema dicho usuario. La quinta muestra el
 tiempo IDLE. La cuarta muestra muestra el JCPU time que es el tiempo que utilizan todos
 los procesos adjuntos a las consolas virtuales. La sexta muestra el PCPU time que es el
 tiempo que utiliza el proceso que esta marcado en la columna numero 7. En la columna
 numero siete muestra el proceso que esta ejecutando el usuario (generalmente el ultimo
 proceso).
 




      *****************************************************************************
 06  **                             S O C K E T S                                 **
      *****************************************************************************


  1.  Introduccion

  2.  Aplicaciones Cliente/Servidor
      2.1 pake sepan ke es una app C/S
      2.2 Algo de TCP-IP
      2.3 Lista de Puertos

  3.  Socket, la oreja de los procesos
      3.1 Ke es un Socket?  ---> Esto fue extraido de mi cuaderno =)
      3.2 El dominio de un socket

  4. Las Funciones para el manejo de Sockets
     4.1 Descripcion de las Funciones usadas en los Sockets

  5. Ejemplos y Otras Cosass...=)

  6. Gracias Por leer esto...



1. Introduccion


Hace  tiempo  tenia las  ganas de hacer un articulo en el cual, se enseñara a
crear aplicaciondes Cliente/Servidor, y esas ganas se estan materializando hoy.
Es por lo anterior ke me atrevi a hacer un articulos para esta e-zine, la cual
esta comenzando. Con este articulo no pretendo ser una  guia para expertos en la
materia, sino  ke una  ayuda para  akellos ke  estan  comenzando en esto  de la
creacion de aplicaciones Clinete/Servidor(C/S, para ke no se mareen)

Pero ya esta bueno de weadas y vamos a lo ke nos trae a hacer esto.



2. Aplicaciones Cliente/Servidor,


2.1 Para ke sepan ke cosa es app C/S.

Una persona ke desea desarrollar una aplicacion siguiento la arkitectura C/S de-
be contar con funciones ke gestionen todos los procesos de conexion, envio de
datos, recepcion de datos. A estas funciones, se le llama Inferfaz de programa-
cion, ke en nuestro caso son los sockets. Estos se componen de funciones las
ke realizan las tareas puntuales, estas se trabajan como si uno estubiera traba-
jando  con  archivos  en  C; las  funciones  seran  explicadas en detalle mas
adelante.

Para la creacion de aplicaciones el desarrollador o programador se apoya en un
protocolo establecido en la red, para este articulo nos centraremos en el proto-
tolo por defecto  de la Inet(Internet, o para algunos despues de ver Serial Espe-
riment Lain la Wired jejeje =)..., ya deberias saber ke es TCP-IP, sino sabias
antes de seguir seria mejor ke mires algun articulo te toke  ese tema o algun
libro, no recomiendo ninguno, ya ke hay muchos ke son muy buenos...

Continuemos... ahp enke estaba? ayap!!

Cada aplicacion tiene su propio protocolo esto es, cuando uno se encuentra
con alguna persona, lo primero ke hace es Saludar y luego se van turnando en la
conversacion, uno hace el papel del ke estucha y el otro habla... bueno esto se
tambien se usa para la aplicaciones C/S, en un comienzo el Servidor esta escu-
chando, es decir esta listo para entablar una conversacion y llega un cliente
ke kiere hablar y ... ya se lo pueden imaginar. Si kieren saber como funcionan
algunas aplicaciones como el telnet, ftp u otra cosa pueden ver los RFC's ke
claro estan en ingles =( pero hay algunos ke estan traducidos, esto los encuen-
tran en el sitio: http://lucas.hispalinux.es o en el http://lucas.linux.cl/
los ke estan en ingles los encuentar en la siguiente, pongo esta porke estan
zipiados http://www.rfc-editor.org/download.html

Para los ke no saben ke son los RFC's (solicitides de comentario), estos son
documentos ke se emiten periodicamente y establecen normas o estandares para
la Inet.


2.2 Algo de TCP-IP.

Ke es TCP-IP?

Es el protocolo usado en Inet, este esta compuesto de dos protocolos los cuales
son el TCP(Transmision Control Protocol), y el IP (Inertent Protocol).

El TCP como su nombre indica, es el protolo ke se encarga de la entrega de los
paketes, brindando confiabilidad en las entrega. No asi como su hermanastro,
ese loko, el UDP(User Datagram Protocol) el cual no tiene la confiabilidad de
su broder. El IP es el protocolo basico de Inet, es el ke se encarga del
direccionamiento de los paketes y el proceso de fragmentacion.

Otra de las cosas importantes ke debo mencionar del TCP es ke incluye un
concepto, siii el de Puerto... Los puertos son numeros ke van desde el 1 hasta
65.535 ke permiten ke los paketes de informacion sean enviados a una parte
especifica de la app. Los estos numero tb representan SERVICIOS ke presta la
makina.

Aki esta una lista con los servicios, fue extraida de un LINUX DEABIAN 2.0.36 del
archivo "/etc/services"

tcpmux		1/tcp				# TCP port service multiplexer
echo		7/tcp
echo		7/udp
discard		9/tcp		sink null
discard		9/udp		sink null
systat		11/tcp		users
daytime		13/tcp
daytime		13/udp
netstat		15/tcp
qotd		17/tcp		quote
msp		18/tcp				# message send protocol
msp		18/udp				# message send protocol
chargen		19/tcp		ttytst source
chargen		19/udp		ttytst source
ftp-data	20/tcp
ftp		21/tcp
fsp		21/udp		fspd
ssh		22/tcp				# SSH Remote Login Protocol
ssh		22/udp				# SSH Remote Login Protocol
telnet		23/tcp				# 24 - private
smtp		25/tcp		mail 		# 26 - unassigned
time		37/tcp		timserver
time		37/udp		timserver
rlp		39/udp		resource		# resource location
nameserver	42/tcp		name		# IEN 116
whois		43/tcp		nicname
re-mail-ck	50/tcp				# Remote Mail Checking Protocol
re-mail-ck	50/udp				# Remote Mail Checking Protocol
domain		53/tcp		nameserver		# name-domain server
domain		53/udp		nameserver
mtp		57/tcp				# deprecated
bootps		67/tcp				# BOOTP server
bootps		67/udp
bootpc		68/tcp				# BOOTP client
bootpc		68/udp
tftp		69/udp
gopher		70/tcp				# Internet Gopher
gopher		70/udp
rje		77/tcp		netrjs
finger		79/tcp
www		80/tcp		http		# WorldWideWeb HTTP
www		80/udp				# HyperText Transfer Protocol
link		87/tcp		ttylink
kerberos	88/tcp		kerberos5 krb5	# Kerberos v5
kerberos	88/udp		kerberos5 krb5	# Kerberos v5
supdup		95/tcp
# 100 - reserved
hostnames	101/tcp		hostname		# usually from sri-nic
iso-tsap	102/tcp		tsap		# part of ISODE.
csnet-ns	105/tcp		cso-ns		# also used by CSO name server
csnet-ns	105/udp		cso-ns
#3com-tsmux	106/tcp		poppassd
#3com-tsmux	106/udp		poppassd
rtelnet		107/tcp				# Remote Telnet
rtelnet		107/udp
pop-2		109/tcp		postoffice		# POP version 2
pop-2		109/udp
pop-3		110/tcp				# POP version 3
pop-3		110/udp
sunrpc		111/tcp		portmapper		# RPC 4.0 portmapper TCP
sunrpc		111/udp		portmapper		# RPC 4.0 portmapper UDP
auth		113/tcp		authentication tap ident
sftp		115/tcp
uucp-path	117/tcp
nntp		119/tcp		readnews untp	# USENET News Transfer Protocol
ntp		123/tcp
ntp		123/udp				# Network Time Protocol
netbios-ns	137/tcp				# NETBIOS Name Service
netbios-ns	137/udp
netbios-dgm	138/tcp				# NETBIOS Datagram Service
netbios-dgm	138/udp
netbios-ssn	139/tcp				# NETBIOS session service
netbios-ssn	139/udp
imap2		143/tcp				# Interim Mail Access Proto v2
imap2		143/udp
snmp		161/udp				# Simple Net Mgmt Proto
snmp-trap	162/udp		snmptrap		# Traps for SNMP
cmip-man	163/tcp				# ISO mgmt over IP (CMOT)
cmip-man	163/udp
cmip-agent	164/tcp
cmip-agent	164/udp
xdmcp		177/tcp				# X Display Mgr. Control Proto
xdmcp		177/udp
nextstep	178/tcp		NeXTStep NextStep	# NeXTStep window
nextstep	178/udp		NeXTStep NextStep	# server
bgp		179/tcp				# Border Gateway Proto.
bgp		179/udp
prospero	191/tcp				# Cliff Neuman's Prospero
prospero	191/udp
irc		194/tcp				# Internet Relay Chat
irc		194/udp
smux		199/tcp				# SNMP Unix Multiplexer
smux		199/udp
at-rtmp		201/tcp				# AppleTalk routing
at-rtmp		201/udp
at-nbp		202/tcp				# AppleTalk name binding
at-nbp		202/udp
at-echo		204/tcp				# AppleTalk echo
at-echo		204/udp
at-zis		206/tcp				# AppleTalk zone information
at-zis		206/udp
qmtp		209/tcp				# The Quick Mail Transfer Protocol
qmtp		209/udp				# The Quick Mail Transfer Protocol
z3950		210/tcp		wais		# NISO Z39.50 database
z3950		210/udp		wais
ipx		213/tcp				# IPX
ipx		213/udp
imap3		220/tcp				# Interactive Mail Access
imap3		220/udp				# Protocol v3
ulistserv	372/tcp				# UNIX Listserv
ulistserv	372/udp
https		443/tcp				# MCom
https		443/udp				# MCom
snpp		444/tcp				# Simple Network Paging Protocol
snpp		444/udp				# Simple Network Paging Protocol
saft		487/tcp				# Simple Asynchronous File Transfer
saft		487/udp				# Simple Asynchronous File Transfer
npmp-local	610/tcp		dqs313_qmaster	# npmp-local / DQS
npmp-local	610/udp		dqs313_qmaster	# npmp-local / DQS
npmp-gui	611/tcp		dqs313_execd	# npmp-gui / DQS
npmp-gui	611/udp		dqs313_execd	# npmp-gui / DQS
hmmp-ind	612/tcp		dqs313_intercell	# HMMP Indication / DQS
hmmp-ind	612/udp		dqs313_intercell	# HMMP Indication / DQS
exec		512/tcp
biff		512/udp		comsat
login		513/tcp
who		513/udp		whod
shell		514/tcp		cmd		# no passwords used
syslog		514/udp
printer		515/tcp		spooler		# line printer spooler
talk		517/udp
ntalk		518/udp
route		520/udp		router routed	# RIP
timed		525/udp		timeserver
tempo		526/tcp		newdate
courier		530/tcp		rpc
conference	531/tcp		chat
netnews		532/tcp		readnews
netwall		533/udp				# -for emergency broadcasts
uucp		540/tcp		uucpd		# uucp daemon
afpovertcp	548/tcp				# AFP over TCP
afpovertcp	548/udp				# AFP over TCP
remotefs	556/tcp		rfs_server rfs	# Brunhoff remote filesystem
klogin		543/tcp				# Kerberized `rlogin' (v5)
kshell		544/tcp		krcmd		# Kerberized `rsh' (v5)
kerberos-adm	749/tcp				# Kerberos `kadmin' (v5)
webster		765/tcp				# Network dictionary
webster		765/udp
ingreslock	1524/tcp
ingreslock	1524/udp
prospero-np	1525/tcp				# Prospero non-privileged
prospero-np	1525/udp
datametrics	1645/tcp		old-radius		# datametrics / old radius entry
datametrics	1645/udp		old-radius		# datametrics / old radius entry
sa-msg-port	1646/tcp		old-radacct		# sa-msg-port / old radacct entry
sa-msg-port	1646/udp		old-radacct		# sa-msg-port / old radacct entry
radius		1812/tcp				# Radius
radius		1812/udp				# Radius
radacct		1813/tcp				# Radius Accounting
radacct		1813/udp				# Radius Accounting
cvspserver	2401/tcp				# CVS client/server operations
cvspserver	2401/udp				# CVS client/server operations
mysql		3306/tcp				# MySQL
mysql		3306/udp				# MySQL
rfe		5002/tcp				# Radio Free Ethernet
rfe		5002/udp				# Actually uses UDP only
cfengine	5308/tcp				# CFengine
cfengine	5308/udp				# CFengine
bbs		7000/tcp				# BBS service
kerberos4	750/udp		kerberos-iv kdc	# Kerberos (server) udp
kerberos4	750/tcp		kerberos-iv kdc	# Kerberos (server) tcp
kerberos_master	751/udp				# Kerberos authentication
kerberos_master	751/tcp				# Kerberos authentication
passwd_server	752/udp				# Kerberos passwd server
krb_prop	754/tcp				# Kerberos slave propagation
krbupdate	760/tcp		kreg		# Kerberos registration
kpasswd		761/tcp		kpwd		# Kerberos "passwd"
kpop		1109/tcp				# Pop with Kerberos
knetd		2053/tcp				# Kerberos de-multiplexor
zephyr-srv	2102/udp				# Zephyr server
zephyr-clt	2103/udp				# Zephyr serv-hm connection
zephyr-hm	2104/udp				# Zephyr hostmanager
eklogin		2105/tcp				# Kerberos encrypted rlogin
supfilesrv	871/tcp				# SUP server
supfiledbg	1127/tcp				# SUP debugging
rtmp		1/ddp				# Routing Table Maintenance Protocol
nbp		2/ddp				# Name Binding Protocol
echo		4/ddp				# AppleTalk Echo Protocol
zip		6/ddp				# Zone Information Protocol
poppassd	106/tcp				# Eudora
poppassd	106/udp				# Eudora
mailq		174/tcp				# Mailer transport queue for Zmailer
mailq		174/tcp				# Mailer transport queue for Zmailer
omirr		808/tcp		omirrd		# online mirror
omirr		808/udp		omirrd		# online mirror
rsync		873/tcp				# rsync
rsync		873/udp				# rsync
socks		1080/tcp				# socks proxy server
socks		1080/udp				# socks proxy server
rmtcfg		1236/tcp				# Gracilis Packeten remote config server
xtel		1313/tcp				# french minitel
coda_opcons	1355/udp				# Coda opcons            (Coda fs)
coda_venus	1363/udp				# Coda venus             (Coda fs)
coda_auth	1357/udp				# Coda auth              (Coda fs)
coda_udpsrv	1359/udp				# Coda udpsrv            (Coda fs)
coda_filesrv	1361/udp				# Coda filesrv           (Coda fs)
codacon		1423/tcp		venus.cmu		# Coda Console           (Coda fs)
coda_aux1	1431/tcp				# coda auxiliary service (Coda fs)
coda_aux1	1431/udp				# coda auxiliary service (Coda fs)
coda_aux2	1433/tcp				# coda auxiliary service (Coda fs)
coda_aux2	1433/udp				# coda auxiliary service (Coda fs)
coda_aux3	1435/tcp				# coda auxiliary service (Coda fs)
coda_aux3	1435/udp				# coda auxiliary service (Coda fs)
cfinger		2003/tcp				# GNU Finger
ninstall	2150/tcp				# ninstall service
ninstall	2150/udp				# ninstall service
afbackup	2988/tcp				# Afbackup system
afbackup	2988/udp				# Afbackup system
icp		3130/tcp				# Internet Cache Protocol (Squid)
icp		3130/udp				# Internet Cache Protocol (Squid)
postgres	5432/tcp				# POSTGRES
postgres	5432/udp				# POSTGRES
fax		4557/tcp				# FAX transmission service        (old)
hylafax		4559/tcp				# HylaFAX client-server protocol  (new)
noclog		5354/tcp				# noclogd with TCP (nocol)
noclog		5354/udp				# noclogd with UDP (nocol)
hostmon		5355/tcp				# hostmon uses TCP (nocol)
hostmon		5355/udp				# hostmon uses TCP (nocol)
ircd		6667/tcp				# Internet Relay Chat
ircd		6667/udp				# Internet Relay Chat
webcache	8080/tcp				# WWW caching service
webcache	8080/udp				# WWW caching service
tproxy		8081/tcp				# Transparent Proxy
tproxy		8081/udp				# Transparent Proxy
mandelspawn	9359/udp		mandelbrot		# network mandelbrot
amanda		10080/udp				# amanda backup services
kamanda		10081/tcp				# amanda backup services (Kerberos)
kamanda		10081/udp				# amanda backup services (Kerberos)
amandaidx	10082/tcp				# amanda backup services
amidxtape	10083/tcp				# amanda backup services
isdnlog		20011/tcp				# isdn logging system
isdnlog		20011/udp				# isdn logging system
vboxd		20012/tcp				# voice box system
vboxd		20012/udp				# voice box system
binkp        	24554/tcp				# Binkley
binkp           24554/udp				# Binkley
asp		27374/tcp				# Address Search Protocol
asp		27374/udp				# Address Search Protocol
tfido           60177/tcp				# Ifmail
tfido           60177/udp				# Ifmail
fido            60179/tcp				# Ifmail
fido            60179/udp				# Ifmail







3 Socket, La oreja de los procesos.

3.1 Ke es un Socket?  ---> Esto fue extraido de mi cuaderno =)


Un socket es un punto de comunicacion por el cual un proceso puede enviar o
recibir informacion. En el interior de un proceso un socket se identifica por
un descriptor de la misma naturaleza ke los de los archivos, es decir son del
mismo conjuntos. Esta propiedad es esencial, puesto ke permite. por ejem, la
redirecion de los archivos de entrada/salida estandar(descriptores 0, 1 y 2)
a los socketsy por tanto la utilizacion de app's estandar sobre la red. Esto
significa tambien ke todo nuevo proceso (creado por un fork) hereda los
descriptores de socket de su padre.

La creacion de un socket se realiza por la instrucion socket cuyo valor de
vuelta de es un descriptor sobre el cual es posible realizar operaciones de
lectura y escritura. Un socket permite la comunicacion en los dos sentidos.


3.2 El dominio de un socket

Especificar el formato de la direccion, es definir las esctrutura o armado de
las direcciones, mejor explico esto con un ejemplo

La estructura generica es:


        struct sockaddr{
                u_short         sa_family   /* familia de direccion */
                char            sa_data[14] /* espacio para el pakete*/
        };


ke se utiliza para describir las direcciones primitivas.

Para una aplicacion en particular, esta estructura se debe remplazar por la
estructura correspondiente al dominio de comunicacion ke utilizara la app.

Algunas estructuras son...:


  I) Para dominio UNIX (AF_UNIX), estos socket son locales al sistema ke han
sido creados. Permite la comunicacion entre procesos.

La estrutura de una direccion en este dominio esta predefinida en <sys/un.h>


        struct sockaddr_un{
                u_short         sun_family  /* dominio Unix: AF_UNIX */
                char            sun_data[108] /*espacio para pakete */
        };


 II) Para el dominio Inet (AF_INET), las estructura de los sockets tienen la
la siguiente estructura:


        struct in_addr{
                u_longs addr;
        };


        struct sockaddr_in{
                short           sin_family; /* familia AF_INET */
                u_short         sin_port;   /* numero de puerto */
                struct in_addr  sin_addr;   /* la direccion de Inet*/
                char            sin_zaro[8] /* un campo de 8 ceros */



III) Existen otros dominios pero solo los nombrare...

        AF_NS           /* protocolo XEROS NS */
        AF_CCITT        /* protocolo CCITT, protocolo x25, etc */
        AF_SNA          /* IBM SNA, para red IBM */
        AF_DECnet       /* DECnet */
        AF_APPLETALK    /* Apple Talk, para red Mac */




4. Las Funciones para el manejo de Sockets

Aki pongo una tabla con las funciones para la utilizar los socketes...

+--------------+--------------------------------------------------------------+
|  Funcion     |                        Detalle                               |
+--------------+--------------------------------------------------------------+
|socket        |Crea un descriptor                                            |
|connect       |Conecta el cliente(terminal Local) con el servidor(terminal   |
|              |remota)                                                       |
|write         |Envia informacion a traves de la conexion establecida         |
|read          |Recibe las informacion ke viene por el punto de conexion      |
|close         |Termina la conexion y libera el descriptor                    |
|bind          |Establece el vinculo entre el socket, la  @ip y el puerto     |
|listen        |Espera conexion, se usa para la creacion de app serv          |
|accept        |El serv accepta la conexion de un cliente                     |
|recv          |Recive el siguinete DATAGRAMA                                 |
|recvmsg       |Es una variacion recv ke se usa con la misma fuencion         |
|recvfrom      |Recive el siguinete DATAGRAMA y graba la @ip final ke hace de |
|              |fuente                                                        |
|send          |Envia un DATAGRAMA                                            |
|sendmsg       |Es una variacion de send ke tiene la misma fuencion           |
|sendto        |Envia un DATAGRAMA a una @ip                                  |
|shutdown      |Termina una conexion TCP/IP, en un sentido, en otro o en ambos|
|getpeerbyname |Obtiene la @ip de una makina remota  usando conexion TCP/IP   |
|getsockopt    |Lee las opciones de un socket                                 |
|setsockopt    |Cambia opciones de un socket                                  |
|gethostbyaddr |Busca informacion de una makina por su @ip                    |
|gethostbyname |Busca informacion de una makina por su nombre                 |
|gethostid     |Nosda la @ip de la makina en ke esta corriendo la app         |
|gethostname   |Nosda el nombre de la makina en ke esta corriendo la app      |
|getprotobyname|Nosda el numero para un protocolo valido sabiendo solo el name|
|getservbyname |Nosda el nombre del servicio ke corre en el serv              |
|getsockname   |Entrega el nombre de un determinado socket                    |
|select        |Un proceso espera a ke el primer descriptor de un conjunto    |
|              |determinado de descriptores este preparado                    |
+--------------+--------------------------------------------------------------+

4.1 Descripcion de las Funciones usadas en los Sockets

-> socket

   Descripcion : Esta funcion creas un socket ke se usa para la comunicacion
                dentro de una RED, la funcion devuelve un descriptor

   Definicion  : int socket ( int familia, int tipo, int protocolo);

                 # familia  : es la familia o dominio de las direcciones ke se
                            van a usar; AF_UNIX, AF_INET, ...
                 # tipo     : es el tipo de conexion, SOCK_STREAM para TCP o
                            SOCK_DGRAM para UDP
                 # Protocolo: es el numero de protocolo ke se va a usar; el 0
                            es el valor por defecto, siendo el 6 TCP y el 17 UDP


   Para ver una lista con todos los Protocolos ve el fichero "protocolos" ke esta
en "/etc/protocols"...

El valor devuelto por la fucion socket es un valor positivo si sale todo bien, o
un -1 si algo fallo. En el caso de error, la variable "errno" (vea el man!! komo
teclea en la consola  "man errno" enter, para salir usa la "q")... para saber
algo mas de socket ver el man socket

-> connect

   Descripcion: Mediante esta funecion se especifica la @ip remota, para un
socket previa% creado. Si el socket es TCP, connect usa paketes para estableser
la conexion, mientras ke en UDP no envia ningun pakete.

   Deficionion: int connect(int socket, sockaddr_in *direccion, int long_dir);

   Donde      :
                # socket : es el descriptor del socket.
                # sockaddr_in : es la @ip de la makina remota y usa una estruct
                         ke se mostro anterio%.
                #long_dir: es la logitud de la @ip
Cuando sale todo bien devuelve un 0, pero si algo sale mal entrega un -1.

-> write

   Descripcion: Esta funcion envia o transmite datos entre las makinas.

   Definicion : int write( int socket, char *buffer, int long_buffer);

   Donde      :
                # socket : es el descriptor del socket.
                # buffer : es la direccion de un espacio reservado ke tine datos
                          ke se kieren enviar.
                # long_buffer: es el tamaño del buffer.

Si todo sale Bien entrega un 0, si algo fallo entrega -1.


-> read

   Descripcion: Esta funecion recibe datos de la makina remota.

   Definicion : int read(int socket, char *buffer, int long_buffer);

   Donde      :
                # socket: es el descriptor.
                # buffer: es la direccion del espacio reservado para poner los
                        datos.
                # long_buffer: es el tamaño del buffer.

Si todo bien entrega un 0, si hay un error -1.

-> close

   Descripcion: Cierra la comunicacion y libera el descriptor.

   Definicion : int close( int socket);

   Donde      :
                # socket: es el descriptor ke se kiere liberar.

Si todo bien .... ya saben!!


!!!Hasta aki llega esta entrega!! ya ke tengo algo de problemas de tiempo...!!!
   no vemos en el proximo numero.....!


Si kieres hacer preguntas manda un correo, si me kieres correguir!! tb manda un
correo al EDITOR...


      *****************************************************************************
 07  **                                                                           **
      *****************************************************************************

Todo aquel que sea conceptualizado como un Internauta se caracteriza por utilizar 
un teléfono, un módem y una computadora para muchos fines diferentes: Divertirnos,
informarnos, estudiar, cocinar, planificar viajes y otras actividades que amplían
nuestro quehacer diario. Para Kevin Mitnick el quehacer diario en sus últimos diez
años fue el explorar y explotar computadoras ajenas y sistemas telefónicos. ¿Su 
profesión? Hacker de nacimiento.

Este terrorista electrónico, como lo cataloga el Departamento de Justicia de los
Estados Unidos, conocido en los medios como el Cóndor, fue capaz de crear números
telefónicos imposibles de facturar (para la compañía telefónica él era James Bond,
con un número que terminaba en 007), pudo apropiarse de 20.000 números de tarjetas
de crédito de habitantes de California y burlarse del FBI por más de dos años con 
sólo un teléfono celular alterado y un computador portátil.

Es la peor pesadilla de las empresas de telefonía. Es sospechoso de robar el software
de más de media docena de fabricantes de teléfonos celulares y tenía el control de 
tres oficinas centrales de teléfonos en Manhattan y de todos los centros de conmutación
de California, dándole la habilidad de escuchar cualquier conversación telefónica o, 
si no eras una persona de su agrado, modificar el teléfono de tu casa de tal manera 
que, cada vez que levantaras el auricular, una grabadora pedía que depositaras 25 
centavos. 

¿Cómo se forma un Hacker?

Como Hacker, la carrera de Mitnick tiene sus inicios en 1980 cuando apenas contaba 
16 años y, obsesionado por las redes de computadoras, rompió la seguridad del 
sistema administrativo de su colegio, pero no para alterar sus notas, lo hizo 
solo para mirar. Su bautizo como infractor de la ley fue en 1981. Junto a dos 
amigos entró físicamente a las oficinas de COSMOS de Pacific Bell. COSMOS 
(Computer System for Mainframe Operations) era una base de datos utilizada por la 
mayor parte de las compañías telefónicas norteamericanas para controlar el registro
de llamadas. Una vez dentro de las oficinas obtuvieron la lista de claves de seguridad,
la combinación de las puertas de acceso de varias sucursales y manuales del sistema
COSMOS. La información robada tenía un valor equivalente a los 200 mil dólares. Fueron
delatados por la novia de uno de los amigos y debido a su minoría de edad una Corte
Juvenil lo sentenció a tres meses de cárcel y a un año bajo libertad condicional.

Luego de cumplido el período de tres meses el oficial custodio encargado de su caso
encontró que su teléfono fue desconectado y que en la compañía telefónica no había 
ningún registro de él.

Sus objetivos iban creciendo a cada paso y en 1982 entró ilegalmente, via módem, a
la computadora del North American Air Defense Command en Colorado. Antes de entrar
alteró el programa encargado de rastrear la procedencia de las llamadas y desvió el
rastro de su llamada a otro lugar. El FBI, creyendo que había hallado a Mitnick, 
allanó la casa de unos inmigrantes que estaban viendo televisión.

Un año más tarde fue arrestado de nuevo cuando era estudiante de la Universidad del 
Sur de California. En esta ocasión entró ilegalmente a ARPAnet (la predecesora de 
Internet) y trató de accesar a la computadora del Pentágono. Lo sentenciaron a seis
meses de cárcel en una prisión juvenil en California.

En 1987, luego de tratar de poner su vida en orden, cayó ante la tentación y fue 
acusado, en Santa Cruz California, de invadir el sistema de la compañía Microcorp 
Systems. Lo sentenciaron a tres años de libertad condicional y luego de la sentencia
su expediente desapareció de la computadora de la policia local.

Luego buscó trabajo en lo que mejor sabía hacer y solicitó empleo en el Security 
Pacific Bank como encargado de la seguridad de la red del banco. El banco lo rechazó
por sus antecedentes penales y Mitnick falsificó un balance general del banco donde 
se mostraban pérdidas por 400 millones de dólares y trató de enviarlo por la red. 
Afortunadamente el administrador de la red detuvo el balance antes de que viera la luz.

Ese mismo año inició el escandalo que lo lanzó a la fama. Durante meses observó 
secretamente el correo electrónico de los miembros del departamento de seguridad
de MCI Communications y Digital Equipment Corporation para conocer cómo estaban 
protegidos las computadoras y el sistema telefónico de ambas compañías.

Luego de recoger suficiente información se apoderó de 16 códigos de seguridad de 
MCI y junto a un amigo, Lenny DiCicco, entraron a la red del laboratorio de 
investigaciones de Digital Corporation, conocida como Easynet. Ambos Hackers 
querían obtener una copia del prototipo del nuevo sistema operativo de seguridad
de Digital llamado VMS. El personal de seguridad de Digital se dio cuenta 
inmediatamente del ataque y dieron aviso al FBI, y comenzaron a rastrear a
los hackers.

Mitnick fue un mal cómplice y, a pesar de que habían trabajado juntos, trató de 
echarle toda la culpa a DiCicco haciendo llamadas anónimas al jefe de éste que 
trabajaba en una compañía de software como técnico de soporte. Lleno de rabia y 
frustración DiCicco le confesó todo a su jefe que los denunció a Digital y al FBI.

Mitnick fue arrestado en 1988 por invadir el sistema de Digital Equipment. La 
empresa acusó a Mitnick y a DiCicco ante un juez federal de causarles daños por
4 millones de dólares en el robo de su sistema operativo. Fue declarado culpable
de un cargo de fraude en computadoras y de uno por posesión ilegal de códigos de
acceso de larga distancia.

Adicional a la sentencia el fiscal obtuvo una orden de la corte que prohibía a 
Mitnick el uso del teléfono en la prisión alegando que el prisionero podría obtener
acceso a las computadoras a través de cualquier teléfono. A petición de Mitnick el 
juez lo autorizó a llamar únicamente a su abogado, a su esposa, a su madre y a su 
abuela y sólo bajo supervisión de un oficial de la prisión.

Este caso produjo revuelo en los Estados Unidos, no sólo por el hecho delictivo 
sino por la táctica que utilizó la defensa. Su abogado convenció al juez que 
Mitnick sufría  de una adicción por las computadoras equivalente a la de un 
drogadicto, un alcohólico o un apostador. Gracias a esta maniobra de la defensa
Mitnick fue sentenciado a sólo un  año de prisión y al salir de allí debía 
seguir un programa de seis meses para tratar su adicción a las computadoras.
Durante su tratamiento le fue prohibido tocar una computadora o un módem y 
llegó a perder más de 45 kilos.

Para 1991 ya era el Hacker que había ocupado la primera plana del New York Times 
y uno de sus reporteros, John Markoff, decidió escribir un libro de estilo Cyberpunk
narrando las aventuras de Mitnick. Al parecer a Mitnick no le gustó el libro ya que 
luego de salir a la venta, la cuenta en Internet de Markoff fue invadida, cambiando
su nivel de acceso, de manera de que cualquier persona en el mundo conectada a 
Internet podía ver su correo electrónico.

En 1992, y luego de concluir su programa, Mitnick comenzó a trabajar en una agencia 
de detectives. Pronto se descubrió un manejo ilegal en el uso de la base de datos y
fue objeto de una investigación por parte del FBI quien determinó que había violado
los términos de su libertad condicional. Allanaron su casa pero había desaparecido 
sin dejar rastro alguno. Ahora Mitnick se había convertido en un Hacker prófugo.

El fiscal no estaba tan equivocado cuando pidió la restricción del uso del teléfono. 
También en 1992, el Departamento de Vehículos de California ofreció una recompensa de
1 millón de dólares a quien arrestara a Mitnick por haber tratado de obtener una 
licencia de conducir de manera fraudulenta, utilizando un código de acceso y enviando
sus datos vía fax.

El Fín

Luego de convertirse en prófugo de la justicia cambió de táctica y concluyó que la 
mejor manera de no ser rastreado era utilizando teléfonos celulares. De esta manera
podría cometer sus fechorías y no estar atado a ningún lugar fijo. Para ello 
necesitaba obtener programas que le permitieran moverse con la misma facilidad con 
que lo hacía en la red telefónica.

Luego de varios intentos infructuosos, en cuanto a calidad de información, se 
encontró con la computadora de Tsutomu Shimomura la cual invadió en la Navidad
de 1994. Shimomura, físico computista y experto en sistemas de seguridad del 
San Diego Supercomputer Center, era además un muy buen Hacker, pero era de los
chicos buenos, ya que cuando hallaba una falla de seguridad en algún sistema
lo reportaba a las autoridades, no a otros Hackers.

Shimomura notó que alguien había invadido su computadora en su ausencia, utilizando
un método de intrusión muy sofisticado y que él nunca antes había visto. El intruso
le había robado su correo electrónico, software para el control de teléfonos celulares
y varias herramientas de seguridad en Internet. Allí comenzó la cuenta regresiva para
Mitnick. Shimomura se propuso como orgullo personal atrapar al Hacker que había 
invadido su privacidad.

Hacia finales de enero de 1995, el software de Shimomura fue hallado en una 
cuenta en The Well, un proveedor de Internet en California. Mitnick había 
creado una cuenta fantasma en ese proveedor y desde allí utilizaba las 
herramientas de Shimomura para lanzar ataques hacia una docena de corporaciones
de computadoras, entre ellas Motorola, Apple y Qualcomm.

Shimomura se reunió con el gerente de The Well y con un técnico de Sprint 
(proveedor de servicios telefónicos celulares) y descubrieron que Mitnick 
había creado un número celular fantasma para accesar el sistema. Luego de
dos semanas de rastreos determinaron que las llamadas provenían de Raleigh,
 California. 

Al llegar Shimomura a Raleigh recibió una llamada del experto en seguridad 
de InterNex, otro proveedor de Internet en California. Mitnick había invadido 
otra vez el sistema de InterNex, había creado una cuenta de nombre Nancy, 
borrado una con el nombre Bob y había cambiado varias claves de seguridad
incluyendo la  del experto y la del gerente del sistema que posee los 
privilegios más altos. De igual manera Shimomura tenía información sobre
la invasión de Mitcnick a Netcom, una red de base de datos de noticias.

Shimomura se comunicó con el FBI y éstos enviaron a un grupo de rastreo
por radio. El equipo de rastreo poseía un simulador de celda, un equipo
normalmente utilizado para probar teléfonos celulares pero modificado para
rastrear el telefono de Mitnick mientras este está encendido y aunque no 
esté en uso. Con este aparato el celular se convertiría en un transmisor
sin que el usuario lo supiera.

A medianoche terminaron de colocar los equipos en una Van y comenzó la 
búsqueda de la señal, porque eso era lo que querían localizar; no buscaban
a un hombre porque todas  as fotos que tenían eran viejas y no estaban 
seguros de su aspecto actual, el objetivo de esa noche era determinar el 
lugar de procedencia de la señal. Ya para la madrugada localizaron la señal 
en un grupo de apartamentos pero no pudieron determinar en cuál debido a
interferencias en la señal.

Mientras esto ocurría la gente de InterNex, The Well y Netcom estaban 
preocupados por los movimientos que casi simultáneamente Mitnick hacía
en cada uno de estos sistemas. Cambiaba claves de acceso que él mismo
había creado y que tenían menos de 12 horas de creadas, utilizando códigos
extraños e irónicos como no,panix,  fukhood y fuckjkt. Estaba creando 
nuevas cuentas con mayores niveles de seguridad como si sospechara que
lo estaban vigilando.

El FBI, Shimomura y el equipo de Sprint se habían reunido para planificar la 
captura. Shimomura envió un mensaje codificado al buscapersonas del encargado
en Netcom para advertirle que el arresto se iba a realizar al día siguiente, 
16 de Febrero. Shimomura envió el mensaje varias veces por equivocación y el
encargado interpretó que Mitnick ya había sido arrestado adelantándose a 
realizar una copia de respaldo de todo el material que Mitnick había almacenado
en Netcom como evidencia y borrando las versiones almacenadas por Mitnick. 
Había que realizar el arresto de inmediato, antes de que Mitnick se diera 
cuenta de que su información había sido borrada.

Cuando faltaban minutos para dar la orden el simulador de celdas detectó una 
nueva señal de transmisión de datos vía celular y simultánea a la de Mitnick,
muy cerca de esa zona. Algo extraño estaba haciendo Mitnick con las líneas 
celulares, Shimomura trató de advertirle al agente del FBI pero ya todo estaba
en manos de ellos, Shimomura de ahora en adelante no era más que un espectador 
privilegiado. El FBI no pensaban hacer una entrada violenta porque no creían que
Mitnick estuviera armado, pero tenían que actuar muy rápido porque sabían el daño
que este hombre podía causar en un solo minuto con una computadora. Se acercaron
lentamente hasta la entrada del apartamento de Mitnick y anunciaron su presencia,
si no les abrían la puerta en cinco segundos la echarían abajo. Mitnick abrió 
la puerta con toda calma y el FBI procedió a arrestarlo y a decomisar todo el 
material pertinente discos, computador, teléfonos celulares, manuales, etc.

De regreso a su hotel Shimomura decide chequear la contestadora telefónica 
de su residencia en San Diego. Se quedó en una pieza cuando escucho la voz 
de Mitnick quien le había dejado varios mensajes con acento oriental en tono
de burla. El último de estos mensajes lo había recibido ocho horas después 
de que Mitnick había sido arrestado y antes de que la prensa se hubiera 
enterado de todo el asunto. Cómo se realizó esa llamada aún es un misterio
al igual que el origen y objetivo de la segunda señal de Mitnick.

Este persistente hacker actualmente está siendo juzgado y enfrenta dos cargos
federales, uso ilegal de equipos de acceso telefónico y fraude por computadoras.
Puede ser condenado por hasta 35 años y a pagar una multa de hasta medio millón
de dólares. Mitnick también es sospechoso de robar el software que las compañías
telefónicas piensan usar para todo tipo de procesos, desde la facturación hasta 
el seguimiento del origen de una llamada pasando por la decodificación de las 
señales de los teléfonos celulares para preservar su privacidad.

El vuelo final 
       

Todos los cargos bajo los cuales
ha sido acusado Kevin Mitnick podrían 
suponerle más de doscientos años
de prisión si es declarado culpable 
       
"No culpable" alcanzó a declararse Kevin Mitnick ante el Gran Jurado de 
California, que el pasado 30 de septiembre lo acusó de 25 cargos por los
cuales podría ser condenado a más de doscientos años de presidio. 
Esta acusación revela el amplio daño que Mitnick causó mientras era un 
fugitivo de la justicia. Los delitos por computadora permiten a sofisticados
criminales causar estragos alrededor del mundo usando sólo una computadora y
un modem como sus armas. Queremos con esta acusación dar un paso adelante en
los esfuerzos federales por perseguir y capturar a los hackers dijo la fiscal
encargada del caso, Nora Manella. Los cargos por los que fue acusado Mitnick y
su ayudante Lewis Depayne, de 36 años, incluyen el robo de software, fraude 
electrónico, daño a las computadoras de la Universidad del Sur de California, 
robo de archivos electrónicos e intercepción de mensajes de correo electrónico.
Entre las compañías afectadas por las actividades del llamado Condor se 
cuentan Motorola, Nokia, Fujitsu y Nec. Se supone que los daños causados por 
Mitnick en los dos años y medio durante los cuales fue un fugitivo suman millones
de dólares, especialmente por el software robado y las inversiones que debieron
realizar las empresas para proteger sus sistemas. El asistente del fiscal David
Schindler dijo que Mitnick -quien actualmente tiene 33 años- sería probablemente
sentenciado a muchos años si es encontrado culpable, negándose, sin embargo, a
ser más específico, bajo el argumento de que se trata de un área legal muy nueva.
Todos los cargos bajo los cuales ha sido acusado Mitnick podrían suponerle más de
doscientos años de prisión si es declarado culpable de todos ellos. 
Ya en abril de este año el famoso hacker había sido declarado culpable por un 
jurado de Carolina del Norte por el uso del quince números de teléfonos celulares
robados para llamar a bases de datos electrónicas. Igualmente se le condenó por
haber violado el regimen de libertad condicional al que estaba sometido luego de
ser encontrado culpable de penetrar ilegalmente en sistemas de información de 
corporaciones de informática. 
  
Mitnick: hacker, cracker y phone phreaker 
  
La definición de un cracker es alguien que trata de violar el acceso a un 
sistema adquiriendo passwords. La mayoría de los crackers son adolescentes
nada bondadosos y que buscan dar sus golpes destruyendo o alterando la data
de un sistema. Tienden a unirse en grupos muy pequeños, secretos y cerrados
al contrario de los inmensos, abierto y policulturales hackers. Se espera 
que un verdadero hacker haga algo de crackin juguetón y conozca muchas de las
técnicas básicas, pero cualquiera que pase de la etapa de larva puede caer en
la tentación y, debido a su creciente deseo de realizar algo por razones 
inmediatas, benignas y prácticas, no vea nada de malo en invadir cierta 
seguridad y privacidad para poder lograr una meta. Para el cracker el invadir
un sistema no requiere de misteriosos estados de iluminación mental, pero sí
mucha persistencia y la testaruda repetición de trucos bien conocidos en los 
puntos débiles de un sistema, tratan de descubrir información clasificada 
hurgando al azar y con ciega persistencia. Suele decirse que los crackers 
son sólo hackers mediocres y que su nivel de educación e inteligencia sobre
un sistema es menor. 
Los phone phreaker son los más famosos en los medios de comunicación por 
los desastres que han hecho a través de los años. En los años 60 ya existían
los Phone Phreaks y la gran victima era AT&T. Uno de los más famosos Phone 
Phreaks de esa epoca era John Draper, alias Captain Crunch 
(http://www.fc.net/phrack.html). El descubrió que modificando una caja de 
cereal podia producir el silbido que simulaba un tono de 2600 Hz para
desbloquear el acceso a una troncal y poder hacer llamadas internacionales
gratis. Hace algún tiempo el hacer phreaking fue una actividad semi-respetable
dentro de la comunidad hacker; había un acuerdo de caballeros donde el hacer
phreaking era bien visto como juego intelectual y como una forma de exploración,
pero el robo de servicios era tabú. La modernización de las redes hizo necesario
que los phreakers utilizaran técnicas menos éticas, como robar números de calling
cards: los obtenian colocándose cerca de algún teléfono público y memorizando el
número de tarjeta que marcaba un usuario descuidado, una vez obtenido el número y
la clave la información era esparcida de tal manera que en un caso se llegaron a
realizar 600 llamadas internacionales en dos minutos antes de que los operadores 
de seguridad del sistema la cancelaran.



Epílogo

Como decía en mi página, este texto lo he conseguido de la página de ByronHack,
la cual os recomiendo. En la mía teneis su dirección. Bueno, a lo que iba; a mí
no me parece nada justo el trato que le han hecho al señor Mitinick. Él es un 
genio como pocos los hay. Tuvo sus aventuras y desventuras, hizo cosas malas, ya
se sabe, pero nadie cuenta con las buenas. Nadie se da cuenta de que gracias a él
los sistemas de seguridad ahora son más complejos y currados. Nadie se ha dado 
cuenta del gran logro que consiguió: sobrevivir durante dos años con un móvil y
un PC. Eso nadie lo valora, el hecho de que un sólo hombre en su gran cruzada logró
despistar, atormentar y acojonar a la seguridad informática de todo un pais. El FBI
lo persiguió como a un perro y el Gran Mitnick hizo con ellos lo que quiso.Pero ya 
se sabe, dicen que el que mal anda, mal acaba. Yo pienso que los cargos son excesivos,
que ha estado demasiado tiempo encarcelado sin juicio y que ha recibido un trato injusto.
Yo no soy de los que piden su libertad, ya que, según dicen, robó gran cantidad de 
material privado. Y amigos, una cosa es burlar la seguridad de un sistemas, y otra es
saquear. Pero tampoco se lo reprocho, ya que, lo primero es que soy un gran admirador 
suyo y eso jamás se me ocurriría. Y lo segundo es la gran cruzada que ha montado y en 
la cual tiene cientos de seguidores.
Su condena es excesiva y se merece que la rebajen, aunque solamente sea por ser lo que
es: UN GENIO.


      *****************************************************************************
 08  **                               DESPEDIDA                                   **
      *****************************************************************************

 Una vez mas quiero agradecerles por la gran cantidad de mail's que me han hecho llegar,
 y por todo el apollo que me han brindado en la realizacion de la OCU n°2.

 Ha se me olvidava tambien pueden mandar sus articulos para que salgan en esta revista.

 Esto fue todo en esta edicion y esperemos que la revista siga dia a dia creciendo tanto
 como en numeros de lectores como en tamaño.


           Se despide hasta la proxima edicion O.C.U. la n° 03. 



                                                                 BLACKWRITE
                                                                   EDITOR




   < < < <-----------[ Si alguien kiere ayudarnos...Bienvenido sea. ]--------------> > > >






       ______________________________________________________________________________
      |                                                                              |
      |     CUALQUIER CONSULTA, DUDA O SUGERENCIA POR FABOR DIRIJIRLA AL EDITOR      |
      |              ESPERAMOS SUS MAIL'S HASTA LA SIGUIENTE EDICION                 |
      |______________________________________________________________________________|
      |                                                                              |
      |                   C H I L E  -  O C T U B R E   2 0 0 1                      |
      |______________________________________________________________________________|

