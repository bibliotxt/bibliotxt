**************************************************************

                    F  E  E  D  B  A  C  K

**************************************************************
                    Antenas & TV por cable


En respuesta a varios mensajes que consultaban la posibilidad
de la captaci¢n de se¤ales de cable mediante una antena orien-
tada a el repartidor zonal, como por ejemplo el de Sergio    
Marcovecchio entre otros, va un breve repaso del tema:

     Las antenas no son otra cosa que un circuito con constan-
tes L-C distribuidas, es decir que se cuenta con una capacidad
y una inductancia en un espacio relativamente grande, lo cual
no quita que estas posean todas las caracter¡sticas de los cir-
cuitos L-C. Es decir que dicho circuito se hace resonante cada
vez que una onda impacta en ella con una longitud de « ldo    
(longitud de onda). Al hacerse resonante b sicamente podemos
decir que se hace un corto, que su impedancia cae al valor te¢-
ricamente mas bajo posible. Teniendo como base que las ondas se
hacen repetitivas cada « ldo podemos decir que la antena reso-
nar  a «,1,1«,2,etc ldo. Dicha ldo se calcula como 

               ldo=c/f

siendo c la velocidad de la luz y f la frecuencia de la onda.
Por ejemplo si tengo una antena de .5 m esta resonar  a 600
Mhz, 1200,1800,etc.
     Esto significa que dicha onda inducir  una V en el dipolo.
Pero si coloco un dipolo, este tendr  un l¢bulo de radiaci¢n
circular, es decir, captar  se¤ales que se encuentren a una
cierta distancia a la redonda. Si a dicho dipolo le colocamos
directores y reflectores, podemos modificar dicho l¢bulo de
radiaci¢n haci‚ndolo mas directivo, y ganando en distancia.
Esto es una antena del tipo yaghi, que es muy usada, similar a
las antenas de TV (las antenas de TV son un "engendro" de este
tipo de antena, poseen en su forma cl sica 5 dipolos que act£an
a frec. distintas y un reflector).
     No voy a entrar mucho en detalle, este tema lo tocaremos
en un futuro en FULCRUM pero en los repartidores del cable, ya
sea por mala aislaci¢n o por desadaptaci¢n de impedancias se
generan p‚rdidas, parte de las cuales son literalmente irradia-
das por los contactos y cables que act£an como antenas. Si co-
locamos una antena y la apuntamos hacia este lugar, probable-
mente captaremos se¤al de cable. Dicho esto se entiende que
este tema es muy aleatorio, depende de la directibilidad de la
antena, de la distancia con el objeto, y de las p‚rdidas que
este irradie. Se puede probar y ver que pasa, pero si el tendi-
do de la red es bueno, si se tiene una buena calidad esto NUNCA
ser  posible, digo, si pueden ver la se¤al de esta forma deben
agradecer el eficiente servicio de cablevisi¢n.
     Del tema hay mucho para decir, esto es solo una respuesta
puntual a una pregunta, ya hablaremos de esto poniendo todos
los puntos a las i en otra oportunidad.

                                                       [Biggs]

*************************************************************
                    Coprocesador Matem tico


Otro tema en cuesti¢n en este tiempo se dio con Acetilcolina el
cual esta interesado sobre la implementaci¢n de funciones tri-
gonom‚tricas utilizando el copro de una 486.

     Antes que nada, quiero aclarar que al mismo tiempo que se
desarrolla un micro, se hace tambi‚n un copro para interactuar
con dicho micro; En respuesta a la preg. , vamos a describir el
funcionamiento del 8087 que es el copro para una XT, dejando
aclarado que es igual para los copro posteriores, como el 80487
que ser¡a el de la 486. Se lo hace as¡ porque ambos IC interac-
tuan profundamente entre s¡ y se debe dise¤ar un copro    espe-
cialmente para cada micro. Veamos pues, el funcionamiento del
8087.

     Los micros est n dise¤ados para el procesamiento de ins-
trucciones de uso general, la aritm‚tica vinculada con este es
muy simple, sin embargo hay  aplicaciones en las que es conve-
niente que se puedan procesar fracciones y operaciones aritm‚-
ticas avanzadas. Estas no son f ciles de implementar, para eso
se dise¤¢ el copro que ejecuta operaciones hasta 100 veces m s
r pido. Este tambi‚n es llamado Extensi¢n Num‚rico del Procesa-
dor -NPX-.
     Al tratar el 8086, se vio la conexi¢n de l¡neas QS0, QS2,
RQ/GT con el 8087. La l¡nea Busy del 8087 indica que la NEU
(unidad de ejecuci¢n num‚rica) est  ejecutando una instrucci¢n 
num‚rica, la cual es conectada a la l¡nea TEST del 8086. Al
utilizar el copro, al hacer el prog. se antepone la instrucci¢n
WAIT antes de cada instrucci¢n para el 8087. El 8086 encuentra
el WAIT y queda en espera hasta que el copro ejecuta su ins-
trucci¢n, entonces la l¡nea Busy del 8087 baja y el 8086 sigue
procesando. La l¡nea INT en una salida que indica que hubo un
error en el procesamiento de la instrucci¢n, sin embargo esta
puede ser enmascarada. En el 8087 los errores se llaman excep-
ciones y pueden ser de distinta naturaleza:

     Overflow:cuando el resultado es grande para la magnitud
     del formato usado.

     Divisi¢n por cero.

     Underflow:cuando el resultado es demasiado peque¤o.

     Operando no normalizado.

     Resultado inexacto.
 
     Un Registro de 16 bits (CONTROL WORD) contiene las m sca-
ras para las excepciones, la interrupci¢n, la precisi¢n (24-64
bits) y el redondeo. Se notan en el gr fico (copro.jpg) 2 sec-
ciones bien diferenciadas: la unidad de control y  la de ejecu-
ci¢n num‚rica vinculadas por una cola de operandos y un bus
interno. La unidad de Ctrl monitorea las l¡neas de estado para
determinar cuando est  siendo tomada una instrucci¢n, y mantie-
ne una de instrucciones igual con el micro. Las instrucciones
para el 8087 aparecen mezcladas con el juego de instrucciones
del 8086, se diferencian porque las instrucciones del 8087 co-
mienzan con la sig. cadena de bits en el 1§ byte: 11011 lo que
corresponde al c¢digo de escape del 8086. Ante dicho c¢digo, el
8086 sigue con la pr¢xima instrucci¢n (si la previa no fue un
WAIT) mientras que el 8087 comienza a ejecutarla.
     EL NEU del 8087 contiene 8 registros de 80 bits denomina-
dos R1 al R8 sobre los que opera la ALU. Estos registros permi-
ten almacenar n£meros en formatos tales como:

     Enteros cortos de 32 bits

     Enteros largos de 64 bits

     BCD empaquetado de a 8 bits

     Reales cortos de 32 bits

     Reales largos de 64 bits

     Almacenamiento temporario de reales de 80 bits

     Los formatos enteros se manejan como el complemento a 2
mientras que los reales en notaci¢n mantisa-exponente. EL for-
mato de 80 bits p. ej. consta de 64 bits de mantisa, 15 de ex-
ponente y 1 de signo, con lo que pueden representarse hasta    
10^4932. Estos registros forman un stack interno al 8087, y al
igual que el stack de la memoria, crece hacia los registros de
menor n£mero. En la palabra de estado se refleja el estado del
8087. Una palabra de marca (TAG WORD) indica el contenido de
cada registro de acuerdo con 4 c¢digos (V lido, cero, especial
y vac¡o). Tambi‚n contiene registros para almacenar la direc-
ci¢n de la instrucci¢n (INSTRUCTION POINTER) y la del operando
(DATA POINTER). 
     El efecto de usar el 8087 es ampliar el conjunto de ins-
trucciones del 8086 de 2 formas: por un lado a las operaciones
que ya exist¡an pero estaban limitadas a 16 bits tales como la
comparaci¢n, la suma, resta, multiplicaci¢n y divisi¢n que aho-
ra pueden efectuarse hasta con 80 bits y por otro lado agrega
las siguientes operaciones:

     Ra¡z cuadrada

     Valor absoluto

     Cambio de signo

     Tangente

     Arco Tangente

     Logaritmo en base 2

     Exponencial

     Hecha ya la presentaci¢n del caso, veamos en detalle el
funcionamiento interno del copro, y el uso en la programaci¢n
de sus virtudes.
     Para empezar a verle el uso que le podemos dar, hay que
saber para que me sirven las palabras de control, tag y estado
as¡ que ac  va una descripci¢n de estas...

PALABRA DE CONTROL

     Mediante esta, se seleccionan las diferentes opciones de
proceso del 8087. Como se observa en el gr fico, el byte de
menor orden configura las interrupciones y la m scara de excep-
ciones. Los 5-0 de esta palabra contienen la m scara individual
de cada uno de los 6 tipos de excepciones y el bit 7 contiene
una general para todas. Respecto del byte m s significativo,
podemos decir que configura el modo de operaci¢n del 8087. Los
bits de control de precisi¢n (8 y 9) se pueden usar para habi-
litar la precisi¢n de la operaciones, muy £til a la hora de
compatibilizar con micros anteriores. Los valores que pueden
adoptar los bits son los siguientes:

     00 = 24 bits
     01 = reservado
     10 = 53 bits
     11 = 64 bits

     Los bits de control de redondeo (10 y 11) se disponen para
el redondeo y corte del resultado en diferentes modos, seg£n el
est ndar norteamericano IEEE. Tambi‚n se puede recortar el es-
pacio del n£mero por la proximidad al infinito pudi‚ndose con-
seguir el recorte con cualquier signo ñì. Los valores que pue-
den adoptar son los siguientes:

     00 = redondeo al valor m s cercano
     01 = redondeo hacia abajo (-ì)
     10 = redondeo hacia arriba (+ì)
     11 = recorte (cortando a trav‚s de 0)
                                                0
ÚÄÄÄÂÄÄÄÂÄÄÄÂÄÄÄÂÄÄÄÂÄÄÄÂÄÄÄÂÄÄÄÂÄÄÄÂÄÄÄÂÄÄÄÂÄÄÄ¿
³XXX³IC ³RC ³PC ³ M ³ X ³PM ³UM ³OM ³ZM ³DM ³IM ³
ÀÂÂÂÁÄÂÄÁÂÂÄÁÂÂÄÁÄÂÄÁÄÂÄÁÄÂÄÁÄÂÄÁÄÂÄÁÄÂÄÁÄÂÄÁÄÂÄÙ
 ³³³  ³  ³³  ³³   ³   ³   ³   ³   ³   ³   ³   ³(1=ENMASC)
 ³³³  ³  ³³  ³³   ³   ³   ³   ³   ³   ³   ³   ÀOP. INVALIDA
 ³³³  ³  ³³  ³³   ³   ³   ³   ³   ³   ³   ÀÄÄÄÄOP. FUERA NORMA
 ³³³  ³  ³³  ³³   ³   ³   ³   ³   ³   ÀÄÄÄÄÄÄÄÄDIV. X 0
 ³³³  ³  ³³  ³³   ³   ³   ³   ³   ÀÄÄÄÄÄÄÄÄÄÄÄÄSOBREPASAMIENTO
 ³³³  ³  ³³  ³³   ³   ³   ³   ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄREVALSAMIENT. X0
 ³³³  ³  ³³  ³³   ³   ³   ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄPRECISIşN
 ³³³  ³  ³³  ³³   ³   ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄRESERVADO
 ³³³  ³  ³³  ³³   ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄMASC INTERRUP.
 ³³³  ³  ³³  ÀÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄCTROL PRECISIşN
 ³³³  ³  ÀÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄCTROL REDONDEO
 ³³³  ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄCTROL ì(1=S/SIG)
 ÀÁÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄRESERVADO
           
PALABRA DE ETIQUETA (TAG WORD)

     Esta palabra marca el contenido de cada uno de los regis-
tros. La funci¢n principal del TAG WORD es optimizar el funcio-
namiento del 8087. Se puede usar para interpretar el contenido
de los registros del 8087. Est  dividida en 8 partes de 2 bits,
indicando el estado de los registros 0..7. Los valores que pue-
den adoptar son los siguientes:

     00 = V lido

     01 = Cero

     10 = Especial

     11 = Vac¡o

                                                       0
ÚÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄ¿     
³TAG 7 ³TAG 6 ³TAG 5 ³TAG 4 ³TAG 3 ³TAG 2 ³TAG 1 ³TAG 0 ³
ÀÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÙ     
                                                 ÚÄÄÄÄÄÄ¿
                                                   2 bits
 

PALABRA DE ESTADO

     La palabra de estado refleja el estado global del 8087,
pudiendo ser almacenado en memoria los datos de dicho registro.
Dicha palabra est  compuesta por un registro de 16 bits, de los
cuales el bit 15 indica que la NEU est  ocupada, es decir que
est  ejecutando una instrucci¢n. Los cuatro bits de c¢digo de
condici¢n num‚rica (C0-C3  son similares a los flags de la CPU,
diversas instrucciones cambiar n sus estados para reflejar el
resultado de las operaciones que ha realizado. Sus valores son
los siguientes:           
                          
ÚÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÂÄÄÂÄÄÂÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Intruc. tipo³C3³C2³C1³C0³         Interpretaci¢n            ³
ÃÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Comparaci¢n,³0 ³0 ³X ³0 ³ ST>FUENTE O IGUAL A 0             ³
³texto       ³0 ³0 ³X ³1 ³ ST<FUENTE O IGUAL A 0             ³
³            ³1 ³0 ³X ³0 ³ ST=FUENTE O IGUAL A 0             ³
³            ³1 ³1 ³X ³1 ³ ST NO ES COMPARABLE               ³
ÃÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Resto       ³Q1³0 ³Q0³Q2³COMP. REDUC. CON 3 BITS BAJOS COCI.³
³            ³U ³1 ³U ³U ³REDUCCION INCOMPLETA               ³
ÃÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Examinar    ³0 ³0 ³0 ³0 ³VALIDO, POS. SIN NORMALIZACION     ³
³            ³0 ³0 ³0 ³1 ³NO VALI.,POS., EXPONENTE=0         ³
³            ³0 ³0 ³1 ³0 ³VALIDO NEGATIVO SIN NORMALIZACION  ³
³            ³0 ³0 ³1 ³1 ³NO VALI.,NEG., EXPONENTE=0         ³
³            ³0 ³1 ³0 ³0 ³VALIDO, POSITIVO Y NORMALIZADO     ³
³            ³0 ³1 ³0 ³1 ³INFINITO POSITIVO                  ³
³            ³0 ³1 ³1 ³0 ³VALIDO NEGATIVO NORMALIZADO        ³
³            ³0 ³1 ³1 ³1 ³INFINITO NEGATIVO                  ³
³            ³1 ³0 ³0 ³0 ³CERO POSITIVO                      ³
³            ³1 ³0 ³0 ³1 ³VACIO                              ³
³            ³1 ³0 ³1 ³0 ³CERO NEGATIVO                      ³
³            ³1 ³0 ³1 ³1 ³VACIO                              ³
³            ³1 ³1 ³0 ³0 ³NO VALIDO, POS., EXPONENTE=0       ³
³            ³1 ³1 ³0 ³1 ³VACIO                              ³
³            ³1 ³1 ³1 ³0 ³NO VALIDO, POS., EXPONENTE=0       ³
³            ³1 ³1 ³1 ³1 ³VACIO                              ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÁÄÄÁÄÄÁÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
                                                              
NOTA:     ST es el punto m s alto del stack
          X es un valor que no afecta a la instrucci¢n 
          U es un valor indefinido despu‚s de la instrucci¢n 
          Qn es el bit n del cociente

     Los bits 14-12 indican cual de los 8 registros se encuen-
tra en el punto m s alto de stack. El bit 7 es el de interrup-
ci¢n. Si este se encuentra en "1" si alg£n bit de excepci¢n
esta activo. Los bits 5-0 indican que la NEU ha encontrado una
excepci¢n mientras ejecutaba una instrucci¢n.

                                           0
ÚÄÄÂÄÄÂÄÄÄÂÄÄÂÄÄÂÄÄÂÄÄÂÄÄÂÄÄÂÄÄÂÄÄÂÄÄÂÄÄÂÄÄ¿
³B ³C3³TOP³C2³C1³C0³IR³X ³PE³UE³OE³ZE³DE³IE³
ÀÂÄÁÂÄÁÂÂÂÁÂÄÁÂÄÁÂÄÁÂÄÁÂÄÁÂÄÁÂÄÁÂÄÁÂÄÁÂÄÁÂÄÙ                  
 ³  ³  ³³³ ³  ³  ³  ³  ³  ³  ³  ³  ³  ³  ³1=Hay excepci¢n     
 ³  ³  ³³³ ³  ³  ³  ³  ³  ³  ³  ³  ³  ³  ÀOperaci¢n no valida
 ³  ³  ³³³ ³  ³  ³  ³  ³  ³  ³  ³  ³  ÀÄÄÄOperando fuera norma
 ³  ³  ³³³ ³  ³  ³  ³  ³  ³  ³  ³  ÀÄÄÄÄÄÄDivisi¢n x cero  
 ³  ³  ³³³ ³  ³  ³  ³  ³  ³  ³  ÀÄÄÄÄÄÄÄÄÄSobrepasamiento
 ³  ³  ³³³ ³  ³  ³  ³  ³  ³  ÀÄÄÄÄÄÄÄÄÄÄÄÄRebasamiento x cero 
 ³  ³  ³³³ ³  ³  ³  ³  ³  ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄPrecisi¢n 
 ³  ³  ³³³ ³  ³  ³  ³  ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄReservado
 ³  ³  ³³³ ³  ³  ³  ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄPetici¢n int
 ³  ÀÄÄÅÅÅÄÁÄÄÁÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄC¢dig. de condici¢n
 ³     ÀÁÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄPuntero del stack
 ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄNeu ocupada


     Creo que con lo dicho alcanza como para tener una idea de
lo que se trata de hacer con un coprocesador, as¡ que si tienen
dudas, solamente me las hacen llegar y listo, por mi parte solo
resta dar el set de instrucciones que, por una cuesti¢n de ac-
tualizaci¢n, les mando el del 80287 que es pr cticamente igual
al del 8087 aqui tratado, es decir que todo lo dicho es absolu-
tamente v lido, 
                                                              
ÚÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Instrucci¢n³ Prop¢sito ³         Caracter¡sticas            ³
ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³FLD fuente ³Carga real ³Guarda (push) la fuente de datos    ³
³           ³           ³sobre la parte alta de los reg. del ³
³           ³           ³stack, la pila ST(0)                ³
³FST destino³Almacenar  ³Copia ST(0) en el destino indicado  ³
³           ³real       ³que puede ser una pos. de memoria o ³
³           ³           ³un registro                         ³
³FSTP destn.³Almacenar y³Copia ST(0) en el destino indicado  ³
³           ³botar      ³y lo pasa automaticamente al stack. ³
³FXCH destn.³Intercam.  ³Intercambia ST con el destn. indica-³
³           ³st         ³do                                  ³
³FILD fuente³Cargar     ³Empuja la fuente de datos hacia la  ³
³           ³entero     ³parte alta del stack,ST(0)          ³
³FIST  dest ³Almacenar  ³Almacena ST(0) en el destino indica-³
³           ³entero     ³do que debe ser un operando de mem. ³
³           ³           ³entera                              ³
³FISTP dest.³Almacenar  ³Idem anterior, solo que lo tambi‚n  ³
³           ³entero     ³lo pasa automaticamente al stack    ³
³FBLD fuente³Cargar bcd ³Carga un numero (BCD) hacia ST(0) en³
³           ³           ³el stack                            ³
³FBSTP dest.³Almacena y ³Almacena en ST(0) el n£mero BCD en  ³
³           ³bota BCD   ³el destino y lo bota ST(0) del stack³
ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³FADD       ³Adici¢n    ³Asume que ST(1) se adicona a ST(0)  ³
³           ³real       ³con el resultado en ST(0) o con     ³
³           ³           ³referencia explicita a ST(0)        ³
³           ³           ³adicionada a otro registro.         ³
³FADDP dest,³Adici¢n    ³La fuente es ST(0) y el destino debe³
³ fuente    ³real y bota³ser otro registro del stack. El     ³
³           ³           ³resultado se deja en este £ltimo.   ³
³FIADD mem- ³Adici¢n    ³El destino, ST(0) se adiciona a la  ³
³ entera    ³ entera    ³fuente, memoria entera y la suma    ³
³           ³           ³retorna a ST(0)                     ³
ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³FSUB       ³Subst. real³Asume que el destino es ST(1) y     ³
³           ³           ³ST(0) se resta con ‚l, con el resul.³
³           ³           ³en ST(1), con un operando. mem-real ³
³           ³           ³restado de ST(0) y el resultado en  ³
³           ³           ³ST(0), o con ref. a ST(0) y a otro  ³
³           ³           ³registro expl¡cito.                 ³
³FSUBP dest,³Subst. real³La fuente ST(0) se resta del destino³
³ fuente    ³ y botado  ³, otro reg. del stack, y se almacena³
³           ³           ³en el destino.                      ³
³FISUB fuet.³Subst.     ³EL operando de mem-entera se resta y³
³           ³entera     ³guarda en el destino ST(0)          ³
³FSUBR      ³Substr.    ³El destino se resta a la fuente y   ³
³           ³invertida  ³el resultado queda en el destino. La³
³           ³de reales  ³config. es igual a FSUB             ³
³FSUBRP     ³Substr.    ³Es igual a FSUBP salvo que el destn.³
³           ³inversa de ³se resta a de la fuente ST(0) que   ³
³           ³reales y   ³aun sirve como aperand. fuente      ³
³           ³botados    ³                                    ³
³FISUBR     ³Subst.     ³Igual que FISUB, solo que se resta  ³
³ fuente    ³inversa de ³el destino de la fuente, siendo esta³
³           ³enteros    ³£ltima un operan. de mem-entera.    ³
ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³FMUL       ³Multip.    ³Se la puede ejecutar sin operndos   ³
³           ³real       ³y asume que la fuente es ST(0) y el ³
³           ³           ³destino es ST(1)                    ³
³FMULP des, ³Multip.    ³Idem anterior solo que bota el      ³
³ fuente    ³real y     ³resultado al stack                  ³
³           ³botar      ³                                    ³
³FIMUL fuent³Multip.    ³Multiplica el destino por la fuente ³
³           ³entera     ³, el primero lo asume como ST(0) y  ³
³           ³           ³la fuente es un operando de memoria ³
³           ³           ³entera.                             ³
ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³FDIV       ³Dividir    ³Si se la opera sin operandos, asume ³
³           ³reales     ³que la fuente es ST(0) y el destino ³
³           ³           ³ST(1). Sino, la fuente es la especi-³
³           ³           ³ficada y el destino ST(0)-(Dst/Fnt) ³
³FDIVP dest,³Dividir    ³Idem anterior solo que bota el      ³
³fuente     ³reales y   ³resultado al stack.                 ³
³           ³botar      ³                                    ³
³FIDIV fuent³Divisi¢n   ³Esta instrucci¢n asume que el desti-³
³           ³entera     ³no es ST(0)  la fuente un operando  ³
³           ³           ³de memoria entera.                  ³
³FDIVR      ³Divisi¢n   ³Idem que FDIV solo que el la fuente ³
³           ³inversa    ³se divide por el destino.           ³
³           ³real       ³                                    ³
³FDIVRP des,³Divisi¢n   ³Igual que FDIVP solo que divide la  ³
³fuente     ³inversa    ³fuente entre el destino.            ³
³           ³real y bot.³                                    ³
³FIDIVR funt³Divisi¢n   ³Edentica a FIDIV salvo que la fuente³
³           ³inversa    ³se divide entre el destino.         ³
³           ³entera     ³                                    ³
ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³FSQRT      ³Ra¡z cuad. ³Reemplaza el contenido de ST(0) por ³
³           ³           ³su ra¡z cuadrada.                   ³
³FSCALE     ³Escala     ³Interpreta el n£mero de ST(1) como  ³
³           ³           ³entero, suma este valor al exp. del ³
³           ³           ³n£mero ST(0) lo que es igual a :    ³
³           ³           ³ ST(0)*(2^ST(1))                    ³
³FPREM      ³Residuo    ³Toma el m¢dulo  de ST en relaci¢n   ³
³           ³parcial    ³con el n£mero de ST(1), con igual   ³
³           ³           ³signo que ST(0).                    ³
³FRNDINT    ³Redondear  ³Redondea ST(0) al entero.           ³
³           ³al entero  ³                                    ³
³FXTRACT    ³Extraer    ³Reduce el n£mero en ST(0) a un sig. ³
³           ³exp. y     ³y un exp. para aritm‚tica de 80 bits³
³           ³significado³                                    ³
³FABS       ³Valor absl.³Genera el valor absoluto de ST(0)   ³
³FCHS       ³Cambio de  ³Invierte el signo de ST(0)          ³
³           ³signo      ³                                    ³
ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³FCOM       ³Comp. real ³Compara el operando fuente que se   ³
³           ³           ³puede especif. (sino es ST(1)) con  ³
³           ³           ³el de destino ST(0)                 ³
³FCOMP      ³Comp. real ³Idem anterior solo que adem s lo    ³
³           ³y botar    ³pasa al stack.                      ³
³FCOMPP     ³Comp. real ³Idem anterior (very bobo no ???)    ³
³           ³y botar dos³                                    ³
³           ³veces      ³                                    ³
³FICOM fuet.³Compara    ³Comp. ST(0) con el operando fuente  ³
³           ³entero     ³que debe ser un opr. de mem. entera.³
³FICOMP fnt.³Compara    ³Idem anterior solo que ST(0) se re- ³
³           ³entero y   ³gistra de inmediato despues de la   ³
³           ³bota       ³comparaci¢n.                        ³
³FTST       ³Prueba     ³Prueba ST(0) en relaci¢n con +0.0   ³
³           ³           ³El resultado el c¢digo:             ³
³           ³           ³C3,C1=0,0 => ST +;0,1 => ST -       ³
³           ³           ³1,0 => ST=0 ; 1,1 =>no se puede comp³
³           ³           ³ST                                  ³
ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³FPTAN      ³Tangente   ³Calcula Y/X =tang(z), siendo z=ST(0)³
³           ³parcial    ³retorna y en ST(1) y x en ST(0)     ³
³FPATAN     ³Arco tgn   ³Calcula z=ARC TGN(y/x) donde x=ST(0)³
³           ³parcial    ³y y=ST(1), Z se retorna en ST(0).   ³
³F2XM1      ³2^x-1      ³x se lo especifica en ST(0) y debe  ³
³           ³           ³ estar en rango (0.0.5), y el resul-³
³           ³           ³tado se retorna por ST(0)           ³
³FYL2X      ³Y*log(x)   ³x=ST(0) y Y=ST(1). El resultado se  ³
³           ³           ³bota al stack y queda nuevamente en ³
³           ³           ³ST(0)                               ³
³FYL2XP1    ³Y*log(X+1) ³Las diferencias son taradas no?? lo ³
³           ³           ³que si hay que aclarar es que x debe³
³           ³           ³estar en el rango de 0.1-û2-2.      ³
ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³FLDZ       ³Carga cero ³carga 0.0 en ST(0)                  ³
³FLD1       ³Carga +1.0 ³carga +1.0 en ST(0)                 ³
³FLDP1      ³Carga pi   ³Carga pi en ST(0)                   ³
³FLDL2T     ³Carga      ³Carga log10 en ST(0)                ³
³           ³log2(10)   ³                                    ³
³FLDL2E     ³Carga      ³                                    ³
³           ³log2(e)    ³Carga log e en ST(0)                ³
³FLDLG2     ³Carga      ³                                    ³
³           ³log10(2)   ³Carga log10(2) en ST(0)             ³
³FLDLN2     ³Carga      ³                                    ³
³           ³loge(2)    ³Carga log e (2) en ST(0)            ³
ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³FINIT,     ³Iniciar    ³Inicializa el 8287                  ³
³FNINIT     ³procesador.³                                    ³
³FDISI,     ³Inactivar  ³Inactiva al copro para recivir int. ³
³FNDISI     ³Interrup.  ³de hard.                            ³
³FENI,FNENI ³Activa int.³Inversamente a FDISI, activa las int³
³FLDCW fuet.³Carga palb.³Carga la pal. de ctrl definida en el³
³           ³de ctrl.   ³operando fuente.                    ³
³FSTCW,     ³Almacenar  ³Carga la palabra de ctrl en el      ³
³FNSTCW dest³pal. ctrl. ³operando.                           ³
³FCLEX,     ³Limpia     ³Borra todas las banderas de excep-  ³
³FNCLEX     ³exepciones.³ciones.                             ³
³FSTENV,    ³Almacena   ³Escribe el estado basico y los indi-³
³FNSTENV dst³Ambiente.  ³cadores de excepciones en la posi-  ³
³           ³           ³cion definida por el usuario.       ³
³FLDENV fnt.³Carga      ³Carga el ambiente definido por el   ³
³           ³Ambiente   ³usuario.                            ³
³FSAVE,     ³Salvar     ³Escribe el ambiente y el reg. stack ³
³FNSAVE, dst³estado     ³en la localidad de mem. especif. por³
³           ³           ³el usuario.                         ³
³FRSTOR, fnt³Reestablece³Vuelve a cargar al copro del operan.³
³           ³estado     ³fuente.                             ³
³FINSCTP    ³Inc. el    ³very simple no???                   ³
³           ³stack      ³                                    ³
³FFREE, dst ³Reg. libre ³Cambia la etiqueta del destino a    ³
³           ³           ³vacio.                              ³
³FDECSTP    ³Dec. stack ³shhhhhhhhhhhhhhhhhh!!!              ³
³FNOP       ³no operat. ³sin comentarios!                    ³
³FWAIT      ³Espera     ³Hace que el micro espere a que el   ³
³           ³           ³copro termine de ejecutar la instr. ³
³           ³           ³para poder seguir en lo suyo.       ³
ÀÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

a .. y de yapa un peque¤o ejemplo ....

;Este ejemplo utiliza el copro para multiplicar 100000 por 10 y
;cambiar el resultado dentro y fuera del ST
.8087                                        ;copro
Stack segment para stack 'stack'
     db   64 dup('stack')
stack ends
data segment para public 'data'
     hm1  dd   100000
     hm2  dd   10
     hm3  dd   ?
     hm4  dd   ?
data ends
cseg segment para public 'code'
coproc proc far
     assume cd:cseg;DS:data;ss:stack
     push ds                            ;todo este boludeo que
     sub ax,ax                          ;se hace es porque se
     push ax                            ;'toca' el stack al 
     mov ax,seg data                    ;usar el copro, por eso
     mov ds,ax                          ;salvo todo.
     finit                              ;inicializo el micro
     fild hm2                           ;carga 10 en stack (ST)
     fimul hm1                          ;mult. res y retorna st
     fist hm3                           ;carga res entero hm3
     fst hm4                            ;carga res real hm4
     ret
coproc endp
cseg ends
     end coproc

bye !!!!
                                                         Biggs
