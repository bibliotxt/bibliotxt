<jakin>

        JJ   AAAAAAAA  KK   KK   II  NN    NN
        JJ   AA    AA  KK  KK    II  NNNN  NN
        JJ   AAAAAAAA  KKKKKK    II  NN NN NN 
        JJ   AA    AA  KK  KK    II  NN  NNNN
  JJ    JJ   AA    AA  KK   KK   II  NN   NNN
  JJJJJJJJ   AA    AA  KK    KK  II  NN    NN

      e         z        i        n        e	
 ______________________________________________________________________
| 3. alea (Balioa: 41k)                                                |		
|______________________________________________________________________|
| 2004/03/26                                                           |
|______________________________________________________________________|
|                                                                      |
| Segurtasun elektronikoari buruzko fanxina, euskera hutsez            |
|                                                                      |
|______________________________________________________________________|
|                                                                      |
| Parte hartzaileak: edit,niuBAI,Regexp, Espoz&Mina, Assert,           |
|                    keepalive eta KM                                  |
|______________________________________________________________________|
| email helbidea: jakin@mailbox.co.za                                  |
|		  jakinezine@hispavista.com                            |
|______________________________________________________________________|
| Web helbidea:  http://www.jakin.tk                                   |
|		 http://www.angelfire.com/zine2/jakinezine/            |
|                http://jakinezine.galeon.com                          |
|______________________________________________________________________|



Ale honetan:

Zb Artikulua				Egilea	
______________________________________________________
0. Hitzaurrea                           edit
1. TCP/IP programazioa (III)            niuBAI
2. Perl	pusketak                        Regexp
3. Sistema eragileak                    Espoz&Mina
4. Sare bayesiarrak                     Assert
5. Interneten funtzionamendua: AS-ak    keepalive
6. Kultura                              km
7. Estekak,Oharrak,Agurrak              edit
______________________________________________________



	"adimen"
iz. 1. Ulertzeko ahalmena, pentsamendu bidez nor bere buruaz eta inguruaz jabetzeko ahalmena. 
2. Egoera bati aurre egiteko, arazo bati irtenbidea emateko, zirkunstantzien arabera aukera egiteko ahalmena. 
3. Ik. entzumen.  adimen artifizial. INFORM. Makina batek egindako giza adimenaren simulazioa; 
sistema informatikoetan ezagutzaren adierazpidea, ikasketa, autozuzenketa eta erabakiak 
hartzeko ahalmena garatzeko zientzia.



(((((((((((((((((((((((((((((((((((( Jakin dezagun!! ))))))))))))))))))))))))))))))))))))))


	0. Hitzaurrea
	__________________________

<0>

Aupa!!!
Aurrera jarraitzen dugu, hona hemen Jakin ezinearen 3 alea. 
Honez gero zenbait webgune berezitan gure berri daukatela dakigu, eta gure berri eman dute ere. Ez da ahantzi
behar Jakin-en berria ahalik eta gehien hedatu behar dela. Jendeak bere weblogetan aipatzen gaitu barrapunto,
eta slashdot-en nonbait. Bestelako albiste webgunetan aipatu gaituzte. Linux erabiltzaile taldeetan ere
agertzen gara. Baina ez da nahikoa! unibertsitate eta eskoletara heltzea ere komeni da, azken finean bertan dagoen
jendeak nahi denbora libre gehiago dauka ;) . Ohi denez, Jakin ezinearen 255 departamentuak (broadcast dptment.)
tai gabe lanean dabil, zizarea bailitzan munduan zehar hedatzen.

Zure begien aurren daukazun testu hutsezko ezine honetan jarraipenak eta berripenak topa ditzakezu; Alde batetik 
tcp/ip eta perl programazioarekin jarraitzen da, hala nola ohiko gomendio kulturalarekin. Unix munduan barna jarraituz,
oraingo honetan sistema eragilearen (bere osotasunean) teoria eta praktika erakutsiko da: distribuzio bat sortuz! 

Berripenak?
Beste lankide batzuk atera zaizkigu, artikulu benetan interesgarriekin: Assert eta keepalive. Lehenengoak
adimen artifizialeren inguruko artikuluak bidaliko ditu, eta keepalive-k sareei buruzko testuak prestatuko
dituela proposatu du. Bere lehen partehartzean sare bayesiarretaz eta internet-en funtzionamenduaz ariko dira,
eta horiek irakurrita itxaropen handiak ditugu bere lankidetzan.

Egia da gure maila teknikoa asko hobe daitekeela, artikulu gehienek ez dutela gauza berririk kontatzen, eta agian
gure ahalegin hau ez duela pena merezi. Baina gure asmoa 0tik hastea da. Adibidez: edonork xploit bat lor dezake 
eta zerbitzari baten aurka erabili; gure interesa batetik xploit horren anatomia eta bestetik zerbitzariaren iturburu kodea 
aztertzea litzateke, azkenean prozesu guztia ulertzeko. Eta maila horretara pixkanaka helduko gara; norbaitek
asm kodea bidali nahi du?? intel eta sparc-erako arren. :D

Beno ba, zure laguntza eta noski, zure kritika zorrotzak espero ditugu irakurle.
Txapela buruan hackeatu munduan,
bagoaz!


					-edit-
</0>



	1. TCP/IP programazioa (III)
	__________________________

<1>

RAW RAW RAW, sardina bakalau! :D
TCP eta UDP bezero kodeak ikusi ditugu. Lehengoak konexiora orientatuta, bigarrenak konexio iraunkorrik gabe
bidaltzen diren datagramak. RAw motako socketak falta dira orain eta horien adibidea emango dugu.
Lortu nahi duguna zera da: socket motak aurkeztu, adibide batzuk eman, eta horren ondoren bezero-zerbitzari,
bokeoak, hariak e.a. ikusi.

RAW: behe-mailako protokoloak.
TCP/IP programazio inguruan, RAW socketak programatzeak esan nahi du socketak gu geu sortu behar ditugula,
hots, komunikazio parametroak kontrola ditzakegu. Adibidez, ICMP protokoloaren socketak sor ditzakegu, ping
eta bestalako kontrol paqueteak erabiltzeko. RAW socket bat erabiltzerakoan IP goiburua manipula dezakegu,
TCP edo UDP socketak erabiltzen ditugunean ez bezala (setsockopt() funtzioak limiteak ditu). 
Hartaz lan gehiago daukagu egiteko, baina horren ordainean malgutasuna eta aukera gehiago manipulaziorako.

Ze protokolo dauzkagu aukeran? begirada batr bota /etc/protocol fitxategira.

Hona hemen adibide xinple-xinplea. RAW socketen bitartez ICMP bat bidaltzen dugu, DESTINATION_UNREACHABLE
motakoa. RAW socketekin lan gehiago egin behar dugu, goiburu guztiak gu geu definitu behar ditugulako.
Kasu honetan icmp goiburua definitzen dugu hasieran:

-------------------8<-------------------------------------------------------------------

/**
* raw_icmp1.c  by niuBAI
* RAW-icmp motako socketak darabilen kodea. ICMP datagramak bidaltzen ditu
* Kode honi argumentu bat pasa behar zaio:
* 1. Helburu makina
*
* konpilatzeko -adib.-
* gcc -I/usr/src/linux-2.2.14/include  -o raw_icmp1 raw_icmp1.c
*
*/

// Behar ditugun liburutegiak
#include <stdlib.h>
#include <stdio.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/time.h>
#include <sys/unistd.h>
#include <netinet/in.h>
#include <errno.h>

// Lana errezteko zenbait makro definitzen ditugu
#define ICMP_DEST_UNREACH 3 /* Destination Unreachable */
#define ICMP_HOST_UNREACH 1 /* Host Unreachable */

// ICMP goiburuaren definizioa
// beste motako protokoloendako goiburuak definitu behar ditugu
struct icmphdr {
        u_int8_t type;
        u_int8_t code;
        u_int16_t checksum;
        u_int16_t id;
        u_int16_t sequence;
};

// MAIN programaren hasiera
int main(int argc, char *argv[]) {

        int sock;                    // socketa
        struct sockaddr_in soket_in; // socket helbidearen datu egitura
        char *helb_helb;             // helbidearen string-a
        u_char bufferra[sizeof(struct icmphdr)]; // bufferra
        size_t buffertam;                        // buffer tamaina
        struct icmphdr *icmp;                    // icmp goiburua
        socklen_t sa_luzera = sizeof(struct sockaddr_in); // socket luzera
        int luzera = sizeof(bufferra);                    // buffer luzera zenbakia

        // Agurra..
        printf("raw_icmp1, raw socketa icmp goiburuarekin. \n by niuBAI \n");

        // Argumentuak konporbatu
        if (argc != 2) {
            fprintf(stderr,"Erabilera: raw_icmp1 ip_helbidea \n");
            exit(EXIT_FAILURE);  // = exit(1);
        }

        helb_helb = argv[1];

        // Funtzio honek soket_in katearen lehen ngarren byteak 0n ezartzen ditu
        bzero(&soket_in, sizeof(soket_in));

        // Helbidea prestatu
        inet_pton(AF_INET, helb_helb, &soket_in.sin_addr);
        // Soket familia (internet) adierazi
        soket_in.sin_family = AF_INET;

        // Hona hemen RAW socketaren definizioa. Fija zaitezte: protokoloa adierazi behar da: IPPROTO_ICMP
        if ( (sock = socket(AF_INET, SOCK_RAW, IPPROTO_ICMP)) == -1  ) {
                printf("Ezin izan dut socketa sortu: errore kodea %d\n", errno);
                exit(EXIT_FAILURE);
        } else { // Dena ongi doa
                printf("Socketa sortu da\n");
        }


        // Orain ICMP goiburua bete. Gogoratu: icmp punteroa da, honekin bufferra=icmp
        icmp = (struct icmphdr *)bufferra;

        // Funtzio honek soket_in katearen lehen ngarren byteak 0n ezartzen ditu
        bzero(bufferra, sizeof(bufferra));

        icmp->type = ICMP_DEST_UNREACH; // Socket mota ezartzen dugu: HOST_UNREACHABLE
        icmp->code = ICMP_HOST_UNREACH; // Socket kodea ezartzen dugu
        icmp->checksum = 0; // Konprobaketa 0n jartzen dugu


        printf("ICMP datagramak bidaltzen -> %s\n", helb_helb);

	// begizta amaigabean sartzen gara.
        for (;;) {
                // Bidaltzen...
                if(sendto(sock, bufferra, luzera, 0, (struct sockaddr *)&soket_in, sa_luzera) == -1)  {
                        printf("Ezin izan dut ezer bidali, errore kodea %d\n", errno);
                        exit(EXIT_FAILURE);
                } else {
                        printf(" Raw! -> %s (tam %i)\n",helb_helb,(luzera * 8));
                }
                sleep(1); // Lotara pixka bat...
        }

        // Dena ongi atera bada... berez ez da hona helduko.
        exit(EXIT_SUCCESS);

}

-------------------------8<-------------------------------------------------------------


Zein da emaitza? demagun 192.168.1.250 tik erabiltzen dugula 192.168.1.1 en aurka. IPTRAF bezalako aplikazio
batekin zera ikusiko genuke:

ICMP dest unrch (host) (46 bytes) from 192.168.1.250 to 192.168.1.1 on eth0 

Hain justu sortu dugun paketea!!
Nola jolastu daiteke ICMP-rekin? saiatu mota ezberdinetako ICMPak bidaltzen. Nola portatzen dira helburuko
sistema eragileak ICMP arraroak jasotzerakoan? Horixe da Hackerren lana! 

Mota	Izena					Erreferentzia
----	-------------------------		-------------
  0	Echo Reply				 [RFC792]
  1	Unassigned				    [JBP]
  2	Unassigned				    [JBP]
  3	Destination Unreachable			 [RFC792]
  4	Source Quench			 	 [RFC792]
  5	Redirect				 [RFC792]
  6	Alternate Host Address			    [JBP]
  7	Unassigned				    [JBP]
  8	Echo					 [RFC792]
  9	Router Advertisement			[RFC1256]
 10	Router Selection			[RFC1256]
 11	Time Exceeded				 [RFC792]
 12	Parameter Problem			 [RFC792]
 13	Timestamp				 [RFC792]
 14	Timestamp Reply				 [RFC792]
 15	Information Request			 [RFC792]
 16	Information Reply			 [RFC792]
 17	Address Mask Request                     [RFC950]
 18	Address Mask Reply			 [RFC950]
 19	Reserved (for Security)			   [Solo]
 20-29	Reserved (for Robustness Experiment)	    [ZSu]
 30	Traceroute				[RFC1393]
 31	Datagram Conversion Error		[RFC1475]
 32     Mobile Host Redirect              [David Johnson]
 33     IPv6 Where-Are-You                 [Bill Simpson]
 34     IPv6 I-Am-Here                     [Bill Simpson]
 35     Mobile Registration Request        [Bill Simpson]
 36     Mobile Registration Reply          [Bill Simpson]
 37     Domain Name Request                     [Simpson]
 38     Domain Name Reply                       [Simpson]
 39     SKIP                                    [Markson]
 40     Photuris                                [Simpson]
 41-255 Reserved				    [JBP]

ICMP goiburuekin jolas daitekeen bezala, ip, tcp eta udp goiburuekin ere jolas daiteke; eta protokolo askoz
gehiago daude aztertzeko... . Ikusagun

/**** IP goiburua C programazioan ******/
struct ipheader {
 unsigned char ip_hl:4, ip_v:4; /* :4 honek esan nahi du bakoitza 4 biteko tam. duela */
 unsigned char ip_tos;
 unsigned short int ip_len;
 unsigned short int ip_id;
 unsigned short int ip_off;
 unsigned char ip_ttl;
 unsigned char ip_p;
 unsigned short int ip_sum;
 unsigned int ip_src;
 unsinged int ip_dst;
}; /* ip goiburuaren luzera: 20 byte (=160 bit) */

/**** UDP goiburua C programazioan ******/
struct udpheader {
 unsigned short int uh_sport;
 unsigned short int uh_dport;
 unsigned short int uh_len;
 unsigned short int uh_check;
}; /* UDP goiburuaren luzera: 8 byte (=64 bit) */


/**** TCP goiburua C programazioan ******/
struct tcpheader {
 unsigned short int th_sport;
 unsigned short int th_dport;
 unsigned int th_seq;
 unsigned int th_ack;
 unsigned char th_x2:4, th_off:4;
 unsigned char th_flags;
 unsigned short int th_win;
 unsigned short int th_sum;
 unsigned short int th_urp;
}; /* TCP goiburuaren luzera: 20 byte (=160 bit) */


Datorren zenbakitan tcp/ip paketeak sortzen saiatuko gara, baina RAW erabiliz. Paketeen anatomia goitik
behera ikasi behar da. Horrek erabateko kontrola emango digu.


#define LASTER_ARTE 1
exit(LASTER_ARTE);
					-niuBAI-

</1>



	2. Perl pusketak
	__________________________

<2> 

Gabon denoi!
ez telebistarik, ez irratirik, gauero karaktere berdedun konsola! 
Gaurko honetan web armiarma bat sortuko dugu. Perl lengoaiak erreztasu handiak ematen ditu amarauna 
zeharkatzen duten programatxoak garatzeko. Logikoa den moduan edibide xinplea ikusiko dugu lenbizi, gero
web xurgatzaile bat ikusteko.

Lehen kode zati honetan LWP liburutegiaren funtsak ikas ditzakegu, HTTP eskera xinple bat eginez.
Kode honek, argumentu bat jasotzen du <URLa> eta horixe jeitsi eta pantailaratzen du:

-------------------------8<-------------------------------------------------------------

#!/usr/bin/perl

# WEB armiarma bat sortzeko LWP moduluak erabili behar dira
# Bestalde, HTTP protokoloarekin lan egiteko beste zenbait modulu
# erabili behar ditugu: HTTP, URI

use LWP::UserAgent;
use HTTP::Request;
use HTTP::Headers;
use URI::URL;

# Hemen aldagaiak izendatzen ditugu. Argitasunagatik, ez besterik
my $armiarma;   # web bezeroa
my $goiburuak;  # HTTP protokoloaren goiburuak (eskaerarako)
my $url;        # URL (objektua)
my $eskaera;    # HTTP request objektua
my $erantzuna;  # zerbitzariaren erantzuna (orria ala errorea)
my $helburua;   # Helburu helbidea


# argumentuak.
if ($#ARGV != 0  ) {
        printf("Argumentu kopurua desegokia");
        die("Erabilera \n ./armiarma.pl http://helburua\n");
} else {
        $helburua = $ARGV[0];
        printf("OK helburua $helburua\n");
}


# Gure web armiarma edo agentea sortzen dugu:
$goiburuak = new HTTP::Headers(Accept => 'text/plain');

$url = new URI::URL($helburua);
$eskaera = new HTTP::Request(GET, $url, $goiburuak);
$armiarma = new LWP::UserAgent;
$erantzuna = $armiarma->request($eskaera);

## Zerbitzariaren erantzuna
if ($erantzuna->is_success) {
        print "Zerbitzariaren erantzuna: \n";
        print $erantzuna->content;
} else {
        print $erantzuna->message;
}

----------------------8<----------------------------------------------------------------

Erraza ezta?

Orain kode hori konplika dezagun. URL bat jeitsi ordez, url horren esteka propio guztiak jarraitu eta
url guztien bidea jarraitzen duen kodea sortuko dugu. Badira hau egiten duten programak, baina hemen atsegin
duguna guk geuk egitea da ezta??

Armiarma hau egiteko LWP liburutegia eta HTML parser bat erabiliko ditugu HTML kodean barna esteka guztiak
topatu eta jarraitzeko. Kode hau asko hobetu daiteke gure gustura URL bereziak hobeto ulertzeko edo web egitura
osoa jeisteko.

Armiarma honi parametro bakarra pasatzen zaio: url bat.
Adibidez:

./armiarma2.pl http://www.librezale.org

Armiarmak lehen eskaeratik hasita URL berriak ateratzen ditu, eta jatorrizko urlarekin erlazionatuta badaude
bere "datu basean" (hash_taula) sartzen ditu. Pixkanaka hash taula hori betetzen da eta bere elementuak jeisten dira.
Jeitsitakoak markatzen dira birritan ez jeisteko. URL guztiak konprobatzen direnean dei errekurtsiboak bukatzen dira
eta emaitza erakusten da. Programa asko hobetu daiteke emaitza emateko orduan; traza asko dauzka depurazio lanak
egiteko.

-------------------8<------------------------------------------------------------------

#!/usr/bin/perl 

# $Id: armiarma2.pl,v 1.3 2004/03/25 20:18:48 root Exp $
# WEB armiarma bat sortzeko LWP moduluak erabili behar dira
# Bestalde, HTTP protokoloarekin lan egiteko beste zenbait modulu
# erabili behar ditugu: HTTP, URI

#  Behar ditugun moduluak
use LWP::UserAgent;
use HTTP::Request;
use HTML::LinkExtor;
use HTTP::Headers;
use HTML::LinkExtor;
use URI::URL;


# Hemen aldagaiak izendatzen ditugu. Argitasunagatik, ez besterik
my $armiarma;		# web bezeroa
my $goiburuak;		# HTTP protokoloaren goiburuak (eskaerarako)
my $url;		# URL (objektua)
my $eskaera;		# HTTP request objektua
my $erantzuna;  	# zerbitzariaren erantzuna (orria ala errorea)
my $helburua;   	# Helburu helbidea
my %ESTEKAK = ();	# Esteka datubasea. Ez oso egokia horrela egitea

# argumentuak.
if ($#ARGV != 0  ) {
	printf("Argumentu kopurua desegokia");
	die("Erabilera \n ./armiarma.pl http://helburua\n");
} else {
	$helburua = $ARGV[0];
	printf("Jakin ArmIArmA - OK helburua $helburua\n");
}


# Hemen armiarma bilaketarekin hasten da. Dei errekurtsiboak dira.
&jeitsi($helburua);

print "Prest emaitza ikusteko? ";
$item = <STDIN>;

# programaren bukaera. Emaitza erakutsi:
foreach $esteka (keys(%ESTEKAK)) {
	print "$esteka \n";	
}

# Agurra
print "ArmIArmA> Mila eskera ArmIArmA erabiltzeagatik.\n";


##############################################
################ AZPIERRUTINAK ###############
##############################################

## jeitsi: programa errekurtsiboa
# web eskaerak egiten ditugu.
sub jeitsi {

	my ($helburu_url) = @_;

	# irteera baldintza. Honekin dei errekurtsiboak bukatuko dira.
	if ( $helburu_url =~/bukatu-da-akabo/ ) {
		return;
	}

	# URLa jeitsi behar dugu. 1ekin markatzen da, berriro ez jeisteko
	$ESTEKAK{$helburu_url} = 1;

# Gure web armiarma edo agentea sortzen dugu:
$goiburuak = new HTTP::Headers(Accept => 'text/plain');

$url = new URI::URL($helburu_url);
$eskaera = new HTTP::Request(GET, $url, $goiburuak);
$eskaera->referer("http://www.jakin.tk");
$armiarma = new LWP::UserAgent;
$armiarma->agent("Jakin-aRMiaRMa/0.1");
$erantzuna = $armiarma->request($eskaera);

print "ArmIArmA> GET $helburu_url ...\n";


## Zerbitzariaren erantzuna
if ($erantzuna->is_success) {# arrakasta eukiz gero
        print "Zerbitzariaren erantzuna: \n";
       # print $erantzuna->content;
} else { # bestela...
        print $erantzuna->message;
	return; # atera funtziotik
}

print "ArmIArmA> Estekak atera\n";

$parserra = HTML::LinkExtor->new(undef, $helburu_url);
$parserra->parse($erantzuna->content);

foreach $linkarray ($parserra->links) {
    my @element = @$linkarray;
    my $elt_type = shift @element;  # elementu mota

    if ($elt_type =~/^a$/) {
	    while (@element) {
	        # extract the next attribute and its value
	        my ($attr_name, $attr_value) = splice(@element, 0, 2);
		if ($attr_value =~ /$helburua/) {
			#&garbitu_esteka();
			&hash_taulara($attr_value);
			#print "Esteka: -> $elt_type :  $attr_value \n";
		}#if
    	    }#while
   }#if
}#foreach

#printf "Guztira: ". keys(%ESTEKAK) ."\n";
 
# Dei errekurtsiboa
&jeitsi(&berria_bilatu());
}


### garbitu_esteka
## estekaren helbideari anchor eta parametroak kendu.
## funtzio erreserbatua, hobekuntza bezala.
sub garbitu_esteka {
	my $emaitza = $helburua;
}


### berria_bilatu
# HASHetik aztertu gabe dagoen URLa lortu
sub berria_bilatu {
	foreach $url_bat (keys(%ESTEKAK)) {
		if ($ESTEKAK{$url_bat} == 0) {
			#print "Hona hemen bat: $url_bat \n";
			return $url_bat;
		}
	}
	# Honekin irteera baldintza betetzea behartzen dugu.
	return "bukatu-da-akabo";
}

### hash_taulara
# HASH taulan sartu
sub hash_taulara {
	my ($esteka_berria) = @_;
	#print "taulan sartu... ". $esteka_berria ." \n";
	# URLa berria bada, HASHean sartu 0 markarekin
	if (!exists($ESTEKAK{$esteka_berria})) {
		$ESTEKAK{$esteka_berria} = 0;
		print "Taulan ->  esteka BERRIA: ". $esteka_berria ." - ". $ESTEKAK{$esteka_berria} ." \n";
	} else {
		#print "Taulan ->  esteka badago: $ESTEKAK{$esteka_berria} \n";
	}
}


-------------------------8<------------------------------------------------------------

die("by the sword");

					-Regexp Angelorum-

</2>


	3. Sistema eragileak: nire lehen banaketa
	__________________________

<3>

Kaixo lagunok. agur bero bat Nafarroatik.
Sistema eragile bat garatu dezakegu geu bakarrik? bai, gaur egun posible da, edonork
sor dezake linux distribuzio bat edo liveCD propio bat; dokumentazio asko daukagu horretarako,
eta egon lasai, hemen ez dugu horren copy-pasterik eginen.

Ze helburu daukagu sistema eragile bat sortuz? sistema pertsonalizatua izatea, sistema propioa
sortzea, helburu zehatzetarako sistema doitzea... danetarik. Baina hemen aurkeztu nahi den helburua
IKASKETA da. Linux sistemetaz ari gara, noski: sistema eragileen funtzionamendua ulertzeko modurik egokiena
unix batekin ibiltzea da. Azken finean, egungo windowsak unixen ideiak darabilzki, ongi funtzionatzen
dutela erakutsi dutelako. 

Linux sistemaren banaketa bat sortzeko proposatu nahi dugu aukera LFS proiektua da: Linux From Scratch,
hots, linux 0tik hasita. Honek apenas dakar softwarerik, zenbait partxe bakarrik eskeintzen ditu.
Linux From Scratch liburu bat da, linux bat pausoz pauso (aginduz-agingu, ia ia) sortzeko azaltzen diguna.

Gaurko artikuluan LFS banaketa baten sorkuntza esperientziaz arituko gara.
Osagaiak: -linuxdun makina bat partizio libre batekin (3G libre gomendatzen dira)
	  -LFS dokumentazioa
	  -Beharrezkoak diren iturburu kodeak, internetetik jeitsiak. Ez dute zertan azken bertsioak izan behar,
		dokumentazioak esaten duenak baizik.p


1-Prestaketa:
Partizio berria /mnt/lfs guneak montatu eta shell aldagai baten bitartez atzitzen dugu:
LFS=/mnt/lfs
export LFS
Erabiltzaile berezia sortzea ere komeni da.
Hortik aurrera, $LFS partizioan source izeneko direktorio bat hartu eta iturburu kodea jeisten has gaitezke,
kode gehiena ftp.gnu.org-en dago.
Iturburu kodearekin batera distribuzioa sortzeko zenbait partxe ere jeitsi beharko dira, direktorio berdinean
gorde daitezkeenak.
Lan neketsu hori aurrezteko, Jakinen webgunean script bat prestatu dugu wget-eki jeisteko:
(honako hau exekutatu)
lynx -source http://www.angelfire.com/zine2/jakinezine/jakinos.sh | sh

2-Banan banan instalatu:
Konpilazioa! lehen konpilazio bat egin behar da, baina gure sistemako tresnak sortzeko. Aurrepauso bat besterik
ez da, eta pazientziakin egi behar da. Bitarrak /tools izeneko direktorioan gordeko dira. make check pausoak
egiten badira zenbait akats egon daitezke, baina gainontzeko konpilaziotan ez da errorerik egon behar.
Laburbide gisa horrela egin daiteke pakete bakoitzeko, posible bada:

./configure --prefix=$LFS/tools && make && make install && echo "Dena primeran doa"

Azken mezua ikusten bada, orduan dena ongi doa.

3- Behin dena instalatu denean chroot egin!!
chroot egiterakon sistemaren / direktorioa (sustraia) lekuz mugitzen dugu nolabait. /mnt/lfs izanen da orain
gure sustraia eta hortik lanean jarraitu behar da. Shell minimoa eta konpilazio tresnak prestaturik ditugunez,
orain gure sistema eraikitzen da. Berriro ere pakete guztiak konpilatu beharko ditugu beste batzuekin batera.
kernela ere prestatu beharko da eta bukatzeko GRUB prestatu.

4-Pauso guztiak ongi jarraituz gero, gure sistema propioaren hazia lortu dugu. reset bat egin eta probatu,
eta BADABIL!!
Gure laborategian Jakin Linux izena eman diogu:

Jakin Linux 1.1 (Lapurdi)

Eta orain zer??
jejeje. Beno, hori gutxienezkoa da. Zer lortu dugu honekin? distribuzio pertsonala gure ego-aren zerbitzuan?
ez horixe!! Gure ustez, horrelako linux distro bat benetako Hacker distribuzioa da; iturburu kodea, konpiladoreak,
ikasketa eta ikerketara zuzendutako distroa baita. Gure aldetik Jakin Linux hori garatzen saiatuko gara, Lapurdi
bertsiotik hasita, Euskalerria bertsiora heldu artio!! :D

Benetan Linux From scratch-en liburua jarraitzea oso interesgarria da, eta linux-en funtzionamendua ulertzen
lagunduko digu. Hagitz gomendagarria!


echo -n "Agur" && echo "... hurrena arte" 

					-Espoz&Mina-

</3>


	4. Sare Bayesiarrak
	__________________________

<4>

Sare Bayesiarrak: ezjakintasun egoeren aurrean erabakiak hartzeko tresna aproposa.

Kaixo Jakinzaleaok! 
Zertan ari zarete hau irakurtzen? ziur aski kutxa beltzak irekitzeko eta ezagutzeko grina daukazue,
hitz batean "hackeatu". Nire partetik Adimen Artifizialak (informatika bezain "zaharra" dena)
eskeintzen dituen tresnak aurkeztuko ditut. Oraingo honetan Sare Bayesiarrak.

Honez gero ezagutuko dituzue "Bayes" hitza, izan ere xelebre egin da SPAMaren aurkako burrukan;
bogofilter, spamassassin, assps bezalako email filtroek sare bayesiarrak erabiltzen dituzte email
onak eta zaborra bereizteko eta bere erabilera asko hadeatu da azken urtean. Holako programak erabili
badituzue ohartuko zineten nolako arrazonamendua darabilten: puntuazio sistemak erabiltzen dira probabilitate
sinpleak eginez; horixe da AAren (Adimen Artifizialaren) oinarrizko eredua, emaitzak ez dute zertan
zehatzak izan behar eta lausotasuna onargarritzat jotzen da. 

Adibidez, demagun mail bat jaso aurretik filtratzen dugula; spamassassinek hola arrazonamendua
erakuts zezakeen:

Content analysis details:   (14.3 points, 5.0 required)

 pts rule name              description
---- ---------------------- --------------------------------------------------
 0.5 X_PRIORITY_HIGH        Sent with 'X-Priority' set to high
 3.5 TRACKER_ID             BODY: Incorporates a tracking ID number
 0.5 REMOVE_REMOVAL_2WORD   BODY: List removal information
 0.1 HTML_70_80             BODY: Message is 70% to 80% HTML
 0.1 HTML_FONTCOLOR_RED     BODY: HTML font color is red
 0.4 HTML_FONT_INVISIBLE    BODY: HTML font color is same as background
 0.1 HTML_FONTCOLOR_UNKNOWN BODY: HTML font color is unknown to us
 0.1 MIME_HTML_ONLY         BODY: Message only has text/html MIME parts
 0.0 HTML_MESSAGE           BODY: HTML included in message
 0.1 HTML_FONT_BIG          BODY: HTML has a big font
 1.6 FRONTPAGE              BODY: Frontpage used to create the message
 0.8 REMOVE_PAGE            URI: URL of page called "remove"
 3.3 MSGID_FROM_MTA_SHORT   Message-Id was added by a relay
 1.9 FORGED_MUA_EUDORA      Forged mail pretending to be from Eudora
 1.1 UPPERCASE_50_75        message body is 50-75% uppercase

Hara! spamassassin programaren irteera 14,3 balioa da. Hortik aurrera guk erabaki dugu spam baten
balioa 5etik gorakoa izan behar duela, eta ondoriotzat emaila zaborra bezala aurkezten da.

-Sare Bayesiarren funtsak.
AAean funtsezko ataza ezagutzaren errepresentazioa da. Ezagutza erregelen bitartez errepresenta daiteke,
adibidez:
Edozein M makina PortuIrekia(M, 135/tcp) -> SistemaEragilea(M, Windows)

Hau da, makina batek 135garren portua irekia badauka, ziuraski Windows sistema eragilea da.
Erregela honi buelta ematen diogu:
Edozein M makina SistemaEragilea(M, Windows) -> PortuIrekia(M, 135/tcp)

Hurbilpen hau ez da guztiz egiazkoa, windows guztiek ez dutelako 135 portua irekia, eta 135
garren portua irekia eukitzeak ez du derrigor esan nahi windows baten aurren gaudenik.
Horregatik Probabilitate Teoria erabili behar da, ezjakintasun egoerak hobeto laburbiltzen dituelako.

Edozein M makina PortuIrekia(M, 135/tcp) -> SistemaEragilea(M, Windows) 0,8 probabilitatearekin.

Nondik ateratzen da 0.8 hori? estadistikatik, inkestetatik,..
- Zenbait axioma edo oinarriko egiak:
 1) 0 <= P(A) <= 1
 2) P(Egia) = 1      eta   P(Faltsua) = 0
 3) P(A v B) = P(A) + P(B) - P(A^B)

-"A priori" motako probabilitatea ere erabili daiteke.

Emaila("Spam") = 0,4

Hots, emial bat spam izateko probabilitatea %40koa da. Gaur egun holako baieztapena egiatik hurbil dago tamalez.
Baieztapen konplexuagoak egin daitezke:
Emaila("Spam" ^ "Nigeriarra") = 0,15

- Baldintzazko probabilitatea:
P(A|B) = 0,7  Hots, Aren probabilitatea B jakinda 0,7 da.
Adibideak:

Queso edo Nmap bezalako programek horrelako erregelak erabili zezaketen:
P(Windows | PortuIrekia 135) = 0,7
P(Windows | PortuIrekia 135) ^ PortuIrekia(445)) = 0,9

Formula orokorra:
         P(A ^ B)
P(A|B)= ----------    non P(B) > 0
           P(B)

- Probabilitate konjuntoa
N dimentsioko taula non gelaska bakoitzan egoera zehatz bat gertatzeko probabilitatea ematen den.
Adibidez.
P(Windows,PortuIrekia 135)

          PortuIrekia 135  |  ¬PortuIrekia 135
 windows        0,6        |        0,1
¬Windows        0,2        |        0,1           Elementu guztien baturak 1 itzuli behar du.

Hartaz: P(Windows v PortuIrekia 135) = 0,6 + 0,1 + 0,2    (3.garren axiomatik)

Baldintzazko probabilitatearekin:  
                            P(Windows^PortuIrekia 135)         0,6
P(Windows|PortuIrekia 135)= --------------------------  = ------------ = 0,75
                               P(PortuIrekia 135)           0,6 + 0,2

Demagun Ssitema bat eskaneatzen dugula. 135garren portua irekita dago, eta dakigunez
Oinarrizko datu estatistikoak eukita, ezjakintasun egoera argitu daiteke.

- Bayes-en teoria

Aurreko ideiak aurkeztu ostean, hona hemen Bayes-en teoria:

        P(A|B)P(B)
P(B|A)= ----------   
           P(A)

Bale ba, formuladun txapa guzti hau zertarako? formula batera iristeko? 
Bai jauna! formula horrekin laburbiltzen da AAren inferentzia probablistikoaren metodorik erabiliena.
Nola erabili daiteke? Ikusagun adibidetxo bat.

Demagun a priorizko probabilitate hauek ditugula:

P(SistemaMotel)=0,1  Sistema bat motel ibiltzeko probabilitatea (P(A))
P(MIMAILBirusInfekzioa)=0,0005 Sistema bat Mimail birusa eukitzeko probabilitatea (P(B))
P(SistemaMotel | MIMAILBirusInfekzioa) = 0,4  Sistema motel joateko probabilitatea infekzioa dagoela jakinda.(P(A|B))

Demagun orain gure sistema motel dabilela. Zein da MIMAL birusak zerikusiri eukitzeko probabilitatea?
        P(A|B)P(B)    0.4 x 0.0005
P(B|A)= ---------- = -------------- = 0.0002
           P(A)           0.1

Hara, moteltasunaren arrazoia MIMAIL birusa izatearen probabilitatea 0.0002koa da.
P(A),P(B) eta P(A|B) bezalako datuak estatistiketatik atera daitezke. Hortik aurrera informazio berria lor dezakegu.
Ikusten den bezala, emaitza ez da BAI ala EZ itsurakoa. Zenbaki bat itzultzen da, eta gure lana izango
da balio horiei muga bat jartzea eman nahi diegun esanahia lortzeko. Adibidez, spamassassin-ek 5.0ko puntuaketa
SPAM bezala kontsideratzen du.
Aldagai gehiago sar ditzakegu:
P(RAMGutxi) = 0,1  Sistema batek behar baino RAM memoria gutxiago eukitzea  (P(C))
P(SistemaMotel | RAMGutxi) = 0,5 Sistema bat motel ibilitzeko probabilitatea RAM gutxi daukala jakinda.

P(C) eta P(B) probabilitateak balndintza independienteak dira, eta independentzia horrek probabilitate kalkuluak
erreztuko ditu.

Sareak.
Oinarri hauekin arrazonamendu sistemak eraiki behar dira, ezjakintasun egoeren aurrean erantzunak lortu ahal
izateko. Teoria probabilistikoarekin erantzunak lor daitezke baina eremu zehatz batean aldagai bat baino gehiago
egon daiteke eta horrek zailtasunak gehitzen dizkio arrazonamenduari batez ere baldintzazko probabiliteak direla eta.
Zorionez, Bayes-en teoria erabiliz eta baldintza independentziari eskerrak eremuaren aukerak murrizten dira.
Aldagaien artean dauden dependentziak aurkezteko Uste-sareak erabiltzen dira; adibide honetan erakusten dena bezalakoa:

               ________                 ___________
              | Birusa | P(B)=0,0005   | RAM eskas | P(C)=0,1
	    B |________|             C |___________|
		  \                      /
                   \                    /
                    \                  /
                     \                /
                      \              /                         Hauxe litzateke Bayesiar Sarea
                      _\|__________|/_                         (grafo zuzendua eta aziklikoa)
                     | Sistema Motel  |  B    C   P(A)   
                    A|________________|----------------        Bestelako izenak: sare probabilistikoa, 
                         /     \         T    T   0,80         ezagutza mapa, kausalitate sarea,e.a...
                        /       \        T    F   0,60
                       /         \       F    T   0,50
                      /           \      F    F   0,02    
                     /             \
                    /               \
               ___|/____         ____\|______
               | crash |         | itzali   |
              D|_______|        E|__________|
 
               A  P(D)            A   P(E)
             ----------         -----------
              T   0.7             T   0,6
              F   0.05            F   0,03

Sare hauen bitartez probabilitateak errepresentatzen ditugu eta azken finean adierazpen multzo bat kodifikatzen ari
gara. Sareak erabiliz inferentzia prozedurak definitu daitezke, programa bati portaera "adimentsua" emateko balio
dezaketenak. Hurrengo aleetan sareetan sakondu eta inplementazio praktikoak erakusten saiatuko naiz.

Ordura arte, asko ikasi!!

fire => exit()

					-Assert-

</4>



	5. Interneten funtzionamendua: AS-ak
	__________________________

<5>

Kaixo, keepalive naiz. Internet sarearean funtzionamendu orokorraz arituko naiz. Goitik-beherako
azalpena ematen saiatuko naiz, hots, idei orokorrak eman eta kasu zehatzekin bukatuko dut. 
Gai honek artiukulu askotarako ematen du, beno ba, ikusiko dugu noraino heltzen garen.

Internet TCP/IP protokoloan oinarrituko komunikazio sarea da. Faltsua al da printzipio hau? Gaur egun, protokolo 
askoz osatuta dago, eta mota guztitako enkapsulazioak topa ditzakegu sarean: ppp, atm, l2tp, mpls, pptp...
Hala ere guzti horiek TCP/IP protokoloarekin batera funtzionatzen dute. Zeren gainean? kable arruntak, zuntz
optikoak, airea, edozein moduan azken finean. TCP/IP protokoloak bere behe mailan ez du inolako komunikazio
motarik derrigortzen eta hortan datza neurri handi batean bere arrakasta.

Bai, guzti hori badakigu, baina nola funtzionatzen du dena?
Zer dago hor kanpoan? Router mordoak leku guztitan? Nork kontrolatzen ditu sareak? EEBBak?

Internet sarea ASz osaturiko sarea da: Sistema Autonomoak alegia (AS: Autonomous System). Sistema autonomo bakoitzak
sarearen zati baten jabetza dauka: IP helbideak(aurrizkiak) eta hori bezain garrantzitsu den ikusgarritasuna. Zer esan nahi
dugu ikusgarritasunarekin? Ip helbide batera heltzeko Sare Autonomoak helbide horren ikusgarritasuna eman behar
du, hots, bere bideratze taulan iragarri behar du. Sistema autonomoetan: ikusgarritasuna eta iragarpena
oinarrizko ideiak dira. Nortzuk dira ASak? baldintza batzuk betetzen duen edozein erakunde, enpresa, e.a.
ez du zertan publikoa izan behar.

Demagun Internet txiki bat daukagula, 6 sistema autonomoekin: SA1,SA2,SA3,SA4,SA5,SA6.
Bakoitzak IP mordo bat dauka (IP helbideak faltsuak eta baliorik ez dutenak mundu errealean).

 
   ___                    ___                        ___
  /   \                  /   \                      /   \
 | SA1 |                | SA4 |                    | SA3 |
  \___/                  \___/                      \___/
  10.1.0.0/16            14.4.0.0/16                13.3.0.0/16     
  100.1.1.0/17                                      130.3.0.0/16
                                                    13.13.13.0/17

                    ___                      
                   /   \                     
                  | SA5 |                    
                   \___/                     
                   15.5.0.0/16
                   155.55.0.0/16


      ___                    ___                       
     /   \                  /   \                      
    | SA6 |                | SA2 |                    
     \___/                  \___/                     
     16.6.0.0/16            12.2.0.0/16
     166.66.0.0/16          22.22.2.0/17
     66.6.0.0/16


Internet-ek horrelako itsura logikoa dauka: sistema autonomoetaz osaturik dago. Bakoitzak bere sare zatiaren
ardura dauka. SA2 an adibidez, nola jakin dezakegu beste lekuetare joaten? SA2-k, gainontzeko sistema autonomoen
helbideratzeak ikasten ditu. Helbideratze taulak, DNS zerbitzarien datuak bezalaxe behin eta berriro eguneratzen
ari dira internet sarean; nola mugitzen dira datu horiek? BGP bezalako helbideratze protokoloen bitartez.
BGP routerrek interneteko bideratze GUZTIAK (bai, GUZTIAK) ezagutzen dituzte.

Demagun Otsonet enpresaren zerbitzua kontratatzen dugula, eta bere OtsoADSL bat gure etxean
jartzen dutela 166.66.34.154 helbide publikoarekin. Nola daki nire ruterrak 130.3.45.234 helbidera heltzen?
Hasteko ruterrak bere gateway-a bilatuko du, eta router honek edo enpresako beste batek (BGP routerrak izaten dira)
bidea erakutsiko dio. Horrelako zerbait. 
                                                            ________
                                                           /       /|
                                   _________              /_______/ |
           ________               / Adslak /|             |       | | 
ETXEA-----|________|-------------/________//--------------| BGP   | |-------- ..... -------- Beste AStara
           130.3.45.234/24       |________|               | rout. | /
                                   130.3.45.1/24          |_______|/

ASen artean konexio zuzena egon daiteke peering akordioen bitartez. Peering akordioak trafiko elkarbanaketak
dira, non ASak bata besteari bere bideak erakutsiz beraien artean sare trafiko banatzen duten.
Peering akordioak gune neutrotan egiten dira, Euskonix (Bilbon), Espanix(Madrilen) edo Lynx (Londres) kasu.

Denok jo dugu RIPE-ren whois zerbitzura noizbait IP helbide batengatik galdetzeko.
www.ripe.net erakundeak IPak ematen dituen erakunde bakarra da? ez horixe. Munduan hiru erakunde sortu
dira: RIPE (europarako), ARIN (Estatu batuak), APNIC (gainontzekoak)

Laburbilduz: internet sarea, IP mailan ASz osatutako sarea da, eta AS horien arteko komunikazio edo
bideraketa BGP protokoloaren bitartez egin daiteke. AS barruan iBGP edo bestelako bideratze protokoloak
erabil daitezke.

Nondik joaten dira paketeak peering-a ez baldinbadaukagu?? AS txikiek AS handiei "transitoa" kontratatzen
diete eta horrela AS handiek bere internet zatia erakusten dute; hots, AS handiek zure gateway izateagatik
kobratzen dizute. 

Galdera batzuk utziko ditut airean:

Nortzuk daude goi mailan?
Orduan.. internet esku pribatuetan dago?

write mem
exit
					-keepalive-

</5>



	6. Kultura
	__________________________

<6>


Titulua: Criptonomicon
Egilea: Neal Stephenson (http://www.nealstephenson.com)
http://www.cryptonomicon.com/ Web gune ofiziala

Liburu ikaragarri ona hauxe. Zergatik ona? egileak kriston dokumentazio lana egin duela nabaritzen da, eta modu 
ulerkor eta dibertigarrian idazten du gainera. 1000 orri inguruko liburua da hauxe, frantzian eta espainian hiru liburutan 
argitaratu dena. 

Liburuak hiruzpalau istorio paralelo kontatzen ditu, elkarrekin lotuak. Batetik Lawrence Waterhouse 
bigarren gerrate mundialeko kriptoanalista baten komeriak kontatzen ditu, Alan Turing eta beste matematikari alemaniar 
baten adiskidea dena. Bestetik Shaftoe, gerrateko marine txoriburuaren abenturak (kriptoanalisten lan zikina egiten duena) 
deskribitzen ditu munduaren punta batetik bestera (inglaterra, suedia, eta batez ere pazifikoa). Bestetik Goto Dengo japoniarra,
eta bukatzeko, gaur egunean kokatuta Randy Waterhouse izeneko hacker baten historia kontatzen du. Randy-ren teknologia
enpresa batean dabil lanean, eta Kinakuta izeneko irla-estatu txiki batean (.kk dominioduna) datu babestoki bat montatzeko
plana dauka. Istorio guztiek lotura sendoak dauzkate, batez ere Filipinar irlen inguruan. 
Informatikari dagokionean, egileak ez du inolako exagerazio edo fantasiarik sartzen, eta liburuan aipatzen diren
teknikak guztiz errealak dira. Adibidez, Vi editorearekin zaudenean, diskoan gordetzen dena zifratu daitekela; holako
zehaztasunek liburuari errealismoa eta fidagarritasuna ematen diote.


Randy-ren gora beherak inerneten burbuila garaian suertatzen dira; tipoa unix-zale amorratua da, jendearekin erlazionatzeko 
zailtasunak ditu eta paranoia puntu bat dauka beti (beti bere portatilaren datuak zifratzen ditu). 


Liburua, kanpotik ikusita nahi-ta-ezin bat izan daitekela dirudi, baina benetan, oso gomendagarria da.




					-km-
</6>


	7. Estekak,Oharrak,Agurrak
	__________________________

<7>

uf! bukatu da Jakin ezinearen hirugarren ale hau, ahalegin handiz erditua. 
Ez ahaztu hauexek direla ezinearen helbideak:

http://www.jakin.tk/
http://jakinezine.galeon.com/

Eta email helbidea:
jakin@mailbox.co.za

CALL FOR PAPERS!!!
Zeren zain zaude? gai asko dauzkagu hitzegiteko: ASM, aribako sareak, spectrum :), algoritmo genetikoak, matematikak,
gai sozialak, hacktibismoa, hacker taldeak, istorioak, albisteak, proiektuak... Anima zaitezte!

Hurrengo aleari begira zenbait ideia ditugu prestaturik. Adi egon!

<Oharra>
Jakin ezinea ez da ikurleek bere kodeaz egiten duten erabileraren arduradun. Fanxinaren helburu bakarra
informatika teknikak erakustea da, dokumentaziotan, interneten, edonon dagoen informazioa modu ulerkor
batean laburtzea azken finean. Ohar tipiko hau sartzea beharrezkoa EZ dela deritzogu, baina badazpada
hemen da.
</Oharra>
					-edit-

</7>

</jakin>
