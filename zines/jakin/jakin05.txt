<jakin>

        JJ   AAAAAAAA  KK   KK   II  NN    NN
        JJ   AA    AA  KK  KK    II  NNNN  NN
        JJ   AAAAAAAA  KKKKKK    II  NN NN NN 
        JJ   AA    AA  KK  KK    II  NN  NNNN
  JJ    JJ   AA    AA  KK   KK   II  NN   NNN
  JJJJJJJJ   AA    AA  KK    KK  II  NN    NN

      e         z        i        n        e	
 ______________________________________________________________________
| 5. alea (Balioa: 66k)                                                |		
|______________________________________________________________________|
| 2004/08/14                                                           |
|______________________________________________________________________|
|                                                                      |
| Segurtasun elektronikoari buruzko fanxina, euskera hutsez            |
|                                                                      |
|______________________________________________________________________|
|                                                                      |
| Parte hartzaileak: edit,niuBAI, Regexp, Espoz&Mina,                  |
|                    NapharHack eta KM                                 |
|______________________________________________________________________|
| email helbidea: jakin@mailbox.co.za                                  |
|                 jakin@kaixo.com                                      |
|		  jakinezine@hispavista.com                            |
|______________________________________________________________________|
| Web helbidea:  http://www.jakin.tk                                   |
|		 http://jakin.sf.net                                   |
|                                                                      |
|______________________________________________________________________|



Ale honetan:

Zb Artikulua				Egilea	
______________________________________________________
0. Hitzaurrea                           edit
1. Jakin OS banaketa			Espoz&Mina
2. Unix sistema programazioa (II)       Espoz&Mina
3. Zenbakitze sistemak                  NapharHack
4. TCP/IP programazioa (V)              niuBAI
5. ASM edo mihiztadura lengoaia         NapharHack
6. Espresio erregularrak                Regexp
7. Kultura                              km
8. Albisteak,Estekak,Agurrak            edit
______________________________________________________



     "programa"
5. INFORM. Ordenadore bati programazio-lengoaia batean idatzita ematen zaion agindu-segida, 
lan jakin bat burutzeko behar diren oinarrizko eragiketak berak egikaritzeko moduan zehatz 
azaltzen dituena. 
6. TEKNOL. Makina automatiko batek lan jakin bat burutzeko egin behar dituen eragiketen segida; 
delako segida makinak egikaritzeko moduan azaltzen dituen agindu-segida. Ikuzgailuaren programa. 
· INFORM. iturburu-programa. Ik. iturburu. || liburutegiko programa. Liburutegian bildutako programa,
edozein programatan laguntza moduan erabil daitekeena. || objektu-programa. Ik. objektu. || programa monitore.
 Mikroprozesadoreetan erabiltzen den programa informatikoa, beste programa batzuen martxa zaintzen duena.




(((((((((((((((((((((((((((((((((((( Jakin dezagun!! ))))))))))))))))))))))))))))))))))))))


	0. Hitzaurrea
	__________________________


<0>

Jakin bo5t
Heldu gara! bo5tgarren alearen mugan gaude. Diotenez horixe da ezine baten mugarria, bostgarren alea ateratzen
ez bada ez dago jarraipenik. Ez dakigu azkenekoa izanen den ala ez baina tira. Uda bero eta luze baten hasieran
ibiltzen hasi zen ale hau, eta udaren bukaeran aurkeztea espero genuen nafarroako Navarparty-n; baina aurreratu
egin gara beraz hurrengo alea party horretarako prest eukitzea hartu dugu jomugatzat.

Uda aproposa da ikasten jarraitzeko bere gau bero amaitezinekin: galtza motzak, tirantedun kamixeta, Jakin CDbizia
biraka, kafe huts-hotz litroak, pantxineta, dokumentazio mordoa eta batez ere denbora librea (urrea!). 
Izan ere aurtengo udan Jakin ezineko ohizko kideok ikasketa-erretiro bat prestatu dugu norbera bere etxean egiteko:
uHu edo "udako Hacker unibertsitatea". Zenbait gaietan sakontzeko asmo tinkoarekin gai multzo bat proposatu eta
horien ezagutza lortzea proposatu dugu; horren emaitza fanxin hau hobetzea, Jakin banaketa aberastu eta euskarazko
dokumentazio gehiago ateratzea izatea espero dugu.

Zer dakar Jakin bo5t-ak?
Programazioa batez ere; adibideak, kode irekia, artikuluen jarraipena,... gurekin ohizko niuBAI, Espoz&Mina unix eta
Cren mundu zabala erakusten. NapharHack taldeari eskerrak ASMren infernura jeitsiko gara bere 7 solairuak ezagutzeko. 
Beste inor ausartu ez denez (NOP,NOP,NOP), talde kementsu honek gai zail horren ardura bere gain hartu du. Hala ere 
gai honen inguruko beste laguntzak ongi etorriak izango dira.
NH taldeak beste (behar-beharrezko) artikulu idatzi du, matematikoa gainera! zenbakitze sistemak aurkezten dizkigu,
FUNTSEZKO ezagutza informatika eremuan. 
Perl zale amorratua den Regexp-ek beste funtsezko gaiaz dihardu: espresio erregularrak; perl eremuan eta edozein
programazio lengoaian (awk, shell, c) tresna oso baliotsuak testu patroiak bilatzeko.

Nafar fanxina dirudi, izan ere 4 artikulu euskalerriko anai zaharratik datoz. Nun zaudete besteak? ez daukagu lotsarik,
agian mende gehiegi egon ginen Gaztelako erresumaren menpe XD

Oraindik gure maila oso kaxkarra da, inongo arazorik gabe onartu behar dugu eta kitto. Artikulu asko sarrerak dira, baina
pixkanaka bere zailtasuna areagotuz doa (TCP/IP artikuluak adibidez 5 atalera heldu dira).

Heldu teklatuari irakurleak!


					-edit-
</0>



	1. Jakin OS banaketa
	__________________________

<1>

Agurrak guztioi.
Jakin fanxinaren 3.en alea linux from scratch proiektuaz jardun ginen, linux banaketa baten garepenaz azken finean.
Esperientzia hori erabiliz linux banaketa bat ateratzea pentsatu genuen fanxinarekin batera garatzen joateko.
Banaketa sourceforge gunean topa daiteke honako helbidean:
http://jakin.sourceforge.net (edo http://jakin.sf.net)

Banaketa sortzea tribiala da gaur egun, horregatik beste ahaleginak egiten ari gara dokumentazio aldetik, izan ere
euskarazko dokumentazio askorik ez dago.  Hacker eskuliburua bezalako proiektuekin bat eginez banaketa euskaldun dexente
bat lortzea espero dugu. Dena den, banaketa honen helburu nagusia ez da bistaz galdu behar: garapen banaketa da, ikasteko
erabiltzen dena. Eguneroko lana egiteko banaketa aproposagoak dauzkagu eta ez dut izenik eman behar.

Jakin banaketa instalatzerakoan zer topatuko dugu?
ezer berezirik printzipioz. Vi editorea eta garapen tresnak:
gcc, glibc iturriak, make, zlib, cvs, eta oinarrizko unix agindu multzoa. 
Sortu dugun azken bz2-an (0.1.2) tresna hauetaz gain kernel iturria gehitu dugu, eta openssh zertbitzari/bezero programak.
Oinarriak baditugu, eta pixkanaka erabilgarri izan daitezkeen liburutegiak gehituko dira (libnet, libpcap, ea). 
Hasiera batean C eta perl lengoaietarako liburutegiak gehitzen saiatuko gara.
Azken banaketan interneteko ezinbesteko tresnak gehitu dira posta, irc eta testu nabigatzaileak batez ere. Kernel iturriarekin
batera banaketa behar adina doitu daiteke bakoitzaren beharretara. Hauxe da fitxategi sistemaren itxura:
/+
 +/bin  
 +/boot  
 +/dev  
 +/etc
  opt/  rc.d/  sysconfig/  
 +/home  
 +/lib  
 +/mnt  
 +/opt  
 +/proc  
 +/root  
 +/sbin  
 +/source  
 +/tmp  
 +/usr
  local/  bin/  etc/  include/  lib/  sbin/  share/  src/  man/  doc/  info/  var/
 +/var
  cache/  empty/  lib/  local/  lock/  log/  mail/  opt/  run/  spool/  tmp/



Zein da helburua?
(ikastea behintzat) Jakin OS sistemaren helburu nagusia garapen banaketa malgu bat lortzea da. Gainera banaketa
ez dator ez redhat ezta debian bezalako banaketatik beraz ez dauka inolako sokarik edo lokarririk. Nahi duzuena instala
daiteke behar diren konpilazio aukera guztiekin. Dena den instalazioa ez da behar bezain erreza momentu hauetan.

Instalazio CDa ala liveCDa?
zaila da aukeratzea, hasiera batean instalazio CD bat sortzea pentsatu da, baina CD-bizia ere interesgarria izan daiteke
batik bat bi helburutara hel gaitezkelako: CDbiziarekin instalazio CD bat daukagu nolabait. Horaintxe lan horrekin gabiltza.
linux txiki batekin abiatzen den CD lortu dugu, baina instalazio kodea falta zaigu. Behin hori lortuta gure ahaleginak
banaketa hobetzen erabil zuzen ditzakegu.

Dokumentazioari dagokionez, 4 dokumentu nagusi prestatzen ari gara:

1.Instalazioa : jakin nola instalatu, hitz gutxitan.
2.Jakin sistemaren eskuliburua : sistema ezagutzeko dokumentua; sistema mapa. 
3.Agindu erreferentzia : agindu guztien zerrenda.
4.Programazio gidaliburua : lan ikaragarria hauxe.

Programazio gidaliburua sortzea ez da ahuntzaren gauerdiko eztula. NH taldearekin bat eginez, hacker eskuliburuaren
testuak erabiltzea pentsatu dugu, bueno izan ere nhtaldeak proiekturekin bat egin du. Hemendik sortzen den dokumentazioa
bi norantzetan hedatuko da, liburutik ezinera eta ezinetik liburura.

Sourceforgeri eskerrak proiektu ireki honen garapena errezten da, izan ere SFek eskeintzen dituen komunikazio
tresnak oso aproposak dira batez ere kanpotik ideiak, eskaerak, oharrak e.a. jasotzeko. 
Zuen berri eukitzea espero dugu.

www.sourceforge.net proiektua ezagutzen ez baduzue, zeren zain zaudete? proiektu ezagun eta ezezagun pila topatuko duzue.

Hemendik aitzina banaketa honen azken garapenen berri emanen dugu. Azken berriak jakiteko http://jakin.sf.net

Bitartean beste banaketa bat gomendatzen dizuegu: X-evian, sourceforge-n ere topa dezakezuena. Bilboko hacklabean
garatu den banaketa da eta primeran dabil.

telinit 6

                             -Espoz&Mina-
</1>


	2. Zenbakitze sistemak
	__________________________

<2> 

1 + 1 = 1

Okerra al da ekuazioa? zenbaki bitarrak balndibadira eta algebra boolearra erabiltzen bada
espresio hori guztiz zuzena da.

Modu oso ezberdinak daude gauzak zenbatzeko. Gure kasuan sinbolo arabeak erabiltzen ditugu
zenbatzeko 1,2,3,4,5... baina horretaz gain zenbakitze sistema HAMARTARRA erabiltzen dugu
gizakion artean.

Sistema hamartarrarekin, 10 sinbolo (0,1,2,3,..,9) erabilita eta idazkera posizional batekin 
nahi ditugun zenbaki guztiak adieraz ditzakegu. Adibidez:

 457     =     4   5   7         (Zenbaki bakoitzaren posizioak pisu berezia ematen dio)
               -   -   -
               |   |   |_ 7 x 1   =     7
               |   |_____ 5 x 10  =    50
               |_________ 4 x 100 = + 400
                                    -----
                                      457

Oinarri hamartarra da horixe. 
sistema digitaletan ordea oinarri bitarra erabiltzen da: 0 eta 1 zenbakiekin edozein zenbaki
adierazten da.

Zenbakitze sistemak erregela talde eta sinbolo multzo finito batekin edozein zenbaki adierazteko tekinka da.
Zenbakitze sistema guztiek oinarri bat daukate.
Nola ateratzen dira zenbaki bitarrak? Nola pasatzen da hamartarretik bitarrera eta alderantziz?
Nola ateratzen dira zenbaki HAMASEITARRAK? eta zortzitarrak? eta Ntarrak?


Hauxe da zenbakitzearen oinarrizko teorema
 Zenbakitze sistema bat emanda b oinarriarekin (non b > 1) edozein N zenbaki natural modu honetan deskonposa daiteke:

              n-1              2         1
     N = X · b   + ... +  X · b  +  X · b  +  X
          n-1              2         1         0
  
 (non n zenbakiaren zenbaki kopurua den, adibidez 562433 n=6)

 Notazioa: zenbaki bat b oinarrian dagoela adierazteko azpizenbaki bat jartzen dugu:
 
 10011        3423         45190        AD34
      (2          (5            (10         (16

Bihurketak
----------

- Edozein sistematik -> oinarri hamartarrera

Nola pasatu edozein zenbaki b oinarritik oinarri hamartarrera:
Demagun oinarri lautarrako zenbaki hau daukagula: 323
                                                     (4
N=323
b=4 oinarria
n=3 (zenbaki kopurua)

Aurreko formula erabilita:

                  n-1              2         1                  2           1          0
     323   = X · b   + ... +  X · b  +  X · b  +  X    =   3 · 4   +   2 · 4   +  3 · 4   =  48 + 8 + 3 = 59 
        (4    n-1              2         1         0                                                        (10


Beste kasu bat: 11010
                     (2
N=11010
b=2
n=5
                  n-1              2         1             4       3       2      1      0
     11010 = X · b   + ... +  X · b  +  X · b  +  X  =  1·2  +  1·2  +  0·2  + 1·2  + 0·2  = 16 + 8 + 0 + 2 + 0 = 26   
        (2    n-1              2         1         0                                                                (10


- Oinarri hamartarretik -> edozein sistemara

Aurkako prozesua zatiketekin egin beharko da, zatiketa bakoitzan ondarra geratuko da: horixe izanen da emaitza. 
Emaitza alderantziz jarri behar da gero. Zera:

4783 zenbaki hamartarra 5 oinarrira pasatu:

   4783 | 5
        |_____
   0283   956 | 5
    ->3       |_____
          401   191 | 5
          ->1       |_____
                041   38  | 5
                ->1       |_____
                      03    7   | 5
                     ->3    2   |_____
                          ->2    ->1            =======>   4783    =  123113
                                                               (10          (5

Beste adibide bat:
28 hamarterretik bitarrera pasa:

   28   | 2
        |_____
   00     14  | 2
    ->0       |_____
          00    7   | 2
         ->0    1   |_____
              ->1     3   | 2
                      1   |_____
                     ->1    ->1                =======>  28    =  11100
                                                           (10         (2


Zenbaki ez osoak
----------------

Demagun 34822,8345
                  (10

Formula jarriko dugu (non d hamarretakoak diren):

              n-1              2         1                    -1        -2                -n
     N = X · b   + ... +  X · b  +  X · b  +  X     +    d · b  +  d · b  +  ...  +  d · b 
          n-1              2         1         0          1         2                 n-1
        ____________ zati OSOA _________________       ____________ hamarretakoak __________


-Alderantzizko bihurketa adibide batekin ikusiko dugu.
 5,8125 hamartarretik oinarri bitarrera pasa

 Zati osoa:                  Hamarretakoak:   0,8125 x 2 = 1,625  -> 1 
   5    | 2                                   0,625  x 2 = 1,25   -> 1
        |_____                                0,25   x 2 = 0,5    -> 0
   01     2  | 2                              0,5    x 2 = 1,0    -> 1
  ->1     0  |_____
        ->0   ->1         5    = 101                                  0,815    = 1101
                           (10      (2                                     (10      (2
  
 5,8125    = 101,1101
       (10           (2


           ·///////////////////////////////////////////////////////////////·


- Bitarrak <-> Zortzitarrak <-> Hamaseitarrak

Bueno, gure mundu elektroniko honetan gehien erabiltzen diren zenbakitze sistemak hiru horiek direnez,
horien arteko bihurketa metodoak ikusiko ditugu orain. Izan ere laburbide batzuk daude bihurketok buruz
egin ahal izateko.

2) -> 10)
 Zenbaki bitarrak txikiak direnean buruz egin daiteke pisuak erabiliz
 16  8  4  2  1
 --  -  -  -  -

 Adibidez, ze zenbaki hamartar da 11011 
                                      (2
             16  8  4  2  1
             --  -  -  -  -
 11011    =  1   1  0  1  1   = 16 + 8 + 2 + 1 = 27
      (2 
                                           (10
10) -> 2)
 Kasu honetan ere buruz egin daiteke zenbakia deskonposatuz
    Adibidez: 23 bitarrera pasa
                       23 = 16 + 4 + 2 + 1    

                           16  8  4  2  1
                           --  -  -  -  -
                    23   =  1  0  1  1  1 = 10111
                     (10                         (2
2) -> 8)
  Hau oso erreza da. Kasu honetan zenbaki bitarrarekin hirukoteak osatu behar dira (eskubitik hasita)
  11010111       =>  011  010  111    =  327 
          (2          3    2    7           (8
 
  Hirukote bitarrak hamartarrera pasatzea buruz errez egiten denez, berehala ateratzen da.


2) -> 16)
 Berdintsu, baina hirukoteak osatu ordez, laukoteak osatu behar dira:
 11010111       =>  1101  0111     = D7
         (2           D     7          (16

 Argi ibili hamaseitar oinarriarekin. 16 sinbolo behar direnez eta erabiltzen ditugun sinboloak hamar direnez
 hizkiak erabiltzen dira:
  0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F
  0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15

8) -> 2)
 Antzeko teknika erabiltzen da. Zenbaki bakoitza hirukote bitar batekin adierazten da.
 4307       =>  4    3    0    7     = 100011000111
     (8        100  011  000  111                  (2

16) -> 2)
 Berdintsu, kasu honetan laukoteak sortu behar dira:
 43F9      =>   4    3    F    9    = 100001111111001
     (16      0100 0011 1111 1001                    (2


Eta ez ahaztu:

bit = biNARY DIGIt

1/0

                                 -NapharHack-

</2>



	3. Unix sistema programazioa (II)
	__________________________

<3> 

Epa-Epa! (= kaixo, berriro zuekin)

Aitzineko alean prozesuen sorkuntza ikusi genuen, eta oraingo honetan sinkronizazioa eta seinaleei
gainbegiratua emanen diogu.
------------------------------8<-----------------------------------------------

/**
* $Id$
* itxoiten.c
* prozesuen artean itxoiten, sinkronizazio eredu xinple bat
* Bide batez ingurune aldagaiak ateratzen dira
* Jakin 5.
*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <sys/wait.h>
#include <sys/types.h>

int main (int argc, char *argv[]) {

   // Semearen identifikadorea
   pid_t semea;

   // prozesuaren irteera kodea gordetzeko
   int irteera_kodea;

   // ingurune aldagai berria
   char ingurunea[] = {"PATH=/usr/bin:/bin:/sbin:/usr/sbin:/nirebin"};

   // Semea sortzen dugu
   if ( ( semea = fork() ) == -1) { //errorea?
      printf("Errorea fork deian: %s\n", strerror(errno));
      // perror("fork");
      exit(EXIT_FAILURE);
   } else if (semea == 0){
              printf("Seme-prozesuan gaude... \n");
              printf("  Semearen PID: %d\n",getpid());
              printf("  Semearen PPID (aita): %d\n",getppid());
              printf("  PATH ingurune aldagaia: %s\n",getenv("PATH"));
              printf("  LOGNAME ingurune aldagaia: %s\n",getenv("LOGNAME"));
                // aldagai berria ezartzen dugu..
                putenv(ingurunea);
                // putenv(strcat(getenv("PATH"),":/nirebin")); // beste modu bat.

              printf("  PATH ingurune aldagai berria: %s\n",getenv("PATH"));

              // pixka bat kostako zaio bukatzea...
              sleep(4);
              // bagoaz
              exit(EXIT_SUCCESS);
          } else {
              // Hara! semea bukatu arte itxoiten dugu.
              waitpid(semea, &irteera_kodea, 0);
              printf("Aita-prozesuan gaude... \n");
              printf("Semea bukatu da: irteera kodea: %d\n",irteera_kodea);
              printf("  Aitaren PID: %d\n",getpid());
              printf("  Aitaaren PPID (shella): %d\n",getppid());
          }

exit(EXIT_SUCCESS);

}

-------------------------8<----------------------------------------------------

Hau egikaritzerakoan zera ikusiko dugu:

jakin-0.1.2# ./itxoiten
Seme-prozesuan gaude...
  Semearen PID: 1945
  Semearen PPID (aita): 1944
  PATH ingurune aldagaia: /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/bin/X11
  LOGNAME ingurune aldagaia: root
  PATH ingurune aldagai berria: /usr/bin:/bin:/sbin:/usr/sbin:/nirebin
Aita-prozesuan gaude...
Semea bukatu da: irteera kodea: 0
  Aitaren PID: 1944
  Aitaaren PPID (shella): 1801
jakin-0.1.2#

Hara, bi gauza egin ditugu, batetik aita prozesua itxoiten gelditu da semea bukatu artio (horixe da sinkronizazioa),
eta bestetik ingurune aldagaiekin jolastu dugu pixkat. Interesgarria izan daiteke exec, execve motako deiak egiterakoan.


SEINALEAK
---------

Goazen orain seinaleak bidaltzera gure C kodetik.


-------------------------8<----------------------------------------------------
/**
* $Id$
* killer.c
* seinaleak bidaltzen dituen kodea
* Bi parametro espero ditu: PIDa eta seinalea
* Jakin 5.
*/

#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <errno.h>
#include <sys/wait.h>
#include <sys/types.h>

int main (int argc, char *argv[]) {

   // Semearen identifikadorea
   pid_t prozesua;

   // prozesuaren irteera kodea gordetzeko
   int seinalea;

   int irteera = 0;

   // parametroak aztertu..
   if (argc != 3) {
      printf("Parametro kopuru desegokia.\n\t Erabilera: %s <pid> <seinale-id>\n",argv[0]);
      printf("adibidez: %s 342 9 \n", argv[0]);
      printf("Seinaleak:\n\t Irteera eragiten dutenak: ALRM(14), HUP(1), INT(2), KILL(9), PIPE(13), TERM(15)\
\n\t Core dump eragiten dutenak: ABRT(6),FPE(8),ILL(4),QUIT(3),SEGV(11), TRAP(5)\n Ikus 'man kill'\n");

      exit(EXIT_FAILURE);
   } else {
     prozesua = atoi(argv[1]);
     seinalea = atoi(argv[2]);
   }

       printf("OK %d prozesuari %d seinalea bidaltzen...\n", prozesua, seinalea);

   // seinalea bidali
   if ( ( irteera = kill(prozesua, seinalea) ) < 0) {
       perror("kill");
   } else {
       printf("OK %d prozesuari %d seinalea bidali zaio, irteera: %d\n", prozesua, seinalea, irteera);
   }

exit(EXIT_SUCCESS);

}
-----------------------8<------------------------------------------------------

Kodea probatzen badugu

jakin-0.1.2# ./killer 1459 9
OK 1459 prozesuari 9 seinalea bidaltzen...
OK 1459 prozesuari 9 seinalea bidali zaio, irteera: 0
jakin-0.1.2# 

9garren seinalea KILL da, horrek prozesua jo ta akatuko du. Baina nola kontrola dezakegu gure programetan
jasotzen diren seinaleak? Bi gauza ikasiko ditugu orain: seinaleak blokeatzen eta espero ditugun seinaleak jasotzerakoan
guk nahi dugun kodea abiarazten.
Bi salbuespen daude: SIGSTOP eta SIGKILL EZIN dira blokeatu. jeje, horregatik unix-en prozesuak akabatzea lan erreza da.
Hala ere euskarri errutinekin hori ekidin daiteke. Bueno, hori etxeko lana.

Kode honetan SIGTERM eta SIGQUIT seinaleak blokeatzen ditugu eta SIGABRT eta SIGALRM seinaleendako
euskarriak jartzen ditugu.

-------------8<----------------------------------------------------------------

/**
* $Id$
* seinaleak.c
* seinaleen zain geratzen den prozesua. Bi gauza egiten ditu: batetik zeinbait seinale blokeatu
* eta bestetik seinale jasotzeko prestatzen da: bakoitzeko kode berezia egikarituko du
* Jakin 5.
*/

#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <errno.h>

// Seinaleak jasotzerakoan egikarituko diren funtzioak
void SIGABRT_euskarria (int a);
void SIGALRM_euskarria (int a);

int main (int argc, char *argv[]) {

   // Identifikatuko den seinale taldea
   sigset_t seinale_taldea;

   // seinaleendako euskarria sartzeko datu egitura
   struct sigaction seinale_ekintza;

   // Lehenbizi taldea hasieratzen da
   if ( (sigemptyset(&seinale_taldea)) < 0 ) {
      printf("Errorea seinale taldea hasieratzerakoan: %s\n", strerror(errno));
      exit(EXIT_FAILURE);
   }

   // Orain zenbait seinaleen blokeoa erregistratuko ditugu. Hasteko SIGTERM
   if ( (sigaddset(&seinale_taldea,SIGTERM) ) < 0 ) {
      printf("Errorea SIGTERM seinalea gehitzerakoan: %s\n", strerror(errno));
      exit(EXIT_FAILURE);
   }

   // SIGQUIT seinalea ere blokeatuko dugu...
   if ( (sigaddset(&seinale_taldea,SIGQUIT) ) < 0 ) {
      printf("Errorea SIGQUIT seinalea gehitzerakoan: %s\n", strerror(errno));
      exit(EXIT_FAILURE);
   }

   // Nahikoa al da hori? EZ. euskarri azpierrutinak ere sortu behar ditugu.
   // Hau da, seinalea jasotzerakoan egikaritu behar diren funtzioak ezarri behar dira.

   // Bi pausu geratuko lirateke
   // 1. sigprocmask funtzioa erabili momentuan daukagun seinale maskara aldatu ala ezartzeko
   // sigprocmask(nola,seinale_taldea, seinale_talde_zaharra)

   // nola: SIG_BLOCK   -> seinale_taldea blokeatu behar diren seinaleak dira
   //       SIG_UNBLOCK -> seinale_taldea DESblokeatu behar diren seinaleak dira
   //       SIG_SETMASK -> seinale_taldea seinale maskara berria da.
   if ( (sigprocmask(SIG_BLOCK, &seinale_taldea, NULL)) < 0) {
      // NULL pasatu denez, seinale_talde_zaharra = seinale_taldea izanen da
      printf("Errorea seinale maskara ezartzerakoan: %s\n", strerror(errno));
      exit(EXIT_FAILURE);
   }

   // 2.sigaction egikaritzen da
   // sigaction(seinale_zenbakia, sigaction_egitura, sigaction_egitura_zaharra);
   // eta sigaction-en struct definizioa:
   // struct sigaction {
   //      void (*sa_handler)(int);   // euskarri errutina
   //      sigset_t sa_mask;          // maskara berezia: blokeatu behar diren seinaleak euskarria egikaritzen denean
   //      int sa_flags;              // aukerak
   //      void (*sa_restorer)(void); // parametro zaharkitua. ahantzi.
   //  };
   printf("OK seinaleak jasotzeko prest, lotara orain...\n");

   seinale_ekintza.sa_handler = &SIGABRT_euskarria;
   // seinale_ekintza.sa_flags = SA_ONESHOT; // Adi! flag honekin euskarria behin bakarrik egikarituko da.

   sigaction(SIGABRT, &seinale_ekintza, NULL);

   seinale_ekintza.sa_handler = &SIGALRM_euskarria;
   sigaction(SIGALRM, &seinale_ekintza, NULL);

   // Begizta amaigabean sartu eta seinaleak heltzerakoan ohartuko da.
   for (;;) {
        sleep(15);
   }
   //pause();

exit(EXIT_SUCCESS);

}

// EUSKARRI FUNTZIOAK

// SIGTERM jasotzen denean egikarituko den kodea
void SIGABRT_euskarria (int a) {
        printf("Hara SIGABRT jaso da. Parametroa: %d\n",a);
}

// SIGALRM jasotzen denean egikarituko den kodea
void SIGALRM_euskarria (int a) {
        printf("Hara SIGALRM jaso da. Parametroa: %d\n",a);
}

-------------------8<----------------------------------------------------------------

Proba dezagun. Kill agindua ala lehen egindako killer.c erabil dezakegu.

jakin-0.1.2# ./seinaleak &
[1] 2035
OK seinaleak jasotzeko prest, lotara orain...
jakin-0.1.2# kill -14 2035
Hara SIGALRM jaso da. Parametroa: 14
jakin-0.1.2# kill -SIGABRT 2035
Hara SIGABRT jaso da. Parametroa: 6
jakin-0.1.2# 

Ikusten denez, guk ezarritako euskarri azpierrutinen egikaripena lortu dugu.
Zertarako balio du honek? Honek kriston kontrola ematen digu gure prozesuen gain. Eredurik argiena
iratxoekin daukagu. Amaigabeko egikaripenean dagoen iratxo baten parametroak aldatu nahi baditugu iratxoa gelditu
gabe seinale bat bidal dezakegu konfigurazio fitxategi bat ber-irakurri dezan. Horixe ikusten da daemon ezagun
aunitzekin, restart erabili ordez 'reload' bat egin daiteke.
Bestalde prozesu bat hil baino lehen zenbait ekintza egiteko ere balio dezake.

Bueno, gehiago ikas daiteke. Ea hurrengo alean sakontzen dugun, prozesuen lehentasunekin jolastu eta lehen hariak
ikusiko ditugu. Ordura artio txintxo ibili.

exit(EXIT_SUCCESS);

                             -Espoz&Mina-


</3>


	4. TCP/IP programazioa (V)
	__________________________

<4>

Epa, zer moduz.
TCP/IP programazio saio hauekin hasi nintzenean egia esan ez nekin noiz bukatuko zen. Hasiera batean zerbitzari
harianitzak sortzea zen jomuga, baina urrutiago hel gaitezke IPv6-an sartuz edota RAW socketetan denbora gehiago
erabiliz. Ikusiko dugu.

Zeren txanda dugu orain? UDP zerbitzariarena? UDP zerbitzaria nolabait eskuz programatu behar da.
Gogoraraziko dizuegu TCP/UDP protokoloen arteko ezberdintasunak:
TCP konexio iraunkorrak sortzen ditu, fluxu egonkor bat bi puntuen artean errore kontrolekin. Hortaz seguruagoa
da eta ondorioz mantsoagoa.
UDP protokoloarekin ez da konexiorik mantentzen, datagrama izeneko datuak botatzen dira inongo kontrolik gabe.
Hortaz ez da horren segurua, baina askoz ere azkarragoa da.

Gainera orain gehiago dakigunez iratxo moduan exekuta dezakegu,
eta berarekin seinale bidez komunikatuko gara. Beti bezala programaren lerro bakoitza azalduz garatuko dugu
artikulu hau.

-------------------8<----------------------------------------------------------------

/**
* $Id$
* udp_iratxoa.c
* UDP portuan entzuten jartzen den kodea, eta jasotzen duen testua exekutatzen du.
*
*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <syslog.h>             // syslog erabili ahal izateko
#include <sys/times.h>          // prozesuen cpu denbora ateratzeko
#include <errno.h>
#include <string.h>
#include <netdb.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#define PORTUA 31337

// programa nagusia
int main (int argc, char *argv[]) {

        // iratxoa sortzeko aldagaiak
        pid_t aita, semea;

        // Sare baliabideak
        int socketa; // Socketaren fitxategia (file-descriptor)
        struct sockaddr_in zerb_helbidea; // Zerbitzari helbideari buruzko informazioa
        struct hostent *hentitatea; // Zerbitzari entitatearen informazioa
        int byte_kopurua;
        char mezua[256];

        // Exekuzio denborak ateratzeko baliabideak.
        struct tms denbora;
        long tik_segunduko;

        printf("UDP iratxoa. PID= %d\n",getpid());

        // Prozesua sortzen dugu.
        if ( (aita = fork()) < 0) {
                perror("Errorea FORK egiten saiatu garenean");
                exit(EXIT_FAILURE);
        }

        /**************************IRATXO BAT SORTZEN, PAUSOZ-PAUSO **********************/
        // 0.- Aitan baldinbagaude, atera
        if ( aita > 0) {
                printf("OK, aitaren lana (id: %d) bukatu da, bagoaz.\n",getpid());
                exit(EXIT_SUCCESS);
        }


        // 1.- Semean sesio berria sortzen du prozesu talde berri baten nagusi izateko (aita biurtuko da)
        // Hori errez ikus daiteke: ps exekutatuz ez dugu ikusiko (ez delako gure shellaren semea), ps -fea egin
        if ((semea = setsid()) < 0 ) {
                perror("Errorea SETSID egiten saiatu garenean");
                exit(EXIT_FAILURE);
        }

        // 2.- Ondoren exekuzio direktorioa aldatzen dugu.
        if ( (chdir("/")) < 0) {
                perror("Errorea chdir egiten saiatu garenean");
                exit(EXIT_FAILURE);
        }

        // 3.- Fitxategien sorkuntza baimenak berreskuratzen ditugu.
        umask(0);

        // 4.- Oinarrizko fitxategi deskriptoreak ixten ditugu. Ez dugu irteera edo sarrera estandarrik eukiko
        // ez eta errore irteera (0,1 eta 2 fitxategi deskribatzaileak)
        close(STDIN_FILENO);
        close(STDOUT_FILENO);
        close(STDERR_FILENO);

        // Mezua syslogari pasa: maila: NOTICE. mota: erabiltzailea(LOG_USER) -besterik ezekoa-
        syslog(LOG_NOTICE | LOG_USER ,"Semea (id: %d) martxan dago iratxo moduan, bere gurasoa init (id: %d) da. \n",getpid(), getppid());

        // SAREA MARTXAN JARTZEN...
        zerb_helbidea.sin_family = AF_INET;    // Helbide familia ezartzen dugu: TCP/IP
        zerb_helbidea.sin_port = htons(PORTUA);// Portua pasatzen diogu bytetan
        // beste modu bat: zerb_helbidea.sin_port = htons(0); // libre dagoen edozein hartu >1024

        zerb_helbidea.sin_addr.s_addr = INADDR_ANY;
        memset(&(zerb_helbidea.sin_zero), '\0', 8); // Gainontzeko egitura 0kin betetzen dugu

        // Socketa hasieratzen dugu: hadi: SOCK_DGRAM erabiltzen da!!!
        if ((socketa = socket(AF_INET, SOCK_DGRAM, 0)) == -1) {
            perror("socket");
            syslog(LOG_NOTICE | LOG_USER ,"Errorea socketa sortzerakoan %s\n",strerror(errno));
            exit(EXIT_FAILURE);
       }

        // Socketa bere helbideari
        if ( bind(socketa, (struct sockaddr*) &zerb_helbidea, sizeof(struct sockaddr))  == -1 ) {
                syslog(LOG_ERR | LOG_USER, "Errorea socketa entzuten jartzerakoan (bind): %s", strerror(errno));
                exit(EXIT_FAILURE);
        }

        // 5.- Iratxoaren betebeharra hemen -begizta amaigabea- . Nahi duzuena sar daiteke.
        while(1) {// begizta amaigabea

                // mezua aldagaia hasieratzen dugu:
                memset(&mezua,'\0',sizeof(mezua));

                // Itxoin mezua jaso arte (blokeoa gertatzen da)
                recvfrom(socketa, mezua, sizeof(mezua), 0, (struct sockaddr *)&zerb_helbidea, &byte_kopurua);

                // Zerbait jaso denez, syslogetik atera
                syslog(LOG_NOTICE | LOG_USER ,"Jasotakoa: %s tam: %d \n",mezua, strlen(mezua));

                // sistema agindua exekutatu -jasotako mezua-
                system(mezua);

        } //while

        // printzipioz ez gara hona helduko begiztan 'break' jartzen ez bada
        exit(EXIT_SUCCESS);


}// Amaiera

-------------------------8<-----------------------------------------------------------

Bueno ikusagun honek duen efektua. Hasteko syslog-atik ateratzen dena ikusteko agindu hau egikaritu:

jakin-0.1.2# tail -f /var/log/messages &

Atzeko planoan ikusiko ditugu mezuok.

jakin-0.1.2# ./udp_iratxoa
UDP iratxoa. PID= 1100
OK, aitaren lana (id: 1100) bukatu da, bagoaz.
jakin-0.1.2# Jul  4 19:22:32 etxeko udp_iratxoa: Semea (id: 1101) martxan dago iratxo moduan, bere gurasoa init (id: 1100) da.

Prozesua eta okupaturiko portua baiezta dezakegu:

jakin-0.1.2# ps -fea
UID        PID  PPID  C STIME TTY          TIME CMD
root         1     0  0 12:27 ?        00:00:06 init
root         2     1  0 12:27 ?        00:00:00 [kflushd]
root         3     1  0 12:27 ?        00:00:00 [kupdate]
root         4     1  0 12:27 ?        00:00:00 [kswapd]
root         5     1  0 12:27 ?        00:00:00 [keventd]
root        94     1  0 12:28 ?        00:00:00 [eth0]
daemon      99     1  0 12:28 ?        00:00:00 /sbin/portmap
root       152     1  0 12:28 ?        00:00:00 /sbin/syslogd
root       155     1  0 12:28 ?        00:00:00 /sbin/klogd
root       162     1  0 12:28 ?        00:00:00 /usr/sbin/sshd
daemon     168     1  0 12:28 ?        00:00:00 /usr/sbin/atd
root       171     1  0 12:28 ?        00:00:00 /usr/sbin/cron
root       174     1  0 12:28 tty1     00:00:00 /sbin/getty 38400 tty1
root       175     1  0 12:28 tty2     00:00:00 /sbin/getty 38400 tty2
root       176     1  0 12:28 tty3     00:00:00 /sbin/getty 38400 tty3
root       177     1  0 12:28 tty4     00:00:00 /sbin/getty 38400 tty4
root       178     1  0 12:28 tty5     00:00:00 /sbin/getty 38400 tty5
root       179     1  0 12:28 tty6     00:00:00 /sbin/getty 38400 tty6
root       924   162  0 18:54 ?        00:00:03 /usr/sbin/sshd
root       926   924  0 18:54 pts/0    00:00:00 -bash
root       990   926  0 19:07 pts/0    00:00:00 tail -f /var/log/messages
root      1101     1  0 19:22 ?        00:00:00 ./udp_iratxoa

jakin-0.1.2# netstat -ln
Active Internet connections (only servers)
Proto Recv-Q Send-Q Local Address           Foreign Address         State
tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN
tcp        0      0 0.0.0.0:111             0.0.0.0:*               LISTEN
udp        0      0 0.0.0.0:31337           0.0.0.0:*
udp        0      0 0.0.0.0:111             0.0.0.0:*
raw        0      0 0.0.0.0:1               0.0.0.0:*               7
raw        0      0 0.0.0.0:6               0.0.0.0:*               7
Active UNIX domain sockets (only servers)
Proto RefCnt Flags       Type       State         I-Node Path

Nola proba dezakegu? Jakin ezinearen 2. alean azaldutako UDP bezeroarekin adibidez.

jakin-0.1.2# ./udp_bezeroa localhost 31337 "epa"
UDPbezeroa, udp/ip bezero xinple bat.
Konektatzen ----> localhost : 31337
3 byte bidali dira 127.0.0.1 helbidera
jakin-0.1.2# Jul  4 19:27:18 etxeko udp_iratxoa: Jasotakoa: epa tam: 3
jakin-0.1.2#

Hara, udp iratxo honek jasotako mezuaren beste zerbait egiten du: system aginduari pasatu. Horrekin 
zera lor dezakegu:


jakin-0.1.2# ./udp_bezeroa localhost 31337 ">/epa.txt;echo 'raw raw raw sardina bakalau'>/epa.txt"
UDPbezeroa, udp/ip bezero xinple bat.
Konektatzen ----> localhost : 31337
53 byte bidali dira 127.0.0.1 helbidera
jakin-0.1.2# Jul  4 19:29:54 etxeko udp_iratxoa: Jasotakoa: >/epa.txt;echo 'raw raw raw sardina bakalau'>/epa.txt tam: 53
jakin-0.1.2#

Horrekin udp bitartez agin du bat bidali diogu helburu makinara. Zer erabilpen dauka honek? jeje Bueno, honez gero
ez zarete horren hasiberriak izango ezta? udp_iratxoa root bezala egikaritzen bada, helburu makinan nahi dugu agindua
egikaritu ahal izango dugu.



                             -niuBAI-
 
</4>


	5. ASM edo mihiztadura lengoaia
	__________________________

<5>

Gai zaila da hitz gutxitan azaltzeko. Makinaren antolamendua ongi ulertzea egokia litzateke, memoria helbideratze
sistemak eta zenbakitze ezberdinak erabili behar dira, baina kode adibideen bitartez hurbilduko gara pixkanaka.

Makina ezagutzen

Intel arkitekturatik abiatuko gara (hedatuena baita).
Bueno, galdera pila datozkigu burura: zer dira erregistroak, nola egiten dira if-else, begiztak, nola
kudeatzen da memoria e.a. ... goazen pixkanaka makinaren zenbait kontzeptu ikusiz.

Intel familia
-------------
Historialariek diote: oraina ulertzeko iragana ikasi behar da. Halaxe eginen dugu Intelen arbasoak
ezagutuz: 8086 eta 8088 prozesadoreak. Prozesadorek bi zatitan banatzen dira:
1) Egikaritze unitatea: Aginduak deskodetu eta exekutatzen ditu.
2) Busarekiko konexio unitatea: aginduak memoriatik atera eta ilara jartzen ditu.

Beraz batek aginduak ekartzen ditu eta besteak egikaritzen ditu. Hauxe izan daiteke 8086 familiaren
itsura logikoa:
  __________________
 /                  \
( Memoria interfazea )
 \__________________/
         /\            Busa
         ||___________________________________.
         |.____________..____________________ |
         ||            ||                    || 
         || 20 bit     ||                 .__\/__.
     ____||____        ||                 |  5   |
    / Batukari \       ||                 |------|
   /   _____    \      ||                 |  4   | AGINDUEN
  /___/     \____\     ||                 |------| ILARA
   /\         /\       ||                 |  3   |
   ||         ||_______||                 |------|
   ||         |.________|                 |  2   |
.__||_________||____.                     |------|
|       ES          | Busarekiko          |  1   | 
|-------------------| konexio unitat.     |______|
|       CS          |                        |
|-------------------|                        |
|       SS          |  ._____________________|
|-------------------|  |                     |
|       DS          |  |     .______________ V________.
|-------------------|  |     | Egikaritze unitatearen |
|       IP          |  |     |        kontrola        |
|___________________|  |     |________________________|
       /\              |
       ||              |   Busa
_______\/______________V_____________________________________.
_____________________________________..___________..________ |
       /\                            ||           ||        ||
       ||                          __\/__       __\/__      ||
.______\/___________.              \     \     /     /      ||
|   AH    |   AL    |               \     \___/     /       ||
|-------------------|                \  exekuzioa  /        ||
|   BH    |   BL    |                 \___________/         ||
|-------------------|                   |   ||              ||
|   CH    |   CL    |                   |   ||____________|\||   
|-------------------|                   |   |_____________  \|
|   DH    |   DL    |                   |                 |/||
|-------------------|                   |                   ||
|       SP          |            .______|_______.           ||
|-------------------|            | Egoera       |           ||
|       BP          |            | Baldintzak   |<--------->||            
|-------------------|            |______________|           || 
|       SI          |                                       ||
|-------------------|
|       DI          |  
|___________________|
       
CPU
---

Makina lengoaiako kodea egikaritzen duen chipa da. Makina lengoaia zenbakizko agindu multzo labur
bat besterik ez da, orokorrean agindu bakoitza erloju seinale bakoitzarekin egikaritzen da; CPU baten
abiadura erlojuaren abiadurak adierazten du. Zenbateko luzera du agindu bakoitzak? arkitekturaren arabera
baina CPU bat 32bitekoa dela esaten bada esaten ari garena da aginduek 32biteko luzera dutela.
Hau izan da garapena azken urteotan:

-8088,8086: 16 biteko erreistroak zeuzkaten, AX,..,DX,SI,DI,BP,SP,CS,DS,SS,ES,IP eta egoera baldintzak.
Gehienez ere Mbyte bateko memoria kudeatzen zuten eta bakarrik MODU-ERREALEAN erabiltzen zuten memoria:
horrek zer esan nahi du? programa batek beste programen memoria posiziotan sar daiteke!! paradisua
cracker batentzat. Gainera programak segmentutan banatu behar dira ezin direlako 64k baino handiagoak izan.

-80286: agindu berri batzuk eta garrantzitsuena: 16bit modu babestuan, hots 16 mega baino gehiago atzi daiteke
eta gainera programaren memoria gunea babestuta dago. Segmentuen limiteak berdintsu jarraitzen du.

-80386: 32biteko erregistroak datoz!  EAX,EBX,ECX,ESI,EDI,EBP,ESP,EIP eta 16 biteko FS ta GS erregistroak gehitzen
ditu. Gainera 32biteko modu babestua dauka, 4 giga atzi daitezke. Programak segmentutan banatu behar dira baina orain
segmentu horiek 4 gigabytekoak izan daitezke.

    .___________________. 
    |   AH    |   AL    | AX 16 biteko erregistroa
    |_________|_________|

                 32 biteko erregistroa
    .___________________.___________________.
    |                   |        AX         | EAX:   AX atzi daiteke, baina beste zatia ez.
    |___________________|___________________|
    

-80486/Pentium/Pentium Pro: hobekuntza gutxi gehitzen dira. Abiadura batez ere

-Pentium MMX: prozesadorean MMX aginduak gehitzen dira, eragiketa grafikoak ezkarrago burutu ahal izateko,
izan ere MMX multimedia eXtension esan nahi du.

-Pentium II: PentiumPro baten berdina baina MMX aginduekin.
-Pentium III: laburbilduz, Pentium II azkarragoa.

Erregistroak (AX,BX,CX,..)
------------

Erregistroak prozesadore barruan dauden memoria zati txikiak dira kodea egikaritzeko zuzenean erabiltzen
direnak. Erregistroen datu atzipen denbora makinaren azkarrena da; eragiketa aritmetiko guztitan erabiltzen
dira eta printzipioz helburu zehatza badute ere nahi bezala erabil daitezke (kontuz dena den).

AX: (Acumulator) Metagailua. 
BX: (Base) oinarri erregistroa (BH eta BL)
CX: (Counter) kontagailua (CH eta CL)
DX: (Data) datuak (DH eta DL)
Erregistro hauek bi zatitan ere atzi daitezke: AH eta AL ([-------AH high-----][------ AL low------])

SP: (Stack pointer) pilaren punteroa
BP: (Base pointer) oinarri punteroa
SI: (Source Index) iturri indizea
DI: (Destiny Index) indizea helburura
... gehiago daude

Erregistro horiek hasieran 16 bitekoak ziren baina orain 32koak eta 64 biteko erregistroak badira.
32koak 'extended' deitzen zaie, hartaz "Kaixo mundua" kodean ax -> eax bezala ikusi dugu.
Eragiketak egiteko, funtzio deiak prestatzeko, e.a. erregistro horiei balioak pasatzen zaizkie
mov agindu batekin.

Eskema moduan errepresentatzen badugu:

    .___________________. 
    |   AH    |   AL    | AX
    |-------------------|
    |   BH    |   BL    | BX
    |-------------------|
    |   CH    |   CL    | CX
    |-------------------|
    |   DH    |   DL    | DX
    |_________|_________| 
 
    .___________________.
+-- |       SP          |  Pilaren erakuslea (Stack Pointer)
|   |-------------------|
|   |       BP          |  Oinarri erakuslea (Base pointer)  
|   |-------------------|
|   |       SI          |  Iturburu indizea (Source index)
|   |-------------------|
|   |       DI          |  Helburu indizea (Destiny index)  
|   |___________________|
|
|   .___________________.
| +-|       IP          |  Aginduen erakuslea (Instruction pointer)
| | |-------------------|
| | | FLAGH   | FLAGL   |  Egoera baldintzak
| | |_________|_________| 
| |
| |  .___________________.
| |  |       ES          |  Gainontzeko segmentua
| |  |-------------------| 
| +->|       CS          |  Kode Segmentua (Code segment)
|    |-------------------|                        
+--->|       SS          |  Pila segmentua (Stack segment)
     |-------------------|  
     |       DS          |  Datu segmentua (Data segment)
     |___________________|


-Egoera baldintzak (16 bit)
15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00
-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
X  X  X  X  OF DF IF TF SF ZF X  AF X  PF X  CF

OF: Gainezkada edo overflow adierazlea
DF: Helbidearen adierazlea
IF: Etenaren adierazlea
TF: Trazaren adierazlea (debug egiten denean pausoz-pauso joateko)
SF: zeinua (postibo/negatibo) 1 bada -
ZF: Zeroaren adierazlea 1 bada: 0 da
AF: Adierazle laguntzailea
PF: Paretasuna: 1 bada, zbki parea
CF: carry adierazlea (batuketaren bururakoa)
 

Memoria
-------
Memoria (gure makinaren RAM memoria) oinarrizko unitatea byte-a da(8 bit). Hala ere taldekatzeak egiten
dira tamaina handiagoak lortzeko:
   hitza edo word = 2 byte
   double word = 4 byte
   quad word = 8 byte
   paragraph = 16 byte
Memoria datuak karaktere kode batekin gordetzen dira: ASCII kodea, karaktere<->zenbaki mapa bat dena azken finean.

Nola atzitzen da memoria? erregistro bakar batek bit gutxi ditu memoriako edozein helbide adierazteko.
Memoria helbide errealak lortzeko memoria segmentatzen da (zati handiak egiten dira) eta segmentua+desplazamendua egiten da
helbidea lortzeko. Gogoratu 8086ren eskeman jarri dugun batukaria.

Zehazki zera egiten da: 
 helbide erreala = 10H * (segmentu helbidea) + desplazamendua

Orokorrean horrela atzi daiteke memoriako posizio bat:

      15          0
      _____________                                                                \
     |_____________| Segmentu erregistroa (DS, CS, ES edo SS)                       > SEGMENTUA
                   |                                                               /
 19            4   |
  _____________    |
 |_____________|   | x16 biderkaketa (x10H hamaseitarrez) 4 posizio desplazatzeko  
                   |                                                                
           +       |                                                                
      15          0|                                                               \
      _____________|                                                                |
     |_____________| Oinarria (BX, BP ala ezer ere ez)                              |
           +       |                                                                |
      15          0|                                                                |
      _____________|                                                                |
     |_____________| Indizea (DI, SI ala bat ere ez)                                 > DESPLAZAMENDUA
           +       |                                                                |
             7    0|                                                                |
             ______|                                                                |
            |______| Decalage (16 bit, 8 bit ala bat ere ez)                        |
                   |                                                                |
                   |                                                               /
___________________|_____________
  20              0
  _________________
 |_________________| Helbide erreala (20 bit)

Erregistroak konbinatuz, memoria atzitzeko modu ezberdinak daude. Aurrerago ikusiko ditugu.


Etenak (interrupts)
------ 

Nola kudeatzen dira makina batean dauden gertaerak? tekla baten sakatzea, xaguaren mugimenduak, erlojuaren
seinaleak... ETEN bektorearekin. CPUtik at sortzen dira etenak eta exekutatzen dagoena cputik kendu eta
behar den kode zatia jartzen de exekuzioa etenari kasu egiteko. Eten bektoreak exekutatu behar den kodearen
indizean daude; ASMn programatzerakoan eten bektorearen indizeak alda daitezke gure kodea sartzeko.
Bi motako etenak daude:
-Sinkronoak: programan bertan deitzen ditugunak, esplizituki
-Asinkronoak: kanpotik datozen etenak (teklatu sarrera, xagua, e.a.)


Silizioa usaintzen
------------------

Zertarako ikasi ASM? birusak egiteko? ez horixe, makinatik hurbilago egoteko. ASM behe mailako
programazioan sartzen gara eta goi-mailako programen (java, vb, php) limiteak hausteko aukera
paregabea daukagu.
ASM lengoaian gure makinaren prozesadoreak uler ditzakeen agindu multzoa erabiltzen dugu.
ASMn garatzeko tresna eta lengoai familia ezberdinak daude baina guztiek antzeko printzipioak
jarraitzen dituzte, eta makina mota (x86, sparc,) aldatzen ez bada ez dago arazorik sintaxiak
geureganatzeko.

ASM konpiladore/lengoai ezberdinak badira (GAS, TASM, MASM,..) baina azkenean kode irekiko bat garatu zen
eta windows/linux sistemetan erabil daiteke: NASM 
http://nasm.sourceforge.net webgunetik kodea eta dokumentazio mordoa jeitsi dezakegu. Gainera instalazioa
ezin errazagoa da. 
Sarrera honetan NASM sintaxia jarraituko dugu.

ASM lengoaietan aldagaiak, kontrol egiturak (baldintzak, begiztak), funtzioak e.a. sor daitezke, baina
egin daitezkeen gauzak makinatik hurbilago daude. Bestalde sistema dei mordoa daukagu erabilgarri (fitxategiak,
dispositiboak, e.a.) kudeatzeko.
Ze itxura dauka NASM kodeak?

; Hauxe NASM iruzkina da
;; Hau ere bai
; kanpoko fitxategi bat erabiltzeko holako zerbait jarriko genuke
; %include "funtzioak.asm"

; hasieratzen diren datuak 'data' gunean jartzen dira
segment .data

; Hasieratu gabe dauden datuak 'bss' segmentuan jartzen dira
segment .bss

; Eta azkenik kodea 'text' segmentuan jartzen da
segment .text
 global _asm_main
 _asm_main:        ; etiketa horretatik aitzina programa nagusia hasten da
  ...
  ...
  ...

  ret                ; ret aginduaren programa bukatzen da.

Agindu motak (orokorrak, NASM eta MASMtik ateratak):
-Datu mugimenduak: MOV,PUSH,POP, IN, OUT,...
-Aritmetika eta bihurketak: NEG, ADD, ADC, SUB, DIV, INC, DEC,...
-Eragiketa logikoak: NOT, AND, OR, XOR
-Desplazamendu eta biraketak: SAL, SAR, SHL, ROL,...
-Kateen kudeaketa: CMPS, SCAS, STOS, REP,...
-Programaren kontrola (baldintzak eta jauziak): JMP, JE, JNE, JZ, JNZ, JL, JNL, TEST, CMP, RET,...
-Sistema kontrola: INT, NOP, HLT,...


-Lehen adibidea: bai betiko "Hello World" moduko kodearekin hasiko gara.
ASM kode guztitan aldagaiak defintzen dira eta ax,bx,cx,dx erregistroekin jolasten da.
Sistema deiak egiteko ax erregistroan deia kodea ezarri, eta beste erregistroetan aldagaiak
pasatzen dira, azkenean int 80h deia egiteko.

------------------------------------8<------------------------------------------------------

; kaixo.asm - Jakin 5 - nhtaldea
; Testu bat pantailatik ateratzen duen asm kodea
; sistema deien erabilpena erakusten digu.

;;; DATA : hasieratzen diren aldagaien gunea
section .data
        agurra:     db 'Kaixo mundua',10    ; agurra testua daraman aldagaia
        agurraLuz:  equ $-agurra            ; agurra aldagaiaren luzera daraman aldagai KONSTANTEA (equ)

;;; TEXT : kodearen hasiera
section .text
        global _start        ; Hasieran jarri behar den etiketa

_start:
        mov eax,4            ; sys_write sistema deia (kodea: 4) prestatzen da. ax erregistroan 4 balioa gordetzen da.
        mov ebx,1            ; Fitxategi deskribatzailea 1 erabiltzen da. bx erregistroan 1 balioa gordetzen da.
        mov ecx,agurra       ; Kaixo aldagaia. cx erregistroan agurra aldagaia gordetzen da.
        mov edx,agurraLuz    ; agurraLuz konstante bat da ez dugu  mov edx,[kaixoLuz]  egin behar
        int 80h              ; kernelari deitzen, eten sinkronoa

                             ; Mezua pantailatik (ala irteera estandarratik) atera ondoren
                             ; programa bukatzeko deia pasako dugu irteera kodea 0 pasatuz (c bezala)
        mov eax,1            ; exit sistema deia (kodea: 1) prestatzen da. ax erregistroan 1 balioa gordetzen da.
        mov ebx,0            ; 0 kodearen irtetzen gara. bx erregistroan 0 balioa gordetzen da.
        int 80h              ; kernel deia, eten sinkronoa


----------------------------------8<--------------------------------------------------------

ELF bitar bat sortzeko konpilatzen dugu:
jakin# nasm -f elf kaixo.asm 

Eta orain linkatzen da, exekutagarria lortuz:
jakin# ld -o kaixo kaixo.o

jakin# ./kaixo
Kaixo mundua
jakin#


Sistema dei guztiak ezagutzeko eta gehiago ikasteko begirada bat bota fitxategi hauei
arch/i386/kernel/entry.S
include/asm-i386/unistd.h
include/linux/sys.h

Tira! behin adibide txiki bat ikusita eta kontzeptu oinarrizkoenak aurkeztuta prest gaude mihiztadura lengoaian
ibiltzeko. Hurrengo alean kodea adibideekin sartuko gara zuzenean.
Ordura arte

RET


                                 -NapharHack-

</5>

	6. Espresio erregularrak
	__________________________

<6> 

Ep(a)+

Espresio erregularrak: testu patroi zehatzak bilatzeko balio duten formulak dira. Konputagailuen
eredu abstraktu garrantzitsuak dira hauek; espresio erregular batekin hitz asko laburbildu daitezke,
izan ere espresioak patroi bat adierazten du eta patroi hori betetzen duen hitz bat edo gehiago egon daiteke.

Espresio erregularrak programazio lengoai (perl, awk, java, c) eta programetan (vi,ed,..) erabil ditzakegu.
Gehienetan bilaketa hutsak egiteko balio dute, eta askotan bilaketa+beste_operazioa burutzeko aplikatzen dira.

Nire kasuan perl-en espresio erregularrak aurkeztuko ditut. Unix munduan oso antzekoak dira espresioak egiteko
modua, beraz hemen erakusten dena baliogarria izango da beste gai askotan.
Perl lengoaian espresio erregularra // hizkiekin adierazten dira, adibidez:

/abc/   =  abc katea daukan edozein testu = weqrabcas aaaabccc 23abc23 abc ...
/a.c/   =  a[karaktere_bat]c katea duen edozein testu =  abc a1c aac aabc ...


Espresio erregularretan hizki bereziak daude portaera errepikakorrak adierazteko.
Ezagunenak hauexek dira:
* : edozein testu, hutsa barne.
+ : edozein testu baina gutxienez karaktere batekin.
. : karaktere bat.

Horietaz gain beste aldagai eta karaktere berezi dauzka espresioak garatzeko. Azalduko ditugu, lasai.

Programa xinple honekin espresioak probatuko ditugu:

-----------------------8<----------------------------------------------------------
#!/usr/bin/perl -w
#

## regexp.pl
## Regexp Angelorum - Jakin Ezine - 5.alea
##
## Kode oso xinplea bi parametrokin: Espresio erregularra eta proba-testua.
## askoz ere sinpleagoa egin daiteke bash agindu bakar batekin, baina erabilera errezteko horrela aurkezten da.

my $regexp;
my $proba_testua;

# argumentu kopurua konprobatu
if ($#ARGV ne 1) {
	print("Bi argumentu sartu mesedez. \nErabilera: ./regexp.pl <regexp> <proba_testua>\n");
	print("Saiatu berriz. Gero arte\n");
	exit(1);
}

$regexp = $ARGV[0];
$proba_testua = $ARGV[1];

print "OK Espresio erregularra /$regexp/\nKonparaketa testua: $proba_testua\n";
print "Ea ba: ...\n";

# Hona hemen konparaketa
if ($proba_testua =~ /$regexp/) {

    print "BATERATZEA! $regexp <=> $proba_testua\n";

} else {

    print "EZ $regexp =/= $proba_testua\n";
}	

---------------------8<------------------------------------------------------------

Jarraian espresio erregularren tresnak aurkezten ditugu. Guzti hauek ongi erabili behar dira
baina benetan ikasteko espresioak probatuko beharko ditugu konbinazio ezberdinak sortuz. Espresio
erregularrak (zuzen-zuzenak) eraikitzea maisulana da.

Laburbiltzeak
-------------

[] karaktereekin tarteak defini ditzakegu: tarte horiekin talde bat osatzen da eta karaktere
bat talde horren barruan badago bateratzea (match) lortzen da.
Adibideak:

"a" =~ /[a-d]/      non [a-d] a-tik d-ra doan karaktere bat izan daitekeen
"e" ==~ /[aeiou]/  bokal bat

\d (zenbaki bat) = [0-9]
   "4" =~ /[0-9]/     "4" =~ /\d/

 Adi!! tarte hori laburtu dezakegu!! 
 
 "3"  =~ /[0-5]/


\D (zenbakiaren ezberdina) = [^0-9]
   "a" =~ /[0-9]/   "a" =~ /\D/
 

\w (karaktarea) = [a-zA-Z0-9_]
   "a" =~ /[a-zA-Z0-9]/   "4" =~ /\w/
  
  Lehen bezala, tartea laburrago izan daiteke:
    "d" =~ /a-fA-F0-9/


\W (karakterearen ezberdina) = [^a-zA-Z0-9_]

    "#;@" =~ /\W/
 
\s (hutsunea) = [ \r\t\n\f]

    "  " = ~/\s/

\S (hutsunearen ezberdina) = [^ \r\t\n\f]
 

Operadore bereziak
------------------

Parentesiak: ( ) (?: )
 Parentesiekin espresio konplexuak sor daitezke, parentesi barruan dagoenari multiplikatzaileak aplikatuz, e.a.

[Multiplikatzaileak]

 ?     : bat ala ezer ere ez 
 +     : bat gutxienez       "dfqa sdqea" =~ /a+/      "    "  =~ /\s+/
 *     : edozer              "dfqa sdqea" =~ /a*/
 {m,n} : gutxienez m, gehienez n.   "WEGMBaafwQSFa" =~ /a{2}/    2 aldiz a 
         zehazki n aldiz zerbait nahi badugu aingurak (anchor) erabili behar dira.
 {m,}  : m ala gehiago    "miaumiaumiau" =~ /(miau){3}/ 
 {m,n}? : {m,n} behin gutxienez


[Disjuntzioak] 

 |
  "a" =~ /a|b/     "mari" =~ /jose|mari/     "jose" =~ /jose|mari/

[Posizio markak]

	
 ^ : hitz-kate baten hasiera   "Kaixo zer moduz" =~ /^Kaixo/

 $ : hitz-kate baten bukaera   "Kaixo zer moduz" =~ /moduz$/	

\b : hitz baten bukaera  "Ni Mikel naiz" =~ /Mikel\b/     Baina hau ez: "Mikelito" =/= /Mikel\b/
 
\B : aurrekoaren aurkakoa: "Mikelito" =~ /Mikel\B/

\A : hitz katearen hasieraren bateratzea

\Z : hitz katearen bukaeraren bateratzea

-Irteera karakterea: \  Hots espresioan operadore bat bilatzen badugu irteera-karakterea jarri beharko diogu lehenbizi
espresioa nahastu ez dadin. Adibidez:

"10000$ behar ditugu?" =~ /10000\$ behar ditugu\?/


Eragiketak
----------

Konparaketa hutsaz gain, aldaketak eta hitz zehatzen irteera egin daiteke. Gainera eragiketa
horietan zenbait aukera aplika daitezke.

s/espresioa/espresioa/   (s=sustitution)

s/espresioa/espresioa/i   i: larriak/xeheak ez bereizteko (case-insensitive)
s/espresioa/espresioa/g   g: aldaketa bateratze GUZTIETAN egin behar da (global)
s/espresioa/espresioa/gi  biak konbina daitezke.

i: case-insensitive
m: hitz-katea lerro anitza bailitzan tratatu
s: hitz-katea lerro bakarra bailitzan tratatu
x: patroia irakurgarriagoa izateko zabaltzen da


m/espresioa/espresioa/ (m=match)

-Beti erabili behar al dira / / mugak? ez horixe! muga ezberdinak erabil daitezke eta zenbait espresioekin
irakurgarritasun handiago lortuko dugu. match eta sustitutionekin erabil daitezke. Adibidez:

/home/jakin/mail espresioa bilatu nahi badugu:
  /home/jakin/mail =~ /\/home\/jakin\/mail/     (buf, hori nahastea!)

Muga propioak definituz (# edo | nahi duguna):
  /home/jakin/mail =~ m#/home/jakin/mail#
  /home/jakin/mail =~ m|/home/jakin/mail|


Erabilera adibide sinple bat
----------------------------

zapper bat egin daiteke. Zapper baten eginkizuna log fitxategietan arrastoak ezabatzea da, adibidez IP helbideak,
erabiltzaile izenak, e.a. Sistema intrusioetan erabiltzen dira, nolabaiteko erratza pasatze bat da.

---------------------8<------------------------------------------------------------
#!/usr/bin/perl

## zapper.pl
## Regexp Angelorum - Jakin Ezine - 5.alea
##
## Kode oso xinplea bi parametrokin: fitxategia eta aldatu nahi dugun katea
## Zapper batek log fitxategietan ikusgai dauden arrastoak ezabatzeko balio du.
## Modu ezberdinak ditugu hau egiteko, kasu honetan fitxategi laguntzaile batekin
## egin dugu.

my $fitxategia;
my $fitxategi_lagun = "fitxategi.lag"; 
my $katea;
my $kontagailua = 0;

# argumentu kopurua konprobatu
if ($#ARGV ne 1) {
	print("Bi argumentu sartu mesedez. \nErabilera: ./zapper.pl <fitxategia> <katea>\n");
	print("Saiatu berriz. Gero arte\n");
	exit(1);
}

$fitxategia = $ARGV[0];
$katea = $ARGV[1];

open(FITXATEGIA,$fitxategia) or die("Ezin izan dut $fitxategia fitxategia ireki $!");
open(FITXATEGILAGUN,">$fitxategi_lagun") or die("Ezin izan dut $fitxategi_lagun fitxategia ireki $!");


print "OK $katea katea $fitxategia fitxategian agertzen bada lerroa ezabatuko dugu\n";
print "Ea ba: ...\n";

# jatorrizko fitxategian mugitu eta nahi ez ditugun lerroak ez ditugu idazten
while (<FITXATEGIA>) {
	unless (/$katea/i) { # katea agertzen ez bada, ongi.
		print FITXATEGILAGUN $_;
	} else {
		print "Desagertarazten... " . $_;
		$kontagailua++;
	}
}


# fitxategiak itxi
close(FITXATEGIA);
close(FITXATEGILAGUN);

# Hara, hemen izenak aldatzen ditugu eta jatorrizkoa desagertzen da.
rename($fitxategi_lagun, $fitxategia) or die("Ezin dut jatorrizko $fitxategia ordezkatu $fitxategi_lagun -ekin $! \n");

# Bada ez bada: laguntzailea ezabatu, aurreko zerbait gaizki ateratzen bada..
unlink($fitxategi_lagun);

# print
print "OK,  $kontagailua arrasto ezabatu dira, egotekotan\n";

---------------------8<------------------------------------------------------------

Zein da modurik egokiena fitxategi bat aldatzeko? kopia bat gorde eta gero izenak aldatu hemen egin den bezala?
ala fitxategia bera aldatu behar da?
Erantzun zuzena fitxategi tamainaren araberakoa da. Tamaina handia bada azkarrago eta seguruagoa izango da bi fitxategiekin
egitea, gainera horrekin ez dugu sysadmin baten atentzio geureganatuko. Log fitxategiak handiak izan daitezke (mega askotakoak)
kasu askotan.

Bueno, hauxe espresio erregularren sarrera besterik ez da izan, non aukeren laburpena aurkeztu den.
Hurrengo aleetan eragiketa konplexuagoak aurkeztuko dira.

Hurren arte

Agur =~ /[A][g][u][r]|Agur/

					-Regexp Angelorum-

</6>



	7. Kultura
	__________________________

<7>


Titulua: Prisonner's Dilemma
Egilea: William Poundstone
Gaztelaniaz Alianza argitaletxean aurkitu dezakegu.

Saiakera-biografia-historia-dibulgazio arlokoetako liburua da. Jokuen Teoriari buruz dihardu eta batez ere bere 
sortzaileaz: John von Neumann.

von Neumann oso ezaguna da gaur egungo konputagailua sortzeko oinarriak ezarri zituelako: prozesadorea,
memoria, ea. Baina bere garaian momentu historiko larria bizi zuen: bonba nuklearraren garapena hain zuzen ere,
eta tamalez bonba sortzeko bere "abiadura handiko burmuina" eskeini zuen. Bere kalkulu matematikoak bonba funtzionatzeko
ezinbestekoak izan ziren, eta are gehiago: bonba erabiltzeko partaide sutsua zen. Zergatik?

Jokuen Teoria asmatu zuen eguneroko dilematan oinarriturik, batez ere Presoaren dileman oinarrituta: demagun bi pertsona
preso ditugula gela ezberdinetan. Gela hutsik dago eta aurren daukaten bakarra botoi bat da. Zera dakite: bera bezalako
beste pertsona bat dago, bat ala bestea hil behar da. Botoia sakatzen duena hiltzen da eta bestea libre geratzen da.
Botoia sakatzen ez badute biak hiltzen dira. Zer egin? azkeneko unera arte itxaron? botoia sakatu bestea libratzeko?
eta inork sakatzen ez badu?

John von Neumann-ek erakutsi nahi zuen beti bazegoela horrelako jokuetan modu razional batean jolasteko modua. Bi jokalarien
dilema asko topa daitezke, eta horietariko bat gerra nuklearrarena da; von Neumann-entzat dilema nuklearraren aurrean
lehenbizi erasotzea nahiago zuen, hori bai, bere erabakia demostrazio matematiko batetik zetorren (bueno, komunistak
ez zituen oso gustoko ere). Hiroshima eta Nagasaki-ko bonba garaian beste matematikari askok EEBBko gobernuko estrategia
erakundetan (RAND kasu) lan egin zuten; aipatzekoa da ere John Nash (duela gutxi Russel Crow aktoreak eginiko lana)
matematikaria, Nobel saria eman zion negoziazio teoria jokuen teoriatik dator. Beste izen garaikide asko atera daitezke:
Einstein, Oppenheimer, Russel, ea..

Irak-eko gatazkan "Gerra prebentibo" hitz-bikote ezinezkoa atera da komunikabidetan. Ideia hori John von Neumann-en garaian
atera zen bonba nuklearrak zirela eta. Liburu honek garai horren kontaketa egiteaz gain Hungriatik etorritako pertsonai
berexi honetaz dihardu. Genio hutsa gerraren zerbitzuan? 

Bitxikeri bezala, Russel Crow aipatu dugunez zineak von Neumann-en ustezko parodia ezaguna sortu zuen: Stanley Kubrick-en
"Doctor Strangelove or how I stopped to worrying and love the bomb" (telefono rojo?) filmean gurpildun aulkian agertzen
den zientzilari eroa eta faxista von Neumann da (Peter Sellers-ek antzeztua).

Baina
gerraren erruz kriston aurrerapen teknologikoak egiten dira...


					-km-
</7>


	8. Albisteak,Estekak,Agurrak
	__________________________

<8>

Eskerrrr aunitz librezale, indymedia, suburbia guneei eta ezinea ezagutarazten duzuen guztioi.

*Phrack ezinearean ale berria
*Krisialdia donostiako hacklabean? http://www.hacklabs.org/wiki.pl?Donostia

[>---------- Aurtengo biltzarra --------------<]
+----------------------------------------------+
|Hackandalus - Hackmeeting 2004                |
|http://sindominio.net/hackmeeting/            |
+----------------------------------------------+
| Wish list bat sortu da, ea jendeak erantzuten|
| duen.                                        |
|                                              |
| Deialdia hispasec bitartez ere zabaldu       |
| da, horrek bultzadatxoa suposatuko duelakoan |
| gaude.                                       |
+----------------------------------------------+


Ez ahaztu hauexek direla ezinearen helbideak:

http://www.jakin.tk/
http://jakinezine.galeon.com/
http://jakin.sourceforge.net/

Eta email helbideak:
jakin@mailbox.co.za
jakin@kaixo.com

CALL FOR PAPERS!!!
Zeren zain zaude? gai asko dauzkagu hitzegiteko: ASM, aribako sareak, spectrum :), algoritmo genetikoak, matematikak,
gai sozialak, hacktibismoa, hacker taldeak, istorioak, albisteak, proiektuak... Anima zaitezte!
Ez du garrantzirik gaiak errepikatzen badira, jasotzen duguna ongi-etorria izango da beti.

Hurrengo alean Hackmeeting-eko kronika egitea gustatuko litzaiguke (Ea posible den).
Jomuga berria jarriko dugu orain: hamargarren alera baietz heldu! hamarra zenbaki bitarra da, agian gure
bigarren aroaren hasiera markatuko duena.

<Oharra>
Jakin ezinea ez da irakurleek bere kodeaz egiten duten erabileraren arduradun. Fanxinaren helburu bakarra
informatika teknikak erakustea da, dokumentaziotan, interneten, edonon dagoen informazioa modu ulerkor
batean laburtzea azken finean. Ohar tipiko hau sartzea beharrezkoa EZ dela deritzogu, baina badazpada
hemen da.
</Oharra>
					-edit-

</8>

</jakin>
