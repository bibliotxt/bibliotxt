<jakin>

        JJ   AAAAAAAA  KK   KK   II  NN    NN
        JJ   AA    AA  KK  KK    II  NNNN  NN
        JJ   AAAAAAAA  KKKKKK    II  NN NN NN 
        JJ   AA    AA  KK  KK    II  NN  NNNN
  JJ    JJ   AA    AA  KK   KK   II  NN   NNN
  JJJJJJJJ   AA    AA  KK    KK  II  NN    NN

      e         z        i        n        e	
 ______________________________________________________________________
| 4. alea (Balioa: 63k)                                                |		
|______________________________________________________________________|
| 2004/06/14                                                           |
|______________________________________________________________________|
|                                                                      |
| Segurtasun elektronikoari buruzko fanxina, euskera hutsez            |
|                                                                      |
|______________________________________________________________________|
|                                                                      |
| Parte hartzaileak: edit,niuBAI, Regexp, Espoz&Mina, Assert,          |
|                    NapharHack, keepalive eta KM                      |
|______________________________________________________________________|
| email helbidea: jakin@mailbox.co.za                                  |
|                 jakin@kaixo.com                                      |
|		  jakinezine@hispavista.com                            |
|______________________________________________________________________|
| Web helbidea:  http://www.jakin.tk                                   |
|		 http://www.angelfire.com/zine2/jakinezine/            |
|                http://jakinezine.galeon.com                          |
|______________________________________________________________________|



Ale honetan:

Zb Artikulua				Egilea	
______________________________________________________
0. Hitzaurrea                           edit
1. NapharHack taldearen proiektua	NapharHack
2. Unix sistema programazioa (I)        Espoz&Mina
3. IRC errobota eta Turing-en testa     Regexp
4. TCP/IP programazioa (IV)             niuBAI
5. Sistema adituak                      Assert
6. Interneten funtzionamendua: BGP    	keepalive
7. Kultura                              km
8. Estekak,Oharrak,Agurrak              edit
______________________________________________________



     "robot"
iz. 1. Fikziozko filmetan, giza itxurako makina, mugitzeko, hitz egiteko eta aginduak betetzeko gai dena. 
2. TEKNOL. Aparatu automatikoa, ezarritako programa aldagarriaren arabera, objektuak maneiatu edo 
eragiketa bat edo gehiago exekutatzeko gai dena.




(((((((((((((((((((((((((((((((((((( Jakin dezagun!! ))))))))))))))))))))))))))))))))))))))


	0. Hitzaurrea
	__________________________

<0>

Lau. 
Lau dira apokalipsiko zaldunak eta dagoeneko lau dira Jakin ezinearean aleak :D 
Holako astokeriak botata ere aurrera goaz; nazkatuta gaude telebistarekin, nazkatuta gaude irratiarekin,
nazkatuta egunkariekin, politikoekin,.. gure inguruko mundu honen funtzionamendua ezagutu nahi dugu, gauzek
nola funtzionatzen duten JAKIN nahi dugu; horretarako jakinmina, informazioa, ezagutza zabaldu nahi ditugu
zernahi kosta. Jakin ezinea ahalegin horren ur ttantta besterik ez da; gauzak nola sortu erakusten saiatzen
gara, gauza erabilgarriak garatzeko bidea marrazten ahalegintzen gara ale bakoitzarekin.

Sistemen funtzionamendua ulertzeko behe mailatik hasten saiatzen gara eta aurrera egiten dugu oinarri bat
edukita, eta beti, beti izango gara IKASLE eta ez maisu. Maisuak bere katedra eserlekutara joan daitezke
heuren ipurdia loditzera. 

Lanak jarraipen bat dauka eta laugarren ale honek ez du baliorik aurreko aleak ezagutu gabe. Zorionez nolabaiteko
lei motiv bat lortu dugu zenbait gaietan: harrokeririk gabe irakasten saiatzea. C eta UNIX munduan murgiltzen
jarraitzen dugu. Interneten oinarri den BGP ezagutuko dugu. Perl lengoaiaren erabilpen berri bat ikusiko dugu.
Adimen artifiziala begibistan mantentzen dugu. Gai interesgarriak zalantza barik eta gehiago nahi ditugu, gure
jakintza grina asekaitza baita.

Beraz, 255 departamentuaren laguntzarekin ezine honen jarraipena bermatzen duen parteartzea eskatzen dugu
ohizkoa den moduan. Gure deia zabaldu webgunetara, blogetara, ogg iturrietara, eztabaida-guneetara,... zer ba, 
ez al duzue ulertu? denok gara 255 departamentua. Modan dagoen eskari batekin bukatuko dugu hitzaurrea:

Pasa ezazu!
XD

					-edit-
</0>



	1. NapharHack taldearen proiektua
	__________________________

<1>

Kaixo, email honekin sortu berri den talde bat aurkeztu nahiko genuke: NapharHack taldea, edo laburrean NH taldea.
Pertsona mordoa gara, 2 hain zuzen ere. Espero dugu nafar gehiago biltzea, Jakineko kide den Espoz&Mina adibidez.
Hacking-ean interesaturik ginen bi pertsona elkartu gara eta talde bat osatzea pentsatu genuen, jende gehiago
agertuko zelako itxaropenez. 

Behin talde bat osatuta, zer egin? proiektu bat behar genuen ta hasteko dokumentazio proiektu bati hasiera
emanen diogu: 

Hacker Eskuliburua
------------------

-Zer da Hacker Eskuliburua? hacker batendako erabilgarri izan daitekeen gidaliburua, erreferentziako liburu teknikoa:
programazioa, lengoaiak, protokoloak, ... ikerketarako lagungarri izan daitekeen gidaliburua.

-Zer EZ da Hacker Eskuliburua? sistemak hackeatzeko liburua, hacking teknika zehatzen testua, black-hat testua.

Pena merezi al du ahaleginak? guretzat behintzat bai. Geure lanerako erabiliko baitugu.

Hauxe da garatu dugun aurkibidea, GUZTIZ IREKIA dagoena. Gaiak falta dira (kriptografia, PIC txipak, eta abar 
luuuuuze bat), eta apika batzuk soberan daude.

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
   Aurkibidea

   0000.- Sarrera.
   0001.- Oinarrizko hacker testuak
    0001.0001.- Hacker manifestua
    0001.0010.- Jargon file
    0001.0011.- Hacker howtoa

   0010.- Lengoai erreferentzia
    0010.0001.- C
    0010.0010.- Perl
    0010.0011.- ASM
    0010.0100.- Java
    0010.0101.- C++
    0010.0110.- SH
    0010.0101.- AWK

   0011.- Sistema eragileak
    0011.0001.- Unix
    0011.0010.- Windows

   0100.- Sareak
    0100.0001.- TCP/IP
    0100.0010.- Ethernet
    0100.0011.- V35,V56
    0100.0100.- 802.11b

   0101.- Aplikazio maila
    0101.0001.- HTTP
    0101.0010.- SMTP, POP3, IMAP
    0101.0011.- IRC

   0110.- C & UNIX programazioa
    0110.0001.- Garapen tresnak
    0110.0010.- Oinarriko S/I
    0110.0011.- Prozesuak eta hariak
    0110.0100.- Komunikazioak
    0110.0101.- IPv6

   0111.- Birusak
   1000.- Tresnak
    1000.0001.- Oinarrizkoak
    1000.0010.- Eskaneoak
    1000.0010.- Auditoriak
    1000.0010.- Snifferrak
    1000.0010.- Crackerrak

   1001.- WAN protokoloak
    1001.0001.- BGP
    1001.0001.- IGRP

   1010.- SNMP protokoloa
   1011.- Burnia

   A- Eranskina: ASCII kodea
   B- Eranskina: RFC esanguratsuenak

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Proiektu honen lehen emaitza bezala honako testu ezagun honen itzulpena aurkeztu nahiko genuke: Hacker Manifestua.
Eskuliburuaren hitzaurrean zenbait hacker oinarrizko testuak aukeratu ditugu: Hacker Manifestua, Jargon file,..

                            ·////////////////////////////////////////////·

HACKER MANIFESTUA

Gaurkoan beste bat harrapatu dute, egunkari guztitan azaltzen da. "Gazte bat delitu informatikogatik atxilotua".
"Hacker bat atxilotu da banketxe baten sisteman sartu delako". "Ume madarikatuak. Denak berdintsuak dira".
Heuren psikologia kaxkarra eta 50 hamarkadako pentsakerakin ikusi al dute hacker baten begien atzekaldean
dagoena? Pentsatu al dute noizbait bere portaeraren arrazoia, zein den bere bilakaeraren errudun?

Hacker bat naiz, sar zaitez nire munduan. Nire mundua eskolan hasten da. Nire klasekideak baino azkarragoa naiz,
klasean erakusten dena aspergarria da. "Irakasle madarikatuak, denak berdintsuak dira". Eskolan ala institutuan
egon naiteke. Behin eta berriro entzun diet nola laburbildu frakzioak. Guzti hori ulertzen dut jada. "Ez, Smith jauna,
ez dut nire lana idatzi. Neure buruan gordeta daukat. "Ume madarikatuak. Ziur naiz kopiatu egin duela. Denak berdintsuak
dira". 

Gaurkoan gauza bat deskubritu egin dut. Ordenadore bat. Egon, hau itzela da. Nik diodana egiten du. Erroreak
egiten baditu, nik halaxe agindu diodalako da. Eta ez ni gustoko ez duelako, nitaz beldur delako, marijakintsu bat naizela
pentsatzen duelako edo irakastea ezta hemen egotea atsegin ez duelako. Ume madarikatuak. Jolastu besterik ez dute egiten.
Denak berdintsuak dira. Orduantxe zerbait gertatzen da... ate bat irekitzen da mundu berri batera... linea telefonikoaren
bitartez, heroina zainetan bailitzan, pultsu elektriko bat jaulkitzen da, eguneroko hutsegitetatik at babesleku bila...
eta teklatu baten aurrean nago. "Hauxe da... hauxe da nire lekua... ". Hemen mundu guztia ezagutzen dut...
beraiekin topatu ez banaiz ere, beraiei hitzegin edo bere abotsa inoiz ez entzun ez badut ere... denak ezagutzen ditut...
ume madarikatuak. Berriz ere telefonora engantxatuta. Denak berdintsuak dira... apustua egin dezakezu baietz denak
berdintsuak direla... eskua eskeini eta besoa hartzen dizute... eta kexu dira dena horren eginda ematen diegu ezen
ez baitzaie dastatzeko aukerarik ematen. 

Sadikoak ala apatikoen gobernupean gaude. Irakasteko zerbait daukatenek ikasketa grina duten ikasle bila dabiltza, baina
horratza metan bilatzea bezala da. Mundu hau geurea da... elektroien eta interruptoreen mundua, baudioaren edertasunarena
Jada existitzen den zerbitzua darabilgu, musutruk, espekulatzaileengatik ez balitz merkeago litzetekeen horregatik ordaindu gabe
Eta gaizkile deitzen gaituzue. Bilatu... eta gaizkile deitzen gaituzue. Gure ezagutzak handitu nahi ditugu eta gaizkile deitzen
gaituzue. Ez dugu ez larru-kolore ez nazio ezta erlijiorik bereizten.. eta gaizkile deitzen gaituzue. Bonba atomikoak sortzen
dituzue. gerra egiten dituzue, erahiltzen duzue, herriari iruzur egiten diozue eta gezur esaten diguzue onak zaretela 
pentsarazten gaituzuenean, eta hala ta guztiz ere gaizkiletzat hartzen gaituzue.
Bai horixe, gaizkilea naiz. Nire delitua jakinahia da. Nire delitua jendeak esan eta egiten duenagatik juzgatzea da,
eta ez bere itxuragatik. Nire delitua zuek baino azkarragoa izatea da, inoiz ez barkatuko ez didazuena.

Hacker bat naiz, eta hauxe da nire manifestua. Gutariko batzuk akabatu ditzakezue, baina ez guztioi... azken finean,
denak berdintsuak gara.
					The Mentor

                            ·////////////////////////////////////////////·

Esan bezala, guretzat ahalegin honek pena merezi du. 

Gaizki esanak barkatu, eta ongi esanak ongi hartu.

Jaso ezazue gure agurrik beroena NapharHacken laborategitik.

					-NapharHack-

</1>



	2. Unix sistema programazioa (I)
	__________________________

<2> 

Kaixo unixzaleok!
Bada garaia unix sistema programazioan murgiltzeko. Zalantzarik gabe egun ezagutzen diren teknologia
garrantzitsuenen oinarriak c lengoaia eta unix sistema eragileak dira; are gehiago, c eta unix ezin dira
bata bestea gabe ulertu (unix c lengoaian eginda dago). 

Jakinen lehen aletik TCP/IP programazioaz aritu gara niuBAIren eskutik, eta orain prozesuetaz arduratuko gara.
Unix = prozesuak + fitxategiak. C lengoaia eta fitxategien kudeaketa nahiko ezaguna denez, unix-en beste %50az
jardungo gara: prozesuen kontrola.

Prozesuen sorkuntza, gurasoak, semeak, seinaleen bidezko kontrola, prozesuen arteko komunikazioa eta noski: hariak.
Ohi denez adibide xinpleekin hasiko gara; JAKIN ezinearen "estiloa"ri atxekituz, ezagutzaren hazia ematen dugu
hortik aitzina aurrerapausoak irakurleen eskutan uzteko.
Eta ikusiko duzuen moduan, niuBAIen artikuluarentzako baliagarria izanen da. Hemendik aitzina biak konplementarioak
izanen dira. Kodeketa estilo antzekoa erabiltzen saiatuko gara.

Goazen helloworld adibidearekin :) 

-------------------8<--------------------------------------------------------------
/**
* $Id$
* -Goikoa CVS baterako marka berezia da-
* 1en_prozesua.c
* Prozesuen programazioa
* ARGI ibili fork deiarekin. Deia egiten denetik ezin da ziurtatu zein exekutatuko den lehenbizi.
* FORK deiak aitaren memoria espazio guztiaren kopia sortuko du.
*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

// programa nagusia
int main (int argc, char *argv[]) {

        // prozesuaren identifikadorea
        pid_t semea;

        printf("Prozesuen lehen probak. PID= %d\n",getpid());

        // Honak hemen FORK deia, gure programak prozesu seme bat sortu eta aita biurtzen da.
        if ( (semea = fork()) == -1) {
                // errorerik egon bada
                perror("Errorea FORK egiten saiatu garenean");
                exit(EXIT_FAILURE);

        // hemendik aurrera bi prozesuak pasako dira hemendik. Bereizteko ID balio erabiltzen da
        } else if (semea == 0) {
                // semearen kodea
                printf("Semean gaude\n");
                printf("Semearen PID: %d\n",getpid());
                printf("Semearen aitaren PID: %d\n", getppid());
                exit(EXIT_SUCCESS);
        } else {
                // gurasoaren kodea
                printf("Aitan gaude. semearen balioa: %i\n",semea);
                printf("Aitaren PID: %d\n",getpid());
                printf("Aitaren aitaren PID (shell prozesuaren IDa ziurrenik): %d\n", getppid());
        }

        exit(EXIT_SUCCESS);

}

---------------------------8<------------------------------------------------------

Unixen prozesu exekuzioak hierarkia bat osatzen du. Lehen prozesua (id=1) init izaten da (sched solarisen). Init
prozesuak gainontzeko prozesu guztiak sortzen ditu, ondorioz prozesu guztiek guraso bat daukate. Era berean kode
hau exekutatzen dugunean, gure shell sesioaren (bash, csh edo dena delakoa) seme bat sortzen dugu, eta berak bere
seme bat ere sortzen du fork deiaren bitartez. "ps -axf" aginduarekin prozesuen famili-zuhaitza ikus dezakegu.
Semea sortzen denean aitaren datu guztien kopia berri bat egiten da, ez dira datu berdinak erabiltzen.

Hauxe izan daiteke kodearen irteera (lehenbizi ps bat egiten dugu gure shellaren IDa jakiteko):

bash# ps
  PID TTY          TIME CMD
 1015 pts/0    00:00:00 bash
 1299 pts/0    00:00:00 ps
bash# ./1en_prozesua
Prozesuen lehen probak. PID= 1300
Semean gaude
Semearen PID: 1301
Semearen aitaren PID: 1300
Aitan gaude. semearen balioa: 1301
Aitaren PID: 1300
Aitaren aitaren PID (shell prozesuaren IDa ziurrenik): 1015

Hara! bat datoz noski, kodearen aita (1015) bash shell sesioarena da.

C programa batetik sistema deiak egin daitezke system komandoaren bitartez.
...
system("ls -R /var/log/*");
...

Honek duen eragina zera da: prozesu seme bat sortzen da. Honen antzeko beste dei bat dago: popen, prozesu
bat sortzen du baina tuberiak erabilita.
Bestalde exec agindu familia ere erabil dezakegu, baina kontuz, efektua ezberdina da. exec bat egiten denean ez
da aitaren kopia bat egiten, exec aginduaren exekuzioak aitarena ordezkatzen du. Zenbait kasutan agian horrelako
dei batekin nahikoa daukagu.

Erreza ezta? orain iratxoak aurkeztuko ditugu. Iratxo ala deabru esaten da euskaraz? zuen iradokizunak espero ditugu.
DAEMON (arima babeslea, grekeratik) = deabrua = iratxoa

Iratxo bat, definizioz etengabeko exekuzioan dagoen prozesua da, eta lo egiten du esnatzen ez zaion bitartean.
Horrelako prozesu bat sortzeko aurreko kodearean "antzeko" zerbait egin behar da, berezitasun bat gehituta:
iratxoa ezin da shellaren seme bezala geratu, shellatik irtetzerakoan bere exekuzioa bukatuko delako, hori ekiditeko
setsid deia darabilgu. Behin seme "independiente" hori sortu dugunean etengabeko begiztan nahi dugun ataza ematen diogu,
eta horrelaxe badaukagu iratxoa. 
Lehen adibide honetan syslog eta cpu denboren erabilpena ere erakusten da, bide batez...

---------------------------8<------------------------------------------------------

/**
* $Id$
* iratxoa.c
* Prozesuen programazioa
* Fork deiaren bitartez seme prozesua sortzen dugu eta horrek behar den lana egiten du.
*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <syslog.h>             // syslog erabili ahal izateko
#include <sys/times.h>          // prozesuen cpu denbora ateratzeko

// programa nagusia
int main (int argc, char *argv[]) {

        pid_t aita, semea;

        // Exekuzio denborak ateratzeko baliabideak.
        struct tms denbora;
        long tik_segunduko;

        printf("Prozesuen lehen probak. PID= %d\n",getpid());

        // Prozesua sortzen dugu.
        if ( (aita = fork()) < 0) {
                perror("Errorea FORK egiten saiatu garenean");
                exit(EXIT_FAILURE);
        }

        /**************************IRATXO BAT SORTZEN, PAUSOZ-PAUSO **********************/
        // 0.- Aitan baldinbagaude, atera
        if ( aita > 0) {
                printf("OK, aitaren lana (id: %d) bukatu da, bagoaz.\n",getpid());
                exit(EXIT_SUCCESS);
        }


        // 1.- Semean sesio berria sortzen du prozesu talde berri baten nagusi izateko (aita biurtuko da)
        // Hori errez ikus daiteke: ps exekutatuz ez dugu ikusiko (ez delako gure shellaren semea), ps -fea egin
        if ((semea = setsid()) < 0 ) {
                perror("Errorea SETSID egiten saiatu garenean");
                exit(EXIT_FAILURE);
        }

        // 2.- Ondoren exekuzio direktorioa aldatzen dugu.
        if ( (chdir("/")) < 0) {
                perror("Errorea chdir egiten saiatu garenean");
                exit(EXIT_FAILURE);
        }

        // 3.- Fitxategien sorkuntza baimenak berreskuratzen ditugu.
        umask(0);

        // 4.- Oinarrizko fitxategi deskriptoreak ixten ditugu. Ez dugu irteera edo sarrera estandarrik eukiko
	// ez eta errore irteera (0,1 eta 2 fitxategi deskribatzaileak)
        close(STDIN_FILENO);
        close(STDOUT_FILENO);
        close(STDERR_FILENO);


        // Mezua syslogari pasa: maila: NOTICE. mota: erabiltzailea(LOG_USER) -besterik ezekoa-
        syslog(LOG_NOTICE | LOG_USER ,"Semea (id: %d) martxan dago iratxo moduan, bere gurasoa init (id: %d) da. \n",getpid(), getppid());

        // 5.- Iratxoaren betebeharra hemen -begizta amaigabea- . Nahi duzuena sar daiteke.
        while(1) {// begizta amaigabea

                sleep(3); // lotara pixkat -3 seg.-

                // Sistema dei bat egiten dugu. Honek seme bat sortuko du.
                system("ls -R /proc");

                // exekuzio denborak lortzen ditugu.
                times(&denbora);
                tik_segunduko = sysconf(_SC_CLK_TCK);
                syslog(LOG_NOTICE | LOG_USER ,"Erabiltzailearen CPU denb. : %6.6f seg. - Sistemaren CPU denb. : %6.6f seg. \n",(float)denbora.tms_utime/tik_segunduko, (float)denbora.tms_stime/tik_segunduko);
                syslog(LOG_NOTICE | LOG_USER ,"SErabiltzailearen CPU denb. : %6.6f seg. - SSistemaren CPU denb. : %6.6f seg. \n ",(float)denbora.tms_cutime/tik_segunduko, (float)denbora.tms_cstime/tik_segunduko);

        }

        // printzipioz ez gara hona helduko begiztan 'break' jartzen ez bada
        exit(EXIT_SUCCESS);


}// Amaiera


----------------------8<-----------------------------------------------------------

Ongi. ps -axf edo ps -fea eginda iratxoa martxan ikusiko dugu. Zer egiten du? exekuzio denborak syslogari pasa.
Edozein linux sisteman (syslog martxan egon beharko du), "tail -f /var/log/messages" exekutatuz horrelako irteera
ikusiko dugu:
bash# ./iratxoa
Prozesuen lehen probak. PID= 1316
OK, aitaren lana (id: 1316) bukatu da, bagoaz.
bash#
bash# tail -f /var/log/messages
...
Apr  6 03:05:44 jakin01 iratxoa: Erabiltzailearen CPU denb. : 0.040000 seg. - Sistemaren CPU denb. : 0.000000 seg.
Apr  6 03:05:44 jakin01 iratxoa: SErabiltzailearen CPU denb. : 0.480000 seg. - SSistemaren CPU denb. : 0.700000 seg.
Apr  6 03:05:47 jakin01 iratxoa: Erabiltzailearen CPU denb. : 0.050000 seg. - Sistemaren CPU denb. : 0.000000 seg.
Apr  6 03:05:47 jakin01 iratxoa: SErabiltzailearen CPU denb. : 0.540000 seg. - SSistemaren CPU denb. : 0.770000 seg.
...

Seinaleak.
Prozesuak sortzen badakigu, baina nola komunika gaitezke beraiekin? eta beste prozesuekin? seinaleekin! prozesuen
arteko komunikazioa tuberia, socket edo seinaleekin egin daiteke. Ziur aski uste baino gehiagotan erabili dituzue
seinaleak, kill aginduaren bitartez. Ez pentsa kill agindua prozesuak hiltzeko soilik balio duenik: kill aginduak 
seinaleak bidaltzeko balio du. 
Adibidez, gure iratxoa akabatezko, bere IDa lortu eta horrela akabatuko genuke:
bash# kill -9 1340        (edo kill -SIGKILL 1340   edo    kill -KILL 1340)

Baina seinale gehiago daude noski: SIGALRM, SIGHUP. Hauexek:
SIGHUP, SIGINT, SIGQUIT, SIGILL, SIGTRAP, SIGIOT, SIGBUS, SIGFPE, SIGKILL, SIGUSR1, SIGSEGV, 
SIGUSR2, SIGPIPE, SIGALRM, SIGTERM, SIGSTKFLT, SIGCHLD, SIGCONT, SIGSTOP, SIGTSTP, SIGTTIN, 
SIGTTOU, SIGURG, SIGXCPU, SIGXFSZ, SIGVTALRM, SIGPROF, SIGWINCH, SIGIO, SIGPWR

Hurrengo alean seinaleen kudeaketaz arduratuko gara. Ordura artio, iratxo aunitz sortu!


kill -QUIT 1


					-Espoz&Mina-

</2>


	3. TCP/IP programazioa (IV)
	__________________________

<3> 

Gabon guztioi!!
Aurreko alean RAW socketei buruz jardun ginen eta ikerketarako atal interesgarria denez datozen aleetan
leku berezia emango diegu. Baina gaurkoan: tcp zerbitzaria. Espoz&Mina-k aurkeztutako kodea erabiliz daemon
moduan exekutatzen den tcp/ip zerbitzari baten adibidea aurkeztuko dugu. 

tcpzerbitzaria.c izeneko fitxategi honen kodeak ez du ezer berezirik egiten: konexio berriak onartu, banner
bat erakutsi eta kitto. Mezu guztiak syslog-era bidaltzen ditu. Baina ohi denez adibide xinple honen bitartez
kode konplexuago batendako abiapuntua ematen saiatzen gara.

Zerbitzaria iratxo moduan egikaritu edo exekutatzen da. tcp/31337 portuan entzuten geratzen da, edozein ip
helbideari atxekituz (hots, makinak ip helbide bat baino gehiago baldinbadauka edozeinera konektatu ahal izango
da localhost barne). 

----------------------8<-----------------------------------------------------------
/**
* $Id: tcpzerbitzaria.c,v 1.1.1.1 2004/04/12 17:43:46 root Exp $
* tcpzerbitzaria.c
* TCP portuan entzuten jartzen dugun zerbitzaria
*/

#include <stdio.h>
#include <stdlib.h>
#include <syslog.h>
#include <unistd.h>
#include <errno.h>
#include <string.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>

#define PORTUA 31337

// at_exit funtzio bezala erregistratutko dugun funtzioa
void irteera_atazak (void);

// funtzio nagusia
int main (int argc, char *argv[]) {

        // Behar ditugun aldagaiak
        pid_t aita, semea;
        int zerbitzarisocket, sock_tmp;
        struct sockaddr_in zerbitzari_helb;
        struct sockaddr_in bezero_helb;
        int bezero_helb_tam;
        struct hostent *host_entitatea;
        int jasotakoa;
        int tamaina;
        int bidalitako_tamaina;
        int jasotako_tamaina;
        char *bufferra;

        // Lehenbizi gurasotik ateratzen gara eta iratxoa sortzen dugu.
        if ((aita = fork()) < 0 ) {
                perror("Errorea prozesu berria sortzerakoan: ");
                exit(EXIT_FAILURE);
        }

        // aitan baldinbagaude, atera, semea uzten dugu.
        if (aita > 0) {
                exit(EXIT_FAILURE);
        }

        // LOGa prestatzen dugu. "tcpzerbitzaria" hitza identifikadorea izango da.
        openlog("tcpzerbitzaria",LOG_PID, LOG_DAEMON);

        // Irteera funtzioa ezartzen dugu. Kodea amaitzean automatikoki deituko den funtzioa
        if (atexit(irteera_atazak) != 0) {
                perror("Errorea irteera funtzioa erregistratzerakoan.");
                syslog(LOG_ERR | LOG_USER, "Errorea irteera funtzioa erregistratzerakoan.");
                exit(EXIT_FAILURE);
        }

        // Semearen sesio propioa lortzen dugu.
        if ( ( semea = setsid()) < 0) {
                perror("Errorea prozesu sesio propioa eskatzerakoan.");
                syslog(LOG_ERR | LOG_USER, "Errorea prozesu sesio propioa eskatzerakoan.");
                exit(EXIT_FAILURE);
        }

        // Direktorioa aldatzen dugu
        if ( (chdir("/")) < 0) {
                perror("Errorea / direktoriora aldatzerakoan.");
                syslog(LOG_ERR | LOG_USER, "Errorea / direktoriora aldatzerakoan.");
                exit(EXIT_FAILURE);
        }

        // fitxategi baimenak berreskuratzen ditugu.
        umask(0);

        // Oinarrizko fitxategi deskriptoreak ixten ditugu. 
        close(STDIN_FILENO);
        close(STDOUT_FILENO);
        close(STDERR_FILENO);

        syslog(LOG_ERR | LOG_USER, "OK, tcpzerbitzaria iratxo bihurtu dugu, socketa martxan jarriko dugu..");

        // Socketa sortzen dugu.
        if ((zerbitzarisocket = socket(AF_INET, SOCK_STREAM, 0) ) == -1 ) {
                syslog(LOG_ERR | LOG_USER, "Errorea socketa sortzerakoan: %s", strerror(errno));
                exit(EXIT_FAILURE);
        }

        // Socketaren helbide datuak ezarri (mota, portua, helbidea..)
        zerbitzari_helb.sin_family = AF_INET;
        zerbitzari_helb.sin_port = htons(PORTUA);
        zerbitzari_helb.sin_addr.s_addr = htonl(INADDR_ANY);

        // Socketa bere helbideari
        if ( bind(zerbitzarisocket, (struct sockaddr*) &zerbitzari_helb, sizeof(struct sockaddr))  == -1 ) {
                syslog(LOG_ERR | LOG_USER, "Errorea socketa sortzerakoan: %s", strerror(errno));
                exit(EXIT_FAILURE);
        }

        // Socketa entzuten jartzen dugu.
        if ( listen(zerbitzarisocket, 10) == -1 ) {
                syslog(LOG_ERR | LOG_USER, "Errorea socketa listen moduan jartzerakoan %s", strerror(errno));
                exit(EXIT_FAILURE);
        }

        syslog(LOG_NOTICE | LOG_USER, "OK, tcpzerbitzaria %i portuan entzuten dago, eskaeren zain. ",PORTUA);


        // zerbitzariaren begizta nagusia
        while (1) {
                bezero_helb_tam = sizeof(struct sockaddr_in);

                // konexio bat onartzen dugu.
                        sock_tmp = accept(zerbitzarisocket, (struct sockaddr*) &bezero_helb, &bezero_helb_tam);

                // konexioan errorerik baldinbadago
                if ( sock_tmp == -1) {
                        syslog(LOG_ERR | LOG_USER, "Errorea konexioa onartzerakoan %s", strerror(errno));
                        exit(EXIT_FAILURE);
                }

                host_entitatea = gethostbyaddr((char *) &bezero_helb.sin_addr, sizeof(struct in_addr), AF_INET);

                syslog(LOG_NOTICE | LOG_USER, "OK, konexio berria : %d",inet_ntoa((struct in_addr)bezero_helb.sin_addr ));

                bufferra = "+OK tcpzerbitzaria, JaKiN ezine LABS\n";
                if (send(sock_tmp,bufferra, strlen(bufferra),0) == -1 ) {
                        syslog(LOG_ERR | LOG_USER, "Errorea datuak bezeroari bidaltzerakoan %s", strerror(errno));
                        errno = 0;
                }
                syslog(LOG_NOTICE | LOG_USER, "OK datuak bidalita: %s", bufferra);



        }


        exit(EXIT_SUCCESS);

}//amaiera


// programaren irteeran exekutatuko den funtzioa
void irteera_atazak(void) {
        // azken mezua pantailarat
        syslog(LOG_NOTICE | LOG_USER,"zerbitzaren exekuzioa gelditu da.");
        // log-a ixten dugu.
        closelog();
        exit(EXIT_SUCCESS);
}

--------------------8<-------------------------------------------------------------

-Martxan dagoenean zerbitzariaren portu irekia ikus dezakegu netstat aginduaren bitartez:

bash# netstat -ln   ( edo  netstat -a)
Active Internet connections (only servers)
Proto Recv-Q Send-Q Local Address           Foreign Address         State
tcp        0      0 0.0.0.0:31337           0.0.0.0:*               LISTEN
tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN
tcp        0      0 0.0.0.0:25              0.0.0.0:*               LISTEN
raw        0      0 0.0.0.0:1               0.0.0.0:*               7
raw        0      0 0.0.0.0:6               0.0.0.0:*               7
Active UNIX domain sockets (only servers)
Proto RefCnt Flags       Type       State         I-Node Path

Hara! hortxe tcpzerbitzariaren marka: 0.0.0.0:31337 LISTEN egoeran. Hots, 31337 tcp portua konexioen
zai daukagu. 

-Zer aterako da syslog-en? (/var/log/messages edo /var/log/user.log fitxategietan)

Apr 12 20:48:24 jakin01 tcpzerbitzaria[395]: OK, tcpzerbitzaria iratxo bihurtu dugu, socketa martxan jarriko dugu..
Apr 12 20:48:24 jakin01 tcpzerbitzaria[395]: OK, tcpzerbitzaria 31337 portuan entzuten dago, eskaeren zain.

-Behin iratxoa exekuzioan dagoenean, konexio saiakera xinple bat egin daiteke makina berdinatik:
(kasu honetan localhostera konektatzen gara)

bash# telnet 127.0.0.1 31337
Trying 127.0.0.1...
Connected to 127.0.0.1.
Escape character is '^]'.
+OK tcpzerbitzaria, JaKiN ezine LABS

Hortik ateratzeko modurik egokiena Ctrl-] erabiltzea da, eta ondoren "quit"

puts("Gaurkoz nahikoa, hurrena arte!");
abort();

					-niuBAI-

</3>


	4. IRC errobota eta Turing-en testa
	__________________________

<4>


Epa!
aspertuta zaude? IRCan ez duzu neskekin ligatzen? hona hemen denborapasa itzel bat: 
IRC errobotak [:|]

Dakizuen moduan, perlekin edozer gauza egin daiteke, eta IRC protokolorako baliabideak ere
badauzka. Ebento edo gertaeretara bideratutako IRC liburutegi dexente bat eskeintzen du, eta
artikulu honetan IRC bezero automatiko bat nola garatzen den ikusiko dugu. Dena den ez pentsa
publizitate edo txapa ematen duen entitatea lortuko dugunik.

IRC errobota eta Turing-en testa
Zein izanen da helburu nagusia? Turing-en testa betetzea. Bueno, test hori pasatzea ezinezkoa da,
baina iraupen on bat lor daiteke. Zer demontre da Turing-en testa? pertsona bat ikusten ez duen
beste entitate batekin komunikatzen da (ordenagailu bitartez adibidez) eta beste aldean makina bat
jartzen bada hizketa egiteko pertsona horrek makina batekin dagoela ez asmatzea (hitz gutxitan).

Gure IRC errobota pertsona normal bat bezala portatzea saiatuko gara. Mmm.. normalak al dira IRCan
ordu pila bat pasatzen dituzten pertsonak? askotan ez, eta horrek gure lana erreztuko du ;)

Errobotak ez du portaera adimentsua edukiko. Horretarako lan handia beharko genuke, lengoai naturalen
prozesamenduan sartu beharko ginateke, eta errobotaren deskribapena ez litzateke hau bezalako testu
fitxategi txiki batean. Horregatik errobotak baldintza + ausazko balioak erabiliko ditu.

Adibidez, pertsona berri bat kanalean sartzen denean zer egingo du errobotak? agurtu?
Errobotaren "arrazonamendua" holako zerbait izango da:

if (pertsona_berria_kanalean(&nick) && ZF(0,7)) {
	hitzegin(ausazko_agurra());
}


Zer esan nahi du ZF(0,7)????
ZF= ziurtasun faktorea da, adimen artifizialetik hartu dugun portaera bat (ez oso formalki). Zera esan nahi du,
errobotan zerbait esango du 0,7ko probabilitatearekin. Kanal batean suertatzen den edozein gertaeraren
aurrean errobotak holako portaera ez-ziurra edukiko du beti. Zergatik? bere portaera beti berdina bada
jendeak errobota bat dela susmatuko duelako. 0'7 balio batekin gehienetan agurtuko du (agur ezberdinekin),
baina EZ BETI.

Bai baina... zer egingo du errobotak orokorrean?
Zera, errobotak gertaeren aurrean "mugitu"ko da soilik: beste norbaitek zerbait esaten duenean, norbait sartzen denean,
pribatu bat bidaltzen diotenean, eta ZF balioak erabiliz portaera hori ez da ziurra izango.

Ze itxura edukiko du kodeak?
Esan bezala IRC liburutegiaren bitartez gertaeretara zuzendutako kodea egin behar da; holako kode estiloa
GUIen programazioan, XMLren azterketan, e.a. erabiltzen da. Gertaerek agintzen dute, IRCn gertatzen diren
ebentoek gure kodea aktibatuko dute. Erreza da, gure ardura bakarra errobotak esaten duena kontrolatzea da.

Ikusagun errobotaren kodea. Errobotaren "adimena" asko erreztu da, zure lana izanen da hau garatzea.
Agian Net::IRC modulua instalatu beharko duzue:
http://search.cpan.org/CPAN/authors/id/J/JM/JMUHLICH/Net-IRC-0.75.tar.gz

-----------------------8<----------------------------------------------------------
#!/usr/bin/perl -w
#
#  Alan Turing IRC errobota
# Net::IRC liburutegiak jeitsi eta instalatzeko:
# wget http://search.cpan.org/CPAN/authors/id/J/JM/JMUHLICH/Net-IRC-0.75.tar.gz
# tar zxfp Net-IRC-0.75.tar.gz;cd Net-IRC-0.75;perl Makefile.PL make && make install

use strict;
use Net::IRC;

## alan_turing.pl
## Regexp Angelorum - Jakin Ezine - 4.alea
##
## IRC konexioa sortzen dugu

my $irc = new Net::IRC;

print "AlanTuring> Gogoratu erabilera \n./alan_turing.pl irc.irc-hispano.org 6666 alantu alantu_user \"#donosti\" \n\n";
print "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n";
print "AlanTuring> IRC zerbitzariarekin konektatzen \n";

# Honekin konexioa burutzen da. Parametroak pasatzen ez badira,
# besterik ezeko balioak hartuko ditu.
my $conn = $irc->newconn(Server   => ($ARGV[0]  ||  'irc.prison.net'),
			 Port     => ($ARGV[1] || 6667),
			 Nick     => ($ARGV[2] || 'AlanTuring'),
			 Ircname  => 'Alan Turing - Jakin Ezine labs www.jakin.tk',
			 Username => ($ARGV[3] || 'alan_turing'))
    or die "Ezin izan dut IRC zerbitzariarekin konektatu \n";

my $kanala = ($ARGV[4] || '#donosti');

###############################################################################
## ESALDI BASEA #
###############################################################################

# Esaera generikoak edozein hizketaldian onargarri direnak
my @generikoa = (
	"hara!",
	"mmm...",
	"bueno",
	"ja",
	"jejeje",
	":)",
	":/",
	"ez dut uste",
	"jur jur",
	"kar kar",
	"ba",
	"ze",
	"juaaas"
	     );

my @galderabat = (
	"Nungoa zara xxx?:ah..",
	"xxx zenbat urte dituzu?: mm benetan, jaja",
	"eta zure adina?:esan ba",
	"xxx erretzen al duzu?",
	"jo xxx ",
	"atxurrakin zaude xxx?",
	"drogarik hartzen al dituzue?: benga egia esan",
	"xxx ikasle/langile?:zer ikasi duzu?",
	"norbaitek txifloak erretzen ditu hemen?:ez dakit ba",
	"xxx erretzen al duzu?",
	"edaten duk xxx?: asko?",
	"nongo zinen xxx?: ez dut ezagutzen",
	"ez zaitez nazkantea izan",
	"porroak gustoko al dituzu xxx ?:bestelako gauzarik?",
	"askotan zaude hemen xxx?"
	);

my @galderak = (
	"Aupa zer moduz?",
	"Bai?",
	"esan?",
	"zer?",
	"bai zer?",
	"nola???",
	"zer da ba?",
	"ze berri?",
	"arazoren bat?",
	"hemen naiz",
	"hementxe gaude",
	"arazorik?",
	"zr",
	"se mua?",
	"zer daukazu?",
	"zer",
	"ze",
	"baina zer da?"
	);

my @agurrak = (
	"Epa",
	"zer moduz",	
	"ongi etorri",
	"agur bero bat",
	"mxak",
	"besarkada bat",
	"Epa epa epa!"
	);

my @bot = (
	"Bai zera","ez hoixe", "ezetz ba", "[:|]"
	);

my @vete = (
	"Ez noala"
	);

##
## Hemen euskarri azpierrutinak

#############################################################
# ON_CONNECT egikarituko da zerbitzarira konektatzerakoan.
#############################################################
sub on_connect {
	my $self = shift;
	
	print "AlanTuring>[OHARRA] $kanala -era konektatzen\n";
	$self->join("$kanala");
	if (&agian() && &agian()) {
		&ausazko_loaldia(2);
		$self->privmsg($kanala, &ausazko_hizkera());
	}
	$self->topic("$kanala");
}


#############################################################
# ON_INIT konektatzerakoan jasotzen den mezua pantailaratzeko
#############################################################
sub on_init {
    my ($self, $event) = @_;
    my (@args) = ($event->args);
    shift (@args);
    
    print "AlanTuring>[OHARRA] @args\n";
}


#############################################################
# ON_PART egikaritzen da norbaitek alde egiten duenean.
#############################################################
sub on_part {
    my ($self, $event) = @_;
    my ($channel) = ($event->to)[0];

    printf "AlanTuring>[OHARRA] -  %s-k %s kanaletik alde egin du \n", $event->nick, $channel;
}

#############################################################
# ON_JOIN egikaritzen da norbait kanalan sartzen denean
#############################################################
sub on_join {
    my ($self, $event) = @_;
    my ($channel) = ($event->to)[0];
    my $mezua;
    printf "AlanTuring>[OHARRA] %s (%s)  %s kanalan sartu da \n",$event->nick, $event->userhost, $channel;

    # pertsona berria agurtu
    if (&agianCF(0.7)) {
     &ausazko_loaldia(3);
     $mezua = &ausazko_agurra()." ".$event->nick;
     $self->privmsg($channel, $mezua);
     print "AlanTuring> ".$mezua."\n";
    }
}

#############################################################
# ON_MSG egikaritzen da mezu probatuak jasotzerakoan
#############################################################
sub on_msg {
    my ($self, $event) = @_;
    my ($nick) = $event->nick;
    my ($arg) = ($event->args);

    my $mezua;
    my @galdera;

    print "[PRIB]$nick>  ", ($event->args), "\n";

    # ausazko zerbait esan
   if (&agianCF(0.3)) {
	sleep(1);
	&ausazko_loaldia(5);
 	$mezua = &ausazko_hizkera();
 	print "AlanTuring [PRIB] $nick> ".$mezua."\n";
	$self->privmsg($nick,$mezua);
    }

     # galdera bat bota
    if (&agianCF(0.3)) {
	sleep(1);
	&ausazko_loaldia(4);
 	$mezua = &ausazko_galderabat();
	$mezua =~ s/xxx/$nick/g;
	@galdera = split /:/,$mezua;
	$self->privmsg($nick,$galdera[0]);
 	print "AlanTuring [PRIB] $nick> ".$galdera[0]."\n";
	if (&agian()) {
		sleep(1);
		&ausazko_loaldia(10);
	 	$mezua = &ausazko_galderabat();
		$mezua =~ s/xxx/$nick/g;
		@galdera = split /:/,$mezua;
		$self->privmsg($nick,$galdera[1]);
	 	print "AlanTuring [PRIB] $nick> ".$galdera[1]."\n";
	}
    }
    
    # norbaitek bot esaten badu...
    if ($arg =~ /bot/i) {       # bot hitza agertu
	if (&agian()) {		
 		&ausazko_loaldia(4);
		my $boterantzun = $bot[rand scalar @bot];
		$self->privmsg($nick,$boterantzun);
	 	print "AlanTuring [PRIB] $nick> ".$boterantzun."\n";
	}
    }

}


#############################################################
# ON_PUBLIC egikaritzen da kanalan zerbait esaten denean
# hauxe da funtziorik erabiliena beti
#############################################################
sub on_public {
    my ($self, $event) = @_;
    my @to = $event->to;

    my ($nick, $mynick) = ($event->nick, $self->nick);
    my ($arg) = ($event->args);
    my $mezua;
    my @galdera;

    
    print "<$nick> $arg\n";
    #Norbaitek BOT nicka aipatzen badu.

    if ($arg =~ /$mynick/i) {          
	    if (&agianCF(0.7)) {
		&ausazko_loaldia(5);
	 	$mezua = &ausazko_galdera();
 		print "AlanTuring> $mezua\n";
		$self->privmsg($kanala,$mezua);
    	}
    }

    # aldegiteko esan
    if ($arg =~ /vete/i || $arg =~ /fuera/i) {       
	 	$mezua = &ausazko_vete();
		&ausazko_loaldia(3);
		$self->privmsg($kanala,$mezua);
 		print "AlanTuring> $mezua\n";
    }


   # bot hitza agertu
   if ($arg =~ /bot/i) {       
	if (&agian()) {		
 		&ausazko_loaldia(4);
		$self->privmsg($kanala,$bot[rand scalar @bot]);
		#$self->privmsg($kanala,&ausazko_bot());
	}
    }


    # zerbait esan
    if (&agianCF(0.7)) {
	&ausazko_loaldia(5);
 	$mezua = &ausazko_hizkera();
	$self->privmsg($kanala,$mezua);
 	print "AlanTuring> $mezua\n";
    }

    # galderak bota
    if (&agianCF(0.8)) {
	&ausazko_loaldia(4);
 	$mezua = &ausazko_galderabat();
	$mezua =~ s/xxx/$nick/g;
	@galdera = split /:/,$mezua;
	$self->privmsg($kanala,$galdera[0]);
 	print "AlanTuring> $galdera[0]\n";	
	if (&agian()) {
		sleep(1);
		&ausazko_loaldia(10);
	 	$mezua = &ausazko_galderabat();
		$mezua =~ s/xxx/$nick/g;
		@galdera = split /:/,$mezua;
		$self->privmsg($kanala,$galdera[1]);
	 	print "AlanTuring> $galdera[1]\n";	
	}
    }
    
}


#############################################################
# ON_NAMES kanalan dauden erabiltzaileen izenak
#############################################################
sub on_names {
    my ($self, $event) = @_;
    my (@list, $channel) = ($event->args);   

    ($channel, @list) = splice @list, 2;

    print "AlanTuring>[OHARRA] erabiltzaileak $channel kanalan: @list\n";
}


#############################################################
# ON_NICK_TAKEN gure ezizena aldatzen du beste norbaitek baldinbadauka
#############################################################
sub on_nick_taken {
    my ($self) = shift;

    $self->nick(substr($self->nick, -1) . substr($self->nick, 0, 8));
}


#############################################################
# ON_DISCONNECT deskonetatzen denean berriz konektatuko da
#############################################################
sub on_disconnect {
	my ($self, $event) = @_;

	print "AlanTuring>[OHARRA] deskonektatuta! ", $event->from(), " (",
	      ($event->args())[0], "). Birkonektatzen...\n";
	$self->connect();
}

#############################################################
# ON_TOPIC kanalaren TOPICa ateratzen dugu
#############################################################
sub on_topic {
	my ($self, $event) = @_;
	my @args = $event->args();

	# Zenbait kasu ezberdinetan egikarituko da hau: sarreran, aldaketak daudenean..

	if ($event->type() eq 'notopic') {
	    print "AlanTuring>[OHARRA] ez dago Topic $args[1] kanalerako.\n";

	# Topic aldaketa dago
	} elsif ($event->type() eq 'topic' and $event->to()) {
	    print "AlanTuring>[OHARRA] Topic aldaketa: ", $event->to(), ": $args[0]\n";

	} else {
	    print "AlanTuring>[OHARRA] $args[1] kanalaren Topic-a \"$args[2]\" da.\n";
	}
}

###################################################################################
###################################################################################
## Ausazko zerbait esate du
sub ausazko_hizkera {   # 
    return $generikoa[ rand scalar @generikoa ];
}

## Ausazko agurra esaten du
sub ausazko_agurra {   
    return $agurrak[ rand scalar @agurrak ];
}

## Ausazko galdera bat hartzen du...
sub ausazko_galdera {   
    return $galderak[ rand scalar @galderak ];
}

## Ausazko galdera bat hartzen du...
sub ausazko_galderabat {   
    return $galderabat[ rand scalar @galderabat ];
}

## Ausazko komentarioa vete hitzari
sub ausazko_vete {   
    return $vete[ rand scalar @vete ];
}

## Ausazko komentarioa bot hitzari
sub ausazko_bot {   
    return $bot[ rand scalar @bot ];
}


my $VALUE = 45632;


## agian: agian exekutatu zerbait hala ez.
## 0 ala 1 itzultzen du
sub agian () {
 	my $val = rand($VALUE);
  	return (int(rand($val)) % 2);
}

## agianCF
## 0 ala 1 itzultzen du, zirutasun faktore baten arabera
## posibilitatea doitzeko modua. %10, %20, %30...
sub agianCF () {
 	my $val = $_[0]; # 0.1, 0.2, 0.3, 0.4, 0.5 ... 0.9.
	$val *= 10;
  	return (int(rand(10)) > $val);
}

### ausazko_loaldia: itxoite denbora ez finkoa.
## honekin denbora hutsuneak eragiten ditugu, errobota azkarregia izan ez dadin
sub ausazko_loaldia () {
 	my $val = ($_[0] || 3);
  	sleep(int(rand($val)));  	
}


##
## Hemendik doa egikaritze hasiera.
##

## Egiten dugun lehenengo gauza euskarri azpierrutinak dira

print "AlanTuring> euskarri azpierrutinak instalatzen... ";

$conn->add_handler('msg',    \&on_msg);
$conn->add_handler('public', \&on_public);
$conn->add_handler('join',   \&on_join);
$conn->add_handler('part',   \&on_part);
$conn->add_handler('topic',   \&on_topic);
$conn->add_handler('notopic',   \&on_topic);

$conn->add_global_handler([ 251,252,253,254,302,255 ], \&on_init);
$conn->add_global_handler('disconnect', \&on_disconnect);
$conn->add_global_handler(376, \&on_connect);
$conn->add_global_handler(433, \&on_nick_taken);
$conn->add_global_handler(353, \&on_names);

print " OK - egina.\n";

print "\n";

$irc->start;


--------------------8<-------------------------------------------------------------

Ze erabilpen ditu honek? gizarte ingeniaritza gehien bat. Errobotaren portaera helburu batetara zuzendu daiteke,
adibidez pasahitzak edo email helbideak lortzeko. Jendeak bere datuak ematen ditu, ikaragarria da.

Dena den kode hori asko hobetu daiteke, esaldi gehiago asma daitezke, e.a. luze bat. Lan hori zuentzat.

Esan bezala, errobotaren funtzionamendua gertaeren menpe dago eta horrek zera suposatzen du: jende asko
dagoen kanaletan zoratuko da. Kopuru egoki bat 60 pertsona dira, ez gehiago. Gomendio bat: neska
izenakin sar ezazue, ikusiko duzue zenbat pribatu heltzen zaizkion (deskojonoa hi!).

Eta hemendik zera proposatzen dut. Garatu kode hau eta Ekainak 24an #donosti/bilbao kanalean sartu zuen errobota,
eta bertan ikusiko gara.

Bide batez... ez al dakizu nor den Alan Turing? informa zaitez, pena merezi baitu. Informatikak
asko zor dio maritxu horri. Aurten bere heriotzaren 50 urte bete dira. Programatzen bego. 

\QUIT
					-Regexp Angelorum-

</4>


	5. Sistema adituak
	__________________________

<5>

1956an Darmouth College-en emandako hitzaldi batean "Adimen Artifiziala" aurkeztu zen. Adimen Artifiziala
informatika bera bezain "zaharra" dela esan daiteke. Ordundik Adimen Artifiziala esparru teoriko eta teknikoeta
garatzen hasi zen lengoai bereziak (LISP, Prolog), tresnak eta sistemak (CLIPS) sortuz. Eremu ezberdintan
banatu zen: sistema adituak, lengoai naturalen prozesamendua, ikusmena, arazoen ebazpena, tutore sistemak,
eta abar luze bat. 

Adimen Artifizialaren inguruan itxaropen ikaragarriak zeuden eta krisialdi garaia ere ezagutu zuen. Historia behin
eta berriro errepikatzen da eta Internet garaiarekin analogi egin daiteke kasu honetan. Krisialdiaren ondoren
bere neurria hartu zuen eta egun uste baino leku gehiagotan topa dezakegu. 

Noizbait pentsatu ahal duzue nork diseinatzen dituen zirkuitu inpresoen bide ordenatuak?
Nola erabakitzen dira logistika munduan bideratze optimoak?
Nork egiten du gure gaixotasunen diagnosia? ;)
Nola erabakitzen du zuen garbigailuak erabili behar duen ur kopuru eta tenperatura?

Adimen Artifizialak karrera berezia beharko luke, matematika, psikologia, informatika eta agian filosofia
ere jorratu beharko zuena...

Sistema Adituak.
Gaurkoan sistema adituetaz arituko gara. Sistema adituak pertsona aditu bat ordezkatzen saiatzen den sistema
da. Sistema aditu bat eraiki dugu. Zer pausu jarraitu behar ditugu?

Adi! utzi emacs editorea eta cvs-a alde batean. Sistema adituen garapenak ez du zerikusirik sistema arrunten
garapenarekin. Bien arteko ezberdintasuna ikusita hau errez ikusiko duzue:
(informatika ikasleek hau ongi ezagutuko duzue, Pikaza Atxa jauna da gure iturria)

Programazio arrunta     =/=      Sistema adituak
-------------------------------------------------
- Emaitza zehatzak ematen ditu =/=  Azalpenak, eritziak, gomendioak ematen ditu
- Informazio zehatza darabil  =/=   Ziurgabetasunean mugitzen da
- Programan informazioa eta kontrola integratuta  =/= Ezagutza eta kontrola banaturik
- Zenbakiak erabiltzan ditu    =/=      Sinboloak erabiltzen ditu
- Algoritmikoak dira   =/=  Heuristikoak
- Agindu interfazea  =/=  Lengoai naturala
- Soluzio hobezina  =/= Soluzio onargarriak

Bueno, berez Sistema aditu baten garrapenak beste sistemen pauso antzekoak jarrai ditzake baina funtsezko
pauso berri bat azaltzen da analisi eta diseinu artean:

 1.ANALISIA <---------------------------|
         \                              |
   2.JAKINTZAREN LORPENA <---------|    |   Hauxe da pausu nagusia! Aditu baten jakintza lortzea
           \                       |    |
       3.DISEINUA <----------------|    |
             \                     |    |
          4.TESTAK ----------------|    |
               \                        |
            5.DOKUMENTAZIOA             |
                 \                      |
              6.MANTENIMENDUA ----------|

Jakintza lortzeaz gain horren errepresentazio sistematiko bat lortu behar da. Gai luzea da, orain ez gara horretan sartuko.
Sistema Aditu baten mekanismoa holakoa da:

 _____________________
| JAKINTZA BASEA      |             Jakintza basean ezaguera GUZTIA dago, jakintza erregelen bitartez
| ------------------  |             errepresentatuta egoten da. Hola itxura dute erregelek:
| Domeinu zehatzaren  |              Baldin portu_irekia(x,69) => Zerbitzaria(x,DHCP)
| jakintza            |              Baldin portu_irekia(x,23) => Routerra_da(x)
|_____________________|
   |\
     \
     _\|__________________             _______________
    | INFERENTZI MOTOREA  |           | Erabiltzailea |
    |                     |  <------> |-------------- |
    |_____________________|           | Sarrera       |
         /|                           | Ondorioak     |
        /                             |_______________|
 _____|/______________
| LAN MEMORIA         |
| ------------------  |             Lan memoria gure ordenadorearen RAM memoriaren antzeko zerbait da
| Hasierako egiak     |             arrazonamendua egiten direnenean bertan gordetzen dira inplikatuta
| Inferentziak        |             dauden erregeleak egitateak, e.a...
| Ondorioak           |
|_____________________|

Eta zer egiten du Inferentzi Motoreak??
Gauza oso xinplea: lan memorian dauden egitateak aztertzen ditu eta Jakintza Basearekin parekatzen ditu.
Egitate batek erregela bat aplikatzea ekartzen du eta horrek egitate berriak,ebazpenak edo emaitzak sortzen ditu.
Guztien artean arrazonamendu makina bat osatzen dute. Adibidez demagun Jakintza base xinple hau daukagula:

      JAKINTZA BASEA
              Baldin portu_irekia(x,69) => Zerbitzaria(x,DHCP)
              Baldin portu_irekia(x,23) => Routerra_da(x)
              Baldin portu_irekia(x,445) => Windows_da(x)
      LAN MEMORIA
	      portu_irekia(x,69), portu_irekia(x,445)
	
Kasu honetan inferentzi motoreak LAN MEMORIAKO egitateak JAKINTZA BASEAN dauden erregelekin parekatzen saiatuko da
eta ondorio honetara heltzen da:
		x windows bat da eta DHCP zerbitzaria gainera.

Arrazonamendua bi zentzutan egin daiteke (Forward chaining eta BAckward chaining): kasu honetan aurreranzko kateaketa
erabili da, baina atzeranzka ere egin daiteke.	
      LAN MEMORIA
	      Windows_da(x), Zerbitzaria(x,DHCP)
Emaitza:
		portu_irekia(x,445) eta portu_irekia(x,69)

Ziurra al da emaitza hori? ez du zertan egia izan behar, baina horretarako ziurtasun faktoreak eta balio lausoak
erabil daitezke:
		portu_irekia(x,445,0'7) eta portu_irekia(x,69,0'9)
Hots, X windows bada eta DHCP zerbitzua irekia baldinbadauka 445 portua irekia dago %70 probabilitatearekin eta 69 portua
ere irekita dago 90%ko probabilitatearekin.


Sistema aditu baten adibide bat nahi duzue? Nessus hurbilpen bat da. Nessus segurtasun auditoriak egiten ditu, nolabait
hacker baten jakintza dauka eta pausu berdinak jarraitzen ditu. Emaitza bezala txosten luzea ematen du zenbait gomendio
zehatzekin. Nmap ez da horren aditua, baina Sistema eagileen asmakuntzan eta TCP sekuentziekin aditu bezala portatzen
da.

Sistema adituak edozein eremutan sor daitezke, baina kontuz, arrakastatsuak izateko komenigarria da eremu edo domeinu
txikietatik ez urruntzea. Adibidez pertsona oso bat modelatzen duen sistema aditua ia ezinezkoa da; modulutan banatu
behar da. Beraz ideiaren bat baduzue saiatu jakintza xinpleak modelatzen.

Aizu, nazkatuta nago zure txaparekin. Gauza praktikoak nahi ditut arren. kodea orain!

Ongi da. Sistema adituen garapenerako tresnak badituzue jada. Behe mailatik hasiko gara: prolog, perl, eta noski LISP.
Ondoren goi mailako lengoaiak: smalltalk, c++ eta CLIPS. Eta ingurune euskaldun bat ere badago, unibertsitatean garatuta:
EHSIS (CLIPS  da azken finean). 
LISP bezalako lengoaiak ez dira errezak programazio prozedurala besterik ezagutu ez dutenendako. Programazio funtzionala
egin behar da, non prozeduren garapenik ez dago, bakarrik programen deklarazioa ikusten da (definizio formal baten antzeko
zerbait). Agian LISP oso "behe mailakoa" da hasiberrientzat, horregatik CLIPS gomendatuko nuke. 
Bai, horrelaxe instala dezakezue:

debian@etxean# apt-get install clips 

Jarraipena hurrengo alean...

baldin atera(0,7) => exit();
					-Assert-

</5>



	6. Interneten funtzionamendua: BGP
	__________________________

<6>

Eup.
Aurreko Jakinean Internet sarearen funtzionamendu orokorraz hitzegin genuen batez ere
sarearen "enborran" zentratuz. Internet AStaz osatuta dago eta beraien artean protokolo baten
bitartez ulertzen dira: BGP edo Border Gateway Protocol

Internet puska hauxe erabiliko dugu adibide gisa.
      ___                                    ___                       
     /   \                                  /   \                      
    | SA6 |        <---- BGP ---->         | SA2 |                    
     \___/                                  \___/                     
     16.6.0.0/16                            12.2.0.0/16
     166.66.0.0/16                          22.22.2.0/17
     66.6.0.0/16

Komunkazioak BGP ulertzen duten routerren artean sustatzen da. BGP tcp/179 portua erabiltzen duen zerbitzua
besterik ez da, pauso zehatz batzuk jarraitzen dituena BGP sesioa (lotura bat) irekitzeko. 

    ___                                    ___                       
   /   \                                  /   \                      
  | SA6 |                                | SA2 |
   \___/                                  \___/ 
Egoera: Idle                            Egoera: Idle

Beraz BGP lotura bat lortzeko bi puntuak internetera konektaturik eta up (piztuta alegia) egon behar dute 
eta BGP portua ireki behar dute. Sesioa edozein norabidetan has daiteke:
    ___                                    ___                       
   /   \                                  /   \                      
0.| SA6 |                                | SA2 |
   \___/                                  \___/ 
Egoera: Active                        Egoera: Active

    ___                                    ___                       
   /   \                                  /   \                      
1.| SA6 | --->  OPEN mezua bidali --->   | SA2 |
   \___/                                  \___/ 
Egoera: OpenSent                      Egoera: Active

Non open mezuan zera dagoen:
-BGP bertsio zenbkia: proposatzen den protokolo bertsio. Egun gehienek BGP 4 erabiltzen dute.
-Router ala dispositiboaren AS zenbakia: Esan bezala, AS bakoitzak zenbaki bat dauka esleituta 1-64511 tartean.
 Zer gertatzen da 64512-65535 bitartearekin? BGP pribatua (ala internal BGP) egiteko. (192.168.0.0 IP helbideak bezalaxe).
-Hold time: BGP komunikazio bizia da, honekin adierazten da mezu bakoitzaren artean pasa daitekeen segundu kopuru
 maximoa. Denbora hori pasatzen bada, BGP sesioa bukatutzat jotzen da. Sesioa buka ez dadin mezu bereziak
 bidaltzen dira sesioa mantentzeko; asmatzen al duzue mezu horien izena? bai noski, nire ezizena bait da: keepalive.
 Bi routerrak ados jarriko dira baliorik bajuena erabiltzeko.
-BGP makinaren identifikazioa: router ala dispositiboak identifikadore bat asmatzen du bere IP helbidean oinarrituta
-Aukerazko parametroak: mota, luzera, sesio kautotzea. 

    ___                                    ___                       
   /   \                                  /   \                      
2.| SA6 | <---  OPEN mezua itzuli <---   | SA2 |
   \___/                                  \___/ 
Egoera: OpenConfirm                    Egoera: OpenSent

SA2 routerrak open mezua bidaltzen du ere bere balioekin; SA6k balio horiek aztertzen ditu eta onargarritzat
jotzen baditu konfirmazioa bidaltzen dio keepalive batekin.

    ___                                    ___                       
   /   \                                  /   \                      
3.| SA6 |    --->  keepalive --->        | SA2 |
   \___/                                  \___/ 
Egoera: Established                    Egoera: Established


BGP p2p motako komunikazioa da. Ez Antxon ez, horrek ez du esan nahi divx-ak elkarbanatzen dituztenik. Peer to peer
esaldiak esan nahi duena da bi muturrak berdintsuak direla, ez dela bata bestea baino gehiago, ez dela bezero-zerbitzari
paradigmaren kasua.
Behin sesioa hasi denean, BGP makinak bere informazioa trukatzen dute: bere sarearen informazioa da, ip sareak eta bideratzeak.
SA edo Sistema autonomo bakoitzak bere sare egitura aldatzen duenean, bere BGP routerrak aldaketa horien berri emango dio
bere BGP BIZILAGUNEI, eta ondorioz interneteko BGP ROUTER GUZTI GUZTITAN informazioa zabaldauko da berehala. Bai. Hala da.
BGP router batean interneteko helbideratze guztiak daude.

    ___                                    ___                       
   /   \                                  /   \                      
4.| SA6 |    <--->  egunerketak <--->    | SA2 |
   \___/            keepalive             \___/ 


Zer ikusiko genuke SA6ren BGP routerran?
Demagun SA6 SA2 eta SA5 ekin sesioa irekita daukala.

SA6-BGP# sh ip bgp summary
BGP taula - (C) zisko - lizartza
Bizilaguna      AS    MsgRcvd    MsgSent     TblVer    InQ  OutQ     Up/Down   State/PFXRecv
12.2.0.1        222      14         15          10      0    0       0:02:32     27
15.5.0.1        555      11         11          7       0    0       0:00:49     23

Hortxe aurkezten dira BGP sesioak eta bere balioak: auzokidearen helbidea, AS identifikazioa, jasotako eta bidalitako
mezu kopurua, itxaroten dauden irteera/jasoera mezuak (Inqueue/outqueue), zenbat denboraz egon den sesioa, eta interesgarriena
Taularen bertsioa: horren bitartez BGPk jakin dezake bere helbideratze datuak eguneratuta dauden hala ez; BGP router bakoitzak
taula zenbaki ala bertsio bat mantentzen dute, eta bertsio hori bere BGP bizilagunei jakinarazten die. SA6ren taulan balioren
bat aldatzen bada taula bertsio zenbaki inkrementatzen da; ondoren bere bizilagunei egindako aldaketak eta taula zenbaki
berria bidaltzen da. Kontutan hartu komunikazio horiek bi zentzutan egingo direla beti.

Aizu! badakit maltzurrak zaretela. Zer gertatzen da BGP router batean sartzen bazarete intentzio txarrekin?
Internet-en kriston "cisco"a sortu daiteke BGP router bat gaizki erabiltzen bada. Bideratzen faltsuak sar daitezke eta
komunikazio guztiak zulo beltzetara eraman daitezke. Nola topatu BGP routerrak? tcp/179 portuak bilatzen dituen
errobota erabil daiteke, baina tira, lan hori Regexp Angelorumi utzi egingo diogu.

BGP ez da protokolo segurua. Momentuz mekanismo xinple bat badauka segurtasun pixka bat gehitzeko: MD5 kautotzea.
Sesioa hasten denean aukera hori erabili daiteke. Izan ere sistema hau geroz eta gehiago erabiltzen da BGP router
kudeatzaileen artean.


BGP zuen Debian-ean praktika dezakezue. Bai mutil, BSD-n baita ;)
Izan ere linux-erako inplementazio ikaragarri ona dago: zebra. Zebrak protokolo asko ezagutzen ditu
eta Cisco router bat bezala erabiltzen da (shell berezia, e.a.); sintaxia ikasteko ere ongi dator, berdina
baita. Eta badakigu jakin, zenbait gune profesionaletan router garestiak erabili ordez linux makinak erabiltzen
direla. 

Operadoreen arteko komunikaziotan E1, E3, STM1 bezalako interfazeak erabiltzen dira, koaxialak, rj-45 itxurakoak,e.a. 
izan daitezkeenak. Agian txartel guzti horiek ez daude linuxerako erabilgarriak, baina zenbait egoeratan ethernet
erabili daiteke zuzenean eta Cisco garesti bat erabili ordez Linux-kaxa bat jar daiteke. 
beno, beste baten jarraitzen dugu.

adio!

MConnect-BGP-Bi# write mem
MConnect-BGP-Bi# reload

					-keepalive-

</6>



	7. Kultura
	__________________________

<7>


Titulua: Neuromancer (a.k.a. Neuromante)
Egilea: William Gibson
http://www.williamgibsonbooks.com/ Web gune ofiziala
http://lib.ru/GIBSON/neuromancer.txt (hara, erreza da hortik topatzea)

Hona hemen Neuromancer, William Gibson-en libururik ezagunena eta "ziberkulturaren" lanik esanguratsuena
inongo zalantzarik gabe. Berak erabili zuen lehen aldiz ziberespazio hitza etorkizunaren aurreikusle bihurtu
delarik (Julio Verneren antzera).

Gibsonen liburuan etorkizunean kokatzen gaitu, non mundua teknologia, sareak eta korporazio handien menpe dagoen.
Case izeneko protagonista "cowboy" edo hacker ikaragarri ona da eta sistema konplexu batean sartzea behartuko dute.
Horretarako cyborg neska eta besteleko pertsonaien laguntza eukiko du. Case ziberespaziora zuzenean konektatzen da
kableen bitartez, eta bertan bizi diren pertsonekin komunika daiteke; datuak izotza bezala aurkezten dira, eta 
birusak erabiltzen ditu sistemetan sartzeko. Altxorrik preziatuenak adimen artifizialdun sistemak dira... 
mundu teknologiko korapilatsu batean murgiltzen gaitu azken finean.

Askotan irakurketa zaila egiten da, eta baita ulergaitza ere; izan ere Gibsonek gustoko du modu ilunean idazten,
horregatik zenbait pasarte arraro xamar irudituko zaizkio irakurle sufrituari.

Gibsonen lana hobeto ulertzeko eta kontestualizazio egoki bat edukitzeko oso gomendagarri da "Are you Ciberpunk"
hitzaldia entzutea. Iruñeko hackmeeting-ean eman zen eta sarean eskuragarri daukazue (ftp bitartez eta edk bitartez ere).
Helbide ezagun honetan aurkituko dituzue behar diren esteka guztiak: http://www.sindominio.net/hackmeeting

Bada baita Gibsonen unibertsoan oinarritzen den film ezagun bat: Johnny Mnemonic, non keanu Reeves-ek Matrix-en
beteko zuen betebeharraren aurrerapen bat ematen duen nolabait.



					-km-
</7>


	8. Estekak,Oharrak,Agurrak
	__________________________

<8>

Nahikoa oraingoz! pixkanaka joan beharko ezta?
Hala ere 5.alerako zenbait ideia dauzkagu, adi egon! Hemendik aurrera indymedia bezalako guneen bitartez emango
dugu lehen oharra. Zuen iradokizunak espero ditugu.

Hurrengo alean Jakin-etik ateratako proiektu baten berri emango dugu: Jakin OS banaketa.
http://jakin.sourceforge.net gunean eskuragarri duzue. Ez da beste munduko gauza, ikasketa prozesuan beste pauso
bat besterik ez da.


Hackmeeting!
Hackmeeting-eko zerrendatik berri bat dator: aurtengo bilgunea Sevillan izango da: Hackandalus2004!
Hispaliseko zentruan bertan ibiliko gara. Ohi denez iraila bukaera inguruan edo urriaren hasieraldera izango da.
Hemendik aurrera denbora daukazue hitzaldiren bat eskeintzeko, proposamenak emateko.. e.a. Informazioa
gehiago ohizko helbidean:
http://sindominio.net/hackmeeting/

Ez ahaztu hauexek direla ezinearen helbideak:

http://www.jakin.tk/
http://jakinezine.galeon.com/
http://jakin.sourceforge.net/

Eta email helbideak:
jakin@mailbox.co.za
jakin@kaixo.com

CALL FOR PAPERS!!!
Zeren zain zaude? gai asko dauzkagu hitzegiteko: ASM, aribako sareak, spectrum :), algoritmo genetikoak, matematikak,
gai sozialak, hacktibismoa, hacker taldeak, istorioak, albisteak, proiektuak... Anima zaitezte!
Ez du garrantzirik gaiak errepikatzen badira, jasotzen duguna ongi-etorria izango da beti.

Hurrengo aleari begira zenbait ideia ditugu prestaturik. Adi egon!

<Oharra>
Jakin ezinea ez da ikurleek bere kodeaz egiten duten erabileraren arduradun. Fanxinaren helburu bakarra
informatika teknikak erakustea da, dokumentaziotan, interneten, edonon dagoen informazioa modu ulerkor
batean laburtzea azken finean. Ohar tipiko hau sartzea beharrezkoa EZ dela deritzogu, baina badazpada
hemen da.
</Oharra>
					-edit-

</8>

</jakin>
